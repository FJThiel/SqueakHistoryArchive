'From Squeak 2.1 of June 30, 1998 on 30 June 1998 at 11:08:24 pm'!!AcceptableCleanTextMorph methodsFor: 'all' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 23:09'!byteReverseForm: aForm	"Byte-reverse the words of the given Form's bitmap. Supports porting a Squeak image to the Acorn."	| bits mask pixelDepth dstWord srcWord srcPix nPix |	(aForm isKindOf: Cursor)		ifFalse:[aForm unhibernate].	bits _ aForm bits.	pixelDepth _ aForm depth.	nPix _ 32 // pixelDepth.	1 to: bits size do: [:i |		srcWord _ bits at: i.		mask _ (1 << pixelDepth) - 1.		dstWord _ 0.		1 to: nPix do: [:p|			srcPix _ srcWord bitAnd: mask.			srcWord _ srcWord >> pixelDepth.			dstWord _ ((dstWord << pixelDepth) bitOr: srcPix)].		bits at: i put: dstWord].	(aForm isKindOf: Cursor)		ifFalse:[aForm hibernate]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:48'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	On Acorn, the test is whether systemAttribute 1001 = 'RiscOS' (on newer VMs) or if the primPathNameDelimiter is $. (on older ones), which is what we would like to use for a dirsep if only it would work out. See pathNameDelimiter for more woeful details - then just get on and enjoy Squeak"	| attr |	attr _ Smalltalk getSystemAttribute: 1001.	attr isNil ifFalse:[^attr = 'RiscOS'].	^self primPathNameDelimiter = $.! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/10/1998 21:45'!pathNameDelimiter"Acorn RiscOS uses a dot as the directory separator and has no real concept of filename extensions. We tried to make code handle this, but there are just too many uses of dot as a filename extension - so fake it out by pretending to use a slash. The file prims do conversions instead.Sad, but pragmatic"	^ $/! !!AssignmentTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: ' assign', (assignmentSuffix copyWithout: $:), 'Getter: #'.	aStream nextPutAll: (Utilities getterSelectorFor: assignmentRoot).	aStream nextPutAll: ' setter: #'.	aStream nextPutAll: (Utilities setterSelectorFor: assignmentRoot).	aStream nextPutAll: ' amt: '.! !An asynchronous file allows simple file read and write operations to be performed in parallel with other processing. This is useful in multimedia applications that need to stream large amounts of sound or image data from or to a file while doing other work.!!AsyncFile methodsFor: 'all'!close	fileHandle ifNil: [^ self].  "already closed"	self primClose: fileHandle.	Smalltalk unregisterExternalObject: semaphore.	semaphore _ nil.	fileHandle _ nil.! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 07:54'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name _ fullFileName.	writeable _ aBoolean.	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	fileHandle _ self primOpen: name forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil.		^ nil].! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 08:28'!readByteCount: byteCount fromFilePosition: fPosition onCompletionDo: aBlock	"Start a read operation to read byteCount's from the given position in this file. and fork a process to await its completion. When the operation completes, evaluate the given block. Note that, since the completion block may run asynchronous, the client may need to use a SharedQueue or a semaphore for synchronization."	| buffer n |	buffer _ String new: byteCount.	self primReadStart: fileHandle fPosition: fPosition count: byteCount.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primReadResult: fileHandle intoBuffer: buffer at: 1 count: byteCount.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].		aBlock value: buffer.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 10:07'!test: byteCount fileName: fileName	"AsyncFile new test: 10000 fileName: 'testData'"	| buf1 buf2 bytesWritten bytesRead |	buf1 _ String new: byteCount withAll: $x.	buf2 _ String new: byteCount.	self open: fileName forWrite: true.	self primWriteStart: fileHandle		fPosition: 0		fromBuffer: buf1		at: 1		count: byteCount.	semaphore wait.	bytesWritten _ self primWriteResult: fileHandle.	self close.		self open: fileName forWrite: false.	self primReadStart: fileHandle fPosition: 0 count: byteCount.	semaphore wait.	bytesRead _		self primReadResult: fileHandle			intoBuffer: buf2			at: 1			count: byteCount.	self close.	buf1 = buf2 ifFalse: [self error: 'buffers do not match'].	^ 'wrote ', bytesWritten printString, ' bytes; ',	   'read ', bytesRead printString, ' bytes'! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 17:28'!writeBuffer: buffer atFilePosition: fPosition onCompletionDo: aBlock	"Start an operation to write the contents of the buffer at given position in this file, and fork a process to await its completion. When the write completes, evaluate the given block. Note that, since the completion block runs asynchronously, the client may need to use a SharedQueue or a semaphore for synchronization."	| n |	self primWriteStart: fileHandle		fPosition: fPosition		fromBuffer: buffer		at: 1		count: buffer size.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primWriteResult: fileHandle.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].		n = buffer size ifFalse: [^ self error: 'did not write the entire buffer'].		aBlock value.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:42'!primClose: fHandle	"Close this file. Do nothing if primitive fails."	<primitive: 540>! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:54'!primOpen: fileName forWrite: openForWrite semaIndex: semaIndex	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise."	<primitive: 541>	^ nil! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:28'!primReadResult: fHandle intoBuffer: buffer at: startIndex count: count	"Copy the result of the last read operation into the given buffer starting at the given index. The buffer may be any sort of bytes or words object, excluding CompiledMethods. Answer the number of bytes read. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 542>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:36'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 543>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:27'!primWriteResult: fHandle	"Answer the number of bytes written. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 544>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 08:35'!primWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: startIndex count: count	"Start a write operation of count bytes starting at the given index in the given buffer. The buffer may be any sort of bytes or words object, excluding CompiledMethods. The contents of the buffer are copied into an internal buffer immediately, so the buffer can be reused after the write operation has been started. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 545>	writeable ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!AsyncFile class methodsFor: 'class initialization' stamp: 'jm 6/25/1998 17:33'!initialize	"AsyncFile initialize"	"Possible abnormal I/O completion results."	Busy _ -1.	Error _ -2.! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 6/22/1998 14:15'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| fName |	super restore: nameOfSwiki.	fName _ ServerAction serverDirectory, name, (ServerAction pathSeparator), 				'authorizer'.	(FileDirectory new fileExists: fName) ifTrue: [		authorizer _ (FileStream oldFileNamed: fName) fileInObjectAndCode].! !A minimalist button-like object intended for use with the tile-scripting system.!!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 17:02'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label...' action: #setLabel.! !!BasicButton methodsFor: 'all' stamp: 'sw 6/29/1998 20:57'!initialize	super initialize.	self borderWidth: 1.	self borderColor: Color yellow darker.	self color: Color yellow.	self label: 'Button'! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:49'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:53'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ aFont		ifNil:			[StringMorph contents: aString]		ifNotNil:			[StringMorph contents: aString font: aFont].	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!BasicButton class methodsFor: 'all' stamp: 'sw 6/16/1998 16:58'!defaultNameStemForInstances	^ 'button'! !!Behavior methodsFor: 'copying' stamp: 'sw 6/16/1998 15:15'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ methodDict copy! !I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMapThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'copying' stamp: 'di 6/29/1998 20:27'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	self primitiveFailed  "Later do nicer error recovery"! !This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'di 6/30/1998 11:13'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 33]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/29/1998 12:19'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/30/1998 11:43'!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/29/1998 12:27'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 18:05'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:45'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	"Check for degenerate shift values 4/28/97 ar"	sourcePixSize = 32 		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:44'!warpLoop	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:08'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:09'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:55'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 00:29'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5]		ifFalse: [bitsPerColor _ 8].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:56'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 16:41'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5.  rgbMask _ 16r1F]		ifFalse: [bitsPerColor _ 8.  rgbMask _ 16rFF].	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff _ 0]							ifFalse: [diff _ 1]]				ifFalse: [diff _ (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff _ (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount _ bitCount + diff].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 11:27'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	pixMask _ (1<<destPixSize) - 1.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'translation support' stamp: 'di 6/30/1998 11:12'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/29/1998 23:24'!initialize	"BitBltSimulation initialize"  	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/30/1998 11:11'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!Bitmap methodsFor: 'filing' stamp: 'di 6/17/1998 12:20'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 7936 or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 7936 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 + (S//7936*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 5 + (self size//7936*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!BlockContext methodsFor: 'evaluating' stamp: 'tk 6/24/1998 15:32'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver. If an error occurs the given is evaluated with the error message and the receiver as parameters. The error handler block may return a value to be used if the receiver block gets an error. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | ^ 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'division by 0' = err				ifTrue: [^ Float infinity]				ifFalse: [self error: err]]"	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ errorHandlerBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive]		priority: Processor activePriority! !!BookMorph methodsFor: 'initialization' stamp: 'sw 5/31/1998 00:40'!addDressing	| controlColor pageControls |	self addMorph: (Morph new color: color; extent: 0@10).  "spacer"	controlColor _ (color saturation > 0.1)		ifTrue:			[color lighter]		ifFalse:			[color darker].	pageControls _ Preferences noviceMode		ifTrue:			[self makeKidsPageControlsColored: controlColor]		ifFalse:			[self makeAuthoringPageControlsColored: controlColor].	pageControls borderWidth: 1; inset: 4.				self addMorph: pageControls! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/31/1998 00:04'!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: evt cursorPoint) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!BookMorph methodsFor: 'menu' stamp: 'tk 6/11/1998 17:46'!deletePage	| message |	message _ 'Are you certain that youwant to delete this page and all its morphs?'.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'menu' stamp: 'tk 6/11/1998 17:42'!deletePageBasic	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].! !!BookMorph methodsFor: 'menu' stamp: 'tk 6/14/1998 14:26'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil: [			newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'private' stamp: 'tk 6/17/1998 16:16'!makePageControls	| b c r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	c _ AlignmentMorph newColumn.	c color: b color; borderWidth: 0; inset: 0.	c hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<-';			actionSelector: #previousPage).	r addMorphBack: (b fullCopy label: 'Insert';		actionSelector: #insertPage).	r addMorphBack: (b fullCopy label: 'Delete';		actionSelector: #deletePage).	r addMorphBack: (b fullCopy label: 'Text';		actionSelector: #newTextMorph).	r addMorphBack: (b fullCopy label: '->';			actionSelector: #nextPage).	c addMorphBack: r.	r _ r copy removeAllMorphs.	r addMorphBack: (b fullCopy label: 'Bookmark';	actionSelector: #bookmarkForThisPage).	r addMorphBack: (b fullCopy label: 'Save';		actionSelector: #saveOnFile).	c addMorphBack: r.		^ c! !!BookMorph class methodsFor: 'all' stamp: 'sw 5/13/1998 11:43'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color r: 0.9 g: 0.9 b: 0.9).	book borderWidth: 1; borderColor: Color black.	book addDressing; insertPage.	^ book! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 6/25/1998 10:10'!computeThumbnail	| f scale |	f _ page imageForm.	page fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!BooleanScriptEditor methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	((submorphs size > 0) and:	 [submorphs first submorphs size > 0]) ifTrue: [			aStream nextPutAll: '(('.			super storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ') ~~ false)'.			^ self].	aStream nextPutAll: ' true '.! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:55'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(borderColor isColor and: [borderColor alpha < 1.0]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:25'!areasRemainingToFill: aRectangle	color isTransparent ifTrue: [^ Array with: aRectangle].	borderWidth = 0		ifTrue: [^ aRectangle areasOutside: self bounds]		ifFalse: [(borderColor isColor and: [borderColor isTransparent])					ifTrue: [^ aRectangle areasOutside: self innerBounds]					ifFalse: [^ aRectangle areasOutside: self bounds]]! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' action: #startInfection.	aCustomMenu add: 'set atom count' action: #setAtomCount.	aCustomMenu add: 'show infection history' action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString _ FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph _ GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection _ false.		self stopStepping].! !!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'class functions' stamp: 'di 6/2/1998 13:58'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName |	oldClass _ self selectedClassOrMetaClass.	newClassName _ (defString findTokens: Character separators) third copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [Smalltalk includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	oldClass ifNil: [oldClass _ Object].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!Browser methodsFor: 'message functions' stamp: 'di 5/27/1998 15:45'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.  "In case organization not cached"	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!extent	^ Display extent! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'testing' stamp: 'jm 5/30/1998 21:10'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:59'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self		image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:48'!line: pt1 to: pt2 brushForm: brush	"Noop here; overridden by non-trivial canvases."! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/12/1998 16:33'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:40'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window listView |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: (listView _ PluggableListMorph on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3)."	multiSelect ifTrue: [listView controller: PluggableListControllerOfMany new]."	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:02'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:<Comments here, if any>Executable statements after this comment quote..."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'wod 5/12/1998 18:27'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	"wod 5/12/1998: use #asFileName rather than #truncateTo:"	| file slips |	Cursor write showWhile: [		file _ FileStream newFileNamed:			(self name, FileDirectory dot, Utilities dateTimeSuffix, FileDirectory dot, 'cs') asFileName.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	Preferences suppressCheckForSlips ifTrue: [^ self].  "Can hard-code that pref if desired"	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcript in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'References to #halt or Transcript']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 14:34'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: 'Your Name'.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'accessing' stamp: 'di 5/25/1998 14:24'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/10/1998 07:19'!oldOpenAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| buttonView col |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	buttonView _ PluggableButtonMorph		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	col _ Color perform: self defaultBackgroundColor.	buttonView		label: myChangeSet name; 		onColor: col offColor: col;		triggerOnMouseDown: true; borderColor: window color.	window addMorph: buttonView		frame: (((0@0 extent: 1.0@0.06) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:)		frame: (((0.5@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.36 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/8/1998 17:35'!oldOpenView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView buttonView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	buttonView _ PluggableButtonView		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	buttonView		label: myChangeSet name;		triggerOnMouseDown: true; borderWidth: 1; 		window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	topView addSubView: buttonView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: classView below: buttonView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: messageView toRightOf: classView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/10/1998 07:53'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| chgSetList |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (chgSetList _ PluggableListMorphByItem on: self			list: #changeSetList			selected: #currentCngSet			changeSelected: #showChangeSetNamed:			menu: #changeSetMenu:)		frame: (((0@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	chgSetList autoDeselect: false.	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0.5@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:)		frame: (((0@0.25 extent: 1@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.5 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/5/1998 07:08'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:.	cngSetListView window: ((0 @ 0 extent: 180 @ 100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (180 @ 0 extent: 180 @ 100).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView window: (0 @ 100 extent: 360 @ 100).	topView addSubView: messageView below: cngSetListView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: messageView.! !!ChangeSorter methodsFor: 'access' stamp: 'di 6/15/1998 20:33'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 08:15'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self changed: #contents.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 07:38'!showChangeSetNamed: aName	aName ifNil: [^ self showChangeSet: nil].	self showChangeSet: 		(AllChangeSets detect: [:each | each name = aName]) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/12/1998 16:29'!changeSetList	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	^ AllChangeSets reversed collect: [:each | each name]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/17/1998 17:57'!chooseCngSet	"Put up a list of them"	| index |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	index _ (PopUpMenu labels: 		(AllChangeSets reversed collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (AllChangeSets at: (AllChangeSets size - index + 1))].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:05'!newSet	"Create a new changeSet and show it.  make the new guy the current one.  Also, reject name if already in use."	| newName newSet |	self okToChange ifFalse: [^ self].	newName _ FillInTheBlank request: 'A name for the new change set'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue: [^ self].	(self class changeSetNamed: newName) ifNotNil:			[^ self inform: 'Sorry that name is already used'].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	self update.	self showChangeSet: newSet.	self newCurrent.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 11:58'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self inform: 'No change made'].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:19'!updateIfNecessary	"recompute all of my panes"	| newList |	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:54'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil: [		^ aMenu labels: 'copy method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(1 3 6 10 )		selections: #(copyMethodToOtherforget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]	ifNil: [^ aMenu labels: 'delete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 5 9 )		selections: #( forget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:44'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionrevert and forgetmore...' 	lines: #(5 7 9)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!ClassDescription methodsFor: 'copying' stamp: 'sw 6/16/1998 15:01'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'wod 5/22/1998 01:47'!commentStamp: changeStamp    ^ self commentStamp: changeStamp prior: 0! !!Color methodsFor: 'transformations' stamp: 'jm 6/25/1998 10:12'!darker	"Answer a darker shade of this color."	^ self mixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'jm 6/17/1998 11:23'!lighter	"Answer a lighter shade of this color."	^ self mixed: 0.8333 with: Color white! !!Color methodsFor: 'other' stamp: 'sw 6/10/1998 17:50'!newTileMorphRepresentative	^ ColorTileMorph new colorSwatchColor: self! !!Color methodsFor: 'conversions' stamp: 'jm 6/2/1998 14:56'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val rgbBlack32 |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		rgbBlack32 _ 16rFF000001.  "closest black for 32-bit depth, with opaque alpha"		"eight bits per component; top 8 bits set to all ones (opaque)"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack32] ifFalse: [16rFF000000 + val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!ColorSeerTile methodsFor: 'as yet unclassified' stamp: 'jm 5/28/1998 19:19'!storeCodeOn: aStream indent: tabCount	"We have a hidden arg. Output two keywords with interspersed arguments."	| parts |	parts _ operatorOrExpression keywords.	"color:sees:"	^ aStream nextPutAll: (parts at: 1); space;		nextPutAll: colorSwatch color printString; space;		nextPutAll: (parts at: 2).! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 6/10/1998 17:49'!colorSwatchColor: aColor	colorSwatch color: aColor! !!ColorTileMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:02'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: colorSwatch color printString.! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:14'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompositionScanner methodsFor: 'initialize-release' stamp: 'jm 5/29/1998 14:48'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	super		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows _ scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r _ rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:31'!storeCodeOn: aStream indent: tabCount	aStream nextPut: $(.	testPart storeCodeOn: aStream indent: 0.	aStream nextPut: $); cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifTrue: ['; cr.	self storeCodeBlockFor: yesPart on: aStream indent: tabCount + 2.	aStream nextPut: $]; cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifFalse: ['; cr.	self storeCodeBlockFor: noPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !!ContextPart methodsFor: 'private' stamp: 'ar 6/5/1998 21:57'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value t1 t2 t3 |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 83 or:[primitiveIndex = 84])		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'di 6/20/1998 12:59'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn't repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored.  On the high level, objectToStoreOnDataStream allows you to substitute another object on the way out.  The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload and (class) readDataFrom:size:. See these methods, and the class DiskProxy, for more information about externalizing and internalizing.NOTE: A DataStream should be treated as a write-stream for writing.  It is a read-stream for reading.  It is not a ReadWriteStream.!!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:17'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].	"After reading the externalObject, internalize it.	 #readReference is a special case. Either:	   (1) We actually have to read the object, recursively calling		   next, which internalizes the object.	   (2) We just read a reference to an object already read and		   thus already interalized.	 Either way, we must not re-internalize the object here."	selector == #readReference ifFalse:		[anObject _ self internalize: anObject.		self checkForPaths: anObject].	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:18'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectToStoreOnDataStream) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectToStoreOnDataStream.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:03'!readString	| str |	byteStream ascii.	str _ byteStream nextString.	byteStream binary.	^ str! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:27'!readStringOld   ^ byteStream nextStringOld! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:13'!typeIDFor: anObject	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  	Classes can control their instance variables by defining objectToStoreOnDataStream.	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."		^ TypeMap at: anObject class ifAbsent: [9 "instance of any normal class"]	"See DataStream initialize.  nil=1. true=2. false=3. a SmallInteger=4. (a String was 5). a Symbol=6.  a ByteArray=7. an Array=8. other = 9.  a Bitmap=11. a Metaclass=12. a Float=14.  a Rectangle=15. any instance that can have a short header=16.  a String=17 (new format)."! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!writeBitmap: aBitmap	"PRIVATE -- Write the contents of a Bitmap."	aBitmap writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words."! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!writeByteArray: aByteArray	"PRIVATE -- Write the contents of a ByteArray."	byteStream nextNumber: 4 put: aByteArray size.	"May have to convert types here..."	byteStream nextPutAll: aByteArray.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 20:57'!writeString: aString	"PRIVATE -- Write the contents of a String."	byteStream nextStringPut: aString.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:23'!writeStringOld: aString	"PRIVATE -- Write the contents of a String."	| length |	aString size < 16384 		ifTrue: [			(length _ aString size) < 192				ifTrue: [byteStream nextPut: length]				ifFalse: 					[byteStream nextPut: (length // 256 + 192).					byteStream nextPut: (length \\ 256)].			aString do: [:char | byteStream nextPut: char asciiValue]]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!DataStream class methodsFor: 'all' stamp: 'tk 6/8/1998 21:10'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 40. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"Does anything use this?"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	"t at:  put: 18.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!Date class methodsFor: 'instance creation' stamp: 'di 5/26/1998 11:53'!newDay: day month: month year: year 	"Note: day, month and year are all integers, except month may be a string"	"Answer an instance of me which is the day'th day of the month named 	 month in the year'th year. The year may be specified as the actual 	 number of years since the beginning of the Roman calendar or the 	 number of years since 1900.  **Note** two digit dates are always from 1900.		1/1/01 will NOT mean 2001."	"Tolerate a month index instead of a month name."	| monthIndex daysInMonth firstDayOfMonth |	year < 100 ifTrue: [^ self			newDay: day			month: month			year: 1900 + year].	monthIndex _ month isInteger	 ifTrue: [month] ifFalse: [self indexOfMonth: month].	monthIndex = 2		ifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [daysInMonth _ DaysInMonth at: monthIndex].	monthIndex > 2		ifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].	(day < 1 or: [day > daysInMonth])		ifTrue: [self error: 'illegal day in month']		ifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]! !!Debugger methodsFor: 'initialize' stamp: 'wod 5/26/1998 16:44'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (SystemWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 13:04'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msgString]		ifFalse: [msg _ msgString].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcess].	Display fullScreen.	Cursor normal show.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 14:46'!release	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"	super release.! !!Debugger methodsFor: 'notifier menu' stamp: 'wod 5/26/1998 16:19'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."	World ifNotNil:		[self breakDependents.		self openFullMorphicLabel: topView label.		^ topView delete].	topView controller controlTerminate.	topView deEmphasizeView; erase.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack menu' stamp: 'ar 5/26/1998 16:26'!step	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #contentsSelection]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #contentsSelection.					self updateInspectors]]! !!Debugger methodsFor: 'private' stamp: 'di 6/20/1998 14:48'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'instance creation' stamp: 'di 6/17/1998 14:39'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'di 6/30/1998 12:12'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| f |	<primitive: 19> "Simulation guard"	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	false ifTrue:  "Set to true for log to file"		[f _ FileStream fileNamed: 'SqueakDebug.log'.		f nextPutAll: aString; cr.		aContext stack do: [:ctxt | f print: ctxt; cr].		f close.		self primitiveError: aString].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'di 6/30/1998 12:13'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !!DosFileDirectory methodsFor: 'all' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!nextPut: aByte	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!nextPutAll: aByteArray	"do nothing"! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'jm 6/28/1998 13:57'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: self stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:58'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 6/28/1998 12:50'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!EToyHolder methodsFor: 'demo stuff' stamp: 'sw 5/31/1998 23:00'!scaffoldingMailStrings	^ #('You have Mail!!')! !!EToyHolder methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!cedarText	self codeStrippedOut: '2.0BetaExternal'! !!EToyHolder methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!initializeScaffoldingContentsForFreshEToy	self codeStrippedOut: '2.0BetaExternal'! !!EToyHolder methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!kayaText	self codeStrippedOut: '2.0BetaExternal'! !!EToyHolder methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!scaffoldingImagineersStrings	self codeStrippedOut: '2.0BetaExternal'! !!EToyParameters methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!initializein: arg1	self codeStrippedOut: '2.0BetaExternal'! !!EToyPlayer methodsFor: 'initialization' stamp: 'sw 6/5/1998 18:15'!initializeFor: anEToyHolder inWorld: aWorld	"Prepare the receiver to present the given EToy in the given world."	"Note: Any existing morphs are removed from the given world first."	| m leftEdge rightEdge sizeWanted ok |	associatedMorph _ aWorld.	aWorld removeAllMorphs.	self standardHolder: anEToyHolder.	aWorld presenter: self.		aWorld addEToy: anEToyHolder.	self initializeToggles.	aWorld addMorph: anEToyHolder scaffoldingBook beSticky.	leftEdge _ anEToyHolder scaffoldingBook right - 1.	rightEdge _ aWorld width - 185.	m _ anEToyHolder playfield.	m wantsMouseOverHalos: true.	sizeWanted _ m valueOfProperty: #worldSize.	ok _ sizeWanted ifNil: [false] ifNotNil:		[(aWorld extent x >= sizeWanted x) & (aWorld extent y >= sizeWanted y)].	ok ifFalse: ["size not remembered"		m extent: (rightEdge - leftEdge)@(aWorld height//2).		m color: self initialPlayfieldColor].	aWorld addMorphBack: (m position: leftEdge@0).	aWorld startSteppingSubmorphsOf: m.	m _ anEToyHolder eToyPalette.	m ifNil: [m _ EToyPalette new].	anEToyHolder eToyPalette: m.	standardPalette _ m.	aWorld addMorph: (m beSticky position: anEToyHolder playfield right-1 @0).	m initializeInWorld: aWorld.  "So palettes can get at world"	m showNoPalette.	self harmonizeTilesWithColorSetting.	self addControlsFor: anEToyHolder inWorld:  aWorld.	anEToyHolder notInPlayfield 		ifNil: [self addExtrasFor: anEToyHolder 					inWorld: aWorld]  "differs from orig 118tk here"		ifNotNil: [anEToyHolder notInPlayfield reverseDo: [:each | aWorld addMorph: each]].	anEToyHolder scaffoldingBook selectTabNamed: 'Toy'.	EToyParameters kidsMode ifTrue:		[anEToyHolder scaffoldingBook configureForKids].	self startRunningScripts! !!EToyPlayer class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!openFrontCoverFor: arg1	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!eToyDoItStrings	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!guessDOLProxy	"deleted for external release"! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!loadPurpleWalt	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!openImagineeringStudio	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!prepareRelease	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!previewEToysOn: arg1	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!readCollagePic	self codeStrippedOut: '2.0BetaExternal'! !!EToyWorld methodsFor: 'misc' stamp: 'sw 6/1/1998 14:20'!adjustTabs	"Get the tabs names right"	| but tabHeight  aTitle projects which balloonText |	tabHeight _ 15.	tabs removeAllMorphs.	projects _ ScheduledControllers scheduledWindowControllers		select: [:c | c view isKindOf: ProjectView]		thenCollect: [:c | c model].	projects doWithIndex: [:project :ind |		aTitle _ project name.		but _ tabs addButtonShowing: aTitle, '              '			named: aTitle selector: #selectTabNamed: 			arguments: (Array with: aTitle) padding: tabs padding atIndex: ind.		but font: (StrikeFont familyName: 'ComicBold' size: 16).		but extent: (but extent x @ tabHeight).		(which _ #('Imagineers' 'Etoys') indexOf: aTitle ifAbsent: [0]) > 0			ifTrue:			[balloonText _#('Would you like to meet some other imagineers?Click here!!''Click here to explore the world of EToys!!') at: which.			but setBalloonText: balloonText]].	"Change its background color?"	tabs color: Color transparent; borderWidth: 0.! !!EToyWorld methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!createFrontCover	self codeStrippedOut: '2.0BetaExternal'! !!EToyWorld methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!exitFromCover	self codeStrippedOut: '2.0BetaExternal'! !!EToyWorld methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!scanServerForEToys	self codeStrippedOut: '2.0BetaExternal'! !!EToyWorldView class methodsFor: 'initialization' stamp: 'jm 6/10/1998 07:44'!openOn: aWorld label: labelString	"Open a view with the given label on the given world."	| windowExtent topView topLeft |	windowExtent _ aWorld extent + (2@2).  "add border width"	topView _ self fullColorWhenInactive		ifTrue: [topView _ ColorSystemView new]		ifFalse: [topView _ StandardSystemView new].	topView model: CautiousModel new;		borderWidth: 1;		addSubView: (self new initialize model: aWorld).	topView controller openNoTerminate.	topLeft _ ((Display extent - windowExtent) // 2) max: (0@0).	topView resizeTo: (topLeft extent: windowExtent).	aWorld setStandardTexture.	labelString isEmpty		ifTrue: [topView noLabel]		ifFalse: [topView label: labelString].	Processor terminateActive.! !!EllipseMorph methodsFor: 'all' stamp: 'di 6/24/1998 14:27'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!EventHandler methodsFor: 'access' stamp: 'sw 6/15/1998 09:59'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	^ nil! !!EventRecorder methodsFor: 'as yet unclassified' stamp: 'jm 5/29/1998 14:21'!testControl: anEvent	"See if it is a control event for me.  Control 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"	anEvent isKeystroke ifFalse: [^ self].	anEvent controlKeyPressed ifFalse: [^ self].	anEvent commandKeyPressed ifTrue: [^ self].	"not this"	anEvent macOptionKeyPressed ifTrue: [^ self].	"not this"	anEvent shiftPressed ifTrue: [^ self].	"not this"	anEvent keyCharacter = $1 ifTrue: ["start recording"		tape ifNil: [tape _ OrderedCollection new].		state _ #record].	anEvent keyCharacter = $2 ifTrue: ["stop recording (or playing back)"		state _ nil].	anEvent keyCharacter = $3 ifTrue: ["start playing back"		state _ #play.		tape ifNotNil: [			tape do: [:evt | 				anEvent hand world runStepMethods.				anEvent hand handleEvent: evt.				anEvent hand world displayWorld]].		state _ nil].! !!FileDirectory methodsFor: 'enumeration' stamp: 'wod 6/16/1998 15:07'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"wod 6/16/1998: add Cursor wait, and use 'self pathNameDelimiter asString' rather than hardwired ':' "	"FileDirectory default statsForDirectoryTree: '\smalltalk'"	| dirs files bytes todo p entries |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			entries _ self directoryContentsFor: p.			entries do: [:entry |				(entry at: 4)					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, (entry at: 1)).						dirs _ dirs + 1]					ifFalse: [						files _ files + 1.						bytes _ bytes + (entry at: 5)]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:32'!changeSuffix"if 'changes' is not suitable, override this message to return something that is ok"	^'changes'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:31'!imageSuffix"if 'image' is not suitable, override this message to return something that is ok"	^'image'! !!FileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:49'!pathNameDelimiter"return the active directory class's directory seperator character"	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !!FileList methodsFor: 'initialization' stamp: 'di 5/25/1998 10:26'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:05'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '"Please fill in the following info, then select all text and choose DoIt."| aa | aa _ ServerDirectory new.aa server: ''st.cs.uiuc.edu''.    "host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.    "<- this is optional.  Only used when *writing* update files."ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 09:40'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromDays: (entry at: 3) // 86400)					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:35'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ sortMode == #name  "case-insensitive compare"		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) <= 2]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) >= 2]].	allFiles _ pat = '*'.	entries do:		[:entry | "<name><creationTime><modificationTime><dirFlag><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: (self fileNameFormattedFrom: entry sizePad: sizePad)]].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes"		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:08'!removeServer	| choice names |	names _ ServerDirectory serverNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 16:49'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim _ directory pathNameDelimiter.				path _ String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:07'!volumeMenu: aMenu	^ aMenu		labels:'add server...remove server...'		lines: # ()		selections: #(askServerInfo removeServer)! !!FileList methodsFor: 'file list' stamp: 'di 5/26/1998 20:22'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - self folderString size.					listIndex _ 0.					brevityState _ #FileList.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/24/1998 16:21'!fileAllIn	"File in all of the currently selected file, if any."	"wod 5/24/1998: open the file read only."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn.! !!FileList methodsFor: 'file list menu' stamp: 'jm 6/13/1998 08:40'!openImageInWindow	"Handle three file formats: GIF, Form stoteOn: (run coded), and BMP. Fail if file format is not recognized." 	| image |	image _ Form fromFile: (directory oldFileNamed: fileName).	World		ifNil: [FormView open: image named: fileName]		ifNotNil: [World addMorph: (SketchMorph new form: image)].! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/29/1998 17:09'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory oldFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FileList methodsFor: 'file list menu' stamp: 'di 5/24/1998 14:09'!putUpdate	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdate: 				(directory oldFileNamed: self fullName).! !!FileList methodsFor: 'private'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findFirst: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'di 6/30/1998 21:41'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	listIndex = 0 ifTrue: [^ self defaultContents].	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000])		ifTrue: [^ f contentsOfEntireFile].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	^ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'! !!FileList methodsFor: 'private' stamp: 'di 5/28/1998 15:01'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil:		[listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents]! !!FileList methodsFor: 'private' stamp: 'wod 5/27/1998 17:47'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	"wod 5/27/1998: nil out the fileName."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [self listForPattern: pattern]			ifFalse: [				pattern isEmpty					ifTrue: [self listForPattern: '*']					ifFalse: [self listForPattern: '*', pattern, '*']].		listIndex _ 0.		volListIndex _ volList size.		fileName _ nil.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:23'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView |	World ifNotNil: [^ self openAsMorph].	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/28/1998 10:37'!openAsMorph     "FileList openAsMorph openInMVC"	"Open a morphic view of a FileList on the default directory."	| dir aFileList window |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:22'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	window openInWorld! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 00:53'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 01:07'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!anyShapeFill	"Fill the interior of the outtermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape: to paint a solid color.  See also convexShapeFill:"	| shape |	shape _ (self findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent).		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'di 6/11/1998 21:38'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:04'!peripheralColor  "Form fromUser peripheralColor"	"Return the dominant color as sampled at four corners"	^ (self boundingBox innerCorners collect:		[:p | self colorAt: p]) asBag sortedCounts first value! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!primCountBits	"Count the non-zero pixels of this form."	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this form into the valueTable, which is	a bitmap similar to a color map.  Since the underlying BitBlt function	that performs the tally does not do bit-boundary clipping, the	tallies for any word-boundary fringes must be subtracted."	self tallyPixelValuesPrimitive: destRect into: valueTable.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:37'!tallyPixelValuesPrimitive: destRect into: valueTable	"Tally the selected pixels of this form into valueTable, a Bitmap similar to a color map, and return valueTable. Since the BitBlt function that performs the tally does not do bit-boundary clipping, the tallies for any word-boundary fringes must be subtracted by the sender."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		colorMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 01:00'!trimToPixelValue: pv orNot: not	"Return the smallest part of me that includes all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	^ self copy: (self innerPixelRectFor: pv orNot: not)"Try this to select all but the background...Form fromUser in: [:f |(f trimToPixelValue: (f peripheralColor pixelValueForDepth: f depth) orNot: true) display]Or this to select whatever is black...Form fromUser in: [:f |(f trimToPixelValue: (Color black pixelValueForDepth: f depth) orNot: false) display]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/17/1998 12:38'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: ByteArray) ifTrue: [^ self  "already compacted"].	compactBits _ ByteArray new: (bits size*4) + 5 + (bits size//7936*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!FormCanvas methodsFor: 'drawing' stamp: 'di 6/26/1998 15:09'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: 0@0.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:41'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [			fillC == nil ifTrue: [^ self].  "both border and fill are transparent"			borderC _ nil.			rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor].	port combinationRule:		(self drawRule: Form over color: c borderColor: borderColor).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:33'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 15:41'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rule |	rule _ self drawRule: Form over color: fillColor borderColor: borderColor.	port combinationRule: rule.	borderColor isTransparent ifFalse: [		"draw border of rectangle"		(r area > 10000 or: [fillColor isTransparent or: [rule = Form blend]]) ifTrue: [			port frameRect: (r translateBy: origin)				borderWidth: borderWidth				borderColor: (self drawColor: borderColor).		] ifFalse: [			"for small rectangles, it's faster to fill the entire outer rectangle than to compute and fill the border rects"			port fillRect: r color: (self drawColor: borderColor) offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse: [		port 	fillRect: (r insetBy: borderWidth)				color: (self drawColor: fillColor)				offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/3/1998 14:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		port fillColor: (self drawColor: bottomRightColor);			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint color: Color black);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over color: c);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c)		background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:27'!drawRule: defaultRule color: color	"Answer the BitBlt combination rule for the given default rule and color. If this canvas is in shadow-drawing mode, answer 'paint'. If the color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color isColor and: [color alpha < 1.0])		ifTrue: [^ Form blend]		ifFalse: [^ defaultRule].! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:32'!drawRule: defaultRule color: color1 borderColor: color2	"Answer the BitBlt combination rule for the given default rule and colors. If this canvas is in shadow-drawing mode, answer 'paint'. If either color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color1 isColor and: [color1 alpha < 1.0]) ifTrue: [^ Form blend].	(color2 isColor and: [color2 alpha < 1.0]) ifTrue: [^ Form blend].	^ defaultRule! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:40'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:41'!stipple: newStipple	shadowStipple _ newStipple.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:46'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:11'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: Color white.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:14'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: Color white.	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: Color red.	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.	canvas point: 100@100 color: Color black.	canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.	canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.	canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.	canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.	canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.	canvas showAt: 0@0.! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:57'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:56'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!GradientFillMorph methodsFor: 'drawing' stamp: 'jm 6/1/1998 19:24'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorArrayForDepth: aCanvas depth.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 6/2/1998 15:57'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 alpha < 1.0]) ifTrue: [^ true].	^ false! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:55'!fillColor: aColorOrPattern	aColorOrPattern == lastColor ifTrue: [^ self].	super fillColor: aColorOrPattern.	lastColor _ aColorOrPattern.! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:01'!fillRect: rect color: fillColor offset: aPoint	fillColor class == InfiniteForm ifTrue: [		self fillColor: nil.		fillColor displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.		^ self].	sourceForm _ nil.	self fillColor: fillColor.	destX _ rect left + aPoint x.	destY _ rect top + aPoint y.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:36'!frameRectBottom: rect height: h	sourceForm _ nil.	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:35'!frameRectRight: rect width: w	sourceForm _ nil.	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!HTMLformatter class methodsFor: 'formatting' stamp: 'pm 6/6/1998 21:39'!textAreaStart: fieldName rows: rows cols: cols       ^ '<TEXTAREA NAME="', fieldName, '" ROWS=',rows,' COLS=',cols,'>' ! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 5/22/1998 16:28'!innerTarget	^ innerTarget! !!HaloMorph methodsFor: 'stepping' stamp: 'jm 6/2/1998 13:51'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target fullBoundsInWorld].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'sw 6/15/1998 14:54'!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: 16@16)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'sw 6/15/1998 15:41'!addHandles	| box |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: 17)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box topLeft + (0 @ (9 + ((box height - 36) // 4)))) color: Color lightBrown on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + (18@0)) color: Color transparent on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black on: #mouseDown send: #doGrab:with: to: self.	self addHandleAt: box topRight color: Color green on: #mouseDown send: #doDup:with: to: self.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue:			[(self addHandleAt: box bottomRight color: Color lightOrange on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse:			[(self addHandleAt: box bottomRight color: Color yellow on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target "innerTarget" externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 6/15/1998 15:00'!addHandlesForWorldHalos	| box |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box topLeft + (0@20)) color: Color lightBrown on: #mouseDown send: #tearOffTile to: target.	self addHandleAt: box leftCenter color: Color cyan on: #mouseDown send: #openViewerForArgument to: target.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue on: #mouseDown send: #mouseDownOnHelpHandle: to: target)			on: #mouseUp send: #deleteBalloon to: target].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:06'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	cacheCanvas ifNil: [		"could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:05'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	depth = 32 ifTrue: [		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	myBnds _ super fullBounds.  "my full bounds without my shadow"	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 5/29/1998 18:08'!newMouseFocus: aMorphOrNil	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 6/17/1998 08:57'!updateMouseDownTransform	"To help with, eg, autoscrolling"	mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self].! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/17/1998 16:17'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #duplicateMorph.	(argument pasteUpMorph morphsAt: targetOffset) size > 2 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse: [		menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue: [		menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'inspect in Morphic' action: #inspectMorphInMorphic.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue: [		menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue: [			 menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'di 6/13/1998 11:04'!buildWorldMenu	"Build the meta menu for the world."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'go back' target: owner action: #goBack.	menu add: 'jump to...'		subMenu: (Project buildJumpToMenu: (MenuMorph new defaultTarget: Project)).	menu addLine.	menu add: 'paste morph' action: #pasteMorph.	menu add: 'new morph...' action: #newMorph.	World ifNotNil: [		subMenu _ MenuMorph new defaultTarget: self.		subMenu add: 'workspace' action: #openWorkspace.		subMenu add: 'browser' action: #openBrowser.		subMenu add: 'recent changes' action: #openRecentChanges.		subMenu add: 'change sorter' selector: #openChangeSorter: argument: 1.		subMenu add: 'dual sorter' selector: #openChangeSorter: argument: 2.		subMenu add: 'changes log' action: #openChangesLog.		subMenu add: 'file list' action: #openFileList.		subMenu add: 'transcript' action: #openTranscript.		subMenu add: 'project (mvc)' action: #openMVCProject.		subMenu add: 'project (morphic)' action: #openMorphicProject.		subMenu add: 'project link...' action: #projectThumbnail.		subMenu addLine.		subMenu add: 'collapse all' action: #collapseAll.		subMenu add: 'expand all' action: #expandAll.		subMenu add: 'find window' action: #findWindow.		menu add: 'windows...' subMenu: subMenu].	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'grab drawing from screen' action: #grabDrawingFromScreen.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu add: 'graphics...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'add slot to model' action: #newVariable.	subMenu add: 'write init method for model' action: #writeInitMethodForModel.	subMenu add: 'grab model for this world' action: #grabModel.	menu add: 'model...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'set display depth...' action: #setDisplayDepth.	subMenu add: 'change background color' action: #changeBackgroundColor.	subMenu add: 'use texture background' target: self world action: #setStandardTexture.	subMenu add: 'unlock contents' action: #unlockWorldContents.	subMenu add: 'unhide hidden objects' action: #showHiders.	subMenu add: 'round up stray objects' action: #roundUpStrayObjects.	gridOn		ifTrue: [subMenu add: 'turn gridding off' action: #setGridding]		ifFalse: [subMenu add: 'turn gridding on' action: #setGridding].	menu add: 'options...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'update code from server' action: #updateFromServer.	subMenu addLine.	subMenu add: 'local host address' action: #reportLocalAddress.	subMenu add: 'connect remote user' action: #connectRemoteUser.	subMenu add: 'disconnect remote user' action: #disconnectRemoteUser.	subMenu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu add: 'remote...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'save world in file' action: #saveWorldInFile.	subMenu add: 'read morph(s) from file' action: #readMorphFile.	menu add: 'file...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self world.	subMenu add: 'add stop, step, & go buttons' target: self world presenter action: #addStopStepGoButtons.	subMenu add: 'add scripting knobs' target: self presenter action: #addStandardControls.	subMenu add: 'remove scripting knobs' target: self world action: #removeScriptingControls.	subMenu addLine.	subMenu add: 'parts bin' target: self presenter action: #createStandardPartsBin.	subMenu add: 'control panel' target: self presenter action: #createControlPanel.	menu add: 'scripting...' subMenu: subMenu.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'inspect world' action: #inspectWorld.	subMenu add: 'inspect model' action: #inspectWorldModel.	subMenu add: 'clear palette area' action: #clearPaletteArea.	subMenu add: 'flush viewer cache' action: #flushViewerCache.	subMenu add: 'full screen' action: #fullScreen.	subMenu add: 'start MessageTally' action: #startMessageTally.	subMenu add: 'call #tempCommand' action: #callTempCommand.	subMenu add: 'show space left' action: #showSpaceLeft.	menu add: 'debug...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save' action: #saveSession.	subMenu add: 'save as...' action: #saveAs.	subMenu add: 'save and quit' action: #saveAndQuit.	subMenu add: 'quit...' action: #quitSession.	menu add: 'save / quit...' subMenu: subMenu.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/14/1998 14:29'!copyToPasteBuffer	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	argument isMorph		ifTrue: [Cursor wait showWhile: 					[PasteBuffer _ argument veryDeepCopy]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/22/1998 18:02'!duplicateMorph	| newMorph |	newMorph _ argument veryDeepCopy.		false ifTrue: [newMorph _ argument usableDuplicateIn: self world].	"old"	self grabMorphFromMenu: newMorph.	newMorph costumee ifNotNil: [newMorph costumee startRunning].	" -- End of presently active code -- "	self flag: #noteToDan.  "The following code was formerly in duplicateMorph, and 		may need to be reincorporated somewhere:""	oldModel _ argument findA: MorphicModel.	oldModel ifNotNil:		[oldModel model duplicate: (new findA: MorphicModel) from: oldModel]."	self flag: #noteToTed.  "the following corrsponds to the hook you had in for getting script tiles straightened out:""	newMorph justDuplicatedFrom: argument.		We depend on nameInModel working, and hand having grabbed already (old tck note)"! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 6/1/1998 19:15'!makeNewDrawing	"Make a new drawing in the standard playfield."	| aPlayfield bnds |	(aPlayfield _ self world playfield) ifNil: [aPlayfield _ self world].	bnds _ aPlayfield paintingBoundsAround: aPlayfield boundsInWorld center.	self makeNewDrawingInBounds: bnds pasteUpMorph: aPlayfield.! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/14/1998 14:34'!objectToPaste	"It may need to be sent #startRunning by the client"	^ Cursor wait showWhile: [PasteBuffer veryDeepCopy]	"PasteBuffer usableDuplicateIn: self world"! !!HandMorph methodsFor: 'meta menu' stamp: 'di 6/12/1998 15:29'!openChangeSorter: oneOrTwo	oneOrTwo = 1		ifTrue: [ChangeSorter new open]		ifFalse: [DualChangeSorter new open]! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/14/1998 14:35'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee costumee ifNotNil: [aPastee costumee startRunning]! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/17/1998 16:27'!saveOnFile	"Save the guy we clicked on, not the hand"	argument saveOnFile! !!HandMorph methodsFor: 'from EToyHand' stamp: 'jm 6/2/1998 14:28'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor p |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new costumee: (newPlayer _ Player newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect ofWorld: w.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch forwardDirection: sketchEditor forwardDirection.			newSketch rotationDegrees: sketchEditor forwardDirection.			newSketch rotationStyle: sketchEditor rotationStyle.			aPasteUpMorph addMorphFront: newSketch.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits: [			p _ aPasteUpMorph standardPalette.			p ifNotNil: [p showNoPalette]].! !!InputSensor methodsFor: 'modifier keys' stamp: 'jm 5/29/1998 14:17'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	^ self primMouseButtons anyMask: 32! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:20'!openAsMorphOn: anObject	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: anObject defaultLabelForInspector)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.7 corner: 1@1).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:12'!openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject) openInWorld! !!Integer methodsFor: 'arithmetic' stamp: 'LC 6/18/1998 09:33'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger		ifTrue: [quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"								neg: self negative ~~ aNumber negative.				(quoRem at: 2) = 0					ifTrue: [^(quoRem at: 1) normalize]					ifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]		ifFalse: [^ (aNumber adaptInteger: self) / aNumber adaptToInteger]! !!Integer methodsFor: 'truncation and round off' stamp: 'sw 6/26/1998 15:48'!atRandom	"Return a random integer from 1 to self.  Heavy users should use Interval atRandom or atRandom: directly."	self < 1 ifTrue: [^ self].	^ (1 to: self) atRandom! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'private' stamp: 'LC 6/18/1998 10:07'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	arg = 0 ifTrue: [^ self error: 'division by 0'].	"*****We've added this line*****"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0 ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l				put: lo - (lo // 256 * 256) "sign-tolerant form of (lo bitAnd: 255)".			a _ (lo // 256) - (hi bitShift: -4).			l _ l + 1].		a < 0 ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !!Interpreter methodsFor: 'contexts' stamp: 'jm 6/24/1998 17:59'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/25/1998 06:45'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 09:37'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 17:59'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 11:14'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 14:08'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 6/28/1998 12:49'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primBitmapcompresstoByteArray	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:16'!primBitmapdecompressfromByteArrayat	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primStringcomparewithcollated	^ self primitiveFail! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 6/28/1998 11:55'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Black Uhuru:Desktop Folder:CW Test Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 6/28/1998 11:56'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives													onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/30/1998 13:58'!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ # (83 73 84 33 0 2 0 0 34 226 114 76 97 117 2 162 0 0 0 22 1 221 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 99 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 189 166 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 140 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 177 190 158 132 0 0 37 198 0 0 29 242 0 0 7 229 0 0 8 33 202 166 25 188 0 0 0 0 0 0 74 218 13 192 248 235 186 60 187 86 182 50 249 202 82 126 132 219 225 217 121 124 162 181 178 35 44 114 140 80 66 9 187 40 158 158 156 30 167 157 39 161 114 250 92 159 19 110 134 239 165 173 199 52 252 197 241 79 249 209 6 121 107 17 38 127 194 201 113 9 229 71 24 121 110 132 229 25 57 22 225 71 158 69 249 25 225 79 158 63 225 132 19 254 132 19 202 7 132 19 70 248 153 157 132 19 26 97 228 248 17 78 152 132 191 132 37 225 3 35 199 8 91 129 187 26 176 232 243 35 199 143 54 136 242 149 175 17 78 56 161 71 88 228 248 73 88 100 198 9 127 138 39 28 24 127 2 1 232 117 118 1 48 0 144 199 3 204 192 63 123 39 167 221 46 115 126 81 240 169 92 139 40 72 156 230 23 52 78 149 91 68 89 18 57 49 168 90 107 111 109 21 133 230 121 133 149 142 144 34 47 175 100 49 187 203 229 174 113 214 47 44 99 96 81 254 0 250 37 222 254 46 118 220 124 163 4 48 237 48 192 165 175 138 156 39 40 120 155 57 185 85 11 6 144 32 161 172 234 156 53 127 64 229 240 167 249 69 206 39 54 9 173 65 13 207 106 179 38 135 184 144 18 144 52 81 113 44 172 163 151 251 47 113 94 65 146 100 141 243 32 27 249 54 209 199 201 77 77 81 18 122 30 143 232 21 90 85 145 11 104 132 30 10 194 66 26 86 129 153 22 130 17 76 228 143 214 65 58 176 152 200 132 72 39 158 140 0 106 135 69 22 22 3 1 21 23 17 69 108 46 193 203 85 215 114 243 10 155 57 231 108 103 65 129 227 233 129 44 216 241 0 204 209 67 244 124 3 211 201 100 178 171 250 243 56 32 35 138 140 233 156 61 152 201 14 12 227 98 183 178 33 211 187 80 14 48 65 4 152 120 132 50 75 99 32 18 137 165 137 68 24 18 4 186 88 63 146 216 180 9 160 56 66 190 168 178 153 233 46 89 18 188 242 176 2 102 184 2 44 204 75 108 56 126 30 12 66 239 188 249 144 70 170 132 22 73 37 87 21 144 154 69 229 123 38 209 12 110 183 243 68 134 220 18 183 187 106 188 100 111 193 127 73 40 20 52 6 224 225 114 85 149 166 242 88 171 2 30 110 97 75 72 86 52 34 237 143 57 92 238 42 172 86 67 0 30 245 206 107 141 1 116 173 169 173 25 34 248 39 143 186 178 134 58 214 225 77 182 48 87 189 222 53 79 169 170 243 48 59 188 5 5 134 0 60 76 14 239 207 130 252 206 35 100 24 160 107 104 152 200 25 30 98 219 207 130 252 26 122 189 250 255 169 87 91 156 71 82 141 137 200 195 45 168 94 33 120 90 88 93 215 144 160 26 5 240 240 14 43 155 210 149 24 27 194 35 157 240 248 169 19 141 241 96 29 223 251 155 254 48 213 136 43 83 245 218 224 172 30 241 13 54 146 164 60 233 28 124 178 183 245 191 214 65 251 189 162 42 201 102 63 202 67 245 7 61 169 60 86 119 217 47 170 34 15 173 213 32 128 7 9 179 3 171 228 111 93 221 164 22 83 30 216 0 196 225 162 180 63 230 56 235 112 79 241 48 12 112 184 213 165 139 200 76 46 169 135 203 93 159 210 195 168 193 41 159 84 227 172 83 78 242 56 227 148 71 120 140 58 229 17 93 71 157 114 138 135 241 130 83 30 210 227 47 167 124 74 216 63 157 114 138 199 168 83 30 162 113 206 41 39 121 24 3 56 101 227 15 135 123 178 96 207 58 220 211 157 209 48 192 225 214 7 164 171 231 114 109 133 243 78 56 92 203 31 78 7 137 156 200 241 135 211 73 242 56 227 80 70 244 24 117 40 41 30 99 29 120 136 199 185 14 156 228 97 114 36 187 94 6 242 192 194 31 177 194 227 29 38 193 35 24 24 110 123 223 78 18 78 87 26 225 33 123 150 15 243 168 246 44 79 241 200 116 157 92 87 136 23 135 203 89 97 8 32 250 111 51 130 12 84 131 86 244 47 60 176 83 5 135 189 226 100 194 35 40 168 42 231 148 91 66 129 224 119 234 198 58 3 86 180 216 100 8 160 235 120 103 72 120 233 164 39 31 227 145 234 192 169 58 75 116 78 109 184 204 70 195 156 75 215 134 24 48 49 22 220 240 41 130 70 196 151 28 219 2 141 51 15 232 24 192 139 0 141 124 248 131 99 248 63 200 135 249 112 239 251 151 46 193 141 159 73 176 27 51 175 195 51 44 38 20 170 248 246 135 222 132 198 171 42 96 201 87 183 64 120 223 46 8 119 180 241 225 7 45 244 78 120 61 182 67 194 68 231 199 217 248 118 146 143 111 223 188 15 110 218 123 247 0 23 68 194 119 61 122 92 112 253 252 145 46 25 229 119 60 248 246 39 46 230 219 31 199 219 81 126 144 115 51 236 198 127 63 159 142 143 160 177 120 63 158 159 161 92 122 40 231 195 176 137 42 157 131 89 145 49 110 20 177 23 22 233 163 212 218 214 16 233 206 4 173 192 109 66 81 81 139 236 214 30 152 188 253 138 56 113 102 150 174 8 102 101 124 143 205 1 251 13 251 241 191 219 31 249 154 71 252 74 188 23 1 251 148 89 136 29 193 191 13 114 218 235 48 255 139 249 96 54 35 206 29 207 15 136 187 117 124 150 198 20 188 209 165 122 149 0 76 197 129 36 230 167 91 85 190 110 172 3 212 135 230 207 192 252 59 118 129 61 55 177 19 149 127 255 147 252 198 167 52 68 176 8 8 159 238 110 176 95 178 131 185 38 205 134 216 30 228 215 73 235 124 242 246 213 122 126 212 131 228 183 79 143 217 202 92 152 78 182 225 72 13 92 48 88 3 104 122 20 65 9 136 106 17 24 90 212 0 179 224 250 47 12 3 106 32 3 216 169 131 53 16 107 2 0 93 121 208 87 249 10 244 213 180 241 29 119 188 94 77 166 234 38 200 196 15 224 67 198 183 130 112 140 144 219 112 224 145 46 56 248 230 3 192 204 94 207 248 86 162 30 43 58 123 163 65 239 247 169 107 144 201 91 252 70 212 148 230 239 202 195 28 135 74 97 70 41 100 189 211 0 231 21 178 180 135 229 100 233 134 225 192 182 231 83 253 28 121 206 137 65 58 190 42 23 114 122 55 227 191 19 49 15 189 159 211 119 20 172 207 245 68 48 16 231 175 197 90 224 183 101 230 195 17 6 235 117 109 4 152 189 116 18 206 90 112 175 52 171 54 208 18 10 138 92 169 40 142 79 54 13 59 130 1 198 8 166 8 48 236 96 198 133 89 186 212 73 55 60 17 164 97 133 9 223 22 11 198 43 184 91 11 19 245 61 107 110 177 139 140 6 201 190 245 200 248 160 63 202 75 106 235 244 157 149 203 109 54 218 207 255 141 98 140 56 248 195 142 44 76 216 53 152 114 46 234 120 110 47 216 130 155 192 137 122 216 67 55 140 7 27 138 17 80 44 93 170 106 130 66 172 158 129 67 216 169 83 196 98 30 172 103 236 126 70 0 237 170 216 0 66 95 198 78 94 21 48 164 137 103 201 132 41 181 153 79 220 134 238 94 24 50 179 192 63 217 213 111 48 4 240 49 169 178 61 238 115 126 112 57 186 55 177 128 57 209 181 6 222 207 96 39 126 178 113 26 25 129 95 196 72 192 134 22 211 249 236 133 33 5 135 177 83 225 178 218 186 154 60 204 216 191 113 151 215 75 135 155 232 249 112 139 229 83 152 134 247 173 4 171 121 13 112 110 195 208 225 246 117 247 66 33 98 244 189 130 10 55 224 56 159 33 19 63 8 189 13 213 200 122 6 193 90 214 194 82 196 234 8 86 56 27 240 113 0 214 71 176 54 55 172 65 108 53 193 46 216 10 29 136 117 19 108 230 11 112 15 98 71 9 198 47 128 251 0 206 159 79 48 233 101 216 130 146 53 16 204 255 57 60 140 82 210 65 114 254 6 216 137 24 114 1 152 146 14 56 75 185 136 204 106 224 166 101 208 131 239 121 208 124 75 43 224 61 196 54 80 222 235 224 99 196 54 19 236 74 39 124 6 112 201 109 4 155 244 25 124 131 24 205 145 187 19 223 221 0 142 14 25 203 50 152 108 128 233 248 54 8 6 78 87 176 162 230 18 200 116 136 98 88 11 152 219 141 111 142 136 94 141 195 186 82 3 178 148 141 27 70 241 65 184 149 110 58 196 225 44 178 235 226 148 125 226 117 162 100 73 236 189 208 107 81 26 147 162 91 87 177 148 49 188 94 80 164 128 180 76 181 198 232 150 181 105 138 160 166 151 249 2 154 172 152 203 101 73 75 175 19 148 101 162 150 93 226 245 138 56 140 119 11 154 31 239 211 52 89 212 172 71 137 39 86 74 233 181 40 33 171 190 220 17 87 78 135 99 180 211 157 229 46 76 150 69 30 92 136 241 72 60 190 48 129 64 184 57 68 175 71 249 252 15 0 12 0 235 49 185 14 204 107 214 217 121 201 105 215 132 222 54 182 50 249 211 46 202 7 166 178 181 79 217 105 231 118 141 167 71 56 57 238 225 217 122 50 15 79 40 158 106 225 159 230 19 222 17 38 217 79 54 97 251 201 109 178 201 126 242 155 12 54 217 100 31 57 30 225 100 31 149 71 37 191 143 12 232 38 155 220 150 112 178 201 38 147 77 56 225 40 32 19 126 132 31 57 78 56 225 228 54 217 228 182 100 63 217 20 184 183 117 211 107 227 143 93 79 205 111 128 39 252 141 222 102 100 176 9 26 182 148 108 0 130 7 62 60 80 14 186 152 166 169 132 16 23 124 27 9 217 243 77 248 254 12 122 17 248 22 193 247 71 100 27 105 35 110 210 82 28 213 198 245 152 108 16 215 243 207 146 71 72 247 240 252 95 59 73 49 32 208 87 130 53 125 110 142 231 13 75 177 230 62 229 172 46 233 10 160 30 99 120 219 17 67 224 242 199 240 124 129 254 104 232 95 128 23 10 120 116 198 22 66 218 103 73 217 195 149 196 245 202 15 9 185 48 239 122 168 234 109 114 144 68 160 126 236 18 20 157 129 225 225 163 252 177 250 192 119 220 62 82 228 138 213 158 180 166 35 238 195 238 35 23 230 201 59 192 61 41 175 36 213 160 2 66 60 76 35 11 175 68 73 152 178 158 244 199 108 120 251 245 97 93 154 42 171 121 24 166 240 64 125 26 234 114 172 189 80 159 129 218 135 253 50 168 37 168 75 210 191 121 180 14 234 163 233 137 83 47 67 221 159 158 120 168 8 234 96 122 242 193 31 64 253 93 242 61 152 170 204 230 197 107 140 245 40 170 28 209 149 81 99 149 156 214 45 3 120 17 124 252 137 60 5 211 84 219 124 212 25 99 224 5 1 99 42 17 91 227 229 4 214 53 51 123 167 159 128 41 26 176 222 157 250 219 139 111 66 45 120 218 133 255 213 98 93 143 245 50 127 135 241 127 193 99 245 140 242 151 63 127 194 231 31 200 31 129 141 42 155 207 74 198 103 151 162 203 49 83 211 167 242 18 19 174 37 248 220 186 129 199 199 201 44 176 224 179 121 172 96 60 30 215 166 12 83 137 141 20 156 226 58 139 199 42 168 127 191 192 163 224 207 241 143 77 190 178 62 226 99 124 245 203 230 132 166 175 208 69 190 136 245 126 228 165 14 235 138 148 235 209 159 64 93 153 242 236 122 122 129 63 255 6 127 205 136 35 248 107 250 229 220 123 109 80 55 254 234 245 95 140 231 249 116 249 93 109 192 70 147 205 103 61 227 51 42 235 138 164 6 18 241 112 168 43 20 209 116 243 10 179 61 88 247 162 238 132 14 239 196 58 132 255 9 190 239 178 252 83 240 191 236 63 29 89 31 218 129 245 78 172 143 225 156 142 63 221 157 245 169 67 150 126 150 245 210 239 162 233 115 159 173 151 114 174 23 109 60 17 95 203 92 95 192 250 118 156 119 15 214 109 88 219 250 17 122 185 227 127 186 57 104 233 167 29 107 225 47 182 158 14 204 124 57 176 19 234 219 214 117 245 185 158 178 254 3 57 17 244 244 160 146 136 107 19 171 130 186 213 210 147 237 51 66 31 247 97 127 47 214 199 215 125 215 214 145 208 205 17 172 239 157 249 199 219 95 91 208 77 231 127 243 209 61 168 171 27 240 191 13 189 20 114 117 88 49 98 31 231 234 174 45 7 114 117 150 143 42 99 108 64 141 51 63 92 227 36 176 85 2 31 144 207 62 33 3 94 247 150 3 124 252 147 17 81 111 243 113 93 60 161 127 188 156 129 39 182 76 34 39 216 251 7 59 7 220 130 253 125 150 223 181 96 125 51 214 203 249 222 206 1 215 99 125 19 214 55 98 45 124 75 228 78 225 251 118 238 236 33 189 219 222 130 218 157 97 148 41 161 20 220 125 32 234 87 149 179 235 252 11 220 43 115 240 156 26 150 204 97 88 204 29 234 56 209 220 35 181 180 43 7 58 226 173 126 248 193 158 35 156 155 131 241 177 35 169 107 231 96 1 164 31 234 24 105 137 142 74 170 218 186 68 14 108 221 46 205 33 250 56 135 55 26 26 120 224 164 31 232 248 144 132 133 39 252 32 59 199 14 182 113 68 62 155 131 249 129 232 30 52 131 220 9 83 148 252 216 225 32 229 105 188 232 154 14 71 250 122 104 135 184 25 234 183 28 69 166 60 173 79 10 212 214 39 201 54 134 250 13 71 55 144 146 230 56 42 237 144 34 134 250 136 195 110 202 235 125 9 103 133 14 236 120 64 173 222 247 157 157 208 227 207 61 245 117 215 244 96 247 201 65 218 1 231 4 84 95 189 227 180 179 95 117 3 175 20 149 118 96 47 198 102 117 246 104 179 95 249 123 26 81 161 3 59 102 80 173 247 253 34 99 204 63 92 16 61 205 8 28 149 165 133 210 78 80 111 241 183 183 143 130 135 21 112 89 18 97 168 172 83 198 81 139 167 206 75 170 145 135 101 185 68 160 74 196 131 168 134 25 87 180 85 212 211 25 212 211 164 156 163 150 0 42 168 58 7 107 161 122 51 168 186 146 24 90 65 61 147 65 61 67 124 168 6 83 25 149 215 212 176 56 107 69 39 232 181 228 167 229 160 214 94 89 138 203 250 146 36 88 202 231 168 180 83 201 81 233 29 0 162 130 5 125 232 121 176 19 152 14 135 131 189 172 83 197 24 122 190 180 75 54 70 142 142 231 180 199 146 61 155 149 117 170 57 106 241 224 84 82 46 232 149 229 39 142 74 59 53 28 181 38 168 37 226 138 169 104 9 73 5 178 116 205 154 128 165 47 49 235 19 164 150 163 122 194 202 164 28 15 107 241 172 144 44 212 58 142 90 210 125 94 78 152 121 138 44 212 29 56 235 151 198 193 141 227 186 52 113 117 214 157 28 181 34 131 58 40 79 154 87 144 45 212 122 84 222 64 244 1 83 201 187 158 133 186 11 121 13 203 163 212 195 55 120 221 141 122 165 247 0 43 254 74 243 54 119 20 218 105 16 26 210 117 45 235 65 31 204 218 200 51 74 9 72 123 48 24 201 161 210 44 205 115 3 75 213 123 80 121 129 100 82 149 7 37 117 228 170 242 154 248 172 149 129 120 92 151 13 227 100 159 68 109 229 50 52 205 239 124 86 150 228 175 199 89 239 151 13 126 99 115 117 214 102 225 121 186 148 92 241 188 127 163 238 69 149 31 147 13 83 82 63 112 133 143 80 247 33 106 143 166 230 236 255 10 234 13 200 235 32 156 24 21 60 197 66 189 81 160 130 105 93 67 189 9 189 33 26 211 149 100 142 86 27 245 102 116 202 80 194 84 11 234 179 80 111 17 106 80 38 233 106 100 67 13 45 168 215 80 76 75 92 211 107 43 207 202 206 77 207 108 241 169 62 204 202 208 129 13 56 67 117 54 230 105 255 247 127 141 89 25 58 176 231 21 179 174 238 133 211 115 175 13 33 42 116 224 218 130 161 58 215 25 233 253 167 222 69 84 232 144 253 153 156 119 94 201 57 222 101 53 248 209 27 34 186 6 160 198 134 83 30 64 229 113 33 228 149 71 183 241 28 149 118 218 56 106 121 80 27 77 106 137 92 106 179 102 189 13 81 217 172 161 68 114 124 201 139 172 252 122 59 71 245 178 180 145 143 136 214 172 119 112 212 237 221 145 72 176 144 230 45 212 118 100 8 64 169 49 159 213 38 63 229 245 32 71 245 245 107 166 114 78 137 45 229 154 203 168 135 80 229 220 76 54 85 126 39 71 45 131 92 110 234 90 46 138 90 168 29 168 242 176 156 200 239 13 46 163 222 37 124 8 142 112 180 161 77 134 238 70 134 104 70 233 134 221 193 103 12 221 35 18 27 108 95 244 85 134 22 189 225 94 134 250 76 153 216 2 46 207 74 111 37 56 42 237 28 70 94 163 108 63 180 201 235 125 34 151 131 242 174 105 232 8 162 70 180 137 117 94 23 81 59 133 43 199 32 192 254 7 53 192 211 134 115 251 48 251 194 27 63 199 60 4 29 114 148 239 14 203 140 49 240 148 115 202 242 190 140 222 21 96 70 129 14 9 114 212 90 99 44 162 74 230 57 77 31 141 38 229 24 181 191 75 248 244 10 1 81 161 3 215 31 153 20 181 114 45 146 174 169 11 32 42 116 224 38 66 164 168 213 27 138 116 69 181 216 110 66 7 54 219 12 213 185 36 75 207 189 154 18 137 237 213 20 57 38 178 50 3 92 201 202 139 62 212 139 89 25 242 208 232 90 86 94 68 13 113 212 234 224 253 97 62 238 82 224 179 80 143 35 67 125 218 4 44 150 54 211 252 9 174 6 231 222 52 253 219 221 143 161 26 160 3 215 185 12 213 185 230 77 255 238 226 20 162 66 135 132 217 150 125 218 185 141 72 121 26 218 197 70 191 161 157 244 115 71 241 48 134 134 187 228 172 239 209 59 95 225 67 112 241 203 158 11 174 179 137 59 18 149 135 230 231 51 64 240 143 139 208 127 232 92 110 239 59 73 232 55 209 155 229 72 159 97 82 0 248 7 106 175 31 174 86 205 72 143 106 208 127 254 15 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 77 114 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 215 154 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 177 190 158 123 0 0 42 109 0 0 31 62 0 0 9 113 0 0 8 117 16 125 111 57 0 0 0 0 0 0 27 241 13 192 213 101 47 91 187 188 110 221 29 229 18 150 183 198 233 53 72 187 149 29 97 73 24 97 155 146 205 162 120 122 246 155 230 166 118 54 232 76 126 126 20 79 13 207 60 59 243 247 250 17 78 219 94 172 181 174 129 145 219 100 179 219 18 70 246 179 178 167 91 194 201 38 180 35 172 211 45 97 219 235 216 126 178 25 217 39 217 71 201 182 35 199 200 38 140 48 194 175 99 114 194 54 57 30 219 30 97 69 185 132 17 254 81 242 180 91 129 175 26 212 121 117 190 155 125 180 149 173 237 35 91 26 97 155 220 214 205 54 153 109 178 201 102 120 178 129 241 30 16 128 94 103 135 7 96 0 48 103 9 192 108 60 53 159 116 5 223 89 254 32 131 224 123 30 88 32 6 7 240 28 172 219 186 208 28 124 75 185 149 167 86 127 182 93 150 90 109 54 139 217 227 117 183 88 4 204 110 181 218 170 44 181 43 138 24 148 102 15 163 239 4 240 249 72 236 94 215 148 9 48 243 110 128 121 109 89 121 230 224 209 157 79 150 22 173 215 173 220 186 115 79 238 76 68 166 149 184 130 93 11 205 144 134 167 1 207 164 242 125 39 117 21 111 67 90 189 97 229 86 122 235 209 237 170 170 169 88 148 80 214 63 125 32 232 41 95 87 222 190 8 32 129 115 75 224 159 54 74 150 196 29 14 109 2 6 148 175 2 40 249 3 203 152 141 47 4 158 92 139 119 254 30 52 198 23 241 222 18 194 241 125 162 71 178 183 74 77 242 7 90 42 49 41 244 222 236 219 208 118 254 125 74 245 6 159 95 110 179 56 37 159 79 246 93 160 144 125 78 169 243 161 3 1 19 105 16 217 134 183 143 114 142 133 128 44 244 42 0 44 194 81 74 138 164 89 37 187 169 162 218 132 45 194 100 89 104 201 201 49 127 119 56 139 168 148 153 114 9 221 87 178 109 44 89 120 224 76 30 61 48 164 131 39 151 153 208 40 108 230 213 41 68 106 116 60 152 86 21 160 90 212 65 2 27 106 184 36 38 50 26 70 50 25 177 8 93 194 98 225 215 26 108 162 0 137 216 23 83 6 56 179 4 52 14 193 112 154 96 16 11 150 74 22 96 134 114 165 216 177 3 32 47 72 95 168 95 36 235 172 110 151 100 119 143 41 160 133 185 160 103 63 17 2 145 251 217 234 38 89 214 64 2 245 158 80 235 41 115 184 90 101 239 251 76 198 51 76 203 183 217 202 110 21 89 61 158 249 30 143 83 29 128 135 213 90 86 16 207 147 90 230 104 48 173 104 243 184 189 126 146 246 66 14 171 173 172 88 37 128 71 173 165 80 29 64 215 170 234 170 81 130 31 243 168 41 90 93 163 49 55 52 219 251 250 250 128 253 108 59 127 120 236 9 63 93 197 199 90 94 71 187 84 104 40 144 156 78 183 219 101 42 145 157 30 122 56 117 153 0 199 182 246 64 215 156 101 176 51 247 0 61 33 30 130 217 30 107 133 214 90 197 211 92 170 14 133 135 214 108 207 201 81 5 224 161 49 219 175 8 242 119 30 92 118 85 0 93 61 99 68 174 243 144 59 174 8 242 215 80 234 181 249 63 245 154 22 225 17 83 35 5 121 216 36 159 93 114 94 22 86 209 213 35 141 26 252 127 242 176 143 41 27 215 149 12 18 241 208 17 143 15 59 209 53 30 130 249 125 159 116 38 52 85 242 231 62 170 87 223 149 62 173 67 25 242 125 109 188 79 243 247 231 250 244 106 75 197 184 143 73 163 36 197 49 39 211 232 182 183 255 183 5 113 255 225 245 121 99 166 97 130 135 175 217 217 16 207 147 106 43 186 170 42 242 240 183 171 4 240 160 208 154 177 74 254 173 171 141 106 81 113 220 75 151 125 70 189 196 113 163 180 23 114 220 112 220 151 120 168 6 56 238 138 130 82 211 184 30 86 91 109 92 15 181 15 231 126 81 213 27 206 61 198 227 186 115 31 231 49 225 220 199 117 157 112 238 113 30 234 11 206 125 84 143 127 57 247 75 194 126 236 220 227 60 38 156 251 40 141 155 206 61 198 67 61 192 185 107 205 62 185 233 195 62 13 208 117 231 41 156 198 207 133 130 108 236 207 251 135 251 116 49 239 211 234 31 142 251 98 225 223 112 220 151 59 172 106 128 227 174 117 184 238 90 108 234 88 182 244 207 142 91 255 15 199 132 68 174 116 134 107 142 41 198 227 186 211 25 215 99 194 233 196 121 92 235 228 163 60 110 118 242 24 15 141 57 214 245 146 144 7 22 254 184 53 191 213 97 162 60 156 142 177 182 119 122 178 113 185 210 136 135 187 161 101 140 71 69 67 75 156 71 178 245 226 58 71 164 56 172 150 18 85 0 209 255 54 107 72 66 53 120 69 95 229 129 157 202 57 230 57 211 137 7 45 141 153 44 238 54 143 195 121 86 221 112 103 192 138 150 215 171 2 232 122 171 51 68 61 121 204 219 95 227 17 239 192 241 58 139 118 78 255 88 153 77 132 206 196 151 213 4 208 50 218 69 203 133 58 196 215 158 250 6 212 205 123 67 193 0 246 3 212 137 129 223 158 194 179 95 12 136 129 190 87 102 173 197 141 168 201 112 16 51 111 194 59 208 202 20 43 19 59 191 254 75 168 91 80 2 107 223 171 135 192 107 7 32 240 72 135 24 120 82 207 223 4 30 198 118 72 76 20 126 166 52 177 147 242 137 157 79 189 6 107 94 221 50 204 5 145 192 99 221 67 130 43 119 244 228 24 152 31 249 13 133 216 217 51 67 236 220 131 175 67 252 96 202 58 56 136 231 25 62 143 188 14 117 121 71 240 254 2 231 210 203 57 159 128 29 92 233 41 152 21 25 51 220 62 20 114 115 55 139 155 95 90 29 34 199 64 51 163 144 185 106 30 197 19 153 38 158 54 97 11 120 2 229 237 83 32 188 253 10 225 38 173 136 249 77 70 113 243 46 101 110 155 188 184 135 53 125 77 209 142 242 85 126 191 67 220 220 93 12 250 162 189 48 248 157 67 172 242 231 189 152 107 35 36 182 126 1 30 127 119 144 85 190 184 13 71 18 60 48 199 17 150 240 165 39 224 228 189 221 226 163 39 202 185 250 240 116 61 205 36 128 189 90 200 42 191 7 66 83 198 29 48 248 171 233 10 187 251 127 196 53 27 139 193 147 212 138 120 241 71 52 230 186 252 120 31 192 198 93 236 48 8 217 185 202 120 187 186 221 67 14 37 183 68 150 26 101 175 47 55 191 188 122 5 206 44 21 16 167 36 63 56 69 39 91 254 242 17 214 216 227 199 115 46 91 78 229 53 245 16 103 212 248 172 173 0 146 12 96 200 50 70 216 27 243 15 199 123 18 251 212 134 55 56 208 24 226 65 56 42 78 124 216 221 83 255 50 13 63 10 62 24 128 94 204 181 157 234 133 53 62 183 133 52 193 252 61 252 189 225 142 45 144 254 149 238 108 72 210 114 61 158 102 233 252 84 34 3 50 177 32 132 105 35 53 128 104 88 121 99 106 47 164 63 51 55 42 216 252 112 117 11 172 229 143 139 192 184 242 8 158 7 155 131 127 18 17 191 19 223 5 193 248 137 249 136 13 224 153 6 83 58 107 48 255 254 108 208 106 17 55 13 229 7 196 109 10 62 223 207 114 94 238 242 217 189 14 248 127 28 68 97 126 190 125 216 210 143 253 16 245 225 249 147 48 255 91 7 192 152 17 221 29 204 58 177 73 220 190 151 166 88 216 12 137 79 255 115 96 156 185 155 21 26 108 136 29 66 126 219 120 197 167 63 243 160 146 31 245 160 252 198 204 112 103 67 253 105 23 151 106 224 182 145 26 64 243 235 149 188 14 25 139 95 245 161 6 196 237 151 107 128 181 254 238 135 106 2 53 48 121 164 6 104 23 84 68 78 196 89 29 165 15 160 152 250 208 34 186 218 75 132 86 182 85 96 194 136 179 130 72 73 12 69 42 36 98 137 240 35 244 242 37 114 152 227 155 243 87 35 15 67 217 165 98 129 213 231 254 188 112 35 136 79 4 60 191 161 143 60 71 82 46 70 29 111 214 190 30 93 0 70 200 93 31 82 122 233 112 67 81 3 138 251 238 243 249 37 47 95 218 80 111 8 35 104 132 208 79 29 162 127 4 192 224 221 79 13 68 95 102 84 137 113 127 31 196 62 154 45 165 40 127 142 49 173 178 146 193 161 63 200 224 255 99 134 146 20 231 87 215 40 238 101 14 78 221 18 105 99 168 11 61 17 247 228 106 7 101 59 228 115 206 187 28 229 31 35 250 179 191 149 137 254 51 71 72 121 243 240 204 47 227 147 233 236 5 16 60 171 248 156 126 154 199 139 67 249 219 97 118 117 77 85 22 102 252 226 105 74 201 249 124 200 205 187 222 61 63 5 154 119 164 18 86 249 0 228 226 245 255 8 43 125 28 104 43 246 97 194 218 111 131 123 241 186 155 176 148 26 104 194 43 13 15 33 115 22 32 87 86 74 88 245 124 216 136 216 87 9 91 234 133 173 136 125 155 176 252 231 169 142 216 94 194 214 164 195 179 136 29 37 44 241 56 214 37 8 253 132 125 190 15 126 129 74 242 237 208 197 107 224 55 136 225 63 117 0 214 217 224 77 196 248 230 68 150 27 142 35 198 183 197 54 62 15 239 34 214 75 88 173 22 6 113 4 194 103 59 121 243 88 50 254 238 131 116 131 230 37 12 53 54 221 67 88 253 239 25 78 93 77 124 127 33 199 201 230 32 198 117 93 255 45 118 23 170 200 243 77 57 198 112 235 54 115 19 97 183 239 97 149 136 209 220 5 30 90 206 112 194 156 197 91 69 85 55 107 68 140 231 120 232 155 12 127 26 146 205 181 47 90 194 238 7 152 165 172 163 244 210 220 105 54 253 217 7 52 199 57 198 117 157 108 195 126 35 219 253 38 172 79 159 195 237 202 176 74 77 14 187 201 34 121 70 150 44 208 134 135 31 42 59 37 233 209 7 33 14 169 124 209 38 146 113 18 173 90 89 220 141 242 167 101 151 62 186 118 197 159 133 50 166 209 254 115 161 195 135 68 229 182 6 98 73 46 255 244 3 131 178 251 142 91 134 46 217 105 192 181 188 8 189 201 161 197 195 179 120 173 228 117 57 92 77 190 212 176 178 69 29 126 175 228 211 21 53 58 252 110 175 182 216 237 242 235 106 36 111 147 236 55 228 219 237 50 74 108 147 252 205 248 158 167 153 68 138 132 69 139 110 103 243 103 97 153 149 189 164 48 239 16 28 166 173 179 20 91 49 217 36 62 174 8 241 136 254 87 37 145 32 92 122 227 207 67 124 254 7 0 12 0 235 117 249 249 94 179 188 38 114 202 39 70 249 123 114 202 39 102 3 183 84 182 246 41 211 235 240 155 173 199 125 201 38 252 60 60 245 164 143 223 212 180 240 31 243 247 128 108 74 182 145 231 29 217 132 19 70 246 145 219 39 249 125 100 27 121 182 201 38 91 42 139 186 201 237 35 155 28 219 132 147 227 145 77 54 225 228 55 217 132 147 125 100 191 100 19 222 17 78 126 31 217 94 146 253 146 77 54 121 74 182 71 184 192 189 173 156 30 63 252 177 139 108 182 118 246 50 60 97 101 244 146 12 54 65 195 62 74 54 158 224 129 47 160 28 116 81 77 139 19 66 92 240 223 69 72 243 207 225 255 23 232 73 240 47 134 255 11 80 181 19 55 188 53 70 91 24 198 179 59 95 129 154 144 115 115 199 88 125 233 163 120 173 155 32 224 17 82 228 142 238 152 37 174 55 35 174 32 57 232 10 183 252 128 52 2 145 225 221 79 147 166 121 52 15 252 41 222 182 226 23 88 31 240 178 111 31 35 143 187 31 221 51 242 238 116 165 0 119 208 253 240 103 46 144 215 73 17 33 149 111 144 122 242 20 188 171 96 26 153 255 202 212 132 169 232 201 182 104 142 166 236 215 135 245 141 233 242 186 199 96 138 155 161 62 9 245 30 172 111 129 250 20 212 173 216 191 9 106 25 234 27 50 223 63 219 0 245 3 153 137 129 223 64 45 101 38 62 86 12 245 67 153 201 227 95 134 250 73 114 6 166 42 183 121 241 24 227 221 106 92 145 116 117 204 88 37 39 184 105 0 47 130 143 159 145 23 97 154 90 155 143 6 99 60 36 71 125 198 84 34 90 224 37 132 245 214 153 235 167 127 4 83 212 96 93 157 254 199 75 127 128 90 240 84 133 239 202 177 246 98 189 200 223 253 248 94 240 88 54 163 254 253 111 31 240 249 19 112 63 66 106 108 62 171 25 159 157 170 174 68 77 77 159 202 75 236 58 139 207 205 27 120 60 71 102 129 5 175 205 99 21 227 241 136 54 101 152 106 116 116 217 41 186 44 30 187 161 126 126 158 71 193 159 227 31 235 124 229 124 196 203 248 234 83 204 9 77 95 161 139 92 143 245 237 200 75 5 214 183 166 93 103 191 1 245 109 233 138 237 175 206 243 183 119 141 191 109 136 35 248 171 127 230 252 95 219 161 174 125 246 119 223 73 229 249 116 181 185 218 129 141 102 155 207 38 198 103 88 209 85 57 238 75 196 66 129 206 128 164 233 230 37 102 15 99 29 64 221 9 29 222 139 245 17 124 39 248 190 207 242 79 193 255 162 255 236 207 249 80 37 214 30 172 123 112 78 199 159 14 228 124 234 30 75 63 139 122 233 115 209 244 121 131 173 151 74 174 23 45 149 136 21 50 23 205 145 44 39 226 188 117 88 183 97 109 235 71 232 229 206 255 234 230 110 75 63 119 97 45 252 197 214 211 190 153 99 190 70 168 239 184 162 171 255 233 41 231 63 144 19 65 79 199 213 68 76 155 88 21 212 195 150 158 108 159 17 250 232 192 126 35 214 189 87 124 215 214 145 208 141 15 235 206 153 183 94 253 236 188 110 14 253 39 31 249 81 87 219 241 221 154 94 150 115 117 72 53 162 87 115 245 71 54 29 200 213 57 62 106 140 241 254 120 140 249 97 129 147 7 55 75 224 3 242 217 7 100 192 119 112 211 1 62 222 102 68 52 217 124 108 137 37 244 171 203 25 248 96 227 195 62 145 19 236 253 131 157 3 118 99 191 201 242 187 102 172 119 97 189 152 239 237 28 208 128 245 78 172 119 96 45 124 75 228 78 225 251 118 238 236 38 61 69 127 132 218 157 101 148 41 193 235 235 11 7 90 252 109 146 228 111 11 170 131 121 254 133 110 114 115 120 194 129 254 71 78 92 29 131 108 177 230 128 237 217 194 28 149 1 186 47 27 146 163 74 97 140 236 252 185 57 170 146 186 54 4 139 36 157 50 18 95 30 165 164 48 71 105 72 54 71 174 80 193 62 129 155 155 195 27 58 238 63 154 74 152 234 152 82 16 8 221 167 210 239 43 228 41 54 135 232 139 124 17 30 79 41 242 104 203 177 80 203 254 3 189 203 124 244 103 199 255 147 219 251 100 171 219 243 218 79 221 222 35 103 70 97 37 9 143 36 119 241 119 223 96 50 242 246 61 77 200 133 183 97 178 185 236 174 18 220 231 157 65 96 199 41 36 247 241 71 171 249 72 29 192 74 217 39 29 239 72 123 122 63 225 154 14 73 193 110 218 33 110 134 250 121 71 225 51 253 103 59 92 211 198 72 124 144 118 72 17 67 157 118 116 248 204 215 6 40 170 153 26 164 29 82 204 80 191 232 168 46 93 19 172 69 134 160 67 182 48 212 175 59 94 150 174 216 245 85 68 133 14 41 97 168 159 115 28 103 230 173 215 246 114 84 218 129 60 1 14 230 109 114 242 199 236 167 221 63 118 77 71 186 78 68 104 135 148 117 128 127 150 254 170 52 50 149 84 140 182 247 118 210 11 179 210 12 192 80 89 103 43 71 173 243 107 137 152 106 170 90 66 142 67 168 215 53 107 2 150 32 56 42 237 148 115 212 138 144 58 169 196 66 90 76 185 60 175 133 90 193 81 203 186 78 43 9 51 79 145 133 90 137 179 126 52 5 91 198 152 46 79 124 56 171 135 163 86 101 81 35 202 164 121 9 217 66 245 114 212 173 253 225 71 76 53 190 68 145 133 90 133 188 134 148 49 186 207 93 227 181 26 245 74 119 218 203 122 101 153 145 161 178 78 141 208 144 174 107 250 53 13 213 114 71 41 3 105 71 252 210 18 42 205 131 220 81 88 50 172 67 229 249 146 201 184 18 145 227 163 31 42 175 158 207 90 237 139 197 116 197 48 78 4 101 106 43 23 161 105 6 229 179 178 52 218 128 179 30 85 12 45 165 71 23 21 97 205 186 77 120 158 46 39 87 60 239 61 212 70 84 249 97 197 48 229 248 251 174 240 79 212 38 68 237 214 226 49 37 47 61 11 117 59 242 26 129 51 153 101 79 177 80 119 8 84 48 173 13 212 157 232 13 225 168 174 38 151 104 181 81 119 161 83 66 246 138 47 171 207 66 221 45 212 160 78 210 248 181 166 134 102 212 107 32 170 37 54 244 122 29 117 20 207 156 115 55 49 251 169 55 51 152 135 160 3 91 92 134 234 108 125 51 109 95 250 30 71 165 29 216 253 51 84 231 86 32 179 111 224 207 136 10 29 216 53 51 212 98 99 60 79 42 69 133 253 19 162 66 135 220 216 1 168 165 95 40 25 91 22 16 77 0 116 203 197 19 0 237 220 196 81 75 167 78 203 249 132 194 80 229 44 170 76 110 70 84 195 140 169 218 42 234 201 44 234 73 178 135 163 150 1 42 196 214 37 88 11 245 150 44 170 174 38 134 87 80 79 101 81 79 145 86 84 3 75 228 171 106 88 152 245 214 14 216 166 148 125 179 18 212 218 163 200 75 198 204 54 200 28 149 118 110 227 168 158 119 80 33 153 191 143 74 247 205 211 161 144 191 135 117 110 71 207 235 84 78 171 75 9 229 162 123 237 69 47 151 116 13 64 141 181 100 179 15 157 146 27 87 222 41 233 5 0 71 165 157 54 142 90 233 215 198 146 90 98 41 101 91 179 222 129 168 108 214 64 34 153 186 156 29 216 54 92 160 62 79 218 57 170 135 165 195 124 164 183 102 189 147 163 150 116 209 85 72 94 229 22 234 93 200 16 128 210 32 53 168 77 254 139 215 187 57 170 183 79 51 213 33 53 122 57 135 94 68 189 7 85 206 15 27 214 85 126 47 71 45 135 61 138 169 107 75 198 108 161 238 71 149 135 148 68 106 35 15 221 39 124 8 14 127 180 225 117 134 14 32 67 52 83 118 193 174 231 223 12 221 143 179 134 153 151 175 207 250 0 207 67 229 198 56 232 97 72 93 204 0 116 15 143 121 8 58 112 103 192 80 157 187 132 217 95 255 254 91 152 243 160 67 30 226 168 245 198 184 20 151 205 33 77 31 11 39 149 40 21 252 187 83 211 93 63 206 10 29 184 33 16 57 111 245 230 32 83 85 43 18 27 116 224 50 131 161 58 151 28 153 186 6 31 162 66 7 238 95 178 168 43 247 50 153 243 191 29 70 84 232 144 14 177 31 2 71 217 240 6 31 162 74 218 132 162 95 67 61 36 210 70 20 22 41 215 80 253 136 26 129 196 86 152 117 33 55 116 50 212 95 148 139 157 232 162 15 209 219 29 142 74 59 93 92 67 206 205 225 185 95 190 248 56 215 16 237 144 238 108 98 51 70 15 229 29 214 98 232 48 159 213 185 175 203 156 127 57 45 244 250 114 154 244 136 237 11 3 92 217 190 44 204 26 224 168 85 144 216 198 10 219 151 5 212 35 28 181 214 127 52 196 199 189 28 73 45 212 94 100 40 168 77 192 170 114 125 63 20 204 186 215 234 245 237 108 233 64 16 93 25 58 112 139 203 80 157 219 221 204 15 119 124 27 53 4 29 184 116 102 168 206 101 116 230 185 39 166 16 21 58 112 207 192 25 186 114 255 144 121 238 12 36 0 159 36 5 105 7 46 212 225 250 194 51 87 193 24 26 233 84 114 190 71 111 166 69 70 129 235 105 246 185 224 210 157 184 165 176 50 124 33 123 1 65 175 223 225 196 26 222 208 185 220 158 215 159 128 126 51 189 255 150 130 134 73 1 224 205 75 176 25 245 194 5 240 43 82 119 220 160 111 254 15).! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:40'!macAsyncFilePrimsFile	^ '/*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>#include "sq.h"/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpen(&pb, false);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBRead(&state->pb, true);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWrite(&state->pb, true);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/13/1998 08:59'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Macintosh virtual machine.	Many primitives are "stubbed-out", meaning that if they are invoked from the	image they will return a "primitive failed" error. Among the stubbed out primitives	are those that support sound input and output, serial and MIDI ports, networking,	joystick, and file directory operations. The basic file read/write operations are	NOT stubbed out, although they could be as long as the image loading mechanism	still works. In this case, you''ll need to modify the method "openSourceFiles"	in the image to skip opening the changes and sources files at startup time.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been implemented, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioBeep()			-- make a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- some other behavior appropriate to this platform							-- (if this is a noop you won''t be able to quit from Squeak)		ioRelinquishProcessorForMicroseconds()							-- called when Squeak is idle to return time to the OS  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that that directory is the default working directory	for file operations. The "shortImageName" is used to display the image file	name (but not its full path) in the title bar of the Macintosh window.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- return the number of seconds since Jan 1, 1901	   						-- may return 0, but then the current date and time	   						-- will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqFilePrims.c	-- file primitives (can be stubbed out)		sqMacMinimal.c	-- this file		sqMiscPrims.c	-- automatically generated primitives (optional)	plus the appropriate support libraries. To build a PowerPC	virtual machine using CodeWarrior 8, these are:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		MathLib		MWCRuntime.Lib*/#include <MacHeaders.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#define STUBBED_OUT { success(false); }/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	success(false);  /* stubbed out */}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* Process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	Cursor macCursor;	int i;	for (i = 0; i < 16; i++) {		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top) - 20;		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 20, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	return 0;}int clipboardSize(void) {	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	return 0;}/*** Directory ***/int dir_Delimitor(void) {	return '':'';}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												{/* noop */}/*** Joystick Stubs ***/int joystickRead(int stickIndex)											STUBBED_OUT/*** MIDI Stubs ***/int sqMIDIClosePort(int portNum)											STUBBED_OUTint sqMIDIGetClock(void)													STUBBED_OUTint sqMIDIGetPortCount(void)												STUBBED_OUTint sqMIDIGetPortDirectionality(int portNum)								STUBBED_OUTint sqMIDIGetPortName(int portNum, int namePtr, int length)					STUBBED_OUTint sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate)	STUBBED_OUTint sqMIDIParameter(int whichParameter, int modify, int newValue)			STUBBED_OUTint sqMIDIPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time)	STUBBED_OUT/*** Networking Stubs ***/int sqNetworkInit(int resolverSemaIndex)									STUBBED_OUTvoid sqNetworkShutdown(void)												STUBBED_OUTvoid sqResolverAbort(void)													STUBBED_OUTvoid sqResolverAddrLookupResult(char *nameForAddress, int nameSize)			STUBBED_OUTint sqResolverAddrLookupResultSize(void)									STUBBED_OUTint sqResolverError(void)													STUBBED_OUTint sqResolverLocalAddress(void)											STUBBED_OUTint sqResolverNameLookupResult(void)										STUBBED_OUTvoid sqResolverStartAddrLookup(int address)									STUBBED_OUTvoid sqResolverStartNameLookup(char *hostName, int nameSize)				STUBBED_OUTint sqResolverStatus(void)													STUBBED_OUTvoid sqSocketAbortConnection(SocketPtr s)									STUBBED_OUTvoid sqSocketCloseConnection(SocketPtr s)									STUBBED_OUTint sqSocketConnectionStatus(SocketPtr s)									STUBBED_OUTvoid sqSocketConnectToPort(SocketPtr s, int addr, int port)					STUBBED_OUTvoid sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex)							STUBBED_OUTvoid sqSocketDestroy(SocketPtr s)											STUBBED_OUTint sqSocketError(SocketPtr s)												STUBBED_OUTvoid sqSocketListenOnPort(SocketPtr s, int port)							STUBBED_OUTint sqSocketLocalAddress(SocketPtr s)										STUBBED_OUTint sqSocketLocalPort(SocketPtr s)											STUBBED_OUTint sqSocketReceiveDataAvailable(SocketPtr s)								STUBBED_OUTint sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize)			STUBBED_OUTint sqSocketRemoteAddress(SocketPtr s)										STUBBED_OUTint sqSocketRemotePort(SocketPtr s)											STUBBED_OUTint sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize)				STUBBED_OUTint sqSocketSendDone(SocketPtr s)											STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** Serial Port Functions Stubs ***/int serialPortClose(int portNum)											STUBBED_OUTint serialPortOpen(  int portNum, int baudRate, int stopBitsType,  int parityType, int dataBits, int inFlowCtrl, int outFlowCtrl,  int xOnChar, int xOffChar)												STUBBED_OUTint serialPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint serialPortWriteFrom(int portNum, int count, int bufferPtr)				STUBBED_OUT/*** Sound Output Stubs ***/int snd_AvailableSpace(void)												STUBBED_OUTint snd_PlaySamplesFromAtLength(  int frameCount, int arrayIndex, int startIndex)							STUBBED_OUTint snd_InsertSamplesFromLeadTime(  int frameCount, int srcBufPtr, int samplesOfLeadTime)						STUBBED_OUTint snd_PlaySilence(void)													STUBBED_OUTint snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_Stop(void)															STUBBED_OUT/*** Sound Input Stubs ***/int snd_SetRecordLevel(int level)											STUBBED_OUTint snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_StopRecording(void)													STUBBED_OUTdouble snd_GetRecordingSampleRate(void)										STUBBED_OUTint snd_RecordSamplesIntoAtLength(  int buf, int startSliceIndex, int bufferSizeInBytes)						STUBBED_OUT/*** Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void)			STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUTint primReverbSoundapplyReverbTostartingAtcount(void)						STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUT/*** Old Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtpan(void)						STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primWaveTableSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUT/*** Main ***/void main(void) {	sqImageFile f;	int reservedMemory, availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	SetUpMenus();	SetUpWindow();	SetUpPixmap();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following to open the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:12'!macSerialAndMIDIPortFile	^ '#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <Serial.h>#include <Strings.h>#include "sq.h"/*** Constants ***/#define INPUT_BUF_SIZE 1000/*** Imported Variables ***/extern int successFlag;/*** Local Variables ***/short inRefNum[4] = {0, 0, 0, 0};short outRefNum[4] = {0, 0, 0, 0};char inputBuffer[4][INPUT_BUF_SIZE];/*** Private Functions ***/int portCount(void);int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);int portCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			strcpy(portName, p2cstr(*(serialPtr->name)));			strcpy(inName, p2cstr(*(serialPtr->inputDriverName)));			strcpy(outName, p2cstr(*(serialPtr->outputDriverName)));			c2pstr((void *) *(serialPtr->name));			c2pstr((void *) *(serialPtr->inputDriverName));			c2pstr((void *) *(serialPtr->outputDriverName)); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	osErr = OpenDriver(c2pstr(outName), &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	osErr = OpenDriver(c2pstr(inName), &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	return serialPortClose(portNum);}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return portCount();}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */	success((portNum == 0) || (portNum == 1));	return 3;}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int count;	if ((portNum > 4) || (portNum >= portCount())) {		return success(false);	}	portNames(portNum, userName, inName, outName);	count = strlen(userName);	success(count > 0);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	return serialPortWriteFrom(portNum, count, bufferPtr);}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:14'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	Cursor macCursor;	int i;	for (i = 0; i < 16; i++) {		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 750000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:38'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built from four header and twelve source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- Mac primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	interp.c				-- automatically generated code for the virtual machineThe platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, May 8, 1998'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:11'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primStringcomparewithcollated(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);'.! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:05'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. stop stepping if realJoystickIndex is nil; that means we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt m mCenter r scaledPt |	realJoystickIndex ifNil: [^ self stopStepping].	threshold _ 30.	joyMax _ 350.	joyPt _ Sensor joystickXY: realJoystickIndex.	joyPt x abs < threshold ifTrue: [joyPt _ 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt _ joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue _ joyPt.	m _ handleMorph.	mCenter _ m center.	r _ m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt _ r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:00'!stepTime	^ 0! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set X range' action: #setXRange.	aCustomMenu add: 'set Y range' action: #setYRange.	autoCenter		ifTrue: [aCustomMenu add: 'turn auto-center off' action: #toggleAutoCenter]		ifFalse: [aCustomMenu add: 'turn auto-center on' action: #toggleAutoCenter].	realJoystickIndex		ifNil: [aCustomMenu add: 'track real joystick' action: #trackRealJoystick]		ifNotNil: [aCustomMenu add: 'stop tracking joystick' action: #stopTrackingJoystick].! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex _ nil.	self stopStepping.! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:59'!trackRealJoystick	| s |	s _ FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex _ Number readFromString: s.	self startStepping.! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 5/29/1998 17:12'!playURLNamed: urlString	| titleString |	titleString _ urlString		copyFrom: (urlString findLast: [:c | c=$/]) + 1		to: urlString size.	ScorePlayerMorph		openOn: (self scoreFromURL: urlString)		title: titleString.! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/22/1998 14:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !!MappedTabsMorph methodsFor: 'all' stamp: 'sw 6/1/1998 14:16'!addButtonShowing: aString named: aName selector: aSymbol arguments: argList padding: padding atIndex: anIndex	| bb |	bb _ super addButtonShowing: aString named: aName 			selector: aSymbol arguments: argList padding: padding atIndex: anIndex.	tabsInOrder ifNil: [tabsInOrder _ OrderedCollection new].	tabsInOrder addLast: bb.	^ bb! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 6/15/1998 12:18'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self boundsInWorld containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:])			ifFalse: [owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				evt hand world displayWorld.				owner invokeItem: self]]].! !!MenuMorph methodsFor: 'control' stamp: 'di 6/22/1998 15:15'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MessageSet methodsFor: 'message list' stamp: 'wod 6/16/1998 15:08'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'contents' stamp: 'di 6/26/1998 09:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	^ true! !!Metaclass methodsFor: 'accessing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!Morph methodsFor: 'accessing' stamp: 'sw 6/15/1998 15:25'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(doGrab:with:				'Pick up')		(doMenu:with:				'Menu')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:54'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	^ color isColor and: [color alpha < 1.0]! !!Morph methodsFor: 'copying' stamp: 'tk 5/22/1998 12:17'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream"	self allMorphsDo: [:m | m prepareToBeSaved].		"Actors fix open scriptEditors"	^ super veryDeepCopy ! !!Morph methodsFor: 'copying' stamp: 'tk 5/22/1998 12:17'!veryDeepCopyWithoutCostumee	| hold copy holdState |	hold _ costumee.	holdState _ self valueOfProperty: #actorState.	holdState ifNotNil: [self removeProperty: #actorState].	costumee _ nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy setProperty: #actorState toValue: (holdState copyWithPlayerReferenceNilled)].	costumee _ hold.	holdState ifNotNil: [self setProperty: #actorState toValue: holdState].	^ copy! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/29/1998 15:39'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 6/5/1998 23:22'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition aWorld |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	(aWorld _ self world) ifNotNil:		[aWorld startSteppingSubmorphsOf: newMorph]! !!Morph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:10'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'jm 5/30/1998 21:06'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	submorphs isEmpty		ifTrue: [self drawOn: aCanvas]		ifFalse: [			(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].			submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'geometry' stamp: 'jm 5/29/1998 15:42'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		submorphs size > 0 ifTrue: [			submorphs do: [:m | fullBounds _ fullBounds quickMerge: m fullBounds]]].	^ fullBounds! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 18:00'!printStructureOn: aStream indent: tabCount	tabCount timesRepeat: [aStream tab].	self printOn: aStream.	aStream cr.	self submorphsDo: [:m | m printStructureOn: aStream indent: tabCount + 1].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s _ WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!Morph methodsFor: 'e-toy commands' stamp: 'tk 6/21/1998 10:07'!hide	"Move this morph way, way offstage!!  Remember its coordinates in relative form, in case window moves while hidden."	owner ifNil: [^ self].	self position < (5000@5000) ifTrue: [		self setProperty: #relPosition toValue: (self position - owner position).		self position: self position + (1000000@100000)].! !!Morph methodsFor: 'e-toy commands' stamp: 'tk 6/25/1998 16:10'!show	"Make sure this morph is on-stage."	| saved |	self world ifNil: [^ self].	"would like to set bounds, but we must be in a world"	(self fullBounds intersects: self world bounds) ifFalse: [		(saved _ self valueOfProperty: #relPosition) ifNil: [			"backward compatibility -- remove later"			saved _ self position - (1000000@100000) - owner position].		self position: saved + owner position.		self wrap].  "be sure I'm on-stage"! !!Morph methodsFor: 'other' stamp: 'di 6/17/1998 12:44'!flash	| w |	w _ self world.	w ifNotNil:		[Display flash: (((self transformFrom: w) invertRect: bounds)								translateBy: w viewBox origin)].! !!Morph methodsFor: 'other' stamp: 'tk 5/26/1998 15:33'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream |	aFileName _ ('my ', self class name) asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name? (".morph" will be added to end)' 			initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: aFileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color _ aColor.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 6/26/1998 16:05'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 6/10/1998 17:42'!tearOffTile	| aValue |	costumee ifNotNil: [^ costumee tearOffTileForSelf].		(aValue _ self valueAsConstant) ifNotNil:		[^ self world primaryHand attachMorph: aValue newTileMorphRepresentative]. 	^ self assuredCostumee tearOffTileForSelf! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 6/17/1998 16:17'!addDebuggingItemsTo: aMenu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: aHandMorph.	subMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	subMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[subMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	subMenu add: 'browse morph class' action: #browseMorphClass.	costumee ifNotNil:		[subMenu add: 'inspect player' action: #inspectCostumee.		World ifNil: [subMenu add: 'inspect player (morphic)' action: #inspectArgumentsCostumeeInMorphic].		subMenu add: 'browse player class' action: #browsePlayerClass].	subMenu add: 'make own subclass' action: #subclassMorph.	subMenu add: 'internal name' action: #nameMorph.	subMenu add: 'save morph in file' action: #saveOnFile.	subMenu defaultTarget: self.	subMenu add: 'edit balloon help' action: #editBalloonHelpText.	subMenu add: 'temp command' action: #tempCommand.	aMenu add: 'debug...' subMenu: subMenu! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/30/1998 17:47'!usableDuplicate	^ self usableDuplicateIn: self world! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/30/1998 17:45'!usableDuplicateIn: aWorld	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	costumee ifNotNil:		[newPlayer _ costumee duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"		newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ aWorld allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph removeProperty: #partsDonor.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [aWorld flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 6/15/1998 15:14'!addFontHandlesTo: aHalo box: box	"Add handles for controlling font, style, and emphasis choices to the halo"	aHalo addHandleAt: (box bottomLeft + (18@0)) color: Color lightGreen on: #mouseDown send: #chooseFont to: self.	aHalo addHandleAt: (box bottomLeft + (36@0)) color: Color lightRed on: #mouseDown send: #chooseStyle to: self.	aHalo addHandleAt: (box bottomRight - (18@0)) color: Color lightBrown darker on: #mouseDown send: #chooseEmphasis to: self.! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 6/10/1998 17:33'!valueAsConstant	"If the receiver can be perceived by the end-user as bearing a data value of any type other than player-reference, return the literal representing its value at this very moment -- for the purpose of a value-tile being constructed."	^ nil! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/29/1998 21:28'!newBounds: bounds color: color	^ (self new privateBounds: bounds) privateColor: color! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:16'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:20'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!NewParagraph methodsFor: 'composition' stamp: 'di 6/22/1998 12:37'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						hitCR ifTrue:							["If text ends with CR, add a null line at the end"							((lineY + lineHeightGuess) <= container bottom) ifTrue:								[row _ container rectanglesAt: lineY height: lineHeightGuess.								row size > 0 ifTrue:									[line _ (TextLine start: charIndex stop: charIndex-1										internalSpaces: 0 paddingWidth: 0)									rectangle: row first;									lineHeight: lineHeightGuess baseline: textStyle baseline.									lines addLast: line]]].						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/22/1998 12:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!Object methodsFor: 'accessing' stamp: 'jm 6/1/1998 12:41'!do: aBlock	"Obsolete!! Replaced by Object>in:. Apply the given block to the receiver, as if the receiver were contained in a collection with itself as the only element."	"Note: Calling this method 'do:' turned out to mask errors. For example, an initialized instance variable will respond to 'do:', passing nil as an argument. This method will be entirely removed in the future."	self notify:'Only collections should respond to "do:". The "do:" method in Object will soon be removed; clients depending on it should use "in:" instead. If you get this message in system code, please report it to johnm@wdi.disney.com. Proceed from this notifier to get the old behavior.'.	^ self in: aBlock! !!Object methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:51'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'copying' stamp: 'tk 6/23/1998 11:38'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	^ SmartRefStream new veryDeepCopy: self! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!modelWakeUp	"A window with me as model is being entered.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'private' stamp: 'di 5/28/1998 12:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System error handling failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		20 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	Smalltalk isMorphic ifTrue:		[^ World install "To init hand events and redisplay world"].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting' stamp: 'jm 6/1/1998 12:58'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ (OrderedCollection new: 1) add: self; yourself! !!PWS class methodsFor: 'HTTPcodes' stamp: 'tk 6/24/1998 16:24'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body></html>'! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 6/11/1998 11:25'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting.				self setAction: #paint:]].! !!Paragraph methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:48'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'composition' stamp: 'jm 5/29/1998 14:48'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 6/26/1998 15:04'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesAndSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 5/28/1998 11:31'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!Parser methodsFor: 'scanning' stamp: 'sn 9/19/97 19:32'!advance    | this |    prevMark _ hereMark.    prevToken _ "Now means prev size"        self previousTokenSize.    this _ here.    here _ token.    hereType _ tokenType.    hereMark _ mark.    self scanToken.    ^this! !!Parser methodsFor: 'private' stamp: 'sn 9/19/97 19:31'!previousTokenSize    "Answer the size of the previous token. Bugfix for Strings."    hereType == #number ifTrue: [^mark - prevMark].    hereType == #string ifTrue: [^here size + 2].    "One for eachsingle quote"    ^here size! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 6/30/1998 09:15'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[^ root veryDeepCopy].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/31/1998 00:21'!wantsDroppedMorph: aMorph event: evt	^ (self openToDragNDrop and: [self isPartsBin not]) and: [self bounds containsPoint: evt cursorPoint]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/8/1998 11:41'!addCustomMenuItems: menu hand: aHandMorph	| subMenu prefix |	super addCustomMenuItems: menu hand: aHandMorph.	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack].		subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	menu add: 'playfield options...' subMenu: subMenu.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #paintBackground to: self."	aHalo addHandleAt: box leftCenter color: Color veryVeryLightGray on: #mouseDown send: #makeNewDrawingWithin to: self."! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/5/1998 18:13'!wantsHaloFor: aSubMorph	^ (isPartsBin ~~ true and: [openToDragNDrop ~~ false]) and:		[self wantsMouseOverHalos]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/8/1998 10:58'!toggleMouseOverHalos	wantsMouseOverHalos _ self wantsMouseOverHalos not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos	^ wantsMouseOverHalos == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos _ aBoolean! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 19:16'!makeNewDrawingWithin	| bnds |	bnds _ self paintingBoundsAround: self boundsInWorld center.	self primaryHand makeNewDrawingInBounds: bnds pasteUpMorph: self.! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 18:52'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ ScriptingSystem reasonablePaintingExtent.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/1998 22:53'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	self autoLineLayout		ifTrue:			[self fixLayout]! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 6/18/1998 10:31'!convertbosfcepcbbfgccpmcpbttloiairfidcuw0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"These variables are automatically stored into the new instance ('presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'openToDragNDrop' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle')."	"Incoming morphs have extra inst var: 'wantsMouseOverHalos'"! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points == nil ifTrue:		[points _ OrderedCollection new: 1000.		points addLast: p1].	points addLast: p2! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!catchDivideByZero: aStream indent: tabCount	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	(submorphs at: 2) type = #operator ifFalse: [^ false].		"not me"	(submorphs at: 2) operatorOrExpression == #/ ifFalse: [^ false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs at: 3) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| aStream |	aStream _ ReadWriteStream on: ''.	self storeCodeOn: aStream indent: 1.	^ aStream contents! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 6/29/1998 09:22'!inPartsBin	| o |	o _ self owner.	[o == nil] whileFalse:		[(o isKindOf: PartsBinMorph) ifTrue: [^ true].  "special case for ancient Parts Viewer stuff"		o _ o owner].	^ super inPartsBin! !!PhraseTileMorph methodsFor: 'all' stamp: 'tk 6/21/1998 09:45'!isPossessive	^ self hasProperty: #possessive! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	"Add in some smarts for division by zero."	aStream nextPut: $(.	(submorphs at: 1) storeCodeOn: aStream indent: tabCount.	aStream space.	(submorphs at: 2) storeCodeOn: aStream indent: tabCount.	submorphs size > 2 ifTrue: [		(self catchDivideByZero: aStream indent: tabCount) ifFalse: [			aStream space.			(submorphs at: 3) storeCodeOn: aStream indent: tabCount]].	aStream nextPut: $).! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:50'!addNotes	| newNotes rightEdge topEdge track trackColor i done n nLeft nTop nRight |	newNotes _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated.							newNotes add:								(Morph									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: newNotes.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:20'!drawOn: aCanvas	| innerBox center |	super drawOn: aCanvas.	self drawStaffOn: aCanvas.	innerBox _ self innerBounds.	center _ innerBox center x.	aCanvas		fillRectangle: (center@innerBox top corner: (center + 1)@innerBox bottom)		color: Color red.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:01'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	blackKeyColor _ Color gray: 0.7.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 5/30/1998 20:58'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:03'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	self drawOn: aCanvas.	submorphs isEmpty ifFalse: [		clippingCanvas _ aCanvas copyClipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:06'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) time < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 18:59'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 07:52'!isBlackKey: midiKey	"Answer true if the given MIDI key corresponds to a black key on the piano keyboard."	| note |	note _ midiKey \\ 12.	note = 1 ifTrue: [^ true].	note = 3 ifTrue: [^ true].	note = 6 ifTrue: [^ true].	note = 8 ifTrue: [^ true].	note = 10 ifTrue: [^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:03'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	lowestNote _ 24.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/8/1998 15:51'!step	| t fudge |	score ifNil: [^ self].	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		fudge _ 0.  "pixels of 'fudge factor' to adjust for display update delay"		self goToTime: t - (((self width // 2) - borderWidth + fudge) asFloat / timeScale) truncated.		self addNotes.		lastUpdateTick _ t].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:07'!stepTime	^ 0! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:06'!xForTime: aNumber	^ bounds left + borderWidth + (timeScale * (aNumber - leftEdgeTime) asFloat) truncated! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:47'!yForMidiKey: midiKey	^ (bounds bottom - borderWidth - 4) - (4 * (midiKey - lowestNote))! !!PinMorph methodsFor: 'events' stamp: 'jm 5/29/1998 14:33'!handlesMouseDown: evt	^ (evt yellowButtonPressed | evt blueButtonPressed) not! !!Player methodsFor: 'clone' stamp: 'tk 6/25/1998 17:06'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls civ ii |	newCls _ (self class officialClass instanceOfUniqueClassWithInstVarString: 			self class instanceVariablesString 		andClassInstVarString: self class class instanceVariablesString) class.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	civ _ self class class allInstVarNames.	ii _ civ indexOf: 'scripts'.	newCls instVarAt: ii put: self class scripts.	"later must duplicate this""	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]]."	ii _ civ indexOf: 'slotInfo'.	newCls instVarAt: ii put: self class slotInfo deepCopy.	ii _ civ indexOf: 'costumeDictionary'.	newCls instVarAt: ii put: self class costumeDictionary copy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!Player methodsFor: 'clone' stamp: 'sw 6/16/1998 15:17'!duplicatedPlayerForCostume: aCostume	"Answer a new Player that starts out life wearing aCostume and having the same instance variables and methods as the receiver, but its own private independent uniclass"	| anInstance itsClass |	anInstance _ self class officialClass instanceOfUniqueClassWithInstVarString: self class instanceVariablesString andClassInstVarString: self class class instanceVariablesString.	anInstance costume: aCostume.	anInstance copyStateFrom: self.	(itsClass _ anInstance class) copyMethodDictionaryFrom: self class.	itsClass class copyMethodDictionaryFrom: self class class.	^ anInstance! !!Player class methodsFor: 'initialization' stamp: 'sw 6/16/1998 15:32'!copyStateFrom: anotherClass	| dupScript |	scripts _ IdentityDictionary new.	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]].	slotInfo _ anotherClass slotInfo deepCopy.	self copyAddedStateFrom: anotherClass.  "The player-ref jump table"! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii _ BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className _ (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii _ ii + 1].	BiggestSubclassNumber _ ii.	^ className	! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 6/26/1998 11:07'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:14'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableListView methodsFor: 'model access' stamp: 'di 6/26/1998 11:05'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:13'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'wod 5/26/1998 17:03'!setSelection: sel	selectionInterval _ sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [scroller changed].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 6/26/1998 11:09'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/22/1998 15:14'!handleEdit: editBlock	| result |	textMorph editor model: model.  "For evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/26/1998 15:04'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2].		cpHere y >= self bottom			ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]].	selRect _ transform invertRect: rectToTest.	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 6/21/1998 21:10'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft + 1) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:36'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/21/1998 21:10'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'editing' stamp: 'jm 6/3/1998 14:29'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1).! !!PolygonMorph methodsFor: 'menu' stamp: 'di 6/21/1998 12:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	quickFill		ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]		ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 21:15'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent+2. "for anyShapeFill"	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill].	^ filledForm! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 6/3/1998 16:43'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	nLines _ (frame height - 4) // marker height.	allLabels := labelString findTokens: Character cr asString.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines) startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PositionableStream methodsFor: 'positioning' stamp: 'di 5/25/1998 15:16'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/9/1998 13:15'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| aString length |	length _ self next asciiValue.		"first byte."	length >= 192 ifTrue: [length _ length - 192.		1 to: 3 do: [:ii | length _ length * 256 + self next asciiValue]].	aString _ String new: length.	self nextInto: aString.	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ (length - 192) * 256 + self next].	aString _ String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 5/29/1998 09:41'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s.	^s! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/29/1998 09:50'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		(TabbedPaletteComplex)		(BasicButton JoystickMorph ClockMorph RecordingControlsMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/26/1998 16:39'!createTilePartsBin	"currently disused"	associatedMorph primaryHand attachMorph: self newTilePartsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/29/1998 10:09'!customPagesForPartsBin	| aPage |	^ #(BookMorph "WebBookMorph") collect:		[:sym |			aPage _ self newPageForStandardPartsBin.			aPage addMorphBack: (Smalltalk at: sym) authoringPrototype.			aPage addMorphBack: associatedMorph previousPageButton markAsPartsDonor.			aPage addMorphBack: associatedMorph nextPageButton markAsPartsDonor.			aPage fixLayout.			aPage]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/29/1998 10:40'!newStandardPartsBin	| aBook aPage aSize |	aSize _ 340 @ 160.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 2.	aBook removeEverything.	aBook openToDragNDrop: false.	aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: '    Parts Bin    ').	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/24/1998 16:00'!newTilePartsBin	| aPartsContainer aPage aSize |	aSize _ 340 @ 160.	aPartsContainer _ BookMorph new color: Color red veryMuchLighter.	aPartsContainer borderWidth: 2.	aPartsContainer removeEverything.	aPartsContainer openToDragNDrop: false.	aPartsContainer addMorphBack: (aPartsContainer makeMinimalControlsWithColor: Color transparent title: '    Tiles    ').	#(valueTiles booleanTiles arithmeticTiles) do:		[:aSym |			aPage _ self newPageForStandardPartsBin.			(self perform: aSym) do:				[:aTile | aPage addMorphBack: aTile markAsPartsDonor].			aPage fixLayout.			self coloredTilesEnabled ifFalse:				[aPage makeAllTilesGreen].			aPartsContainer insertPage: aPage pageSize: aSize].	aPartsContainer goToPage: 1.^ aPartsContainer! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/29/1998 09:46'!tilesPagesForPartsBin	| aPage bools |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	aPage makeAllTilesGreen.	aPage fixLayout.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 6/8/1998 11:06'!mouseOverHalosEnabled	^ mouseOverHalosEnabled == true! !!Presenter methodsFor: 'misc' stamp: 'sw 6/8/1998 11:06'!initializeToggles 	balloonHelpEnabled _ true.	mouseOverHalosEnabled _ true.	soundsEnabled _ true.	fenceEnabled _ true.	coloredTilesEnabled _ false! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 15:42'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				vanishingPoint _ Sensor cursorPoint.				(entering ifTrue: [self] ifFalse: [previousProject]) dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [vanishingPoint _ v windowBox center]].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 14:14'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'di 6/23/1998 09:36'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	world isMorph		ifTrue: [world _ World.				self dependents do:					[:d | (d isKindOf: SystemWindow)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]].				world sleep "Release all space possible in old world"]		ifFalse: [world _ ScheduledControllers.				ScheduledControllers unCacheWindows.				self dependents do:					[:d | (d isKindOf: StandardSystemView)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]].	transcript _ Transcript.	displayDepth _ Display depth.	activeProcess _ nil! !!Project methodsFor: 'release' stamp: 'di 6/22/1998 09:40'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	ProjectViewMorph allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'di 6/17/1998 13:08'!maybeForkInterrupt	Smalltalk isMorphic		ifTrue: [self cmdDotEnabled ifTrue:					[[self interruptName: 'User Interrupt'] fork]]		ifFalse: [ScheduledControllers cmdDotEnabled ifTrue:					[[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'class initialization' stamp: 'di 6/20/1998 10:31'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	NavList _ OrderedCollection with: CurrentProject.	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:29'!addItem: item toMenu: menu selection: action	(menu isKindOf: MenuMorph)		ifTrue: [menu add: item selector: #jumpToSelection: argument: action]		ifFalse: [menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:28'!buildJumpToMenu: menu	"Present a list of potential projects."	"Time millisecondsToRun: [Project jumpToMenu]"	| prev |	"First a FIFO list"	(prev _ CurrentProject previousProject) ifNotNil:		[1 to: 5 do:			[:i | 			prev ifNotNil: 				[self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: '%back' , i printString.				prev _ prev previousProject]].		menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: [		self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent.		menu addLine].	"Finally all the projects"	Project allNames do: [:n | self addItem: n toMenu: menu selection: n].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:24'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUp! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:03'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."	"Project jumpToProject"	| nBack prev |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true]].	selection = #parent ifTrue: [CurrentProject parent enter: false. ^ self].	(Project named: selection) enter: false! !!ProjectView methodsFor: 'displaying' stamp: 'di 5/27/1998 16:58'!displayView	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/15/1998 16:21'!enter	"Enter my project."	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	project enter: false.! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 12:36'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and:	 [image depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP "scaleP x asFloat max: scaleP y asFloat".				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self image: (Form extent: newExtent depth: Display depth).		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 11:46'!mouseDown: evt	"Quick hack: use old-fashioned menu."	| menu selection |	menu _ CustomMenu new		add: 'enter' action: #enter;		add: 'jump to project...' action: #jumpToProject.	selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: nil.	selection = #enter ifTrue: [^ self enter].	selection = #jumpToProject ifTrue: [Project jumpToProject. ^ self].! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:17'!initialize	| m1 m2 |	super initialize.	self typeColor: (TilePadMorph colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:44'!numericValue	^ super numericValue atRandom! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:45'!storeCodeOn: aStream indent: tabCount	aStream			nextPut: $(;			nextPutAll: literal printString;			nextPutAll: ' atRandom)'.! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:14'!updateLiteralLabel	|  desiredW leader myLabel myReadout |	(myLabel _ self labelMorph) ifNil: [^ self].	myReadout _ submorphs reversed detect: [:m | m isKindOf: StringMorph].	myReadout contents: literal stringForReadout.	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width + myReadout width + 5.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myReadout position: (self left + (leader + 0)) @ (bounds top + 2); fullBounds.	myLabel position: myReadout topRight + (5@0).	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [Smalltalk changes preambleString == nil])		ifTrue: [Smalltalk changes preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [Smalltalk changes postscriptString == nil])		ifTrue: [Smalltalk changes postscriptString: chunk].							! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| val chunk |	'Reading ' , self name		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!ReferenceStream class methodsFor: 'all' stamp: 'tk 5/26/1998 14:51'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	" 4 = If UniClasses (subclasses of Player) have class instance variables, append their values in the form (#Class43 (val1 val2 vla3)).  An array of those.  Can still read version 3."	^ 4! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/1/1998 09:02'!ticksSinceStart	"Return the number of logical ticks have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/28/1998 18:52'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Reset Insts.';		actionSelector: #reset).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	repeatSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Repeat';		actionSelector: #repeat:;		target: scorePlayer;		setSwitchState: scorePlayer repeat.	r addMorphBack: repeatSwitch.	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:05'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll h |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	h _ self world activeHand.	h		ifNil: [self world addMorph: pianoRoll]		ifNotNil: [h attachMorph: pianoRoll].	pianoRoll startStepping.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:10'!scorePlayer	^ scorePlayer! !!ScreenController methodsFor: 'menu messages' stamp: 'tao 5/25/1998 09:54'!aboutThisSystem 	"Identify software version"	| aString eToySystem aNumber |	aString _ Smalltalk version.	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'EToy System: ', eToySystem version, ' of ', eToySystem versionDate].	aNumber _ ChangeSorter highestNumberedChangeSet.	(aNumber notNil and: [aNumber > 0]) ifTrue:		[aString _ aString, 'Highest-numbered Change Set: ', aNumber printString].	^ self inform: aString! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/2/1998 15:37'!soundOnOrOff	Preferences setPreference: #disableSounds		toValue: (Preferences valueOfFlag: #disableSounds) not! !!ScreenController methodsFor: 'nested menus' stamp: 'di 6/2/1998 15:35'!helpMenu	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'preferences...'			'update code from server'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'set display depth...'			'full screen on'			'full screen off' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) , 		#(	'view GIF imports'			'space left'			'vm statistics' )		lines: #(2 5 8 11)		selections: #(editPreferences  absorbUpdatesFromServer aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor setDisplayDepth fullScreenOn fullScreenOff soundOnOrOff viewGIFImports garbageCollect vmStatistics)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!openEToy	self codeStrippedOut: '2.0BetaExternal'! !!ScreenController methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!openEToyPanel	self codeStrippedOut: '2.0BetaExternal'! !!ScreenController methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!openImagineeringStudio	self codeStrippedOut: '2.0BetaExternal'! !!ScreenController class methodsFor: 'class initialization' stamp: 'di 6/2/1998 15:48'!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them."	"ScreenController initialize"	ChangesMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.! !!ScreenController class methodsFor: 'stripped' stamp: 'di 5/22/1998 21:55'!initializeOpenMenuForInternalUse	self codeStrippedOut: '2.0BetaExternal'! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:11'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/29/1998 10:43'!storeCodeOn: aStream indent: tabCount	| lastOwner |	lastOwner _ nil.	self tileRows do: [:r |		r do: [:m |			((m isKindOf: TileMorph) or:			 [(m isKindOf: CompoundTileMorph) or:			 [m isKindOf: PhraseTileMorph]]) ifTrue: [				tabCount timesRepeat: [aStream tab].				((m owner ~= lastOwner) and: [lastOwner ~= nil])					ifTrue:						[aStream nextPut: $.; cr; tab.						m storeCodeOn: aStream indent: tabCount]					ifFalse:						[(lastOwner ~= nil) ifTrue: [aStream space].						m storeCodeOn: aStream indent: tabCount].				lastOwner _ m owner]]].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 17:40'!userScriptObject	^ self topEditor playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScrollController methodsFor: 'control defaults' stamp: 'di 6/26/1998 13:11'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's menu."	| menu sel |	menu _ view getMenu: shiftKeyState.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!ScrollPane methodsFor: 'initialization' stamp: 'jm 6/17/1998 11:57'!fullCopy	| copy |	self mouseEnter: nil.		 "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.		"So that references are updated properly"	self mouseLeave: nil.	^ copy mouseLeave: nil! !!ScrollPane methodsFor: 'pane events' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:29'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:20'!checkNames: list	"Look at these names for update and see if they are OK"list do: [:local |	(local count: [:char | char == $.]) > 1 ifTrue: [		self inform: 'File name ',local,'may not have more than one period'.	^ false].	(local at: 1) isDigit ifTrue: [		self inform: 'File name ',local,'may not begin with a number'.	^ false].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		self inform: 'File name ',local,'may not contain % / * or space'.	^ false]].^ true! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:25'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2051)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:24'!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind).			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!ServerDirectory methodsFor: 'accessing' stamp: 'di 5/26/1998 20:53'!fullPath: serverAndDirectory	"Parse and save a full path"	| start bare |	bare _ serverAndDirectory.	bare size > 7 ifTrue: [ 		start _ (bare copyFrom: 1 to: 8) asLowercase.		(start beginsWith: 'ftp://') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: 7 to: bare size].		(start beginsWith: 'http://') 			ifTrue: [type _ #http.				bare _ bare copyFrom: 8 to: serverAndDirectory size]].	server _ bare copyUpTo: self pathNameDelimiter.	bare size > (server size + 1) 		ifTrue: [directory _ bare copyFrom: server size + 1 to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/23/1998 09:41'!printOn: aStrm	aStrm nextPutAll: self class name; nextPut: $<.	aStrm nextPutAll: self moniker.	aStrm nextPut: $>.! !!ServerDirectory methodsFor: 'file directory' stamp: 'di 6/2/1998 13:33'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name><creationTime><modificationTime><dirFlag><fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		Array with: (tokens at: 9)  "file name"			with: dateInSeconds "creation date"			with: dateInSeconds "modification time"			with: tokens first first = $d "is-a-directory flag"			with: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group	"NOTE: This is an association whose key is the anme of the group, and	whose value is an array of serverDirectories, the first of which is	deemed to be the group directory."	^ group! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:54'!removeFromGroup	"Allowable if not in a group presently"	group ifNotNil:		["Group is an association shared by all members.		Therefore all will feel this removal"		group value: (group value copyWithout: self).		group _ nil  "...and I'm outa here"]! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 16:01'!addGroup: serverArray named: nameString	| groupAssn |	serverArray do: [:server | server removeFromGroup].	groupAssn _ nameString -> serverArray asArray copy.	serverArray do: [:server | server group: groupAssn].! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:24'!addServer: server named: nameString	Servers at: nameString put: server! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:15'!groupNamed: nameString	"Return the first server in the group of this name."	| grp server |	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [nameString = server groupName						ifTrue: [^ server]]].	^ self error: 'Server name not found'! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:03'!groupNames	"Return the names of all registered groups of servers, including individual servers not in any group.  Note: A serverDirectory that is a member of a group will return an array of the servers in its group.  The first server in that array represents the group, and its name is the name of the goup."	| grp names server |	names _ OrderedCollection new.	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [names add: server groupName]].	^ names asSortedArray! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 14:29'!removeServerNamed: nameString	Servers removeKey: nameString! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:16'!serverNamed: nameString	^ Servers at: nameString		ifAbsent: [self error: 'Server name not found']! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 13:30'!serverNames	^ Servers keys asSortedArray! !!SimpleButtonMorph methodsFor: 'events' stamp: 'jm 6/17/1998 09:01'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 6/8/1998 16:05'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'jm 6/2/1998 13:07'!initializeFor: aSketchMorph inBounds: boundsToUse ofWorld: w	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	palette _ w paintBox.	w addMorphFront: palette.  "bring to front"	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	aSketchMorph ifNotNil: [		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter].! !!SketchMorph methodsFor: 'menu' stamp: 'jm 6/2/1998 14:28'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w oldRotation oldFwdDir bnds sketchEditor |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	oldRotation _ rotationDegrees.	oldFwdDir _ self forwardDirection.	self rotationDegrees: 0.	forBackground		ifTrue: [bnds _ aPasteUpMorph boundsInWorld]		ifFalse: [			bnds _ self boundsInWorld.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds ofWorld: aPasteUpMorph world.	self rotationDegrees: oldRotation.  "restore old rotation so that cancel leaves it right"	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self topRendererOrSelf position: aRect origin.			self forwardDirection: sketchEditor forwardDirection.			self rotationDegrees: oldRotation + (sketchEditor forwardDirection - oldFwdDir).			self rotationStyle: sketchEditor rotationStyle.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil:				[aPasteUpMorph standardPalette viewMorph: self]].! !!SketchMorph methodsFor: 'other' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #editDrawing to: aHalo innerTarget! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 14:47'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:09'!moreObjects	"Return true if there appears to be another object following this one on the file."	| byte |	byteStream atEnd ifTrue: [^ false].	"off end of file"	(byte _ byteStream peek) ifNil: [^ false].	"off end of file"	byte = 33 "$!! asciiValue" ifTrue: [^ false].	byte = 0 ifTrue: [^ false].	^ byte <= RefTypes size		"between 1 and 16"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 10:58'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream.	"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ #marked.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:20'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses (i.e. scripts slotInfo costumeDictionary).  Later: Watch for changed structure."	| normal aName newName newCls |	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars" 	classInstVars _ super next.	"Array of arrays"	normal _ Object class instSize.	"might give trouble if Player class superclass changes size"	classInstVars do: [:list |		aName _ (list at: 1) asSymbol.		newName _ renamed at: aName ifAbsent: [aName].		newCls _ Smalltalk at: newName 				ifAbsent: [self error: 'UniClass definition missing'].		newCls class instSize = (normal+(list size)-1) ifFalse: [			self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		2 to: list size do: [:ii |			newCls instVarAt: normal+ii-1 put: (list at: ii)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:28'!saveClassInstVars	"Install the values of the instance variables of UniClasses.  classInstVars is an array of arrays (#Player3 (Player3 class's inst var scripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	self uniClasesDo: [:aUniClass | 		mySize _ aUniClass class instSize.		mySize = normal ifFalse: [			list _ OrderedCollection new.			list add: aUniClass name.	"a symbol"			normal+1 to: mySize do: [:ii | 				list addLast: (aUniClass instVarAt: ii)]].		classInstVars add: list asArray].	classInstVars _ classInstVars asArray.	! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:32'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class." | uniClasses normal more aUniClass mySize |"Any classes used in the structure of classInstVars must be written out also!!	dummy nextPut: (OrderedCollection new).But for now, only uses Arrays."uniClasses _ Set new.normal _ Object class instSize.more _ true.[more] whileTrue: [	more _ false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass _ each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize _ aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more _ true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/25/1998 21:42'!veryDeepClassVars: refs	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo costumeDictionary) and player321 cross references.""Uniclasses use class vars to hold onto siblings who are referred to in code"| class val pp |pp _ Object class instSize + 1.refs do: [:each | "values = new ones"	"each is not a Metaclass and not a Class!!"	(class _ each class) isSystemDefined ifFalse: [		class classPool associationsDo: [:assoc |			(val _ refs at: assoc value ifAbsent: [nil]) ifNotNil: [				"If not in refs, then the right value is already in the field"				assoc value: val]].		pp to: class class instSize do: [:ii | 			(val _ refs at: (class instVarAt: ii) ifAbsent: [nil]) ifNotNil: [				"If not in refs, then the right value is already in the field"				class instVarAt: ii put: val]].		]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/26/1998 21:35'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: assoc key comeFullyUpOnReload]]				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		"ScannedObject _ refs."	"debug"	^ refs at: anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/24/1998 10:39'!veryDeepRectify: refs	"refs is a dictionary of (old object -> shallow copy of it).  For each field, map the value to a new object.  This is for copying, so if an object is not in refs, use its old value.	Rehash the Sets.  If any other class depends on the hashes of its inst vars, let is recompute also."	| hashers new class index sub val |	hashers _ OrderedCollection new.	refs associationsDo: [:assoc | 		assoc key == assoc value ifFalse: ["is a new object"			new _ assoc value.			class _ new class.			class isVariable				ifTrue: 					[index _ new basicSize.					[index > 0] whileTrue: 						[sub _ new basicAt: index.						(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [								"If not in refs, then the right value is already in the field"								new basicAt: index put: val].						index _ index - 1]].			index _ class instSize.			[index > 0] whileTrue: 				[sub _ new instVarAt: index.				(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [						"If not in refs, then the right value is already in the field"						new instVarAt: index put: val].				index _ index - 1].			(new respondsTo: #rehash) ifTrue: [hashers add: new].			]].	"Force new Sets and Dictionaries to rehash"	hashers do: [:each | each rehash].! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 6/25/1998 12:29'!reasonablePaintingExtent	"Answer a reasonable maximum extent for the painting area when the user paints a new objects or repaints an old one.  Temporarily made large here in order *not* to apply any restraint, as per current sentiment"	^  1800 @ 1800! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 6/10/1998 15:10'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view topView isCollapsed ifFalse: [model modelWakeUp].! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:46'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| eval |	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	emphasis > 0 ifTrue: [self error: 'Synthietic fonts do not get written out. Proceed for plain font.'].	eval _ 'StrikeFont familyName: #', self name ,' size: ', self height printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval).! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:49'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $)! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 6/26/1998 14:42'!familyName: aName size: aSize	| aStyle |	(aStyle _ TextStyle named: aName asSymbol)		ifNil: [aStyle _ TextStyle default].	"substitute. OK not to copy"	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'examples' stamp: 'tk 6/26/1998 15:19'!update	"A temporary method to change the names of StrikeFonts.  New convention is that each StrikeFont is in a TextStyle that has only fonts of the same name (family).  The name of that TextStyle in TextConstants is the same name as the family name of this font.  Sizes are no longer in the name of the font."	"StrikeFont update"| sty |TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		"Transcript show: assoc key; space."		sty _ assoc value.		sty fontArray do: [:font | font name: assoc key]		]]].TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		sty _ assoc value.		sty fontArray do: [:font | 			(StrikeFont familyName: font name size: font height) == font ifFalse: [				self error: 'not same']]]]].! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'tk 6/21/1998 11:41'!atPin: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  "	<primitive: 63>	^(super atWrap: index) asCharacter! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location	aPoint on aDisplayMedium."	(self asDisplayText foregroundColor: Color black backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!StringHolder methodsFor: 'initialize-release' stamp: 'di 5/27/1998 21:21'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| shiftMenu |	^ shifted 	ifFalse: [aMenu 		labels: PluggableTextController yellowButtonMenu labelString 		lines: PluggableTextController yellowButtonMenu lineArray		selections: PluggableTextController yellowButtonMessages]	ifTrue: [shiftMenu _ PluggableTextController shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: PluggableTextController shiftedYellowButtonMessages]! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:51'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:46'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!StringMorph methodsFor: 'initialization' stamp: 'sw 6/15/1998 15:34'!addOptionalHandlesTo: aHalo box: box	self flag: #deferred.	"Eventually...	self addFontHandlesTo: aHalo box: box"! !!StringMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 18:03'!valueAsConstant	^ self contents! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!SystemDictionary methodsFor: 'browsing' stamp: 'jm 5/29/1998 14:30'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-sensitive, unless the shift key is pressed, in which case the search is case-insensitive (and consequently somewhat slower)."	| caseBlind testString suffix |	(caseBlind _ Sensor controlKeyPressed)		ifTrue:			[testString _ aString asLowercase.			suffix _ ' (case-blind)']		ifFalse:			[testString _ aString.			suffix _ ' (case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: testString caseSensitive: caseBlind not]]]		name:  'Methods with string ''', aString, '''', suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 6/17/1998 13:16'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Project current interruptName: 'Space is low'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 6/30/1998 22:56'!version	"Answer the version of this release."	^ 'Squeak 2.1 of June 30, 1998'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'TPR 5/10/1998 21:33'!saveAs	| dir newName newImageName newChangesName |	dir _ FileDirectory default.	newName _ (FillInTheBlank		request: 'New File Name?'		initialAnswer: 'NewImageName') asFileName.	newName _ FileDirectory baseNameFor: newName.	newImageName _ newName, FileDirectory dot, FileDirectory imageSuffix.	newChangesName _ newName, FileDirectory dot, FileDirectory changeSuffix.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemTracer methodsFor: 'initialization' stamp: 'jm 6/13/1998 08:33'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: self fullName		type: 'STim'		creator: 'FAST'.	file close.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:57'!extent: newExtent	| inner panelRect labelRect paneColor |	self removeHandles.	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	panelRect _ self panelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	paneMorphs with: paneRects do:		[:m :frame |  m color: paneColor.		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated].	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].	self isActive ifTrue: [self addHandles]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:56'!labelRect	^ self innerBounds withHeight: self labelHeight.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:55'!panelRect	"Return the area below title bar, devoted to panes"	^ self innerBounds topLeft + (0@(self labelHeight))					corner: self innerBounds bottomRight! !!SystemWindow methodsFor: 'label' stamp: 'di 6/10/1998 13:53'!relabel	| newLabel |	newLabel _ FillInTheBlank request: 'New label for this window'						initialAnswer: labelString.	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!SystemWindow methodsFor: 'open/close' stamp: 'di 6/17/1998 13:41'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model release.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 6/15/1998 23:16'!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color gray; extent: (i<=6 ifTrue: [2@20] ifFalse: [20@2]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorph: handle].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 6/24/1998 21:30'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		super bounds: fullFrame.		paneMorphs reverseDo: [:m | self addMorph: m].		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		paneMorphs do: [:m | m delete; releaseCachedState].		collapsedFrame			ifNil:	[self extent: (label width + 50) @ (self labelHeight + 2).					self position: (RealEstateAgent assignCollapsePointFor: self)]			ifNotNil: [super bounds: collapsedFrame]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 6/17/1998 11:55'!mouseLeaveEvent: event fromPane: pane	"For backward compatibility only.  Not used by any newly created window"	(pane isKindOf: ScrollPane) ifTrue: [pane mouseLeave: event].! !!SystemWindow methodsFor: 'top window' stamp: 'di 6/24/1998 22:27'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	owner firstSubmorph == self ifFalse: [owner addMorphFront: self].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp]! !!SystemWindow methodsFor: 'top window' stamp: 'di 6/16/1998 08:21'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	"Note - the following code is equiv to simply:		self removeHandles.	It has been rewritten so that only 4 damage rects will get repainted, 	all within this window, and none within its subpanes"	"First do the top and bottom handles, together with the label"	self invalidRect: (self bounds topLeft corner: self right@(self top+2)).	self invalidRect: (self left@(self bottom-2) corner: self bounds bottomRight).	(self submorphs select: [:m | (m isMemberOf: Morph)			and: [m bottom <= (self top+2) or: [m top >= (self bottom-2)]]])		do: [:m | m delete].self world displayWorld.	"Now do the left and right handles"	self invalidRect: (self bounds topLeft corner: (self left+2)@self bottom).	self invalidRect: ((self right-2)@self top corner: self bounds bottomRight).	self removeHandles.  "Only these are left"self world displayWorld.	self submorphsDo: [:m | m lock].! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:26'!handlesMouseDown: evt	"If I am not the topWindow, then my mouseDown action dominates"	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/16/1998 08:19'!mouseDown: evt	| cp |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[^ evt hand grabMorph: self].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseMove: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!SystemWindow methodsFor: 'menu' stamp: 'di 5/27/1998 15:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'relabel' action: #relabel.! !!TabbedPaletteComplex methodsFor: 'disk-file load/store' stamp: 'sw 5/31/1998 00:20'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: evt cursorPoint) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TabbedPaletteComplex methodsFor: 'miscellaneous' stamp: 'sw 6/1/1998 14:18'!padding	^ 10! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 6/3/1998 21:36'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add:  'add tab' action: #insertTab.	subMenu addLine.	subMenu add:  'delete selected tab' action: #deleteTab.	subMenu add:  'rename selected tab' action: #renameTab.	subMenu add:  'recolor selected tab' action: #recolorTab.	(self primaryHand classOfPasteBuffer isKindOf: BookMorph class) ifTrue:		[subMenu addLine.		subMenu add: 'paste book before current tab' action: #pasteBookAsNewTab.		subMenu add: 'paste book after last tab' action: #pasteBookAfterLastTab].	aCustomMenu add: 'tabs...' subMenu: subMenu! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 5/30/1998 22:13'!deleteTab	| aMorph |	tabsMorph submorphs size <= 1 ifTrue: [^ self beep].	aMorph _ self selectedTabStringButtonMorph.	self deletePage.	aMorph delete! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 5/30/1998 22:27'!insertTab	self addTabNamed: 'tab' color: Color blue atIndex: (pages indexOf: currentPage)! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 6/3/1998 21:33'!pasteBookAfterLastTab	^ self pasteBookAsNewTabAtIndex: (pages size + 1)! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 6/3/1998 21:33'!pasteBookAsNewTab	^ self pasteBookAsNewTabAtIndex: (pages indexOf: currentPage)! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 6/3/1998 21:32'!pasteBookAsNewTabAtIndex: anIndex	| aBook nameToUse saturatedColor but |	aBook _ self primaryHand objectToPaste.	(aBook isKindOf: BookMorph) ifFalse: [^ self inform: 'oops, no book to paste'].	nameToUse _ aBook externalName.	[nameToUse endsWithDigit] whileTrue: [nameToUse _ nameToUse allButLast].	nameToUse size == 0 ifTrue: [nameToUse _ 'tab'].	nameToUse _ self unusedTabNameLike: nameToUse.	aBook setNameTo: nameToUse.	saturatedColor _ aBook currentPage color darker darker.	but _ tabsMorph addButtonShowing: nameToUse named: nameToUse selector: #selectTabNamed: arguments: (Array with: nameToUse) padding: self padding atIndex: anIndex.	but buttonOnColor: saturatedColor.	but buttonOffColor: aBook currentPage color.	self insertPage: aBook pageSize: nil atIndex: anIndex.	self selectTabNamed: nameToUse! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 5/30/1998 21:43'!recolorTab	"Prompt the user for a new color for the currently-selected tab, and carry out her request"	| selectedBookName aColor tabStringMorph |	selectedBookName _ self currentPage externalName.	self inform: 'Choose new color for tab named ', selectedBookName.	aColor _ Color fromUser.	(tabStringMorph _ self selectedTabStringButtonMorph) ifNil: [^ self beep].	tabStringMorph buttonOnColor: aColor.	tabStringMorph buttonOffColor: aColor muchLighter.	tabStringMorph color: aColor.	tabStringMorph changed! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 6/1/1998 14:06'!renameTab	"Prompt the user for a new name for the currently-selected tab, and carry out her request"	| selectedBookName reply tabStringMorph |	selectedBookName _ self currentPage externalName.	reply _ FillInTheBlank  request: 'New name? ' initialAnswer: selectedBookName.	(reply isNil or: [reply = selectedBookName]) ifTrue: [^ self].	(self tabNamesInUse includes: reply) ifTrue: [^ self inform: 'That name is already used here.'].	(tabStringMorph _ self selectedTabStringButtonMorph) ifNil: [^ self beep].	tabStringMorph contents: reply; changed.	tabStringMorph arguments: (Array with: reply).	tabStringMorph setNameTo: reply.	self currentPage setNameTo: reply! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 6/1/1998 14:14'!addTabNamed: str color: saturatedColor atIndex: anIndex	| aName paleColor but aBookMorph |	aName _ str withBlanksTrimmed.  "backward compat; nowadays comes in with no blanks"	paleColor _ saturatedColor muchLighter.	but _ tabsMorph addButtonShowing: aName named: aName selector: #selectTabNamed: arguments: (Array with: aName) padding: self padding atIndex: anIndex.	but buttonOnColor: saturatedColor.	but buttonOffColor: paleColor.	but color: paleColor.	aBookMorph _ BookMorph new pageSize: pageSize.	aBookMorph removeEverything; color: paleColor; setNameTo: aName; addDressing; insertPageColored: paleColor.	self insertPage: aBookMorph pageSize: nil atIndex: anIndex.	self selectTabNamed: aName.	^ aBookMorph! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 5/30/1998 21:40'!selectedTabStringButtonMorph	"Answer the StringButtonMorph representing the current tab"	| selectedBookName tabStringMorph |	selectedBookName _ self currentPage externalName.	tabStringMorph _ tabsMorph stringButtonSubmorphs detect: [:m | m contents withBlanksTrimmed = selectedBookName] ifNone: [self beep.  ^ nil].	^ tabStringMorph! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 5/30/1998 22:04'!tabNamesInUse	^ (tabsMorph stringButtonSubmorphs collect: [:m | m externalName])! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 5/30/1998 22:05'!unusedTabNameLike: aString	| testString testSuffix usedNames |	testString _ aString.	testSuffix _ 0.	usedNames _ self tabNamesInUse.	[usedNames includes: testString] whileTrue:		[testSuffix _ testSuffix + 1.		testString _ aString, (testSuffix printString)].	^ testString! !!TabbedPaletteComplex class methodsFor: 'all' stamp: 'sw 5/30/1998 21:49'!authoringPrototype	| aComplex |	aComplex _ self new.	aComplex pageSize: 180 @ 88.	aComplex addTabNamed: 'one' color: Color red atIndex: 1.	aComplex addTabNamed: 'two' color: Color blue atIndex: 2.	^ aComplex! !!TabbedPaletteComplex class methodsFor: 'all' stamp: 'sw 6/3/1998 21:27'!defaultNameStemForInstances	^ 'tabbedPalette'! !!TabsMorph methodsFor: 'all' stamp: 'sw 6/3/1998 21:21'!addButtonShowing: aString named: aName selector: aSymbol arguments: argList padding: padding atIndex: anIndex	| b indexToUse |	indexToUse _ anIndex == nil ifTrue: [submorphs size + 1] ifFalse: [(2 * (anIndex - 1)) + 1].	indexToUse == 1 ifFalse:		[self privateAddMorph: (Morph new extent: (padding @ 0)) atIndex: (indexToUse - 1)		"spacer before"].	b _ StringButtonMorph new.	b	contents: aString;		color: self buttonOffColor;		target: self;		actionSelector: aSymbol.	argList ifNotNil: [b arguments: argList].	b setNameTo: aName.	self privateAddMorph: b atIndex: indexToUse.	(indexToUse == 1 and: [submorphs size > 1]) ifTrue:		[self privateAddMorph: (Morph new extent: (padding @ 0)) atIndex: 2		"spacer after"].	^ b! !!TabsMorph methodsFor: 'all' stamp: 'sw 5/30/1998 23:06'!selectTabNamed: aString	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTabName: aString.	owner goToPageMorphNamed: aString! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 6/30/1998 22:03'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 12:37'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'menu' stamp: 'sw 6/15/1998 15:13'!addOptionalHandlesTo: aHalo box: box	self addFontHandlesTo: aHalo box: box! !!TextMorph methodsFor: 'private' stamp: 'di 6/22/1998 20:22'!updateFromParagraph  	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last.		self editor setEmphasisHere]! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:11'!readKeyboard	super readKeyboard.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/14/1998 13:12'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/30/1998 08:50'!mouseDown: event	event yellowButtonPressed ifTrue: [^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextStyle methodsFor: 'accessing' stamp: 'tk 6/26/1998 15:03'!fontNamesAndSizes  "TextStyle default fontNames"	^ fontArray collect: [:x | x name, ' ', x height printString]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 6/26/1998 15:58'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.	"Only works if file created by special code above"	newName _ this fontArray first name.	this fontArray do: [:aFont | aFont name = newName ifFalse: [		self error: 'All must be same family']].	style _ TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights _ style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/15/1998 15:18'!tearOffTile	(objectToView isKindOf: Player) ifTrue: [^ objectToView tearOffTileForSelf].	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[objectToView costume]! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 17:58'!bePossessive	self setProperty: #possessive toValue: true.	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 18:00'!bringUpToDate	| newLabel |	type == #objRef ifTrue:		[newLabel _ actualObject externalName.		self isPossessive ifTrue:			[newLabel _ newLabel, '''s'].		self line1: newLabel]	! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 17:58'!isPossessive	^ self hasProperty: #possessive! !!TileMorph methodsFor: 'arrows' stamp: 'tk 6/21/1998 09:41'!showSuffixChoices	"The user wants to know what can follow this tile"	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: 1 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter coloredTilesEnabled ifFalse:		[phrase topEditor			ifNotNil:				[phrase topEditor makeAllTilesGreen]			ifNil:				[phrase makeAllTilesGreen]]! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:12'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:04'!storeCodeOn: aStream indent: tabCount	| op refType playerBearingCode |	"Must determine whom is scripted for what follows to work"	playerBearingCode _ self playerBearingCode.  "If it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["This is the critical point -- if the object is the method's own 'self' then we MUST, rather than just MAY, put out self rather than the referencer call, though the latter will temporarily work as long we have true uniclasses."				aStream nextPutAll: 'self']			ifFalse:				[aStream nextPutAll: 'self class '.				aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TilePadMorph methodsFor: 'all' stamp: 'sw 6/15/1998 09:21'!acceptDroppingMorph: aMorph event: evt	| editor wasPossessive |	wasPossessive _ submorphs size > 0 and: [submorphs first isPossessive].	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	wasPossessive ifTrue: [aMorph bePossessive].	(editor _ self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	submorphs do: [:m | m storeCodeOn: aStream indent: tabCount].! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	World ifNotNil: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TransformMorph methodsFor: 'drawing' stamp: 'jm 6/17/1998 12:22'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageForm.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 6/22/1998 13:54'!rotationDegrees: degrees	self adjustAfter:		[self angle: (degrees degreesToRadians negated						detentBy: Float pi / 20.0						atMultiplesOf: Float pi / 2.0 snap: false)]! !!TranslucentColor methodsFor: 'printing' stamp: 'jm 6/2/1998 08:26'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'jm 6/2/1998 08:35'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 17:45'!valueAsConstant	^ self readFromTarget! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 6/11/1998 16:27'!valueAsConstant	^ self valueFromContents! !!UserScript methodsFor: 'initialization' stamp: 'tk 6/13/1998 14:25'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [		currentScriptEditor == #textuallyCoded ifFalse: [			currentScriptEditor donorActor: player1 ownActor: player2]].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!Utilities class methodsFor: 'fetching updates' stamp: 'wod 6/18/1998 03:45'!absorbUpdatesFromServer	"Go to two common servers and look for updates.  Do not bring themto the user's disk.  A file on the server called updates.list has the namesof the last N update files.  We look backwards for the first one we do nothave, and start there bringing them in.  tk 9/10/97""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""wod 6/18/1998: stop after first failure""Utilities absorbUpdatesFromServer"| doc urls failed loaded str |Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"Cursor wait showWhile: [	(Smalltalk includesKey: #EToySystem)		ifTrue: [(Smalltalk at: #EToySystem) guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']).	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil: [			doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			"check here that it worked"			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse: [					doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse: [							"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							ChangeSorter newChangesFromStream: doc								named: (this findTokens: '/') last.							self saveUpdate: doc onFile: (this findTokens: '/') last.	"if wanted"							loaded _ loaded + 1]]]].	].str _ 'Loaded ', loaded printString ,' new update files.'.failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',					'\Starting with "' withCRs, failed, '".'].self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 6/30/1998 15:49'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger > 412]].	Utilities absorbUpdatesWriteFiles: true zapNums: false.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #()."	| fileNames fileNamesInOrder fileNamesUnnumbered names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	fileNames _ FileDirectory default fileNames select:		[:n | n first isDigit			and: [(n initialInteger between: n1 and: n2)			and: [(skipList includes: n initialInteger) not]]].	fileNamesInOrder _ fileNames asSortedCollection.	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | FileDirectory default rename: n toBe: nu].	(ServerDirectory groupNamed: choice) putUpdateMulti: fileNamesUnnumbered! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/23/1998 08:55'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted"	| index him |	UpdateUrlLists size > 1 ifTrue: [		index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 			startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.		index > 0 ifTrue: [			him _ UpdateUrlLists at: index.			UpdateUrlLists removeAt: index.			UpdateUrlLists addFirst: him].		^ index > 0].	^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'wod 5/21/1998 18:38'!saveUpdate: doc onFile: fileName	"See if the user wants the update stored on a local file.  With or without the update number on the front."	| file fName pos |	(Preferences valueOfFlag: #updateSavesFile) ifFalse: [^ self].	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue: [		pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(FileDirectory default fileExists: fName) ifFalse: [		file _ FileStream newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Utilities class methodsFor: 'support windows' stamp: 'di 5/28/1998 12:11'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selection<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!WorldMorph methodsFor: 'initialization' stamp: 'jm 6/1/1998 19:26'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	model _ nil.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!exit	self sleep.	Project current exit.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!goBack	self sleep.	Project returnToPreviousProject.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:27'!sleep	Cursor normal show.	"restore the normal cursor"	self canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/25/1998 13:14'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: viewBox extent).	damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				(mm fullBounds intersects: r) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'events' stamp: 'jm 6/10/1998 07:57'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.	evt hand invokeMetaMenu: evt.! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/14/1998 12:56'!activeHand: aHandMorph	activeHand _ aHandMorph! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 6/14/1998 12:57'!doOneCycle	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'sensing' stamp: 'di 6/26/1998 12:24'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	| c root |	(self bounds containsPoint: aPoint)		ifFalse: [^ Color black].	c _ FormCanvas extent: 1@1 depth: Display depth.	c _ c copyOrigin: aPoint negated clipRect: ((0@0) extent: 1@1).	c fillColor: color.	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsAt: aPoint) reverseDo: [:subM |				subM == aMorph ifTrue: [^ c form colorAt: 0@0].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsAt: aPoint) reverseDo: [:subM |					subM == aMorph ifTrue: [^ c form colorAt: 0@0].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form colorAt: 0@0! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 6/2/1998 13:14'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid _ Compiler evaluate: (FillInTheBlank request: 'Enter grid size' initialAnswer: '16').	Utilities informUser: 'Choose a background color' during: [backColor _ Color fromUser].	Utilities informUser: 'Choose a line color' during: [lineColor _ Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 6/2/1998 13:13'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do: [:i |		gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.		gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm.	self fullRepaintNeeded.	self changed: #newColor.  "propagate to view"! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 6/2/1998 13:13'!setStandardTexture	| parms |	parms _ self textureParameters.	self makeGraphPaperGrid: parms first		background: parms second		line: parms third.! !	Smalltalk condenseChanges!	Browser initialize.!----QUIT----(30 June 1998 11:10:33 pm ) priorSource: 567912!----QUIT----(30 June 1998 11:14:22 pm ) priorSource: 567966!----QUIT----(30 June 1998 11:46:41 pm ) priorSource: 568028!'From Squeak 2.0 of May 22, 1998 on 23 May 1998 at 10:55:47 am'!"Change Set:		SameGameDate:			23 May 1998Author:			Tim OlsonSameGame is a simple game morph for Squeak 2.0.  It is based upon my memory of a game by the same name that was originally written for X/Motif by Eiji Fukumoto.The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by '(selection - 2) squared', so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the 'Hint' button will find one and select it for you (although it is likely not the best group to select!!!!).When there are no more groups available, the score display will flash with your final score.Come on, you can beat that last score!!!!  Click 'New game'"!Morph subclass: #LedDigitMorph	instanceVariableNames: 'digit highlighted '	classVariableNames: 'HSegmentOrigins HSegments VSegmentOrigins VSegments '	poolDictionaries: ''	category: 'Morphic-Games'!Morph subclass: #LedMorph	instanceVariableNames: 'digits value flashing flash '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!AlignmentMorph subclass: #SameGame	instanceVariableNames: 'board scoreDisplay selectionDisplay helpText '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!AlignmentMorph subclass: #SameGameBoard	instanceVariableNames: 'protoTile rows columns palette selection selectionColor flashColor flash target actionSelector arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!SimpleSwitchMorph subclass: #SameGameTile	instanceVariableNames: 'switchState disabled oldSwitchState '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!!LedDigitMorph commentStamp: 'di 7/1/1998 00:10' prior: 0!I am a 7-segment LED that can display a decimal digit!!LedDigitMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:01'!initialize	super initialize.	color _ Color green.	highlighted _ false.	digit _ 0.! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit	^ digit! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit _ anInteger \\ 10	"make sure it stays between 0 and 9"! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 17:00'!highlighted	^ highlighted! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 17:03'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor _ highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor _ color darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ ((hThickness - thickness) // 2) max: 0.	hOffset _ ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 13:58'!drawOnFills: aRectangle	^ true! !!LedDigitMorph class methodsFor: 'initialization' stamp: 'tao 5/18/1998 12:29'!initialize	HSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments _ {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}}.	VSegments _ {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}}.! !!LedMorph commentStamp: 'di 7/1/1998 00:10' prior: 0!I am a collection of LED digits that can display a decimal value.  The display can be set to flash by sending flash: true.!!LedMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:38'!initialize	super initialize.	flashing _ false.	flash _ false.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:51'!color: aColor	color _ aColor.	self submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!digits	^ digits! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits _ aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash	^ flash! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!value	^ value! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value _ aNumber.	val _ value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val _ val // 10].	self changed.! !!LedMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 14:00'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color darker darker.! !!LedMorph methodsFor: 'change reporting' stamp: 'tao 5/18/1998 13:53'!layoutChanged	super layoutChanged.	submorphs withIndexDo:		[:m :i |		m			position: self position + (((i-1) * self width / digits) rounded @ 0);			extent: (self width / digits) rounded @ self height]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:42'!step	(flash or: [flashing])		ifTrue:			[flashing _ flashing not.			self submorphsDo: [:m | m highlighted: flashing]]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:44'!stepTime	^ 500! !!SameGame commentStamp: 'di 7/1/1998 00:10' prior: 0!See SameGame>>helpString for an explanation of how to play!!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 19:36'!initialize	| |	super initialize.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self addMorph: self makeControls.	self addMorph: self board.	helpText _ nil.	self newGame.! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		inset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; centering: #center; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:40'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		inset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'access' stamp: 'tao 5/23/1998 10:32'!helpString^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'actions' stamp: 'tao 5/23/1998 10:51'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count _ self board selectionCount.	count = 0 ifTrue:		[score _ scoreDisplay value + (selectionDisplay value - 2) squared.		board findSelection ifNil:			[count _ board tilesRemaining.			count = 0				ifTrue: [score _ score + (5 * board rows * board columns)]				ifFalse: [score _ score - count].			scoreDisplay flash: true].		scoreDisplay value: score].	selectionDisplay value: count.! !!SameGameBoard commentStamp: 'di 7/1/1998 00:10' prior: 0!I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:25'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	hResizing _ #rigid.	vResizing _ #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self fixLayout.	self resetBoard.! !!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:39'!resetBoard	selection _ nil.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom]! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'geometry' stamp: 'tao 5/18/1998 20:41'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	(bounds extent // protoTile extent) = (aPoint // protoTile extent)		ifFalse:			[self changed.			bounds _ bounds topLeft extent: (aPoint truncateTo: protoTile extent).			self layoutChanged.			self changed]! !!SameGameBoard methodsFor: 'dropping/grabbing' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 17:57'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MorphicEvent new]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 16:53'!removeSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) disabled: true; setSwitchState: false].		self collapseColumns: (selection collect: [:loc | loc x]) asSet asSortedCollection.		selection _ nil.		flash _ false.		(target ~~ nil and: [actionSelector ~~ nil])			ifTrue: [target perform: actionSelector withArguments: arguments]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 20:20'!tileClickedAt: location newSelection: isNewSelection	| tile |	isNewSelection		ifTrue:			[self deselectSelection.			tile _ self tileAt: location.			selectionColor _ tile color.			selection _ OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1				ifTrue: [self deselectSelection]				ifFalse:					[(target ~~ nil and: [actionSelector ~~ nil])					ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse:			[self removeSelection].! !!SameGameBoard methodsFor: 'private' stamp: 'tao 5/18/1998 20:42'!fixLayout	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameTile commentStamp: 'di 7/1/1998 00:10' prior: 0!I am a single tile for the SameGame.  I act much like a switch.!!SameGameTile methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:59'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/18/1998 20:51'!color: aColor	color _ aColor.	onColor _ aColor.	offColor _ aColor.	self changed.! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!SameGameTile methodsFor: 'drawing' stamp: 'tao 5/15/1998 12:31'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color darker			bottomRightColor: color lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/17/1998 09:53'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		target			perform: actionSelector			withArguments: (arguments copyWith: switchState)].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !LedDigitMorph initialize!!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:11'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !----QUIT----(1 July 1998 12:13:14 am ) priorSource: 568090!'From Squeak 2.1 of June 30, 1998 on 1 July 1998 at 12:35:48 pm'!"Change Set:		quickFixesDate:			1 July 1998Author:			Scott WallaceMoves the detent feature of rotation to the Halo, so that scripted rotations don't show the detent behavior.Performance improvement in Morph>>world.Fix to a bug in the copy-to-paste-buffer that showed up when the morph to be copied was flexed.Moved #stringForReadout from Integer to Number, as per Georg Gollman bug report.Warning issued upon attempt to duplicate an object bearing any anonymous scripts."!!Morph methodsFor: 'accessing' stamp: 'sw 7/1/1998 12:28' prior: 33934400!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(maybeDoDup:with:			'Duplicate')		(doGrab:with:				'Pick up')		(doMenu:with:				'Menu')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 12:15' prior: 19902019!world	^ owner ifNil: [nil] ifNotNil: [owner world]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 7/1/1998 12:25'!okayToDuplicate	costumee ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 12:28' prior: 33736757!addHandles	| box |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: 17)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box topLeft + (0 @ (9 + ((box height - 36) // 4)))) color: Color lightBrown on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + (18@0)) color: Color transparent on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black on: #mouseDown send: #doGrab:with: to: self.	self addHandleAt: box topRight color: Color green on: #mouseDown send: #maybeDoDup:with: to: self.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue:			[(self addHandleAt: box bottomRight color: Color lightOrange on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse:			[(self addHandleAt: box bottomRight color: Color yellow on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target "innerTarget" externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 11:35' prior: 18976334!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - target referencePosition) degrees.	degrees _ degrees - angleOffset degrees.	(degrees abs < 1.0) ifTrue: [degrees _ 0.0].	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	target rotationDegrees: (degrees						detentBy: 10.0						atMultiplesOf: 90.0 snap: false).	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 12:30'!maybeDoDup: evt with: dupHandle	^ target okayToDuplicate ifTrue:		[self doDup: evt with: dupHandle]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/1/1998 12:30' prior: 33742678!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	(argument pasteUpMorph morphsAt: targetOffset) size > 2 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse: [		menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue: [		menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'inspect in Morphic' action: #inspectMorphInMorphic.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue: [		menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue: [			 menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/1/1998 11:52' prior: 33749360!copyToPasteBuffer	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	argument isMorph		ifTrue: [Cursor wait showWhile: 					[argument okayToDuplicate ifTrue:						[PasteBuffer _ argument topRendererOrSelf veryDeepCopy]]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/1/1998 12:30'!maybeDuplicateMorph	argument okayToDuplicate ifTrue:		[self duplicateMorph]! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/1/1998 12:03' prior: 33967384!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[^ root topRendererOrSelf veryDeepCopy].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 7/1/1998 11:33' prior: 34108353!rotationDegrees: degrees	self adjustAfter:		[self angle: degrees degreesToRadians negated]! !Integer removeSelector: #stringForReadout!Integer removeSelector: #stringForReadout!'From Squeak 2.1 of June 30, 1998 on 1 July 1998 at 4:12:22 pm'!"Change Set:		EmbedInTextFixDate:			1 July 1998Author:			Dan Ingalls1.  Makes textAnchor offset work correctly within TransformMorphs.2.  Corrects a problem with emphasis being ignored following a textAnchor.3.  Amends = test for textAnchors to use == with the anchoredMorph."!!CharacterScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 14:55' prior: 17397598!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	destX _ destX + (width _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + width) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis fo rnext run"	^ true! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 16:03' prior: 17896484!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				height _ anchoredMorph height.				runX _ destX.				anchoredMorph displayOn: destForm at: destX - width@destY].	^ true! !!TextAnchor methodsFor: 'all' stamp: 'di 7/1/1998 14:35' prior: 21961071!= other 	^ (other class == self class) 		and: [other anchoredMorph == anchoredMorph]! !CharacterScanner removeSelector: #ifCharIn:at:fits:do:!CharacterScanner removeSelector: #ifCharIn:at:fits:do:!CharacterScanner removeSelector: #setFontAt:!CharacterScanner removeSelector: #setFontAt:!CharacterScanner removeSelector: #beginAt:!CharacterScanner removeSelector: #beginAt:!'From Squeak 2.1 of June 30, 1998 on 1 July 1998 at 11:15:34 pm'!"Change Set:		FloatTruncateFixDate:			1 July 1998Author:			Dan IngallsFixes Float truncate to return accurate values when they are too large to express as a SmallInteger (ie when the primitive fails).  Also fixes LargeInteger asFloat which had been missing an occasional low-order bit."!!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01' prior: 18718026!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20' prior: 18721015!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Integer methodsFor: 'converting' stamp: 'di 7/1/1998 21:37' prior: 19149181!asFloat	"Answer a Float that represents the value of the receiver. Optimized to process only the significant digits of a LargeInteger."	| sum factor numBytes |	sum _ 0.0.	factor _ self sign asFloat.	numBytes _ self size.	numBytes > 8		ifFalse: [			1 to: self size do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0]]		ifTrue: [			(numBytes - 7) to: numBytes do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0].			sum _ sum timesTwoPower: 8 * (numBytes - 8)].	^ sum! !'From Squeak 2.1 of June 30, 1998 on 4 July 1998 at 10:20:07 pm'!!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!Player methodsFor: 'clone' stamp: 'tk 6/27/1998 07:43' prior: 33981356!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls civ ii |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	civ _ self class class allInstVarNames.	ii _ civ indexOf: 'scripts'.	newCls instVarAt: ii put: self class scripts.	"later must duplicate this"	ii _ civ indexOf: 'slotInfo'.	newCls instVarAt: ii put: self class slotInfo deepCopy.	ii _ civ indexOf: 'costumeDictionary'.	newCls instVarAt: ii put: self class costumeDictionary copy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/27/1998 07:46' prior: 34059694!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: nil "assoc key comeFullyUpOnReload"]]						"a DiskProxy will never be looked up -- its not in any field.						Old value of field is used."				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		"ScannedObject _ refs."	"debug"	^ refs at: anObject! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 7/2/1998 16:44' prior: 34065707!familyName: aName size: aSize	| aStyle both ind |	(aStyle _ TextStyle named: aName asSymbol) ifNil: [		both _ aName splitInteger.		(both at: 2) > 0 			ifTrue: ["old style"				ind _ #('ComicB' 'Comic' 'ComicAll') indexOf: (both at: 1).				ind = 0 ifTrue: [^ self familyName: (both at: 1) size: aSize].				aStyle _ TextConstants at: (#(ComicBold ComicPlain ComicPlain) at: ind)]			ifFalse: [aStyle _ TextStyle default]].	"Substitute. Read-only so OK not to copy"	^ aStyle fontOfSize: aSize! !!String methodsFor: 'converting' stamp: 'tk 7/2/1998 16:32'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.  '43Sam' yields #(43 'Sam').  'Try90' yields #('Try' 90) "	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 			with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !'From Squeak 2.1 of June 30, 1998 on 3 July 1998 at 2:54:43 pm'!"Change Set:		DragOverChangesDate:			3 July 1998Author:			Dan IngallsThis changeSet removes the conflict between clients of mouseEnter: and mouseLeave:, regarding whether they are interested in mouseUp activity, or mouseDown (really hand-carrying) activity.  It does this by establishing that, if you wish to receive enter and leave events,	handlesMouseOver: will do so when the hand is empty and the mouse is not pressed,and that 	handlesDragOver: will do so when the hand is carrying something.Returning true to the first works well for most browser-like components.  Returning true to both works for dragging tiles into scriptors, and probably dragOver only would suffice there.It adds dragOverMorphs to HandMorph, parallel to mouseOverMorphs, and ensures that a given morph is never in both at once.The successes achieved include:Browsers no longer show two scrollbars at once.Auto-scrolling now works, even when you pull the mouse over other panes.Scrollbars do not disappear if you drag the elevator outside the scrollbar.Resize handles do not conflict with adjacent scrollbars.Time is not wasted on mouseOver support when you are dragging a morph."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: ''	category: 'Morphic-Kernel'!ThreePhaseButtonMorph subclass: #TrashCanMorph	instanceVariableNames: ''	classVariableNames: 'TrashPic TrashPicOn '	poolDictionaries: ''	category: 'Morphic-Widgets'!!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:11'!handlesDragOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the hand drags something over me (button up or button down)?"	"NOTE: The default response is false, even if the eventHandler has entries for mouseEnter: and mouseLeave:.  You must override this method and return true if you want to get dragOver events."	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:15' prior: 19920189!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	eventHandler ifNotNil: [^ eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:11' prior: 19920538!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?"	"NOTE: The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	eventHandler ifNotNil: [^ eventHandler handlesMouseOver: evt].	^ false! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!HandMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 12:23' prior: 18980383!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:47'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesDragOver: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeave: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnter: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 14:00' prior: 18993441!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:46' prior: 18993747!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 12:56'!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p].  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/2/1998 14:51'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:24'!handlesDragOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 7/3/1998 00:53' prior: 33991782!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform invertRect: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'di 7/3/1998 12:55' prior: 20748908!mouseLeave: event 	selectionInterval _ textMorph editor selectionInterval.	super mouseLeave: event.	event hand newKeyboardFocus: nil! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^true! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 7/3/1998 01:29' prior: 34081821!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color yellow; extent: (i<=6 ifTrue: [1@20] ifFalse: [20@1]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorphBack: handle].! !!SystemWindow methodsFor: 'top window' stamp: 'di 7/3/1998 01:30' prior: 34083816!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	"Note - the following code is equiv to simply:		self removeHandles.	It has been rewritten so that only 4 damage rects will get repainted, 	all within this window, and none within its subpanes"	"First do the top and bottom handles, together with the label"	self invalidRect: (self bounds topLeft corner: self right@(self top+1)).	self invalidRect: (self left@(self bottom-1) corner: self bounds bottomRight).	(self submorphs select: [:m | (m isMemberOf: Morph)			and: [m bottom <= (self top+1) or: [m top >= (self bottom-1)]]])		do: [:m | m delete].self world displayWorld.	"Now do the left and right handles"	self invalidRect: (self bounds topLeft corner: (self left+1)@self bottom).	self invalidRect: ((self right-1)@self top corner: self bounds bottomRight).	self removeHandles.  "Only these are left"self world displayWorld.	self submorphsDo: [:m | m lock].! !!TilePadMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!TrashCanMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 14:28' prior: 22144264!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:17'!handlesDragOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:33'!handlesMouseOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:23'!mouseEnter: event	"Present feedback for potential deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseEnterSound].			hand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:23'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand endDisplaySuppression.			self state: #off]		ifFalse: [			self stopShowingStampIn: hand].! !PluggableListMorph removeSelector: #handlesMouseOver:!PluggableTextMorph removeSelector: #handlesMouseOver:!TrashCanMorph removeSelector: #stepTime!TrashCanMorph removeSelector: #stepTime!TrashCanMorph removeSelector: #step!TrashCanMorph removeSelector: #step!TrashCanMorph removeSelector: #handEntering:!TrashCanMorph removeSelector: #handEntering:!TrashCanMorph removeSelector: #handExiting:!TrashCanMorph removeSelector: #handExiting:!WorldMorph removeSelector: #rootMorphsAt:!WorldMorph removeSelector: #rootMorphsAt:!"Postscript:Init new field in extant HandMorphsExecutable statements after this comment quote..."HandMorph allSubInstancesDo: [:h | h instVarNamed: 'dragOverMorphs' put: OrderedCollection new]!'From Squeak 2.1 of June 30, 1998 on 5 July 1998 at 9:10:25 pm'!"Change Set:		DragTweaksDate:			5 July 1998Author:			Dan IngallsRestored the brown handle to morphic command halo, allowing a morph to be dragged within its owner's bounds without extracting it or changing its front-to-back order.Put in a feature that allows this constrained drag to be accessed merely by dragging more than 5 pixels with the cmd-key held down.Made handle size parametric in existing halo code.Adjusted placment logic of a few other command handles to work better on very small morphs.Fix a performance bug that repainted everything between 0@0 and a halo at pop-up time."!!Morph methodsFor: 'geometry' stamp: 'di 7/5/1998 20:57' prior: 19916666!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/5/1998 12:52' prior: 19969052!addHalo	| halo |	halo _ HaloMorph new bounds: self bounds.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'jun98 additions' stamp: 'di 7/5/1998 12:08' prior: 33943827!addFontHandlesTo: aHalo box: box	"Add handles for controlling font, style, and emphasis choices to the halo"	| s |	s _ aHalo handleSize.	aHalo addHandleAt: (box bottomLeft + ((s+2)@0))		color: Color lightGreen on: #mouseDown send: #chooseFont to: self.	aHalo addHandleAt: (box bottomLeft + ((s+2*2)@0))		color: Color lightRed on: #mouseDown send: #chooseStyle to: self.	aHalo addHandleAt: (box bottomRight - ((s+2)@0))		color: Color lightBrown darker on: #mouseDown send: #chooseEmphasis to: self.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:55' prior: 33736117!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 12:45' prior: 34149438!addHandles	| box s |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: s+1)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color transparent		on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 12:34' prior: 33738682!addHandlesForWorldHalos	| box s |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	s _ self handleSize.	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: target.	self addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: target.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: target)			on: #mouseUp send: #deleteBalloon to: target].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:54'!handleSize	^ 16! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/5/1998 14:05' prior: 18998188!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].	lastEvent _ evt.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		lastEvent _ evt.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph position.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom: self position - targetOffset].! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03' prior: 19042235!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	mouseDownMorph _ nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!RemoteHandMorph methodsFor: 'other' stamp: 'di 7/5/1998 21:07' prior: 20978921!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt anyButtonPressed and:		 [evt controlKeyPressed and:		 [lastEvent anyButtonPressed not]]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent]! !HandMorph removeSelector: #doSpecialDrag:!'From Squeak 2.1 of June 30, 1998 on 6 July 1998 at 8:55:36 am'!!TransformationMorph methodsFor: 'private' stamp: 'di 7/6/1998 08:50' prior: 22138947!adjustAfter: changeBlock	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ transform invert: self renderedMorph referencePosition.	changeBlock value.	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self layoutChanged.	"Maintain constant ref position"	self position: self position + (oldRefPos - (transform invert: self renderedMorph referencePosition))! !'From Squeak 2.1 of June 30, 1998 on 6 July 1998 at 11:47:26 am'!"Change Set:		TwoTweaks-diDate:			6 July 1998Author:			Dan IngallsFixes the initial bounding box when bringing up a halo on a flexed morph.Renames 'window...' to 'open...' in the Morphic world menu, as in MVC."!!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/6/1998 11:32' prior: 34182800!addHalo	| halo |	halo _ HaloMorph new bounds: self fullBoundsInWorld.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!HandMorph methodsFor: 'meta menu' stamp: 'di 7/6/1998 11:40' prior: 33744518!buildWorldMenu	"Build the meta menu for the world."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'go back' target: owner action: #goBack.	menu add: 'jump to...'		subMenu: (Project buildJumpToMenu: (MenuMorph new defaultTarget: Project)).	menu addLine.	menu add: 'paste morph' action: #pasteMorph.	menu add: 'new morph...' action: #newMorph.	World ifNotNil: [		subMenu _ MenuMorph new defaultTarget: self.		subMenu add: 'workspace' action: #openWorkspace.		subMenu add: 'browser' action: #openBrowser.		subMenu add: 'recent changes' action: #openRecentChanges.		subMenu add: 'change sorter' selector: #openChangeSorter: argument: 1.		subMenu add: 'dual sorter' selector: #openChangeSorter: argument: 2.		subMenu add: 'changes log' action: #openChangesLog.		subMenu add: 'file list' action: #openFileList.		subMenu add: 'transcript' action: #openTranscript.		subMenu add: 'project (mvc)' action: #openMVCProject.		subMenu add: 'project (morphic)' action: #openMorphicProject.		subMenu add: 'project link...' action: #projectThumbnail.		subMenu addLine.		subMenu add: 'collapse all' action: #collapseAll.		subMenu add: 'expand all' action: #expandAll.		subMenu add: 'find window' action: #findWindow.		menu add: 'open...' subMenu: subMenu].	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'grab drawing from screen' action: #grabDrawingFromScreen.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu add: 'graphics...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'add slot to model' action: #newVariable.	subMenu add: 'write init method for model' action: #writeInitMethodForModel.	subMenu add: 'grab model for this world' action: #grabModel.	menu add: 'model...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'set display depth...' action: #setDisplayDepth.	subMenu add: 'change background color' action: #changeBackgroundColor.	subMenu add: 'use texture background' target: self world action: #setStandardTexture.	subMenu add: 'unlock contents' action: #unlockWorldContents.	subMenu add: 'unhide hidden objects' action: #showHiders.	subMenu add: 'round up stray objects' action: #roundUpStrayObjects.	gridOn		ifTrue: [subMenu add: 'turn gridding off' action: #setGridding]		ifFalse: [subMenu add: 'turn gridding on' action: #setGridding].	menu add: 'options...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'update code from server' action: #updateFromServer.	subMenu addLine.	subMenu add: 'local host address' action: #reportLocalAddress.	subMenu add: 'connect remote user' action: #connectRemoteUser.	subMenu add: 'disconnect remote user' action: #disconnectRemoteUser.	subMenu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu add: 'remote...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'save world in file' action: #saveWorldInFile.	subMenu add: 'read morph(s) from file' action: #readMorphFile.	menu add: 'file...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self world.	subMenu add: 'add stop, step, & go buttons' target: self world presenter action: #addStopStepGoButtons.	subMenu add: 'add scripting knobs' target: self presenter action: #addStandardControls.	subMenu add: 'remove scripting knobs' target: self world action: #removeScriptingControls.	subMenu addLine.	subMenu add: 'parts bin' target: self presenter action: #createStandardPartsBin.	subMenu add: 'control panel' target: self presenter action: #createControlPanel.	menu add: 'scripting...' subMenu: subMenu.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'inspect world' action: #inspectWorld.	subMenu add: 'inspect model' action: #inspectWorldModel.	subMenu add: 'clear palette area' action: #clearPaletteArea.	subMenu add: 'flush viewer cache' action: #flushViewerCache.	subMenu add: 'full screen' action: #fullScreen.	subMenu add: 'start MessageTally' action: #startMessageTally.	subMenu add: 'call #tempCommand' action: #callTempCommand.	subMenu add: 'show space left' action: #showSpaceLeft.	menu add: 'debug...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save' action: #saveSession.	subMenu add: 'save as...' action: #saveAs.	subMenu add: 'save and quit' action: #saveAndQuit.	subMenu add: 'quit...' action: #quitSession.	menu add: 'save / quit...' subMenu: subMenu.	^ menu! !'From Squeak 2.1 of June 30, 1998 on 6 July 1998 at 5:21:52 pm'!!ScrollPane methodsFor: 'geometry' stamp: 'di 7/6/1998 13:11' prior: 21165004!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset r |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	(r _ self totalScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r]! !----QUIT----(23 July 1998 10:10:11 pm ) priorSource: 592906!