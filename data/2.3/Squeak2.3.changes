'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 11:30:26 am'!I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 20:06'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	f _ (FileStream readOnlyFileNamed: fileName) binary.	self readFrom: f.	f close.! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/17/1998 20:36'!edit	| ed |	ed _ WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 1/14/1999 10:12'!play	"Play the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	self sound play.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 1/14/1999 10:11'!sound	"Answer the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	^ snd! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 7/12/1998 18:24'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."	| compressionType |	channelCount _ in nextNumber: 2.	frameCount _ in nextNumber: 4.	bitsPerSample _ in nextNumber: 2.	samplingRate _ self readExtendedFloat.	chunkSize > 18 ifTrue: [		fileType = 'AIFF'			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].		compressionType _ (in next: 4) asString.		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 11:43'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp _ in nextNumber: 2.	mantissa _ in nextNumber: 8.  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign _ 1.0]		ifFalse: [sign _ -1.0].	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 19:58'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in _ aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz _ in nextNumber: 4.	end _ in position + sz.	fileType _ (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType _ (in next: 4) asString.		chunkSize _ in nextNumber: 4.		p _ in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/5/1998 17:31'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey _ in next.	detune _ in next.	lowNote _ in next.	highNote _ in next.	lowVelocity _ in next.	highVelocity _ in next.	gain _ in nextNumber: 2.	sustainMode _ in nextNumber: 2.	sustainStartID _ in nextNumber: 2.	sustainEndID _ in nextNumber: 2.	releaseMode _ in nextNumber: 2.	releaseStartID _ in nextNumber: 2.	releaseEndID _ in nextNumber: 2.	isLooped _ sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped _ false]].	pitch _ self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 21:22'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount _ in nextNumber: 2.	markers _ Array new: markerCount.	1 to: markerCount do: [:i |		id _ in nextNumber: 2.		position _ in nextNumber: 4.		labelBytes _ in next.		label _ (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:58'!readMergedStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."	| buf w1 w2 |	buf _ channelData at: 1.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w1 _ s next.				w1 > 127 ifTrue: [w1 _ w1 - 256].				w2 _ s next.				w2 > 127 ifTrue: [w2 _ w2 - 256].				buf at: i put: ((w1 + w2) bitShift: 7)]]		ifFalse: [			1 to: frameCount do: [:i |				w1 _ (s next bitShift: 8) + s next.				w1 > 32767 ifTrue: [w1 _ w1 - 65536].				w2 _ (s next bitShift: 8) + s next.				w2 > 32767 ifTrue: [w2 _ w2 - 65536].				buf at: i put: ((w1 + w2) bitShift: -1)]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:53'!readMonoChannelDataFrom: s	"Read monophonic channel data from the given stream. Each frame contains a single sample."	| buf w |	buf _ channelData at: 1.  "the only buffer"	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				buf at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				buf at: i put: w]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:55'!readMultiChannelDataFrom: s	"Read multi-channel data from the given stream. Each frame contains channelCount samples."	| w |	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ s next.					w > 127 ifTrue: [w _ w - 256].					(channelData at: ch) at: i put: (w bitShift: 8)]]]		ifFalse: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ (s next bitShift: 8) + s next.					w > 32767 ifTrue: [w _ w - 65536].					(channelData at: ch) at: i put: w]]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/3/1998 14:55'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples s |	skipDataChunk ifTrue: [in skip: chunkSize. ^ self].	offset _ in nextNumber: 4.	blockSize _ in nextNumber: 4.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples _ chunkSize - 8.	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))		ifFalse: [self error: 'actual sample count does not match COMM chunk'].	(mergeIfStereo and: [channelCount = 2])		ifTrue: [			channelData _ Array with: (SoundBuffer newMonoSampleCount: frameCount)]		ifFalse: [			channelData _				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))		ifTrue: [s _ ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"		ifFalse: [s _ in].  "not enough space to buffer; read directly from file"	"mono and stereo are special-cased for better performance"	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].	channelCount = 2 ifTrue: [		mergeIfStereo			ifTrue: [channelCount _ 1. ^ self readMergedStereoChannelDataFrom: s]			ifFalse: [^ self readStereoChannelDataFrom: s]].	self readMultiChannelDataFrom: s.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:56'!readStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream. Each frame contains two samples."	| left right w |	left _ channelData at: 1.	right _ channelData at: 2.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				left at: i put: (w bitShift: 8).				w _ s next.				w > 127 ifTrue: [w _ w - 256].				right at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				left at: i put: w.				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				right at: i put: w]].! !!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	"Subclasses should override to return the ending time if the event has some duration."	^ time! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isControlChange	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isPitchBend	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isProgramChange	^ false! !!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port. This default implementation does nothing."! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes _ #().! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !!AbstractSound methodsFor: 'playing' stamp: 'ar 12/5/1998 22:20'!isPlaying	"Return true if the receiver is currently playing"	^ SoundPlayer isPlaying: self! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just after the last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize _ self samplingRate // 10.	buf _ SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/19/1998 08:30'!viewSamples	| stereoBuf |	stereoBuf _ self computeSamplesForSeconds: self duration.	WaveEditor openOn: stereoBuf extractLeftChannel.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange _ false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange _ true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs _ 10]		ifFalse: [			env _ envelopes first.			decayInMs _ env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor _ 2 raisedTo: 15.	FloatScaleFactor _ ScaleFactor asFloat.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave _ PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:00'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch _ el at: 1.				pitch isNumber ifFalse: [pitch _ self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p _ pitchNameOrNumber asFloat]		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].	octave _ -1.	[p >= TopOfBottomOctave] whileTrue: [		octave _ octave + 1.		p _ p / 2.0].	i _ self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i _ i - 1]].	midiKey _ ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey _ 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 7/6/1998 15:47'!pitchTable	"AbstractSound pitchTable"	| out note i |	out _ WriteStream on: (String new: 1000).	i _ 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note _ noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i _ i + 1]].	^ out contents! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	pitch _ aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch _ pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale _ SequentialSound new.	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd _ endPitch asFloat]		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p _ startPitch asFloat]		ifFalse: [p _ AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p _ p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/3/1998 17:00'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale _ self majorPitchesFrom: aPitch.	score _ MixedSound new.	leadingRest _ pan _ 0.	#(1 3 5 8) do: [:noteIndex |		note _ aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest _ leadingRest + 0.2.		pan _ pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/14/1999 11:59'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod ratio |	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.	s _ FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal _ nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt _ Sensor cursorPoint.		mousePt ~= lastVal ifTrue: [			mod _ mousePt x asFloat / 20.0.			ratio _ mousePt y asFloat / 20.0.			s modulation: mod ratio: ratio.			lastVal _ mousePt.			status _'mod: ', mod printString, 'ratio: ', ratio printString.			status asParagraph displayOn: Display at: 10@10]].	SoundPlayer shutDown.! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:27'!initSounds	"AbstractSound initSounds"	Sounds _ Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 13:00'!updateFMSounds	"AbstractSound updateFMSounds"	Sounds keys do: [:k |		((Sounds at: k) isKindOf: FMSound) ifTrue: [			Sounds removeKey: k ifAbsent: []]].	(FMSound class organization listAtCategoryNamed: #instruments) do:		[:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:11'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:50'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName refStream |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	refStream _ SmartRefStream fileNamed: fileName, '.sounds'.	refStream nextPut: aDictionary.	refStream close.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:52'!updateScorePlayers	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allInstances do: [:p | p pause].	SoundPlayer shutDown.	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'jm 8/19/1998 14:22'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	"AbstractSound cCodeForSoundPrimitives"	^ CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(ReverbSound applyReverbTo:startingAt:count:)	).! !!AcceptableCleanTextMorph methodsFor: 'all' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:48'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	On Acorn, the test is whether systemAttribute 1001 = 'RiscOS' (on newer VMs) or if the primPathNameDelimiter is $. (on older ones), which is what we would like to use for a dirsep if only it would work out. See pathNameDelimiter for more woeful details - then just get on and enjoy Squeak"	| attr |	attr _ Smalltalk getSystemAttribute: 1001.	attr isNil ifFalse:[^attr = 'RiscOS'].	^self primPathNameDelimiter = $.! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/10/1998 21:45'!pathNameDelimiter"Acorn RiscOS uses a dot as the directory separator and has no real concept of filename extensions. We tried to make code handle this, but there are just too many uses of dot as a filename extension - so fake it out by pretending to use a slash. The file prims do conversions instead.Sad, but pragmatic"	^ $/! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/1/199812:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage liveText|	liveText _ HTMLformatter evalEmbedded: (pageRef text)		with: request unlessContains: (self dangerSet).	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: liveText			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: ((self formatterFor: 'page') format: formattedPage).! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/10/199815:33'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!! -- but don't complain!! Could be for ActivePage!!""	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr."! !!AlignmentMorph methodsFor: 'initialization' stamp: 'sw 10/24/1998 14:25'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder _ Morph new extent: 16 @ 16; beTransparent.	downArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/23/1998 14:18'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 11/10/1998 13:14'!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ 2 * (inset + borderWidth).	orientation = #horizontal ifTrue: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize).			(m isAlignmentMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize).			(m isAlignmentMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra asFloat / spaceFillingMorphs! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 11/10/1998 13:33'!fixLayout	| extraPerMorph fractionalExtra fractionAccumulator nextPlace extra space |	extraPerMorph _ self extraSpacePerMorph asFloat.	fractionalExtra _ extraPerMorph fractionPart.	extraPerMorph _ extraPerMorph truncated.	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	fractionAccumulator _ 0.0.	submorphs do: [:m |		fractionAccumulator _ fractionAccumulator + fractionalExtra.		fractionAccumulator > 0.5			ifTrue: [				extra _ extraPerMorph + 1.				fractionAccumulator _ fractionAccumulator - 1.0]			ifFalse: [extra _ extraPerMorph].		space _ self placeAndSize: m at: nextPlace padding: extra.		nextPlace _ nextPlace + space].! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 21:27'!morph 	^ morph! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:09'!morph: m	morph _ m! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/4/1998 15:47'!occurAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick	(target == nil or: [selector == nil]) ifTrue:		[^ morph encounteredAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick].	target perform: selector withArguments: arguments! !!AmbientEvent methodsFor: 'all' stamp: 'sw 12/30/1998 19:48'!relatedPlayer	(morph isMemberOf: MovieFrameSyncMorph)		ifFalse: [^ nil].	^ morph moviePlayerMorph! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:08'!target: t selector: s arguments: a	target _ t.	selector _ s.	arguments _ a.! !!Array methodsFor: 'converting' stamp: 'di 1/9/1999 15:11'!elementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array."	<primitive: 128>	self primitiveFailed! !!Array methodsFor: 'converting' stamp: 'di 1/9/1999 15:08'!elementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray."	<primitive: 72>	self primitiveFailed! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection _ self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!AssignmentTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: ' assign', (assignmentSuffix copyWithout: $:), 'Getter: #'.	aStream nextPutAll: (Utilities getterSelectorFor: assignmentRoot).	aStream nextPutAll: ' setter: #'.	aStream nextPutAll: (Utilities setterSelectorFor: assignmentRoot).	aStream nextPutAll: ' amt: '.! !An asynchronous file allows simple file read and write operations to be performed in parallel with other processing. This is useful in multimedia applications that need to stream large amounts of sound or image data from or to a file while doing other work.!!AsyncFile methodsFor: 'all'!close	fileHandle ifNil: [^ self].  "already closed"	self primClose: fileHandle.	Smalltalk unregisterExternalObject: semaphore.	semaphore _ nil.	fileHandle _ nil.! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!fileHandle	^ fileHandle! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 07:54'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name _ fullFileName.	writeable _ aBoolean.	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	fileHandle _ self primOpen: name forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil.		^ nil].! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 08:28'!readByteCount: byteCount fromFilePosition: fPosition onCompletionDo: aBlock	"Start a read operation to read byteCount's from the given position in this file. and fork a process to await its completion. When the operation completes, evaluate the given block. Note that, since the completion block may run asynchronous, the client may need to use a SharedQueue or a semaphore for synchronization."	| buffer n |	buffer _ String new: byteCount.	self primReadStart: fileHandle fPosition: fPosition count: byteCount.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primReadResult: fileHandle intoBuffer: buffer at: 1 count: byteCount.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].		aBlock value: buffer.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 10:07'!test: byteCount fileName: fileName	"AsyncFile new test: 10000 fileName: 'testData'"	| buf1 buf2 bytesWritten bytesRead |	buf1 _ String new: byteCount withAll: $x.	buf2 _ String new: byteCount.	self open: fileName forWrite: true.	self primWriteStart: fileHandle		fPosition: 0		fromBuffer: buf1		at: 1		count: byteCount.	semaphore wait.	bytesWritten _ self primWriteResult: fileHandle.	self close.		self open: fileName forWrite: false.	self primReadStart: fileHandle fPosition: 0 count: byteCount.	semaphore wait.	bytesRead _		self primReadResult: fileHandle			intoBuffer: buf2			at: 1			count: byteCount.	self close.	buf1 = buf2 ifFalse: [self error: 'buffers do not match'].	^ 'wrote ', bytesWritten printString, ' bytes; ',	   'read ', bytesRead printString, ' bytes'! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!waitForCompletion	semaphore wait! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 17:28'!writeBuffer: buffer atFilePosition: fPosition onCompletionDo: aBlock	"Start an operation to write the contents of the buffer at given position in this file, and fork a process to await its completion. When the write completes, evaluate the given block. Note that, since the completion block runs asynchronously, the client may need to use a SharedQueue or a semaphore for synchronization."	| n |	self primWriteStart: fileHandle		fPosition: fPosition		fromBuffer: buffer		at: 1		count: buffer size.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primWriteResult: fileHandle.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].		n = buffer size ifFalse: [^ self error: 'did not write the entire buffer'].		aBlock value.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:42'!primClose: fHandle	"Close this file. Do nothing if primitive fails."	<primitive: 540>! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:54'!primOpen: fileName forWrite: openForWrite semaIndex: semaIndex	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise."	<primitive: 541>	^ nil! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:28'!primReadResult: fHandle intoBuffer: buffer at: startIndex count: count	"Copy the result of the last read operation into the given buffer starting at the given index. The buffer may be any sort of bytes or words object, excluding CompiledMethods. Answer the number of bytes read. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 542>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:36'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 543>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:27'!primWriteResult: fHandle	"Answer the number of bytes written. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 544>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 08:35'!primWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: startIndex count: count	"Start a write operation of count bytes starting at the given index in the given buffer. The buffer may be any sort of bytes or words object, excluding CompiledMethods. The contents of the buffer are copied into an internal buffer immediately, so the buffer can be reused after the write operation has been started. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 545>	writeable ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!AsyncFile class methodsFor: 'class initialization' stamp: 'jm 6/25/1998 17:33'!initialize	"AsyncFile initialize"	"Possible abnormal I/O completion results."	Busy _ -1.	Error _ -2.! !!AtomMorph methodsFor: 'all' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p _ self position.	vx _ velocity x.		vy _ velocity y.	px _ p x + vx.		py _ p y + vy.	bounced _ false.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.		bounced _ true].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.		bounced _ true].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.		bounced _ true].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.		bounced _ true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !a stream on Text's which keeps track of the last attribute put; new characters are added with those attributes.instance vars:	characters - a WriteStream of the characters in the stream	attributeRuns - a RunArray with the attributes for the stream	currentAttributes - the attributes to be used for new text	attributesChanged - whether the attributes have changed since the last addition!!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'ls 6/27/1998 15:04'!contents	| ans |	ans _ Text new: characters size.	ans setString: characters contents  setRuns: attributeRuns.   "this is declared private, but it's exactly what I need, and it's declared as exactly what I want it to do...."	^ans! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 14:59'!nextPut: aChar	attributesChanged 		ifTrue: [ 			attributeRuns addLast: currentAttributes.			attributesChanged _ false ]		ifFalse: [			attributeRuns  repeatLastIfEmpty: [ OrderedCollection new ] ].	characters nextPut: aChar! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 15:02'!nextPutAll: aString	"add an entire string with the same attributes"	attributesChanged 		ifTrue: [ attributeRuns addLast: currentAttributes times: aString size.			attributesChanged _ false. ]		ifFalse: [ attributeRuns repeatLast: aString size  ifEmpty: [ OrderedCollection new ] ].	characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 6/27/1998 15:09'!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 7/28/1998 02:08'!currentAttributes: newAttributes	"set the current attributes"	attributesChanged _ currentAttributes ~= newAttributes.	currentAttributes _ newAttributes.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 9/10/1998 03:36'!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:08'!initialize	characters _ WriteStream on: String new.	currentAttributes _ OrderedCollection new.	attributesChanged _ true.	attributeRuns _ RunArray new.	! !!AttributedTextStream class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:07'!new	^super basicNew initialize! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/21/1998 08:23'!authorizer	"*** Do not use this method to add or delete users!!  The change will not be recorded on the disk!!  Instead call mapName:password:to: in this class.***"	^authorizer! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 7/6/1998 07:31'!checkAuthorization: request	^ authorizer ifNotNil: [authorizer user: request userID].! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/199815:32'!process: request	self checkAuthorization: request.	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/13/1998 20:45'!processSpecial: request	"Let SwikiAction process this with no authorization check."	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 6/22/1998 14:15'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| fName |	super restore: nameOfSwiki.	fName _ ServerAction serverDirectory, name, (ServerAction pathSeparator), 				'authorizer'.	(FileDirectory new fileExists: fName) ifTrue: [		authorizer _ (FileStream oldFileNamed: fName) fileInObjectAndCode].! !Allows anyone to read the pages of this Swiki, but only authorized users can edit or change pages.  Can have multiple users, each with a different password.  Each can modify the whole Swiki area.To restart an existing Authorized Swiki:	AuthorizedWriteSwiki new restore: 'SWSecure'.The front page URL is:  http://serverMachine:80/SWSecure.1To make a completely new one:	| a s |	a := Authorizer new.	a realm: 'SwikiArea'.	a mapName: 'viki' password: 'hard2guess' to: 'viki'.	AuthorizedWriteSwiki setUp: 'SWSecure'.	s := AuthorizedWriteSwiki new restore: 'SWSecure'.	s authorizer: a.!!AuthorizedWriteSwiki methodsFor: 'as yet unclassified' stamp: 'tk 9/13/1998 20:59'!process: request	"Only demand authorization of name and password when requesting the edit page, requesting the append page, receiving an edit, or receiving an append."	| command coreRef |	request fields ifNotNil: ["Are there input fields?"		coreRef _ request message size < 2			ifTrue: ['1']			ifFalse: [request message at: 2].		coreRef = 'searchresult' ifFalse: ["Must be text for an edit!!"			self checkAuthorization: request]].	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[self checkAuthorization: request].			command = 'insert' ifTrue:					[self checkAuthorization: request]].	^(super processSpecial: request).		"all the way up to SwikiAction"! !!Bag methodsFor: 'adding' stamp: 'TAG 10/13/1998 22:39'!add: newObject withOccurrences: anInteger 	"Add the element newObject to the receiver. Do so as though the element  	were added anInteger number of times. Answer newObject."	contents at: newObject put: (contents at: newObject ifAbsent: [0])			+ anInteger.	^ newObject! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end	^end! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end: aPoint	end _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!inTangent	"Return the tangent at the start point"	^via - start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialZ	^0 "Assume no depth given"! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!outTangent	"Return the tangent at the end point"	^end - via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start	^start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start: aPoint	start _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via	^via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via: aPoint	via _ aPoint! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:46'!computeInitialStateFrom: source with: transformation	"Compute the initial state in the receiver."	start _ (transformation localPointToGlobal: source start) asIntegerPoint.	end _ (transformation localPointToGlobal: source end) asIntegerPoint.	via _ (transformation localPointToGlobal: source via) asIntegerPoint.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:39'!computeSplitAt: t	"Split the receiver at the parametric value t"	| left right newVia1 newVia2 newPoint |	left _ self clone.	right _ self clone.	"Compute new intermediate points"	newVia1 _ (via - start) * t + start.	newVia2 _ (end - via) * t + via.	"Compute new point on curve"	newPoint _ ((newVia1 - newVia2) * t + newVia2) asIntegerPoint.	left via: newVia1 asIntegerPoint.	left end: newPoint.	right start: newPoint.	right via: newVia2 asIntegerPoint.	^Array with: left with: right! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 01:34'!floatStepToFirstScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.	"self xDirection: xDir.	self yDirection: yDir."	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:45'!floatStepToNextScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	[yValue asFloat > lastY] whileTrue:[		(fwDx < -50.0 or:[fwDx > 50.0]) ifTrue:[self halt].		(fwDy < -50.0 or:[fwDy > 50.0]) ifTrue:[self halt].		(fwDDx < -50.0 or:[fwDDx > 50.0]) ifTrue:[self halt].		(fwDDy < -50.0 or:[fwDDy > 50.0]) ifTrue:[self halt].		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.	].	edgeTableEntry xValue: lastX asInteger.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 16:23'!intStepToFirstScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	squaredStepSize = ((scaledStepSize * scaledStepSize) bitShift: -24)		ifFalse:[self error:'Bad computation'].	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 04:02'!intStepToNextScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	[maxSteps >= 0 and:[yValue * 256 > lastY]] whileTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].	edgeTableEntry xValue: lastX // 256.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 22:14'!isMonoton	"Return true if the receiver is monoton along the y-axis,	e.g., check if the tangents have the same sign"	^(via y - start y) * (end y - via y) >= 0! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/31/1998 16:36'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	^self intStepToFirstScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 03:40'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	^self intStepToNextScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/1/1998 00:31'!subdivide	"Subdivide the receiver"	| dy dx |	"Test 1: If the bezier curve is not monoton in Y, we need a subdivision"	self isMonoton ifFalse:[		MonotonSubdivisions _ MonotonSubdivisions + 1.		^self subdivideToBeMonoton].	"Test 2: If the receiver is horizontal, don't do anything"	(end y = start y) ifTrue:[^nil].	"Test 3: If the receiver can be represented as a straight line,			make a line from the receiver and declare it invalid"	((end - start) crossProduct: (via - start)) = 0 ifTrue:[		LineConversions _ LineConversions + 1.		^self subdivideToBeLine].	"Test 4: If the height of the curve exceeds 256 pixels, subdivide 			(forward differencing is numerically not very stable)"	dy _ end y - start y.	dy < 0 ifTrue:[dy _ dy negated].	(dy > 255) ifTrue:[		HeightSubdivisions _ HeightSubdivisions + 1.		^self subdivideAt: 0.5].	"Test 5: Check if the incremental values could possibly overflow the scaled integer range"	dx _ end x - start x.	dx < 0 ifTrue:[dx _ dx negated].	dy * 32 < dx ifTrue:[		OverflowSubdivisions _ OverflowSubdivisions + 1.		^self subdivideAt: 0.5].	^nil! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 22:13'!subdivideAt: parameter	"Subdivide the receiver at the given parameter"	| both |	(parameter <= 0.0 or:[parameter >= 1.0]) ifTrue:[self halt].	both _ self computeSplitAt: parameter.	"Transcript cr.	self quickPrint: self.	Transcript space.	self quickPrint: both first.	Transcript space.	self quickPrint: both last.	Transcript endEntry."	self via: both first via.	self end: both first end.	^both last! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/11/1998 22:15'!subdivideToBeLine	"Not a true subdivision.	Just return a line representing the receiver and fake me to be of zero height"	| line |	line _ BalloonLineSimulation new.	line start: start.	line end: end.	"Make me invalid"	end _ start.	via _ start.	 ^line! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:24'!subdivideToBeMonoton	"Subdivide the receiver at it's extreme point"	| v1 v2 t other |	v1 _ (via - start).	v2 _ (end - via).	t _ (v1 y / (v2 y - v1 y)) negated asFloat.	other _ self subdivideAt: t.	self isMonoton ifFalse:[self halt].	other isMonoton ifFalse:[self halt].	^other! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 16:37'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| halfWord1 halfWord2 result |	(value >= 0 and:[value < 16r1000000]) ifFalse:[^self error:'Value out of range'].	halfWord1 _ value bitAnd: 16rFFFF.	halfWord2 _ (value bitShift: -16) bitAnd: 255.	result _ (halfWord1 * halfWord1) bitShift: -16. "We don't need the lower 16bits at all"	result _ result + ((halfWord1 * halfWord2) * 2).	result _ result + ((halfWord2 * halfWord2) bitShift: 16).	"word1 _ halfWord1 * halfWord1.	word2 _ (halfWord2 * halfWord1) + (word1 bitShift: -16).	word1 _ word1 bitAnd: 16rFFFF.	word2 _ word2 + (halfWord1 * halfWord2).	word2 _ word2 + ((halfWord2 * halfWord2) bitShift: 16)."	^result bitShift: -8! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDraw	| entry minY maxY lX lY canvas |	entry _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	self stepToFirstScanLineAt: minY in: entry.	lX _ entry xValue.	lY _ entry yValue.	minY+1 to: maxY do:[:y|		self stepToNextScanLineAt: y in: entry.		canvas line: lX@lY to: entry xValue @ y width: 2 color: Color black.		lX _ entry xValue.		lY _ y.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!debugDraw2	| canvas last max t next |	canvas _ FormCanvas on: Display.	max _ 100.	last _ nil.	0 to: max do:[:i|		t _ i asFloat / max asFloat.		next _ self valueAt: t.		last ifNotNil:[			canvas line: last to: next rounded width: 2 color: Color blue.		].		last _ next rounded.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDrawWide: n	| entry minY maxY canvas curve p1 p2 entry2 y |	curve _ self class new.	curve start: start + (0@n).	curve via: via + (0@n).	curve end: end + (0@n).	entry _ BalloonEdgeData new.	entry2 _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	entry2 yValue: minY + n.	self stepToFirstScanLineAt: minY in: entry.	curve stepToFirstScanLineAt: minY+n in: entry2.	y _ minY.	1 to: n do:[:i|		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p1 _ entry xValue @ y.		canvas line: p1 to: p1 + (n@0) width: 1 color: Color black.	].	[y < maxY] whileTrue:[		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p2 _ (entry xValue + n) @ y.		curve stepToNextScanLineAt: y in: entry2.		p1 _ entry2 xValue @ y.		canvas line: p1 to: p2 width: 1 color: Color black.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:35'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: via;		nextPutAll:' - ';		print: end;		nextPut:$)! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 21:56'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 22:13'!quickPrint: curve first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).	Transcript endEntry.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:53'!stepToFirst	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^self].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:50'!stepToFirstInt	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	self halt.	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^nil].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ (scaledStepSize * scaledStepSize) bitShift: -24.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:26'!stepToNext		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 04:01'!stepToNextInt	"Scaled integer version of forward differencing"	self halt.	(maxSteps >= 0) ifTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:27'!validateIntegerRange	fwDx class == SmallInteger ifFalse:[self halt].	fwDy class == SmallInteger ifFalse:[self halt].	fwDDx class == SmallInteger ifFalse:[self halt].	fwDDy class == SmallInteger ifFalse:[self halt].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!valueAt: parameter	"Return the point at the value parameter:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!BalloonBezierSimulation class methodsFor: 'class initialization' stamp: 'ar 10/30/1998 03:04'!initialize	"GraphicsBezierSimulation initialize"	HeightSubdivisions _ 0.	LineConversions _ 0.	MonotonSubdivisions _ 0.	OverflowSubdivisions _ 0.! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index	"For simulation only"	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index put: anInteger	"For simulation only"	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:52'!floatAt: index	"For simulation only"	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:52'!floatAt: index put: value	"For simulation only"	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!BalloonBuffer methodsFor: 'private' stamp: 'ar 11/24/1998 20:52'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!BalloonBuffer methodsFor: 'private' stamp: 'ar 11/24/1998 20:52'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!mew: n	^self new: (n max: 256)! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!new	^self new: 256.! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:28'!flush	"Force all pending primitives onscreen"	engine ifNotNil:[engine flush].! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 12/30/1998 10:54'!initialize	aaLevel _ 1.	deferred _ false.! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:25'!resetEngine	engine _ nil.! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/13/1998 01:02'!aaLevel	^aaLevel! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:53'!aaLevel: newLevel	"Only allow changes to aaLevel if we're working on >= 8 bit forms"	form depth >= 8 ifFalse:[^self].	aaLevel = newLevel ifTrue:[^self].	self flush.	"In case there are pending primitives in the engine"	aaLevel _ newLevel.	engine ifNotNil:[engine aaLevel: aaLevel].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:54'!deferred	^deferred! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:55'!deferred: aBoolean	deferred == aBoolean ifTrue:[^self].	self flush. "Force pending prims on screen"	deferred _ aBoolean.	engine ifNotNil:[engine deferred: aBoolean].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:55'!ensuredEngine	engine ifNil:[		true			ifTrue:[engine _ BalloonEngine new]			ifFalse:[engine _ BalloonDebugEngine new].		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine deferred: deferred.		engine].	engine colorTransform: colorTransform.	engine edgeTransform: transform.	^engine! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^true! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/12/1998 01:07'!isVisible: aRectangle	^transform 		ifNil:[super isVisible: aRectangle]		ifNotNil:[super isVisible: (transform localBoundsToGlobal: aRectangle)]! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 22:33'!copy	self flush.	^super copy resetEngine! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:20'!fillColor: c	"Note: This always fills, even if the color is transparent."	"Note2: To achieve the above we must make sure that c is NOT transparent"	self frameAndFillRectangle: form boundingBox 		fillColor: (c alpha: 1.0)		borderWidth: 0		borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:45'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	^self drawOval: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:49'!fillRectangle: r color: c	^self frameAndFillRectangle: r			fillColor: c			borderWidth: 0			borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:56'!frameAndFillRectangle: r fillColor: c borderWidth: borderWidth borderColor: borderColor	^self drawRectangle: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| bw |	"Fill rectangle and draw top and left border"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now draw bottom right border.	Note: Must inset this manually!!"	bw _ borderWidth // 2.	self drawPolygon: (Array with: r topRight + (bw negated@bw) 							with: r bottomRight - bw asPoint							with: r bottomLeft + (bw@bw negated))		color: nil		borderWidth: borderWidth		borderColor: bottomRightColor.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:42'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r			fillColor: nil			borderWidth: w			borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!line: pt1 to: pt2 width: w color: c	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:39'!point: pt color: c	"Is there any use for this?"	| myPt |	transform 		ifNil:[myPt _ pt]		ifNotNil:[myPt _ transform localPointToGlobal: pt].	^super point: myPt color: c! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawBezierShape: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a boundary shape that is defined by a list of vertices.	Each three subsequent vertices define a quadratic bezier segment.	For lines, the control point should be set to either the start or the end	of the bezier curve."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawBezierShape: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/24/1998 15:16'!drawCompressedShape: compressedShape	"Draw a compressed shape"	self ensuredEngine		drawCompressedShape: compressedShape		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawGeneralBezierShape: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general boundary shape (e.g., possibly containing holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralBezierShape: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:49'!drawGeneralPolygon: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general polygon (e.g., a polygon that can contain holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralPolygon: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw the oval defined by the given rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawOval: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:50'!drawPolygon: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawPolygon: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawRectangle: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawRectangle: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:36'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	^super image: aForm at: aPoint sourceRect: sourceRect rule: rule! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/12/1998 13:33'!line: point1 to: point2 brushForm: brush	| pt1 pt2 |	transform 		ifNil:[pt1 _ point1. pt2 _ point2]		ifNotNil:[pt1 _ transform localPointToGlobal: point1.				pt2 _ transform localPointToGlobal: point2].	^super line: pt1 to: pt2 brushForm: brush! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:38'!paragraph: para bounds: bounds color: c	^super paragraph: para bounds: bounds color: c! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:39'!text: s bounds: boundsRect font: fontOrNil color: c	^super text: s bounds: boundsRect font: fontOrNil color: c! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform	aColorTransform ifNil:[^self].	colorTransform 		ifNil:[colorTransform _ aColorTransform]		ifNotNil:[colorTransform _ colorTransform composedWithLocal: aColorTransform]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 12/30/1998 10:47'!preserveStateDuring: aBlock	| state result |	state _ BalloonState new.	state transform: transform.	state colorTransform: colorTransform.	state aaLevel: self aaLevel.	result _ aBlock value: self.	transform _ state transform.	colorTransform _ state colorTransform.	self aaLevel: state aaLevel.	^result! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform	aTransform ifNil:[^self].	transform 		ifNil:[transform _ aTransform]		ifNotNil:[transform _ transform composedWithLocal: aTransform]! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 11/11/1998 20:12'!drawColor: c	(c isNil or:[c isTransparent]) ifTrue:[^nil].	^shadowDrawing		ifTrue:[Color gray]		ifFalse:[c]! !!BalloonCanvas methodsFor: 'converting' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^self! !!BalloonCanvas class methodsFor: 'instance creation' stamp: 'ar 11/11/1998 19:14'!new	^super new initialize! !!BalloonDebugEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:30'!initialize	super initialize.	deferred _ true.! !!BalloonDebugEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 01:45'!reset	workBuffer _ BalloonBuffer new: 400000.	super reset.! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:04'!primClipRectInto: rect	^BalloonEnginePlugin doPrimitive:'gePrimitiveGetClipRect'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/25/1998 22:29'!primFlushNeeded	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveNeedsFlush'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:04'!primGetAALevel	"Set the AA level"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetAALevel'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:04'!primGetBezierStats: statsArray	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetBezierStats'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:04'!primGetClipRect: rect	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetClipRect'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primGetCounts: statsArray	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetCounts'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:55'!primGetDepth	"Set the AA level"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetDepth'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primGetFailureReason	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetFailureReason'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primGetOffset	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetOffset'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primGetTimes: statsArray	^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetTimes'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/25/1998 22:20'!primNeedsFlush	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveNeedsFlush'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primSetAALevel: level	"Set the AA level"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetAALevel'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:05'!primSetClipRect: rect	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetClipRect'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:06'!primSetColorTransform: transform	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetColorTransform'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:06'!primSetDepth: depth	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetDepth'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:06'!primSetEdgeTransform: transform	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetEdgeTransform'! !!BalloonDebugEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:06'!primSetOffset: point	^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetOffset'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:11'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezier'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:01'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezierShape'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/27/1998 14:27'!primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBitmapFill'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:01'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddCompressedShape'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:02'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalEdge'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:02'!primAddExternalFill: index	^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalFill'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:02'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddGradientFill'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:16'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddLine'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:03'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddOval'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:03'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddPolygon'! !!BalloonDebugEngine methodsFor: 'primitives-adding' stamp: 'ar 11/24/1998 21:20'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddRect'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 20:59'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddActiveEdgeEntry'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 20:59'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveChangedActiveEdgeEntry'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 20:59'!primDisplaySpanBuffer	"Display the current scan line if necessary"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveDisplaySpanBuffer'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 20:59'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveFinishedProcessing'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeProcessing'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	^BalloonEnginePlugin doPrimitive: 'gePrimitiveMergeFillFrom'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextActiveEdgeEntry'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextFillEntry'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextGlobalEdgeEntry'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderImage'! !!BalloonDebugEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/24/1998 21:00'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderScanline'! !!BalloonDebugEngine methodsFor: 'primitives-misc' stamp: 'ar 11/24/1998 20:59'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	^BalloonEnginePlugin doPrimitive: 'gePrimitiveCopyBuffer'! !!BalloonDebugEngine methodsFor: 'primitives-misc' stamp: 'ar 11/24/1998 20:59'!primInitializeBuffer: buffer	^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeBuffer'! !BalloonEdgeData defines an entry in the internal edge table of the Balloon engine.Instance Variables:	index	<Integer>	The index into the external objects array of the associated graphics engine	xValue	<Integer>	The computed x-value of the requested operation	yValue	<Integer>	The y-value for the requested operation	height	<Integer>	The (remaining) height of the edge	source	<Object>		The object from the external objects array!!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!index	^index! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!index: anInteger	index _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines	^lines! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines: anInteger	^lines _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!source	^source! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 21:39'!source: anObject	source _ anObject! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!xValue	^xValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!xValue: anInteger	xValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!yValue	^yValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!yValue: anInteger	yValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue	^zValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue: anInteger	zValue _ anInteger! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToFirstScanLine	source stepToFirstScanLineAt: yValue in: self! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToNextScanLine	source stepToNextScanLineAt: yValue in: self! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:29'!flush	"Force all pending primitives onscreen"	workBuffer ifNil:[^self].	self copyBits.	self release.! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 12/30/1998 11:24'!initialize	externals _ OrderedCollection new: 100.	span _ Bitmap new: 2048.	bitBlt _ nil.	self bitBlt: ((BitBlt toForm: Display) destRect: Display boundingBox; yourself).	forms _ #().	deferred _ false.! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:42'!postFlushIfNeeded	"Force all pending primitives onscreen"	workBuffer ifNil:[^self].	(deferred not or:[postFlushNeeded]) ifTrue:[		self copyBits.		self release].! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:43'!preFlushIfNeeded	"Force all pending primitives onscreen"	workBuffer ifNil:[^self].	self primFlushNeeded ifTrue:[		self copyBits.		self reset].! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/11/1998 22:52'!release	self class recycleBuffer: workBuffer.	workBuffer _ nil.! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:34'!reset	workBuffer ifNil:[workBuffer _ self class allocateOrRecycleBuffer: 10000].	self primInitializeBuffer: workBuffer.	self primSetAALevel: self aaLevel.	self primSetOffset: destOffset.	self primSetClipRect: clipRect.	self primSetEdgeTransform: edgeTransform.	self primSetColorTransform: colorTransform.	forms _ #().! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/25/1998 22:39'!resetIfNeeded	workBuffer ifNil:[self reset].	self primSetEdgeTransform: edgeTransform.	self primSetColorTransform: colorTransform.	self primSetDepth: self primGetDepth + 1.	postFlushNeeded _ false.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:43'!drawBezierShape: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	| fills |	self edgeTransform: aTransform.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderFill.	self primAddBezierShape: points		segments: points size		fill: (fills at: 1)		lineWidth: borderWidth		lineFill: (fills at: 2).	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:44'!drawCompressedShape: shape transform: aTransform	| fillIndexList |	self edgeTransform: aTransform.	self resetIfNeeded.	fillIndexList _ self registerFills: shape fillStyles.	self primAddCompressedShape: shape points		segments: shape numSegments		leftFills: shape leftFills		rightFills: shape rightFills		lineWidths: shape lineWidths		lineFills: shape lineFills		fillIndexList: fillIndexList.	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 1/15/1999 03:02'!drawGeneralBezierShape: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	| fills |	self edgeTransform: aTransform.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderFill.	contours do:[:points|		self primAddBezierShape: points			segments: (points size // 3)			fill: (fills at: 1)			lineWidth: borderWidth			lineFill: (fills at: 2).		"Note: To avoid premature flushing of the pipeline we need to		reset the flush bit within the engine."		self primFlushNeeded: false.	].	"And set the flush bit afterwards"	self primFlushNeeded: true.	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 1/15/1999 03:02'!drawGeneralPolygon: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	| fills |	self edgeTransform: aTransform.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderFill.	contours do:[:points|		self primAddPolygon: points			segments: points size			fill: (fills at: 1)			lineWidth: borderWidth			lineFill: (fills at: 2).		"Note: To avoid premature flushing of the pipeline we need to		reset the flush bit within the engine."		self primFlushNeeded: false.	].	"And set the flush bit afterwards"	self primFlushNeeded: true.	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:45'!drawOval: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	| fills |	self edgeTransform: aMatrix.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderColor.	self primAddOvalFrom: rect origin 			to: rect corner			fillIndex: (fills at: 1)			borderWidth: borderWidth			borderColor: (fills at: 2).	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:45'!drawPolygon: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	| fills |	self edgeTransform: aTransform.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderFill.	self primAddPolygon: points		segments: points size		fill: (fills at: 1)		lineWidth: borderWidth		lineFill: (fills at: 2).	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:45'!drawRectangle: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	| fills |	self edgeTransform: aMatrix.	self resetIfNeeded.	fills _ self registerFill: fillStyle and: borderColor.	self primAddRectFrom: rect origin 			to: rect corner			fillIndex: (fills at: 1)			borderWidth: borderWidth			borderColor: (fills at: 2).	self postFlushIfNeeded.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 1/14/1999 15:24'!registerFill: aFillStyle	"Register the given fill style."	| theForm |	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle scaledPixelValue32].	aFillStyle isGradientFill ifTrue:[		^self primAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill		].	aFillStyle isBitmapFill ifTrue:[		theForm _ aFillStyle form.		theForm unhibernate.		forms _ forms copyWith: theForm.		^self primAddBitmapFill: theForm				colormap: (theForm colormapIfNeededForDepth: 32)				tile: aFillStyle isTiled				from: aFillStyle origin				along: aFillStyle direction				normal: aFillStyle normal				xIndex: forms size].	^0! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:45'!registerFill: fill1 and: fill2	^self registerFills: (Array with: fill1 with: fill2)! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 1/14/1999 15:24'!registerFill: aFillStyle transform: aTransform	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle scaledPixelValue32].	aFillStyle isGradientFill ifTrue:[		^self primAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill			matrix: aTransform.		].	^0! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/26/1998 19:45'!registerFills: fills	| fillIndexList index fillIndex |	"Check if we need to flush the engine.	We do need to do this if any of the fills is a bitmap fill"	(fills contains:[:any| any notNil and:[any isBitmapFill]])		ifTrue:[	self preFlushIfNeeded.				postFlushNeeded _ true].	fillIndexList _ WordArray new: fills size.	index _ 1.	[index <= fills size] whileTrue:[		fillIndex _ self registerFill: (fills at: index).		fillIndex == nil 			ifTrue:[index _ 1] "Need to start over"			ifFalse:[fillIndexList at: index put: fillIndex.					index _ index+1]	].	^fillIndexList! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/25/1998 00:45'!canProceedAfter: failureReason	"Check if we can proceed after the failureReason indicated."	| newBuffer |	failureReason = GErrorNeedFlush ifTrue:[		"Need to flush engine before proceeding"		self copyBits.		self reset.		^true].	failureReason = GErrorNoMoreSpace ifTrue:[		"Work buffer is too small"		newBuffer _ workBuffer species new: workBuffer size * 2.		self primCopyBufferFrom: workBuffer to: newBuffer.		workBuffer _ newBuffer.		^true].	"Not handled"	^false! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/29/1998 18:22'!copyBits	self copyLoopFaster.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoop	"This is the basic rendering loop using as little primitive support as possible."	| finished edge fill |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	self primInitializeProcessing. "Initialize the GE for processing"	[self primFinishedProcessing] whileFalse:[		"Step 1: Process the edges in the global edge table that will be added in this step"		[finished _ self primNextGlobalEdgeEntryInto: edge.		finished] whileFalse:[			edge source: (externals at: edge index).			edge stepToFirstScanLine.			self primAddActiveEdgeTableEntryFrom: edge].		"Step 2: Scan the active edge table"		[finished _ self primNextFillEntryInto: fill.		finished] whileFalse:[			fill source: (externals at: fill index).			"Compute the new fill"			fill computeFill.			"And mix it in the out buffer"			self primMergeFill: fill destForm bits from: fill].		"Step 3: Display the current span buffer if necessary"		self primDisplaySpanBuffer.		"Step 4: Advance and resort the active edge table"		[finished _ self primNextActiveEdgeEntryInto: edge.		finished] whileFalse:[			"If the index is zero then the edge has been handled by the GE"			edge source: (externals at: edge index).			edge stepToNextScanLine.			self primChangeActiveEdgeTableEntryFrom: edge].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoopFaster	"This is a copy loop drawing one scan line at a time"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderScanline: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:33'!copyLoopFastest	"This is a copy loop drawing the entire image"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderImage: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:19'!processStopReason: reason edge: edge fill: fill	"The engine has stopped because of some reason.	Try to figure out how to respond and do the necessary actions."	"Note: The order of operations below can affect the speed"	"Process unknown fills first"	reason = GErrorFillEntry ifTrue:[		fill source: (externals at: fill index).		"Compute the new fill"		fill computeFill.		"And mix it in the out buffer"		^self primMergeFill: fill destForm bits from: fill].	"Process unknown steppings in the AET second"	reason = GErrorAETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToNextScanLine.		^self primChangeActiveEdgeTableEntryFrom: edge].	"Process unknown entries in the GET third"	reason = GErrorGETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToFirstScanLine.		^self primAddActiveEdgeTableEntryFrom: edge].	"Process generic problems last"	(self canProceedAfter: reason) ifTrue:[^self]. "Okay."	^self error:'Unkown stop reason in graphics engine'! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel	^aaLevel ifNil:[1]! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel: anInteger	aaLevel _ (anInteger min: 4) max: 1.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!aaTransform	"Return a transformation for the current anti-aliasing level"	| matrix |	matrix _ MatrixTransform2x3 withScale: (self aaLevel) asFloat asPoint.	matrix offset: (self aaLevel // 2) asFloat asPoint.	^matrix composedWith:(MatrixTransform2x3 withOffset: destOffset asFloatPoint)! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 03:04'!bitBlt	^bitBlt! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:07'!bitBlt: aBitBlt	bitBlt _ aBitBlt.	bitBlt isNil ifTrue:[^self].	self clipRect: bitBlt clipRect.	bitBlt 		sourceForm: (Form extent: span size @ 1 depth: 32 bits: span);		sourceRect: (0@0 extent: 1@span size);		colorMap: (Color colorMapIfNeededFrom: 32 to: bitBlt destForm depth);		combinationRule: (bitBlt destForm depth >= 8 ifTrue:[34] ifFalse:[Form paint]).! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:57'!clipRect	^clipRect! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 02:44'!clipRect: aRect	clipRect _ aRect truncated! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform	^colorTransform! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 12/30/1998 11:24'!deferred	^deferred! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 12/30/1998 11:24'!deferred: aBoolean	deferred _ aBoolean.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:56'!destOffset	^destOffset! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/12/1998 00:22'!destOffset: aPoint	destOffset _ aPoint asIntegerPoint.	bitBlt destX: aPoint x; destY: aPoint y.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/25/1998 22:34'!edgeTransform	^edgeTransform! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/25/1998 22:34'!edgeTransform: aTransform	edgeTransform _ aTransform.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!fullTransformFrom: aMatrix	| m |	m _ self aaTransform composedWith: aMatrix.	"m offset: m offset + destOffset."	^m! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primClipRectInto: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive:'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/26/1998 19:46'!primFlushNeeded	<primitive:'gePrimitiveNeedsFlush'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 1/15/1999 03:03'!primFlushNeeded: aBoolean	<primitive:'gePrimitiveNeedsFlushPut'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetAALevel	"Set the AA level"	<primitive: 'gePrimitiveGetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetBezierStats: statsArray	<primitive:'gePrimitiveGetBezierStats'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetBezierStats'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetClipRect: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetCounts: statsArray	<primitive:'gePrimitiveGetCounts'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetCounts'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/26/1998 19:46'!primGetDepth	<primitive:'gePrimitiveGetDepth'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetFailureReason	<primitive: 'gePrimitiveGetFailureReason'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetFailureReason'].	^0! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetOffset	<primitive: 'gePrimitiveGetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetTimes: statsArray	<primitive:'gePrimitiveGetTimes'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetTimes'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetAALevel: level	"Set the AA level"	<primitive: 'gePrimitiveSetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetClipRect: rect	<primitive: 'gePrimitiveSetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/26/1998 19:47'!primSetColorTransform: transform	<primitive:'gePrimitiveSetColorTransform'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/26/1998 19:47'!primSetDepth: depth	<primitive:'gePrimitiveSetDepth'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/26/1998 19:47'!primSetEdgeTransform: transform	<primitive:'gePrimitiveSetEdgeTransform'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetOffset: point	<primitive: 'gePrimitiveSetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'gePrimitiveAddBezier'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'gePrimitiveAddBezierShape'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/27/1998 14:27'!primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	<primitive: 'gePrimitiveAddBitmapFill'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	<primitive: 'gePrimitiveAddCompressedShape'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'gePrimitiveRegisterExternalEdge'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddExternalFill: index	<primitive: 'gePrimitiveRegisterExternalFill'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalFill: index	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:53'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial	<primitive: 'gePrimitiveAddGradientFill'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddGradientFill: colorRamp 				from: origin 				along: direction 				normal: normal 				radial: isRadial	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:52'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'gePrimitiveAddLine'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:51'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'gePrimitiveAddOval'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/26/1998 19:52'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'gePrimitiveAddPolygon'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 1/14/1999 15:37'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'gePrimitiveAddRect'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/14/1998 20:47'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	<primitive: 'gePrimitiveAddActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddActiveEdgeEntry'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddActiveEdgeTableEntryFrom: edgeEntry	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	<primitive: 'gePrimitiveChangedActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveChangedActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primDisplaySpanBuffer	"Display the current scan line if necessary"	<primitive: 'gePrimitiveDisplaySpanBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveDisplaySpanBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	<primitive: 'gePrimitiveFinishedProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveFinishedProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	<primitive: 'gePrimitiveInitializeProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	<primitive: 'gePrimitiveMergeFillFrom'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveMergeFillFrom'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	<primitive: 'gePrimitiveNextFillEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextFillEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextGlobalEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextGlobalEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderImage'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderImage'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderScanline'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderScanline'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	<primitive: 'gePrimitiveCopyBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveCopyBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primInitializeBuffer: buffer	<primitive: 'gePrimitiveInitializeBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:53'!registerBezier: aCurve transformation: aMatrix	self primAddBezierFrom: aCurve start		to: aCurve end		via: aCurve via		leftFillIndex: (self registerFill: aCurve leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aCurve rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!registerBoundary: boundaryObject transformation: aMatrix	| external |	external _ boundaryObject asEdgeRepresentation: (self fullTransformFrom: aMatrix).	self subdivideExternalEdge: external from: boundaryObject.! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerExternalEdge: externalEdge from: boundaryObject	externals addLast: externalEdge.	self primAddExternalEdge: externals size		initialX: externalEdge initialX		initialY: externalEdge initialY		initialZ: externalEdge initialZ		leftFillIndex: (self registerFill: boundaryObject leftFill transform: nil)		rightFillIndex: (self registerFill: boundaryObject rightFill transform: nil)! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerLine: aLine transformation: aMatrix	self primAddLineFrom: aLine start to: aLine end		leftFillIndex: (self registerFill: aLine leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aLine rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!subdivideExternalEdge: external from: boundaryObject	| external2 |	external2 _ external subdivide.	external2 notNil ifTrue:[		self subdivideExternalEdge: external from: boundaryObject.		self subdivideExternalEdge: external2 from: boundaryObject.	] ifFalse:[		self registerExternalEdge: external from: boundaryObject.	].! !!BalloonEngine methodsFor: 'profiling' stamp: 'ar 11/11/1998 21:16'!doAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	"Note: This method is for profiling the overhead of loading a compressed shape into the engine."	^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix! !!BalloonEngine class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:44'!new	^super new initialize! !!BalloonEngine class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:49'!initialize	"BalloonEngine initialize"	BufferCache _ WeakArray new: 1.	Smalltalk garbageCollect. "Make the cache old"	CacheProtect _ Semaphore forMutualExclusion.	Times _ WordArray new: 10.	Counts _ WordArray new: 10.	BezierStats _ WordArray new: 4.	Debug ifNil:[Debug _ false].! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/25/1998 17:37'!debug: aBoolean	"BalloonEngine debug: true"	"BalloonEngine debug: false"	Debug _ aBoolean! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 1/12/1999 11:17'!doProfileStats: aBool	"Note: On Macintosh systems turning on profiling can significantly	degrade the performance of Balloon since we're using the high	accuracy timer for measuring."	"BalloonEngine doProfileStats: true"	"BalloonEngine doProfileStats: false"	<primitive: 'gePrimitiveDoProfileStats'>	^false! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!printBezierStats	"BalloonEngine printBezierStats"	"BalloonEngine resetBezierStats"	Transcript 		cr; nextPutAll:'Bezier statistics:';		crtab; print: (BezierStats at: 1); tab; nextPutAll:' non-monoton curves splitted';		crtab; print: (BezierStats at: 2); tab; nextPutAll:' curves splitted for numerical accuracy';		crtab; print: (BezierStats at: 3); tab; nextPutAll:' curves splitted to avoid integer overflow';		crtab; print: (BezierStats at: 4); tab; nextPutAll:' curves internally converted to lines';	endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:59'!printStat: time count: n string: aString	Transcript		cr;		print: time; tab;		nextPutAll:' mSecs -- ';		print: n; tab;		nextPutAll:' ops -- ';		print: ((time asFloat / (n max: 1) asFloat) roundTo: 0.01); tab;		nextPutAll: ' avg. mSecs/op -- ';		nextPutAll: aString.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 1/12/1999 10:52'!printStats	"BalloonEngine doProfileStats: true"	"BalloonEngine printStats"	"BalloonEngine resetStats"	Transcript cr; nextPutAll:'/************** BalloonEngine statistics ****************/'.	self printStat: (Times at: 1) count: (Counts at: 1) string: 'Initialization'.	self printStat: (Times at: 2) count: (Counts at: 2) string: 'Finish test'.	self printStat: (Times at: 3) count: (Counts at: 3) string: 'Fetching/Adding GET entries'.	self printStat: (Times at: 4) count: (Counts at: 4) string: 'Adding AET entries'.	self printStat: (Times at: 5) count: (Counts at: 5) string: 'Fetching/Computing fills'.	self printStat: (Times at: 6) count: (Counts at: 6) string: 'Merging fills'.	self printStat: (Times at: 7) count: (Counts at: 7) string: 'Displaying span buffer'.	self printStat: (Times at: 8) count: (Counts at: 8) string: 'Fetching/Updating AET entries'.	self printStat: (Times at: 9) count: (Counts at: 9) string: 'Changing AET entries'.	Transcript cr; print: Times sum; nextPutAll:' mSecs for all operations'.	Transcript cr; print: Counts sum; nextPutAll: ' overall operations'.	Transcript endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!resetBezierStats	BezierStats _ WordArray new: 4.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:38'!resetStats	Times _ WordArray new: 10.	Counts _ WordArray new: 10.! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:50'!allocateOrRecycleBuffer: initialSize	"Try to recycly a buffer. If this is not possibly, create a new one."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		BufferCache at: 1 put: nil.	].	^buffer ifNil:[BalloonBuffer new: initialSize]! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:51'!recycleBuffer: balloonBuffer	"Try to keep the buffer for later drawing operations."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		(buffer isNil or:[buffer size < balloonBuffer size] )			ifTrue:[BufferCache at: 1 put: balloonBuffer].	].! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskGet	^workBuffer at: GWAAColorMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskPut: value	^workBuffer at: GWAAColorMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftGet	^workBuffer at: GWAAColorShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftPut: value	^workBuffer at: GWAAColorShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaHalfPixelGet	^workBuffer at: GWAAHalfPixel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaHalfPixelPut: value	^workBuffer at: GWAAHalfPixel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelGet	^workBuffer at: GWAALevel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelPut: value	^workBuffer at: GWAALevel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskGet	^workBuffer at: GWAAScanMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskPut: value	^workBuffer at: GWAAScanMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaShiftGet	^workBuffer at: GWAAShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:36'!aaShiftPut: value	^workBuffer at: GWAAShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetStartGet	^workBuffer at: GWAETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetStartPut: value	^workBuffer at: GWAETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetUsedGet	^workBuffer at: GWAETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetUsedPut: value	^workBuffer at: GWAETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:43'!clearSpanBufferGet	^workBuffer at: GWClearSpanBuffer! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:44'!clearSpanBufferPut: value	^workBuffer at: GWClearSpanBuffer put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXGet	^workBuffer at: GWClipMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXPut: value	^workBuffer at: GWClipMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYGet	^workBuffer at: GWClipMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYPut: value	^workBuffer at: GWClipMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMinXGet	^workBuffer at: GWClipMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinXPut: value	^workBuffer at: GWClipMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYGet	^workBuffer at: GWClipMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYPut: value	^workBuffer at: GWClipMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!colorTransform	self returnTypeC:'float *'.	^self cCoerce: workBuffer + GWColorTransform to:'float *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!currentYGet	^workBuffer at: GWCurrentY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 21:27'!currentYPut: value	^workBuffer at: GWCurrentY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 20:28'!currentZGet	^workBuffer at: GWCurrentZ! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 20:29'!currentZPut: value	^workBuffer at: GWCurrentZ put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetXGet	^workBuffer at: GWDestOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetXPut: value	^workBuffer at: GWDestOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetYGet	^workBuffer at: GWDestOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetYPut: value	^workBuffer at: GWDestOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!edgeTransform	self returnTypeC:'float *'.	^self cCoerce: workBuffer + GWEdgeTransform to:'float *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxXGet	^workBuffer at: GWFillMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!fillMaxXPut: value	^workBuffer at: GWFillMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxYGet	^workBuffer at: GWFillMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMaxYPut: value	^workBuffer at: GWFillMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinXGet	^workBuffer at: GWFillMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinXPut: value	^workBuffer at: GWFillMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinYGet	^workBuffer at: GWFillMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinYPut: value	^workBuffer at: GWFillMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetXGet	^workBuffer at: GWFillOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetXPut: value	^workBuffer at: GWFillOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetYGet	^workBuffer at: GWFillOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetYPut: value	^workBuffer at: GWFillOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListGet	^workBuffer at: GWPointListFirst! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListPut: value	^workBuffer at: GWPointListFirst put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getStartGet	^workBuffer at: GWGETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!getStartPut: value	^workBuffer at: GWGETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getUsedGet	^workBuffer at: GWGETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!getUsedPut: value	^workBuffer at: GWGETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasColorTransformGet	^workBuffer at: GWHasColorTransform! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasColorTransformPut: value	^workBuffer at: GWHasColorTransform put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasEdgeTransformGet	^workBuffer at: GWHasEdgeTransform! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:35'!hasEdgeTransformPut: value	^workBuffer at: GWHasEdgeTransform put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/9/1998 15:36'!incrementStat: statIndex by: value	^workBuffer at: statIndex put: (workBuffer at: statIndex) + value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!lastExportedEdgeGet	^workBuffer at: GWLastExportedEdge! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 20:11'!lastExportedEdgePut: value	^workBuffer at: GWLastExportedEdge put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillGet	^workBuffer at: GWLastExportedFill! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillPut: value	^workBuffer at: GWLastExportedFill put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXGet	^workBuffer at: GWLastExportedLeftX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXPut: value	^workBuffer at: GWLastExportedLeftX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXGet	^workBuffer at: GWLastExportedRightX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXPut: value	^workBuffer at: GWLastExportedRightX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!magicNumberGet	^workBuffer at: GWMagicIndex! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:39'!magicNumberPut: value	^workBuffer at: GWMagicIndex put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/25/1998 00:20'!needsFlushGet	^workBuffer at: GWNeedsFlush! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/25/1998 00:20'!needsFlushPut: value	^workBuffer at: GWNeedsFlush put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objStartGet	^workBuffer at: GWObjStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objStartPut: value	^workBuffer at: GWObjStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objUsedGet	^workBuffer at: GWObjUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objUsedPut: value	^workBuffer at: GWObjUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:33'!point1Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint1 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point2Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint2 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point3Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint3 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/1/1998 03:13'!point4Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint4 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndAAGet	^workBuffer at: GWSpanEndAA! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndAAPut: value	^workBuffer at: GWSpanEndAA put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndGet	^workBuffer at: GWSpanEnd! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndPut: value	^workBuffer at: GWSpanEnd put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanSizeGet	^workBuffer at: GWSpanSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanSizePut: value	^workBuffer at: GWSpanSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanStartGet	^workBuffer at: GWSpanStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanStartPut: value	^workBuffer at: GWSpanStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stateGet	^workBuffer at: GWState! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!statePut: value	^workBuffer at: GWState put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stopReasonGet	^workBuffer at: GWStopReason! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!stopReasonPut: value	^workBuffer at: GWStopReason put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!wbSizeGet	^workBuffer at: GWSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:37'!wbSizePut: value	^workBuffer at: GWSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:29'!wbTopGet	^workBuffer at: GWBufferTop! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!wbTopPut: value	^workBuffer at: GWBufferTop put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:22'!obj: object at: index	^objBuffer at: object + index! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:22'!obj: object at: index put: value	^objBuffer at: object + index put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:02'!objectHeaderOf: obj	^self makeUnsignedFrom:(self obj: obj at: GEObjectType)! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectIndexOf: obj	^self obj: obj at: GEObjectIndex! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectIndexOf: obj put: value	^self obj: obj at: GEObjectIndex put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectLengthOf: obj	^self obj: obj at: GEObjectLength! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectLengthOf: obj put: value	^self obj: obj at: GEObjectLength put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectTypeOf: obj	^(self makeUnsignedFrom:(self obj: obj at: GEObjectType)) bitAnd: GEPrimitiveTypeMask! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectTypeOf: obj put: value	^self obj: obj at: GEObjectType put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsInvalidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitOr: GEEdgeFillsInvalid)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsValidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitAnd: GEEdgeFillsInvalid bitInvert32)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeLeftFillOf: edge	^self obj: edge at: GEFillIndexLeft! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeLeftFillOf: edge put: value	^self obj: edge at: GEFillIndexLeft put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeNumLinesOf: edge	^self obj: edge at: GENumLines! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeNumLinesOf: edge put: value	^self obj: edge at: GENumLines put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeRightFillOf: edge	^self obj: edge at: GEFillIndexRight! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeRightFillOf: edge put: value	^self obj: edge at: GEFillIndexRight put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeTypeOf: edge	"Return the edge type (e.g., witout the wide edge flag)"	^(self objectTypeOf: edge) >> 1! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeXValueOf: edge	^self obj: edge at: GEXValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeXValueOf: edge put: value	^self obj: edge at: GEXValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeYValueOf: edge	^self obj: edge at: GEYValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeYValueOf: edge put: value	^self obj: edge at: GEYValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeZValueOf: edge	^self obj: edge at: GEZValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeZValueOf: edge put: value	^self obj: edge at: GEZValue put: value! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/31/1998 00:43'!wbStackClear	self wbTopPut: self wbSizeGet.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackPop: nItems	self wbTopPut: self wbTopGet + nItems.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:16'!wbStackPush: nItems	(self allocateStackEntry: nItems) ifFalse:[^false].	self wbTopPut: self wbTopGet - nItems.	^true! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:17'!wbStackSize	^self wbSizeGet - self wbTopGet! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index	^workBuffer at: self wbTopGet + index! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index put: value	^workBuffer at: self wbTopGet + index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/7/1998 22:25'!fillTypeOf: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) >> 8! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index	^self wbStackValue: index+1! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index put: value	^self wbStackValue: index+1 put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:31'!stackFillEntryLength	^3! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:35'!stackFillRightX: index	^self wbStackValue: index+2! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:35'!stackFillRightX: index put: value	^self wbStackValue: index+2 put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:10'!stackFillSize	^self wbStackSize! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index	^self wbStackValue: index! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index put: value	^self wbStackValue: index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:49'!topDepth	self stackFillSize = 0		ifTrue:[^-1]		ifFalse:[^self topFillDepth].! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:28'!topFill	self stackFillSize = 0		ifTrue:[^0]		ifFalse:[^self topFillValue].! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepth	^self stackFillDepth: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepthPut: value	^self stackFillDepth: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:36'!topFillRightX	^self stackFillRightX: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:36'!topFillRightXPut: value	^self stackFillRightX: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValue	^self stackFillValue: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValuePut: value	^self stackFillValue: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 15:19'!topRightX	self stackFillSize = 0		ifTrue:[^999999999]		ifFalse:[^self topFillRightX].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 20:05'!loadArrayTransformFrom: transformOop into: destPtr length: n	"Load a transformation from the given array."	| value |	self inline: false.	self var: #destPtr declareC:'float *destPtr'.	0 to: n-1 do:[:i|		value _ interpreterProxy fetchPointer: i ofObject: transformOop.		((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])			ifFalse:[^interpreterProxy primitiveFail].		(interpreterProxy isIntegerObject: value)			ifTrue:[destPtr at: i put: 				(self cCoerce: (interpreterProxy integerValueOf: value) asFloat to:'float')]			ifFalse:[destPtr at: i put: 				(self cCoerce: (interpreterProxy floatValueOf: value) to: 'float')].	].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 21:04'!loadColorTransformFrom: transformOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	| okay transform |	self var: #transform declareC:'float *transform'.	transform _ self colorTransform.	self hasColorTransformPut: 0.	okay _ self loadTransformFrom: transformOop into: transform length: 8.	okay ifFalse:[^false].	self hasColorTransformPut: 1.	"Scale transform to be in 0-256 range"	transform at: 1 put: (transform at: 1) * (self cCoerce: 256.0 to:'float').	transform at: 3 put: (transform at: 3) * (self cCoerce: 256.0 to:'float').	transform at: 5 put: (transform at: 5) * (self cCoerce: 256.0 to:'float').	transform at: 7 put: (transform at: 7) * (self cCoerce: 256.0 to:'float').	^okay! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/11/1998 22:21'!loadEdgeStateFrom: edgeOop	| edge |	self inline: false.	edge _ self lastExportedEdgeGet.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	self edgeXValueOf: edge 		put: (interpreterProxy fetchInteger: ETXValueIndex ofObject: edgeOop).	self edgeYValueOf: edge 		put: (interpreterProxy fetchInteger: ETYValueIndex ofObject: edgeOop).	self edgeZValueOf: edge 		put: (interpreterProxy fetchInteger: ETZValueIndex ofObject: edgeOop).	self edgeNumLinesOf: edge 		put: (interpreterProxy fetchInteger: ETLinesIndex ofObject: edgeOop).	^edge! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 21:33'!loadEdgeTransformFrom: transformOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	| transform okay |	self inline: false.	self var: #transform declareC:'float *transform'.	self hasEdgeTransformPut: 0.	transform _ self edgeTransform.	okay _ self loadTransformFrom: transformOop into: transform length: 6.	interpreterProxy failed ifTrue:[^nil].	okay ifFalse:[^false].	self hasEdgeTransformPut: 1.	"Add the fill offset to the matrix"	transform at: 2 put: 		(self cCoerce: (transform at: 2) + self destOffsetXGet asFloat to:'float').	transform at: 5 put: 		(self cCoerce: (transform at: 5) + self destOffsetYGet asFloat to:'float').	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 17:26'!loadFormsFrom: arrayOop	"Check all the forms from arrayOop."	| formOop bmBits bmBitsSize bmWidth bmHeight bmDepth ppw bmRaster |	(interpreterProxy fetchClassOf: arrayOop) == interpreterProxy classArray		ifFalse:[^false].	formArray _ arrayOop.	0 to: (interpreterProxy slotSizeOf: formArray) - 1 do:[:i|		formOop _ interpreterProxy fetchPointer: i ofObject: formArray.		(interpreterProxy isIntegerObject: formOop) ifTrue:[^false].		(interpreterProxy isPointers: formOop) ifFalse:[^false].		(interpreterProxy slotSizeOf: formOop) < 5 ifTrue:[^false].		bmBits _ interpreterProxy fetchPointer: 0 ofObject: formOop.		(interpreterProxy fetchClassOf: bmBits) == interpreterProxy classBitmap			ifFalse:[^false].		bmBitsSize _ interpreterProxy slotSizeOf: bmBits.		bmWidth _ interpreterProxy fetchInteger: 1 ofObject: formOop.		bmHeight _ interpreterProxy fetchInteger: 2 ofObject: formOop.		bmDepth _ interpreterProxy fetchInteger: 3 ofObject: formOop.		interpreterProxy failed ifTrue:[^false].		(bmWidth >= 0 and:[bmHeight >= 0]) ifFalse:[^false].		ppw _ 32 // bmDepth.		bmRaster _ bmWidth + (ppw-1) // ppw.		bmBitsSize = (bmRaster * bmHeight)			ifFalse:[^false].	].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/27/1998 21:24'!loadPoint: pointArray from: pointOop	"Load the contents of pointOop into pointArray"	| value |	self inline: false.	self var: #pointArray declareC:'int *pointArray'.	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint 		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchPointer: 0 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 0 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 0 put: (interpreterProxy floatValueOf: value) asInteger].	value _ interpreterProxy fetchPointer: 1 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 1 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 1 put: (interpreterProxy floatValueOf: value) asInteger].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 00:46'!loadSpanBufferFrom: spanOop	"Load the span buffer from the given oop."	self inline: false.	(interpreterProxy fetchClassOf: spanOop) = (interpreterProxy classBitmap) ifFalse:[^false].	spanBuffer _ interpreterProxy firstIndexableField: spanOop.	"Leave last entry unused to avoid complications"	self spanSizePut: (interpreterProxy slotSizeOf: spanOop) - 1.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 23:22'!loadTransformFrom: transformOop into: destPtr length: n	"Load a transformation from transformOop into the float array	defined by destPtr. The transformation is assumed to be either	an array or a FloatArray of length n."	self inline: false.	self var: #destPtr declareC:'float *destPtr'.	transformOop = interpreterProxy nilObject ifTrue:[^false].	(interpreterProxy isIntegerObject: transformOop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: transformOop) = n 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: transformOop) 		ifTrue:[self loadWordTransformFrom: transformOop into: destPtr length: n]		ifFalse:[self loadArrayTransformFrom: transformOop into: destPtr length: n].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 20:03'!loadWordTransformFrom: transformOop into: destPtr length: n	"Load a float array transformation from the given oop"	| srcPtr |	self inline: false.	self var: #srcPtr declareC:'float *srcPtr'.	self var: #destPtr declareC:'float *destPtr'.	srcPtr _ self cCoerce: (interpreterProxy firstIndexableField: transformOop) to: 'float *'.	0 to: n-1 do:[:i| destPtr at: i put: (srcPtr at: i)].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 19:37'!loadWorkBufferFrom: wbOop	"Load the working buffer from the given oop"	self inline: false.	(interpreterProxy isIntegerObject: wbOop) ifTrue:[^false].	(interpreterProxy isWords: wbOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: wbOop) < GWMinimalSize ifTrue:[^false].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	self magicNumberGet = GWMagicNumber ifFalse:[^false].	"Sanity checks"	(self wbSizeGet = (interpreterProxy slotSizeOf: wbOop)) ifFalse:[^false].	self objStartGet = GWHeaderSize ifFalse:[^false].	"Load buffers"	objBuffer _ workBuffer + self objStartGet.	getBuffer _ objBuffer + self objUsedGet.	aetBuffer _ getBuffer + self getUsedGet.	"Make sure we don't exceed the work buffer"	GWHeaderSize + self objUsedGet + self getUsedGet + self aetUsedGet > self wbSizeGet ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 00:36'!quickLoadEngineFrom: engineOop	"Load the minimal required state from the engineOop, e.g., just the work buffer."	self inline: false.	interpreterProxy failed ifTrue:[^false].	(interpreterProxy isIntegerObject: engineOop) ifTrue:[^false].	(interpreterProxy isPointers: engineOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: engineOop) < BEBalloonEngineSize ifTrue:[^false].	engine _ engineOop.	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engineOop))			ifFalse:[^false].	self stopReasonPut: 0.	objUsed _ self objUsedGet.	engineStopped _ false.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 21:06'!quickLoadEngineFrom: oop requiredState: requiredState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/31/1998 17:23'!quickLoadEngineFrom: oop requiredState: requiredState or: alternativeState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stateGet = alternativeState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:21'!storeEdgeStateFrom: edge into: edgeOop	self inline: false.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: ETIndexIndex ofObject: edgeOop withValue: 		(self objectIndexOf: edge).	interpreterProxy storeInteger: ETXValueIndex ofObject: edgeOop withValue: 		(self edgeXValueOf: edge).	interpreterProxy storeInteger: ETYValueIndex ofObject: edgeOop withValue: 		(self currentYGet).	interpreterProxy storeInteger: ETZValueIndex ofObject: edgeOop withValue: 		(self edgeZValueOf: edge).	interpreterProxy storeInteger: ETLinesIndex ofObject: edgeOop withValue: 		(self edgeNumLinesOf: edge).	self lastExportedEdgePut: edge.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/25/1998 00:36'!storeEngineStateInto: oop	self objUsedPut: objUsed.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:24'!storeFillStateInto: fillOop	| fillIndex leftX rightX |	self inline: false.	fillIndex _ self lastExportedFillGet.	leftX _ self lastExportedLeftXGet.	rightX _ self lastExportedRightXGet.	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: FTIndexIndex ofObject: fillOop withValue: 		(self objectIndexOf: fillIndex).	interpreterProxy storeInteger: FTMinXIndex ofObject: fillOop withValue: leftX.	interpreterProxy storeInteger: FTMaxXIndex ofObject: fillOop withValue: rightX.	interpreterProxy storeInteger: FTYValueIndex ofObject: fillOop withValue: self currentYGet.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/9/1998 15:34'!storeStopStateIntoEdge: edgeOop fill: fillOop	| reason edge |	reason _ self stopReasonGet.	reason = GErrorGETEntry ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1.	].	reason = GErrorFillEntry ifTrue:[		self storeFillStateInto: fillOop.	].	reason = GErrorAETEntry ifTrue:[		edge _ aetBuffer at: self aetStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		"Do not advance to the next aet entry yet"		"self aetStartPut: self aetStartGet + 1."	].! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:34'!areEdgeFillsValid: edge	^((self objectHeaderOf: edge) bitAnd: GEEdgeFillsInvalid) = 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 17:06'!finishedProcessing	"Return true if processing is finished"	^self stateGet = GEStateCompleted! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/24/1998 19:39'!hasColorTransform	^self hasColorTransformGet ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/24/1998 19:38'!hasEdgeTransform	^self hasEdgeTransformGet ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:36'!isEdge: edge	| type |	type _ self objectTypeOf: edge.	type > GEPrimitiveEdgeMask ifTrue:[^false].	^((self objectTypeOf: edge) bitAnd: GEPrimitiveEdgeMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isFill: fill	^(self isFillColor: fill) or:[self isRealFill: fill]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:31'!isFillColor: fill	^((self makeUnsignedFrom: fill) bitAnd: 16rFF000000) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/25/1998 00:43'!isObject: obj	^obj >= 0 and:[obj < objUsed]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isRealFill: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 23:12'!isStackEntry: entry	^entry >= self wbTopGet and:[entry < self wbSizeGet]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/30/1998 17:38'!isStackIndex: index	^index >= 0 and:[index < self wbStackSize]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:36'!isWide: object	^((self objectTypeOf: object) bitAnd: GEPrimitiveWide) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/25/1998 00:21'!needsFlush	^self needsFlushGet ~= 0! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveGetAALevel	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self aaLevelGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/14/1998 02:40'!gePrimitiveGetClipRect	| rectOop pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMinXGet yValue: self clipMinYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: pointOop.	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMaxXGet yValue: self clipMaxYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: pointOop.	interpreterProxy pop: 2.	interpreterProxy push: rectOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetCounts	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWCountInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWCountFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWCountNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWCountAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWCountNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWCountMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWCountDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWCountNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWCountChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:55'!gePrimitiveGetDepth	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self currentZGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 22:05'!gePrimitiveGetFailureReason	"Return the reason why the last operation failed."	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	"Note -- don't call loadEngineFrom here because this will override the stopReason with Zero"	(interpreterProxy isIntegerObject: engine) ifTrue:[^false].	(interpreterProxy isPointers: engine) ifFalse:[^false].	(interpreterProxy slotSizeOf: engine) < BEBalloonEngineSize ifTrue:[^false].	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy makePointwithxValue: self destOffsetXGet yValue: self destOffsetYGet.	interpreterProxy pop: 1.	interpreterProxy push: pointOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetTimes	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWTimeInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWTimeFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWTimeNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWTimeAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWTimeNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWTimeMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWTimeDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWTimeNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWTimeChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/25/1998 22:30'!gePrimitiveNeedsFlush	| needFlush |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	needFlush _ self needsFlush.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: needFlush.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 1/15/1999 02:48'!gePrimitiveNeedsFlushPut	| needFlush |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	needFlush _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	needFlush _ interpreterProxy booleanValueOf: needFlush.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	needFlush == true 		ifTrue:[self needsFlushPut: 1]		ifFalse:[self needsFlushPut: 0].	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveSetAALevel	| level |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	level _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self setAALevel: level.	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leace rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetClipRect	| rectOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: rectOop).	self loadPoint: self point2Get from: (interpreterProxy fetchPointer: 1 ofObject: rectOop).	interpreterProxy failed ifFalse:[		self clipMinXPut: (self point1Get at: 0).		self clipMinYPut: (self point1Get at: 1).		self clipMaxXPut: (self point2Get at: 0).		self clipMaxYPut: (self point2Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 19:59'!gePrimitiveSetColorTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadColorTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 20:32'!gePrimitiveSetDepth	| depth |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	depth _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self currentZPut: depth.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:39'!gePrimitiveSetEdgeTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadEdgeTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: pointOop.	interpreterProxy failed ifFalse:[		self destOffsetXPut: (self point1Get at: 0).		self destOffsetYPut: (self point1Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:38'!gePrimitiveAddActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForEdge)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self needAvailableSpace: 1) 		ifFalse:[^interpreterProxy primitiveFail].	(self edgeNumLinesOf: edge) > 0 ifTrue:[		self insertEdgeIntoAET: edge.	].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Back to adding edges from GET"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountAddAETEntry by: 1.		self incrementStat: GWTimeAddAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:39'!gePrimitiveChangedActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingChange)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self edgeNumLinesOf: edge) = 0 		ifTrue:[	self removeFirstAETEntry]		ifFalse:[	self resortFirstAETEntry.				self aetStartPut: self aetStartGet + 1].	self statePut: GEStateUpdateEdges. "Back to updating edges"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountChangeAETEntry by: 1.		self incrementStat: GWTimeChangeAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:39'!gePrimitiveDisplaySpanBuffer	"Note: Must load bitBlt and spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateBlitBuffer)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[		self displaySpanBufferAt: self currentYGet.		self postDisplayAction.	].	self finishedProcessing ifFalse:[		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		self statePut: GEStateUpdateEdges].	self storeEngineStateInto: engine.	doProfileStats ifTrue:[		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:40'!gePrimitiveInitializeProcessing	"Note: No need to load bitBlt but must load spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked) 		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for clear operation"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	self initializeGETProcessing.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Initialized"	interpreterProxy failed ifFalse:[self storeEngineStateInto: engine].	doProfileStats ifTrue:[		self incrementStat: GWCountInitializing by: 1.		self incrementStat: GWTimeInitializing by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:40'!gePrimitiveMergeFillFrom	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop bitsOop value |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	bitsOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForFill)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for merging the fill"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check bitmap"	(interpreterProxy fetchClassOf: bitsOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	"Check fillOop"	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize		ifTrue:[^interpreterProxy primitiveFail].	"Check if this was the fill we have exported"	value _ interpreterProxy fetchInteger: FTIndexIndex ofObject: fillOop.	(self objectIndexOf: self lastExportedFillGet) = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMinXIndex ofObject: fillOop.	self lastExportedLeftXGet = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMaxXIndex ofObject: fillOop.	self lastExportedRightXGet = value		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bitsOop) < (self lastExportedRightXGet - self lastExportedLeftXGet)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self fillBitmapSpan: (interpreterProxy firstIndexableField: bitsOop)		from: self lastExportedLeftXGet		to: self lastExportedRightXGet.	self statePut: GEStateScanningAET. "Back to scanning AET"	self storeEngineStateInto: engine.	interpreterProxy pop: 2. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountMergeFill by: 1.		self incrementStat: GWTimeMergeFill by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUpdateEdges or: GEStateCompleted)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ false.	self stateGet = GEStateCompleted ifFalse:[		hasEdge _ self findNextExternalUpdateFromAET.		hasEdge ifTrue:[			edge _ aetBuffer at: self aetStartGet.			self storeEdgeStateFrom: edge into: edgeOop.			"Do not advance to the next aet entry yet"			"self aetStartPut: self aetStartGet + 1."			self statePut: GEStateWaitingChange. "Wait for changed edge"		] ifFalse:[self statePut: GEStateAddingFromGET]. "Start over"	].	interpreterProxy failed ifTrue:[^nil].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextGlobalEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateAddingFromGET)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ self findNextExternalEntryFromGET.	hasEdge ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1].	interpreterProxy failed ifTrue:[^nil].	hasEdge		ifTrue:[	self statePut: GEStateWaitingForEdge] "Wait for adding edges"		ifFalse:[ "Start scanning the AET"				self statePut: GEStateScanningAET.				self clearSpanBufferPut: 1. "Clear span buffer at next entry"				self aetStartPut: 0.				self wbStackClear].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderImage	"Start/Proceed rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish this scan line"	engineStopped ifTrue:[^self storeRenderingState].	self proceedRenderingImage. "And go on as usual"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderScanline	"Start rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish the current scan line"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/25/1998 16:56'!loadRenderingState	"Load the entire state from the interpreter for the rendering primitives"	| edgeOop fillOop state |	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	edgeOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^false].	(self quickLoadEngineFrom: engine)		ifFalse:[^false].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^false].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^false].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^false].	"Check edgeOop and fillOop"	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^false].	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^false].	"Note: Rendering can only take place if we're not in one of the intermediate	(e.g., external) states."	state _ self stateGet.	(state = GEStateWaitingForEdge or:[		state = GEStateWaitingForFill or:[			state = GEStateWaitingChange]]) ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 1/12/1999 10:43'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		self wbStackClear.		self spanEndAAPut: 0.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 1/12/1999 10:45'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:54'!storeRenderingState	self inline: false.	interpreterProxy failed ifTrue:[^nil].	engineStopped ifTrue:[		"Check the stop reason and store the required information"		self storeStopStateIntoEdge: (interpreterProxy stackObjectValue: 1) 			fill: (interpreterProxy stackObjectValue: 0).	].	self storeEngineStateInto: engine.	interpreterProxy pop: 3.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/31/1998 17:23'!gePrimitiveAbortProcessing	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	self statePut: GEStateCompleted.	self storeEngineStateInto: engine.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/29/1998 16:24'!gePrimitiveCopyBuffer	| buf1 buf2 diff src dst |	self export: true.	self inline: false.	self var: #src declareC:'int * src'.	self var: #dst declareC:'int * dst'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	buf2 _ interpreterProxy stackObjectValue: 0.	buf1 _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	"Make sure the old buffer is properly initialized"	(self loadWorkBufferFrom: buf1) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the buffers are of the same type"	(interpreterProxy fetchClassOf: buf1) = (interpreterProxy fetchClassOf: buf2)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure buf2 is at least of the size of buf1"	diff _ (interpreterProxy slotSizeOf: buf2) - (interpreterProxy slotSizeOf: buf1).	diff < 0 ifTrue:[^interpreterProxy primitiveFail].	"Okay - ready for copying. First of all just copy the contents up to wbTop"	src _ workBuffer.	dst _ interpreterProxy firstIndexableField: buf2.	0 to: self wbTopGet-1 do:[:i|		dst at: i put: (src at: i).	].	"Adjust wbSize and wbTop in the new buffer"	dst at: GWBufferTop put: self wbTopGet + diff.	dst at: GWSize put: self wbSizeGet + diff.	"Now copy the entries from wbTop to wbSize"	src _ src + self wbTopGet.	dst _ dst + self wbTopGet + diff.	0 to: (self wbSizeGet - self wbTopGet - 1) do:[:i|		dst at: i put: (src at: i).	].	"Okay, done. Check the new buffer by loading the state from it"	(self loadWorkBufferFrom: buf2) 		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 1/12/1999 11:16'!gePrimitiveDoProfileStats	"Turn on/off profiling. Return the old value of the flag."	| oldValue newValue |	self inline: false.	self export: true.	oldValue _ doProfileStats.	newValue _ interpreterProxy stackObjectValue: 0.	newValue _ interpreterProxy booleanValueOf: newValue.	interpreterProxy failed ifFalse:[		doProfileStats _ newValue.		interpreterProxy pop: 2. "Pop rcvr, arg"		interpreterProxy pushBool: oldValue.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 1/12/1999 10:39'!gePrimitiveFinishedProcessing	| finished |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	finished _ self finishedProcessing.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: finished.	doProfileStats ifTrue:[		self incrementStat: GWCountFinishTest by: 1.		self incrementStat: GWTimeFinishTest by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:21'!gePrimitiveInitializeBuffer	| wbOop size |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	wbOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: wbOop) 		ifFalse:[^interpreterProxy primitiveFail].	(size _ interpreterProxy slotSizeOf: wbOop) < GWMinimalSize		ifTrue:[^interpreterProxy primitiveFail].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	objBuffer _ workBuffer + GWHeaderSize.	self magicNumberPut: GWMagicNumber.	self wbSizePut: size.	self wbTopPut: size.	self statePut: GEStateUnlocked.	self objStartPut: GWHeaderSize.	self objUsedPut: 4.	"Dummy fill object"	self objectTypeOf: 0 put: GEPrimitiveFill.	self objectLengthOf: 0 put: 4.	self objectIndexOf: 0 put: 0.	self getStartPut: 0.	self getUsedPut: 0.	self aetStartPut: 0.	self aetUsedPut: 0.	self stopReasonPut: 0.	self needsFlushPut: 0.	self clipMinXPut: 0.	self clipMaxXPut: 0.	self clipMinYPut: 0.	self clipMaxYPut: 0.	self currentZPut: 0.	self resetGraphicsEngineStats.	self initEdgeTransform.	self initColorTransform.	interpreterProxy pop: 2.	interpreterProxy push: wbOop.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:42'!gePrimitiveRegisterExternalEdge	| rightFillIndex leftFillIndex initialZ initialY initialX index  edge |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	initialZ _ interpreterProxy stackIntegerValue: 2.	initialY _ interpreterProxy stackIntegerValue: 3.	initialX _ interpreterProxy stackIntegerValue: 4.	index _ interpreterProxy stackIntegerValue: 5.	engine _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(self allocateObjEntry: GEBaseEdgeSize) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	(self isFillOkay: leftFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	(self isFillOkay: rightFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	edge _ objUsed.	objUsed _ edge + GEBaseEdgeSize.	"Install type and length"	self objectTypeOf: edge put: GEPrimitiveEdge.	self objectLengthOf: edge put: GEBaseEdgeSize.	self objectIndexOf: edge put: index.	"Install remaining stuff"	self edgeXValueOf: edge put: initialX.	self edgeYValueOf: edge put: initialY.	self edgeZValueOf: edge put: initialZ.	self edgeLeftFillOf: edge put: (self transformColor: leftFillIndex).	self edgeRightFillOf: edge put: (self transformColor: rightFillIndex).	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:37'!gePrimitiveRegisterExternalFill	| index  fill |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1 		ifFalse:[^interpreterProxy primitiveFail].	index _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Note: We *must* not allocate any fill with index 0"	fill _ 0.	[fill = 0] whileTrue:[		(self allocateObjEntry: GEBaseEdgeSize) 			ifFalse:[^interpreterProxy primitiveFail].		fill _ objUsed.		objUsed _ fill + GEBaseFillSize.		"Install type and length"		self objectTypeOf: fill put: GEPrimitiveFill.		self objectLengthOf: fill put: GEBaseFillSize.		self objectIndexOf: fill put: index.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushInteger: fill.	].! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateAETEntry: nSlots	"Allocate n slots in the active edge table"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:06'!allocateGETEntry: nSlots	"Allocate n slots in the global edge table"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the AET"	(self allocateAETEntry: nSlots) ifFalse:[^false].	self aetUsedGet = 0 ifFalse:["Then move the AET upwards"		srcIndex _ self aetUsedGet.		dstIndex _ self aetUsedGet + nSlots.		1 to: self aetUsedGet do:[:i|			aetBuffer at: (dstIndex _ dstIndex - 1) put: (aetBuffer at: (srcIndex _ srcIndex - 1))].	].	aetBuffer _ aetBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:16'!allocateObjEntry: nSlots	"Allocate n slots in the object buffer"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the GET"	(self allocateGETEntry: nSlots) ifFalse:[^false].	self getUsedGet = 0 ifFalse:["Then move the GET upwards"		srcIndex _ self getUsedGet.		dstIndex _ self getUsedGet + nSlots.		1 to: self getUsedGet do:[:i|			getBuffer at: (dstIndex _ dstIndex - 1) put: (getBuffer at: (srcIndex _ srcIndex - 1))].	].	getBuffer _ getBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateStackEntry: nSlots	"AET and Stack allocation are symmetric"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!allocateStackFillEntry	^self wbStackPush: self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!freeStackFillEntry	self wbStackPop: self stackFillEntryLength.! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 11/25/1998 02:19'!needAvailableSpace: nSlots	"Check if we have n slots available"	GWHeaderSize + objUsed + self getUsedGet + self aetUsedGet + nSlots > self wbTopGet ifTrue:[		self stopBecauseOf: GErrorNoMoreSpace.		^false	].	^true! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/1/1998 01:07'!addEdgeToGET: edge	self inline: false.	(self allocateGETEntry: 1) ifFalse:[^0].	"Install edge in the GET"	getBuffer at: self getUsedGet put: edge.	self getUsedPut: self getUsedGet + 1.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/25/1998 00:41'!createGlobalEdgeTable	"Create the global edge table"	| object end |	self inline: false.	object _ 0.	end _ objUsed.	[object < end] whileTrue:[		"Note: addEdgeToGET: may fail on insufficient space but that's not a problem here"		(self isEdge: object) ifTrue:[			"Check if the edge starts below fillMaxY."			(self edgeYValueOf: object) >= self fillMaxYGet ifFalse:[				self checkedAddEdgeToGET: object.			].		].		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalEntryFromGET	"Check the global edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, initialize the the edge and add it to the AET"	| yValue edge type |	yValue _ self currentYGet.	"As long as we have entries in the GET"	[self getStartGet < self getUsedGet] whileTrue:[		edge _ getBuffer at: self getStartGet.		(self edgeYValueOf: edge) > yValue ifTrue:[^false]. "No more edges to add"		type _ self objectTypeOf: edge.		(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 			ifTrue:[^true]. "This is an external edge"		"Note: We must make sure not to do anything with the edge if there is not		enough room in the AET"		(self needAvailableSpace: 1) ifFalse:[^false]. "No more room"		"Process the edge in the engine itself"		self dispatchOn: type in: EdgeInitTable.		"Insert the edge into the AET"		self insertEdgeIntoAET: edge.		self getStartPut: self getStartGet + 1.	].	"No entries in GET"	^false! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/28/1998 21:07'!getSorts: edge1 before: edge2	"Return true if the edge at index i should sort before the edge at index j."	| diff |	self inline: false.	edge1 = edge2 ifTrue:[^true].	"First, sort by Y"	diff _ (self edgeYValueOf: edge1) - (self edgeYValueOf: edge2).	diff = 0 ifFalse:[^diff < 0].	"Then, by X"	diff _ (self edgeXValueOf: edge1) - (self edgeXValueOf: edge2).	^diff < 0! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/25/1998 00:41'!initializeGETProcessing	"Initialization stuff that needs to be done before any processing can take place."	self inline: false.	"Make sure aaLevel is initialized"	self setAALevel: self aaLevelGet.	self clipMinXGet < 0 ifTrue:[self clipMinXPut: 0].	self clipMaxXGet > self spanSizeGet ifTrue:[self clipMaxXPut: self spanSizeGet].	"Convert clipRect to aaLevel"	self fillMinXPut: self clipMinXGet << self aaShiftGet.	self fillMinYPut: self clipMinYGet << self aaShiftGet.	self fillMaxXPut: self clipMaxXGet << self aaShiftGet.	self fillMaxYPut: self clipMaxYGet << self aaShiftGet.	"Reset GET and AET"	self getUsedPut: 0.	self aetUsedPut: 0.	getBuffer _ aetBuffer _ objBuffer + objUsed.	"Create the global edge table"	self createGlobalEdgeTable.	engineStopped ifTrue:[^nil].	self getUsedGet = 0 ifTrue:[		"Nothing to do"		self currentYPut: self fillMaxYGet.		^0].	"Sort entries in the GET"	self sortGlobalEdgeTable.	"Find the first y value to be processed"	self currentYPut: (self edgeYValueOf: (getBuffer at: 0)).	self currentYGet < self fillMinYGet ifTrue:[self currentYPut: self fillMinYGet].	"Load and clear the span buffer"	self spanStartPut: 0.	self spanEndPut: (self spanSizeGet << self aaShiftGet) - 1.	self clearSpanBuffer. "@@: Is this really necessary?!!"! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 17:55'!quickSortGlobalEdgeTable: array from: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	"Note: The original loop has been heavily re-written for C translation"	| di dij dj tt ij k l n tmp again before |	self var: #array declareC:'int *array'.	self inline: false.	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^0].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	before _ self getSorts: di before: dj. "i.e., should di precede dj?"	before ifFalse:[		tmp _ array at: i.		array at: i put: (array at: j).		array at: j put: tmp.		tt _ di.	di _ dj.	dj _ tt].	n <= 2 ifTrue:[^0].	"More than two elements."	ij _ (i + j) // 2.  "ij is the midpoint of i and j."	dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."	before _ (self getSorts: di before: dij). "i.e. should di precede dij?"	before ifTrue:[		before _ (self getSorts: dij before: dj). "i.e., should dij precede dj?"		before ifFalse:["i.e., should dij precede dj?"			tmp _ array at: j.			array at: j put: (array at: ij).			array at: ij put: tmp.			dij _ dj]	] ifFalse:[  "i.e. di should come after dij"		tmp _ array at: i.		array at: i put: (array at: ij).		array at: ij put: tmp.		 dij _ di].	n <= 3 ifTrue:[^0].	 "More than three elements."	"Find k>i and l<j such that dk,dij,dl are in reverse order.	Swap k and l.  Repeat this procedure until k and l pass each other."	k _ i.	l _ j.	again _ true.	[again] whileTrue:[		before _ true.		[before] whileTrue:[			k <= (l _ l - 1)				ifTrue:[	tmp _ array at: l.						before _ self getSorts: dij before: tmp]				ifFalse:[before _ false].		].		before _ true.		[before] whileTrue:[			(k _ k + 1) <= l				ifTrue:[	tmp _ array at: k.						before _ self getSorts: tmp before: dij]				ifFalse:[before _ false]].		again _ k <= l.		again ifTrue:[			tmp _ array at: k.			array at: k put: (array at: l).			array at: l put: tmp]].	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."	self quickSortGlobalEdgeTable: array from: i to: l.	self quickSortGlobalEdgeTable: array from: k to: j.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 23:34'!sortGlobalEdgeTable	"Sort the entire global edge table"	self quickSortGlobalEdgeTable: getBuffer from: 0 to: self getUsedGet-1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/24/1998 22:47'!findNextAETEdgeFrom: leftEdge	| depth rightEdge |	depth _ self edgeZValueOf: leftEdge.	[self aetStartGet < self aetUsedGet] whileTrue:[		rightEdge _ aetBuffer at: self aetStartGet.		(self edgeZValueOf: rightEdge) >= depth ifTrue:[^rightEdge].		self aetStartPut: self aetStartGet + 1.	].	^nil! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/25/1998 23:21'!findNextExternalFillFromAET	"Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false."	| leftEdge rightEdge leftX rightX |"self currentYGet >= 680 ifTrue:[self printAET.self halt.]."	self inline: false.	leftX _ rightX _ self fillMaxXGet.	[self aetStartGet < self aetUsedGet] whileTrue:[		leftEdge _ rightEdge _ aetBuffer at: self aetStartGet.		"TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill."		leftX _ rightX _ self edgeXValueOf: leftEdge.		leftX >= self fillMaxXGet ifTrue:[^false]. "Nothing more visible"		self quickRemoveInvalidFillsAt: leftX.		"Check if we need to draw the edge"		(self isWide: leftEdge) ifTrue:[			self toggleWideFillOf: leftEdge.			"leftX _ rightX _ self drawWideEdge: leftEdge from: leftX."		].		(self areEdgeFillsValid: leftEdge) ifTrue:[			self toggleFillsOf: leftEdge. "Adjust the fills"			engineStopped ifTrue:[^false].		].		self aetStartPut: self aetStartGet + 1.		self aetStartGet < self aetUsedGet ifTrue:[			rightEdge _ aetBuffer at: self aetStartGet.			rightX _ self edgeXValueOf: rightEdge.			rightX >= self fillMinXGet ifTrue:["This is the visible portion"				self fillAllFrom: leftX to: rightX.				"Fetch the currently active fill"				"fill _ self makeUnsignedFrom: self topFill.				fill = 0 ifFalse:[self fillSpan: fill from: leftX to: rightX max: self topRightX]"			].		].	].	"Note: Due to pre-clipping we may have to draw remaining stuff with the last fill"	rightX < self fillMaxXGet ifTrue:[		self fillAllFrom: rightX to: self fillMaxXGet.		"fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[self fillSpan: fill from: rightX to: self fillMaxXGet max: self topRightX]."	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalUpdateFromAET	"Check the active edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, step the the edge to the next y value."	| edge count type |	self inline: false.	[self aetStartGet < self aetUsedGet] whileTrue:[		edge _ aetBuffer at: self aetStartGet.		count _ (self edgeNumLinesOf: edge) - 1.		count = 0 ifTrue:[			"Edge at end -- remove it"			self removeFirstAETEntry		] ifFalse:[			"Store remaining lines back"			self edgeNumLinesOf: edge put: count.			type _ self objectTypeOf: edge.			(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 				ifTrue:[^true]. "This is an external edge"			self dispatchOn: type in: EdgeStepTable.			self resortFirstAETEntry.			self aetStartPut: self aetStartGet+1.		].	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!indexForInsertingIntoAET: edge	"Find insertion point for the given edge in the AET"	| initialX index |	self inline: false.	initialX _ self edgeXValueOf: edge.	index _ 0.	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) < initialX]]			whileTrue:[index _ index + 1].	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) = initialX and:[			(self getSorts: (aetBuffer at: index) before: edge)]]]				whileTrue:[index _ index + 1].	^index! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 19:52'!insertEdgeIntoAET: edge	"Insert the edge with the given index from the global edge table into the active edge table.	The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX	are both set."	| index |	self inline: false.	"Check for the number of lines remaining"	(self edgeNumLinesOf: edge) <= 0 ifTrue:[^nil]. "Nothing to do"	"Find insertion point"	index _ self indexForInsertingIntoAET: edge.	"And insert edge"	self insertToAET: edge beforeIndex: index.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!insertToAET: edge beforeIndex: index	"Insert the given edge into the AET."	| i |	self inline: false.	"Make sure we have space in the AET"	(self allocateAETEntry: 1) ifFalse:[^nil]. "Insufficient space in AET"	i _ self aetUsedGet-1.	[i < index] whileFalse:[		aetBuffer at: i+1 put: (aetBuffer at: i).		i _ i - 1.	].	aetBuffer at: index put: edge.	self aetUsedPut: self aetUsedGet + 1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 01:39'!moveAETEntryFrom: index edge: edge x: xValue	"The entry at index is not in the right position of the AET. 	Move it to the left until the position is okay."	| newIndex |	self inline: false.	newIndex _ index.	[newIndex > 0 and:[(self edgeXValueOf: (aetBuffer at: newIndex-1)) > xValue]]		whileTrue:[	aetBuffer at: newIndex put: (aetBuffer at: newIndex-1).					newIndex _ newIndex - 1].	aetBuffer at: newIndex put: edge.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!removeFirstAETEntry	| index |	self inline: false.	index _ self aetStartGet.	self aetUsedPut: self aetUsedGet - 1.	[index < self aetUsedGet] whileTrue:[		aetBuffer at: index put: (aetBuffer at: index + 1).		index _ index + 1.	].! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!resortFirstAETEntry	| edge xValue leftEdge |	self inline: false.	self aetStartGet = 0 ifTrue:[^nil]. "Nothing to resort"	edge _ aetBuffer at: self aetStartGet.	xValue _ self edgeXValueOf: edge.	leftEdge _ aetBuffer at: (self aetStartGet - 1).	(self edgeXValueOf: leftEdge) <= xValue ifTrue:[^nil]. "Okay"	self moveAETEntryFrom: self aetStartGet edge: edge x: xValue.! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/24/1998 22:42'!fillSorts: fillEntry1 before: fillEntry2	"Return true if fillEntry1 should be drawn before fillEntry2"	| diff |	self inline: false.	"First check the depth value"	diff _ (self stackFillDepth: fillEntry1) - (self stackFillDepth: fillEntry2).	diff = 0 ifFalse:[^diff > 0].	"See the class comment for aetScanningProblems"	^(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry1)) to:'unsigned') <		(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry2)) to: 'unsigned')! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:47'!findStackFill: fillIndex depth: depth	| index |	index _ 0.	[index < self stackFillSize and:[		(self stackFillValue: index) ~= fillIndex or:[			(self stackFillDepth: index) ~= depth]]]				whileTrue:[index _ index + self stackFillEntryLength].	index >= self stackFillSize 		ifTrue:[^-1]		ifFalse:[^index].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:48'!hideFill: fillIndex depth: depth	"Make the fill style with the given index invisible"	| index newTopIndex newTop newDepth newRightX |	self inline: false.	index _ self findStackFill: fillIndex depth: depth.	index = -1 ifTrue:[^false].	index = 0 ifTrue:[		self freeStackFillEntry.		^true].	"Fill is visible - replace it with the last entry on the stack"	self stackFillValue: index put: (self stackFillValue: 0).	self stackFillDepth: index put: (self stackFillDepth: 0).	self stackFillRightX: index put: (self stackFillRightX: 0).	self freeStackFillEntry.	(self stackFillSize <= self stackFillEntryLength) ifTrue:[^true]. "Done"	"Find the new top fill"	newTopIndex _ 0.	index _ self stackFillEntryLength.	[index < self stackFillSize] whileTrue:[		(self fillSorts: index before: newTopIndex)			ifTrue:[newTopIndex _ index].		index _ index + self stackFillEntryLength.	].	(newTopIndex + self stackFillEntryLength = self stackFillSize) 		ifTrue:[^true]. "Top fill not changed"	newTop _ self stackFillValue: newTopIndex.	self stackFillValue: newTopIndex put: self topFillValue.	self topFillValuePut: newTop.	newDepth _ self stackFillDepth: newTopIndex.	self stackFillDepth: newTopIndex put: self topFillDepth.	self topFillDepthPut: newDepth.	newRightX _ self stackFillRightX: newTopIndex.	self stackFillRightX: newTopIndex put: self topFillRightX.	self topFillRightXPut: newRightX.	^true! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:16'!quickRemoveInvalidFillsAt: leftX	"Remove any top fills if they have become invalid."	self stackFillSize = 0 ifTrue:[^nil].	[self topRightX <= leftX] whileTrue:[		self hideFill: self topFill depth: self topDepth.		self stackFillSize = 0 ifTrue:[^nil].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 14:38'!showFill: fillIndex depth: depth rightX: rightX	self inline: false.	(self allocateStackFillEntry) ifFalse:[^nil]. "Insufficient space"	self stackFillValue: 0 put: fillIndex.	self stackFillDepth: 0 put: depth.	self stackFillRightX: 0 put: rightX.	self stackFillSize = self stackFillEntryLength ifTrue:[^nil]. "No need to update"	(self fillSorts: 0 before: self stackFillSize - self stackFillEntryLength) ifTrue:[		"New top fill"		self stackFillValue: 0 put: self topFillValue.		self stackFillDepth: 0 put: self topFillDepth.		self stackFillRightX: 0 put: self topFillRightX.		self topFillValuePut: fillIndex.		self topFillDepthPut: depth.		self topFillRightXPut: rightX.	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 14:38'!toggleFill: fillIndex depth: depth rightX: rightX	"Make the fill style with the given index either visible or invisible"	| hidden |	self inline: false.	self stackFillSize = 0 ifTrue:[		(self allocateStackFillEntry) ifTrue:[			self topFillValuePut: fillIndex.			self topFillDepthPut: depth.			self topFillRightXPut: rightX.		].	] ifFalse:[		hidden _ self hideFill: fillIndex depth: depth.		hidden ifFalse:[self showFill: fillIndex depth: depth rightX: rightX].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:19'!toggleFillsOf: edge	| depth fillIndex |	self inline: false.	(self needAvailableSpace: self stackFillEntryLength * 2) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ (self edgeZValueOf: edge) << 1.	fillIndex _ self edgeLeftFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth rightX: 999999999].	fillIndex _ self edgeRightFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth rightX: 999999999].	self quickRemoveInvalidFillsAt: (self edgeXValueOf: edge).! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:50'!toggleWideFillOf: edge	| fill type lineWidth depth rightX index |	self inline: false.	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ dispatchReturnValue.	fill = 0 ifTrue:[^nil].	(self needAvailableSpace: self stackFillEntryLength) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ (self edgeZValueOf: edge) << 1 + 1. "So lines sort before interior fills"	rightX _ (self edgeXValueOf: edge) + lineWidth.	index _ self findStackFill: fill depth: depth.	index = -1 ifTrue:[		self showFill: fill 			depth: depth			rightX: rightX.	] ifFalse:[		(self stackFillRightX: index) < rightX			ifTrue:[self stackFillRightX: index put: rightX].	].	self quickRemoveInvalidFillsAt: (self edgeXValueOf: edge).! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaFirstPixelFrom: leftX to: rightX	"Common function to compute the first full pixel for AA drawing"	| firstPixel |	self inline: true.	firstPixel _ (leftX + self aaLevelGet - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.	firstPixel > rightX 		ifTrue:[^rightX]		ifFalse:[^firstPixel]! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaLastPixelFrom: leftX to: rightX	"Common function to compute the last full pixel for AA drawing"	self inline: true.	^(rightX - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:50'!adjustAALevel		"NOTE: 	This method is (hopefully) obsolete due to unrolling 				the fill loops to deal with full pixels."	"Adjust the span buffers values by the appropriate color offset for anti-aliasing.	We do this by replicating the top bits of each color in the lower bits. The idea is that we can scale each color value uniquely from 0 to 255 and thus fill the entire range of colors."	| adjustShift adjustMask x0 x1 pixelValue |	self inline: false.	adjustShift _ 8 - self aaColorShiftGet.	adjustMask _ self aaColorMaskGet bitInvert32.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet.	[x0 < x1] whileTrue:[		pixelValue _ spanBuffer at: x0.		spanBuffer at: x0 put: (pixelValue bitOr: (pixelValue >> adjustShift bitAnd: adjustMask)).		x0 _ x0 + 1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/14/1998 19:31'!clearSpanBuffer	"Clear the current span buffer.	The span buffer is only cleared in the area that has been used by the previous scan line."	| x0 x1 |	self inline: false.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet + 1.	x0 < 0 ifTrue:[x0 _ 0].	x1 > self spanSizeGet ifTrue:[x1 _ self spanSizeGet].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: 0.		x0 _ x0 + 1].	self spanStartPut: self spanSizeGet.	self spanEndPut: 0.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/10/1998 22:05'!displaySpanBufferAt: y	"Display the span buffer at the current scan line."	| targetX0 targetX1 targetY |	self inline: false.	"self aaLevelGet > 1 ifTrue:[self adjustAALevel]."	targetX0 _ self spanStartGet >> self aaShiftGet.	targetX0 < self clipMinXGet ifTrue:[targetX0 _ self clipMinXGet].	targetX1 _ (self spanEndGet + self aaLevelGet - 1) >> self aaShiftGet.	targetX1 > self clipMaxXGet ifTrue:[targetX1 _ self clipMaxXGet].	targetY _ y >> self aaShiftGet.	(targetY < self clipMinYGet or:[targetY >= self clipMaxYGet or:[		targetX1 < self clipMinXGet or:[targetX0 >= self clipMaxXGet]]]) ifTrue:[^0].	self copyBitsFrom: targetX0 to: targetX1 at: targetY.	self showDisplayBits.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 02:34'!drawWideEdge: edge from: leftX	"Draw the given edge starting from leftX with the edge's fill.	Return the end value of the drawing operation."	| rightX fill type lineWidth |	self inline: false. "Not for the moment"	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ self makeUnsignedFrom: dispatchReturnValue.	fill = 0 ifTrue:[^leftX].	"Check if this line is only partially visible"	"self assert:(self isFillColor: fill)."	rightX _ leftX + lineWidth.	self fillSpan: fill from: leftX to: rightX.	^rightX! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 15:12'!fillAllFrom: leftX to: rightX	"Fill the span buffer from leftX to rightX with the given fill."	| fill startX stopX |	self inline: true.	fill _ self topFill.	startX _ leftX.	stopX _ self topRightX.	[stopX < rightX] whileTrue:[		fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[			(self fillSpan: fill from: startX to: stopX) ifTrue:[^true]].		self quickRemoveInvalidFillsAt: stopX.		startX _ stopX.		stopX _ self topRightX].	fill _ self makeUnsignedFrom: self topFill.	fill = 0 ifFalse:[^self fillSpan: fill from: startX to: rightX].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 16:10'!fillBitmapSpan: bits from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge using the given bits.	Note: We always start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those with depth 32) directly."	| x0 x1 x bitX colorMask colorShift baseShift fillValue |	self inline: false.	self var: #bits declareC:'int *bits'.	x0 _ leftX.	x1 _ rightX.	bitX _ -1. "Hack for pre-increment"	self aaLevelGet = 1 ifTrue:["Speedy version for no anti-aliasing"		[x0 < x1] whileTrue:[			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			spanBuffer at: x0 put: fillValue.			x0 _ x0 + 1.		].	] ifFalse:["Generic version with anti-aliasing"		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		baseShift _ self aaShiftGet.		[x0 < x1] whileTrue:[			x _ x0 >> baseShift.			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			fillValue _ (fillValue bitAnd: colorMask) >> colorShift.			spanBuffer at: x put: (spanBuffer at: x) + fillValue.			x0 _ x0 + 1.		].	].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 03:30'!fillColorSpan: pixelValue32 from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge with the given pixel value."	| x0 x1 |	self inline: true.	"Use a unrolled version for anti-aliased fills..."	self aaLevelGet = 1		ifFalse:[^self fillColorSpanAA: pixelValue32 x0: leftX x1: rightX].	x0 _ leftX.	x1 _ rightX.	"Unroll the inner loop four times, since we're only storing data."	[x0 + 4 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		spanBuffer at: x0+1 put: pixelValue32.		spanBuffer at: x0+2 put: pixelValue32.		spanBuffer at: x0+3 put: pixelValue32.		x0 _ x0+4.	].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		x0 _ x0 + 1.	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:52'!fillColorSpanAA: pixelValue32 x0: leftX x1: rightX	"This is the inner loop for solid color fills with anti-aliasing.	This loop has been unrolled for speed and quality into three parts:		a) copy all pixels that fall into the first full pixel.		b) copy aaLevel pixels between the first and the last full pixel		c) copy all pixels that fall in the last full pixel"	| colorMask baseShift x idx firstPixel lastPixel aaLevel pv32 |	self inline: false. "Not now -- maybe later"	"Compute the pixel boundaries."	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	x _ leftX.	"Part a: Deal with the first n sub-pixels"	x < firstPixel ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < firstPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].	"Part b: Deal with the full pixels"	x < lastPixel ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		pv32 _ (pixelValue32 bitAnd: colorMask) >> self aaShiftGet.		[x < lastPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + aaLevel.		].	].	"Part c: Deal with the last n sub-pixels"	x < rightX ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < rightX] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/15/1998 02:04'!fillSpan: fill from: leftX to: rightX	"Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code."	| x0 x1 type |	self inline: false.	fill = 0 ifTrue:[^false]. "Nothing to do"	"Start from spEnd - we must not paint pixels twice at a scan line"	leftX < self spanEndAAGet 		ifTrue:[x0 _ self spanEndAAGet]		ifFalse:[x0 _ leftX].	rightX > (self spanSizeGet << self aaShiftGet) 		ifTrue:[x1 _ (self spanSizeGet << self aaShiftGet)]		ifFalse:[x1 _ rightX].	"Clip left and right values"	x0 < self fillMinXGet ifTrue:[x0 _ self fillMinXGet].	x1 > self fillMaxXGet ifTrue:[x1 _ self fillMaxXGet].	"Adjust start and end values of span"	x0 < self spanStartGet ifTrue:[self spanStartPut: x0].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].	x0 >= x1 ifTrue:[^false]. "Nothing to do"	(self isFillColor: fill) ifTrue:[		self fillColorSpan: fill from: x0 to: x1.	] ifFalse:[		"Store the values for the dispatch"		self lastExportedFillPut: fill.		self lastExportedLeftXPut: x0.		self lastExportedRightXPut: x1.		type _ self fillTypeOf: fill.		type <= 1 ifTrue:[^true].		self dispatchOn: type in: FillTable.	].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 14:57'!fillSpan: fill from: leftX to: rightX max: maxRightX	"Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code."	| x0 x1 type |	self inline: false.	fill = 0 ifTrue:[^false]. "Nothing to do"	"Start from spEnd - we must not paint pixels twice at a scan line"	leftX < self spanEndAAGet 		ifTrue:[x0 _ self spanEndAAGet]		ifFalse:[x0 _ leftX].	rightX > (self spanSizeGet << self aaShiftGet) 		ifTrue:[x1 _ (self spanSizeGet << self aaShiftGet)]		ifFalse:[x1 _ rightX].	maxRightX < x1 ifTrue:[x1 _ maxRightX].	"Clip left and right values"	x0 < self fillMinXGet ifTrue:[x0 _ self fillMinXGet].	x1 > self fillMaxXGet ifTrue:[x1 _ self fillMaxXGet].	"Adjust start and end values of span"	x0 < self spanStartGet ifTrue:[self spanStartPut: x0].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].	x0 >= x1 ifTrue:[^false]. "Nothing to do"	(self isFillColor: fill) ifTrue:[		self fillColorSpan: fill from: x0 to: x1.	] ifFalse:[		"Store the values for the dispatch"		self lastExportedFillPut: fill.		self lastExportedLeftXPut: x0.		self lastExportedRightXPut: x1.		type _ self fillTypeOf: fill.		type <= 1 ifTrue:[^true].		self dispatchOn: type in: FillTable.	].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 15:13'!postDisplayAction	"We have just blitted a scan line to the screen.	Do whatever seems to be a good idea here."	"Note: In the future we may check the time needed for this scan line and interrupt processing to give the Smalltalk code a chance to run at a certain time."	self inline: false.	"Check if there is any more work to do."	(self getStartGet >= self getUsedGet and:[self aetUsedGet = 0]) ifTrue:[		"No more entries to process"		self statePut: GEStateCompleted.	].	(self currentYGet >= self fillMaxYGet) ifTrue:[		"Out of clipping range"		self statePut: GEStateCompleted.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/8/1998 14:26'!incrementPoint: point by: delta	self var: #point declareC:'int *point'.	point at: 0 put: (point at: 0) + delta.	point at: 1 put: (point at: 1) + delta.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/29/1998 18:42'!transformColor: fillIndex	| r g b a transform |	self var: #transform declareC:'float *transform'.	(fillIndex = 0 or:[self isFillColor: fillIndex]) ifFalse:[^fillIndex].	b _ fillIndex bitAnd: 255.	g _ (fillIndex >> 8) bitAnd: 255.	r _ (fillIndex >> 16) bitAnd: 255.	a _ (fillIndex >> 24) bitAnd: 255.	(self hasColorTransform) ifTrue:[		transform _ self colorTransform.		r _ (r * (transform at: 0) + (transform at: 1)) asInteger.		g _ (g * (transform at: 2) + (transform at: 3)) asInteger.		b _ (b * (transform at: 4) + (transform at: 5)) asInteger.		a _ (a * (transform at: 6) + (transform at: 7)) asInteger.		r _ r max: 0. r _ r min: 255.		g _ g max: 0. g _ g min: 255.		b _ b max: 0. b _ b min: 255.		a _ a max: 0. a _ a min: 255.	].	a < 16 ifTrue:[^0]."ALWAYS return zero for transparent fills"	"If alpha is not 255 (or close thereto) then we need to flush the engine before proceeding.	Use alpha = 240 -- this is the max value for aaLevel 4"	(a < 240 and:[self needsFlush]) 		ifTrue:[self stopBecauseOf: GErrorNeedFlush].	^b + (g << 8) + (r << 16) + (a << 24)! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:47'!transformPoint: point	"Transform the given point. If haveMatrix is true then use the current transformation."	self var:#point declareC:'int *point'.	self hasEdgeTransform ifFalse:[		"Multiply each component by aaLevel and add a half pixel"		point at: 0 put: (point at: 0) + self destOffsetXGet * self aaLevelGet.		point at: 1 put: (point at: 1) + self destOffsetYGet * self aaLevelGet.	] ifTrue:[		"Note: AA adjustment is done in #transformPoint: for higher accuracy"		self transformPoint: point into: point.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/1/1998 16:59'!transformPoint: srcPoint into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This method has been rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	self inline: true.	self transformPointX: ((self cCoerce: srcPoint to: 'int *') at: 0) asFloat 		y: ((self cCoerce: srcPoint to:'int *') at: 1) asFloat		into: (self cCoerce: dstPoint to: 'int *')! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:25'!transformPointX: xValue y: yValue into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This should be rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	| x y transform |	self inline: true. "Won't help at the moment ;-("	self var: #dstPoint declareC:'int *dstPoint'.	self var: #xValue declareC: 'double xValue'.	self var: #yValue declareC: 'double yValue'.	self var: #transform declareC:'float *transform'.	transform _ self edgeTransform.	x _ ((((transform at: 0) * xValue) +		((transform at: 1) * yValue) +		(transform at: 2)) * self aaLevelGet asFloat) asInteger.	y _ ((((transform at: 3) * xValue) +		((transform at: 4) * yValue) +		(transform at: 5)) * self aaLevelGet asFloat) asInteger.	dstPoint at: 0 put: x.	dstPoint at: 1 put: y.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:48'!transformPoints: n	"Transform n (n=1,2,3) points.	If haveMatrix is true then the matrix contains the actual transformation."	self inline: true.	n > 0 ifTrue:[self transformPoint: self point1Get].	n > 1 ifTrue:[self transformPoint: self point2Get].	n > 2 ifTrue:[self transformPoint: self point3Get].	n > 3 ifTrue:[self transformPoint: self point4Get].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:51'!transformWidth: w	"Transform the given width"	| deltaX deltaY destWidth destWidth2 |	self inline: false.	self var: #deltaX declareC:'double deltaX'.	self var: #deltaY declareC:'double deltaY'.	w = 0 ifTrue:[^0].	self point1Get at: 0 put: 0.	self point1Get at: 1 put: 0.	self point2Get at: 0 put: w * 256.	self point2Get at: 1 put: 0.	self point3Get at: 0 put: 0.	self point3Get at: 1 put: w * 256.	self transformPoints: 3.	deltaX _ ((self point2Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point2Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	deltaX _ ((self point3Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point3Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth2 _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	destWidth2 < destWidth ifTrue:[destWidth _ destWidth2].	destWidth = 0		ifTrue:[^1]		ifFalse:[^destWidth]! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/25/1998 21:33'!uncheckedTransformColor: fillIndex	| r g b a transform |	self var: #transform declareC:'float *transform'.	(self hasColorTransform) ifFalse:[^fillIndex].	b _ fillIndex bitAnd: 255.	g _ (fillIndex >> 8) bitAnd: 255.	r _ (fillIndex >> 16) bitAnd: 255.	a _ (fillIndex >> 24) bitAnd: 255.	transform _ self colorTransform.	r _ (r * (transform at: 0) + (transform at: 1)) asInteger.	g _ (g * (transform at: 2) + (transform at: 3)) asInteger.	b _ (b * (transform at: 4) + (transform at: 5)) asInteger.	a _ (a * (transform at: 6) + (transform at: 7)) asInteger.	r _ r max: 0. r _ r min: 255.	g _ g max: 0. g _ g min: 255.	b _ b max: 0. b _ b min: 255.	a _ a max: 0. a _ a min: 255.	a < 16 ifTrue:[^0]."ALWAYS return zero for transparent fills"	^b + (g << 8) + (r << 16) + (a << 24)! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/9/1998 02:06'!accurateLengthOf: deltaX with: deltaY	"Return the accurate length of the vector described by deltaX and deltaY"	| length2 |	deltaX = 0 ifTrue:[deltaY < 0 ifTrue:[^0-deltaY] ifFalse:[^deltaY]].	deltaY = 0 ifTrue:[deltaX < 0 ifTrue:[^0-deltaX] ifFalse:[^deltaX]].	length2 _ (deltaX * deltaX) + (deltaY * deltaY).	^self computeSqrt: length2! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!computeSqrt: length2	length2 < 32 		ifTrue:[^self smallSqrtTable at: length2]		ifFalse:[^(length2 asFloat sqrt + 0.5) asInteger]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 14:33'!estimatedLengthOf: deltaX with: deltaY	"Estimate the length of the vector described by deltaX and deltaY.	This method may be extremely inaccurate - use it only	if you know exactly that this doesn't matter. Otherwise	use #accurateLengthOf:width:"	| absDx absDy |	deltaX >= 0 ifTrue:[absDx _ deltaX] ifFalse:[absDx _ 0 - deltaX].	deltaY >= 0 ifTrue:[absDy _ deltaY] ifFalse:[absDy _ 0 - deltaY].	absDx > absDy 		ifTrue:[^absDx + (absDy // 2)]		ifFalse:[^absDy + (absDx // 2)]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/24/1998 19:45'!initColorTransform	| transform |	self inline: false.	self var: #transform declareC:'float *transform'.	transform _ self colorTransform.	transform at: 0 put: (self cCoerce: 1.0 to: 'float').	transform at: 1 put: (self cCoerce: 0.0 to: 'float').	transform at: 2 put: (self cCoerce: 1.0 to: 'float').	transform at: 3 put: (self cCoerce: 0.0 to: 'float').	transform at: 4 put: (self cCoerce: 1.0 to: 'float').	transform at: 5 put: (self cCoerce: 0.0 to: 'float').	transform at: 6 put: (self cCoerce: 1.0 to: 'float').	transform at: 7 put: (self cCoerce: 0.0 to: 'float').	self hasColorTransformPut: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/24/1998 19:45'!initEdgeTransform	| transform |	self inline: false.	self var: #transform declareC:'float *transform'.	transform _ self edgeTransform.	transform at: 0 put: (self cCoerce: 1.0 to: 'float').	transform at: 1 put: (self cCoerce: 0.0 to: 'float').	transform at: 2 put: (self cCoerce: 0.0 to: 'float').	transform at: 3 put: (self cCoerce: 0.0 to: 'float').	transform at: 4 put: (self cCoerce: 1.0 to: 'float').	transform at: 5 put: (self cCoerce: 0.0 to: 'float').	self hasEdgeTransformPut: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!resetGraphicsEngineStats	self inline: false.	workBuffer at: GWTimeInitializing put: 0.	workBuffer at: GWTimeFinishTest put: 0.	workBuffer at: GWTimeNextGETEntry put: 0.	workBuffer at: GWTimeAddAETEntry put: 0.	workBuffer at: GWTimeNextFillEntry put: 0.	workBuffer at: GWTimeMergeFill put: 0.	workBuffer at: GWTimeDisplaySpan put: 0.	workBuffer at: GWTimeNextAETEntry put: 0.	workBuffer at: GWTimeChangeAETEntry put: 0.	workBuffer at: GWCountInitializing put: 0.	workBuffer at: GWCountFinishTest put: 0.	workBuffer at: GWCountNextGETEntry put: 0.	workBuffer at: GWCountAddAETEntry put: 0.	workBuffer at: GWCountNextFillEntry put: 0.	workBuffer at: GWCountMergeFill put: 0.	workBuffer at: GWCountDisplaySpan put: 0.	workBuffer at: GWCountNextAETEntry put: 0.	workBuffer at: GWCountChangeAETEntry put: 0.	workBuffer at: GWBezierMonotonSubdivisions put: 0.	workBuffer at: GWBezierHeightSubdivisions put: 0.	workBuffer at: GWBezierOverflowSubdivisions put: 0.	workBuffer at: GWBezierLineConversions put: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!setAALevel: level	"Set the anti-aliasing level. Three levels are supported:		1 - No antialiasing		2 - 2x2 unweighted anti-aliasing		4 - 4x4 unweighted anti-aliasing.	"	| aaLevel |	self inline: false.	level >= 4 ifTrue:[aaLevel _ 4].	(level >= 2) & (level < 4) ifTrue:[aaLevel _ 2].	level < 2 ifTrue:[aaLevel _ 1].	self aaLevelPut: aaLevel.	aaLevel = 1 ifTrue:[		self aaShiftPut: 0.		self aaColorMaskPut: 16rFFFFFFFF.		self aaScanMaskPut: 0.	].	aaLevel = 2 ifTrue:[		self aaShiftPut: 1.		self aaColorMaskPut: 16rFCFCFCFC.		self aaScanMaskPut: 1.	].	aaLevel = 4 ifTrue:[		self aaShiftPut: 2.		self aaColorMaskPut: 16rF0F0F0F0.		self aaScanMaskPut: 3.	].	self aaColorShiftPut: self aaShiftGet * 2.	self aaHalfPixelPut: self aaShiftGet.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 15:25'!smallSqrtTable	| theTable |	self inline: false.	self returnTypeC:'int *'.	self var: #theTable declareC:'static int theTable[32] = 	{0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6}'.	^theTable! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 20:57'!squaredLengthOf: deltaX with: deltaY	^(deltaX * deltaX) + (deltaY * deltaY)! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/25/1998 02:22'!stopBecauseOf: stopReason	self stopReasonPut: stopReason.	engineStopped _ true.! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/29/1998 18:45'!errorWrongIndex	self error:'BalloonEngine: Fatal dispatch error'! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/28/1998 20:58'!makeUnsignedFrom: someIntegerValue	^someIntegerValue! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 1/12/1999 10:47'!declareCVarsIn: cg	"Buffers"	cg var: 'workBuffer' declareC:'int *workBuffer'.	cg var: 'objBuffer' declareC:'int *objBuffer'.	cg var: 'getBuffer' declareC:'int *getBuffer'.	cg var: 'aetBuffer' declareC:'int *aetBuffer'.	cg var: 'spanBuffer' declareC:'unsigned int *spanBuffer'.	cg var: 'edgeTransform' declareC: 'float edgeTransform[6]'.	cg var: 'doProfileStats' declareC:'int doProfileStats = 0'.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/7/1998 22:26'!initialize	"BalloonEngineBase initialize"	"BalloonEnginePlugin translateDoInlining: true."	EdgeInitTable _ self initializeEdgeInitTable.	EdgeStepTable _ self initializeEdgeStepTable.	WideLineWidthTable _ self initializeWideLineWidthTable.	WideLineFillTable _ self initializeWideLineFillTable.	FillTable _ self initializeFillTable.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeInitTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToFirstLine		stepToFirstWideLine		stepToFirstBezier		stepToFirstWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeStepTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToNextLine		stepToNextWideLine		stepToNextBezier		stepToNextWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/25/1998 19:46'!initializeFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex "Type zero - undefined"		errorWrongIndex "Type one - external fill"		fillLinearGradient "Linear gradient fill"		fillRadialGradient "Radial gradient fill"		fillBitmapSpan	"Clipped bitmap fill"		fillBitmapSpan	"Repeated bitmap fill"	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineFill		returnWideBezierFill	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineWidthTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineWidth		returnWideBezierWidth	)! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 10/28/1998 20:48'!moduleName	^'sqBalloonEngine'! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 11/11/1998 21:56'!simulatorClass	^BalloonEngineSimulation! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:33'!a1EngineOutline	"The following is a brief outline on how the engine works.	In general, we're using a pretty straight-forward active edge approach, e.g., 	we classify all edges into three different states:		a) Waiting for processing		b) Active (e.g., being processed)		c) Finished	Before the engine starts all edges are sorted by their y-value in a so-called	'global edge table' (furthermore referred to as GET) and processed in top 	to bottom order (the edges are also sorted by x-value but this is only for 	simplifying the insertion when adding edges).	Then, we start at the first visible scan line and execute the following steps:	1) Move all edges starting at the current scan line from state a) to state b)	This step requires the GET to be sorted so that we only need to check	the first edges of the GET. After the initial state of the edge (e.g., it's current	pixel value and data required for incremental updates) the edges are then 	inserted in the 'active edge table' (called AET). The sort order in the AET is 	defined by the pixel position of each edge at the current scan line and thus 	edges are kept in increasing x-order.	This step does occur for every edge only once and is therefore not the most	time-critical part of the approach.	2) Draw the current scan line	This step includes two sub-parts. In the first part, the scan line is assembled.	This involves walking through the AET and drawing the pixels between	each two neighbour edges. Since each edge can have two associated fills	(a 'left' and a 'right' fill) we need to make sure that edges falling on the	same pixel position do not affect the painted image. This issue is discussed	in the aetScanningProblems documentation.	Wide edges (e.g., edges having an associated width) are also handled during	this step. Wide edges are always preferred over interior fills - this ensures	that the outline of an object cannot be overdrawn by any interior fill of	a shape that ends very close to the edge (for more information see wideEdges 	documentation).	After the scan is assembled it is blitted to the screen. This only happens all	'aaLevel' scan lines (for further information see the antiAliasing documentation).	This second step is done at each scan line in the image, and is usually the most	time-critical part.	3) Update all currently active edges	Updating the active edges basically means either to remove the edge from the AET	(if it is at the end y value) or incrementally computing the pixel value for the	next scan line. Based on the information gathered in the first step, this part	should be executed as fast as possible - it happens for each edge in the AET	at each scan line and may be the bottleneck if many edges are involved in	the drawing operations (see the TODO list; part of it probably deals with the	issue)."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:55'!a2AntiAliasing	"The engine currently used a very simple, but efficient anti-aliasing scheme. It is based on a square unweighted filter of size 1, 2, or 4 resulting in three levels of anti-aliasing:	* No anti-aliasing (filter size 1)	This simply draws each pixel 'as is' on the screen	* Slight anti-aliasing (filter size 2)	Doubles the rasterization size in each direction and assembles the pixel value as the medium of the four sub-pixels falling into the full pixel	* Full anti-aliasing (filter size 4)	Quadruples the rasterization in each direction and assembles the pixel value as the medium of the sixteen sub-pixels falling into the full pixelThe reason for using these three AA levels is simply efficiency of computing. Since the above filters (1x1, 2x2, 4x4) have all power of two elements (1, 4, and 16) we can compute the weighted sum of the final pixel by computing	destColor _ destColor + (srcColor // subPixels)And, since we're only working on 32bit destination buffer we do not need to compute the components of each color separately but can neatly put the entire color into a single formula:	destPixel32 _ destPixel32 + ((srcPixel32 bitAnd: aaMask) >> aaShift).with aaMask = 16rFFFFFFFF for aaLevel = 1, aaMask = 16rFCFCFCFC for aaLevel = 2, aaMask = 16rF0F0F0F0 for aaLevel = 4 and aaShift = 0, 2, or 4 for the different levels. However, while the above is efficient to compute, it also drops accuracy. So, for the 4x4 anti-aliasing we're effectively only using the high 4 bits of each color component. While is generally not a problem (we add 16 sub-pixels into this value) there is a simple arithmetic difficulty because the above cannot fill the entire range of values, e.g.,	16 * (255 // 16) = 16 * 15 = 240and not 255 as expected. We solve this problem by replicating the top n (n=0, 2, 4) bits of each component as the low bits in an adjustment step before blitting to scan line to the screen. This has the nice effect that a zero pixel value (e.g., transparent) will remain zero, a white pixel (as computed above) will result in a value of 255 for each component (defining opaque white) and each color inbetween linearly mapped between 0 and 255. "	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a3RasterizationRules	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a4WideEdges! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:36'!a5AETScanningProblems	"Due to having two fill entries (one left and one right) there can be problems while scanning the active edge table. In general, the AET should look like the following (ri - regions, ei - edges, fi - fills):			|				\				|	r1		|		r2		 \		r3		|		r4			|				  \				|			e1				 e2				e3			with:		f(r1) = fLeft(e1) = 0				(empty fill, denoted -)		f(r2) = fRight(e1) = fLeft(e2)		(denoted x)		f(r3) = fRight(e2) = fLeft(e3)	(denoted o)		f(r4) = fRight(e3) = 0	However, due to integer arithmetic used during computations the AET may look like the following:			X			\|						|			 | \						|			 |   \					|	r1		 | r2 \			r3		|		r4			 |	   \					|			e1		e2				e3			In this case, the starting point of e1 and e2 have the same x value at the first scan line but e2 has been sorted before e1 (Note: This can happen in *many* cases - the above is just a very simple example). Given the above outlined fill relations we have a problem. So, for instance, using the left/right fills as defined by the edges would lead to the effect that in the first scan line region r3 is actually filled with the right fill of e1 while it should actually be filled with the right fill of e2. This leads to noticable artifacts in the image and increasing resolution does not help.	What we do here is defining an arbitrary sort order between fills (you can think of it as a depth value but the only thing that matters is that you can order the fills by this number and that the empty fill is always sorted at the end), and toggle the fills between an 'active' and an 'inactive' state at each edge. This is done as follows:	For each edge ei in the AET do:		* if fLeft(ei) isActive then removeActive(fLeft(ei)) else addActive(fLeft(ei))		* if fRight(ei) isActive then removeActive(fRight(ei)) else addActive(fRight(ei))		* draw the span from ei to ei+1 with currentActive	where addActive adds the fill to the list of currently active fills, removeActive() removes the fill from the active list and currentActive returns the fill AS DEFINED BY THE SORT ORDER from the list of active fills. Note that this does not change anything in the first example above because the list will only contain one entry (besides the empty fill). In the second case however, it will lead to the following sequence:	* toggle fLeft(e2) = f(r2) = 'x'		- makes fLeft(e2) active		- activeList = 'x'	* toggle fRight(e2) = f(r3) = 'o'		- makes fRight(e2) active		- activeList = 'xo'	* draw span from e2 to e1		Depending on the sort order between 'x' and 'o' the region will be drawn with either one of the fills. It is significant to note here that the occurence of such a problem is generally only *very* few pixels large (in the above example zero pixels) and will therefore not be visually noticable. In any case, there is a unique decision for the fill to use here and that is what we need if the problem did not happen accidentally (e.g., someone has manually changed one fill of an edge but not the fill of the opposite edge).	* toggle fLeft(e1) = f(r1) = '-'		- makes fLeft(r1) visible		- activeList = 'xo-'		[Note: empty fills are a special case. 		They can be ignored since they sort last		and the activeList can return the empty		fill if it is itself empty].	* toggle fRight(e1) = f(r2) = 'x'		- makes fRight(e1) invisible		- activeList = 'o-'	* draw span from e2 to e3		Since the active list contains (besides the empty fill) only one fill value this will be used. Fortunately, this is the correct fill because it is the fill we had initially defined for the region r2.An interesting side effect of the above is that there is no such notion as a 'left' or 'right' fill anymore. Another (not-so-nice) side effect is that the entire AET has to be scanned from the beginning even if only the last few edges actually affect the visible region.PS. I need to find a way of clipping the edges for this. More on it later..."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/8/1998 00:06'!a6StuffTODO	"This is an unordered list of things to do:BalloonEnginePlugin>>stepToFirstBezierIn:at:	1)	Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure.BalloonEngineBase>>dispatchOn:in:	1)	Check what dispatches cost most and must be inlined		by an #inlinedDispatchOn:in: Probably this will be		stepping and eventually wide line stuff but we'll see.BalloonEngineBase	1)	Check which variables should become inst vars, if any.		This will remove an indirection during memory access		and might allow a couple of optimizations by the C compiler.Anti-Aliasing:	1)	Check if we can use a weighted 3x3 filter function of the form				1	2	1				2	4	2				1	2	1		Which should be *extremely* nice for fonts (it's sharpening		edges). The good thing about the above is that it sums up to		16 (as in the 4x4 case) but I don't know how to keep a history		without needing two extra scan lines.	2)	Check if we can - somehow - integrate more general filters.	3) Unroll the loops during AA so we can copy and mask aaLevel pixels	   in each step between start and end. This should speed up filling	   by a factor of 2-4 (in particular for difficult stuff like radial gradients).Clipping	1)	Find a way of clipping edges left of the clip rectangle		or at least ignoring most of them after the first scan line.		The AET scanning problems discuss the issue but it should be		possible to keep the color list between spans (if not empty)		and speed up drawing at the very right (such as in the		Winnie Pooh example where a lot of stuff is between the		left border and the clipping rect.	2)	Check if we can determine empty states of the color list and		an edge that is longer than anything left of it. This should		work in theory but might be relatively expensive to compute."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'private' stamp: 'ar 11/9/1998 15:41'!localTranslate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		BalloonEnginePlugin localTranslate: 'sqBalloonEngine.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ CCodeGenerator new initialize.	theClass _ self.	[theClass == InterpreterPlugin] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/24/1998 23:54'!initEdgeConstants: dict	"Initialize the edge constants"	self initFromSpecArray:	#(		"Edge primitive types"		(GEPrimitiveEdge 2)			"External edge - not handled by the GE"		(GEPrimitiveWideEdge 3)		"Wide external edge"		(GEPrimitiveLine 4)			"Straight line"		(GEPrimitiveWideLine 5)		"Wide line"		(GEPrimitiveBezier 6)		"Quadratic bezier curve"		(GEPrimitiveWideBezier 7)	"Wide bezier curve"		"Special flags"		(GEPrimitiveWide 16r01)		"Flag determining a wide primitive"		(GEPrimitiveWideMask 16rFE)	"Mask for clearing the wide flag"		(GEEdgeFillsInvalid 16r10000) "Flag determining if left/right fills of an edge are invalid"		(GEEdgeClipFlag 16r20000)	"Flag determining if this is a clip edge"		"General edge state constants"		(GEXValue 4)					"Current raster x"		(GEYValue 5)					"Current raster y"		(GEZValue 6)					"Current raster z"		(GENumLines 7)					"Number of scan lines remaining"		(GEFillIndexLeft 8)				"Left fill index"		(GEFillIndexRight 9)				"Right fill index"		(GEBaseEdgeSize 10)				"Basic size of each edge"		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"General Line state constants"		(GLXDirection 10)				"Direction of edge (1: left-to-right; -1: right-to-left)"		(GLYDirection 11)				"Direction of edge (1: top-to-bottom; -1: bottom-to-top)"		(GLXIncrement 12)				"Increment at each scan line"		(GLError 13)						"Current error"		(GLErrorAdjUp 14)				"Error to add at each scan line"		(GLErrorAdjDown 15)				"Error to subtract on roll-over"			"Note: The following entries are only needed before the incremental			state is computed. They are therefore aliased to the error values above"		(GLEndX 14)						"End X of line"		(GLEndY 15)						"End Y of line"		(GLBaseSize 16)					"Basic size of each line"		"Additional stuff for wide lines"		(GLWideFill 16)					"Current fill of line"		(GLWideWidth 17)				"Current width of line"		(GLWideEntry 18)				"Initial steps"		(GLWideExit 19)					"Final steps"		(GLWideExtent 20)				"Target width"		(GLWideSize 21)					"Size of wide lines"		"General Bezier state constants"		(GBUpdateData 10)				"Incremental update data for beziers"			(GBUpdateX 0)				"Last computed X value (24.8)"			(GBUpdateY 1)				"Last computed Y value (24.8)"			(GBUpdateDX 2)				"Delta X forward difference step (8.24)"			(GBUpdateDY 3)				"Delta Y forward difference step (8.24)"			(GBUpdateDDX 4)				"Delta DX forward difference step (8.24)"			(GBUpdateDDY 5)				"Delta DY forward difference step (8.24)"		"Note: The following four entries are only needed before the incremental			state is computed. They are therefore aliased to the incremental values above"		(GBViaX 12)						"via x"		(GBViaY 13)						"via y"		(GBEndX 14)						"end x"		(GBEndY 15)						"end y"		(GBBaseSize 16)					"Basic size of each bezier.										Note: MUST be greater or equal to the size of lines"		"Additional stuff for wide beziers"		(GBWideFill 16)					"Current fill of line"		(GBWideWidth 17)				"Current width of line"		(GBWideEntry 18)				"Initial steps"		(GBWideExit 19)					"Final steps"		(GBWideExtent 20)				"Target extent"		(GBFinalX 21)					"Final X value"		(GBWideUpdateData 22)	"Update data for second curve"		(GBWideSize 28)					"Size of wide beziers"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/27/1998 14:19'!initFillConstants: dict	"Initialize the fill constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		"Fill primitive types"		(GEPrimitiveFill 16r100)		(GEPrimitiveLinearGradientFill 16r200)		(GEPrimitiveRadialGradientFill 16r300)		(GEPrimitiveClippedBitmapFill 16r400)		(GEPrimitiveRepeatedBitmapFill 16r500)		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"Oriented fill constants"		(GFOriginX 4)				"X origin of fill"		(GFOriginY 5)				"Y origin of fill"		(GFDirectionX 6)				"X direction of fill"		(GFDirectionY 7)				"Y direction of fill"		(GFNormalX 8)				"X normal of fill"		(GFNormalY 9)				"Y normal of fill"		"Gradient fill constants"		(GFRampLength 10)			"Length of following color ramp"		(GFRampOffset 12)			"Offset of first ramp entry"		(GGBaseSize 12)		"Bitmap fill constants"		(GBBitmapWidth 10)			"Width of bitmap"		(GBBitmapHeight 11)			"Height of bitmap"		(GBBitmapDepth 12)			"Depth of bitmap"		(GBBitmapSize 13)			"Size of bitmap words"		(GBBitmapRaster 14)			"Size of raster line"		(GBColormapSize 15)			"Size of colormap, if any"		(GBTileFlag 16)				"True if the bitmap is tiled"		(GBColormapOffset 18)		"Offset of colormap, if any"		(GBMBaseSize 18)			"Basic size of bitmap fill"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initFromSpecArray: specArray in: aDictionary	specArray do:[:spec|		self initPoolVariable: spec first value: spec last in: aDictionary.	]! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool	"BalloonEngineBase initPool"	(Smalltalk includesKey: #BalloonEngineConstants) ifFalse:[		Smalltalk declare: #BalloonEngineConstants from: Undeclared.	].	(Smalltalk at: #BalloonEngineConstants) isNil ifTrue:[		(Smalltalk associationAt: #BalloonEngineConstants) value: Dictionary new.	].	self initPool: (Smalltalk at: #BalloonEngineConstants).! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool: aDictionary	self initStateConstants: aDictionary.	self initWorkBufferConstants: aDictionary.	self initPrimitiveConstants: aDictionary.	self initEdgeConstants: aDictionary.	self initFillConstants: aDictionary.	self initializeInstVarNames: BalloonEngine in: aDictionary prefixedBy: 'BE'.	self initializeInstVarNames: BalloonEdgeData in: aDictionary prefixedBy: 'ET'.	self initializeInstVarNames: BalloonFillData in: aDictionary prefixedBy: 'FT'.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolFull	"BalloonEngineBase initPoolFull"	"Move old stuff to Undeclared and re-initialize the receiver"	BalloonEngineConstants associationsDo:[:assoc|		Undeclared declare: assoc key from: BalloonEngineConstants.	].	self initPool.	Undeclared removeUnreferencedKeys.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolVariable: token value: value in: aDictionary	aDictionary declare: token from: Undeclared.	(aDictionary associationAt: token) value: value.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPrimitiveConstants: dict	"Initialize the primitive constants"	self initFromSpecArray:	#(		"Primitive type constants"		(GEPrimitiveUnknown 0)		(GEPrimitiveEdgeMask 16rFF)		(GEPrimitiveFillMask 16rFF00)		(GEPrimitiveTypeMask 16rFFFF)		"General state constants (Note: could be compressed later)"		(GEObjectType 0)				"Type of object"		(GEObjectLength 1)			"Length of object"		(GEObjectIndex 2)			"Index into external objects"		(GEObjectUnused 3)			"Currently unused"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/25/1998 00:25'!initStateConstants: dict	"Initialize the state Constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		(GEStateUnlocked 0)			"Buffer is unlocked and can be modified as wanted"		(GEStateAddingFromGET 1)	"Adding edges from the GET"		(GEStateWaitingForEdge 2)	"Waiting for edges added to GET"		(GEStateScanningAET 3)		"Scanning the active edge table"		(GEStateWaitingForFill 4)		"Waiting for a fill to mix in during AET scan"		(GEStateBlitBuffer 5)			"Blt the current scan line"		(GEStateUpdateEdges 6)		"Update edges to next scan line"		(GEStateWaitingChange 7)	"Waiting for a changed edge"		(GEStateCompleted 8)			"Rendering completed"		"Error constants"		(GErrorNoMoreSpace 1)		"No more space in collection"		(GErrorBadState 2)			"Tried to call a primitive while engine in bad state"		(GErrorNeedFlush 3)			"Tried to call a primitive that requires flushing before"		"Incremental error constants"		(GErrorGETEntry 4)			"Unknown entry in GET"		(GErrorFillEntry 5)			"Unknown FILL encountered"		(GErrorAETEntry 6)			"Unknown entry in AET"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/25/1998 00:20'!initWorkBufferConstants: dict	"Initialize the work buffer constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		"General work buffer constants"		(GWMagicNumber 16r416E6469)	"Magic number"		(GWHeaderSize 128)				"Size of header"		(GWMinimalSize 256)				"Minimal size of work buffer"		"Header entries"		(GWMagicIndex 0)				"Index of magic number"		(GWSize 1)						"Size of full buffer"		(GWState 2)						"Current state (e.g., locked or not)"		"Buffer entries"		(GWObjStart 8)					"objStart"		(GWObjUsed 9)					"objUsed"		(GWBufferTop 10)				"wbTop"		(GWGETStart 11)					"getStart"		(GWGETUsed 12)					"getUsed"		(GWAETStart 13)					"aetStart"		(GWAETUsed 14)					"aetUsed"		"Transform entries"		(GWHasEdgeTransform 16)		"True if we have an edge transformation"		(GWHasColorTransform 17)		"True if we have a color transformation"		(GWEdgeTransform 18)			"2x3 edge transformation"		(GWColorTransform 24)			"8 word RGBA color transformation"		"Span entries"		(GWSpanStart 32)				"spStart"		(GWSpanSize 33)					"spSize"		(GWSpanEnd 34)					"spEnd"		(GWSpanEndAA 35)				"spEndAA"		"Bounds entries"		(GWFillMinX 36)					"fillMinX"		(GWFillMaxX 37)					"fillMaxX"		(GWFillMinY 38)					"fillMinY"		(GWFillMaxY 39)					"fillMaxY"		(GWFillOffsetX 40)				"fillOffsetX"		(GWFillOffsetY 41)				"fillOffsetY"		(GWClipMinX 42)		(GWClipMaxX 43)		(GWClipMinY 44)		(GWClipMaxY 45)		(GWDestOffsetX 46)		(GWDestOffsetY 47)		"AA entries"		(GWAALevel 48)					"aaLevel"		(GWAAShift 49)					"aaShift"		(GWAAColorShift 50)				"aaColorShift"		(GWAAColorMask 51)				"aaColorMask"		(GWAAScanMask 52)				"aaScanMask"		(GWAAHalfPixel 53)				"aaHalfPixel"		"Misc entries"		(GWNeedsFlush 63)				"True if the engine may need a flush"		(GWStopReason 64)				"stopReason"		(GWLastExportedEdge 65)			"last exported edge"		(GWLastExportedFill 66)			"last exported fill"		(GWLastExportedLeftX 67)			"last exported leftX"		(GWLastExportedRightX 68)		"last exported rightX"		(GWClearSpanBuffer 69)			"Do we have to clear the span buffer?"		(GWPointListFirst 70)				"First point list in buffer"		(GWPoint1 80)		(GWPoint2 82)		(GWPoint3 84)		(GWPoint4 86)		(GWCurrentY 88)		"Profile stats"		(GWTimeInitializing 90)		(GWCountInitializing 91)		(GWTimeFinishTest 92)		(GWCountFinishTest 93)		(GWTimeNextGETEntry 94)		(GWCountNextGETEntry 95)		(GWTimeAddAETEntry 96)		(GWCountAddAETEntry 97)		(GWTimeNextFillEntry 98)		(GWCountNextFillEntry 99)		(GWTimeMergeFill 100)		(GWCountMergeFill 101)		(GWTimeDisplaySpan 102)		(GWCountDisplaySpan 103)		(GWTimeNextAETEntry 104)		(GWCountNextAETEntry 105)		(GWTimeChangeAETEntry 106)		(GWCountChangeAETEntry 107)		"Bezier stats"		(GWBezierMonotonSubdivisions 108) 	"# of subdivision due to non-monoton beziers"		(GWBezierHeightSubdivisions 109)		"# of subdivisions due to excessive height"		(GWBezierOverflowSubdivisions 110)	"# of subdivisions due to possible int overflow"		(GWBezierLineConversions 111)		"# of beziers converted to lines"		(GWHasClipShapes 112)		"True if the engine contains clip shapes"		(GWCurrentZ 113)			"Current z value of primitives"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initializeInstVarNames: aClass in: aDictionary prefixedBy: aString	| token value |	aClass instVarNames doWithIndex:[:instVarName :index|		token _ (aString, instVarName first asUppercase asString, (instVarName copyFrom: 2 to: instVarName size),'Index') asSymbol.		value _ index - 1.		aDictionary declare: token from: Undeclared.		(aDictionary associationAt: token) value: value.	].	token _ (aString, aClass name,'Size') asSymbol.	aDictionary declare:  token from: Undeclared.	(aDictionary associationAt: token) value: aClass instSize.! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddBezier	| leftFill rightFill viaOop endOop startOop nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	viaOop _ interpreterProxy stackObjectValue: 2.	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Do a quick check if the fillIndices are equal - if so, just ignore it"	leftFill = rightFill & false ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: viaOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self transformPoints: 3.	nSegments _ self loadAndSubdivideBezierFrom: self point1Get 						via: self point2Get 						to: self point3Get 						isWide: false.	self needAvailableSpace: nSegments * GBBaseSize.	engineStopped ifFalse:[		leftFill _ self transformColor: leftFill.		rightFill _ self transformColor: rightFill].	engineStopped ifFalse:[		self loadWideBezier: 0 lineFill: 0 leftFill: leftFill rightFill: rightFill n: nSegments.	].	engineStopped ifTrue:[		"Make sure the stack is okay"		self wbStackClear.		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddBezierShape	| points lineFill lineWidth fillIndex length isArray segSize nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nSegments _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = (nSegments * 3) or:[length = (nSegments * 6)])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = (nSegments * 3)			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 5].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual shape"	isArray ifTrue:[		self loadArrayShape: points nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill.	] ifFalse:[		self loadShape: (interpreterProxy firstIndexableField: points) nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nSegments * 3 = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/27/1998 14:26'!gePrimitiveAddBitmapFill	| nrmOop dirOop originOop tileFlag fill xIndex cmOop formOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	xIndex _ interpreterProxy stackIntegerValue: 0.	xIndex <= 0 ifTrue:[^interpreterProxy primitiveFail].	nrmOop _ interpreterProxy stackObjectValue: 1.	dirOop _ interpreterProxy stackObjectValue: 2.	originOop _ interpreterProxy stackObjectValue: 3.	tileFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 4).	tileFlag ifTrue:[tileFlag _ 1] ifFalse:[tileFlag _ 0].	cmOop _ interpreterProxy stackObjectValue: 5.	formOop _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadBitmapFill: formOop 				colormap: cmOop				tile: tileFlag				from: self point1Get 				along: self point2Get 				normal: self point3Get 				xIndex: xIndex-1.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 8.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddCompressedShape	| fillIndexList lineFills lineWidths rightFills leftFills nSegments points pointsShort |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	fillIndexList _ interpreterProxy stackObjectValue: 0.	lineFills _ interpreterProxy stackObjectValue: 1.	lineWidths _ interpreterProxy stackObjectValue: 2.	rightFills _ interpreterProxy stackObjectValue: 3.	leftFills _ interpreterProxy stackObjectValue: 4.	nSegments _ interpreterProxy stackIntegerValue: 5.	points _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the compressed shape is okay"	(self checkCompressedShape: points 			segments: nSegments 			leftFills: leftFills 			rightFills: rightFills 			lineWidths: lineWidths 			lineFills: lineFills 			fillIndexList: fillIndexList) ifFalse:[^interpreterProxy primitiveFail].	"Now check that we have some hope to have enough free space.	Do this by assuming nSegments boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(self needAvailableSpace: (GBBaseSize max: GLBaseSize) * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check if the points are short"	pointsShort _ (interpreterProxy slotSizeOf: points) = (nSegments * 3).	"Then actually load the compressed shape"	self loadCompressedShape: (interpreterProxy firstIndexableField: points)			segments: nSegments 			leftFills: (interpreterProxy firstIndexableField: leftFills)			rightFills: (interpreterProxy firstIndexableField: rightFills)			lineWidths: (interpreterProxy firstIndexableField: lineWidths)			lineFills: (interpreterProxy firstIndexableField: lineFills)			fillIndexList: (interpreterProxy firstIndexableField: fillIndexList)			pointShort: pointsShort.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 7. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/24/1998 21:15'!gePrimitiveAddGradientFill	| isRadial nrmOop dirOop originOop rampOop fill |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	isRadial _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	nrmOop _ interpreterProxy stackValue: 1.	dirOop _ interpreterProxy stackValue: 2.	originOop _ interpreterProxy stackValue: 3.	rampOop _ interpreterProxy stackValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadGradientFill: rampOop 				from: self point1Get 				along: self point2Get 				normal: self point3Get 				isRadial: isRadial.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:27'!gePrimitiveAddLine	| leftFill rightFill endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	endOop _ interpreterProxy stackObjectValue: 2.	startOop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 4) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Load the points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	"Transform points"	self transformPoints: 2.	"Transform colors"	leftFill _ self transformColor: leftFill.	rightFill _ self transformColor: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Load line"	self loadWideLine: 0 from: self point1Get to: self point2Get 		lineFill: 0 leftFill: leftFill rightFill: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 4. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:40'!gePrimitiveAddOval	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	fillIndex _ self transformColor: fillIndex.	borderIndex _ self transformColor: borderIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth <= 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (16 * GBBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self loadOval: borderWidth lineFill: borderIndex 		leftFill: 0 rightFill: fillIndex.	engineStopped ifTrue:[		self wbStackClear.		^interpreterProxy primitiveFail.	].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:30'!gePrimitiveAddPolygon	| points lineFill lineWidth fillIndex nPoints length isArray segSize |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nPoints _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = nPoints or:[nPoints * 2 = length])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = nPoints			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nPoints)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[lineWidth _ self transformWidth: lineWidth].	"And load the actual polygon"	isArray ifTrue:[		self loadArrayPolygon: points nPoints: nPoints			fill: fillIndex lineWidth: lineWidth lineFill: lineFill	] ifFalse:[		self loadPolygon: (interpreterProxy firstIndexableField: points) nPoints: nPoints 			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nPoints = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:30'!gePrimitiveAddRect	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	borderIndex _ self transformColor: borderIndex.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth = 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (4 * GLBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^nil].	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).	"Transform the points"	self transformPoints: 4.	self loadRectangle: borderWidth lineFill: borderIndex leftFill: 0 rightFill: fillIndex.	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 21:28'!gePrimitiveGetBezierStats	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 4		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWBezierMonotonSubdivisions).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWBezierHeightSubdivisions).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWBezierOverflowSubdivisions).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWBezierLineConversions).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndXOf: line	^self obj: line at: GLEndX! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndXOf: line put: value	^self obj: line at: GLEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndYOf: line	^self obj: line at: GLEndY! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndYOf: line put: value	^self obj: line at: GLEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineErrorAdjDownOf: line	^self obj: line at: GLErrorAdjDown! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineErrorAdjDownOf: line put: value	^self obj: line at: GLErrorAdjDown put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorAdjUpOf: line	^self obj: line at: GLErrorAdjUp! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorAdjUpOf: line put: value	^self obj: line at: GLErrorAdjUp put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorOf: line	^self obj: line at: GLError! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorOf: line put: value	^self obj: line at: GLError put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineXDirectionOf: line	^self obj: line at: GLXDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXDirectionOf: line put: value	^self obj: line at: GLXDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXIncrementOf: line	^self obj: line at: GLXIncrement! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXIncrementOf: line put: value	^self obj: line at: GLXIncrement put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineYDirectionOf: line	^self obj: line at: GLYDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineYDirectionOf: line put: value	^self obj: line at: GLYDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!wideLineEntryOf: line	^self obj: line at: GLWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineEntryOf: line put: value	^self obj: line at: GLWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExitOf: line	^self obj: line at: GLWideExit! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExitOf: line put: value	^self obj: line at: GLWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExtentOf: line	^self obj: line at: GLWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExtentOf: line put: value	^self obj: line at: GLWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineFillOf: line	^self obj: line at: GLWideFill! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineFillOf: line put: value	^self obj: line at: GLWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineWidthOf: line	^self obj: line at: GLWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineWidthOf: line put: value	^self obj: line at: GLWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!bezierEndXOf: bezier	^self obj: bezier at: GBEndX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierEndXOf: bezier put: value	^self obj: bezier at: GBEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierEndYOf: bezier	^self obj: bezier at: GBEndY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierEndYOf: bezier put: value	^self obj: bezier at: GBEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:19'!bezierFinalXOf: bezier	^self obj: bezier at: GBFinalX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierFinalXOf: bezier put: value	^self obj: bezier at: GBFinalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:24'!bezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!bezierViaXOf: bezier	^self obj: bezier at: GBViaX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierViaXOf: bezier put: value	^self obj: bezier at: GBViaX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierViaYOf: bezier	^self obj: bezier at: GBViaY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierViaYOf: bezier put: value	^self obj: bezier at: GBViaY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index	^self wbStackValue: self wbStackSize - index + 4! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index put: value	^self wbStackValue: self wbStackSize - index + 4 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index	^self wbStackValue: self wbStackSize - index + 5! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index put: value	^self wbStackValue: self wbStackSize - index + 5 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index	^self wbStackValue: self wbStackSize - index + 0! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index put: value	^self wbStackValue: self wbStackSize - index + 0 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzStartY: index	^self wbStackValue: self wbStackSize - index + 1! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartY: index put: value	^self wbStackValue: self wbStackSize - index + 1 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaX: index	^self wbStackValue: self wbStackSize - index + 2! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaX: index put: value	^self wbStackValue: self wbStackSize - index + 2 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaY: index	^self wbStackValue: self wbStackSize - index + 3! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaY: index put: value	^self wbStackValue: self wbStackSize - index + 3 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierEntryOf: line	^self obj: line at: GBWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierEntryOf: line put: value	^self obj: line at: GBWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierExitOf: line	^self obj: line at: GBWideExit! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierExitOf: line put: value	^self obj: line at: GBWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierExtentOf: bezier	^self obj: bezier at: GBWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierExtentOf: bezier put: value	^self obj: bezier at: GBWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:19'!wideBezierFillOf: bezier	^self obj: bezier at: GBWideFill! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!wideBezierFillOf: bezier put: value	^self obj: bezier at: GBWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:25'!wideBezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier +  GBWideUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierWidthOf: line	^self obj: line at: GBWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierWidthOf: line put: value	^self obj: line at: GBWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:18'!gradientRampLengthOf: fill	^self obj: fill at: GFRampLength! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:17'!gradientRampLengthOf: fill put: value	^self obj: fill at: GFRampLength put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:25'!gradientRampOf: fill	self returnTypeC:'int *'.	^objBuffer + fill +  GFRampOffset! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isBezier: bezier	^((self objectTypeOf: bezier) bitAnd: GEPrimitiveWideMask) = GEPrimitiveBezier! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/8/1998 15:14'!isFillOkay: fill	self inline: false.	^(fill = 0 or:[(self isFillColor: fill) or:[((self isObject: fill) and:[self isFill: fill])]]) ! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isLine: line	^((self objectTypeOf: line) bitAnd: GEPrimitiveWideMask) = GEPrimitiveLine! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/6/1998 01:53'!isWideBezier: bezier	^(self isBezier: bezier) and:[self isWide: bezier]! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 22:08'!isWideLine: line	^(self isLine: line) and:[self isWide: line]! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:52'!stepToFirstLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstLineIn: line at: yValue	"Initialize the line at yValue"	| deltaX deltaY xDir widthX error xInc errorAdjUp startY |	self inline: false.	"Do a quick check if there is anything at all to do"	((self isWide: line) not and:[yValue >= (self lineEndYOf: line)])		ifTrue:[^self edgeNumLinesOf: line put: 0].	deltaX _ (self lineEndXOf: line) - (self edgeXValueOf: line).	deltaY _ (self lineEndYOf: line) - (self edgeYValueOf: line).	"Check if edge goes left to right"	deltaX >= 0 		ifTrue:[	xDir _ 1.				widthX _ deltaX.				error _ 0]		ifFalse:[	xDir _ -1.				widthX _ 0 - deltaX.				error _ 1 - deltaY].	"Check if deltaY is zero.	Note: We could actually get out here immediately 	but wide lines rely on an accurate setup in this case"	deltaY = 0		ifTrue:[	error _ 0.			"No error for horizontal edges"				xInc _ deltaX.		"Encodes width and direction"				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"				deltaY > widthX "Note: The '>' instead of '>=' could be important here..."					ifTrue:[	xInc _ 0.							errorAdjUp _ widthX]					ifFalse:[	xInc _ (widthX // deltaY) * xDir.							errorAdjUp _ widthX \\ deltaY]].	"Store the values"	self edgeNumLinesOf: line put: deltaY.	self lineXDirectionOf: line put: xDir.	"self lineYDirectionOf: line put: yDir." "<-- Already set"	self lineXIncrementOf: line put: xInc.	self lineErrorOf: line put: error.	self lineErrorAdjUpOf: line put: errorAdjUp.	self lineErrorAdjDownOf: line put: deltaY.	"And step to the first scan line"	(startY _ self edgeYValueOf: line) = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:53'!stepToNextLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextLineIn: line at: yValue	"Incrementally step to the next scan line in the given line"	| x  err |	self inline: true.	x _ (self edgeXValueOf: line) + (self lineXIncrementOf: line).	err _ (self lineErrorOf: line) + (self lineErrorAdjUpOf: line).	err > 0 ifTrue:[		x _ x + (self lineXDirectionOf: line).		err _ err - (self lineErrorAdjDownOf: line).	].	self lineErrorOf: line put: err.	self edgeXValueOf: line put: x.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/24/1998 23:15'!loadLine: line from: point1 to: point2 offset: yOffset leftFill: leftFill rightFill: rightFill	"Load the line defined by point1 and point2."	| p1 p2 yDir |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(point1 at: 1) <= (point2 at: 1) 		ifTrue:[	p1 _ point1.				p2 _ point2.				yDir _ 1]		ifFalse:[	p1 _ point2.				p2 _ point1.				yDir _ -1].	self edgeXValueOf: line put: (p1 at: 0).	self edgeYValueOf: line put: (p1 at: 1) - yOffset.	self edgeZValueOf: line put: self currentZGet.	self edgeLeftFillOf: line put: leftFill.	self edgeRightFillOf: line put: rightFill.	self lineEndXOf: line put: (p2 at: 0).	self lineEndYOf: line put: (p2 at: 1) - yOffset.	self lineYDirectionOf: line put: yDir.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/6/1998 17:07'!loadRectangle: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a rectangle currently defined by point1-point4"	self loadWideLine: lineWidth from: self point1Get to: self point2Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point2Get to: self point3Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point3Get to: self point4Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point4Get to: self point1Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/8/1998 19:24'!loadWideLine: lineWidth from: p1 to: p2 lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a (possibly wide) line defined by the points p1 and p2"	| line offset |	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[	line _ self allocateLine.				offset _ 0]		ifFalse:[	line _ self allocateWideLine.				offset _ self offsetFromWidth: lineWidth].	engineStopped ifTrue:[^0].	self loadLine: line 		from: p1		to: p2		offset: offset 		leftFill: leftFill		rightFill: rightFill.	(self isWide: line) ifTrue:[		self wideLineFillOf: line put: lineFill.		self wideLineWidthOf: line put: lineWidth.		self wideLineExtentOf: line put: lineWidth].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:34'!adjustWideLine: line afterSteppingFrom: lastX to: nextX	"Adjust the wide line after it has been stepped from lastX to nextX.	Special adjustments of line width and start position are made here	to simulate a rectangular brush"	|  yEntry yExit lineWidth lineOffset deltaX xDir baseWidth |	self inline: false.	"Don't inline this"	"Fetch the values the adjustment decisions are based on"	yEntry _ (self wideLineEntryOf: line).	yExit _ (self wideLineExitOf: line).	baseWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: baseWidth.	lineWidth _ self wideLineWidthOf: line.	xDir _ self lineXDirectionOf: line.	deltaX _ nextX - lastX.	"Adjust the start of the line to fill an entire rectangle"	yEntry < baseWidth ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth - deltaX] "effectively adding"			ifFalse:[	lineWidth _ lineWidth + deltaX.					self edgeXValueOf: line put: lastX].	].	"Adjust the end of x-major lines"	((yExit + lineOffset) = 0) ifTrue:[		xDir > 0			ifTrue:[lineWidth _ lineWidth - (self lineXIncrementOf: line)]			ifFalse:[lineWidth _ lineWidth + (self lineXIncrementOf: line).	"effectively subtracting"					self edgeXValueOf: line put: lastX].	].	"Adjust the end of the line to fill an entire rectangle"	(yExit + lineOffset) > 0 ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth + deltaX. "effectively subtracting"					self edgeXValueOf: line put: lastX]			ifFalse:[	lineWidth _ lineWidth - deltaX]	].	"Store the manipulated line width back"	self wideLineWidthOf: line put: lineWidth.! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineFill	"Return the fill of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineWidth	"Return the width of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:54'!stepToFirstWideLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideLineIn: line at: yValue	"Initialize the wide line at yValue."	| startY yEntry yExit lineWidth nLines lineOffset startX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the line"	startX _ self edgeXValueOf: line.	startY _ self edgeYValueOf: line.	self stepToFirstLineIn: line at: startY.	nLines _ (self edgeNumLinesOf: line).	xDir _ self lineXDirectionOf: line.	"Adjust the line to start at the correct X position"	self edgeXValueOf: line put: startX - lineOffset.	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: line put: nLines + lineWidth.	"Adjust the values for x-major lines"	xDir > 0 ifTrue:[		self wideLineWidthOf: line put: (self lineXIncrementOf: line) + lineWidth.	] ifFalse:[		self wideLineWidthOf: line put: lineWidth - (self lineXIncrementOf: line). "adding"		self edgeXValueOf: line put: (self edgeXValueOf: line) + (self lineXIncrementOf: line).	].	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: line]		ifFalse:[self edgeFillsInvalidate: line].	"And step to the first scan line"	startY = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextWideLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: (self edgeNumLinesOf: line) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:55'!stepToNextWideLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextWideLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideLineIn: line at: yValue	"Incrementally step to the next scan line in the given wide line"	|  yEntry yExit lineWidth lineOffset lastX nextX |	self inline: true.	"Adjust entry/exit values"	yEntry _ (self wideLineEntryOf: line) + 1.	yExit _ (self wideLineExitOf: line) + 1.	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn fills on/off"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: line].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: line].	"Step to the next scan line"	lastX _ self edgeXValueOf: line.	self stepToNextLineIn: line at: yValue.	nextX _ self edgeXValueOf: line.	"Check for special start/end adjustments"	(yEntry <= lineWidth or:[yExit+lineOffset >= 0]) ifTrue:[		"Yes, need an update"		self adjustWideLine: line afterSteppingFrom: lastX to: nextX.	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:56'!assureValue: val1 between: val2 and: val3	"Make sure that val1 is between val2 and val3."	self inline: true.	val2 > val3 ifTrue:[		val1 > val2 ifTrue:[^val2].		val1 < val3 ifTrue:[^val3].	] ifFalse:[		val1 < val2 ifTrue:[^val2].		val1 > val3 ifTrue:[^val3].	].	^val1	! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:57'!computeBezier: index splitAt: param	"Split the bezier curve at the given parametric value.	Note: Since this method is only invoked to make non-monoton		beziers monoton we must check for the resulting y values		to be *really* between the start and end value."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	self var: #param declareC:'double param'.	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	sharedX _ leftViaX _ leftViaX + ((viaX - startX) asFloat * param) asInteger.	sharedY _ leftViaY _ leftViaY + ((viaY - startY) asFloat * param) asInteger.	rightViaX _ rightViaX + ((endX - viaX) asFloat * param) asInteger.	rightViaY _ rightViaY + ((endY - viaY) asFloat * param) asInteger.	"Compute new shared point"	sharedX _ sharedX + ((rightViaX - leftViaX) asFloat * param) asInteger.	sharedY _ sharedY + ((rightViaY - leftViaY) asFloat * param) asInteger.	"Check the new via points"	leftViaY _ self assureValue: leftViaY between: startY and: sharedY.	rightViaY _ self assureValue: rightViaY between: sharedY and: endY.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/6/1998 01:26'!computeBezierSplitAtHalf: index	"Split the bezier curve at 0.5."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	leftViaX _ leftViaX + ((viaX - startX) // 2).	leftViaY _ leftViaY + ((viaY - startY) // 2).	sharedX _ rightViaX _ rightViaX + ((endX - viaX) // 2).	sharedY _ rightViaY _ rightViaY + ((endY - viaY) // 2).	"Compute new shared point"	sharedX _ sharedX + ((leftViaX - rightViaX) // 2).	sharedY _ sharedY + ((leftViaY - rightViaY) // 2).	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 20:15'!loadAndSubdivideBezierFrom: point1 via: point2 to: point3 isWide: wideFlag	"Load and subdivide the bezier curve from point1/point2/point3.	If wideFlag is set then make sure the curve is monoton in X."	| bz1 bz2 index2 index1 |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	bz1 _ self allocateBezierStackEntry.		engineStopped ifTrue:[^0].	"Load point1/point2/point3 on the top of the stack"	self bzStartX: bz1 put: (point1 at: 0).	self bzStartY: bz1 put: (point1 at: 1).	self bzViaX: bz1 put: (point2 at: 0).	self bzViaY: bz1 put: (point2 at: 1).	self bzEndX: bz1 put: (point3 at: 0).	self bzEndY: bz1 put: (point3 at: 1).	"Now check if the bezier curve is monoton. If not, subdivide it."	index2 _ bz2 _ self subdivideToBeMonoton: bz1 inX: wideFlag.	bz1 to: bz2 by: 6 do:[:index|		index1 _ self subdivideBezierFrom: index.		index1 > index2 ifTrue:[index2 _ index1].		engineStopped ifTrue:[^0]. "Something went wrong"	].	"Return the number of segments"	^index2 // 6! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/24/1998 23:15'!loadBezier: bezier segment: index leftFill: leftFillIndex rightFill: rightFillIndex offset: yOffset	"Initialize the bezier segment stored on the stack"	self inline: false.	(self bzEndY: index) >= (self bzStartY: index) ifTrue:[		"Top to bottom"		self edgeXValueOf: bezier put: (self bzStartX: index).		self edgeYValueOf: bezier put: (self bzStartY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzEndX: index).		self bezierEndYOf: bezier put: (self bzEndY: index) - yOffset.	] ifFalse:[		self edgeXValueOf: bezier put: (self bzEndX: index).		self edgeYValueOf: bezier put: (self bzEndY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzStartX: index).		self bezierEndYOf: bezier put: (self bzStartY: index) - yOffset.	].	self edgeZValueOf: bezier put: self currentZGet.	self edgeLeftFillOf: bezier put: leftFillIndex.	self edgeRightFillOf: bezier put: rightFillIndex.	"self debugDrawBezier: bezier."! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/25/1998 23:21'!loadOval: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a rectangular oval currently defined by point1/point2"	| w h cx cy nSegments |	self inline: false.	w _ ((self point2Get at: 0) - (self point1Get at: 0)) // 2.	h _ ((self point2Get at: 1) - (self point1Get at: 1)) // 2.	cx _ ((self point2Get at: 0) + (self point1Get at: 0)) // 2.	cy _ ((self point2Get at: 1) + (self point1Get at: 1)) // 2.	0 to: 15 do:[:i|		self loadOvalSegment: i w: w h: h cx: cx cy: cy.		self transformPoints: 3.		nSegments _ self loadAndSubdivideBezierFrom: self point1Get 							via: self point2Get to: self point3Get							isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).		engineStopped ifTrue:[^nil].		self loadWideBezier: lineWidth lineFill: lineFill 			leftFill: leftFill rightFill: rightFill n: nSegments.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!loadOvalSegment: seg w: w h: h cx: cx cy: cy	| x0 y0 x2 y2 x1 y1 |	self inline: false.	"Load start point of segment"	x0 _ ((self circleCosTable at: seg * 2 + 0) * w asFloat + cx) asInteger.	y0 _ ((self circleSinTable at: seg * 2 + 0) * h asFloat + cy) asInteger.	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	"Load end point of segment"	x2 _ ((self circleCosTable at: seg * 2 + 2) * w asFloat + cx) asInteger.	y2 _ ((self circleSinTable at: seg * 2 + 2) * h asFloat + cy) asInteger.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	"Load intermediate point of segment"	x1 _ ((self circleCosTable at: seg * 2 + 1) * w asFloat + cx) asInteger.	y1 _ ((self circleSinTable at: seg * 2 + 1) * h asFloat + cy) asInteger.	"NOTE: The intermediate point is the point ON the curve	and not yet the control point (which is OFF the curve)"	x1 _ (x1 * 2) - (x0 + x2 // 2).	y1 _ (y1 * 2) - (y0 + y2 // 2).	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:41'!loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: nSegments	"Load the (possibly wide) bezier from the segments currently on the bezier stack."	| index bezier wide offset |	self inline: false.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[wide _ false.				offset _ 0]		ifFalse:[wide _ true.				offset _ self offsetFromWidth: lineWidth].	index _ nSegments * 6.	[index > 0] whileTrue:[		wide 			ifTrue:[bezier _ self allocateWideBezier]			ifFalse:[bezier _ self allocateBezier].		engineStopped ifTrue:[^0].		self loadBezier: bezier 			segment: index 			leftFill: leftFill 			rightFill: rightFill 			offset: offset.		wide ifTrue:[			self wideBezierFillOf: bezier put: lineFill.			self wideBezierWidthOf: bezier put: lineWidth.			self wideBezierExtentOf: bezier put: lineWidth.		].		index _ index - 6.	].	self wbStackClear.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 14:36'!subdivideBezier: index	"Subdivide the given bezier curve if necessary"	| startX startY endX endY deltaX deltaY |	self inline: false.	startY _ self bzStartY: index.	endY _ self bzEndY: index.	"If the receiver is horizontal, don't do anything"	(endY = startY) ifTrue:[^index].	"TODO: If the curve can be represented as a line, then do so"	"If the height of the curve exceeds 256 pixels, subdivide 	(forward differencing is numerically not very stable)"	deltaY _ endY - startY.	deltaY < 0 ifTrue:[deltaY _ 0 - deltaY].	(deltaY > 255) ifTrue:[		self incrementStat: GWBezierHeightSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	"Check if the incremental values could possibly overflow the scaled integer range"	startX _ self bzStartX: index.	endX _ self bzEndX: index.	deltaX _ endX - startX.	deltaX < 0 ifTrue:[deltaX _ 0 - deltaX].	deltaY * 32 < deltaX ifTrue:[		self incrementStat: GWBezierOverflowSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:43'!subdivideBezierFrom: index	"Recursively subdivide the curve on the bezier stack."	| otherIndex index1 index2 |	self inline: false.	otherIndex _ self subdivideBezier: index.	otherIndex = index ifFalse:[		index1 _ self subdivideBezierFrom: index.		engineStopped ifTrue:[^0].		index2 _ self subdivideBezierFrom: otherIndex.		engineStopped ifTrue:[^0].		index1 >= index2			ifTrue:[^index1]			ifFalse:[^index2]	].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!subdivideToBeMonoton: base inX: doTestX	"Check if the given bezier curve is monoton in Y, and, if desired in X. 	If not, subdivide it"	| index1 index2 base2 |	self inline: false.	base2 _ index1 _ index2 _ self subdivideToBeMonotonInY: base.	doTestX ifTrue:[index1 _ self subdivideToBeMonotonInX: base].	index1 > index2 ifTrue:[index2 _ index1].	(base ~= base2 and:[doTestX]) ifTrue:[index1 _ self subdivideToBeMonotonInX: base2].	index1 > index2 ifTrue:[index2 _ index1].	^index2! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInX: index	"Check if the given bezier curve is monoton in X. If not, subdivide it"	| denom num startX viaX endX dx1 dx2 |	self inline: false.	startX _ self bzStartX: index.	viaX _ self bzViaX: index.	endX _ self bzEndX: index.	dx1 _ viaX - startX.	dx2 _ endX - viaX.	(dx1 * dx2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dx2 - dx1.	num _ dx1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInY: index	"Check if the given bezier curve is monoton in Y. If not, subdivide it"	| startY viaY endY dy1 dy2 denom num |	self inline: false.	startY _ self bzStartY: index.	viaY _ self bzViaY: index.	endY _ self bzEndY: index.	dy1 _ viaY - startY.	dy2 _ endY - viaY.	(dy1 * dy2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dy2 - dy1.	num _ dy1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:07'!stepToFirstBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstBezierIn: bezier at: yValue	"Initialize the bezier at yValue.	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure."	| updateData deltaY maxSteps scaledStepSize squaredStepSize 	startX startY viaX viaY endX endY 	fwX1 fwX2 fwY1 fwY2 	fwDx fwDDx fwDy fwDDy |	self inline: false. "Too many temps for useful inlining"	self var: #updateData declareC:'int *updateData'.	"Do a quick check if there is anything at all to do"	((self isWide: bezier) not and:[yValue >= (self bezierEndYOf: bezier)])		ifTrue:[^self edgeNumLinesOf: bezier put: 0].	"Now really initialize bezier"	startX _ self edgeXValueOf: bezier.	startY _ self edgeYValueOf: bezier.	viaX _ self bezierViaXOf: bezier.	viaY _ self bezierViaYOf: bezier.	endX _ self bezierEndXOf: bezier.	endY _ self bezierEndYOf: bezier.	deltaY _ endY - startY.	"Initialize integer forward differencing"	fwX1 _ (viaX - startX) * 2.	fwX2 _ startX + endX - (viaX * 2).	fwY1 _ (viaY - startY) * 2.	fwY2 _ startY + endY - (viaY * 2).	maxSteps _ deltaY * 2.	maxSteps < 2 ifTrue:[maxSteps _ 2].	scaledStepSize _ 16r1000000 // maxSteps.	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	fwDx _ fwX1 * scaledStepSize.	fwDDx _ fwX2 * squaredStepSize * 2.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwY1 * scaledStepSize.	fwDDy _ fwY2 * squaredStepSize * 2.	fwDy _ fwDy + (fwDDy // 2).	"Store the values"	self edgeNumLinesOf: bezier put: deltaY.	updateData _ self bezierUpdateDataOf: bezier.	updateData at: GBUpdateX put: (startX * 256).	updateData at: GBUpdateY put: (startY * 256).	updateData at: GBUpdateDX put: fwDx.	updateData at: GBUpdateDY put: fwDy.	updateData at: GBUpdateDDX put: fwDDx.	updateData at: GBUpdateDDY put: fwDDy.	"And step to the first scan line"	(startY _ self edgeYValueOf: bezier) = yValue ifFalse:[		self stepToNextBezierIn: bezier at: yValue.		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:08'!stepToNextBezier	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 01:49'!stepToNextBezierForward: updateData at: yValue	"Incrementally step to the next scan line in the given bezier update data.	Note: This method has been written so that inlining works, e.g.,		not declaring updateData as 'int*' but casting it on every use."	| minY lastX lastY fwDx fwDy |	self inline: true.	lastX _ (self cCoerce: updateData to: 'int*') at: GBUpdateX.	lastY _ (self cCoerce: updateData to: 'int*') at: GBUpdateY.	fwDx _ (self cCoerce: updateData to: 'int*') at: GBUpdateDX.	fwDy _ (self cCoerce: updateData to: 'int*') at: GBUpdateDY.	minY _ yValue * 256.	"Step as long as we haven't yet reached minY and also	as long as fwDy is greater than zero thus stepping down.	Note: The test for fwDy should not be necessary in theory		but is a good insurance in practice."	[minY > lastY and:[fwDy >= 0]] whileTrue:[		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDX).		fwDy _ fwDy + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDY).	].	(self cCoerce: updateData to: 'int*') at: GBUpdateX put: lastX.	(self cCoerce: updateData to: 'int*') at: GBUpdateY put: lastY.	(self cCoerce: updateData to: 'int*') at: GBUpdateDX put: fwDx.	(self cCoerce: updateData to: 'int*') at: GBUpdateDY put: fwDy.	^lastX // 256! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given bezier"	|  xValue |	self inline: true.	xValue _ self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	self edgeXValueOf: bezier put: xValue.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx < 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) - (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX + (lineWidth - lineOffset * 256).	"Set lineWidth pixels down"	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx >= 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) + (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	"Set lineWidth-lineOffset pixels left"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX - (lineWidth - lineOffset * 256).	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	"Set lineWidth pixels down"	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset + lineWidth.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 03:44'!computeFinalWideBezierValues: bezier width: lineWidth	"Get both values from the two boundaries of the given bezier 	and compute the actual position/width of the line"	| leftX rightX temp |	leftX _ ((self bezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	rightX _ ((self wideBezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	leftX > rightX ifTrue:[temp _ leftX. leftX _ rightX. rightX _ temp].	self edgeXValueOf: bezier put: leftX.	(rightX - leftX) > lineWidth ifTrue:[		self wideBezierWidthOf: bezier put: (rightX - leftX).	] ifFalse:[		self wideBezierWidthOf: bezier put: lineWidth.	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierFill	^(dispatchReturnValue _ self wideBezierFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierWidth	^(dispatchReturnValue _ self wideBezierWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:00'!stepToFirstWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideBezierIn: bezier at: yValue	"Initialize the bezier at yValue"		| lineWidth startY nLines yEntry yExit lineOffset endX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the bezier"	endX _ self bezierEndXOf: bezier.	startY _ self edgeYValueOf: bezier.	self stepToFirstBezierIn: bezier at: startY.	nLines _ (self edgeNumLinesOf: bezier).	"Copy the incremental update data"	0 to: 5 do:[:i|		(self wideBezierUpdateDataOf: bezier) at: i put:			((self bezierUpdateDataOf: bezier) at: i).	].	"Compute primary x direction of curve (e.g., 1: left to right; -1: right to left)."	xDir _ ((self bezierUpdateDataOf: bezier) at: GBUpdateDX).	xDir = 0 ifTrue:[((self bezierUpdateDataOf: bezier) at: GBUpdateDDX)].	xDir >= 0 ifTrue:[xDir _ 1] ifFalse:[xDir _ -1].	"Adjust the curve to start/end at the right position"	xDir < 0		ifTrue:[self adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX]		ifFalse:[self adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX].	"Adjust the last value for horizontal lines"	nLines = 0 ifTrue:[(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 						(self bezierFinalXOf: bezier) * 256].	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: bezier put: nLines + lineWidth.	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: bezier]		ifFalse:[self edgeFillsInvalidate: bezier].	self computeFinalWideBezierValues: bezier width: lineWidth.	"And step to the first scan line"	startY = yValue ifFalse:[		"Note: Must single step here so that entry/exit works"		startY to: yValue-1 do:[:i| self stepToNextWideBezierIn: bezier at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: (self edgeNumLinesOf: bezier) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:34'!stepToNextWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	self stepToNextWideBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given wide bezier"	|  yEntry yExit lineWidth lineOffset |	self inline: false.	"Don't inline this"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry _ (self wideBezierEntryOf: bezier) + 1.	yExit _ (self wideBezierExitOf: bezier) + 1.	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: bezier].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: bezier].	"Check if we have to step the upper curve"	(yExit + lineOffset < 0) ifTrue:[		self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	] ifFalse:[		"Adjust the last x value to the final x recorded previously"		(self bezierUpdateDataOf: bezier) at: GBUpdateX put: (self bezierFinalXOf: bezier) * 256.	].	"Step the lower curve"	self stepToNextBezierForward: (self wideBezierUpdateDataOf: bezier) at: yValue.	self computeFinalWideBezierValues: bezier width: lineWidth.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedFillIndexList: fillList max: maxIndex segments: nSegs	"Check the fill indexes in the run-length encoded fillList"	| length runLength runValue nFills fillPtr |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	length _ interpreterProxy slotSizeOf: fillList.	fillPtr _ interpreterProxy firstIndexableField: fillList.	nFills _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: fillPtr.		runValue _ self shortRunValueAt: 0 from: fillPtr.		(runValue >= 0 and:[runValue <= maxIndex]) ifFalse:[^false].		nFills _ nFills + runLength.	].	^nFills = nSegs! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/25/1998 00:42'!checkCompressedFills: indexList	"Check if the indexList (containing fill handles) is okay."	| fillPtr length fillIndex |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	"First check if the oops have the right format"	(interpreterProxy isWords: indexList) ifFalse:[^false].	"Then check the fill entries"	length _ interpreterProxy slotSizeOf: indexList.	fillPtr _ interpreterProxy firstIndexableField: indexList.	1 to: length do:[:i|		fillIndex _ fillPtr at: 0.		"Make sure the fill is okay"		(self isFillOkay: fillIndex) ifFalse:[^false].		fillPtr _ fillPtr + 1].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedLineWidths: lineWidthList segments: nSegments	"Check the run-length encoded lineWidthList matches nSegments"	| length runLength nItems ptr |	self inline: false.	self var: #ptr declareC:'int *ptr'.	length _ interpreterProxy slotSizeOf: lineWidthList.	ptr _ interpreterProxy firstIndexableField: lineWidthList.	nItems _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: ptr.		nItems _ nItems + runLength.	].	^nItems = nSegments! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 15:19'!checkCompressedPoints: points segments: nSegments	"Check if the given point array can be handled by the engine."	| pSize |	self inline: false.	(interpreterProxy isWords: points) ifFalse:[^false].	pSize _ interpreterProxy slotSizeOf: points.	"The points must be either in PointArray format or ShortPointArray format.	Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either		pSize = nSegments * 3,		for ShortPointArrays or,		pSize = nSegments * 6,		for PointArrays"	(pSize = (nSegments * 3) or:[pSize = (nSegments * 6)]) 		ifFalse:[^false]. "Can't handle this"	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/12/1998 21:22'!checkCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	"Check if the given shape can be handled by the engine. 	Since there are a number of requirements this is an extra method."	| maxFillIndex |	self inline: false.	(self checkCompressedPoints: points segments: nSegments) 		ifFalse:[^false].	(self checkCompressedFills: fillIndexList)		ifFalse:[^false].	maxFillIndex _ interpreterProxy slotSizeOf: fillIndexList.	(self checkCompressedFillIndexList: leftFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: rightFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: lineFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedLineWidths: lineWidths segments: nSegments)		ifFalse:[^false].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/24/1998 21:13'!loadCompressedSegment: segmentIndex from: points short: pointsShort leftFill: leftFill rightFill: rightFill lineWidth: lineWidth lineColor: lineFill 	"Load the compressed segment identified by segment index"	| x0 y0 x1 y1 x2 y2 index segs |	self inline: true.	"Check if have anything to do at all"	(leftFill = rightFill and:[lineWidth = 0 or:[lineFill = 0]]) 		ifTrue:[^nil]. "Nothing to do"	index _ segmentIndex * 6. "3 points with x/y each"	pointsShort ifTrue:["Load short points"		x0 _ self loadPointShortAt: (index+0) from: points.		y0 _ self loadPointShortAt: (index+1) from: points.		x1 _ self loadPointShortAt: (index+2) from: points.		y1 _ self loadPointShortAt: (index+3) from: points.		x2 _ self loadPointShortAt: (index+4) from: points.		y2 _ self loadPointShortAt: (index+5) from: points.	] ifFalse:[		x0 _ self loadPointIntAt: (index+0) from: points.		y0 _ self loadPointIntAt: (index+1) from: points.		x1 _ self loadPointIntAt: (index+2) from: points.		y1 _ self loadPointIntAt: (index+3) from: points.		x2 _ self loadPointIntAt: (index+4) from: points.		y2 _ self loadPointIntAt: (index+5) from: points.	].	"Briefly check if can represent the bezier as a line"	((x0 = x1 and:[y0 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[		"We can use a line from x0/y0 to x2/y2"		(x0 = x2 and:[y0 = y2]) ifTrue:[^nil]. "Nothing to do"		"Load and transform points"		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x2.		self point2Get at: 1 put: y2.		self transformPoints: 2.		^self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: leftFill 			rightFill: rightFill.	].	"Need bezier curve"	"Load and transform points"	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	self transformPoints: 3.	segs _ self loadAndSubdivideBezierFrom: self point1Get 				via: self point2Get 				to: self point3Get 				isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).	engineStopped ifTrue:[^nil].	self loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: segs.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/25/1998 00:28'!loadCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList pointShort: pointsShort	"Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!!!!!	"	| leftRun rightRun widthRun lineFillRun	leftLength rightLength widthLength lineFillLength	leftValue rightValue widthValue lineFillValue |	self inline: false. "Don't you!!!!!!!!"	self var: #points declareC:'int *points'.	self var: #leftFills declareC:'int *leftFills'.	self var: #rightFills declareC:'int *rightFills'.	self var: #lineWidths declareC:'int *lineWidths'.	self var: #lineFills declareC:'int *lineFills'.	self var: #fillIndexList declareC:'int *fillIndexList'.	nSegments = 0 ifTrue:[^0].	"Initialize run length encodings"	leftRun _  rightRun _ widthRun _ lineFillRun _ -1.	leftLength _ rightLength _ widthLength _ lineFillLength _ 1.	leftValue _ rightValue _ widthValue _ lineFillValue _ 0.	1 to: nSegments do:[:i|		"Decrement current run length and load new stuff"		(leftLength _ leftLength - 1) <= 0 ifTrue:[			leftRun _ leftRun + 1.			leftLength _ self shortRunLengthAt: leftRun from: leftFills.			leftValue _ self shortRunValueAt: leftRun from: leftFills.			leftValue = 0 ifFalse:[				leftValue _ fillIndexList at: leftValue-1.				leftValue _ self transformColor: leftValue.				engineStopped ifTrue:[^nil]]].		(rightLength _ rightLength - 1) <= 0 ifTrue:[			rightRun _ rightRun + 1.			rightLength _ self shortRunLengthAt: rightRun from: rightFills.			rightValue _ self shortRunValueAt: rightRun from: rightFills.			rightValue = 0 ifFalse:[				rightValue _ fillIndexList at: rightValue-1.				rightValue _ self transformColor: rightValue]].		(widthLength _ widthLength - 1) <= 0 ifTrue:[			widthRun _ widthRun + 1.			widthLength _ self shortRunLengthAt: widthRun from: lineWidths.			widthValue _ self shortRunValueAt: widthRun from: lineWidths.			widthValue = 0 ifFalse:[widthValue _ self transformWidth: widthValue]].		(lineFillLength _ lineFillLength - 1) <= 0 ifTrue:[			lineFillRun _ lineFillRun + 1.			lineFillLength _ self shortRunLengthAt: lineFillRun from: lineFills.			lineFillValue _ self shortRunValueAt: lineFillRun from: lineFills.			lineFillValue = 0 ifFalse:[lineFillValue _ fillIndexList at: lineFillValue-1]].		self loadCompressedSegment: i - 1			from: points 			short: pointsShort 			leftFill: leftValue 			rightFill: rightValue 			lineWidth: widthValue 			lineColor: lineFillValue.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:09'!loadArrayPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill	| x0 y0 x1 y1 |	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: points).	interpreterProxy failed ifTrue:[^nil].	x0 _ self point1Get at: 0.	y0 _ self point1Get at: 1.	1 to: nPoints-1 do:[:i|		self loadPoint: self point1Get from: (interpreterProxy fetchPointer: i ofObject: points).		interpreterProxy failed ifTrue:[^nil].		x1 _ self point1Get at: 0.		y1 _ self point1Get at: 1.		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:14'!loadArrayShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill 	| pointOop x0 y0 x1 y1 x2 y2 segs |	self inline: false.	0 to: nSegments-1 do:[:i|		pointOop _ interpreterProxy fetchPointer: (i * 3) ofObject: points.		self loadPoint: self point1Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 1) ofObject: points.		self loadPoint: self point2Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 2) ofObject: points.		self loadPoint: self point3Get from: pointOop.		interpreterProxy failed ifTrue:[^nil].		self transformPoints: 3.		x0 _ self point1Get at: 0.		y0 _ self point1Get at: 1.		x1 _ self point2Get at: 0.		y1 _ self point2Get at: 1.		x2 _ self point3Get at: 0.		y2 _ self point3Get at: 1.		"Check if we can use a line"		((x0 = y0 and:[x1 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[			self loadWideLine: lineWidth				from: self point1Get				to: self point3Get				lineFill: lineFill				leftFill: fillIndex				rightFill: 0.		] ifFalse:["Need bezier"			segs _ self loadAndSubdivideBezierFrom: self point1Get					via: self point2Get					to: self point3Get					isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).			engineStopped ifTrue:[^nil].			self loadWideBezier: lineWidth				lineFill: lineFill				leftFill: fillIndex				rightFill: 0				n: segs.		].		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:10'!loadPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill pointsShort: isShort	| x0 y0 x1 y1 |	self var:#points declareC:'int *points'.	isShort ifTrue:[		x0 _ self loadPointShortAt: 0 from: points.		y0 _ self loadPointShortAt: 1 from: points.	] ifFalse:[		x0 _ self loadPointIntAt: 0 from: points.		y0 _ self loadPointIntAt: 1 from: points.	].	1 to: nPoints-1 do:[:i|		isShort ifTrue:[			x1 _ self loadPointShortAt: i*2 from: points.			y1 _ self loadPointShortAt: i*2+1 from: points.		] ifFalse:[			x1 _ self loadPointIntAt: i*2 from: points.			y1 _ self loadPointIntAt: i*2+1 from: points.		].		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 21:14'!loadShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  pointsShort: pointsShort	self inline: false.	self var:#points declareC:'int *points'.	1 to: nSegments do:[:i|		self loadCompressedSegment: i-1			from: points			short: pointsShort			leftFill: fillIndex			rightFill: 0			lineWidth: lineWidth			lineColor: lineFill.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillLinearGradient	self inline: true.	^self fillLinearGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 21:50'!fillLinearGradient: fill from: leftX to: rightX at: yValue	"Draw a linear gradient fill."	| x0 x1 ramp rampSize dsX ds x rampIndex |	self inline: false.	self var: #ramp declareC:'int *ramp'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	dsX _ self fillDirectionXOf: fill.	ds _ ((leftX - (self fillOriginXOf: fill)) * dsX) + 			((yValue - (self fillOriginYOf: fill)) * (self fillDirectionYOf: fill)).	x _ x0 _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	[(rampIndex _ ds // 16r10000) < 0 and:[x < x1]] 		whileTrue:[	x _ x + 1.					ds _ ds + dsX].	x > x0 ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: 0)) from: x0 to: x].	"Part two: Fill everything inside the boundaries"	self aaLevelGet = 1 ifTrue:[		"Fast version w/o anti-aliasing"		[((rampIndex _ ds // 16r10000) < rampSize and:[rampIndex >= 0]) and:[x < x1]] whileTrue:[			spanBuffer at: x put: (self makeUnsignedFrom: (ramp at: rampIndex)).			x _ x + 1.			ds _ ds + dsX.		].	] ifFalse:[x _ self fillLinearGradientAA: fill ramp: ramp ds: ds dsX: dsX from: x to: rightX].	"Part three fill everything outside right boundary"	x < x1 ifTrue:[		rampIndex < 0 ifTrue:[rampIndex _ 0].		rampIndex >= rampSize ifTrue:[rampIndex _ rampSize-1].		self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampIndex)) from: x to: x1].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 17:18'!fillLinearGradientAA: fill ramp: ramp ds: deltaS dsX: dsX from: leftX to: rightX	"This is the AA version of linear gradient filling."	| colorMask colorShift baseShift rampIndex ds rampSize x idx rampValue 	 aaLevel firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampSize _ self gradientRampLengthOf: fill.	ds _ deltaS.	x _ leftX.	rampIndex _ ds // 16r10000.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < firstPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < firstPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	"Deal with the full pixels"	colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.	colorShift _ self aaShiftGet.	[x < lastPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < lastPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + aaLevel.			ds _ ds + (dsX << colorShift)].		rampIndex _ ds // 16r10000.	].	"Deal with the last n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < rightX and:[rampIndex < rampSize and:[rampIndex>=0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < rightX and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialDecreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ rightX.	x1 > (self fillOriginXOf: fill) ifTrue:[x1 _ self fillOriginXOf: fill].	[x < x1] whileTrue:[		"Try to copy the current value more than just once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		"Step to next ramp value"		nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[nextLength < length2] whileTrue:[			rampIndex _ rampIndex - 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			length2 _ (rampIndex-1) * (rampIndex-1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength x1	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ self fillOriginXOf: fill.	x1 > rightX ifTrue:[x1 _ rightX].	firstPixel _ self aaFirstPixelFrom: leftX to: x1.	lastPixel _ self aaLastPixelFrom: leftX to: x1.	"Deal with the first n sub-pixels"	(x < firstPixel) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the full pixels"	(x < lastPixel) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the last n sub-pixels"	(x < x1) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < x1] whileTrue:[			"Try to copy the current value more than just once"			[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillRadialGradient	self inline: true.	^self fillRadialGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialGradient: fill from: leftX to: rightX at: yValue	"Draw a radial gradient fill."	| x x1 ramp rampSize dsX ds dtX dt length2 deltaX deltaY deltaST |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:'int *deltaST'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	deltaX _ leftX - (self fillOriginXOf: fill).	deltaY _ yValue - (self fillOriginYOf: fill).	dsX _ self fillDirectionXOf: fill.	dtX _ self fillNormalXOf: fill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: fill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: fill)).	x _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	[(self squaredLengthOf: ds // 16r10000 with: dt // 16r10000) >= length2 and:[x < x1]]		whileTrue:[	x _ x + 1.	ds _ ds + dsX.	dt _ dt + dtX].	x > leftX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: leftX to: x].	"Part two: Fill everything inside the boundaries"	deltaST _ self point1Get.	deltaST at: 0 put: ds.	deltaST at: 1 put: dt.	(x < (self fillOriginXOf: fill)) ifTrue:[		"Draw the decreasing part"		self aaLevelGet = 1 			ifTrue:[x _ self fillRadialDecreasing: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1].	].	x < x1 ifTrue:[		"Draw the increasing part"		self aaLevelGet = 1			ifTrue:[x _ self fillRadialIncreasing: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1].	].	"Part three fill everything outside right boundary"	x < rightX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: x to: rightX].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 01:21'!fillRadialIncreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength rampSize lastLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	x1 _ rightX.	[x < x1 and:[lastLength < length2]] whileTrue:[		"Try to copy the current value more than once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[lastLength > nextLength] whileTrue:[			rampIndex _ rampIndex + 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			nextLength _ (rampIndex+1) * (rampIndex+1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 16:09'!fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength rampSize lastLength 	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n subPixels"	(x < firstPixel and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with the full pixels"	(x < lastPixel and:[lastLength < length2]) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with last n sub-pixels"	(x < rightX and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < rightX and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < rightX and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/27/1998 13:36'!loadFillOrientation: fill from: point1 along: point2 normal: point3 width: fillWidth height: fillHeight	"Transform the points"	| dirX dirY nrmX nrmY dsLength2 dsX dsY dtLength2 dtX dtY |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	point2 at: 0 put: (point2 at: 0) + (point1 at: 0).	point2 at: 1 put: (point2 at: 1) + (point1 at: 1).	point3 at: 0 put: (point3 at: 0) + (point1 at: 0).	point3 at: 1 put: (point3 at: 1) + (point1 at: 1).	self transformPoint: point1.	self transformPoint: point2.	self transformPoint: point3.	dirX _ (point2 at: 0) - (point1 at: 0).	dirY _ (point2 at: 1) - (point1 at: 1).	nrmX _ (point3 at: 0) - (point1 at: 0).	nrmY _ (point3 at: 1) - (point1 at: 1).	"Compute the scale from direction/normal into ramp size"	dsLength2 _ (dirX * dirX) + (dirY * dirY).	dsLength2 > 0 ifTrue:[		dsX _ (dirX asFloat * fillWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		dsY _ (dirY asFloat * fillWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.	] ifFalse:[ dsX _ 0. dsY _ 0].	dtLength2 _ (nrmX * nrmX) + (nrmY * nrmY).	dtLength2 > 0 ifTrue:[		dtX _ (nrmX asFloat * fillHeight asFloat * 65536.0 / dtLength2 asFloat) asInteger.		dtY _ (nrmY asFloat * fillHeight asFloat * 65536.0 / dtLength2 asFloat) asInteger.	] ifFalse:[dtX _ 0. dtY _ 0].	self fillOriginXOf: fill put: (point1 at: 0).	self fillOriginYOf: fill put: (point1 at: 1).	self fillDirectionXOf: fill put: dsX.	self fillDirectionYOf: fill put: dsY.	self fillNormalXOf: fill put: dtX.	self fillNormalYOf: fill put: dtY.! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/25/1998 16:44'!loadGradientFill: rampOop from: point1 along: point2 normal: point3 isRadial: isRadial	"Load the gradient fill as defined by the color ramp."	| rampWidth fill |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	(interpreterProxy fetchClassOf: rampOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	rampWidth _ interpreterProxy slotSizeOf: rampOop.	fill _ self allocateGradientFill: (interpreterProxy firstIndexableField: rampOop)				rampWidth: rampWidth isRadial: isRadial.	engineStopped ifTrue:[^nil].	self loadFillOrientation: fill 		from: point1 along: point2 normal: point3 		width: rampWidth height: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:38'!allocateBezier	| bezier |	(self allocateObjEntry: GBBaseSize) ifFalse:[^0].	bezier _ objUsed.	objUsed _ bezier + GBBaseSize.	self objectTypeOf: bezier put: GEPrimitiveBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBBaseSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 10/30/1998 20:52'!allocateBezierStackEntry	self wbStackPush: 6.	^self wbStackSize! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 16:40'!allocateBitmapFill: cmSize colormap: cmBits	| fill fillSize cm |	self var:#cm declareC:'int *cm'.	self var:#cmBits declareC:'int *cmBits'.	fillSize _ GBMBaseSize + cmSize.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ objUsed.	objUsed _ fill + fillSize.	self objectTypeOf: fill put: GEPrimitiveClippedBitmapFill.	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	cm _ self colormapOf: fill.	self hasColorTransform ifTrue:[		0 to: cmSize-1 do:[:i| cm at: i put: (self transformColor: (cmBits at: i))].	] ifFalse:[		0 to: cmSize-1 do:[:i| cm at: i put: (cmBits at: i)].	].	self bitmapCmSizeOf: fill put: cmSize.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:38'!allocateGradientFill: ramp rampWidth: rampWidth isRadial: isRadial	| fill fillSize rampPtr |	self var:#ramp declareC:'int *ramp'.	self var:#rampPtr declareC:'int *rampPtr'.	fillSize _ GGBaseSize + rampWidth.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ objUsed.	objUsed _ fill + fillSize.	isRadial		ifTrue:[self objectTypeOf: fill put: GEPrimitiveRadialGradientFill]		ifFalse:[self objectTypeOf: fill put: GEPrimitiveLinearGradientFill].	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	rampPtr _ self gradientRampOf: fill.	self hasColorTransform ifTrue:[		0 to: rampWidth-1 do:[:i| rampPtr at: i put: (self transformColor: (ramp at: i))].	] ifFalse:[		0 to: rampWidth-1 do:[:i| rampPtr at: i put: (ramp at: i)].	].	self gradientRampLengthOf: fill put: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateLine	| line |	(self allocateObjEntry: GLBaseSize) ifFalse:[^0].	line _ objUsed.	objUsed _ line + GLBaseSize.	self objectTypeOf: line put: GEPrimitiveLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLBaseSize.	^line! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateWideBezier	| bezier |	(self allocateObjEntry: GBWideSize) ifFalse:[^0].	bezier _ objUsed.	objUsed _ bezier + GBWideSize.	self objectTypeOf: bezier put: GEPrimitiveWideBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBWideSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateWideLine	| line |	(self allocateObjEntry: GLWideSize) ifFalse:[^0].	line _ objUsed.	objUsed _ line + GLWideSize.	self objectTypeOf: line put: GEPrimitiveWideLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLWideSize.	^line! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddBezierToGET: bezier	"Add the bezier to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: bezier) 		ifTrue:[lineWidth _ (self wideBezierExtentOf: bezier)]		ifFalse:[lineWidth _ 0].	(self bezierEndYOf: bezier) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: bezier) - lineWidth >= self fillMaxXGet and:[		(self bezierEndXOf: bezier) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: bezier.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddEdgeToGET: edge	"Add the edge to the global edge table.	For known edge types, check if the edge intersects the visible region"	self inline: true.	(self isLine: edge) ifTrue:[^self checkedAddLineToGET: edge].	(self isBezier: edge) ifTrue:[^self checkedAddBezierToGET: edge].	self addEdgeToGET: edge.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddLineToGET: line	"Add the line to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: line) 		ifTrue:[lineWidth _ (self wideLineExtentOf: line)]		ifFalse:[lineWidth _ 0].	(self lineEndYOf: line) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: line) - lineWidth >= self fillMaxXGet and:[		(self lineEndXOf: line) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: line.! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 10/30/1998 20:02'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| word1 word2 |	self inline: true.	word1 _ value bitAnd: 16rFFFF.	word2 _ (value bitShift: -16) bitAnd: 255.	^(( (self cCoerce: (word1 * word1) to:'unsigned') bitShift: -16) +		((word1 * word2) * 2) +			((word2 * word2) bitShift: 16)) bitShift: -8! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleCosTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,		1.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleSinTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		 0.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:24'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(self cCoerce: intArray to: 'int *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:23'!loadPointShortAt: index from: shortArray	"Load the short value from the given index in shortArray"	self returnTypeC:'short'.	^(self cCoerce: shortArray to: 'short *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 03:16'!makeRectFromPoints	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/6/1998 17:55'!offsetFromWidth: lineWidth	"Common function so that we don't compute that wrong in any place	and can easily find all the places where we deal with one-pixel offsets."	self inline: true.	^lineWidth // 2! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/25/1998 19:27'!rShiftTable	| theTable |	self returnTypeC:'int *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static int theTable[17] =		{0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1}'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:55'!shortRunLengthAt: i from: runArray	"Return the run-length value from the given ShortRunArray."	^((self cCoerce: runArray to:'int *') at: i) bitShift: - 16! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:54'!shortRunValueAt: i from: runArray	"Return the run-length value from the given ShortRunArray.	Note: We don't need any coercion to short/int here, since	we deal basically only with unsigned values."	^(((self cCoerce: runArray to:'int *') at: i) bitAnd: 16rFFFF)! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionXOf: fill	^self obj: fill at: GFDirectionX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionXOf: fill put: value	^self obj: fill at: GFDirectionX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:19'!fillDirectionYOf: fill	^self obj: fill at: GFDirectionY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionYOf: fill put: value	^self obj: fill at: GFDirectionY put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalXOf: fill	^self obj: fill at: GFNormalX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalXOf: fill put: value	^self obj: fill at: GFNormalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalYOf: fill	^self obj: fill at: GFNormalY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:16'!fillNormalYOf: fill put: value	^self obj: fill at: GFNormalY put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginXOf: fill	^self obj: fill at: GFOriginX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginXOf: fill put: value	^self obj: fill at: GFOriginX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginYOf: fill	^self obj: fill at: GFOriginY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillOriginYOf: fill put: value	^self obj: fill at: GFOriginY put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:20'!bitmapCmSizeOf: bmFill	^self obj: bmFill at: GBColormapSize! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:19'!bitmapCmSizeOf: bmFill put: value	^self obj: bmFill at: GBColormapSize put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapDepthOf: bmFill	^self obj: bmFill at: GBBitmapDepth! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:20'!bitmapDepthOf: bmFill put: value	^self obj: bmFill at: GBBitmapDepth put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapHeightOf: bmFill	^self obj: bmFill at: GBBitmapHeight! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapHeightOf: bmFill put: value	^self obj: bmFill at: GBBitmapHeight put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapRasterOf: bmFill	^self obj: bmFill at: GBBitmapRaster! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapRasterOf: bmFill put: value	^self obj: bmFill at: GBBitmapRaster put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:19'!bitmapSizeOf: bmFill	^self obj: bmFill at: GBBitmapSize! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapSizeOf: bmFill put: value	^self obj: bmFill at: GBBitmapSize put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/27/1998 14:20'!bitmapTileFlagOf: bmFill	^self obj: bmFill at: GBTileFlag! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/27/1998 14:20'!bitmapTileFlagOf: bmFill put: value	^self obj: bmFill at: GBTileFlag put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapWidthOf: bmFill	^self obj: bmFill at: GBBitmapWidth! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapWidthOf: bmFill put: value	^self obj: bmFill at: GBBitmapWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/25/1998 16:39'!colormapOf: bmFill	self returnTypeC:'int *'.	^objBuffer + bmFill + GBColormapOffset! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 21:33'!bitmapValue: bmFill bits: bits atX: xp y: yp	| bmDepth bmRaster value rShift cMask r g b a |	self inline: true.	bmDepth _ self bitmapDepthOf: bmFill.	bmRaster _ self bitmapRasterOf: bmFill.	bmDepth = 32 ifTrue:[		value _ (self cCoerce: bits to:'int*') at: (bmRaster * yp) + xp.		(value ~= 0 and:[(value bitAnd: 16rFF000000) = 0])				ifTrue:[value _ value bitOr: 16rFF000000].		^self uncheckedTransformColor: value].	"rShift - shift value to convert from pixel to word index"	rShift _ self rShiftTable at: bmDepth.	value _ self makeUnsignedFrom: 		((self cCoerce: bits to:'int*') at: (bmRaster * yp) + (xp >> rShift)).	"cMask - mask out the pixel from the word"	cMask _ (1 << bmDepth) - 1.	"rShift - shift value to move the pixel in the word to the lowest bit position"	rShift _ 32 - bmDepth - ((xp bitAnd: (1 << rShift - 1)) * bmDepth).	value _ (value >> rShift) bitAnd: cMask.	bmDepth = 16 ifTrue:[		"Must convert by expanding bits"		value = 0 ifFalse:[			b _ (value bitAnd: 31) << 3.		b _ b + (b >> 5).			g _ (value >> 5 bitAnd: 31) << 3.	g _ g + (g >> 5).			r _ (value >> 10 bitAnd: 31) << 3.	r _ r + (r >> 5).			a _ 255.			value _ b + (g << 8) + (r << 16) + (a << 24)].	] ifFalse:[		"Must convert by using color map"		(self bitmapCmSizeOf: bmFill) = 0			ifTrue:[value _ 0]			ifFalse:[value _ self makeUnsignedFrom: ((self colormapOf: bmFill) at: value)].	].	^self uncheckedTransformColor: value.! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:19'!clampValue: value max: maxValue	self inline: true.	value < 0 		ifTrue:[^0]		ifFalse:[value >= maxValue 					ifTrue:[^maxValue-1]					ifFalse:[^value]]! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 19:46'!fillBitmapSpan	self inline: true.	^self fillBitmapSpan: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:23'!fillBitmapSpan: bmFill from: leftX to: rightX at: yValue	| x x1 dsX ds dtX dt deltaX deltaY bits xp yp bmWidth bmHeight fillValue tileFlag |	self inline: false.	self var: #bits declareC:'int *bits'.	self aaLevelGet = 1		ifFalse:[^self fillBitmapSpanAA: bmFill from: leftX to: rightX at: yValue].	bits _ self loadBitsFrom: bmFill.	bits == nil ifTrue:[^nil].	bmWidth _ self bitmapWidthOf: bmFill.	bmHeight _ self bitmapHeightOf: bmFill.	tileFlag _ (self bitmapTileFlagOf: bmFill) = 1.	deltaX _ leftX - (self fillOriginXOf: bmFill).	deltaY _ yValue - (self fillOriginYOf: bmFill).	dsX _ self fillDirectionXOf: bmFill.	dtX _ self fillNormalXOf: bmFill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: bmFill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: bmFill)).	x _ leftX.	x1 _ rightX.	[x < x1] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			spanBuffer at: x put: fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:23'!fillBitmapSpanAA: bmFill from: leftX to: rightX at: yValue	| x dsX ds dtX dt deltaX deltaY bits xp yp bmWidth bmHeight fillValue baseShift cMask cShift idx aaLevel firstPixel lastPixel tileFlag |	self inline: false.	self var: #bits declareC:'int *bits'.	bits _ self loadBitsFrom: bmFill.	bits == nil ifTrue:[^nil].	bmWidth _ self bitmapWidthOf: bmFill.	bmHeight _ self bitmapHeightOf: bmFill.	tileFlag _ (self bitmapTileFlagOf: bmFill) = 1.	deltaX _ leftX - (self fillOriginXOf: bmFill).	deltaY _ yValue - (self fillOriginYOf: bmFill).	dsX _ self fillDirectionXOf: bmFill.	dtX _ self fillNormalXOf: bmFill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: bmFill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: bmFill)).	aaLevel _ self aaLevelGet.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	baseShift _ self aaShiftGet.	cMask _ self aaColorMaskGet.	cShift _ self aaColorShiftGet.	x _ leftX.	[x < firstPixel] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].	cMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.	cShift _ self aaShiftGet.	[x < lastPixel] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + (dsX << cShift).		dt _ dt + (dtX << cShift).		x _ x + aaLevel.	].	cMask _ self aaColorMaskGet.	cShift _ self aaColorShiftGet.	[x < rightX] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:24'!loadBitmapFill: formOop colormap: cmOop tile: tileFlag from: point1 along: point2 normal: point3 xIndex: xIndex	"Load the bitmap fill."	| bmFill cmSize cmBits bmBits bmBitsSize bmWidth bmHeight bmDepth ppw bmRaster |	self var: #cmBits declareC:'int *cmBits'.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	cmOop == interpreterProxy nilObject ifTrue:[		cmSize _ 0.		cmBits _ nil.	] ifFalse:[		(interpreterProxy fetchClassOf: cmOop) == interpreterProxy classBitmap			ifFalse:[^interpreterProxy primitiveFail].		cmSize _ interpreterProxy slotSizeOf: cmOop.		cmBits _ interpreterProxy firstIndexableField: cmOop.	].	(interpreterProxy isIntegerObject: formOop) 		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: formOop) 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: formOop) < 5 		ifTrue:[^interpreterProxy primitiveFail].	bmBits _ interpreterProxy fetchPointer: 0 ofObject: formOop.	(interpreterProxy fetchClassOf: bmBits) == interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	bmBitsSize _ interpreterProxy slotSizeOf: bmBits.	bmWidth _ interpreterProxy fetchInteger: 1 ofObject: formOop.	bmHeight _ interpreterProxy fetchInteger: 2 ofObject: formOop.	bmDepth _ interpreterProxy fetchInteger: 3 ofObject: formOop.	interpreterProxy failed ifTrue:[^nil].	(bmWidth >= 0 and:[bmHeight >= 0]) ifFalse:[^interpreterProxy primitiveFail].	(bmDepth = 32) | (bmDepth = 8) | (bmDepth = 16) | 		(bmDepth = 1) | (bmDepth = 2) | (bmDepth = 4)			ifFalse:[^interpreterProxy primitiveFail].	(cmSize = 0 or:[cmSize = (1 << bmDepth)])		ifFalse:[^interpreterProxy primitiveFail].	ppw _ 32 // bmDepth.	bmRaster _ bmWidth + (ppw-1) // ppw.	bmBitsSize = (bmRaster * bmHeight)		ifFalse:[^interpreterProxy primitiveFail].	bmFill _ self allocateBitmapFill: cmSize colormap: cmBits.	engineStopped ifTrue:[^nil].	self bitmapWidthOf: bmFill put: bmWidth.	self bitmapHeightOf: bmFill put: bmHeight.	self bitmapDepthOf: bmFill put: bmDepth.	self bitmapRasterOf: bmFill put: bmRaster.	self bitmapSizeOf: bmFill put: bmBitsSize.	self bitmapTileFlagOf: bmFill put: tileFlag.	self objectIndexOf: bmFill put: xIndex.	self loadFillOrientation: bmFill		from: point1 along: point2 normal: point3		width: bmWidth height: bmHeight.	^bmFill! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 17:25'!loadBitsFrom: bmFill	"Note: Assumes that the contents of formArray has been checked before"	| xIndex formOop bitsOop bitsLen |	self returnTypeC:'int *'.	xIndex _ self objectIndexOf: bmFill.	xIndex > (interpreterProxy slotSizeOf: formArray) ifTrue:[^nil].	formOop _ interpreterProxy fetchPointer: xIndex ofObject: formArray.	bitsOop _ interpreterProxy fetchPointer: 0 ofObject: formOop.	bitsLen _ interpreterProxy slotSizeOf: bitsOop.	bitsLen = (self bitmapSizeOf: bmFill) ifFalse:[^nil].	^interpreterProxy firstIndexableField: bitsOop! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:14'!repeatValue: delta max: maxValue	| newDelta |	self inline: true.	newDelta _ delta.	[newDelta < 0] whileTrue:[newDelta _ newDelta + maxValue].	[newDelta >= maxValue] whileTrue:[newDelta _ newDelta - maxValue].	^newDelta! !!BalloonEnginePlugin class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:01'!declareCVarsIn: cg	"Nothing to declare"! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 20:46'!assert: bool	bool ifFalse:[^self error:'Assertion failed'].! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleCosTable	^CArrayAccessor on:#(1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 0.1950903220161282 0.38268343236509 0.555570233019602 0.707106781186547 0.831469612302545 0.9238795325112865 0.98078528040323 1.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleSinTable	^CArrayAccessor on:#(0.0 0.1950903220161282 0.3826834323650897 0.555570233019602 0.707106781186547 0.831469612302545 0.923879532511287 0.98078528040323 1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/24/1998 20:50'!colorTransform	^super colorTransform asPluggableAccessor:		(Array 			with:[:obj :index| obj floatAt: index]			with:[:obj :index :value| obj floatAt: index put: value])! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 13:32'!copyBitsFrom: x0 to: x1 at: y	bbObj copyBitsFrom: x0 to: x1 at: y.! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 18:44'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	self perform: (selectorArray at: (anInteger + 1)).! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/24/1998 20:50'!edgeTransform	^super edgeTransform asPluggableAccessor:		(Array 			with:[:obj :index| obj floatAt: index]			with:[:obj :index :value| obj floatAt: index put: value])! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 19:19'!ioMicroMSecs	^Time millisecondClockValue! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!loadBitBltFrom: oop	bbObj _ oop.	^true! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:05'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:04'!loadPointShortAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!makeUnsignedFrom: integer	integer < 0 		ifTrue:[^(0 - integer - 1) bitInvert32]		ifFalse:[^integer]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/25/1998 19:24'!rShiftTable	^CArrayAccessor on: #(0 5 4 0 3 0 0 0 2 0 0 0 0 0 0 0 1).! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:54'!shortRunLengthAt: i from: runArray	^runArray getObject lengthAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:55'!shortRunValueAt: i from: runArray	^runArray getObject valueAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/31/1998 23:07'!showDisplayBits	"Do nothing."! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 19:51'!smallSqrtTable	"Return a lookup table for rounded integer square root values from 0 to 31"	^CArrayAccessor on:#(0 1 1 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/25/1998 02:23'!stopBecauseOf: stopReason	"Don't stop because of need to flush."	stopReason = GErrorNeedFlush ifFalse:[		^super stopBecauseOf: stopReason.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawBezier: line	| canvas p1 p2 p3 |	self assert:(self isBezier: line).	p1 _ (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet.	p2 _ (self bezierViaXOf: line) @ (self bezierViaYOf: line) // self aaLevelGet.	p3 _ (self bezierEndXOf: line) @ (self bezierEndYOf: line) // self aaLevelGet.	canvas _ FormCanvas on: Display.	canvas		line: p1 to: p2 width: 2 color: Color blue;		line: p2 to: p3 width: 2 color: Color blue.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:16'!debugDrawEdge: edge	self assert: (self isEdge: edge).	(self isLine: edge) ifTrue:[^self debugDrawLine: edge].	(self isBezier: edge) ifTrue:[^self debugDrawBezier: edge].	self halt.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 13:26'!debugDrawHLine: yValue	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: 0 @ (yValue // self aaLevelGet)		to: Display extent x @ (yValue // self aaLevelGet)		width: 2		color: Color green.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawLine: line	| canvas |	self assert: (self isLine: line).	canvas _ FormCanvas on: Display.	canvas		line: (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet		to: (self lineEndXOf: line) @ (self lineEndYOf: line) // self aaLevelGet		width: 2		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 00:17'!debugDrawLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: (pt1 at: 0) @ (pt1 at: 1) // self aaLevelGet		to: (pt2 at: 0) @ (pt2 at: 1) // self aaLevelGet		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:31'!debugDrawPt: pt	| canvas |	canvas _ FormCanvas on: Display.	canvas		fillRectangle:((pt-2) corner: pt+2) color: Color red! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:24'!debugDrawPtLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: pt1		to: pt2		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/25/1998 00:43'!debugPrintObjects	| object end |	self inline: false.	object _ 0.	end _ objUsed.	[object < end] whileTrue:[		Transcript cr; 			nextPut:$#; print: object; space;			print: (self objectHeaderOf: object); space.		(self isEdge: object) 			ifTrue:[Transcript nextPutAll:'(edge) '].		(self isFill:object)			ifTrue:[Transcript nextPutAll:'(fill) '].		Transcript print: (self objectLengthOf: object); space.		Transcript endEntry.		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 17:21'!debugPrintPoints: n	Transcript cr.	n > 0 ifTrue:[		Transcript print: (self point1Get at: 0) @ (self point1Get at: 1); space.	].	n > 1 ifTrue:[		Transcript print: (self point2Get at: 0) @ (self point2Get at: 1); space.	].	n > 2 ifTrue:[		Transcript print: (self point3Get at: 0) @ (self point3Get at: 1); space.	].	n > 3 ifTrue:[		Transcript print: (self point4Get at: 0) @ (self point4Get at: 1); space.	].	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:15'!printAET	| edge |	Transcript cr; show:'************* ActiveEdgeTable **************'.	0 to: self aetUsedGet - 1 do:[:i|		edge _ aetBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:14'!printGET	| edge |	Transcript cr; show:'************* GlobalEdgeTable **************'.	0 to: self getUsedGet - 1 do:[:i|		edge _ getBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 21:57'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:18'!quickPrintBezier: bezier	Transcript cr.	Transcript nextPut:$(;		print: (self edgeXValueOf: bezier)@(self edgeYValueOf: bezier);		space;		print: (self bezierViaXOf: bezier)@(self bezierViaYOf: bezier);		space;		print: (self bezierEndXOf: bezier)@(self bezierEndYOf: bezier);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:00'!quickPrintBezier: index first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: (self bzStartX: index)@(self bzStartY: index);		space;		print: (self bzViaX: index)@(self bzViaY: index);		space;		print: (self bzEndX: index)@(self bzEndY: index);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'initialize' stamp: 'ar 1/12/1999 10:38'!initialize	doProfileStats _ false.! !!BalloonEngineSimulation class methodsFor: 'instance creation' stamp: 'ar 10/29/1998 19:18'!new	^super new initialize! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm	^destForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm: aForm	destForm _ aForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index	^index! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index: anInteger	index _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX	^maxX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX: anInteger	maxX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX	^minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX: anInteger	minX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source	^source! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source: anObject	source _ anObject! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/28/1998 16:35'!width	^maxX - minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue	^yValue! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue: anInteger	yValue _ anInteger! !!BalloonFillData methodsFor: 'computing' stamp: 'ar 11/14/1998 19:32'!computeFill	(destForm isNil or:[destForm width < self width]) ifTrue:[		destForm _ Form extent: (self width + 10) @ 1 depth: 32.	].	source computeFillFrom: minX to: maxX at: yValue in: destForm! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end	^end! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end: aPoint	end _ aPoint! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialZ	^0 "Assume no depth given"! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start	^start! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start: aPoint	start _ aPoint! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:52'!computeInitialStateFrom: source with: aTransformation	"Compute the initial state in the receiver."	start _ (aTransformation localPointToGlobal: source start) asIntegerPoint.	end _ (aTransformation localPointToGlobal: source end) asIntegerPoint.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:22'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	|  startX endX startY endY yDir deltaY deltaX widthX |	(start y) <= (end y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.		yDir _ 1.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.		yDir _ -1.	].	deltaY _ endY - startY.	deltaX _ endX - startX.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[^edgeTableEntry lines: 0].	"Check if edge goes left to right"	deltaX >= 0 ifTrue:[		xDirection _ 1.		widthX _ deltaX.		error _ 0.	] ifFalse:[		xDirection _ -1.		widthX _ 0 - deltaX.		error _ 1 - deltaY.	].	"Check if edge is horizontal"	deltaY = 0 		ifTrue:[	xIncrement _ 0.				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"			deltaY > widthX 				ifTrue:[	xIncrement _ 0.						errorAdjUp _ widthX]				ifFalse:[	xIncrement _ (widthX // deltaY) * xDirection.						errorAdjUp _ widthX \\ deltaY]].	errorAdjDown _ deltaY.	edgeTableEntry xValue: startX.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		startY to: yValue do:[:y| self stepToNextScanLineAt: y in: edgeTableEntry].		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:39'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	| x |	x _ edgeTableEntry xValue + xIncrement.	error _ error + errorAdjUp.	error > 0 ifTrue:[		x _ x + xDirection.		error _ error - errorAdjDown.	].	edgeTableEntry xValue: x.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 23:42'!subdivide	^nil! !!BalloonLineSimulation methodsFor: 'printing' stamp: 'ar 10/27/1998 23:20'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: end;		nextPut:$)! !A balloon with text used for the display of explanatory information.Balloon help is integrated into Morphic as follows:If a Morph has the property #balloonText, then it will respond to #showBalloon by adding a text balloon to the world, and to #deleteBalloon by removing the balloon.Moreover, if mouseOverEnabled is true (see class msg), then the Hand will arrange to cause display of the balloon after the mouse has lingered over the morph for a while, and removal of the balloon when the mouse leaves the bounds of that morph.  In any case, the Hand will attempt to remove any such balloons before handling mouseDown events, or displaying other balloons.Balloons should not be duplicated with veryDeepCopy unless their target is also duplicated at the same time.!!BalloonMorph class methodsFor: 'all' stamp: 'di 1/14/1999 21:02'!string: str for: morph corner: cornerName	"Make up and return a balloon for morph.  Find the quadrant thatclips the text the least, using cornerName as a tie-breaker.  tk 9/12/97"	| txt tm corners p1 p2 vertices c r maxArea aa verts mp dir mbc pref rectCorner morphPoint balloonColor |	BalloonFont		ifNil: [txt _ str]		ifNotNil: [txt _ Text string: str attribute: (TextFontReference toFont: BalloonFont)].	tm _ (TextMorph new contents: txt) centered.	"Construct vertices for a balloon below and to left of anchor"	corners _ tm bounds corners atAll: #(1 4 3 2).	p1 _ (corners at: 1) + ((0 - tm width//3)@0).	p2 _ (corners at: 1) + ((0 - tm width//6)@(tm height//2)).	vertices _ (Array with: p1 with: p2) , corners.	r _ p1 rect: (corners at: 3).	corners _ #(bottomRight bottomLeft topLeft topRight).	pref _ corners indexOf: cornerName.	c _ tm center.	maxArea _ 0.	(0 to: 3) do:		[:i | "Try four rel locations of the balloon for greatest unclipped area"		rectCorner _ corners atWrap: i+pref+2.		morphPoint _ (#(bottomRight bottomLeft) includes: rectCorner)						ifTrue: [#topCenter] ifFalse: [#bottomCenter].		aa _ ((r align: (r perform: rectCorner)				with: (mbc _ morph fullBoundsInWorld perform: morphPoint))			intersect: (0@0 extent: morph world viewBox extent)) area.		aa > maxArea ifTrue: [verts _ vertices.							maxArea _ aa.							mp _ mbc].		dir _ (i+pref) odd ifTrue: [#horizontal] ifFalse: [#vertical].		vertices _ vertices collect: [:p | p flipBy: dir centerAt: c]].	balloonColor _ Display depth <= 2					ifTrue: [Color white]					ifFalse: [Color r: 1.0 g: 1.0 b: 0.6].	^ self new color: balloonColor;			setBorderWidth: 1 borderColor: Color black;			setVertices: verts;			addMorph: tm;			align: verts first with: mp;			setTarget: morph! !!BalloonRectangleMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 22:31'!initialize	super initialize.	color _ GradientFillStyle ramp: {0.0 -> Color green. 0.5 -> Color yellow. 1.0 -> Color red}.	color radial: true.	borderColor _ GradientFillStyle ramp: {0.0 -> Color black. 1.0 -> Color white}.	borderWidth _ 10.	self extent: 100@100.! !!BalloonRectangleMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 22:24'!doesBevels	"To return true means that this object can show bevelled borders, and	therefore can accept, eg, #raised or #inset as valid borderColors.	Must be overridden by subclasses that do not support bevelled borders."	^ false! !!BalloonRectangleMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 22:20'!newTransformationMorph	^MatrixTransformMorph new! !!BalloonRectangleMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:40'!drawOn: aCanvas	(color isKindOf: OrientedFillStyle) ifTrue:[		color origin: bounds center.		color direction: (bounds extent x * 0.7) @ 0.		color normal: 0@(bounds extent y * 0.7).	].	(borderColor isKindOf: OrientedFillStyle) ifTrue:[		borderColor origin: bounds topLeft.		borderColor direction: (bounds extent x) @ 0.		borderColor normal: 0@(bounds extent y).	].	aCanvas asBalloonCanvas		drawRectangle: (bounds insetBy: borderWidth // 2)		color: color		borderWidth: borderWidth		borderColor: borderColor.! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:07'!computeFillFrom: minX to: maxX at: yValue in: form	| bb |	color isTransparent ifFalse:[		bb _ BitBlt toForm: form.		bb fillColor: color.		bb destX: 0 destY: 0 width: (maxX - minX) height: 1.		bb combinationRule: Form over.		bb copyBits].! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:08'!computeInitialStateFrom: source with: aColorTransform	color _ source asColor.! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:47'!aaLevel	^aaLevel! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:47'!aaLevel: aNumber	aaLevel _ aNumber! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:42'!colorTransform	^colorTransform! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:42'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:41'!transform	^transform! !!BalloonState methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:42'!transform: aMatrixTransform	transform _ aMatrixTransform! !A minimalist button-like object intended for use with the tile-scripting system.!!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 17:02'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label...' action: #setLabel.! !!BasicButton methodsFor: 'all' stamp: 'sw 6/29/1998 20:57'!initialize	super initialize.	self borderWidth: 1.	self borderColor: Color yellow darker.	self color: Color yellow.	self label: 'Button'! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:49'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:53'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ aFont		ifNil:			[StringMorph contents: aString]		ifNotNil:			[StringMorph contents: aString font: aFont].	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!BasicButton class methodsFor: 'all' stamp: 'sw 6/16/1998 16:58'!defaultNameStemForInstances	^ 'button'! !!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'copying' stamp: 'sw 6/16/1998 15:15'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ methodDict copy! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 1/2/1999 15:52'!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary."	| oldMethod |	oldMethod _ self lookupSelector: selector.	methodDict at: selector put: compiledMethod.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod == nil ifFalse: [oldMethod flushCache].	selector flushCache! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 1/2/1999 15:16'!removeSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	^ self removeSelectorSimply: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 9/10/1998 14:37'!changeRecordsAt: selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	| aList |	aList _ ChangeList new			scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])			class: self meta: self isMeta			category: (self whichCategoryIncludesSelector: selector)			selector: selector.	^ aList ifNotNil: [aList changeList]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/2/1999 15:45'!lookupSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass _ self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass _ lookupClass superclass].	^ nil! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/21/98 02:36'!kindOfSubclass 	"Answer a String that is the keyword that describes the receiver's kind of 	subclass, either a regular subclass, a variableSubclass, a 	variableByteSubclass, a variableWordSubclass, or a weakSubclass"	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 1/13/1999 09:03'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal.  Dives into the compact literal notation, making it slow but thorough"	| who |	who _ Set new.	methodDict keyValueDo:		[:sel :method |		((method hasLiteralSuchThat: [:lit | lit == literal]) or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isMemberOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'private' stamp: 'ar 3/23/98 22:55'!becomeCompact	| cct index |	self isWeak ifTrue:[^self halt:'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09'!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	self flag: #obsolete.	^self format: nInstVars variable: isVar words: isWords pointers: isPointers weak: false! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !!Behavior methodsFor: 'private' stamp: 'di 1/2/1999 16:06'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ methodDict at: selector ifAbsent: [^ self].	methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !This class represents a quadratic bezier segment between two pointsInstance variables:	via		<Point>	The additional control point (OFF the curve)!!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint	"Initialize the receiver as straight line"	start _ startPoint.	end _ endPoint.	via _ (start + end) // 2.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint via: viaPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.	via _ viaPoint.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve	"Initialize the receiver with the pointOnCurve assumed at the parametric value 0.5"	start _ startPoint.	end _ endPoint.	"Compute via"	via _ (pointOnCurve * 2) - ((start+end) // 2).! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	"Initialize the receiver with the pointOnCurve at the given parametric value"	| t1 t2 t3 |	start _ startPoint.	end _ endPoint.	"Compute via"	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	via _ (pointOnCurve * t2) - (start * t1)  - (end * t3)! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!bounds	"Return the bounds containing the receiver"	^super bounds encompass: via! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!via	"Return the control point"	^via! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!hasZeroLength	"Return true if the receiver has zero length"	^start = end and:[start = via]! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^true! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isStraight	"Return true if the receiver represents a straight line"	^(self tangentAtStart crossProduct: self tangentAtEnd) = 0! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:15'!length	"Return the length of the receiver"	"Note: Overestimates the length"	^(start dist: via) + (via dist: end)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/6/1998 23:39'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| steps last deltaStep t next |	steps _ 1 max: (self length // 10). "Assume 10 pixels per step"	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	| in out |	in _ self tangentAtStart.	out _ self tangentAtEnd.	^in + (out - in * parameter)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtEnd	"Return the tangent for the last point"	^end - via! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtStart	"Return the tangent for the first point"	^via - start! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:17'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	"Return the point at the parametric value t:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:17'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^self! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:18'!asIntegerSegment	"Convert the receiver into integer representation"	^self species 			from: start asIntegerPoint 			to: end asIntegerPoint 			via: via asIntegerPoint! !!Bezier2Segment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:18'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' via: ';		print: via;		nextPutAll: ' to: ';		print: end;		space.! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:14'!from: startPoint to: endPoint via: viaPoint	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint to: endPoint withMidPoint: pointOnCurve	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint via: viaPoint to: endPoint 	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint withMidPoint: pointOnCurve at: parameter to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint withMidPoint: pointOnCurve to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'copying' stamp: 'di 12/26/1998 15:04'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededForDepth: destForm depth].	^ self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'di 12/31/1998 14:38'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 96>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'di 1/4/1999 01:14'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!BitBlt methodsFor: 'private' stamp: 'ar 10/25/1998 17:30'!copyBitsFrom: x0 to: x1 at: y	destX _ x0.	destY _ y.	sourceX _ x0.	width _ (x1 - x0).	self copyBits.! !!BitBlt methodsFor: 'private' stamp: 'di 9/11/1998 13:07'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededForDepth: destForm depth]! !This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/31/1998 22:05'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'jm 11/24/1998 16:06'!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	self export: true.	interpreterProxy _ anInterpreter.! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/29/1998 12:19'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/31/1998 20:50'!copyBits	| done |	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self tryCopyingBitsQuickly.	done ifTrue:[^nil].	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/11/1998 22:29'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/14/1998 00:44'!tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34"	(combinationRule = 34) ifFalse:[^false].	"We handle only sourcePixSize 32"	(sourcePixSize = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].	"We need at least 8bit deep dest forms"	(destPixSize < 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destPixSize = 8 and:[colorMap = interpreterProxy nilObject]) ifTrue:[^false].	destPixSize = 32 		ifTrue:[self alphaSourceBlendBits32].	destPixSize = 16		ifTrue:[self alphaSourceBlendBits16].	destPixSize = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL _ dx.	affectedR _ dx + bbW.	affectedT _ dy.	affectedB _ dy + bbH.	^true! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:37'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	(dx bitAnd: 1) = 0 		ifTrue:[	mask1 _ 16r0000FFFF.				srcShift _ 16.				adjust _ 0]		ifFalse:[mask1 _ 16rFFFF0000.				srcShift _ 0.				adjust _ 16r0F0F0F0F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r0F0F0F0F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r0F0F0F0F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 2)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			"Treat srcAlpha >= 240 as opaque"			srcAlpha = 240 ifTrue:[				sourceWord _ self rgbMap: sourceWord from: 8 to: 5.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha <= 15 ifTrue:[					"Treat srcAlpha <= 15 as transparent"				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ self rgbMap: destWord from: 5 to: 8.					destWord _ destWord bitOr: 16rFF000000.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.										sourceWord _ self rgbMap: sourceWord from: 8 to: 5.					sourceWord _ sourceWord << srcShift.					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask.					interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).				].			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"			adjust _ adjust bitXor: 16r0F0F0F0F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/2/1998 02:20'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register int srcIndex'.	self var: #dstIndex declareC:'register int dstIndex'.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + dx) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ interpreterProxy longAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				interpreterProxy longAt: dstIndex put: sourceWord.				srcIndex _ srcIndex + 4.				dstIndex _ dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX _ deltaX - 1) ~= 0 and:[					(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 255]]						whileTrue:[							interpreterProxy longAt: dstIndex put: sourceWord.							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].				"Adjust deltaX"				deltaX _ deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX _ deltaX - 1) ~= 0 and:[						(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].					"Adjust deltaX"					deltaX _ deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ self alphaBlendScaled: sourceWord with: destWord.					interpreterProxy longAt: dstIndex put: destWord.					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.				].			].		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:56'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable |	self inline: false. "This particular method should be optimized in itself"	self var: #mappingTable declareC:'unsigned int *mappingTable'.	mappingTable _ self default8To32Table.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	mask1 _ 24 - ((dx bitAnd: 3) * 8).	mask2 _ AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust _ 0]		ifFalse:[adjust _ 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r1F1F1F1F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 4)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		srcShift _ mask1.		dstMask _ mask2.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ mappingTable at: destWord.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord _ self rgbMap: sourceWord from: 8 to: cmBitsPerColor.				sourceWord _ interpreterProxy fetchWord: sourceWord ofObject: colorMap.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[				dstIndex _ dstIndex + 4.				srcShift _ 24.				dstMask _ 16r00FFFFFF.			] ifFalse:[				srcShift _ srcShift - 8.				dstMask _ (dstMask >> 8) bitOr: 16rFF000000.			].			adjust _ adjust bitXor: 16r1F1F1F1F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/29/1998 12:27'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 18:05'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1998 21:12'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:44'!warpLoop	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:11'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ maskTable at: destPixSize.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:33'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ maskTable at: destPixSize.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:55'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:21'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ maskTable at: destPixSize.	destPixSize = 16 		ifTrue: [bitsPerColor _ 5]		ifFalse:[bitsPerColor _ 8].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 11/27/1998 23:56'!alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	self inline: false.	"Do NOT inline this into optimized loops"	unAlpha _ 255 - (sourceWord >> 24).  "High 8 bits of source pixel"	dstMask _ destinationWord.	srcMask _ sourceWord.	b _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	b > 255 ifTrue:[b _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	g _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	g > 255 ifTrue:[g _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	r _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	r > 255 ifTrue:[r _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	a _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	a > 255 ifTrue:[a _ 255].	^(((((a << 8) + r) << 8) + g) << 8) + b! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:56'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:18'!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:36'!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:12'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask _ maskTable at: destPixSize.	destPixSize = 16		ifTrue: [bitsPerColor _ 5.  rgbMask _ 16r1F]		ifFalse: [bitsPerColor _ 8.  rgbMask _ 16rFF].	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff _ 0]							ifFalse: [diff _ 1]]				ifFalse: [diff _ (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff _ (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount _ bitCount + diff].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 22:27'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	pixMask _ maskTable at: destPixSize.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) = 0 ifFalse:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 11/16/1998 00:23'!default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs _ (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex _ (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	self returnTypeC:'unsigned int *'.	self var: #theTable declareC:'static unsigned int theTable[256] = { 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};'.	^theTable! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:15'!pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize <= 8		and colorMap notNil"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		"look up sourcePix in colorMap"		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:18'!pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for colorMap==nil.		SourcePixelSize is also known to be 8 bits or less."	"With no color map, pixels are just masked or zero-filled."	| sourceWord destWord sourcePix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		destPixSize = 32			ifTrue:[destWord _ sourcePix]			ifFalse:[destWord _ (destWord << destPixSize) 								bitOr: (sourcePix bitAnd: destPixMask)].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:20'!pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize >= 16"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		nullMap		ifTrue:			["Map between RGB pixels"			sourcePixSize = 16				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]		ifFalse:			["RGB pixels first get reduced to cmBitsPerColor"			sourcePixSize = 16				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].			"Then look up sourcePix in colorMap"			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:14'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	self inline: false.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	srcPixPerWord _ 32 // sourcePixSize.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation methodsFor: 'translation support' stamp: 'ar 10/12/1998 17:43'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/29/1998 23:24'!initialize	"BitBltSimulation initialize"  	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'ar 10/12/1998 17:42'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!BitBltSimulation class methodsFor: 'translation' stamp: 'ar 12/7/1998 21:27'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.! !!BitBltSimulator methodsFor: 'all' stamp: 'ar 12/7/1998 21:10'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:41'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 237>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size _ bm size.	i _ self encodeInt: size in: ba at: 1.	k _ 1.	[k <= size] whileTrue:		[word _ bm at: k.		lowByte _ word bitAnd: 16rFF.		eqBytes _ ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j _ k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j _ j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i _ self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i _ i+1]				ifFalse: [i _ self encodeInt: j-k+1*4+2 in: ba at: i.						i _ self encodeBytesOf: word in: ba at: i].			k _ j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i _ self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i _ i+1.				k _ k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j _ j+1].				j = size ifTrue: [j _ j + 1].				"We have one or more unmatching words, ending at j-1"				i _ self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i _ self encodeBytesOf: (bm at: m) in: ba at: i].				k _ j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | f unhibernate.	b _ f bits.	n _ n + 1.	rawBytes _ rawBytes + (b size*4).	myBytes _ myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Bitmap methodsFor: 'filing' stamp: 'di 6/1/1998 20:35'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream.	A leading byte ~= 16r80 identifies this as raw bits (uncompressed)."	aStream nextInt32Put: self size.	aStream nextPutAll: self! !!Bitmap methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form	^form! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form: aForm	form _ aForm! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/27/1998 14:37'!tileFlag	^tileFlag! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/27/1998 14:30'!tileFlag: aBoolean	tileFlag _ aBoolean! !!BitmapFillStyle methodsFor: 'testing' stamp: 'ar 11/11/1998 22:40'!isBitmapFill	^true! !!BitmapFillStyle methodsFor: 'testing' stamp: 'ar 11/27/1998 14:37'!isTiled	"Return true if the receiver should be repeated if the fill shape is larger than the form"	^tileFlag == true! !!BitmapFillStyle methodsFor: 'converting' stamp: 'ar 11/11/1998 22:41'!asColor	^form colorAt: 0@0! !!BitmapFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/13/1998 20:32'!form: aForm	^self new form: aForm! !!BlockContext methodsFor: 'evaluating' stamp: 'tk 6/24/1998 15:32'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver. If an error occurs the given is evaluated with the error message and the receiver as parameters. The error handler block may return a value to be used if the receiver block gets an error. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | ^ 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'division by 0' = err				ifTrue: [^ Float infinity]				ifFalse: [self error: err]]"	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ errorHandlerBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'scheduling' stamp: 'di 9/12/1998 11:53'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 11/9/1998 10:16'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess |	forkedProcess _ self newProcess.	forkedProcess priority: priority.	^ forkedProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'private' stamp: 'di 1/14/1999 22:28'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!BlockContext methodsFor: 'system simulation' stamp: 'di 1/11/1999 10:24'!pushArgs: args from: sendr 	"Simulates action of the value primitive."	args size ~= nargs ifTrue: [^self error: 'incorrect number of args'].	self stackp: 0.	args do: [:arg | self push: arg].	sender _ sendr.	pc _ startpc! !!BlockContext class methodsFor: 'as yet unclassified' stamp: 'di 1/14/1999 22:05'!basicNew: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super basicNew: CompiledMethod fullFrameSize! !!BlockContext class methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 22:20'!new	^ super new: CompiledMethod fullFrameSize! !!BlockContext class methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 22:44'!new: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super new: CompiledMethod fullFrameSize! !!BlockNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:11'!printArgumentsOn: aStream indent: level	arguments size = 0		ifFalse: 			[arguments do: 				[:arg | 				aStream nextPut: $:.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: arg key].				aStream space].			aStream nextPutAll: '| '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.sp	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.Pages may be linked to each other.  To create a named link to a new page, type the name of the page in a text area in a page.  Select it and do Cmd-6.  Choose 'link to'.  A new page of that name will be added at the back of the book.  Clicking on the blue text flips to that page.  	To create a link to an existing page, first name the page.  Go to that page and Cmd-click on it.  The name of the page is below the page.  Click in it and backspace and type.  Return to the page you are linking from.  Type the name. Cmd-6, 'link to'.  Text search:  Search for a set of fragments.  allStrings collects text of fields.  Turn to page with all fragments on it and highlight the first one.  Save the container and offset in properties: #searchContainer, #searchOffset, #searchKey.  Search again from there.  Clear those at each page turn, or change of search key.  !!BookMorph methodsFor: 'initialization' stamp: 'tk 1/5/1999 13:49'!fromRemoteStream: strm	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| remote dict |	remote _ strm fileInObjectAndCode.	self initialize.	pages _ OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage fullReleaseCachedState; delete.	"the blank one"	currentPage _ remote at: 2.	dict _ remote at: 1.	self setProperty: #modTime toValue: (dict at: #modTime).	dict at: #allText ifPresent: [:val |		self setProperty: #allText toValue: val].	dict at: #allTextUrls ifPresent: [:val |		self setProperty: #allTextUrls toValue: val].	#(color borderWidth borderColor pageSize) with: 		#(color: borderWidth: borderColor: pageSize:) do: [:key :sel |			dict at: key ifPresent: [:val | 			 	self perform: sel with: val]].	^ self! !!BookMorph methodsFor: 'initialization' stamp: 'tk 1/14/1999 12:53'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self fromRemoteStream: strm.	self setProperty: #url toValue: url.	^ self! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:43'!initialize	super initialize.	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23'!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages _ pages species new.	pages addAll: pageList! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45'!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	self removeAllMorphs! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 17:03'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	openToDragNDrop _ true! !!BookMorph methodsFor: 'sorting' stamp: 'di 1/4/1999 13:27'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects toAdd |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [toAdd _ m page].		toAdd ifNil: [rejects add: m]			ifNotNil: [goodPages add: toAdd]].	self newPages: goodPages.	goodPages size = 0 ifTrue: [self insertPage].	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'sorting' stamp: 'di 1/4/1999 12:53'!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: Sensor cursorPoint		from: 0 to: pages size		during:			[:bar | i _ 0.			thumbnails _ pages collect:				[:p | bar value: (i_ i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter inBook: self]					ifFalse: [p thumbnailForPageSorter inBook: self]]].	^ thumbnails! !!BookMorph methodsFor: 'sorting' stamp: 'di 1/4/1999 13:52'!sortPages	currentPage ifNotNil: [currentPage updateCachedThumbnail].	^ super sortPages! !!BookMorph methodsFor: 'sorting' stamp: 'di 1/4/1999 12:12'!sortPages: evt	^ self sortPages! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/17/1998 11:19'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs.    (As needed, make a variant of this that brings in all pages that are not in memory.)"	| coll |	coll _ OrderedCollection new.	pages do: [:pg |		pg isInMemory ifTrue: [			pg == currentPage ifFalse: [coll add: pg]]].	^ coll! !!BookMorph methodsFor: 'accessing' stamp: 'sw 10/16/1998 22:39'!currentPage	(submorphs includes: currentPage) ifFalse: [currentPage _ nil].	^ currentPage! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/24/1998 07:27'!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in.  (This method may wrongly say a page is not here if pages has a tombstone (MorphObjectOut) and that tombstone would resolve to an object already in this image.  This is an unlikely case, and callers just have to tolerate it.)"	^ pages identityIndexOf: aMorph ifAbsent: [0]! !!BookMorph methodsFor: 'accessing' stamp: 'tk 10/22/1998 15:47'!pages: aMorphList	pages _ aMorphList asOrderedCollection.	"It is tempting to force the first page to be the current page.  But then, two pages might be shown at once!!  Just trust the copying mechanism and let currentPage be copied correctly. --Ted."! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 12:05'!userString	"Do I have a text string to be searched on?"	| list |	self getAllText.	list _ OrderedCollection new.	(self valueOfProperty: #allText ifAbsent: #()) do: [:aList |		list addAll: aList].	^ list! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 17:12'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38'!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 6/24/1998 18:50'!deletePage	| message |	message _ 'Are you certain that youwant to delete this page andeverything that is on it? '.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 6/11/1998 17:42'!deletePageBasic	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/26/1998 16:04'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil:			[newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: 'page'.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 1/12/1999 13:23'!insertPageSilentlyAtEnd	"Create a new page at the end of the book.  Do not turn to it."	| sz newPage bw bc cc |	currentPage == nil		ifTrue: [sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter.			cc _ color]		ifFalse: [sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor.			cc _ currentPage color].	newPagePrototype		ifNil: [newPage _ PasteUpMorph new extent: sz; color: cc.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: 'page'.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]	"was none"		ifFalse: [pages add: newPage after: pages last].	^ newPage! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 10:18'!goToPage: pageNumber	^ self goToPage: pageNumber transitionSpec: nil! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:07'!goToPage: pageNumber transitionSpec: transitionSpec	| pageMorph |	pages isEmpty ifTrue: [^ self].	pageMorph _ (self hasProperty: #dontWrapAtEnd)		ifTrue: [pages atPin: pageNumber]		ifFalse: [pages atWrap: pageNumber].	^ self goToPageMorph: pageMorph transitionSpec: transitionSpec! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:17'!goToPageMorph: aMorph	self goToPage: (pages identityIndexOf: aMorph ifAbsent: [^ self "abort"]).! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/4/1999 12:37'!goToPageMorph: aMorph fromBookmark: aBookmark	"This protocol enables sensitivity to a transitionSpec on the bookmark"		self goToPageMorph: aMorph		transitionSpec: (aBookmark valueOfProperty: #transitionSpec).! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/4/1999 18:08'!goToPageMorph: newPage transitionSpec: transitionSpec	| pageIndex  aWorld oldPageIndex ascending tSpec |	pages isEmpty ifTrue: [^ self].	pageIndex _ pages identityIndexOf: newPage ifAbsent: [^ self "abort"].	oldPageIndex _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageIndex == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageIndex < pageIndex].	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld]]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 1/11/1999 11:52'!goToPageUrl: aUrl	self goToPageMorph: (pages detect: [:pg | pg url = aUrl] ifNone: [pages at: 1]).! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/26/1998 15:41'!goto: aPlayer	self goToPageMorph: aPlayer costume! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:01'!nextPage	currentPage == nil ifTrue: [^ self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) + 1.! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:19'!pageNumber	^ self pageNumberOf: currentPage! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:01'!previousPage	currentPage == nil ifTrue: [^ self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) - 1.! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:20'!setWrapPages: doWrap	doWrap		ifTrue: [self removeProperty: #dontWrapAtEnd]		ifFalse: [self setProperty: #dontWrapAtEnd toValue: true].! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/21/1998 11:15'!transitionSpecFor: aMorph	^ aMorph valueOfProperty: #transitionSpec  " check for special propety"		ifAbsent: [Array with: 'camera'  " ... otherwise this is the default"						with: #none						with: #none]! !!BookMorph methodsFor: 'menu' stamp: 'di 1/14/1999 12:13'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu addLine.	subMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	subMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	subMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'uncache page sorter' action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' action: #textSearch.	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send all pages to server' action: #savePagesOnURL.	subMenu add: 'send this page to server' action: #saveOneOnURL.	subMenu add: 'reload all from server' action: #reload.	subMenu add: 'copy page url to clipboard' action: #copyUrl.	subMenu add: 'keep in one file' action: #keepTogether.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:59'!bookmarkForThisPage	| b |	b _ SimpleButtonMorph new target: self.	b actionSelector: #goToPageMorph:fromBookmark:.	b label: 'Bookmark'.	b arguments: (Array with: currentPage with: b).	self primaryHand attachMorph: b! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/11/1999 12:13'!copyUrl	"Copy this page's url to the clipboard"	| str |	str _ currentPage url ifNil: [str _ 'Page does not have a url.  Send page to server first.'].	ParagraphEditor new clipboardTextPut: str asText.! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/4/1999 10:24'!findText: wants	"Turn to the next page that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere array stringToHilite index insideOf block container keys oldKey oldContainer oldIndex place |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ pages identityIndexOf: currentPage ifAbsent: [1].	stringToHilite _ wants at: 1.	fromHereOn _ here to: pages size.	startToHere _ 1 to: here.	block _ [:pageNo | "Just define block, do not execute yet!!!!!!!!"		array _ allText at: pageNo.		good _ true.		keys do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				array do: [:longString |					(index _ longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [							thisWord _ true.							searchString == stringToHilite ifTrue: [								insideOf _ longString. place _ index]]].				good _ thisWord]].		good ifTrue: ["all are on this page"			self goToPage: pageNo.			container _ self highlightText: stringToHilite at: place in: insideOf.			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: wants.			^ true]].	(oldKey _ self valueOfProperty: #searchKey) = wants ifTrue: [		"does page have the other keys?"		oldContainer _ self valueOfProperty: #searchContainer.		oldIndex _ self valueOfProperty: #searchOffset.		].	keys _ wants.	fromHereOn do: block.	startToHere do: block.	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:16'!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/19/1998 09:30'!getAllText	"Collect the text for each page.  Just point at strings so don't have to recopy them.  Parallel array of urls for ID of pages.	allText = Array (pages size) of arrays (fields in it) of strings of text.	allTextUrls = Array (pages size) of urls or page numbers.	For any page that is out, text data came from .bo file on server.  	Is rewritten when one or all pages are stored."	| oldUrls oldStringLists allText allTextUrls aUrl which |	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ pages collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: pages size.	pages doWithIndex: [:aPage :ind | aUrl _ aPage url.  aPage isInMemory 		ifTrue: [(allText at: ind) addAll: aPage allStrings.			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of pages on server may be different.  (later keep up to date?)"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/13/1999 08:38'!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll knownURL |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url.		knownURL _ true]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ ServerDirectory defaultStemUrl, '1.sp'].	"A new legal place"knownURL ifNil: [	url _ FillInTheBlank 			request: 'url of the place to store a typical page in this book.	Must begin with file:// or ftp://' 			initialAnswer: initial].knownURL ifNotNil: [url _ initial].ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"url _ (url stemAndNumericSuffix) at: 1.		"remove trailing number"url size = 0 ifTrue: [^ url].	"empty"[url last == $x] whileTrue: [url _ url allButLast].^ url! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/4/1999 09:54'!highlightText: stringToHilite at: index in: insideOf	"Find the container with this text and highlight it.  May not be able to do it for stringMorphs."	"Find the container with that text"	| container |	self allMorphsDo: [:sub | 		insideOf == sub userString ifTrue: [container _ sub]].	container ifNil: [		self allMorphsDo: [:sub | 			insideOf = sub userString ifTrue: [container _ sub]]].	"any match"	container ifNil: [^ self].	"Order it highlighted"	(container isKindOf: TextMorph) ifTrue: [		container editor selectFrom: index to: stringToHilite size - 1 + index].	container changed.	^ container! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 16:06'!indexOfCurrentPage	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'di 1/14/1999 12:17'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu hand |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList:		#(('sort pages'				sortPages)		('uncache page sorter'	uncachePageSorter)).	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	aMenu addList:		#(('make bookmark'		bookmarkForThisPage)		('make thumbnail'		thumbnailForThisPage)		('remove control panel'	hidePageControls)).	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'search for text' action: #textSearch.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'copy page url to clipboard' action: #copyUrl.	aMenu add: 'keep in one file' action: #keepTogether.	hand _ self world primaryHand.	aMenu popUpAt: hand position forHand: hand."	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel]."! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/2/1998 19:31'!keepTogether	"Mark this book so that each page will not go into a separate file.  Do this when pages share referenes to a common Player.  Don't want many copies of that Player when bring in.  Do not write pages of book out.  Write the PasteUpMorph that the entire book lives in."	self setProperty: #keepTogether toValue: true.! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 14:11'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose a sound(it is now ' , tSpec first , ')') defaultTarget: target.	SampledSound soundNames do:		[:soundName |		menu add: soundName target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copyAt: 1 put: soundName))].	menu popUpAt: evt hand position forHand: evt hand.! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:53'!menuPageSoundForAll: evt	^ self menuPageSoundFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55'!menuPageSoundForThisPage: evt	currentPage ifNotNil:		[^ self menuPageSoundFor: currentPage event: evt]! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 17:12'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose an effect(it is now ' , tSpec second , ')') defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices _ TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu _ MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect subMenu: subMenu]].	menu popUpAt: evt hand position forHand: evt hand.! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 17:16'!menuPageVisualForAll: evt	^ self menuPageVisualFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55'!menuPageVisualForThisPage: evt	currentPage ifNotNil:		[^ self menuPageVisualFor: currentPage event: evt]! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/10/1999 11:22'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"		url _ FillInTheBlank 			request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' 			initialAnswer: (self getStemUrl, '.bo').		url size > 0 ifTrue: [self setProperty: #url toValue: url]			ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq ~~ nil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph == nil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which _ (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/13/1999 08:57'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURL: stem,(ind printString),'.sp'.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	(URLMorph grabURL: (self valueOfProperty: #url)) book: true].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/14/1999 12:30'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL."	| holder mine sf remoteFile strm remote pageURL num pre index after sp dict allText allTextUrls |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	2 to: remote size do: [:ii | 		((remote at: ii) url findString: pageURL startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	sp _ aPage sqkPage copy.	"is there"	holder _ MorphObjectOut new xxxSetUrl: sp url page: sp.	sp contentsMorph: holder.	remote at: index put: holder.	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: aPage allStrings.		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/14/1999 12:32'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list pg holder mine sf remoteFile urlList |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(color borderWidth borderColor pageSize) do: [:sel |		dict at: sel put: (self perform: sel)].	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(pg _ out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			pg _ (out valueOfProperty: #SqueakPage) copy.			holder _ MorphObjectOut new xxxSetUrl: pg url page: pg.			pg contentsMorph: holder.			list at: ind put: holder]].	urlList _ list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/12/1999 18:57'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?'].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/12/1999 18:58'!saveOneOnURL	"Write out this single page onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	^ self saveOnUrlPage: currentPage! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/13/1999 08:56'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURLbasic.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	(URLMorph grabURL: (self valueOfProperty: #url)) book: true].! !!BookMorph methodsFor: 'menu' stamp: 'tk 8/13/1998 12:09'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentPage ifNotNil:		[newPagePrototype _ currentPage veryDeepCopy].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/16/1998 11:16'!textSearch	"search the text on all pages of this book"	| wanted wants |	wanted _ FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.'.	wants _ wanted findTokens: Character separators.	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!BookMorph methodsFor: 'menu' stamp: 'di 1/4/1999 12:49'!thumbnailForThisPage	self primaryHand attachMorph:		(currentPage thumbnailForPageSorter pageMorph: currentPage inBook: self)! !!BookMorph methodsFor: 'menu' stamp: 'di 12/23/1998 14:55'!uncachePageSorter	pages do: [:aPage | aPage removeProperty: #cachedThumbnail].! !!BookMorph methodsFor: 'other' stamp: 'tk 12/15/1998 14:32'!abandon	"Like delete, but we really intend not to use this morph again.  Make the page cache release the page object."	| pg |	self delete.	pages do: [:aPage |		(pg _ aPage sqkPage) ifNotNil: [			pg contentsMorph == aPage ifTrue: [					pg contentsMorph: nil]]].! !!BookMorph methodsFor: 'other' stamp: 'tk 8/13/1998 12:49'!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: aColor; borderWidth: 0.	aColumn _ AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; inset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; inset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' < ' ; actionSelector: #previousPage).		"fullCopy is OK, since we just made it and it can't own any Players"	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'other' stamp: 'tk 10/22/1998 15:42'!releaseCachedState	"Release the cached state of all my pages."	super releaseCachedState.	pages do: [:page | page fullReleaseCachedState].! !!BookMorph methodsFor: 'other' stamp: 'sw 10/1/1998 13:40'!resizePagesTo: anExtent	pages do:		[:aPage | aPage extent: anExtent]! !!BookMorph methodsFor: 'other' stamp: 'sw 8/11/1998 16:50'!succeededInRevealing: aPlayer	currentPage ifNotNil: [currentPage player == aPlayer ifTrue: [^ true]].	pages do:		[:aPage |			(aPage succeededInRevealing: aPlayer) ifTrue:				[self goToPageMorph: aPage.				^ true]].	^ false! !!BookMorph methodsFor: 'other' stamp: 'sw 10/9/1998 08:00'!wrappedInPartsWindowWithTitle: aTitle	| aWindow |	aWindow _ (PartsWindow labelled: aTitle) model: MorphicModel new.	aWindow book: self.	aWindow extent: self extent.	^ aWindow! !!BookMorph class methodsFor: 'all' stamp: 'tk 1/13/1999 09:07'!alreadyInFromUrl: aUrl	"Does a bookMorph living in some world in this image represent the same set of server pages? If so, don't create another one.  It will steal pages from the existing one.  Go delete the first one."		self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world ifNotNil: [					self inform: 'This book is already open in some project'.					^ true]]]].	^ false! !!BookMorph class methodsFor: 'all' stamp: 'sw 7/4/1998 15:58'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!BookMorph class methodsFor: 'all' stamp: 'tk 12/7/1998 17:55'!grabURL: aURLString	"Create a BookMorph for this url and put it in the hand."	| bk |	bk _ self new fromURL: aURLString.	"If this book is already in, we will steal the pages out of it!!!!!!!!"	bk goToPage: 1.	"install it"	World primaryHand attachMorph: bk.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:27'!acceptSort	book acceptSortedContentsFrom: pageHolder.	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:39'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'di 1/9/1999 11:41'!book: aBookMorph morphsToSort: morphList	| innerBounds |	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.	innerBounds _ Rectangle merging: (morphList collect: [:m | m bounds]).	pageHolder extent: innerBounds extent + pageHolder borderWidth + 6.	self resizeIfNeeded! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:42'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Close'; actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'di 1/8/1999 16:27'!forBook: aBookMorph 	^ self book: aBookMorph		morphsToSort: (aBookMorph pages collect: [:p | p thumbnailForPageSorter])! !!BookPageSorterMorph methodsFor: 'all' stamp: 'di 1/9/1999 11:44'!initialize	super initialize.	self extent: Display extent - 100;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent - borderWidth.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder.! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.book _ deepCopier references at: book ifAbsent: [book].! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."book _ book.		Weakly copied"pageHolder _ pageHolder veryDeepCopyWith: deepCopier.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:57'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'make a flex morph' selector: #makeFlexMorphFor: argument: aHandMorph.	flipOnClick		ifTrue: [aCustomMenu add: 'disable bookmark action' action: #toggleBookmark]		ifFalse: [aCustomMenu add: 'enable bookmark action' action: #toggleBookmark].	(bookMorph isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' action: #setPageSound:.			aCustomMenu add: 'set page visual' action: #setPageVisual:]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/4/1999 13:42'!computeThumbnail	| f scale |	f _ page imageForm.	scale _ (self height / f height).  "keep height invariant""(Sensor shiftPressed) ifTrue: [scale _ scale * 1.4]."	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/8/1999 16:38'!doPageFlip	"Flip to this page"	bookMorph goToPageMorph: page			transitionSpec: (self valueOfProperty: #transitionSpec).	(owner isKindOf: PasteUpMorph) ifTrue:		[owner cursor: (owner submorphs indexOf: self ifAbsent: [1])]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/23/1998 15:57'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Flip to this page with no extra sound"	BookMorph turnOffSoundWhile: [self doPageFlip]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/4/1999 12:19'!handlesMouseDown: event	^ event shiftPressed or: [flipOnClick and: [event controlKeyPressed not]]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/4/1999 12:52'!inBook: book	bookMorph _ book! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/23/1998 15:45'!initialize	| f |	super initialize.	flipOnClick _ false.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:10'!makeFlexMorphFor: aHand	aHand grabMorph: (FlexMorph new originalMorph: page)! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/23/1998 15:56'!mouseDown: event	self doPageFlip! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/4/1999 13:39'!page: aMorph	page _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName.	page fullReleaseCachedState.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 1/4/1999 12:48'!pageMorph: pageMorph inBook: book	page _ pageMorph.	bookMorph _ book! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!pageNumber: n inBook: b	pageNumber _ n.	bookMorph _ b! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:29'!setPageSound: event	^ bookMorph menuPageSoundFor: self event: event! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:29'!setPageVisual: event	^ bookMorph menuPageVisualFor: self event: event! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/8/1998 14:06'!smaller	self form: (self form copy: (0@0 extent: self form extent//2)).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/23/1998 15:53'!toggleBookmark	"Enable or disable sensitivity as a bookmark		enabled means that a normal click will cause a pageFlip		disabled means this morph can be picked up normally by the hand."	flipOnClick _ flipOnClick not! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 19:35'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.page _ deepCopier references at: page ifAbsent: [page].bookMorph _ deepCopier references at: bookMorph ifAbsent: [bookMorph].! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."page _ page.		Weakly copied"pageNumber _ pageNumber veryDeepCopyWith: deepCopier."bookMorph _ bookMorph.		All weakly copied"flipOnClick _ flipOnClick veryDeepCopyWith: deepCopier. ! !A common superclass for BookMorph and WebBookMorph!!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 15:48'!fullControlSpecs	^ #(( '<--'		firstPage		'First page')		( '<-' 		previousPage	'Previous page')		('-'			deletePage		'Delete this page')		('<<>>'		invokeBookMenu 'Invoke menu')		('+'			insertPage		'Add a new page after this one')		('->'			nextPage		'Next page')		( '-->'		lastPage			'Final page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:12'!hidePageControls	"Delete all submorphs answering to the property #pageControl"	self deleteSubmorphsWithProperty: #pageControl! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:16'!makePageControlsFrom: controlSpecs	| c aButton col row b |	c _ (color saturation > 0.1) ifTrue: [color lighter] ifFalse: [color darker].	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: c.	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; inset: 0.	col hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; inset: 0.	row hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:pair |		b _ aButton fullCopy			label: pair first;			actionSelector: pair second;			setBalloonText: pair third.		row addMorphBack: b.		(pair last asLowercase includesSubString: 'menu')			ifTrue: [b actWhen: #buttonDown]].  "pop up menu on mouseDown"	col addMorphBack: row.	^ col! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 17:48'!shortControlSpecs	^ #(( '<-'	previousPage	'Previous page')		('->'		nextPage		'Next page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:13'!showPageControls	| spacer pageControls |	self hidePageControls.	spacer _ Morph new color: color; extent: 0@10.	spacer  setProperty: #pageControl toValue: true.	self addMorph: spacer.	pageControls _ Preferences noviceMode		ifTrue: [self makePageControlsFrom: self shortControlSpecs]		ifFalse: [self makePageControlsFrom: self fullControlSpecs].	pageControls borderWidth: 1; inset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	self addMorph: pageControls.! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"This factoring allows subclasses to have different menu yet still use the super call for the rest of the metamenu."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39'!clearNewPagePrototype	newPagePrototype _ nil! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:40'!firstPage	self goToPage: 1! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:18'!insertPage	self insertPageColored: self color! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'di 1/9/1999 11:52'!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self indexOfCurrentPage.	"Align at bottom right of screen, but leave 20-pix margin."	self bottom + sorter height < Display height ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter topLeft with: self bottomLeft)].	self right + sorter width < Display width ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter bottomLeft with: self bottomRight)].	"Otherwise, place it at lower right of screen"	self world addMorphFront: (sorter position: Display extent - (20@20) - sorter extent).! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:56'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	(self hasSubmorphWithProperty: #pageControl)		ifTrue: [aCustomMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [aCustomMenu add: 'show page controls' action: #showPageControls]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 8/11/1998 16:51'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage player) ifNotNil:		[aBlock value: aPlayer]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:36'!pageSize	^ pageSize! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51'!pageSize: aPoint	pageSize _ aPoint! !!BooklikeMorph methodsFor: 'misc' stamp: 'di 12/20/1998 09:49'!playPageFlipSound	^ self playPageFlipSound: 'camera'! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 12/21/1998 11:11'!playPageFlipSound: soundName	| presenter |	(presenter _ self presenter) ifNil: [^ self].  "Avoid failures when called too early"	(presenter soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: soundName].! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:09'!presentResultMorph: aMorph	"Add the given morph to the world."	self primaryHand attachMorph: aMorph"	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph."! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 15:59'!initialize	"BooklikeMorph initialize"	PageFlipSoundOn _ true! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!BooleanScriptEditor methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	((submorphs size > 0) and:	 [submorphs first submorphs size > 0]) ifTrue: [			aStream nextPutAll: '(('.			super storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ') ~~ false)'.			^ self].	aStream nextPutAll: ' true '.! !!BooleanScriptEditor methodsFor: 'all' stamp: 'sw 8/3/1998 17:15'!wantsDroppedMorph: aMorph	((aMorph isKindOf: PhraseTileMorph) and:		[submorphs size == 1]) ifTrue: [^ false].	^ aMorph isTileLike and: [aMorph resultType ~~ #command]! !A tile whose result type is boolean.!!BooleanTile methodsFor: 'all' stamp: 'sw 8/5/1998 17:52'!resultType	^ #boolean! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:24'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	(color isColor and: [color isTranslucentColor]) ifTrue: [^ true].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 1/1/1999 22:55'!areasRemainingToFill: aRectangle	(color isColor and: [color isTranslucent]) ifTrue: [^ Array with: aRectangle].	(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])		ifTrue: [^ aRectangle areasOutside: self innerBounds]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 6/25/1998 08:34'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	^ aNumber == 2		ifTrue: 			[#(			(color			color		readWrite	getColor				setColor:)			(borderWidth 		number		readWrite	getBorderWidth	setBorderWidth:)			(borderColor			color		readWrite	getBorderColor	setBorderColor:))]		ifFalse:			[super slotNamesAndTypesForBank: aNumber]! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' action: #startInfection.	aCustomMenu add: 'set atom count' action: #setAtomCount.	aCustomMenu add: 'show infection history' action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString _ FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 8/10/1998 18:32'!step	"Bounce those atoms!!"	| r bounces |	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'di 1/4/1999 20:22'!areasRemainingToFill: aRectangle	color isTranslucent		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph _ GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection _ false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 8/10/1998 18:32'!updateTemperature: currentTemperature	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures == nil ifTrue: [		recentTemperatures _ OrderedCollection new.		20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature _ recentTemperatures sum asFloat / recentTemperatures size.! !!Browser methodsFor: 'initialize-release' stamp: 'sw 11/19/1998 15:38'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row aColor |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #editComment.	commentSwitch		label: '?' asText allBold asParagraph;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	aColor _ Color colorFrom: self defaultBackgroundColor.	row submorphs do:		[:m | m color: aColor.		m onColor: aColor darker offColor: aColor].	^ row! !!Browser methodsFor: 'initialize-release' stamp: 'di 12/15/1998 21:12'!openAsMorphClassEditing: editString	"Create a pluggable version a Browser on just a single class."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #classListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #classListMenu:)		frame: (0@0 extent: 0.5@0.06).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.5@0 extent: 0.5@0.06).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0@0.06 extent: 0.5@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.5@0.06 extent: 0.5@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'di 12/15/1998 21:13'!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane aListMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.4 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'di 12/15/1998 21:02'!openAsMorphMessageEditing: editString	"Create a pluggable version a Browser on just a messageCategory."	| window codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0 extent: 1.0@0.06).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.06 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'di 12/15/1998 21:02'!openAsMorphMsgCatEditing: editString	"Create a pluggable version a Browser on just a messageCategory."	| window codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageCatListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageCategoryMenu:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0.06 extent: 1.0@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'di 12/15/1998 21:14'!openAsMorphSysCatEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0@0.06 extent: 0.3333@0.24).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0@0.3 extent: 0.3333@0.06).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.3333@0.06 extent: 0.3333@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.6666@0.06 extent: 0.3333@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:08'!openEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| systemCategoryListView classListView 	messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphEditing: aString].	Sensor leftShiftDown ifTrue: [^ self openAsMorphEditing: aString "testing"].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategoryList		selected: #systemCategoryListIndex		changeSelected: #systemCategoryListIndex:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	topView addSubView: classListView toRightOf: systemCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	messageListView menuTitleSelector: #messageListSelectorTitle.	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@110).	topView addSubView: browserCodeView below: systemCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:17'!openMessageCatEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message category."	| messageCategoryListView messageListView browserCodeView topView |	World ifNotNil: [^ self openAsMorphMsgCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageCategoryListView _ PluggableListView on: self		list: #messageCatListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageCategoryListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 200 @ 70).	topView addSubView: messageListView below: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphClassEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	classListView _ PluggableListView on: self		list: #classListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 100 @ 12).	topView addSubView: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageCategoryListView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	switchView 		window: switchView window 		viewport: (classListView viewport topRight 					corner: messageListView viewport topRight).	topView addSubView: switchView toRightOf: classListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphSysCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategorySingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 67 @ 62).	topView addSubView: classListView below: systemCategoryListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	switchView _ self buildInstanceClassSwitchView.	switchView 		window: switchView window 		viewport: (classListView viewport bottomLeft 					corner: messageCategoryListView viewport bottomLeft).	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 67 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(110-12)).	topView addSubView: browserCodeView below: switchView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:13'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories 		ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) 		ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText stamp: Utilities changeStamp. ^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage) 		ifTrue: [^ self defineMessage: aText notifying: aController].	editSelection == #none		ifTrue: [PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.				^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'system category functions' stamp: 'di 1/9/1999 22:53'!findClass	"Search for a class by name.  Modified so that if only 1 class matches the user-supplied string then the pop-up menu is bypassed"	| pattern foundClass classNames index |	self okToChange ifFalse: [^ self classNotFound].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	classNames _ Smalltalk classNames asArray select: 				[:n | n includesSubstring: pattern caseSensitive: false].	classNames isEmpty ifTrue: [^ self classNotFound].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index). 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundClass category).	self classListIndex: (self classList indexOf: foundClass name). ! !!Browser methodsFor: 'class functions' stamp: 'di 6/2/1998 13:58'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName |	oldClass _ self selectedClassOrMetaClass.	newClassName _ (defString findTokens: Character separators) third copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [Smalltalk includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	oldClass ifNil: [oldClass _ Object].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!Browser methodsFor: 'message category functions' stamp: 'wod 6/24/1998 02:10'!buildMessageCategoryBrowserEditString: aString 	"Create and schedule a message category browser for the currently 	selected	 message category. The initial text view contains the characters 	in aString."	"wod 6/24/1998: set newBrowser classListIndex so that it works whether the	receiver is a standard or a Hierarchy Browser."	| newBrowser |	messageCategoryListIndex ~= 0		ifTrue: 			[newBrowser _ Browser new.			newBrowser systemCategoryListIndex: systemCategoryListIndex.			newBrowser classListIndex: (newBrowser classList indexOf: self selectedClassName).			newBrowser metaClassIndicated: metaClassIndicated.			newBrowser messageCategoryListIndex: messageCategoryListIndex.			newBrowser messageListIndex: messageListIndex.			Browser openBrowserView: (newBrowser openMessageCatEditString: aString)				label: 'Message Category Browser (' , 						newBrowser selectedClassOrMetaClassName , ')']! !!Browser methodsFor: 'message list' stamp: 'di 9/21/1998 23:12'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message functions' stamp: 'di 1/13/1999 13:19'!prettyPrint	"Reformat the selected method"	| selectedClass |	((self messageListIndex = 0) | (self okToChange not))		ifTrue: [^ self changed: #flash].	selectedClass _ self selectedClassOrMetaClass.	contents _ selectedClass compilerClass new			format: contents			in: selectedClass			notifying: nil.	self changed: #contents.! !!Browser methodsFor: 'message functions' stamp: 'di 5/27/1998 15:45'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.  "In case organization not cached"	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !URLs that instruct a browser to do something.!!BrowserUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !!ButtonMorph methodsFor: 'copying' stamp: 'tk 8/13/1998 12:53'!prepareToBeSaved	"SmartRefStream will not write any morph that is owned by someone outside the root being written.  (See DataStream.typeIDFor:)  Open Scripts are like that.  Make a private copy of the scriptEditor."	super prepareToBeSaved.	lastAcceptedScript ifNotNil: [		lastAcceptedScript owner ifNotNil: ["open on the screen"			lastAcceptedScript _ lastAcceptedScript fullCopy setMorph: self.			self flag: #noteToTed.  "What if some tile has a Player?  				Need an invariant that says no script part can have a Player.  Enforce it."			"lastAcceptedScript privateOwner: nil" "fullCopy does it"]].	"lastScriptEditor will not be written out"! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index	<primitive: 60>	^self at: index! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index put: value	<primitive: 61>	^self at: index put: value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	h _ ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	h = 0 ifFalse:[w _ (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:47'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b0 _ (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort _ self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/3/1998 14:20'!shortAt: index put: value bigEndian: aBool	"Store a 16 bit integer quantity starting from the given byte index"	self unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:51'!unsignedShortAt: index bigEndian: aBool	"Return a 16 bit unsigned integer quantity starting from the given byte index"	^aBool 		ifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]		ifFalse:[((self at: index+1) bitShift: 8) + (self at: index)].! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:53'!unsignedShortAt: index put: value bigEndian: aBool	"Store a 16 bit unsigned integer quantity starting from the given byte index"	aBool ifTrue:[		self at: index put: (value bitShift: -8).		self at: index+1 put: (value bitAnd: 255).	] ifFalse:[		self at: index+1 put: (value bitShift: -8).		self at: index put: (value bitAnd: 255).	].	^value! !!ByteArray methodsFor: 'converting' stamp: 'ar 11/2/1998 00:51'!asByteArray	^self! !I am used to simulate the indexed access to arrays during plugin simulation.!!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object at: index + offset + 1! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object at: index + offset + 1 put: value! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index	| idx |	idx _ (offset + index) // 4 + 1.	"Note: This is a special hack for BitBlt."	(idx = (object basicSize + 1)) ifTrue:[^0].	^object basicAt: idx! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index put: value	^object basicAt: (offset + index) // 4 + 1 put: value! !This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: 'interp.c' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.!!CCodeGenerator methodsFor: 'public' stamp: 'jm 12/13/1998 10:03'!initialize	translationDict _ Dictionary new.	inlineList _ Array new.	constants _ Dictionary new: 100.	variables _ OrderedCollection new: 100.	variableDeclarations _ Dictionary new: 100.	methods _ Dictionary new: 500.	self initializeCTranslationDictionary.! !!CCodeGenerator methodsFor: 'inlining' stamp: 'jm 12/10/1998 16:18'!doInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining."	"Modified slightly for the translator, since the first level of inlining for the interpret loop must be performed in order that the instruction implementations can easily discover their addresses."	| pass progress |	inlineFlag ifFalse: [		self inlineDispatchesInMethodNamed: #interpret localizingVars: #().		^ self].	self collectInlineList.	pass _ 0.	progress _ true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		('Inlining pass ', (pass _ pass + 1) printString, '...')			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [:bar |				methods doWithIndex: [:m :i |					bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [progress _ true]]]].	'Inlining bytecodes'		displayProgressAt: Sensor cursorPoint		from: 1 to: 2		during: [:bar |			self inlineDispatchesInMethodNamed: #interpret				localizingVars: #(currentBytecode localIP localSP localHomeContext localCP localTP).			bar value: 1.			self removeMethodsReferingToGlobals: #(					currentBytecode localIP localSP localHomeContext localCP localTP)				except: #interpret.			bar value: 2].! !!CCodeGenerator methodsFor: 'utilities' stamp: 'ar 10/7/1998 17:53'!isGeneratingPluginCode	^false! !!CCodeGenerator methodsFor: 'utilities' stamp: 'jm 11/25/1998 19:02'!nilOrBooleanConstantReceiverOf: sendNode	"Answer nil or the boolean constant that is the receiver of the given message send. Used to suppress conditional code when the condition is a translation-time constant."	| rcvr val |	rcvr _ sendNode receiver.	rcvr isConstant ifTrue: [		val _ rcvr value.		((val == true) or: [val == false]) ifTrue: [^ val]].	^ nil! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 12/7/97 20:54'!emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	assertionFlag ifFalse: [ self removeAssertions ].	self doInlining: inlineFlag.	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypesOn: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methods doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 09:09'!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	| exporting |	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	exporting _ false.	methods do: [:m |		m export			ifTrue: [				exporting ifFalse: [					aStream nextPutAll: '#pragma export on'; cr.					exporting _ true]]			ifFalse: [				exporting ifTrue: [					aStream nextPutAll: '#pragma export off'; cr.					exporting _ false]].		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr].		exporting ifTrue: [			aStream nextPutAll: '#pragma export off'; cr].! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ls 8/15/1998 08:36'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.! !!CCodeGenerator methodsFor: 'C code generator'!emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do: [ :var |		(variableDeclarations includesKey: var) ifTrue: [			aStream nextPutAll: (variableDeclarations at: var), ';'; cr.		] ifFalse: [			"default variable declaration"			aStream nextPutAll: 'int ', var, ';'; cr.		].	].	aStream cr.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/3/1998 13:45'!generateAsFloat: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((double) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' )'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/3/1998 13:45'!generateAsInteger: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((int) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' )'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 7/5/1998 18:17'!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| rcvr arg divisor |	rcvr _ msgNode receiver.	arg _ msgNode args first.	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor _ arg value) isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		aStream nextPutAll: '((int) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.		aStream nextPutAll: ')'.	] ifFalse: [		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitCExpression: arg on: aStream].! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const ifFalse: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if (!!('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ')) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:06'!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,       presumably to help with inlining later. That is, the first argument       is the block to be evaluated if the condition is true. Squeak's compiler	  does not reverse the blocks, but you may need to fix this method if	  you wish to cross-compile using VisualWorks."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const			ifTrue: [msgNode args last emitCCodeOn: aStream level: level generator: self]			ifFalse: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const ifTrue: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const			ifTrue: [msgNode args first emitCCodeOn: aStream level: level generator: self]			ifFalse: [msgNode args last emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/11/1998 00:56'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	#asFloat				#generateAsFloat:on:indent:	#asInteger			#generateAsInteger:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!CCodeGenerator class methodsFor: 'class initialization' stamp: 'jm 8/19/1998 10:03'!initialize	"CCodeGenerator initialize"	UseRightShiftForDivide _ true.		"If UseRightShiftForDivide is true, the translator will generate a right-shift when it encounters a division by a constant that is a small power of two. For example, 'x / 8' will generate '((int) x >> 3)'. The coercion to int is done to make it clear that the C compiler should generate a signed shift."		"Note: The Kernighan and Ritchie 2nd Edition C manual, p. 49, leaves the semantics of right-shifting a negative number open to the discretion of the compiler implementor. However, it strongly suggests that most compilers should generate an arithmetic right shift (i.e., shifting in the sign bit), which is the same as dividing by a power of two. If your compiler does not generate or simulate an arithmetic shift, then make this class variable false and re-translate."! !I am used to simulate the indexed access to any object during plugin simulation.!!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object instVarAt: index + offset + 1! !!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object instVarAt: index + offset + 1 put: value! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+ increment	^self clone += increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+= increment	offset _ offset + increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!- decrement	^self clone -= decrement! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!-= decrement	offset _ offset - decrement! !!CObjectAccessor methodsFor: 'printing' stamp: 'ar 9/16/1998 21:38'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:' on: ';		print: object.! !!CObjectAccessor methodsFor: 'private' stamp: 'ar 11/3/1998 22:37'!getObject	^object! !!CObjectAccessor methodsFor: 'private' stamp: 'ar 10/9/1998 21:56'!setObject: anObject	object _ anObject.	offset _ 0.! !!CObjectAccessor methodsFor: 'converting' stamp: 'ar 11/24/1998 20:51'!asPluggableAccessor: accessorArray	^((CPluggableAccessor on: object) += offset)		readBlock: accessorArray first		writeBlock: accessorArray last! !!CObjectAccessor class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 21:36'!on: anObject	^self new setObject: anObject! !!CPluggableAccessor methodsFor: 'initialize' stamp: 'ar 11/24/1998 20:51'!readBlock: rBlock writeBlock: wBlock	readBlock _ rBlock.	writeBlock _ wBlock! !!CPluggableAccessor methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:45'!at: index	^readBlock value: object value: index + offset + 1! !!CPluggableAccessor methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:45'!at: index put: value	^writeBlock value: object value: index + offset + 1 value: value! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:14'!generate: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage peer cacheFile file|	(request isKindOf: PWS)	ifFalse: [(request isKindOf: String) ifTrue: [peer _ request]ifFalse: [peer _ ' ']]	ifTrue: [peer _ request peerName].	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: peer					storingTo: OrderedCollection new]).	cacheFile _ (self cacheDirectory),(self name),(ServerActionpathSeparator),(pageRef coreID),'.html'.	(StandardFileStream isAFileNamed: cacheFile)	ifTrue: [FileDirectory deleteFilePath: cacheFile].	file _ FileStream fileNamed: cacheFile.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:15'!generateRecent	| file |	file _ FileStream fileNamed: (self cacheDirectory),(selfname),(ServerAction pathSeparator),'recent.html'.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source, 'recent.html')					with: urlmap recent).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 10/13/1998 12:29'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents: source, 'results.html')				with: (urlmap searchFor: (					request fields at: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only if logged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.		^ self].	"return self means do serve the edited page afterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag) withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.			^ self]].		"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/9/1998 21:34'!pageURL: aPage	"make the url suited to aPage"	^(self url),(self name),'/',aPage coreID,'.html'! !!CachedSwikiAction methodsFor: 'access' stamp: 'TPR 7/21/1998 18:05'!url	^cacheURL! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!extent	^ Display extent! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^false! !!Canvas methodsFor: 'testing' stamp: 'jm 5/30/1998 21:10'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!Canvas methodsFor: 'drawing' stamp: 'di 12/14/1998 13:07'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'di 12/14/1998 13:06'!image: aForm at: aPoint rule: combinationRule	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: combinationRule.! !!Canvas methodsFor: 'drawing' stamp: 'di 10/2/1998 21:39'!imageWithOpaqueWhite: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm but with the convention that zero represents opaque white."	self image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form over.! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:48'!line: pt1 to: pt2 brushForm: brush	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'private' stamp: 'di 10/2/1998 22:28'!shadowDrawing	^ shadowDrawing! !I represent the organization of the mail database into set of message lists called "categories". Each category contains a collection of message ID's. The same message may be cross-filed quite cheaply by storing it's ID in multiple categories.The categories information is kept in a binary file on the disk. It is read into memory in its entirety when the mail database is opened. To make changes persist, the categories information must be saved out to disk. This should be done after fetching new mail and when the mail database is closed. It could also be done periodically by some sort of background process. Note that the categories file, unlike the index file, cannot be re-created from the messages file.!!CategoriesFile methodsFor: 'categories access'!addCategory: categoryName	"Add a new category, if it doesn't already exist."	(self categories includes: categoryName) ifFalse:		[categories at: categoryName put: Set new].! !!CategoriesFile methodsFor: 'categories access'!categories	"Answer a collection of my categories, including the pseudo-categories '.unclassified.' and '.all.'. '.unclassified.' contains the orphaned messages that would otherwise not appear in any category. '.all.' contains all the messages in the database. Since these pseudo-categories are computed on the fly, there may be a noticable delay when one of them is selected."	^(categories keys)		add: '.all.';		add: '.unclassified.';		yourself! !!CategoriesFile methodsFor: 'categories access'!file: messageID inCategory: categoryName	"Add the given message ID to the given category. The target category must be a real category, not a pseudo-category."	(categoryName = '.unclassified.' | categoryName = '.all.') ifTrue: [^self].	(categories includesKey: categoryName) ifFalse:		[categories at: categoryName put: Set new].	(categories at: categoryName) add: messageID.! !!CategoriesFile methodsFor: 'categories access'!isUnclassified: messageID	"Answer true if the given message ID does not appear in any of my real (not pseudo) categories."	categories do:		[: category | (category includes: messageID) ifTrue: [^false]].	^true! !!CategoriesFile methodsFor: 'categories access'!messagesIn: category	"Answer a collection of message ID's for the messages in the given category. The pseudo-categories are dynamically computed and so they cannot be accessed in this manner."	^categories at: category ifAbsent: [#()]! !!CategoriesFile methodsFor: 'categories access'!remove: messageID fromCategory: categoryName	"Remove the given message ID from the given category."	| msgList |	msgList _ categories at: categoryName ifAbsent: [^self].	msgList remove: messageID ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeCategory: categoryName	"Remove the given category, if it exists."	categories removeKey: categoryName ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeMessagesInCategory: categoryName butNotIn: indexFile	"Used to clean the dead wood out of a category."	| oldMsgs newMsgs |	oldMsgs _ categories at: categoryName ifAbsent: [^self].	newMsgs _ oldMsgs copy.	oldMsgs do:		[: msgID |		 (indexFile includesKey: msgID) ifFalse:			[newMsgs remove: msgID]].	categories at: categoryName put: newMsgs.! !!CategoriesFile methodsFor: 'categories access' stamp: 'jm 10/4/1998 11:16'!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = '.all.' | oldName = '.unclassified.' |	 (self categories includes: newName)) ifTrue:		[^ self].  "can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!CategoriesFile methodsFor: 'categories access'!unclassifiedFrom: messageIDs	"Answer the subset of the given set of message ID's that do not appear in any category."	^messageIDs select:		[: msgID | self isUnclassified: msgID]! !!CategoriesFile methodsFor: 'read-write' stamp: 'jm 8/18/1998 16:24'!readFrom: aFileStream	"Read the categories from the given FileStream."	| name categorySize messageIDs |	categories _ Dictionary new: 64.	aFileStream binary; position: 0.	[aFileStream atEnd] whileFalse:		[name _ aFileStream ascii; nextString.		 categorySize _ aFileStream binary; nextWord.		 messageIDs _ Set new: categorySize * 4.		 categorySize timesRepeat:			[messageIDs add: aFileStream nextInt32].		 categories at: name put: messageIDs].! !!CategoriesFile methodsFor: 'read-write'!writeOn: aFileStream	"Write the categories to the given FileStream. The categories data is stored in binary (as opposed to a human-readable form) to save space."	aFileStream binary; position: 0.	categories associationsDo:		[: category |		 "(category key) is the category name"		 "(category value) is the set of message ID's in that category"		 aFileStream nextStringPut: (category key).		 aFileStream nextWordPut: (category value) size.		 (category value) do:			[: messageID |			 aFileStream nextInt32Put: messageID]].! !A viewer on an object.  Consists of three panes:   Header pane -- category-name, arrows for moving among categories, etc.   List pane -- contents are a list of subparts in the chosen category.   Editing pane -- optional, a detail pane with info relating to the selected element of the list pane.!!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/24/1998 23:10'!initializeFor: aPlayer	^ self initializeFor: aPlayer categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/25/1998 22:28'!initializeFor: aPlayer categoryChoice: aChoice	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 1;		beSticky.	self color: Color green muchLighter muchLighter.	scriptedPlayer _ aPlayer.	self addHeaderMorph.	self categoryChoice: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/9/1998 16:15'!categoryChoice: aCategory	| bin |	namePane contents: aCategory; color: Color black.	bin _ PhraseWrapperMorph new		borderWidth: 0;		orientation: #vertical.	bin addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: aCategory inViewer: self) collect:			[:aViewerRow | self viewerEntryFor: aViewerRow]).	bin enforceTileColorPolicy.	submorphs size < 2		ifTrue:			[self addMorphBack: bin]		ifFalse:			[self replaceSubmorph: self listPane by: bin].	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/3/1998 13:22'!chooseCategory	"The mouse went down on the receiver; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList _ scriptedPlayer categories.	aLinePosition _ aList indexOf: 'miscellaneous' ifAbsent: [nil].	lineList _ aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aMenu _ CustomMenu labels: aList lines: lineList selections: aList.	reply _ aMenu startUpWithCaption: 'category'.	reply ifNil: [^ self].	self categoryChoice: reply! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 14:09'!currentCategory	^ namePane contents! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:24'!downArrowHit	self previousCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:28'!nextCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [0].	newIndex _ anIndex = aList size		ifTrue:		[1]		ifFalse:		[anIndex + 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:31'!previousCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [aList size + 1].	newIndex _ anIndex = 1		ifTrue:		[aList size]		ifFalse:		[anIndex - 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:25'!upArrowHit	self nextCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/5/1998 09:09'!viewerEntryFor: aViewerRow	| anEntry |	anEntry _ ViewerEntry newColumn.	anEntry addMorphBack: aViewerRow.	^ anEntry! !!CategoryViewer methodsFor: 'editing pane' stamp: 'sw 10/30/1998 18:16'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	self beep.	^ false! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 11/5/1998 20:21'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Delete this Viewer'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	header beSticky.	self addMorph: header.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.		namePane _ (StringButtonMorph contents: '-----' "font: ScriptingSystem fontForScriptorButtons") color: Color black.	namePane target: self; arguments: Array new; actionSelector: #chooseCategory.	namePane actWhen: #buttonDown.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category'.	header addMorphBack: namePane.	self categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!CategoryViewer methodsFor: 'list pane' stamp: 'sw 10/23/1998 13:50'!listPane	^ submorphs second! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 10/30/1998 18:23'!addIsOverColorDetailTo: aRow	| clrTile readout aTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer".	aRow addMorphBack: (clrTile _ Color blue newTileMorphRepresentative).	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	readout _ UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile _ StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/9/1998 14:14'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton setBalloonText: 'menu'.	"aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot])."	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:31'!phraseForSlot: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a PhraseTileMorph representing the slot in the viewer"	| r anArrow |	r _ ViewerRow newRow		color: self color;		beSticky;		centering: #center.	r addDetailButton.	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: slotName type: partType).	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[readOnly ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				r addMorphBack: (anArrow _ self arrowSetterButtonFor: slotName type: partType)].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:37'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: scriptedPlayer costume;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!arrowSetterButtonFor: partName type: partType	| m |	m _ RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 1.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m on: #mouseDown send: #makeSetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!getterButtonFor: partName type: partType	| m |	m _ TileMorph new setOperator: partName.	m typeColor: (ScriptingSystem colorForType: partType).	m on: #mouseDown send: #makeGetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/21/1998 16:44'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 16:04'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType inViewer: self.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/30/1998 18:15'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/24/1998 23:41'!obtainBankInfoFrom: aViewer	self categoryChoice: aViewer currentCategory! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/29/1998 15:59'!tileForPlayer: aPlayer	"Return a tile representing aPlayer"	^ TileMorph new		setObjectRef: nil "disused parm" actualObject: aPlayer;		typeColor: (ScriptingSystem colorForType: #player)! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/21/1998 14:55'!tileForSelf	"Return a tile representing the target morph itself."	^ self tileForPlayer: scriptedPlayer! !A model for a morphic world view which will ask for confirmation before being closed, unless the corresponding preference is set to false. !!CautiousModel methodsFor: 'all' stamp: 'sw 9/15/1998 16:45'!okToChange	Preferences cautionBeforeClosing ifFalse: [^ true].	Sensor leftShiftDown ifTrue: [^ true].	self beep.	^ self confirm: 'Warning!!If you answer "yes" here, thiswindow will disappear andits contents will be lost!!Do you really want to do that?'"CautiousModel new okToChange"! !I am the core of a mail reading and organizing program. The name "Celeste" is a reference to an earlier mail reader named "Babar", which was written at Xerox PARC by Steve Putz and John Maloney.This object provides a user interface and some higher-level functionality for the application. The foundation of of the mail reader is really the mail database, implemented by the class MailDB.!!Celeste methodsFor: 'open-close' stamp: 'jm 10/4/1998 14:01'!close	"Close the mail database."	userPassword _ nil.	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil].! !!Celeste methodsFor: 'open-close' stamp: 'ls 9/13/1998 21:15'!openOnDatabase: aMailDB	"Initialize myself for the mail database with the given root filename."	mailDB _ aMailDB.	mailDB addDependent: self.	currentCategory _ 'new'.	lastCategory _ ''.	subjectFilter _ ''.	fromFilter _ ''.	dateFilter _ nil.	self setCategory: currentCategory.! !!Celeste methodsFor: 'open-close' stamp: 'jm 8/20/1998 18:37'!windowIsClosing	"Close the mail database when my window is closed."	self close.! !!Celeste methodsFor: 'categories pane'!addCategory	"Create a new category with the user-specified name. This does nothing if the category already exists."	| newCatName |	newCatName _ FillInTheBlank request: 'Name for new category?'.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB addCategory: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 09:24'!categoriesKeystroke: aCharacter	aCharacter asciiValue = 30 ifTrue: [self previousCategory].	aCharacter asciiValue = 31 ifTrue: [self nextCategory].! !!Celeste methodsFor: 'categories pane'!category	"Answer the currently selected category or nil."	^currentCategory! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:25'!categoryList	"Answer a list of categories for the categories pane."	^ mailDB allCategories! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/12/1998 09:33'!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\fetch mail\send queued mail\add category' withCRs.	lineSeparations _ #(1 2).	selectors _ #(save fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\import into category\export category (Celeste)\export category (Unix/Eudora)' withCRs.			lineSeparations _ lineSeparations, #(3 3).			selectors _ selectors, #(renameCategory removeCategory importIntoCategory exportCategory exportCategoryUnix)]		ifFalse: [			lineSeparations _ lineSeparations, #(1)].	labels _ labels, '\empty trash\compact\find duplicates\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(3 1 5).	selectors _ selectors, #(emptyTrash compact findDuplicates toggleSuppressHeaders setUserName setCCList setPopServer setPopUserName setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer)]		ifFalse: [labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching)].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [:i |		lines at: i put: ((lines at: i) + (lines at: i-1))].	^ aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane'!compact	"Compact the messages file."	| stats |	Transcript cr; show: 'Compacting message file...'.	Cursor execute showWhile: [stats _ mailDB compact].	Transcript show: 'Done.'; cr.	Transcript show:		'Recovered ',		(stats at: 1) printString, ' message',		(((stats at: 1) > 1) ifTrue: ['s, '] ifFalse: [', ']),		(stats at: 2) printString, ' bytes.'; cr.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!deleteMessagesAfterFetching	"start deleting messages off the server after POP-ing"	DeleteInboxAfterFetching _ true! !!Celeste methodsFor: 'categories pane'!emptyTrash	"Delete all messages in the '.trash.' category.	WARNING: The messages will be completely removed from the database."	| msgList |	msgList _ self filteredMessagesIn: '.trash.'.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB deleteAll: msgList.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategory	"Store the filtered message list of the current category to another mail database. The user is prompted for the name of the other database."	| destDBName destDB |	currentCategory ifNil: [ ^self ].	destDBName _ FillInTheBlank		request: 'Destination mail database?'		initialAnswer: ''.	(destDBName isEmpty) ifTrue: [^self].	destDB _ MailDB openOn: destDBName.	(destDB isNil) ifTrue: [^self].	destDB mergeMessages: (self filteredMessagesIn: currentCategory) from: mailDB.	destDB saveDB.	destDB changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategoryUnix	"Store the filtered message list of the current category into a Eudora/Unix database"	| destFileName destFile messageIds count |	currentCategory ifNil: [ ^self ].	destFileName _ FillInTheBlank		request: 'Destination mail file?'		initialAnswer: ''.	(destFileName isEmpty) ifTrue: [^self].	destFile _ FileStream fileNamed: destFileName.	destFile ifNil: [ ^self error: 'could not open file' ].	destFile setToEnd.	messageIds _ self filteredMessagesIn: currentCategory.	('exporting ', messageIds size printString, ' messages')		displayProgressAt: Sensor mousePoint		from: 0		to: messageIds size		during: [ :bar |			count _ 0.			messageIds do: [ :messageId |				destFile nextPutAll: Celeste eudoraSeparator.				(mailDB getMessage: messageId) text linesDo: [ :line |					(line beginsWith: 'From ') ifTrue: [ destFile nextPut: $> ].					destFile nextPutAll: line.					destFile cr ].				count _ count + 1.				bar value: count. ].		].	destFile close.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 14:06'!fetchMail	"Append messages from the user's mailbox to this mail database."	| server password msgCount |	server _ self class popServer.	password _ self popPassword.	(password isNil or: [password isEmpty]) ifTrue: [^ self].	msgCount _ mailDB fetchMailFromPOP: server		userName: self class popUserName		password: password		doFormatting: FormatWhenFetching		deleteFromServer: DeleteInboxAfterFetching.	msgCount < 0		ifTrue: [self inform: 'could not connect to the mail server']		ifFalse: [self inform: msgCount printString, ' messages fetched'].	msgCount <= 0 ifTrue: [^ self].	currentCategory _ 'new'. 	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:46'!findDuplicates	"Find duplicate messages, and move the redundant copies to a given category."	| duplicatesCategory |	duplicatesCategory _ FillInTheBlank		request: 'File duplicates in category?'		initialAnswer: 'duplicates'.	duplicatesCategory isEmpty ifTrue:[^ self].	Utilities informUser: 'Searching for duplicates...'		during: [mailDB fileDuplicatesIn: duplicatesCategory].	self changed: #categoryList.	self setCategory: duplicatesCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:17'!importIntoCategory	"Add the messages from a Unix or Eudora format file into this category"	| inboxPath count |	currentCategory ifNil: [ ^self ].	"get the file to import from"	inboxPath _ ''.	[	inboxPath _ FillInTheBlank request: 'file to import from?\(should be Eudora or Unix format)' withCRs.		inboxPath isEmpty ifTrue: [ ^self ].		FileStream isAFileNamed: inboxPath 	] whileFalse: [		self inform: 'file does not exist' ].	Utilities informUser: 'Fetching mail from ', inboxPath during: [		count _ mailDB importMailFrom: inboxPath  intoCategory: currentCategory. ].	self inform: count printString, ' messages imported'.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!keepMessagesOnServer	"start keeping messages on the server after POP-ing"	DeleteInboxAfterFetching _ false! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39'!nextCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i < catList size		ifTrue: [self setCategory: (catList at: i + 1)]		ifFalse: [self setCategory: (catList at: 1)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39'!previousCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i > 1		ifTrue: [self setCategory: (catList at: i - 1)]		ifFalse: [self setCategory: (catList at: catList size)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:37'!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	currentCategory ifNil: [ ^self ].	msgList _ mailDB messagesIn: currentCategory.	(mailDB messagesIn: '.trash.') do: [: id |		msgList remove: id ifAbsent: []].	msgList isEmpty ifFalse: [		(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].	mailDB removeCategory: currentCategory.	self changed: #categoryList.	self setCategory: nil.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:45'!renameCategory	"Rename the category with the user-specified name."	| newCatName |	currentCategory ifNil: [ ^self ].	newCatName _ FillInTheBlank		request: 'New name?'		initialAnswer: currentCategory.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB renameCategory: currentCategory to: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 18:34'!save	"Snapshot the database to disk."	mailDB saveDB.! !!Celeste methodsFor: 'categories pane'!setCCList	"Change the default cc: list for use in composing messages."	self class setCCList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 9/21/1998 11:03'!setCategory: newCategory	"Change the currently selected category. We must also compute the table of contents and message list for the new category."	| s |	currentCategory _ newCategory.	(newCategory isNil)		ifTrue: [			currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse: [			currentMessages _ self filteredMessagesIn: newCategory.			currentTOC _ OrderedCollection new: currentMessages size.			1 to: currentMessages size do: [:i |				s _ WriteStream on: (String new: 200).				s nextPutAll: i printString; space.				[s position < 4] whileTrue: [s space].				s nextPutAll: (mailDB getTOCstring: (currentMessages at: i)).				currentTOC add: s contents].			currentTOC _ currentTOC asArray.			(currentMessages includes: currentMsgID) ifFalse: [currentMsgID _ nil]].	self changed: #category.	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:37'!setPopServer	^self class setPopServer! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:39'!setPopUserName	^self class setPopUserName! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 02:31'!setSmtpServer	^self class setSmtpServer! !!Celeste methodsFor: 'categories pane'!setUserName	"Change the user's email name for use in composing messages."	self class setUserName.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:35'!toggleSuppressHeaders	SuppressWorthlessHeaderFields _ SuppressWorthlessHeaderFields not.	self changed: #messageText.! !!Celeste methodsFor: 'table of contents pane'!deleteAll	"Move all visible messages in the current category to '.trash.'."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: '.trash.'.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 16:32'!deleteMessage	"Move the current message to the '.trash.' category and select the next message. Deleted messages can later purged by invoking the 'deleteAll' command in the '.trash.' category."	currentMsgID isNil ifTrue: [^ self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: '.trash.'.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAgain	"File the current message in the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAll	"File all visible messages in the current category in some other category as well."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileMessage	"File the current message in another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!getCategoryNameIfNone: aBlock	"Prompt the user for a category name, remembering it for the next time."	| catList categoryName |	catList _ self categoryList.	catList remove: '.all.' ifAbsent: [].	catList remove: '.trash.' ifAbsent: [].	catList remove: '.unclassified.' ifAbsent: [].	catList add: '<new category>'.	((lastCategoryList ~= catList) or: [lastCategoryMenu = nil])		ifTrue: [lastCategoryMenu _ CustomMenu selections: catList].	categoryName _ lastCategoryMenu startUp.	categoryName = nil ifTrue: [^aBlock value].	categoryName = '<new category>' ifTrue: [		categoryName _ FillInTheBlank			request: 'New category name?'			initialAnswer: ''.		(categoryName isEmpty) ifTrue: [^aBlock value].		lastCategoryMenu _ nil.		mailDB addCategory: categoryName.		self changed: #categoryList.	].	lastCategoryList _ catList.	^lastCategory _ categoryName! !!Celeste methodsFor: 'table of contents pane'!moveAgain	"Move the current message to the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveAll	"Move all visible messages in the current category to another category."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveMessage	"Move the current message to another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:10'!nextMessage	"Select the next message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index < currentMessages size		ifTrue: [self setTOCEntry: (currentTOC at: index + 1)]		ifFalse: [self setTOCEntry: (currentTOC at: 1)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!otherCategories	"Prompt the user with a menu of all other categories in which the currently selected message appears. If the user chooses a category from this menu, go to that category."	| otherCategories choice |	otherCategories _		(mailDB categoriesThatInclude: currentMsgID) asOrderedCollection.	otherCategories remove: currentCategory ifAbsent: [].	(otherCategories isEmpty) ifTrue: [^self].	choice _ (CustomMenu selections: otherCategories) startUp.	choice = nil ifFalse: [self setCategory: choice].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:13'!previousMessage	"Select the previous message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index > 1		ifTrue: [self setTOCEntry: (currentTOC  at: index - 1)]		ifFalse: [self setTOCEntry: (currentTOC  at: currentMessages size)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane'!removeAll	"Remove all messages from the current category."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!removeMessage	"Remove the current message from the current category."	mailDB remove: currentMsgID fromCategory: currentCategory.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 12/14/1998 12:14'!saveMessage	"save the currently seleactead meassage to  file" 	| fileName file |	currentMsgID ifNil: [ ^self ].	fileName _ FillInTheBlank request: 'file to save in'.	fileName isEmpty ifTrue: [ ^self ].  	file _ FileStream fileNamed: fileName.	file nextPutAll: (mailDB getMessage: currentMsgID) text.	file close.! !!Celeste methodsFor: 'table of contents pane'!search	| destCat matchString msgText |	destCat _ FillInTheBlank		request: 'In what category should the search results be filed?'		initialAnswer: '.search results.'.	(destCat isEmpty) ifTrue: [^self].	matchString _ FillInTheBlank		request: 'String sought in message text?'		initialAnswer: ''.	(self filteredMessagesIn: currentCategory) do:		[: msgID |		 msgText _ mailDB getText: msgID.		 ((msgText findString: matchString startingAt: 1) > 0) ifTrue:			[mailDB file: msgID inCategory: destCat]].	self changed: #categoryList.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 10:35'!setTOCEntry: newTOCentry	"Change the currently selected message. This is done by finding the message ID corresponding to the selected table of contents entry."	| i |	(newTOCentry isNil | currentTOC isNil)		ifTrue: [currentMsgID _ nil]		ifFalse:			[i _ currentTOC indexOf: newTOCentry ifAbsent: [nil].			 (i isNil)				ifTrue: [currentMsgID _ nil]				ifFalse: [currentMsgID _ currentMessages at: i]].	self changed: #messageText.  "update the message pane"! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:56'!tocEntry	"Answer the table of contents entry for the currently selected message or nil."	(currentMsgID isNil)		ifTrue: [^nil]		ifFalse: [^currentTOC at: (currentMessages indexOf: currentMsgID)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocEntryList	"Answer a collection of table-of-contents entries for the currently selected category or an empty collection if no category is selected."	currentCategory		ifNil: [^ #()]		ifNotNil: [^ currentTOC].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocKeystroke: aCharacter	aCharacter = Character backspace ifTrue: [self deleteMessage].	aCharacter asciiValue = 30 ifTrue: [self previousMessage].	aCharacter asciiValue = 31 ifTrue: [self nextMessage].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 12/14/1998 12:17'!tocMenu: aMenu	"Answer the menu for the table of contents pane."	| labels lineSeparations selections lines |	currentCategory ifNil: [^ nil].	currentMsgID		ifNil: [			^ aMenu				labels: 'compose\file all\move all\remove all\delete all\search' withCRs				lines: #(1 5)				selections: #(compose fileAll moveAll removeAll deleteAll search)]		ifNotNil: [			labels _ 'delete\compose\reply\forward\'.			lineSeparations _ #(1 3).			selections _ #(deleteMessage compose reply forward).			lastCategory isEmpty ifFalse: [				labels _ labels, 'file -> ', lastCategory, '\move -> ', lastCategory, '\'.				lineSeparations _ lineSeparations, #(2).				selections _ selections, #( fileAgain moveAgain) ].			labels _ labels, 'file\move\remove\file all\move all\remove all\delete all\other categories\search\'.			lineSeparations _ lineSeparations, #(3 4 2).			selections _ selections, #(fileMessage moveMessage removeMessage fileAll moveAll removeAll deleteAll otherCategories search).			labels_ labels, 'save message\'.			lineSeparations _ lineSeparations , #(). 			selections _ selections , #(saveMessage). 			"convert lineSeperations into absolute line positions"			lines _ lineSeparations copy.			(2 to: lines size) do: [ :i |			lines at: i put: ((lines at: i) + (lines at: i-1)) ].			^aMenu labels: labels withCRs lines: lines  selections: selections		].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 9/10/1998 02:19'!updateTOC	"Update the table of contents after a moving, removing, or deleting a message. Select a message near the removed message in the table of contents if possible."	| currentMsgIndex |	((currentCategory isNil) |	 (currentMsgID isNil) |	 (currentMessages size < 2))		ifTrue: [currentMsgIndex _ 1]		ifFalse: [currentMsgIndex _ currentMessages indexOf: currentMsgID].	currentMsgID _ nil.	self setCategory: currentCategory.  "update currentMessages, currentTOC"	currentMessages isEmpty ifFalse: [		(currentMsgIndex <= currentMessages size)			ifTrue: [currentMsgID _ currentMessages at: currentMsgIndex]			ifFalse: [currentMsgID _ currentMessages last].	].	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/17/1998 16:20'!customFilterOff	"Cancel custom filtering."	customFilterBlock ifNil: [		"it's already turned off"		^self ].	customFilterBlock _ nil.	self updateTOC.	self changed: #isCustomFilterOn.! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/17/1998 16:20'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asSortedCollection asOrderedCollection.	filterList addFirst: '(none)'.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (CustomMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName ifNil: [ ^self ].	filterName = '(none)' ifTrue: [^self customFilterOff ].	filterName = '<delete a filter...>' ifTrue: [ ^self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.	self changed: #isCustomFilterOn.! !!Celeste methodsFor: 'filtering'!defineFilter	| filterName expr |	filterName _ FillInTheBlank request: 'Filter name?'.	filterName isEmpty ifTrue: [^''].	(CustomFilters includesKey: filterName)		ifTrue: [expr _ CustomFilters at: filterName]		ifFalse: [expr _ ''].	^self editFilterNamed: filterName filterExpr: expr! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!deleteFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to delete?'.	filterName = nil ifTrue: [^''].	CustomFilters removeKey: filterName ifAbsent: [].! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!editFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to edit?'.	filterName = nil ifTrue: [^''].	^self editFilterNamed: filterName filterExpr: (CustomFilters at: filterName)! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/15/1998 06:49'!editFilterNamed: filterName filterExpr: oldExpr	| newDefinition |	newDefinition _ FillInTheBlank		request:'Enter a filter definition where "m" is the message being testing. The expression can send"fromHas:", "toHas:", "ccHas:", "subjectHas:", "participantHas:", or "textHas:" to m to test forinclusion of a string--or one of an array of strings--in a field. It can also test m''s timeand/or date and can combine several tests with logical operators. Examples:      m fromHas: ''johnm''                       -- messages from johnm     m participantHas: ''johnm''                -- messages from, to, or cc-ing johnm     m textHas: #(squeak smalltalk java)      -- messages with any of these words     m subjectHas: #(0 1 2 3 4 5 6 7 8 9)       -- numbers in lists treated as strings NOTE: "textHas:" is very slow, since it must read the message from disk.'		initialAnswer: oldExpr.	newDefinition isEmpty ifTrue: [^''].	CustomFilters at: filterName put: newDefinition.	^newDefinition! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/14/1998 10:38'!filteredMessagesIn: categoryName	| msgList |	msgList _ mailDB messagesIn: categoryName.	(customFilterBlock notNil) ifTrue:		[msgList _ msgList select:			[: id | customFilterBlock value: (mailDB getTOCentry: id) ]].	(fromFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) from includesSubstring: fromFilter caseSensitive: false]].	(subjectFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) subject includesSubstring: subjectFilter caseSensitive: false]].	^msgList! !!Celeste methodsFor: 'filtering'!fromFilterOff	"Cancel from filtering."	fromFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!fromFilterOn	"Show only those messages from the same person as the currently selected message. The user is given a chance to edit the pattern string used to match 'From:' fields."	fromFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) from].	fromFilter _ FillInTheBlank		request: '''From:'' filter pattern?'		initialAnswer: fromFilter.	fromFilter _ self removeTrailingSeparators: fromFilter.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/15/1998 14:57'!isCustomFilterOn	"whether there is a custom filter in effect"	^customFilterBlock ~~ nil! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^ aString copyFrom: 1 to: i]		ifFalse: [^ ''].! !!Celeste methodsFor: 'filtering'!subjectFilterOff	"Cancel subject filter."	subjectFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/12/1998 19:37'!subjectFilterOn	"Show only those messages whose subject matches the currently selected message. The user is given a chance to edit the pattern string used to match 'Subject:' fields."	subjectFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) subject].	subjectFilter _ subjectFilter withBlanksTrimmed.	(subjectFilter asLowercase beginsWith: 're:') ifTrue: [		subjectFilter _ subjectFilter copyFrom: 4 to: subjectFilter size.		subjectFilter _ subjectFilter withBlanksTrimmed ].	subjectFilter _ FillInTheBlank		request: '''Subject:'' filter pattern?'		initialAnswer: subjectFilter.	subjectFilter _ self removeTrailingSeparators: subjectFilter.	self updateTOC.! !!Celeste methodsFor: 'message text pane'!changeMessage: newText	"Accept an edited version of a message and store it away. Answer true if successful."	(currentCategory isNil | currentMsgID isNil)		ifTrue: [^false]		ifFalse: [			mailDB newText: newText asString for: currentMsgID.			self updateTOC.			^ true].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:56'!compose	"Make a MailSendTool for composing a new message."	self openSender: self composeText.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItContext	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItReceiver	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:59'!format	messageTextView		editString: self formatedMessageText;		hasUnacceptedEdits: true.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 10/27/1998 13:55'!formatedMessageText	"Answer a string that is my formatted mail message."	| message header body bodyText |	currentMsgID isNil ifTrue: [^ ''].	message _ mailDB getMessage: currentMsgID.	header _ message cleanedHeader.	body _ message body.	body contentType = 'text/html'		ifTrue: [			bodyText _ (HtmlParser parse: body content readStream) formattedText. ]		ifFalse: [			bodyText _ body content ].	^header asText, String cr, bodyText! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:57'!forward	"Make a MailSendTool for forwarding the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self forwardTextFor: currentMsgID)].! !!Celeste methodsFor: 'message text pane'!message	"Answer the text of the currently selected message or nil if there isn't one."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getText: currentMsgID) asText]! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 08:14'!messageMenu	"Answer the menu for the message text pane."	(currentMsgID notNil)		ifTrue: [^CustomMenu			labels: 'again\undo\copy\cut\paste\format\accept\cancelcompose\reply\forward' withCRs			lines: #(2 5 6 8)			selections: #(again undo copySelection cut paste format accept cancelcompose reply forward)]		ifFalse: [^SelectionMenu			labels: 'again\undo\copy\cut\paste\compose' withCRs			lines: #(2 5)			selections: #(again undo copySelection cut paste compose)].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:28'!messageMenu: aMenu shifted: shifted	"Use the standard text menu."	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!Celeste methodsFor: 'message text pane' stamp: 'jm 10/2/1998 16:14'!messageText	(currentMsgID isNil) ifTrue: [^''].	SuppressWorthlessHeaderFields		ifTrue: [^ self formatedMessageText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 12:05'!messageText: aStringOrText	currentCategory isNil | currentMsgID isNil ifTrue: [^ self].	mailDB newText: aStringOrText asString for: currentMsgID.	self updateTOC.  "in case the message header was changed"	messageTextView hasUnacceptedEdits: false.	self changed: #messageText.	^ true! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/14/1998 15:13'!messageTextView: aView	messageTextView _ aView.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 03:08'!reply	"Make a MailSendTool for replying to the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self replyTextFor: currentMsgID)].! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 15:26'!clearUserEditFlag	messageTextView hasUnacceptedEdits: false.! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 08:14'!okToChange	"This message is sent when changing the selection in either the message cateory or message list panes. Eventually, this should ask the user if it is okay to throw away and unaccepted edits of the current message. For now, it always gives permission."	currentCategory isNil | currentMsgID isNil ifTrue: [		"no message selected; discard edits in message pane silently"		messageTextView hasUnacceptedEdits: false.		^ true].	messageTextView hasUnacceptedEdits ifFalse: [^ true].	(CustomMenu confirm: 'Discard changes to currently selected message?')		ifTrue: [messageTextView hasUnacceptedEdits: false. ^ true]		ifFalse: [^ false].! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 11:08'!perform: selector orSendTo: otherTarget	"Celeste handles all menu commands."	selector = #format ifTrue: [^ self perform: selector].	((#(yellowButtonActivity shiftedYellowButtonActivity) includes: selector) or:		[(PluggableTextController yellowButtonMessages includes: selector) or:		[PluggableTextController shiftedYellowButtonMessages includes: selector]])			ifTrue: [otherTarget perform: selector]			ifFalse: [self perform: selector].! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:55'!composeText	"Answer the template for a new message."	^ String streamContents: [:str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName; cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList; cr].		str cr].! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:56'!hasUsername: aString	"Answer true if the given string contains the user's name."	^((aString asLowercase)		findString: (Celeste userName) asLowercase		startingAt: 1) ~= 0! !!Celeste methodsFor: 'sending mail' stamp: 'ls 10/16/1998 09:09'!openSender: initialText	CelesteComposition openForCeleste: self  initialText: initialText.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/16/1998 00:34'!openSenderInMVC: initialText	| topWindow textHolder textView sendButton  |	topWindow _ StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250.	textHolder _ StringHolder new .	textHolder contents: initialText.	textView _ PluggableTextView		on: textHolder		text: #contents		accept: #acceptContents:.	sendButton _ PluggableButtonView 		on: [			textView hasUnacceptedEdits ifTrue: [ textView controller accept ].			self queueMessageWithText: textHolder contents.			topWindow controller close. ] fixTemps		getState: nil		action: #value.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	topWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	topWindow addSubView: textView below: sendButton.	topWindow controller open.		! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/14/1998 10:57'!openSenderInMorphic: initialText	"open an interface for sending a mail message with the given initial text"	| textHolder win textMorph buttonsList sendButton |	textHolder _ StringHolder new.	textHolder contents: initialText.	win _ SystemWindow labelled: 'Mister Postman'.		textMorph _ PluggableTextMorph on: textHolder text: #contents  accept: #acceptContents:.	win addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: [			textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].			self queueMessageWithText: textHolder contents.			win delete. ]		getState: nil		action: #value.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		win addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	win openInMVC.! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 14:23'!popPassword	"Answer the password to use when retrieving mail via POP3. The password is stored in an instance variable, which disappears when you close the Celeste window."	userPassword ifNotNil: [^ userPassword].	userPassword _ FillInTheBlank request: 'POP password'.	^ userPassword! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 11:11'!queueMessageWithText: aStringOrText	"Queue a message to be sent later. The message is added to the database and filed in the '.tosend.' category."	| messageText id |	"add a x-mailer line"	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText).	mailDB file: id inCategory: '.tosend.'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 10/15/1998 14:51'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s anyCCs |	msg _ mailDB getMessage: msgID.	s _ WriteStream on: (String new: 500).	"add From:"	s nextPutAll: 'From: ', Celeste userName; cr.	"add To:"	s nextPutAll: 'To: ', msg from; cr.	"add CC:s from the message and from the user's CC list"	s nextPutAll: 'CC: '.	anyCCs _ false.	(msg to isEmpty) ifFalse: [		anyCCs ifTrue:[ s nextPutAll: ', '] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg to ].	(msg cc isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg cc ].	(Celeste ccList isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].			s nextPutAll: Celeste ccList ].	s cr.	"add Subject:"	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	s cr.	"add contents of previous message"	s cr.	s nextPutAll: msg from; nextPutAll: ' wrote:'; cr.	msg bodyText linesDo: [ :line |		s nextPutAll: '> '.		s nextPutAll: line.		s cr ].	s cr.	^s contents! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:59'!sendQueuedMail	"Post queued messages to the SMTP server."	| outgoing sender n message recipients ok |	outgoing _ mailDB messagesIn: '.tosend.'.	outgoing isEmpty ifTrue: [^ self inform: 'no mail to be sent'].	sender _ (MailAddressParser addressesIn: self class userName) first.	('sending ', outgoing size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 1		to: outgoing size		during: [:progressBar |			n _ 0.			outgoing do: [:id |				progressBar value: (n _ n + 1).				message _ mailDB getMessage: id.				recipients _ Set new.				recipients addAll: (MailAddressParser addressesIn: message to).				recipients addAll: (MailAddressParser addressesIn: message cc).				ok _ SMTPSocket 					deliverMailFrom: sender					to: recipients 					text: message text 					usingServer: Celeste smtpServer.				ok					ifTrue: [						mailDB remove: id fromCategory: '.tosend.'.						mailDB file: id inCategory: '.sent.']					ifFalse: [^ self error: 'error posting mail']]].	mailDB saveDB.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'abc' stamp: 'ls 10/15/1998 14:51'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) bodyText, '-------------------------------'! !!Celeste class methodsFor: 'class initialization' stamp: 'jm 10/4/1998 13:55'!initialize	"Celeste initialize"	"user preferences"	CCList _ nil.	DeleteInboxAfterFetching _ false.	PopServer _ nil.	PopUserName _ nil.	SmtpServer _ nil.	SuppressWorthlessHeaderFields _ true.	UserName _ nil.	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:14'!versionString	"return a short string describing this version of Celeste"	^'Celeste 2.0'! !!Celeste class methodsFor: 'instance creation' stamp: 'ls 10/28/1998 14:28'!buildButtonsFor: model 	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on: (Switch new onAction: [model subjectFilterOn];				 offAction: [model subjectFilterOff]).	b label: 'Subj. F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass on: (Switch new onAction: [model fromFilterOn];				 offAction: [model fromFilterOff]).	b label: 'From F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass				on: model				getState: #isCustomFilterOn				action: #customFilterOn.	b label: 'Custom F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model compose]);			 action: #turnOn;			 label: 'New' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model reply]);			 action: #turnOn;			 label: 'Reply' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model forward]);			 action: #turnOn;			 label: 'Forward' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model moveAgain]);			 action: #turnOn;			 label: 'Move Again' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model deleteMessage]);			 action: #turnOn;			 label: 'Delete' asParagraph centered;			 borderWidth: 1.	buttons add: b.	^ buttons! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 9/21/1998 11:06'!buildViewsFor: model	"Answer a collection of window panes for the Celeste user interface."	| listViewClass textViewClass listFont views v |	Smalltalk isMorphic		ifTrue: [			listViewClass _ PluggableListMorphByItem.			textViewClass _ PluggableTextMorph]		ifFalse: [			listViewClass _ PluggableListViewByItem.			textViewClass _ PluggableTextView].	listFont _ StrikeFont allInstances		detect: [:f | (f name beginsWith: 'CourierFixed') and: [f height = 11]]		ifNone: [TextStyle default fontAt: 1].	views _ OrderedCollection new.	v _ listViewClass		on: model		list: #categoryList		selected: #category		changeSelected: #setCategory:		menu: #categoryMenu:		keystroke: #categoriesKeystroke:.	views add: v.	v _ listViewClass		on: model		list: #tocEntryList		selected: #tocEntry		changeSelected: #setTOCEntry:		menu: #tocMenu:		keystroke: #tocKeystroke:.	v font: listFont.	views add: v.	v _ textViewClass new		on: model		text: #messageText		accept: #messageText:		readSelection: nil		menu: #messageMenu:shifted:.	v borderWidth: 1.	model messageTextView: v.	views add: v.	^ views! !!Celeste class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 03:05'!openOn: rootFilename	"Open a MailReader on the mail database with the given root filename."	|database |	database _  MailDB openOn: rootFilename.	database ifNotNil: [ ^ self openOnDatabase: database ].! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 10/4/1998 14:46'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: [			topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 2) frame: (0.125@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 3) frame: (0.25@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 4) frame: (0.375@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 5) frame: (0.50@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 6) frame: (0.625@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 7) frame: (0.75@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 8) frame: (0.875@0.0 extent: 0.125@0.05).			topWindow addMorph: (views at: 1) frame: (0.0@0.05 extent: 0.2@0.25).			topWindow addMorph: (views at: 2) frame: (0.2@0.05 extent: 0.8@0.25).			topWindow addMorph: (views at: 3) frame: (0.0@0.30 extent: 1.0@0.70).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: [			topWindow _ StandardSystemView new				model: model;				label: 'Celeste';				minimumSize: 400@250.			(views at: 1) window: (0@0 extent: 20@25).			(views at: 2) window: (0@0 extent: 80@25).			(views at: 3) window: (0@0 extent: 100@70).			(buttons at: 1) window: (0@0 extent: 12@5).			(buttons at: 2) window: (0@0 extent: 12@5).			(buttons at: 3) window: (0@0 extent: 12@5).			(buttons at: 4) window: (0@0 extent: 10@5).			(buttons at: 5) window: (0@0 extent: 13@5).			(buttons at: 6) window: (0@0 extent: 13@5).			(buttons at: 7) window: (0@0 extent: 15@5).			(buttons at: 8) window: (0@0 extent: 13@5).			topWindow				addSubView: (buttons at: 1);				addSubView: (buttons at: 2) toRightOf: (buttons at: 1);				addSubView: (buttons at: 3) toRightOf: (buttons at: 2);				addSubView: (buttons at: 4) toRightOf: (buttons at: 3);				addSubView: (buttons at: 5) toRightOf: (buttons at: 4);				addSubView: (buttons at: 6) toRightOf: (buttons at: 5);				addSubView: (buttons at: 7) toRightOf: (buttons at: 6);				addSubView: (buttons at: 8) toRightOf: (buttons at: 7);				addSubView: (views at: 1) below: (buttons at: 1);				addSubView: (views at: 2) toRightOf: (views at: 1);				addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!ccList	"Answer the default cc list to be used in composing messages."	CCList isNil ifTrue: [CCList _ ''].	^CCList! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popServer	"Answer the server for downloading email via POP"	(PopServer isNil or: [PopServer isEmpty])		ifTrue: [self setPopServer].	PopServer isEmpty ifTrue: [		self error: 'POP server not specified' ].	^PopServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popUserName	"Answer the user's username on the POP server"	(PopUserName isNil or: [PopUserName isEmpty])		ifTrue: [self setPopUserName].	PopUserName isEmpty ifTrue: [ 		self error: 'no POP user name specified' ].	^PopUserName! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!setCCList	"Change the list of names used in the default cc list. Items in the list should be valid mail addresses and should be separated by commas."	| newList |	(CCList isNil) ifTrue: [CCList _ ''].	newList _ FillInTheBlank		request: 'addresses to automatically add to CC: fields?'		initialAnswer: CCList.	CCList _ newList.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopServer	"Change the user's email name for use in composing messages."	(PopServer isNil) ifTrue: [PopServer _ ''].	PopServer _ FillInTheBlank		request: 'What is your POP server''s hostname?'		initialAnswer: PopServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopUserName	"set the POP server used for downloading email"	(PopUserName isNil) ifTrue: [PopUserName _ ''].	PopUserName _ FillInTheBlank		request: 'What is your username on your POP server?'		initialAnswer: PopUserName.	"be kind, if they include the host name here"	(PopUserName includes: $@) ifTrue: [		PopUserName _ PopUserName copyFrom: 1 to: (PopUserName indexOf: $@)-1 ].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setSmtpServer	"Set the SMTP server used to send outgoing messages via"	(SmtpServer isNil) ifTrue: [		PopServer isNil			ifTrue: [ SmtpServer _ '' ]			ifFalse: [ SmtpServer _ PopServer ] ].	SmtpServer _ FillInTheBlank		request: 'What is your mail server for outgoing mail?'		initialAnswer: SmtpServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:49'!setUserName	"Change the user's email name for use in composing messages."	(UserName isNil) ifTrue: [UserName _ ''].	UserName _ FillInTheBlank		request: 'What is your email address?\(This is the address other people will reply to you)' withCRs		initialAnswer: UserName.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!smtpServer	"Answer the server for sending email"	(SmtpServer isNil or: [SmtpServer isEmpty])		ifTrue: [self setSmtpServer].	SmtpServer isEmpty ifTrue: [		self error: 'no SMTP server specified' ].	^SmtpServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!userName	"Answer the user name to be used in composing messages."	(UserName isNil or: [UserName isEmpty])		ifTrue: [self setUserName].	UserName isEmpty ifTrue: [ self error: 'no user name specified' ].	^UserName! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/20/1998 11:48'!addMVCMailSenderButtons: topView textView: mailTextView	"Add some handy buttons to the mail sender window."	| sendButton sendAndKeepButton doneButton |	sendButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents]);			action: #turnOn;			label: ('Send' asParagraph centered);			window: (0@0 extent: 34@10);			borderWidth: 1.	sendAndKeepButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents.					 Celeste addMessageToInbox: mailTextView model contents]);			action: #turnOn;			label: ('Send&Keep' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	doneButton _		PluggableButtonView new			model: (Button new onAction: [topView controller close]);			action: #turnOn;			label: ('Done' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	topView		addSubView: sendButton above: topView firstSubView;		addSubView: sendAndKeepButton toRightOf: sendButton;		addSubView: doneButton toRightOf: sendAndKeepButton.! !!Celeste class methodsFor: 'sending' stamp: 'jm 10/2/1998 16:24'!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	self inform:'The "keep" feature is not yet implemented;please cc: yourself to retain a copy of your message.'! !!Celeste class methodsFor: 'sending'!eudoraSeparator	"Return a Eudora-style message separator string."	| s today dateString |	s _ WriteStream on: (String new: 50).	today _ Date today.	dateString _ today printFormat: #(2 1 3 32 2 1).	dateString _ dateString copyFrom: 1 to: dateString size - 4.	s nextPutAll: 'From ???@??? '.	s nextPutAll: (today weekday copyFrom: 1 to: 3); space.	s nextPutAll: dateString.	Time now print24: true on: s.	s space.	s print: today year; cr.	^s contents! !a message being composed.  When finished, it will be submitted via a Celeste.!!CelesteComposition methodsFor: 'private' stamp: 'ls 1/3/1999 15:51'!breakLines: aString  atWidth: width	"break lines in the given string into shorter lines"	| result start end |true ifTrue: [ ^aString ].	result _ WriteStream on: (String new: (aString size * 50 // 49)).	aString asString linesDo: [ :line | 		start _ 1.		"output one shorter line each time through this loop"		[ start + width <= line size ] whileTrue: [			"find the end of the line"			end _ start + width - 1.			[end >= start and: [ (line at: (end+1)) isSeparator not ]] whileTrue: [				end _ end - 1 ].			end < start ifTrue: [				"a word spans the entire width!!"				end _ start + width - 1 ].			"copy the line to the output"			result nextPutAll: (line copyFrom: start to: end).			result cr.			"get ready for next iteration"			start _ end+1.			(line at: start) isSeparator ifTrue: [ start _ start + 1 ].		].		"write out the final part of the line"		result nextPutAll: (line copyFrom: start to: line size).		result cr.	].	^result contents! !!CelesteComposition methodsFor: 'access' stamp: 'ls 10/15/1998 21:52'!messageText	"return the current text"	^messageText! !!CelesteComposition methodsFor: 'access' stamp: 'ls 10/16/1998 09:16'!messageText: aText	"change the current text"	messageText _ aText.	self changed: #messageText.	^true! !!CelesteComposition methodsFor: 'access' stamp: 'ls 1/3/1999 15:04'!submit	"submit the message"	textEditor ifNotNil: [		self hasUnacceptedEdits ifTrue: [ textEditor accept ] ].	celeste queueMessageWithText: (self breakLines: messageText atWidth: 72).	morphicWindow ifNotNil: [ morphicWindow delete ].	mvcWindow ifNotNil: [ mvcWindow controller close ].! !!CelesteComposition methodsFor: 'initialization' stamp: 'ls 10/15/1998 21:51'!celeste: aCeleste  initialText: aText	celeste _ aCeleste.	messageText _ aText.! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:11'!open	"open an interface"	Smalltalk isMorphic		ifTrue: [ self openInMorphic ]		ifFalse: [ self openInMVC ]! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:17'!openInMVC	| textView sendButton  |	mvcWindow _ StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250;		model: self.	textView _ PluggableTextView		on: self		text: #messageText		accept: #messageText:.	textEditor _ textView controller.	sendButton _ PluggableButtonView 		on: self		getState: nil		action: #submit.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	mvcWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	mvcWindow addSubView: textView below: sendButton.	mvcWindow controller open.		! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:17'!openInMorphic	"open an interface for sending a mail message with the given initial text"	| textMorph buttonsList sendButton |	morphicWindow _ SystemWindow labelled: 'Mister Postman'.	morphicWindow model: self.		textEditor _ textMorph _ PluggableTextMorph 		on: self 		text: #messageText  		accept: #messageText:.	morphicWindow addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: self getState: nil	 action: #submit.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		morphicWindow addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	morphicWindow openInMVC.! !!CelesteComposition class methodsFor: 'instance creation' stamp: 'ls 10/16/1998 09:08'!celeste: aCeleste  initialText: initialText	"create an instance for the given mail reader, editting the given text"	^self new celeste: aCeleste  initialText: initialText! !!CelesteComposition class methodsFor: 'instance creation' stamp: 'ls 10/16/1998 09:08'!openForCeleste: aCeleste  initialText: initialText	"open a composition window for the given mail reader, editting the given text"	(self celeste: aCeleste  initialText: initialText) open! !!ChangeList methodsFor: 'scanning' stamp: 'sw 11/19/1998 16:00'!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[prevChar = Character cr ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'scanning' stamp: 'sw 9/10/1998 15:17'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ prevPos // 16r1000000.						prevPos _ prevPos \\ 16r1000000]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'menu actions' stamp: 'di 1/13/1999 15:48'!changeListMenu: aMenu^ aMenu labels:'fileIn selectionsfileOut selections...compare to currentselect conflictsselect conflicts withselect unchanged methodsselect methods for this classselect alldeselect allremove doItsremove older versionsremove selections'	lines: #(2 9)	selections: #(fileInSelections fileOutSelectionscompareToCurrentVersion selectConflicts selectConflictsWith selectUnchangedMethods selectMethodsForThisClass selectAll deselectAllremoveDoIts removeOlderMethodVersions removeSelections)! !!ChangeList methodsFor: 'menu actions' stamp: 'di 1/13/1999 14:34'!compareToCurrentVersion	"If the current selection corresponds to a method in the system,	then spawn a window showing the diffs as text"	| change class s1 s2 |	listIndex = 0 ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])	ifTrue:		[s1 _ (class sourceCodeAt: change methodSelector) asString.		s2 _ change string.		s1 = s2 ifTrue: [^ self inform: 'Exact Match'].		(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))			openLabel: 'Comparison to Current Version']	ifFalse:		[self flash].! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 11/14/1998 14:30'!selectMethodsForThisClass	| name |	self currentChange ifNil: [ ^self ].	name _ self currentChange methodClassName.	name ifNil: [ ^self ].	^self selectSuchThat: [ :change |		change methodClassName = name ].! !!ChangeList methodsFor: 'viewing access' stamp: 'di 1/13/1999 14:59'!listSelectionAt: index put: value	^ listSelections at: index put: value! !!ChangeList methodsFor: 'viewing access' stamp: 'di 1/15/1999 01:12'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self changed: #contents! !!ChangeList methodsFor: 'accessing' stamp: 'TPR 11/28/1998 17:38'!listHasSingleEntry	"does the list of changes have only a single item?"	^list size = 1! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/12/1998 16:33'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'public access' stamp: 'di 1/13/1999 12:37'!browseVersionsOf: method class: class meta: meta		category: category selector: selector 	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[changeList listHasSingleEntry ifTrue:				[^ self inform: 'No older versions of this method'].			self open: changeList name: 'Recent versions of ' ,selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'di 1/13/1999 12:39'!browseVersionsOf: method class: class meta: meta		category: category selector: selector lostMethodPointer: sourcePointer	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[changeList listHasSingleEntry ifTrue:				[^ self inform: 'No older versions of this method'].			changeList setLostMethodPointer: sourcePointer.			self open: changeList name: 'Recent versions of ' , selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:39'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  6/28/96 sw"		| method aChangeList |	method _ aClass compiledMethodAt: aSelector.	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !!ChangeList class methodsFor: 'instance creation' stamp: 'di 11/10/1998 13:34'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: ((multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!ChangeRecord methodsFor: 'access'!category	^category! !!ChangeRecord methodsFor: 'access' stamp: 'sw 8/24/1998 08:16'!fileIn	| methodClass |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil].		(type == #doIt) ifTrue:			[Compiler evaluate: self string].		(type == #classComment) ifTrue:			[(Smalltalk at: class asSymbol) comment: self text stamp: stamp]]! !!ChangeRecord methodsFor: 'access'!isMetaClassChange	^meta! !!ChangeRecord methodsFor: 'access'!methodClassName	^class! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!!!!!!!!!!!!!! 9/23/1998 23:05'!addClass: class 	"Include indication that a new class was created."	self atClass: class add: #add.	self addCoherency: class name! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!!!!!!!!!!!!!! 9/23/1998 23:06'!changeClass: class 	"Include indication that a class definition has been changed. 	 6/10/96 sw: don't accumulate this information for classes that don't want logging	 7/12/96 sw: use wantsChangeSetLogging flag"	class wantsChangeSetLogging ifTrue: 		[			self atClass: class add: #change.			self addCoherency: class name		]! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 16:05'!expungeEmptyClassChangeEntries	| toRemove |	toRemove _ OrderedCollection new.	classChanges associationsDo:		[:assoc | assoc value isEmpty ifTrue:			[toRemove add: assoc key]]. 	toRemove do:		[:aKey | classChanges removeKey: aKey ifAbsent: []]! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 14:36'!forgetAllChangesFoundIn: aChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner.	sw 8/14/1998 17:30:  This method somehow became very badly, and damagingly, broken since I originally wrote it.  Below is an attempt to bring it back to health, or at least to remove the most damaging of its bugs."	| cls itsMethodChanges myClassChange |	aChangeSet == self ifTrue: [^ self].	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo:					[:assoc | self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]]]].	classRemoves removeAllFoundIn: aChangeSet classRemoves.	"names of them"	self expungeEmptyClassChangeEntries! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/14/1998 17:22'!removeAllMemoryOfChangesTo: class	"Remove all memory of changes associated with this class"	classChanges removeKey: class name ifAbsent: [].	methodChanges removeKey: class name ifAbsent: [].	classRemoves remove: class name ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/22/1998 21:12'!removeAllMemoryOfChangesToClassNamed: className	"Remove all memory of changes associated with this class"	classChanges removeKey: className ifAbsent: [].	methodChanges removeKey: className ifAbsent: [].	classRemoves remove: className ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'ls 8/12/1998 23:47'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	classChanges removeKey:  cname ifAbsent: [].	methodChanges removeKey:  cname ifAbsent: [].	classRemoves remove:  cname ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!!!!!!!!!!!!!! 9/23/1998 23:16'!verifyClassRemoves	"Verify the internal collection of classes to be	removed. For every class name there, check if	a class named like that exists. If it does, then	remove it from the classRemoves. If it doesn't, 	leave it alone. Use this to fix change sets broken	by classes deleted and then added back.	Also, delete the deleted items that are not symbols (?!!)"	classRemoves _ classRemoves reject: [:one | (Smalltalk at: one ifAbsent: []) isNil not or: [one ~~ one asSymbol]]! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 8/14/1998 17:16'!forgetChange: actionToSubtract forSelector: selector class: class 	"If the receiver records a change that can be subsumed by the change given by the parameters, which characterize a change in another change set which is being 'subtracted' from the receiver, remove it from the receiver."	| myChangeDictionaryForClass methodCurrentlyExists |	myChangeDictionaryForClass _ methodChanges at: class name ifAbsent: [^ self].	methodCurrentlyExists _ class includesSelector: selector.	((#(add change) includes: actionToSubtract) and: [methodCurrentlyExists])		ifTrue:			[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	((#(remove addedThenRemoved) includes: actionToSubtract) and: [methodCurrentlyExists not])			ifTrue:				[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	myChangeDictionaryForClass isEmpty ifTrue: [methodChanges removeKey: class name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 8/10/1998 07:13'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips changes method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		changes _ methodChanges at: aClass name ifAbsent: [nil].		changes ifNotNil:			[changes associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 1/8/1999 08:00'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	"wod 5/12/1998: use #asFileName rather than #truncateTo:"	| file slips |	Cursor write showWhile:		[file _ FileStream newFileNamed:			(self name, FileDirectory dot, Utilities dateTimeSuffix, FileDirectory dot, 'cs') asFileName.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	DeepCopier new checkVariables.	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 10/27/1998 13:53'!lookForSlips	| slips |	slips _ self checkForSlips.	slips size == 0 ifTrue:		[^ self inform: 'No slips detected in thecurrent change set.'].	(self confirm:'Some methods in the current change sethave halts or references to the Transcriptor other ''slips'' in them.Would you like to browse them?')		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/10/1998 12:37'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 11/8/1998 16:36'!summaryString	"Answer the string summarizing this changeSet"	| ps s2 date author line |	^ String streamContents:		[:s |		s nextPutAll: self name.		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:		'.  date _ s2 upTo: Character cr.			s2 match: 'Author:			'.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]]."To summarize all recent changeSets...(FileStream newFileNamed: 'ChangeSummaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialInteger >= 373]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);	close"! !!ChangeSet methodsFor: 'private' stamp: 'SqR!!!!!!!!!!!!!!!! 9/23/1998 23:08'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]! !!ChangeSet methodsFor: 'private' stamp: 'sw 9/2/1998 14:24'!fileOutClassModifications: class on: stream 	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes."	| aClass |	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #comment) ifTrue:		[(aClass _ class theNonMetaClass) organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: aClass].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'accessing' stamp: 'di 5/25/1998 14:24'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:43'!oldOpenAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| buttonView col aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	buttonView _ PluggableButtonMorph		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	col _ Color perform: self defaultBackgroundColor.	buttonView		label: myChangeSet name; 		onColor: col offColor: col;		triggerOnMouseDown: true; borderColor: window color.	window addMorph: buttonView		frame: (((0@0 extent: 1.0@0.06) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0.5@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.36 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/8/1998 17:35'!oldOpenView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView buttonView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	buttonView _ PluggableButtonView		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	buttonView		label: myChangeSet name;		triggerOnMouseDown: true; borderWidth: 1; 		window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	topView addSubView: buttonView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: classView below: buttonView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: messageView toRightOf: classView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'creation' stamp: 'jm 7/5/1998 12:35'!openAsMorph	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	window openInWorld.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 16:48'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| chgSetList aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (chgSetList _ PluggableListMorphByItem on: self			list: #changeSetList			selected: #currentCngSet			changeSelected: #showChangeSetNamed:			menu: #changeSetMenu:)		frame: (((0@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	chgSetList autoDeselect: false.	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0.5@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph  menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0@0.25 extent: 1@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.5 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:18'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:.	cngSetListView window: ((0 @ 0 extent: 180 @ 100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (180 @ 0 extent: 180 @ 100).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: (0 @ 100 extent: 360 @ 100).	topView addSubView: messageView below: cngSetListView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: messageView.! !!ChangeSorter methodsFor: 'access' stamp: 'di 6/15/1998 20:33'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 08:15'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self changed: #contents.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 07:38'!showChangeSetNamed: aName	aName ifNil: [^ self showChangeSet: nil].	self showChangeSet: 		(AllChangeSets detect: [:each | each name = aName]) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/12/1998 16:29'!changeSetList	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	^ AllChangeSets reversed collect: [:each | each name]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 1/9/1999 22:53'!changeSetMenu: aMenu 	"Could be for a single or double changeSorter"	parent ifNotNil: [	^ aMenu labels: 'make changes go to menew...file into new...find...show...updatefileOutbrowserenamecopy all to other sidesubmerge into other sidesubtract other sideedit preamble...edit postscript...clearremove'		lines: #(1 3 9 12 14 )		selections: #(newCurrent newSet fileIntoNewChangeSet findCngSet chooseCngSet update fileOut browseChangeSet rename copyAllToOther submergeIntoOtherSide subtractOtherSide editPreamble editPostscript clearChangeSet remove )]	ifNil: ["Single ChangeSorter"	^ aMenu labels: 'make changes go to menew...file into new...find...show...updatefileOutbrowserenameedit preamble...edit postscript...clearremove'		lines: #(1 3 9 11)		selections: #(newCurrent newSet fileIntoNewChangeSet findCngSet chooseCngSet update fileOut browseChangeSet rename editPreamble editPostscript clearChangeSet remove )]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/8/1999 14:52'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| index changeSetsSortedAlphabetically |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	changeSetsSortedAlphabetically _ AllChangeSets asSortedCollection:		[:a :b | a name asLowercase withoutLeadingDigits < b name asLowercase withoutLeadingDigits].	index _ (PopUpMenu labels: 		(changeSetsSortedAlphabetically collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (changeSetsSortedAlphabetically at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 11/22/1998 23:57'!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a new change set whose name is a function of the filename.  Show the new set and leave the current changeSet unaltered."	| aFileName  aNewChangeSet |	self okToChange ifFalse: [^ self].	aFileName _ FillInTheBlank request: 'Name of file to be imported: '.	aFileName size == 0 ifTrue: [^ self].	(FileDirectory default fileExists: aFileName) ifFalse:		[^ self inform: 'Sorry -- cannot find that file'].	aNewChangeSet _ self class 			newChangesFromStream: (FileStream readOnlyFileNamed: aFileName) 			named: aFileName.	aNewChangeSet ifNotNil: [self showChangeSet: aNewChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 1/9/1999 22:53'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	pattern _ FillInTheBlank request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	candidates _ AllChangeSets select:			[:c | c name includesSubstring: pattern caseSensitive: false].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index _ (PopUpMenu labels: 		(candidates collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 9/4/1998 09:00'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self update.		self showChangeSet: aSet.		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 11:58'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self inform: 'No change made'].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/15/1998 11:29'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	self class gatherChangeSets.	parent modelWakeUp.	"(parent other: self) changed: #classList.	(parent other: self) changed: #messageList."! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:19'!updateIfNecessary	"recompute all of my panes"	| newList |	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:07'!classMenu: aMenu	"Could be for a single or double changeSorter"	^ parent ifNotNil:		[aMenu labels: 'copy class chgs to other sidemove class chgs to other sidedelete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(3 4 )		selections: #(copyClassToOther moveClassToOther forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]	ifNil:		[ aMenu labels: 'delete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(1 2 )		selections: #(forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:17'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	| info cls otherSorter otherChangeSet |	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet == myChangeSet ifTrue: [^ self beep].	(myChangeSet classRemoves includes: currentClassName)		ifTrue:			[otherChangeSet noteRemovalOf: currentClassName]		ifFalse:			[info _ myChangeSet classChangeAt: (cls _ self selectedClassOrMetaClass) name.			info do: [:each | otherChangeSet atClass: cls add: each].			info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].			info associationsDo: [:ass |				otherChangeSet atSelector: ass key class: cls put: ass value]].	otherSorter showChangeSet: otherChangeSet.	self forgetClass! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 12/7/1998 09:43'!selectedClass	"Answer the currently-selected class.  If there is no selection, or if the selection refers to a class no longer extant, return nil"	| c |	^ currentClassName ifNotNil: [(c _ self selectedClassOrMetaClass)		ifNotNil: [c theNonMetaClass]]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:57'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil:		[^ aMenu labels: 'copy method to other sidemove method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 4 7 11)		selections: #(copyMethodToOther moveMethodToOtherforget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]	ifNil: [^ aMenu labels: 'delete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 5 9 )		selections: #( forget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:56'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other info cls sel |	self okToChange ifFalse: [^ self beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].		other atSelector: sel			class: cls 			put: (info at: sel).			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:44'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionrevert and forgetmore...' 	lines: #(5 7 9)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 12/7/1998 14:10'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class _ self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size == 0]) ifTrue: [ ^ false].		myChangeSet preambleString: aString.		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"		^ true].	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 12/7/1998 13:32'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr]].			^ contents _ strm contents].! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/8/1998 16:31'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ (self allChangeSetNames		select: [:csName | nameBlock value: csName])		collect: [:csName | self changeSetNamed: csName]! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 9/4/1998 14:38'!newChangeSet	"Prompt the user for a name, and establish a new change set of that name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank request: 'Please name the new change set:'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue:		[self inform: 'nothing done'.		^ nil].	(self changeSetNamed: newName) ifNotNil:			[self inform: 'Sorry that name is already used'.			^ nil].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	Smalltalk newChanges: newSet.	Transcript cr; show: newName, ' is now the current change set'.	^ newSet! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 11/22/1998 23:59'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose name is derived from aName.  Leave the 'current change set' unchanged.   Returns the new change set;  Returns nil on failure."	|  newName aNewChangeSet existingChanges |	existingChanges _ Smalltalk changes.	newName _ aName sansPeriodSuffix.	(self changeSetNamed: newName) ~~ nil		ifTrue:			[self inform: 'Sorry -- "', newName, '" is already used as a change-set name'.			aStream close.			^ nil].	aNewChangeSet _ ChangeSet new initialize.	aNewChangeSet name: newName.	AllChangeSets add: aNewChangeSet.	Smalltalk newChanges: aNewChangeSet.	aStream fileInAnnouncing: 'Loading ', newName, '...'.	Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName.	Smalltalk newChanges: existingChanges.	^ aNewChangeSet! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/8/1998 16:32'!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | AllChangeSets remove: cs wither]! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/9/1998 10:23'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | AllChangeSets remove: cs wither].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  "	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented.	self openMessageList: messageSet name: ('Methods in Change Set ', aChangeSet name) autoSelect: nil changeSet: aChangeSet! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	| messageSet |	messageSet _ self messageList: messageList.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: autoSelectString.	World		ifNotNil:			[self openAsMorph: messageSet name: labelString]		ifNil:			[ScheduledControllers scheduleActive:  (self open: messageSet name: labelString)]! !Alan Kay's "one-page" character recognizer.  Currently hooked up to text panes and to text morphs, such that you can get it started by hitting cmd-r in such text area that currently has focus.  To reinitialize the recognition dictionary, evaluate	CharRecog reinitializeCharacterDictionary !!CharRecog methodsFor: 'recognizer' stamp: 'sw 12/16/1998 13:18'!stringForUnrecognizedFeatures: features	"Prompt the user for what string the current features represent, and return the result.  9/18/96 sw"	| result |	result _ FillInTheBlank request:('Not recognized. type char, or "tab", "cr" or "bs",or hit return to ignore ', features).	textMorph ifNotNil:		[textMorph world doOneCycle "take down the FillInTheBlank morph"].	^ (result = '~' | result = '')		ifTrue:			['']		ifFalse:			[CharacterDictionary at: features put: result. result]! !!CharRecog methodsFor: 'morphic dockup' stamp: 'sw 12/16/1998 13:17'!textMorph: aTextMorph	textMorph _ aTextMorph! !!Character methodsFor: 'testing' stamp: 'ls 7/26/1998 20:27'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^self isAlphaNumeric or: [ '.~-_' includes: self ]! !!Character methodsFor: 'copying' stamp: 'tk 1/7/1999 16:50'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied."! !!Character methodsFor: 'converting' stamp: 'ls 9/5/1998 01:18'!asIRCLowercase	"convert to lowercase, using IRC's rules"	self == $[ ifTrue: [ ^ ${ ].	self == $] ifTrue: [ ^ $} ].	self == $\ ifTrue: [ ^ $| ].	^self asLowercase! !!Character class methodsFor: 'instance creation' stamp: 'ls 8/15/1998 06:56'!allCharacters	^ (0 to: 255)		collect: [:v | Character value: v]	! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/8/1998 22:15'!lf	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/14/1998 22:08'!nbsp	"non-breakable space.  It looks like a space, but it's not considered a separator"	#xxx. "the correct code for ISO 8859-1 is 160.  However, Squeak's character 160 doesn't look right.  If you value absolute correctness over looks, then change this back"	"Character value: 160"	^Character value: 0! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:55'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel isNil ifTrue: [ 0 ] ifFalse: [ indentationLevel ]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:54'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 14:55'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	destX _ destX + (width _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + width) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis fo rnext run"	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 19:45'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta displaying: display 	"This method will perform text scanning with non-zero kerning.	It calls the faster primitive method, if the kern delta is zero.	Some day we may want to put kerning into the primitive."	| ascii nextDestX maxAscii fillBlt |	line first = startIndex ifTrue: [		"handle indentation"		self indentationLevel timesRepeat: [ self tab ] ].		kernDelta = 0 ifTrue:		[^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString				rightX: rightX stopConditions: stops displaying: display].	display ifTrue: [fillBlt _ self fillBlt].	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue:				[self copyBits				fillBlt == nil ifFalse:					[fillBlt destX: nextDestX destY: destY							width: kernDelta height: height;							copyBits]].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private' stamp: 'ls 7/16/1998 01:39'!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	alignment _ textStyle alignment.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !A set of characters.  Lookups for inclusion are very fast.!!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:33'!add: aCharacter	map at: aCharacter asciiValue+1  put: 1.! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:41'!do: aBlock	"evaluate aBlock with each character in the set"	Character allCharacters do: [ :c |		(self includes: c) ifTrue: [ aBlock value: c ] ]! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:31'!includes: aCharacter	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:34'!remove: aCharacter	map at: aCharacter asciiValue + 1  put: 0! !!CharacterSet methodsFor: 'conversion' stamp: 'ls 8/17/1998 20:39'!complement	"return a character set containing precisely the characters the receiver does not"	| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!= anObject	^self class == anObject class and: [		self byteArrayMap = anObject byteArrayMap ]! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!hash	^self byteArrayMap hash! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:35'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^map! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map _ ByteArray new: 256 withAll: 0.! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set _ self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:36'!empty 	"return an empty set of characters"	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:31'!new	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection _ self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!nonSeparators	"return a set containing everything but the whitespace characters"	^self separators complement! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set _ self empty.	set addAll: Character separators.	^set! !!Class methodsFor: 'initialize-release' stamp: 'sw 8/11/1998 13:23'!removeFromSystemUnlogged	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"	Smalltalk removeClassFromSystemUnlogged: self.	self obsolete! !!Class methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 09:53'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver and redefine its subclasses if necessary."	super		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	self ~~ oldClass		ifTrue: 			[environ at: name put: self.			oldClass obsolete]! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:15'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: self instanceVariablesString , aString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:16'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: newInstVarString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:18'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	self isVariable		ifTrue: 			[self isPointers 				ifTrue: [^self							variableSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			self isBytes 				ifTrue: [^self							variableByteSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			^self				variableWordSubclass: t				instanceVariableNames: f				classVariableNames: d				poolDictionaries: s				category: cat].	^self class		name: t		inEnvironment: Smalltalk		subclassOf: self		instanceVariableNames: f		variable: false		words: true		pointers: true		weak: false		classVariableNames: d		poolDictionaries: s		category: cat		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(self isVariable and: [self isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a byte subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: false 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:17'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 					'cannot make a word subclass of a class with named fields'].	self isBytes		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a word subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 3/21/98 02:36'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: true		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 1/8/1999 08:01'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name, FileDirectory dot, 'html') asHtml]		ifFalse: [FileStream newFileNamed: self name, FileDirectory dot, 'st'].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close.	DeepCopier new checkVariables.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:12'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	self flag: #obsolete.	^self		subclassOf: newSuper 		oldClass: oldClass 		instanceVariableNames: newInstVarString 		variable: v 		words: w 		pointers: p 		weak: false		ifBad: badBlock ! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:11'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p weak: beWeak ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass ifNotNil: [superclass removeSubclass: self.				"Object flushCache"		"done in removeSubclass"].			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p		weak: beWeak.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			weak: sub isWeak			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:28'!comment	"Answer the receiver's comment. (If old format, not a Text, unpack the old way.) "	| aString |	aString _ self theNonMetaClass organization classComment.	(aString asString beginsWith: self name, ' comment:\''' withCRs) 		ifFalse: [^ aString]		ifTrue: ["old format"			aString size = 0 ifTrue: [^ ''].			"get string only of classComment, undoubling quotes"			^ String readFromString: aString]! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/8/1998 14:43'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	Smalltalk changes commentClass: self theNonMetaClass! !!ClassDescription methodsFor: 'copying' stamp: 'sw 6/16/1998 15:01'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 11/9/1998 20:21'!checkForInstVarsOK: instVarString	"Return true if instVarString does no include any names used in a subclass"	| instVarArray |	instVarArray _ Scanner new scanFieldNames: instVarString.	self allSubclasses do:		[:cl | cl instVarNames do:			[:n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 08:40'!renameInstVar: oldName to: newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 15:30'!renameSilentlyInstVar: oldName to: newName	| i oldCode newCode parser header body sels |	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 8/11/1998 12:52'!removeSelectorUnlogged: aSymbol 	"Remove the message whose selector is aSymbol from the method dictionary of the receiver, if it is there. Answer nil otherwise.  Do not log the action either to the current change set or to the changes log"	(methodDict includesKey: aSymbol) ifFalse: [^ nil].	super removeSelector: aSymbol.	self organization removeElement: aSymbol! !!ClassDescription methodsFor: 'compiling' stamp: 'di 8/21/1998 11:01'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode newText |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [text askIfAddStyle: priorMethod req: requestor]			ifFalse: [text].		 method putSource: newText				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/11/1998 14:40'!compileUnlogged: text classified: category notifying: requestor 	| selector  |	self compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^ nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel].	self organization classify: selector under: category.	^ selector! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/8/1998 14:44'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:30'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ organization classComment: aString].	oldCommentRemoteStr _ organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).	Smalltalk changes commentClass: self.	! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/2/1998 14:22'!commentStamp: changeStamp	self organization commentStamp: changeStamp.    ^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 3/21/98 02:36'!kindOfSubclass	"Answer a string that describes what kind of subclass the receiver is, i.e.,	weak, variable, variable byte, variable word, or not variable."	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 11/13/1998 15:25'!methods	"Answer a ClassCategoryReader for compiling messages that are not classified, as in fileouts made with Smalltalk/V"	^ ClassCategoryReader new setClass: self category: ClassOrganizer default! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 22:02'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(65 333 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 15:26'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	Smalltalk changes reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'private' stamp: 'jm 11/1/1998 11:47'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space method |	space _ 0.	self selectorsDo: [:sel |		space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space _ space + 12].			(lit isMemberOf: String) ifTrue: [space _ space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space _ space + ((lit size + 1) * 4)]]].	(self isMemberOf: Metaclass)		ifTrue: [^ space]		ifFalse: [^ space + self class spaceUsed].! !!ClassDiffBuilder methodsFor: 'initialize'!split: aString	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) isSeparator ifTrue:[			out nextPut: c.			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!ClassDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line].	].! !I represent method categorization information for classes.  The handling of class comments has gone through a tortuous evolution.   Grandfathered class comments (before late aug 98) have no time stamps, and historically, fileouts of class comments always substituted the timestamp reflecting the author and date/time at the moment of fileout; and historically any timestamps in a filed out class comment were dropped on the floor, with the author & time prevailing at the moment of filein being substituted.   Such grandfathered comments now go out on fileouts with '<historical>' timestamp; class comments created after the 8/98 changes will have their correct timestamps preserved, though there is not yet a decent ui for reading those stamps other than filing out and looking at the file; nor is there yet any ui for browsing and recovering past versions of such comments.  Everything in good time!!!!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp	^ commentStamp! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp: aStamp	commentStamp _ aStamp! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:33'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	globalComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp _ '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!ClassOrganizer methodsFor: 'object fileIn' stamp: 'tk 11/27/1998 20:37'!convertgcce0: varDict gccec0: smartRefStrm	"These variables are automatically stored into the new instance ('globalComment' 'categoryArray' 'categoryStops' 'elementArray' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('commentStamp' ) and deal with the information in ()"! !!ClockMorph methodsFor: 'all' stamp: 'sw 10/8/1998 17:21'!initialize	super initialize.	self contents: Time now printString! !!ClockMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 15:36'!authoringPrototype	^ super authoringPrototype contents: Time now printString! !!Collection methodsFor: 'accessing' stamp: 'TAG 11/6/1998 16:06'!anyOne	"Return a representative sample of an element, can be very helpful 	when needing to preinfer the nature of the contents of 	semi-homogeneous collections"	self do: [:each | ^ each].	^ self errorEmptyCollection! !!Collection methodsFor: 'testing' stamp: 'di 11/6/1998 09:16'!isSequenceable	^ false! !!Collection methodsFor: 'enumerating' stamp: 'ar 11/3/1998 14:11'!contains: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false"	self do:[:item|		(aBlock value: item) ifTrue:[^true].	].	^false! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:34'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with another Collection, return a Collection of	the results of each element combined with the scalar in that expression."	rcvr isSequenceable & self isSequenceable ifFalse:		[self error: 'Only sequenceable collections may be combined arithmetically'].	^ rcvr with: self collect:		[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]! !!Collection methodsFor: 'converting' stamp: 'di 11/9/1998 12:16'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:37'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:37'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Collection methodsFor: 'converting' stamp: 'ls 1/3/1999 13:48'!asCharacterSet	"Answer a CharacterSet whose elements are the unique elements of the receiver.  The reciever should only contain characters"	^CharacterSet newFrom: self! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!* arg	^ arg adaptToCollection: self andSend: #*! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!+ arg	^ arg adaptToCollection: self andSend: #+! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!- arg	^ arg adaptToCollection: self andSend: #-! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!/ arg	^ arg adaptToCollection: self andSend: #/! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!// arg	^ arg adaptToCollection: self andSend: #//! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!\\ arg	^ arg adaptToCollection: self andSend: #\\! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!abs	"Absolute value of all elements in the collection"	^ self collect: [:a | a abs]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:57'!average	^ self sum / self size! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!ceiling	^ self collect: [:a | a ceiling]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!floor	^ self collect: [:a | a floor]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!log	^ self collect: [:each | each log]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:58'!max	^ self inject: self anyOne into: [:max :each | max max: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!median	^ self asSortedCollection median! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!min	^ self inject: self anyOne into: [:min :each | min min: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!negated	"Negated value of all elements in the collection"	^ self collect: [:a | a negated]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!range	^ self max - self min! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!reciprocal	"Return the reciever full of reciprocated elements"	^ self collect: [:a | a reciprocal]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!rounded	^ self collect: [:a | a rounded]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!sqrt	^ self collect: [:each | each sqrt]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!squared	^ self collect: [:each | each * each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:02'!sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample _ self anyOne.	sum _ self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:54'!truncated	^ self collect: [:a | a truncated]! !!Color methodsFor: 'equality' stamp: 'di 1/6/1999 20:26'!= aColor	"Return true if the receiver equals the given color. This method handles TranslucentColors, too."	aColor isColor ifFalse: [^ false].	^ aColor privateRGB = rgb and:		[aColor privateAlpha = self privateAlpha]! !!Color methodsFor: 'queries' stamp: 'ar 1/14/1999 15:27'!isBitmapFill	^false! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:43'!isBlack	"Return true if the receiver represents black"	^rgb = 0! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:44'!isGray	"Return true if the receiver represents a shade of gray"	^(self privateRed = self privateGreen) and:[self privateRed = self privateBlue]! !!Color methodsFor: 'queries' stamp: 'ar 11/7/1998 20:20'!isSolidFill	^true! !!Color methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ false! !!Color methodsFor: 'queries' stamp: 'di 1/3/1999 12:23'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ false! !!Color methodsFor: 'transformations' stamp: 'jm 6/25/1998 10:12'!darker	"Answer a darker shade of this color."	^ self mixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'jm 6/17/1998 11:23'!lighter	"Answer a lighter shade of this color."	^ self mixed: 0.8333 with: Color white! !!Color methodsFor: 'other' stamp: 'sw 6/10/1998 17:50'!newTileMorphRepresentative	^ ColorTileMorph new colorSwatchColor: self! !!Color methodsFor: 'conversions' stamp: 'ar 11/2/1998 12:19'!asColor	"Convert the receiver into a color"	^self! !!Color methodsFor: 'conversions' stamp: 'jm 6/2/1998 14:56'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val rgbBlack32 |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		rgbBlack32 _ 16rFF000001.  "closest black for 32-bit depth, with opaque alpha"		"eight bits per component; top 8 bits set to all ones (opaque)"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack32] ifFalse: [16rFF000000 + val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| halfword |	depth = 32 ifTrue: [^ pixelValue].	depth = 16		ifTrue: [halfword _ pixelValue]		ifFalse: [halfword _ pixelValue * 					(#(16rFFFF				"replicates at every bit"						16r5555 -			"replicates every 2 bits"						16r1111 - - -			"replicates every 4 bits"						16r0101) at: depth)	"replicates every 8 bits"].	^ halfword bitOr: (halfword bitShift: 16)! !!Color methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:28'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	^self pixelWordForDepth: 32! !!Color methodsFor: 'copying' stamp: 'tk 8/19/1998 16:12'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Color class methodsFor: 'instance creation' stamp: 'sw 11/9/1998 19:25'!colorFrom: parm	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol, else just return the thing"	(parm isKindOf: Color) ifTrue: [^ parm].	(parm isKindOf: Symbol) ifTrue: [^ self perform: parm].	^ parm! !!Color class methodsFor: 'class initialization' stamp: 'di 1/6/1999 17:44'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames _ OrderedCollection new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).! !!Color class methodsFor: 'named colors' stamp: 'wod 5/24/1998 01:56'!tan	^  Color r: 0.8 g: 0.8 b: 0.5! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20'!asGrayScale	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"	^ self copy colors:		(colors collect:			[:c | c isTransparent ifTrue: [c]						ifFalse: [Color gray: c luminance]])! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:48'!indexOfColor: aColor	"Return the index of aColor in my color array"	self ensureColorArrayExists.	^ colors indexOf: aColor ifAbsent: [0]! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 10/19/1998 10:52'!mapColor: oldColor to: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:49'!replaceColorAtIndex: index with: newColor	"Replace a color map entry with newColor."	self ensureColorArrayExists.	colors at: index put: newColor.	cachedColormap == nil ifFalse:		[cachedColormap at: index put: (newColor pixelValueForDepth: cachedDepth)]! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'di 1/5/1999 13:33'!initialize	| chartForm transText |	super initialize.	chartForm _ ColorChart deepCopy.	Display depth >= 16 ifTrue:		[chartForm fillBlack: (10@0 extent: 1@10).		chartForm fillBlack: ((chartForm width - FeedbackBox width - 10)@0 extent: 1@10).		transText _ (Form extent: 63@9 depth: 1   "Where there's a will there's a way..."					fromArray: #( 0 0 4194306 1024 4194306 1024 15628058 2476592640									4887714 2485462016 1883804850 2486772764 4756618									2485462016 4748474 1939416064 0 0)					offset: 0@0).		transText displayOn: chartForm at: 58@0].	self form: chartForm.	selectedColor _ Color white.	sourceHand _ nil.	deleteOnMouseUp _ true.	updateContinuously _ true.	selector _ nil.	target _ nil.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'di 1/6/1999 08:36'!target: anObject	target _ anObject.	(target respondsTo: #color)		ifTrue: [selectedColor _ target color]		ifFalse: [selectedColor _ color white].! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 1/6/1999 09:55'!pickColorAt: aPoint	| worldBox globalP c alpha |	(FeedbackBox containsPoint: aPoint - self topLeft) ifTrue: [^ self].  "do nothing"	"pick up color, either inside or outside this world"	worldBox _ self world viewBox.	globalP _ aPoint + worldBox topLeft.  "get point in screen coordinates"	(worldBox containsPoint: globalP)		ifTrue: [c _ self world colorAt: aPoint belowMorph: Morph new]		ifFalse: [c _ Display colorAt: globalP].	"check for transparent color and update using appropriate feedback color"	(TransparentBox containsPoint: aPoint - self topLeft)		ifTrue: [Display depth >= 16				ifTrue: [alpha _ (aPoint x - bounds left - 10) asFloat								/ (TransparentBox width - FeedbackBox width - 20)									min: 1.0 max: 0.0.						self updateColor: (selectedColor alpha: alpha) feedbackColor: (selectedColor alpha: alpha)]				ifFalse: [self updateColor: Color transparent feedbackColor: Color white]]		ifFalse: [self updateColor: (selectedColor isTranslucentColor									ifTrue: [c alpha: selectedColor alpha]									ifFalse: [c])					feedbackColor: c]! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 1/6/1999 08:43'!updateTargetColor	(target ~~ nil and: [selector ~~ nil]) ifTrue:		[selector numArgs = 2			ifTrue: [target perform: selector with: selectedColor with: sourceHand]			ifFalse: [target perform: selector with: selectedColor]].! !!ColorSeerTile methodsFor: 'as yet unclassified' stamp: 'jm 5/28/1998 19:19'!storeCodeOn: aStream indent: tabCount	"We have a hidden arg. Output two keywords with interspersed arguments."	| parts |	parts _ operatorOrExpression keywords.	"color:sees:"	^ aStream nextPutAll: (parts at: 1); space;		nextPutAll: colorSwatch color printString; space;		nextPutAll: (parts at: 2).! !!ColorTileMorph methodsFor: 'events' stamp: 'sw 9/10/1998 08:22'!mouseUp: evt	evt hand changeColorTarget: colorSwatch selector: #userSelectedColor:! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 10/25/1998 00:25'!colorSwatch	^ colorSwatch! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 6/10/1998 17:49'!colorSwatchColor: aColor	colorSwatch color: aColor! !!ColorTileMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:02'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: colorSwatch color printString.! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:58'!process: request	"URLs are of the form Comment.commentKey or	Comment.commentKey.note of Comment.commentKey.gif.	If commentKey is accessed but not created, create an empty one.	If note is accessed, display it."	| commentKey noteIndex newNote |	(request message size > 1) ifTrue: [commentKey _ request message at: 2]	ifFalse: [^request reply: (self showAllComments: CommentsTable)].	(CommentsTable includesKey: commentKey)		ifFalse:			[CommentsTable at: commentKey put: Discussion new.			(CommentsTable at: commentKey)				title: commentKey.			(CommentsTable at: commentKey)				description: 'Discussion on ' , commentKey].	request fields isNil		ifFalse:			["Are there input fields?"			newNote _ self createComment: request.			newNote parent: commentKey.			(CommentsTable at: commentKey)				addNote: newNote.			newNote url: ('Comment.',commentKey,'.',				(CommentsTable at: commentKey) notes sizeprintString)].	request message size > 2		ifTrue:			["There's a note reference or a request for astatus image"			noteIndex _ request message at: 3.			noteIndex asUppercase = 'GIF'			ifTrue: [			request reply: (PWS success),(PWS content:'image/gif').			request reply: (HTMLformatter textToGIF:				(CommentsTable at: commentKey) status)]			ifFalse: [request reply: (self showNote:((CommentsTable at: commentKey)						at: noteIndex asNumber))]]		ifFalse: [request reply: (self showComment: (CommentsTableat: commentKey))]! !!Comment class methodsFor: 'URL processing' stamp: 'TPR 7/20/1998 18:07'!showAllComments: aDictionaryOfCommentSpaces	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowAllComments.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName)contentsOfEntireFile with: aDictionaryOfCommentSpaces! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 116>! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 12/28/1998 10:03'!frameSize	"NOTE:  Versions 2.3 and later use a single (large) context size."	"Answer the size of temporary frame needed to run the receiver."	^ LargeFrame"	(self header noMask: 16r20000)		ifTrue: [^ SmallFrame]		ifFalse: [^ LargeFrame]"! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 8/20/1998 09:31'!hasReportableSlip	"Answer whether the receiver contains anything that might be brought to the attention of the author when filing out.   Customize the lists to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'suppressCheckForSlips' has not been hard-coded to true."	| assoc | 	#(halt halt: urgent hottest) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'testing' stamp: 'di 12/26/1998 21:31'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/5/1998 17:41'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ self primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>; cr! !!CompiledMethod methodsFor: 'printing' stamp: 'di 12/26/1998 21:30'!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each." 	| aStream |	self isQuick ifTrue: 		[self isReturnSpecial ifTrue:			[^ 'Quick return ' , (#('self' 'true' 'false' 'nil' '-1' '0' '1' '2')									at: self primitive - 255)].		^ 'Quick return field ' , self returnField printString , ' (0-based)'].	aStream _ WriteStream on: (String new: 1000).	self printPrimitiveOn: aStream.	(InstructionPrinter on: self) printInstructionsOn: aStream.	^aStream contents! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 12/26/1998 21:30'!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^ false].	field <= 8 ifTrue:		[^ (self scanFor: 96 + field - 1) or: [self scanLongStore: field - 1]].	field <= 64 ifTrue:		[^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 12/26/1998 22:34'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte _ self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 9/23/1998 19:22'!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 12/18/1998 11:55'!setSourcePosition: position inFile: fileIndex 	"Store the location of the source code for the receiver in the receiver. The 	location consists of which source file (*.sources or *.changes) and the 	position in that file.  Properly replicate a null source pointer as well."	fileIndex > 4 ifTrue: [^ self error: 'invalid file number'].	self at: self size put: 		((fileIndex = 0 and: [position = 0])			ifTrue:[0  "null source pointer"]			ifFalse: [251 + fileIndex]).	1 to: 3 do: 		[:i | self at: self size - i put: ((position bitShift: (i-3)*8) bitAnd: 16rFF)].! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 8/19/1998 16:20'!veryDeepCopyWith: deepCopier	"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way."! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'di 1/11/1999 22:13'!fullFrameSize  "CompiledMethod fullFrameSize"	^ LargeFrame! !!Compiler methodsFor: 'error handling' stamp: 'di 10/9/1998 16:50'!notify: aString at: location	"Refer to the comment in Object|notify:."	requestor == nil		ifTrue: [^SyntaxError 					errorInClass: class					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false]		ifFalse: [^requestor					notify: aString					at: location					in: sourceStream]! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2output	^functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2outputSet: newValue	functionComponent2output _ newValue.	self changed: #functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItem	^listComponent2selectedItem! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItemSet: newValue	listComponent2selectedItem _ newValue.	self changed: #listComponent2selectedItem! !!Component1 methodsFor: 'functions' stamp: 'di 9/15/1998 17:10'!functionComponent2a: a 	^ Smalltalk at: a! !A composite transform provides the effect of several levels of coordinate transformations.!!CompositeTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:00'!isCompositeTransform	^true! !!CompositeTransform methodsFor: 'transformations' stamp: 'di 10/1/1998 13:51'!invert: aPoint	^ globalTransform invert: (localTransform invert: aPoint)! !!CompositeTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:45'!inverseTransformation	"Return the inverse transformation of the receiver"	^self species new		globalTransform: localTransform inverseTransformation		localTransform: globalTransform inverseTransformation! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^localTransform globalPointToLocal:		(globalTransform globalPointToLocal: aPoint)! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^globalTransform localPointToGlobal:		(localTransform localPointToGlobal: aPoint)! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:00'!asCompositeTransform	^self! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:56'!asMatrixTransform2x3	^globalTransform asMatrixTransform2x3		composedWithLocal: localTransform asMatrixTransform2x3! !!CompositionScanner methodsFor: 'initialize-release' stamp: 'jm 5/29/1998 14:48'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	super		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:50'!handlesMouseOverDragging: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows _ scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r _ rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:31'!storeCodeOn: aStream indent: tabCount	aStream nextPut: $(.	testPart storeCodeOn: aStream indent: 0.	aStream nextPut: $); cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifTrue: ['; cr.	self storeCodeBlockFor: yesPart on: aStream indent: tabCount + 2.	aStream nextPut: $]; cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifFalse: ['; cr.	self storeCodeBlockFor: noPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !This class represents a very compact representation of a boundary shape. It consists of a number of compressed arrays that can be handled by the balloon engine directly. Due to this, there are certain restrictions (see below). Boundaries are always represented by three subsequent points that define a quadratic bezier segment. It is recommended that for straight line segments the control point is set either to the previous or the next point.Instance variables:	points		<PointArray | ShortPointArray>	Point storage area	leftFills		<ShortRunArray>	Containing the "left" fill index of each segment	rightFills	<ShortRunArray>	Containing the "right" fill index of each segment	lineWidths	<ShortRunArray>	Containing the line width of each segment	lineFills		<ShortRunArray>	Containing the line fill (e.g., line color) of each segment	fillStyles	<Collections>			Contains the actual fill styles referenced by the indexesRESTRICTIONS:None of the ShortRunArrays may contain a run of length Zero.Also, due to the use of ShortRunArrays 	a) you cannot have more than 32768 different fill styles	b) you cannot have a line width that exceeds 32768In case you have trouble with a), try to merge some of the fills into one. You might do so by converting colors to 32bit pixel values. In case you have trouble with b) you might change the general resolution of the compressed shape to have less accuracy.!!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:23'!bounds	| min max width |	points isEmpty ifTrue:[^0@0 corner: 1@1].	min _ max _ points first.	points do:[:pt|		min _ min min: pt.		max _ max max: pt	].	width _ 0.	lineWidths valuesDo:[:w| width _ width max: w].	^(min corner: max) insetBy: (w negated asPoint)! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!fillStyles	^fillStyles! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!leftFills	^leftFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineFills	^lineFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineWidths	^lineWidths! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/4/1998 13:50'!numSegments	^points size // 3! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 20:42'!points	^points! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!rightFills	^rightFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:09'!segments	"Return all the segments in the receiver"	| out |	out _ WriteStream on: Array new.	self segmentsDo:[:seg| out nextPut: seg].	^out contents! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:12'!collectFills: aBlock	fillStyles _ fillStyles collect: aBlock.! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:11'!copyAndCollectFills: aBlock	^self copy collectFills: aBlock! !!CompressedBoundaryShape methodsFor: 'enumerating' stamp: 'ar 11/9/1998 14:10'!segmentsDo: aBlock	"Enumerate all segments in the receiver and execute aBlock"	| p1 p2 p3 |	1 to: points size by: 3 do:[:i|		p1 _ points at: i.		p2 _ points at: i+1.		p3 _ points at: i+2.		(p1 = p2 or:[p2 = p3]) ifTrue:[			aBlock value: (LineSegment from: p1 to: p3).		] ifFalse:[			aBlock value: (Bezier2Segment from: p1 via: p2 to: p3).		].	].! !!CompressedBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 18:03'!setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	points _ pointList.	leftFills _ leftFillList.	rightFills _ rightFillList.	lineWidths _ lineWidthList.	lineFills _ lineFillList.	fillStyles _ fillStyleList.! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 16:28'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 18:02'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList! !!ConnectionQueue methodsFor: 'private' stamp: 'jm 11/10/1998 18:01'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket _ Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				socket waitForConnectionUntil: (Socket deadlineSecs: 10).				socket isConnected					ifTrue: [  "connection established"						accessSema critical: [connections addLast: socket].						socket _ nil]					ifFalse: [						socket isWaitingForConnection							ifFalse: [socket destroy. socket _ nil]]].  "broken socket; start over"		self pruneStaleConnections].! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:21'!blockCopy: numArgs 	"Primitive. Distinguish a block of code from its enclosing method by 	creating a new BlockContext for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	blockCopy:. Do not use blockCopy: in code that you write!! Only the 	compiler can decide to send the message blockCopy:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 80>	^ BlockContext new		home: self home		startpc: pc + 2		nargs: numArgs! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:40'!pop	"Answer the top of the receiver's stack and remove the top of the stack."	| val |	val _ self at: stackp.	self stackp: stackp - 1.	^ val! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:39'!push: val 	"Push val on the receiver's stack."	self stackp: stackp + 1.	self at: stackp put: val! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/2/1999 15:50'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class _ superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	meth _ class lookupSelector: selector.	meth == nil		ifTrue: [^ self send: #doesNotUnderstand:					to: rcvr					with: (Array with: (Message selector: selector arguments: args))					super: superFlag]		ifFalse: [val _ self tryPrimitiveFor: meth						receiver: rcvr						args: args.				val == #simulatorFail ifFalse: [^ val].				(selector == #doesNotUnderstand: and: [class == Object]) ifTrue:					[^ self error: 'Simulated message ' , (args at: 1) selector									, ' not understood'].				^ self activateMethod: meth					withArgs: args					receiver: rcvr					class: class]! !!ContextPart methodsFor: 'printing' stamp: 'di 9/10/1998 09:19'!printOn: aStream 	| selector class |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:mclass].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 22:18'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: (BlockContext new						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 10:26'!pop: numObjects toAddable: anAddableCollection	"Pop the top numObjects elements from the stack, and store them in	 anAddableCollection, topmost element last.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	| base |	base _ stackp - numObjects.	1 to: numObjects do:		[:i | anAddableCollection add: (self at: base+i)].	self stackp: stackp - numObjects! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 10:25'!pop: numObjects toIndexable: anIndexableCollection	"Pop the top numObjects elements from the stack, and store them in	 anIndexableCollection, topmost element last.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	| base |	base _ stackp - numObjects.	1 to: numObjects do:		[:i | anIndexableCollection at: i put: (self at: base+i)].	self stackp: stackp - numObjects! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 10:12'!push: numObjects fromIndexable: anIndexableCollection	"Push the elements of anIndexableCollection onto the receiver's stack.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	1 to: numObjects do:		[:i | self push: (anIndexableCollection at: i)]! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 22:38'!stackp: newStackp	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."	"Once this primitive is implemented, failure code should cause an error"	| oldStackp |	<primitive: 76>	false ifTrue: [self error: 'stackp store failure'].	stackp == nil ifTrue: [stackp _ 0].	newStackp > stackp  "effectively checks that it is a number"		ifTrue: [oldStackp _ stackp.				stackp _ newStackp.				"Nil any newly accessible cells"				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp _ newStackp]! !!ContextPart methodsFor: 'private'!tryPrimitiveFor: method receiver: receiver args: arguments 	"Simulate a primitive method, method for the receiver and arguments given	as arguments to this message.  Answer resuming the context if successful, else	answer the symbol, #simulatorFail."	| flag primIndex |	(primIndex _ method primitive) = 0 ifTrue: [^#simulatorFail].	^ self doPrimitive: primIndex receiver: receiver args: arguments! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!control	^ control! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!control: midiControl	control _ midiControl.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!control: midiControl value: midiControlValue channel: midiChannel	control _ midiControl.	value _ midiControlValue.	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02'!value	^ value! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!value: midiControlValue	value _ midiControlValue.! !!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isControlChange	^ true! !!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rB0		channel: channel		byte: control		byte: value.! !!ControlChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': ctrl['.	control printOn: aStream.	aStream nextPutAll: ']='.	value printOn: aStream.	aStream nextPut: $).! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 11/19/1998 18:31'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/13/1998 00:48'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!initialize	"Controller initialize"	self MinActivityLapse: 10.! !!CrLfFileStream methodsFor: 'open/close' stamp: 'ar 1/20/98 16:15'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be 	read-only. "	| result |	result _ super open: aFileName forWrite: writeMode.	result ifNotNil: [self detectLineEndConvention].	^ result! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!ascii	super ascii.	self detectLineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!binary	super binary.	lineEndConvention _ nil! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 7/10/1998 23:35'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead pos |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	lineEndConvention _ LineEndDefault.	"Default if nothing else found"	numRead _ 0.	pos _ super position.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char _ super next.			char = Lf				ifTrue: 					[super position: pos.					^ lineEndConvention _ #lf].			char = Cr				ifTrue: 					[super peek = Lf						ifTrue: [lineEndConvention _ #crlf]						ifFalse: [lineEndConvention _ #cr].					super position: pos.					^ lineEndConvention].			numRead _ numRead + 1].	super position: pos.	^ lineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 11/5/1998 23:37'!next    | char secondChar |    char _ super next.    self isBinary ifTrue: [^char].    char == Cr ifTrue:        [secondChar _ super next.        secondChar ifNotNil: [secondChar == Lf ifFalse: [self skip: -1]].        ^Cr].    char == Lf ifTrue: [^Cr].    ^char! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 12/29/1998 17:15'!next: n		| string peekChar |		string _ super next: n.		string size = 0 ifTrue: [ ^string ].		self isBinary ifTrue: [ ^string ].		"if we just read a CR, and the next character is an LF, then skip the LF"		( string last = Character cr ) ifTrue: [			peekChar _ super next.		"super peek doesn't work because it relies on #next"			peekChar ~= Character lf ifTrue: [				super position: (super position - 1) ]. ]. 		string _ string withSqueakLineEndings.		string size = n ifTrue: [ ^string ].		"string shrunk due to embedded crlfs; make up the difference"		^string, (self next: n - string size)! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPut: char 	(lineEndConvention notNil and: [char = Cr])		ifTrue: [super nextPutAll: (LineEndStrings at: lineEndConvention)]		ifFalse: [super nextPut: char].	^ char! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPutAll: aString 	super nextPutAll: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 6/18/1998 13:52'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos _ self position.	next _ self next.	self position: pos.	^ next! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 11/5/1998 14:15'!upTo: aCharacter	| newStream char |	newStream _ WriteStream on: (String new: 100).	[(char _ self next) isNil or: [char == aCharacter]]		whileFalse: [newStream nextPut: char].	^ newStream contents! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!verbatim: aString 	super verbatim: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringToCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCR	"CrLfFileStream defaultToCR"	LineEndDefault := #cr.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCRLF	"CrLfFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToLF	"CrLfFileStream defaultToLF"	LineEndDefault := #lf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:13'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $: ifTrue:[^self defaultToCR].	FileDirectory pathNameDelimiter = $/ ifTrue:[^self defaultToLF].	FileDirectory pathNameDelimiter = $\ ifTrue:[^self defaultToCRLF].	"in case we don't know"	^self defaultToCR! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:14'!initialize	"CrLfFileStream initialize"	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.	self guessDefaultLineEndConvention.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ls 10/28/1998 14:47'!startUp	self guessDefaultLineEndConvention! !!Cursor methodsFor: 'displaying' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor _ (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'di 12/20/1998 22:08'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormalWithMask.  "was self initNormal"		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		"Cursor initialize"! !!Cursor class methodsFor: 'instance creation' stamp: 'di 10/6/1998 13:53'!new	^ self extent: 16 @ 16		fromArray: (Array new: 16 withAll: 0)		offset: 0 @ 0	"Cursor new bitEdit show"! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57'!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor _ aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!Cursor class methodsFor: 'constants' stamp: 'ar 11/18/1998 15:33'!webLink	"Return a cursor that can be used for emphasizing web links"	"Cursor webLink showWhile: [Sensor waitButton]"	^ (CursorWithMask extent: 16@16			fromArray: #(3072 4608 4608 4608 4608 5046 4681 29257 37449 37449 32769 32769 49155 16386 24582 16380 )			offset: -5@0) setMaskForm:		(Form extent: 16@16 			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])			offset: 0@0).! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/6/1998 15:16'!beCursor	maskForm unhibernate.	^ self beCursorWithMask: maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!maskForm	^ maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm _ aForm! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 10/8/1998 16:46'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask |	cursor _ self new.	cursor copy: (1@1 extent: 16@16) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: 16@16.	(0@0) eightNeighbors do:		[:p | mask copy: (p extent: 16@16) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: aForm offset - (1@1).	^ cursor! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 21:59'!coefficients	"Compute an array for the coefficients.  This is copied from Flegal's old	code in the Spline class."	| length extras verts |	coefficients ifNotNil: [^ coefficients].	verts _ closed ifTrue: [vertices copyWith: vertices first]				ifFalse: [vertices].	length _ verts size.	extras _ 0.	coefficients _ Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(verts at: i) x asFloat]						ifFalse: [(verts at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]].	^ coefficients! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:03'!curveBounds	"Compute the bounds from actual curve traversal, with leeway for borderWidth.	Also note the next-to-first and next-to-last points for arrow directions."	| curveBounds |	curveBounds _ vertices first corner: vertices last.	coefficients _ nil.  "Force recomputation"	ntfPoint _ nil.	self lineSegmentsDo:		[:p1 :p2 | ntfPoint == nil ifTrue: [ntfPoint _ p2 asIntegerPoint].		curveBounds _ curveBounds encompass: p2 asIntegerPoint.		ntlPoint _ p1 asIntegerPoint].	^ curveBounds expandBy: borderWidth+1//2! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:01'!lineSegmentsDo: endPointsBlock	"Emit a sequence of line segments into endPointsBlock to approximate this spline."	| n t x y x1 x2 x3 y1 y2 y3 beginPoint endPoint coeffs |	vertices size < 1 ifTrue: [^ self].	coeffs _ self coefficients.	beginPoint _ (x _ (coeffs at: 1) at: 1) @ (y _ (coeffs at: 5) at: 1).	1 to: (coeffs at: 1) size - 1 do: 		[:i |  "taylor series coeffs"		x1 _ (coeffs at: 2) at: i.		y1 _ (coeffs at: 6) at: i.		x2 _ ((coeffs at: 3) at: i) / 2.0.		y2 _ ((coeffs at: 7) at: i) / 2.0.		x3 _ ((coeffs at: 4) at: i) / 6.0.		y3 _ ((coeffs at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((coeffs at: 3) at: i+1) abs									+ ((coeffs at: 7) at: i+1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			endPoint _ (x3 * t + x2 * t + x1 * t + x) @ (y3 * t + y2 * t + y1 * t + y).			endPointsBlock value: beginPoint							value: endPoint.			beginPoint _ endPoint].		endPoint _ (x _ (coeffs at: 1) at: i+1) @ (y _ (coeffs at: 5) at: i+1).		endPointsBlock value: beginPoint						value: endPoint.		beginPoint _ endPoint]! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:04'!privateMoveBy: delta	super privateMoveBy: delta.	coefficients _ nil.  "Force recomputation"! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:07'!releaseCachedState	super releaseCachedState.	coefficients _ nil.! !!CurveMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:44'!updateHandles	| midPts nextVertIx tweens newVert |	midPts _ OrderedCollection new.	nextVertIx _ 2.	tweens _ OrderedCollection new.	self lineSegmentsDo:		[:p1 :p2 | 		tweens addLast: p2 asIntegerPoint.		p2 = (vertices atWrap: nextVertIx) ifTrue:			["Found endPoint."			midPts addLast: (tweens at: tweens size // 2)						+ (tweens at: tweens size + 1 // 2) // 2.			tweens _ OrderedCollection new.			nextVertIx _ nextVertIx + 1]].	midPts withIndexDo:		[:midPt :vertIndex |		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: midPt - (newVert extent // 2)]].! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title _ aTitle! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList _ (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray _ #()]		ifNotNil: [linesArray _ anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font _ aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'di 8/20/1998 09:24'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!CustomMenu methodsFor: 'private' stamp: 'jm 8/20/1998 08:30'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [: label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: (TextStyle default fontAt: 1)		lines: dividers.! !!DataMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:46'!becomeField	| aStack slotNameChosen  |	aStack _ self pasteUpMorph assuredPlayer.	slotNameChosen _ aStack addSlotNamedLike: self externalName withValue: self valueFromContents.	self getSelector: (Utilities getterSelectorFor: slotNameChosen).	self putSelector: (Utilities setterSelectorFor: slotNameChosen).	self target: aStack.	status _ #field.	aStack updateAllViewers! !This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn't repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored.  On the high level, objectToStoreOnDataStream allows you to substitute another object on the way out.  The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload and (class) readDataFrom:size:. See these methods, and the class DiskProxy, for more information about externalizing and internalizing.NOTE: A DataStream should be treated as a write-stream for writing.  It is a read-stream for reading.  It is not a ReadWriteStream.!!DataStream methodsFor: 'all'!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes _ byteStream position.			byteStream close]		ifTrue: [bytes _ 'unknown'].	^ bytes! !!DataStream methodsFor: 'all' stamp: 'tk 9/9/1998 14:10'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].	"After reading the externalObject, internalize it.	 #readReference is a special case. Either:	   (1) We actually have to read the object, recursively calling		   next, which internalizes the object.	   (2) We just read a reference to an object already read and		   thus already interalized.	 Either way, we must not re-internalize the object here."	selector == #readReference ifFalse:		[anObject _ self internalize: anObject].	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:18'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectToStoreOnDataStream) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectToStoreOnDataStream.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'all' stamp: 'jm 8/19/1998 17:00'!readByteArray	"PRIVATE -- Read the contents of a ByteArray."	| count |	count _ byteStream nextNumber: 4.	^ byteStream next: count  "assume stream is in binary mode"! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:32'!readShortRef	"Read an object reference from two bytes only.  Original object must be in first 65536 bytes of the file.  Relative to start of data.  vacantRef not a possibility."	^ self objectAt: (byteStream nextNumber: 2)! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:03'!readString	| str |	byteStream ascii.	str _ byteStream nextString.	byteStream binary.	^ str! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:27'!readStringOld   ^ byteStream nextStringOld! !!DataStream methodsFor: 'all' stamp: 'tk 8/18/1998 08:59'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	aStream binary.	basePos _ aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream _ aStream.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:13'!typeIDFor: anObject	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  	Classes can control their instance variables by defining objectToStoreOnDataStream.	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."		^ TypeMap at: anObject class ifAbsent: [9 "instance of any normal class"]	"See DataStream initialize.  nil=1. true=2. false=3. a SmallInteger=4. (a String was 5). a Symbol=6.  a ByteArray=7. an Array=8. other = 9.  a Bitmap=11. a Metaclass=12. a Float=14.  a Rectangle=15. any instance that can have a short header=16.  a String=17 (new format)."! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:16'!vacantRef	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference	 position' to identify a reference that's not yet filled in. This must be a	 value that won't be used as an ordinary reference. Cf. outputReference: and	 readReference. -- 	 NOTE: We could use a different type ID for vacant-refs rather than writing		object-references with a magic value. (The type ID and value are		overwritten by ordinary object-references when weak refs are fullfilled.)"	^ SmallInteger maxVal! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!writeBitmap: aBitmap	"PRIVATE -- Write the contents of a Bitmap."	aBitmap writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words."! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!writeByteArray: aByteArray	"PRIVATE -- Write the contents of a ByteArray."	byteStream nextNumber: 4 put: aByteArray size.	"May have to convert types here..."	byteStream nextPutAll: aByteArray.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 20:57'!writeString: aString	"PRIVATE -- Write the contents of a String."	byteStream nextStringPut: aString.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:23'!writeStringOld: aString	"PRIVATE -- Write the contents of a String."	| length |	aString size < 16384 		ifTrue: [			(length _ aString size) < 192				ifTrue: [byteStream nextPut: length]				ifFalse: 					[byteStream nextPut: (length // 256 + 192).					byteStream nextPut: (length \\ 256)].			aString do: [:char | byteStream nextPut: char asciiValue]]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!DataStream class methodsFor: 'all' stamp: 'tk 6/8/1998 21:10'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 40. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"Does anything use this?"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	"t at:  put: 18.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!Date class methodsFor: 'instance creation' stamp: 'ls 7/25/1998 01:15'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 	1901."	^self fromDays: seconds // 86400! !!Date class methodsFor: 'instance creation' stamp: 'di 5/26/1998 11:53'!newDay: day month: month year: year 	"Note: day, month and year are all integers, except month may be a string"	"Answer an instance of me which is the day'th day of the month named 	 month in the year'th year. The year may be specified as the actual 	 number of years since the beginning of the Roman calendar or the 	 number of years since 1900.  **Note** two digit dates are always from 1900.		1/1/01 will NOT mean 2001."	"Tolerate a month index instead of a month name."	| monthIndex daysInMonth firstDayOfMonth |	year < 100 ifTrue: [^ self			newDay: day			month: month			year: 1900 + year].	monthIndex _ month isInteger	 ifTrue: [month] ifFalse: [self indexOfMonth: month].	monthIndex = 2		ifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [daysInMonth _ DaysInMonth at: monthIndex].	monthIndex > 2		ifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].	(day < 1 or: [day > daysInMonth])		ifTrue: [self error: 'illegal day in month']		ifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:22'!buildMVCDebuggerViewLabel: aString minSize: aPoint	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	self expandStack.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	stackListView _ PluggableListView on: self			list: #contextStackList			selected: #contextStackIndex			changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted:			keystroke: #contextStackKey:from:.		stackListView menuTitleSelector: #messageListSelectorTitle.		stackListView window: (0 @ 0 extent: 150 @ 50).		topView addSubView: stackListView.	stackCodeView _ PluggableTextView on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ PluggableListView on: self receiverInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ PluggableTextView on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ PluggableListView on: self contextVariablesInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ PluggableTextView on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: ctxtValView toRightOf: ctxtVarView.	topView label: aString.	topView minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sw 10/15/1998 12:59'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (PreDebugWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:44'!openFullMorphicLabel: labelString	| window aListMorph |	self expandStack.	window _ (SystemWindow labelled: labelString) model: self.	aListMorph _ PluggableListMorph on: self list: #contextStackList			selected: #contextStackIndex changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted: keystroke: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@0.7).	window addMorph: (PluggableListMorph on: self receiverInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0.7 corner: 0.2@1).	window addMorph: (PluggableTextMorph on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.2@0.7 corner: 0.5@1).	window addMorph: (PluggableListMorph on: self contextVariablesInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0.5@0.7 corner: 0.7@1).	window addMorph: (PluggableTextMorph on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.7@0.7 corner: 1@1).	^ window openInWorld! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 13:04'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msgString]		ifFalse: [msg _ msgString].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcess].	Display fullScreen.	Cursor normal show.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:31'!release	self windowIsClosing.	super release.! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:30'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'accessing' stamp: 'di 10/9/1998 17:15'!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	contents == nil ifTrue: [^ String new].	^ contents copy! !!Debugger methodsFor: 'notifier menu' stamp: 'wod 5/26/1998 16:19'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."	World ifNotNil:		[self breakDependents.		self openFullMorphicLabel: topView label.		^ topView delete].	topView controller controlTerminate.	topView deEmphasizeView; erase.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack (message list)' stamp: 'di 9/22/1998 00:26'!selectedMessage	"Answer the source code of the currently selected context."	contents _ self selectedContext sourceCode.	Preferences browseWithPrettyPrint ifTrue: [contents _ self selectedClass compilerClass new					format: contents					in: self selectedClass					notifying: nil].	^ contents _ contents asText makeSelectorBoldIn: self selectedClass! !!Debugger methodsFor: 'context stack menu' stamp: 'di 1/14/1999 09:18'!contextStackMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)senders of...implementors of...method inheritanceversionsinst var refs...inst var defs...class var refs...class variablesclass refsbrowse fullmore...'	lines: #(6 10 12 15)	selections: #(fullStack restart proceed doStep send wherebrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFullshiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'context stack menu' stamp: 'di 1/14/1999 09:18'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #contentsSelection]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #contentsSelection.					self updateInspectors]]! !!Debugger methodsFor: 'code pane' stamp: 'di 9/22/1998 00:21'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i methodNode pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.		sourceMap _ methodNode sourceMap.		tempNames _ methodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	pc_ self selectedContext pc -		((externalInterrupt and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:28'!step 	"Update the inspectors."	receiverInspector ifNotNil: [receiverInspector step].	contextVariablesInspector ifNotNil: [contextVariablesInspector step].! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:25'!wantsSteps 	^ true! !!Debugger methodsFor: 'private' stamp: 'di 9/22/1998 00:21'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self changed: #contents.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self changed: #contents.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'di 6/20/1998 14:48'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'class initialization' stamp: 'di 1/14/1999 09:17'!initialize	ErrorRecursion _ false.	ContextStackKeystrokes _ Dictionary new		at: $e put: #send;		at: $t put: #doStep;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where;		yourself.	"Debugger initialize"! !!Debugger class methodsFor: 'instance creation' stamp: 'di 6/17/1998 14:39'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'di 9/22/1998 00:35'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| f |	<primitive: 19> "Simulation guard"	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	Preferences logDebuggerStackToFile ifTrue:		[FileDirectory default deleteFileNamed: 'SqueakDebug.log' ifAbsent: [].		f _ FileStream fileNamed: 'SqueakDebug.log'.		f nextPutAll: aString; cr.		aContext stack do: [:ctxt | f print: ctxt; cr].		f close].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'di 6/30/1998 12:13'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !!Decompiler methodsFor: 'private' stamp: 'di 12/26/1998 21:29'!quickMethod	| |	method isReturnSpecial		ifTrue: [^ constructor codeBlock:				(Array with: (constTable at: method primitive - 255)) returns: true].	method isReturnField		ifTrue: [^ constructor codeBlock:				(Array with: (constructor codeInst: method returnField)) returns: true].	self error: 'improper short method'! !I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).When a tree of Morphs points at a morph outside of it, that morph should not be copied.  Use weak pointers for the potentially outside morphs.  Default is that any new class has all of its newly defined fields be deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.(Object veryDeepCopyWith: notes which superclasses did not do veryDeepInner:, and very deep copies those vars).Key to seeing if you have to add the methods veryDeepFixupWith:   and   veryDeepInner:Does field X contain a morph?  If not, no action needed.Is the morph in field X a submorph of the object?  IS it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If so, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   All uniClass instances do have a new class created for them.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/8/1999 09:37'!checkDeep	"Write exceptions in the Transcript.  Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  This check is only run by hand once in a while to make sure nothing was forgotten.	DeepCopier new checkDeep 	"| mm |Transcript cr; show: 'Instance variables shared with the original object when it is copied'.(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 	(mm _ aClass instVarNames size) > 0 ifTrue: [		(aClass instSize - mm + 1) to: aClass instSize do: [:index |			((aClass compiledMethodAt: #veryDeepInner:) writesField: index) ifFalse: [				Transcript cr; show: aClass name; space; 					show: (aClass allInstVarNames at: index)]]]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/8/1999 07:46'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, look at veryDeepCopyWith:, or tables in WeakFields and WeakFieldNames need to be updated.  	DeepCopier new checkVariables	"	| str str2 meth |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self halt: 'Morph', str].	"added ones are OK"	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/22/1998 11:25'!initialize	references _ IdentityDictionary new: 4096.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	(self identityHash // 16 bitAnd: 7) = 1 ifTrue: [self checkVariables].		"Just check once in a while"! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/31/1998 15:52'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321).""Uniclasses use class vars to hold onto siblings who are referred to in code"| pp |pp _ Object class instSize + 1.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+0"	"(pp+1) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+2 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 22:13'!references	^ references! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/19/1998 15:48'!uniClasses	^uniClasses! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/8/1999 07:17'!warnIverNotCopiedIn: aClass sel: sel	"Warn the user to update veryDeepCopyWith: or veryDeepInner:"	self inform: ('Your file operation succeeded.\\An instance variable was added to to class ', aClass name, ',\and it is not copied in the method ', sel, '.\Please rewrite it to handle all instance variables.\See DeepCopier class comment.') withCRs.	Browser openMessageBrowserForClass: aClass selector: sel editString: nil.! !!Dictionary methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:22'!at: key ifAbsentPut: aBlock 	"Return the value at the given key.	If key is not included in the receiver store the result	of evaluating aBlock as new value."	^self at: key ifAbsent:[self at: key put: aBlock value]! !!Dictionary methodsFor: 'user interface' stamp: 'di 9/23/1998 12:20'!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  "	| viewClass |	viewClass _ PluggableTextView.	Smalltalk at: #FormInspectView		ifPresent: [:formInspectView | viewClass _ formInspectView].	^ DictionaryInspector openOn: self withEvalPane: true		withLabel: aLabel		valueViewClass: viewClass! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:25'!contentsIsString	"Hacked so contents empty when deselected"	^ (selectionIndex = 0)! !an entry in a directory; a reference to either a file or a directory.!!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!creationTime	"time the entry was created.  (what's its type?)"	^creationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!fileSize	"size of the entry, if it's a file"	^fileSize! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!isDirectory	"whether this entry represents a directory"	^dirFlag! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!modificationTime	"time the entry was last modified"	^modificationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!name	"name of the entry"	^name! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:29'!at: index	"compatibility interface"	"self halt: 'old-style access to DirectoryEntry'"	index = 1 ifTrue: [ ^self name ].	index = 2 ifTrue: [ ^self creationTime ].	index = 3 ifTrue: [ ^self modificationTime ].	index = 4 ifTrue:[ ^self isDirectory ].	index = 5 ifTrue:[ ^self fileSize ].	self error: 'invalid index specified'.! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:16'!size	^5! !!DirectoryEntry methodsFor: 'private-initialization' stamp: 'ls 7/15/1998 21:42'!privateName: name0  creationTime: creationTime0  modificationTime: modificationTime0  isDirectory: isDirectory0  fileSize: fileSize0	name _ name0.	creationTime _ creationTime0.	modificationTime _ modificationTime0.	dirFlag _ isDirectory0.	fileSize _ fileSize0.! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:42'!fromArray: array	^self name: (array at: 1) creationTime: (array at: 2) modificationTime: (array at: 3) isDirectory: (array at: 4) fileSize: (array at: 5) ! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:41'!name: name0  creationTime: creationTime  modificationTime: modificationTime   isDirectory: isDirectory  fileSize: fileSize	^self new privateName: name0  creationTime: creationTime  modificationTime: modificationTime  isDirectory: isDirectory  fileSize: fileSize! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!author	^self description! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!children	^#()! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:45'!timestamp	^String new:0! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:53'!url	"fake the url as the title"	^'Comment.', self title! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:31'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 10/5/1998 09:29'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern displaying: true.		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 16:03'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				height _ anchoredMorph height.				runX _ destX.				anchoredMorph displayOn: destForm at: destX - width@destY].	^ true! !!DisplayScanner methodsFor: 'private' stamp: 'di 1/4/1999 00:34'!alphaBits: a	alpha _ a! !!DisplayScanner methodsFor: 'private' stamp: 'di 1/4/1999 00:39'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:30'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:33'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !This class represents a base for generic transformations of 2D points between different coordinate systems (including scaling and rotation). The transformations map objects between one coordinate system and another where it is assumed that a nested hierarchy of transformations can be defined.It is assumed that transformations deal with Integer points. All transformations should return Integer coordinates (even though float points may be passed in as argument).Compositions of transformations MUST work in the following order. A 'global' transformation (the argument in #composedWithGlobal:) is defined as a transformation that takes place between the receiver (the 'local') transformation and any 'global' point computations, whereas a 'local' transformation (e.g., the argument in #composedWithLocal:) takes place between the receiver ('global') and any 'local' points. For the transformation methods this means that combining a global and a local transformation will result in the following order:		globalPointToLocal: globalPoint			"globalPoint -> globalTransform -> localTransform -> locaPoint"			^localTransform globalPointToLocal:				(globalTransform globalPointToLocal: globalPoint)		localPointToGlobal: localPoint			"localPoint -> localTransform -> globalTransform -> globalPoint"			^globalTransform localPointToGlobal:				(localTransform localPointToGlobal: localPoint)!!DisplayTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:18'!setIdentity	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:43'!inverseTransformation	"Return the inverse transformation of the receiver"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:47'!isCompositeTransform	"Return true if the receiver is a composite transformation.	Composite transformations may have impact on the accuracy."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:17'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMorphicTransform	"Return true if the receiver is a MorphicTransform, that is specifies the transformation values explicitly."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:16'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:15'!composedWithGlobal: aTransformation	"Return the composition of the receiver and the global transformation passed in.	A 'global' transformation is defined as a transformation that takes place	between the receiver (the 'local') transformation and any 'global' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	^aTransformation composedWithLocal: self! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:41'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in.	A 'local' transformation is defined as a transformation that takes place	between the receiver (the 'global') transformation and any 'local' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	self isIdentity ifTrue:[^ aTransformation].	aTransformation isIdentity ifTrue:[^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransformation! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:17'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!globalPointsToLocal: inArray	"Transform all the points of inArray from global into local coordinates"	^inArray collect:[:pt| self globalPointToLocal: pt]! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:18'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!localPointsToGlobal: inArray	"Transform all the points of inArray from local into global coordinates"	^inArray collect:[:pt| self localPointToGlobal: pt]! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^Rectangle encompassing: (self globalPointsToLocal: aRectangle corners)! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^Rectangle encompassing: (self localPointsToGlobal: aRectangle corners)! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:59'!asCompositeTransform	"Represent the receiver as a composite transformation"	^CompositeTransform new		globalTransform: self		localTransform: self species identity! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:01'!asMatrixTransform2x3	"Represent the receiver as a 2x3 matrix transformation"	^self subclassResponsibility! !!DisplayTransform class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 20:55'!identity	^self new setIdentity! !!DosFileDirectory methodsFor: 'all' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DosFileDirectory methodsFor: 'all' stamp: 'tk 9/29/1998 15:05'!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	(fileName size = 2 and: [fileName first isLetter and: [fileName last = $:]])		ifTrue: [^ fileName].	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue:[''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !a placeholder for an image that is downloading!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 8/20/1998 09:12'!altText: aString	"set the text to be displayed while downloading"	altText _ aString.	self setContents! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/9/1998 06:59'!defaultExtent: aPoint	"set the size to use when the image hasn't yet downloaded"	defaultExtent _ aPoint! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/19/1998 23:08'!downloadStateIn: aScamper	"download the image"	| doc |	doc _ url retrieveContents.	downloadQueue nextPut: doc.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:21'!initialize	super initialize.	altText _ '[image]'.	self color: Color transparent.	downloadQueue _ SharedQueue new.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 21:43'!setContents	"set up our morphic contents"	| stringMorph imageMorph outlineMorph extent |	self removeAllMorphs.	image		ifNil: [ 			altText = '' ifTrue: [ self extent: 0@0. "don't display anything..." ^self ].			stringMorph _ StringMorph new.			stringMorph contents: altText.			stringMorph position: self position+(2@2).			self addMorph: stringMorph.			outlineMorph _ RectangleMorph new.			outlineMorph borderWidth: 1.			outlineMorph color: Color transparent.			outlineMorph position: self position.			"figure out how big to make the box"			extent _ defaultExtent ifNil: [ 0 @ 0 ].			stringMorph width + 4 > extent x ifTrue: [				extent _ (stringMorph width + 4) @ extent y ].			stringMorph height + 4 > extent y ifTrue: [				extent _ extent x @ (stringMorph height + 4) ].			outlineMorph extent: extent.			self addMorph: outlineMorph.			self extent: outlineMorph extent ]		ifNotNil: [			imageMorph _ ImageMorph new.			imageMorph image: image.			imageMorph position: self position.			self addMorph: imageMorph.			imageMorph extent ~= self extent ifTrue: [				self extent: imageMorph extent ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:42'!step	| doc |	downloadQueue size > 0 ifTrue: [		doc _ downloadQueue next.		doc mainType = 'image' 		ifTrue: [			image _ ImageReadWriter  formFromStream: doc contentStream binary.			self setContents ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:19'!stepTime	"this check doesn't need to be frequent"	^500! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 17:48'!url: aUrl	"set the url to download"	url _ aUrl asUrl.! !!DropShadowMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 08:21'!initialize	super initialize.	self color: Color black.	shadowOffset _ 3@3! !!DropShadowMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 14:43'!ownerChanged	super ownerChanged.	self submorphsDo: [:m | m ownerChanged].	self computeBounds! !!DropShadowMorph methodsFor: 'private' stamp: 'di 1/4/1999 19:53'!computeBounds	submorphs isEmpty ifTrue:		[self extent: 50@40.		fullBounds _ nil.		^ self].	self changed.	bounds _ (submorphs first bounds) copy.	fullBounds _ nil.	bounds _ (self fullBounds translateBy: shadowOffset) merge: self fullBounds.	self changed! !!DualChangeSorter methodsFor: 'all' stamp: 'jm 7/5/1998 12:37'!openAsMorph		| window |	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	window openInWorld.! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!nextPut: aByte	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!nextPutAll: aByteArray	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 7/12/1998 12:51'!position: anOffset	"Pretend to position wherever the caller says!!"! !!EToySystem class methodsFor: 'development support' stamp: 'di 9/14/1998 10:02'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream _ ReferenceStream fileNamed: 'JanForms'.	newFormDict _ aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Smalltalk imageImports add: assoc]! !!EToySystem class methodsFor: 'development support' stamp: 'sw 10/16/1998 09:31'!stripMethodsForExternalRelease	"EToySystem stripMethodsForExternalRelease"	Utilities stripMethods: self methodsToStripForExternalRelease messageCode: '2.3External'! !!EToySystem class methodsFor: 'external release' stamp: 'sw 10/16/1998 09:30'!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		serverUrls)		(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!EToySystem class methodsFor: 'stripped' stamp: 'di 1/15/1999 11:29'!prepareRelease	self codeStrippedOut: '2.3External'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 1/15/1999 11:29'!previewEToysOn: arg1	self codeStrippedOut: '2.3External'! !!EllipseMorph methodsFor: 'all' stamp: 'di 6/24/1998 14:27'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!EmbeddedServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/199816:44'!replyTo: pieces from: request	| theLast |	(StandardFileStream isAFileNamed: pieces)		ifTrue:			[theLast _ request message last asLowercase.			theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].			theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			request reply: PWS success;			 reply: PWS contentHTML , PWS crlf.			request reply: (HTMLformatter evalEmbedded: 				(FileStream fileNamed: pieces) contentsOfEntireFile with: request)]		ifFalse: [request error: PWS notFound]! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs _ (seconds * 1000.0) asInteger - 19.	attack _ self attackTime.	decay _ self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime _ endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime _ attack]				ifFalse: [endTime _ endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 11:31'!editSound: aSound	| p |	sound _ aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p _ OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 10:40'!initOnSound: aSound title: title	sound _ aSound.	soundName _ title.	self initialize.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 11:02'!initialize	super initialize.	prevMouseDown _ false.	showAllEnvelopes _ true.	self editSound: (sound ifNil: [FMSound brass1 copy]).	soundName ifNil: [soundName _ 'test'].	sampleDuration _ 250.  sound duration: sampleDuration.	sound duration: sampleDuration / 1000.0.	denominator _ 7.	self extent: 10@10.  "ie the minimum"! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:59'!addControls	| chooser |	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'editing ' , envelope name;		target: self;		actionSelector: #chooseFrom:envelopeItem:;		getItemsSelector: #curveChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topLeft with: graphArea bounds bottomLeft + (0@5).	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'duration: ' , self durationName;		target: self;		actionSelector: #chooseFrom:durationItem:;		getItemsSelector: #durationChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topRight with: graphArea bounds bottomRight + (-50@5).! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:49'!addKeyboard	keyboard _ PianoKeyboardMorph new soundPrototype: sound.	keyboard align: keyboard bounds bottomCenter with: bounds bottomCenter - (0@4).	self addMorph: keyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:56'!buildGraphAreaIn: frame	| r y |	graphArea _ RectangleMorph		newBounds: ((frame left + 40) @ (frame top + 40)		corner: (frame right+1) @ (frame bottom - 60))		color: Color lightGreen lighter lighter.	graphArea borderWidth: 1.	self addMorph: graphArea.	(envelope updateSelector = #pitch: and: [envelope scale <= 2.0]) ifTrue:		["Show half-steps"		r _ graphArea innerBounds.		0.0 to: 1.0 by: 1.0/12.0/envelope scale do:			[:val |			y _ self yFromValue: val.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].	(envelope updateSelector = #ratio: and: [denominator ~= 9999]) ifTrue:		["Show denominator gridding"		r _ graphArea innerBounds.		(0.0 to: 1.0 by: 1.0/denominator/envelope scale) do:			[:v |			y _ self yFromValue: v.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 13:16'!buildView	| frame |	self color: Color lightGreen.	self removeAllMorphs.	frame _ self innerBounds.	self buildGraphAreaIn: frame.	self buildScalesIn: frame.	self addHandlesIn: frame.	self addCurves.	line addHandles.	self addControls.	self addKeyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:57'!durationChoices	^ #(	'125ms'	'250ms'	'500ms'	'1000ms'	'2000ms'	'other'	'held'	)! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:29'!durationName	self durationChoices do:		[:c | c asNumber = sampleDuration ifTrue: [^ c]].	sampleDuration = 9999 ifTrue: [^ 'held'].	^ sampleDuration printString! !!EnvelopeEditorMorph methodsFor: 'scaling' stamp: 'di 9/4/1998 16:03'!extent: newExtent	super extent: (newExtent max: (self maxTime//10*3+50 max: 355) @ 284).	self buildView! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:45'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	envelope updateSelector = #ratio: ifTrue:		[menu add: 'choose denominator...' action: #chooseDenominator:].	menu add: 'adjust scale...' action: #adjustScale:.	SoundPlayer isReverbOn		ifTrue: [menu add: 'turn reverb off' target: SoundPlayer selector: #stopReverb]		ifFalse: [menu add: 'turn reverb on' target: SoundPlayer selector: #startReverb].	menu addLine.	menu add: 'get sound from lib' action: #chooseSound:.	menu add: 'put sound in lib' action: #saveSound:.	menu add: 'read sound from disk...' action: #readFromDisk:.	menu add: 'save sound on disk...' action: #saveToDisk:.	menu add: 'save library on disk...' action: #saveLibToDisk:.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:49'!chooseFrom: chooserMorph durationItem: item	| str |	item asNumber ~= 0 ifTrue: [sampleDuration _ item asNumber].	item = 'other' ifTrue:		[str _ FillInTheBlank request: 'duration in milliseconds'						initialAnswer: sampleDuration printString.		sampleDuration _ str asNumber].	item = 'held' ifTrue: [sampleDuration _ 9999].	sound duration: sampleDuration / 1000.0.	chooserMorph contentsClipped: 'duration: ' , self durationName! !!EnvelopeEditorMorph methodsFor: 'stepping' stamp: 'di 9/5/1998 10:56'!step	| mouseDown hand |	hand _ self world hands first.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown _ hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown _ mouseDown! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'di 9/15/1998 16:35'!handlesMouseOverDragging: evt	mouseEnterDraggingRecipient ifNotNil: [^ true].	mouseLeaveDraggingRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseEnterDragging: event fromMorph: sourceMorph	^ self send: mouseEnterDraggingSelector to: mouseEnterDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseLeaveDragging: event fromMorph: sourceMorph	^ self send: mouseLeaveDraggingSelector to: mouseLeaveDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].	mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterDraggingRecipient ifNotNil:		[list add: (mouseEnterDraggingRecipient class classThatUnderstands:					mouseEnterDraggingSelector) name , ' ', mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient ifNotNil:		[list add: (mouseLeaveDraggingRecipient class classThatUnderstands:					mouseLeaveDraggingSelector) name , ' ', mouseLeaveDraggingSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseDownSelector	^ mouseDownSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseUpSelector	^ mouseUpSelector! !!EventHandler methodsFor: 'access' stamp: 'sw 9/21/1998 12:07'!printOn: aStream	| aVal |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]]! !!EventHandler methodsFor: 'object fileIn' stamp: 'di 9/15/1998 16:35'!convertmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkv0: smartRefStrm	"These variables are automatically stored into the new instance ('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' ) and deal with the information in ()"! !!EventHandler methodsFor: 'object fileIn' stamp: 'tk 11/27/1998 20:37'!convertmmmmmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkv0: smartRefStrm	"These variables are automatically stored into the new instance ('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' ) and deal with the information in ('mouseEnterLadenRecipient' 'mouseEnterLadenSelector' 'mouseLeaveLadenRecipient' 'mouseLeaveLadenSelector' )"mouseEnterDraggingRecipient _ varDict at: 'mouseEnterLadenRecipient'.mouseEnterDraggingSelector _ varDict at: 'mouseEnterLadenSelector'.mouseLeaveDraggingRecipient _ varDict at: 'mouseLeaveLadenRecipient'.mouseLeaveDraggingSelector _ varDict at: 'mouseLeaveLadenSelector'.! !!EventRecorder methodsFor: 'as yet unclassified' stamp: 'jm 5/29/1998 14:21'!testControl: anEvent	"See if it is a control event for me.  Control 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"	anEvent isKeystroke ifFalse: [^ self].	anEvent controlKeyPressed ifFalse: [^ self].	anEvent commandKeyPressed ifTrue: [^ self].	"not this"	anEvent macOptionKeyPressed ifTrue: [^ self].	"not this"	anEvent shiftPressed ifTrue: [^ self].	"not this"	anEvent keyCharacter = $1 ifTrue: ["start recording"		tape ifNil: [tape _ OrderedCollection new].		state _ #record].	anEvent keyCharacter = $2 ifTrue: ["stop recording (or playing back)"		state _ nil].	anEvent keyCharacter = $3 ifTrue: ["start playing back"		state _ #play.		tape ifNotNil: [			tape do: [:evt | 				anEvent hand world runStepMethods.				anEvent hand handleEvent: evt.				anEvent hand world displayWorld]].		state _ nil].! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'jm 8/16/1998 17:36'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize _ 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginPrepareData	"The FFT plugin requires data to be represented in WordArrays or FloatArrays"	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ realData asFloatArray.	imagData _ imagData asFloatArray.! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginTest  "Display restoreAfter: [(FFT new nu: 12) pluginTest]."	"Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self pluginPrepareData.	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: true]); endEntry.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: false]); endEntry.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/11/1998 02:52'!pluginTransformData: forward	"Plugin testing -- if the primitive is not implemented 	or cannot be found run the simulation. See also: FFTPlugin"	<primitive: 'primitiveFFTTransformData'>	^FFTPlugin doPrimitive: 'primitiveFFTTransformData'.! !FFTPlugin is an example  of how plugins are written. It shows the use of FloatArray for heavy numerical stuff as well as the simulation of plugins from Squeak.See also:		FFT pluginTransformData:!]style[(173 24 1)f1,f1LFFT pluginTransformData:;,f1!!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTPermuteData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData].! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTScaleData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self scaleData.! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTTransformData	| rcvr forward |	self export: true.	forward _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	rcvr _ interpreterProxy stackObjectValue: 1.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self transformData: forward.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 00:25'!permuteData	| i end a b tmp |	self var: #tmp declareC: 'float tmp'.	i _ 0.	end _ permTableSize.	[i < end] whileTrue:		[a _ (permTable at: i) - 1.		b _ (permTable at: i+1) - 1.		(a < realDataSize and:[b < realDataSize]) ifFalse:[^interpreterProxy success: false].		tmp _ realData at: a.		realData at: a put: (realData at: b).		realData at: b put: tmp.		tmp _ imagData at: a.		imagData at: a put: (imagData at: b).		imagData at: b put: tmp.		i _ i + 2]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 10/3/1998 18:10'!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	self var: #realN declareC: 'float realN'.	fftSize <= 1 ifTrue:[^nil].	realN _ self cCoerce: (1.0 / (self cCoerce: fftSize to: 'double')) to: 'float'.	0 to: fftSize-1 do:		[:i |		realData at: i put: (realData at: i) * realN.		imagData at: i put: (imagData at: i) * realN]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 20:21'!transformData: forward	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData.		^nil].	self transformForward: forward.	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 21:28'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i fftSize2 fftSize4 fftScale ii |	self var: #realU declareC:'float realU'.	self var: #realT declareC:'float realT'.	self var: #imagU declareC:'float imagU'.	self var: #imagT declareC:'float imagT'.	fftSize2 _ fftSize // 2.	fftSize4 _ fftSize // 4.	1 to: nu do:		[:level |		lev _ 1 bitShift: level.		lev1 _ lev // 2.		fftScale _ fftSize // lev.		1 to: lev1 do:			[:j |			theta _ j-1 * fftScale.   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < fftSize4  "Compute U, the complex multiplier for each level"				ifTrue:					[realU _ sinTable at: sinTableSize - theta - 1.					imagU _ sinTable at: theta]				ifFalse:					[realU _ 0.0 - (sinTable at: theta - fftSize4).					imagU _ sinTable at: fftSize2 - theta].			forward ifFalse: [imagU _ 0.0 - imagU]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i _ j.			[i <= fftSize] whileTrue:				[ip _ i + lev1 - 1.				ii _ i-1.				realT _ ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT _ ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: ii) - realT.				imagData at: ip put: (imagData at: ii) - imagT.				realData at: ii put: (realData at: ii) + realT.				imagData at: ii put: (imagData at: ii) + imagT.				i _ i + lev]]].! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedFloatPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'float *'.	interpreterProxy success: (interpreterProxy isWords: oop).	interpreterProxy failed ifTrue:[^0].	^self cCoerce: (interpreterProxy firstIndexableField: oop) to:'float *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedWordPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'unsigned int *'.	interpreterProxy success: (interpreterProxy isWords: oop).	^self cCoerce: (interpreterProxy firstIndexableField: oop) to: 'unsigned int *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 10/10/1998 21:43'!loadFFTFrom: fftOop	| oop |	interpreterProxy success: (interpreterProxy slotSizeOf: fftOop) >= 6.	interpreterProxy failed ifTrue:[^false].	nu _ interpreterProxy fetchInteger: 0 ofObject: fftOop.	fftSize _ interpreterProxy fetchInteger: 1 ofObject: fftOop.	oop _ interpreterProxy fetchPointer: 2 ofObject: fftOop.	sinTableSize _ interpreterProxy stSizeOf: oop.	sinTable _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 3 ofObject: fftOop.	permTableSize _ interpreterProxy stSizeOf: oop.	permTable _ self checkedWordPtrOf: oop.	oop _ interpreterProxy fetchPointer: 4 ofObject: fftOop.	realDataSize _ interpreterProxy stSizeOf: oop.	realData _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 5 ofObject: fftOop.	imagDataSize _ interpreterProxy stSizeOf: oop.	imagData _ self checkedFloatPtrOf: oop.	"Check assumptions about sizes"	interpreterProxy success:		(1 << nu = fftSize) & 		(fftSize // 4 + 1 = sinTableSize) & 		(fftSize = realDataSize) & 		(fftSize = imagDataSize) &		(realDataSize = imagDataSize).	^interpreterProxy failed == false! !!FFTPlugin class methodsFor: 'accessing' stamp: 'ar 9/14/1998 23:51'!moduleName	^'sqFFT'! !!FFTPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:27'!declareCVarsIn: cg	cg var: 'sinTable' declareC:'float *sinTable'.	cg var: 'realData' declareC: 'float *realData'.	cg var: 'imagData' declareC:'float *imagData'.	cg var: 'permTable' declareC:'unsigned int *permTable'.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44'!initialize	super initialize.	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples _ SoundBuffer fromArray: anArray]		ifFalse: [samples _ anArray].	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ samples.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound new modulation: 0 ratio: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:10'!clarinet	"FMSound clarinet play"	"(FMSound lowMajorScaleOn: FMSound clarinet) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 2.	p _ OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p _ OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env _ Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute2	"FMSound flute2 play"	"(FMSound majorScaleOn: FMSound flute2) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!mellowBrass	"FMSound mellowBrass play"	"(FMSound lowMajorScaleOn: FMSound mellowBrass) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 70@0.325; add: 120@0.194; add: 200@0.194; add: 320@0.194; add: 380@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.1; add: 70@0.68; add: 120@0.528; add: 200@0.519; add: 320@0.528; add: 380@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd _ FMSound new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!oboe2	"FMSound oboe2 play"	"(FMSound majorScaleOn: FMSound oboe2) play"	| snd p |	snd _ FMSound new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:56'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 110@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:03'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:05'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/14/1998 20:27'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]  "response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.       "150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	resp size > 0 		ifTrue: [			resp first isDigit ifFalse: [ ^self lookFor: beginning ].				"we're in the middle of a line, not the end." #XXX. "this should be fixed..."			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"			]		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/14/1998 21:39'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Return true if OK, the error string if not."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	"Transcript show: resp; cr."	resp size > 0 		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'finalization' stamp: 'ar 3/21/98 18:19'!actAsExecutor	super actAsExecutor.	dataSocket := nil.! !This class implements the Fast Wavelet Transform.  It follows Mac Cody's article in Dr. Dobb's Journal, April 1992.  See also... 	http://www.dfw.net/~mcody/fwt/fwt.htmlNotable features of his implementation include...1.  The ability to generate a large family of wavelets (including the Haar (alpha=beta) and Daubechies) from two parameters, alpha and beta, which range between -pi and pi.2.  All data arrays have 5 elements added on to allow for convolution overrun with filters up to 6 in length (the max for this implementation).3.  After a forward transform, the detail coefficients of the deomposition are found in transform at: 2*i, for i = 1, 2, ... nLevels;  and the approximation coefficients are in transform at: (2*nLevels-1).  these together comprise the complete wavelet transform.The following changes from cody's listings should also be noted...1.  The three DotProduct routines have been merged into one.2.  The four routines WaveletDecomposition, DecomposeBranches, WaveletReconstruction, ReconstructBranches have all been merged into transformForward:.3.  All indexing follows the Smalltalk 1-to-N convention, naturally.!!FWT methodsFor: 'initialization' stamp: 'di 10/31/1998 12:23'!nSamples: n nLevels: nLevs	"Initialize a wavelet transform."	"Note the sample array size must be N + 5, where N is a multiple of 2^nLevels"	| dyadSize |	(n // (1 bitShift: nLevs)) > 0 ifFalse: [self error: 'Data size error'].	(n \\ (1 bitShift: nLevs)) = 0 ifFalse: [self error: 'Data size error'].	nSamples _ n.	samples _ Array new: n + 5.	nLevels _ nLevs.	transform _ Array new: nLevels*2.  "Transformed data is stored as a tree of coeffs"	dyadSize _ nSamples.	1 to: nLevels do:		[:i |  dyadSize _ dyadSize // 2.		transform at: 2*i-1 put: (Array new: dyadSize + 5).		transform at: 2*i put: (Array new: dyadSize + 5)]! !!FWT methodsFor: 'initialization' stamp: 'di 10/30/1998 10:59'!setAlpha: alph beta: bet	"Set alpha and beta, compute wavelet coeefs, and derive hFilter and lFilter"	| tcosa tcosb tsina tsinb |	alpha _ alph.	beta _ bet.	"WaveletCoeffs..."	"precalculate cosine of alpha and sine of beta"	tcosa _ alpha cos.	tcosb _ beta cos.	tsina _ alpha sin.	tsinb _ beta sin.	coeffs _ Array new: 6.		"calculate first two wavelet coefficients a _ a(-2) and b _ a(-1)"	coeffs at: 1 put: ((1.0 + tcosa + tsina) * (1.0 - tcosb - tsinb)					+ (2.0 * tsinb * tcosa)) / 4.0.	coeffs at: 2 put: ((1.0 - tcosa + tsina) * (1.0 + tcosb - tsinb)					- (2.0 * tsinb * tcosa)) / 4.0.	"precalculate cosine and sine of alpha minus beta"	tcosa _ (alpha - beta) cos.	tsina _ (alpha - beta) sin.	"calculate last four wavelet coefficients c _ a(0), d _ a(1), e _ a(2), and f _ a(3)"	coeffs at: 3 put: (1.0 + tcosa + tsina) / 2.0.	coeffs at: 4 put: (1.0 + tcosa - tsina) / 2.0.	coeffs at: 5 put: 1.0 - (coeffs at: 1) - (coeffs at: 3).	coeffs at: 6 put: 1.0 - (coeffs at: 2) - (coeffs at: 4).	"MakeFiltersFromCoeffs..."	"Select the non-zero wavelet coefficients"	coeffs _ coeffs copyFrom: (coeffs findFirst: [:c | c abs > 1.0e-14])						to: (coeffs findLast: [:c | c abs > 1.0e-14]).	"Form the low pass and high pass filters for decomposition"	hTilde _ coeffs reversed collect: [:c | c / 2.0].	gTilde _ coeffs collect: [:c | c / 2.0].	1 to: gTilde size by: 2 do:		[:i | gTilde at: i put: (gTilde at: i) negated].	"Form the low pass and high pass filters for reconstruction"	h _ coeffs copy.	g _ coeffs reversed.	2 to: g size by: 2 do:		[:i | g at: i put: (g at: i) negated]! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:19'!coeffs	"Return all coefficients neede to reconstruct the original samples"	| header csize strm |	header _ Array with: nSamples with: nLevels with: alpha with: beta.	csize _ header size.	1 to: nLevels do: [:i | csize _ csize + (transform at: i*2) size].	csize _ csize + (transform at: nLevels*2-1) size.	coeffs _ Array new: csize.	strm _ WriteStream on: coeffs.	strm nextPutAll: header.	1 to: nLevels do: [:i | strm nextPutAll: (transform at: i*2)].	strm nextPutAll: (transform at: nLevels*2-1).	^ coeffs! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:23'!coeffs: coeffArray	"Initialize this instance from the given coeff array (including header)."	| header strm |	strm _ ReadStream on: coeffArray.	header _ strm next: 4.	self nSamples: header first nLevels: header second.	self setAlpha: header third beta: header fourth.	1 to: nLevels do: [:i | transform at: i*2 put: (strm next: (transform at: i*2) size)].	transform at: nLevels*2-1 put: (strm next: (transform at: nLevels*2-1) size).	strm atEnd ifFalse: [self error: 'Data size error'].! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:26'!samples	^ samples copyFrom: 1 to: nSamples! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:25'!samples: anArray	1 to: anArray size do:		[:i | samples at: i put: (anArray at: i)].	nSamples+1 to: nSamples+5 do:		[:i | samples at: i put: 0.0]! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 09:20'!convolveAndDec: inData dataLen: inLen filter: filter out: outData	"convolve the input sequence with the filter and decimate by two"	| filtLen offset outi dotp |	filtLen _ filter size.	outi _ 1.	1 to: inLen+9 by: 2 do:		[:i | 		i < filtLen		ifTrue:			[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: i inc: 1]		ifFalse:			[i > (inLen+5)			ifTrue:				[offset _ i - (inLen+5).				dotp _ self dotpData: inData endIndex: inLen+5 filter: filter						start: 1+offset stop: filtLen inc: 1]			ifFalse:				[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: filtLen inc: 1]].		outData at: outi put: dotp.		outi _ outi + 1]! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 09:51'!convolveAndInt: inData dataLen: inLen filter: filter sumOutput: sumOutput into: outData	"insert zeros between each element of the input sequence and	   convolve with the filter to interpolate the data"	| outi filtLen oddTerm evenTerm |	outi _ 1.	filtLen _ filter size.	"every other dot product interpolates the data"	filtLen // 2 to: inLen + filtLen - 2 do:		[:i |		oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.		evenTerm _ self dotpData: inData endIndex: i+1 filter: filter									start: 1 stop: filter size inc: 2.		sumOutput			ifTrue:				["summation with previous convolution if true"				outData at: outi put: (outData at: outi) + oddTerm.				outData at: outi+1 put: (outData at: outi+1) + evenTerm]			ifFalse:				["first convolution of pair if false"				outData at: outi put: oddTerm.				outData at: outi+1 put: evenTerm].		outi _ outi + 2].	"Ought to be able to fit this last term into the above loop."	i _ inLen + filtLen - 1.	oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.	sumOutput		ifTrue: [outData at: outi put: (outData at: outi) + oddTerm]		ifFalse: [outData at: outi put: oddTerm].! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 12:55'!dotpData: data endIndex: endIndex filter: filter start: start stop: stop inc: inc	| sum i j |	sum _ 0.0.	j _ endIndex.	i _ start.	[i <= stop] whileTrue:		[sum _ sum + ((data at: j) * (filter at: i)).		i _ i + inc.		j _ j - 1].	^ sum! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 15:53'!transformForward: forward	| inData inLen outData |	forward	ifTrue:		["first InData is input signal, following are intermediate approx coefficients"		inData _ samples.  inLen _ nSamples.		1 to: nLevels do:			[:i |			self convolveAndDec: inData dataLen: inLen					filter: hTilde out: (transform at: 2*i-1).			self convolveAndDec: inData dataLen: inLen					filter: gTilde out: (transform at: 2*i).			inData _ transform at: 2*i-1.  inLen _ inLen // 2]]	ifFalse:		[inLen _ nSamples >> nLevels.		"all but last outData are next higher intermediate approximations,		last is final reconstruction of samples"		nLevels to: 1 by: -1 do:			[:i |			outData _ i = 1 ifTrue: [samples]						ifFalse: [transform at: 2*(i-1)-1].			self convolveAndInt: (transform at: 2*i-1) dataLen: inLen					filter: h sumOutput: false into: outData.			self convolveAndInt: (transform at: 2*i) dataLen: inLen					filter: g sumOutput: true into: outData.			inLen _ inLen * 2]]! !!FWT methodsFor: 'testing' stamp: 'di 10/31/1998 12:25'!doWaveDemo  "FWT new doWaveDemo"	"Printing the above should yield a small number -- I get 1.1e-32"	| originalData |	self nSamples: 312 nLevels: 3.	self setAlpha: 0.0 beta: 0.0.	"Install a sine wave as sample data"	self samples: ((1 to: nSamples) collect: [:i | ((i-1) * 0.02 * Float pi) sin]).	originalData _ samples copy.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (0@0 extent: nSamples@100).	"Transform forward and plot the decomposition"	self transformForward: true.	transform withIndexDo:		[:w :i |		FFT new plot: (w copyFrom: 1 to: w size-5)			in: (i-1\\2*320@(i+1//2*130) extent: (w size-5)@100)].	"Test copy out and read in the transform coefficients"	self coeffs: self coeffs.	"Ttransform back, plot the reconstruction, and return the error figure"	self transformForward: false.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (320@0 extent: nSamples@100).	^ self meanSquareError: originalData! !!FWT methodsFor: 'testing' stamp: 'di 10/30/1998 15:58'!meanSquareError: otherData	"Return the mean-square error between the current sample array and	some other data, presumably to evaluate a compression scheme."	| topSum bottomSum pointDiff |	topSum _ bottomSum _ 0.0.	1 to: nSamples do:		[:i |  pointDiff _ (samples at: i) - (otherData at: i).		topSum _ topSum + (pointDiff * pointDiff).		bottomSum _ bottomSum + ((otherData at: i) * (otherData at: i))].	^ topSum / bottomSum! !!FWT methodsFor: 'testing' stamp: 'di 10/31/1998 22:17'!viewPhiAndPsi  "(FWT new nSamples: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p _ Sensor cursorPoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !This class adds the following optimizations to the basic Inflate decompression:a) Bit reversed accessIf we want to fetch the bits efficiently then we have them in the wrong bit order (e.g., when we should fetch 2r100 we would get 2r001). But since the huffman tree lookup determines the efficiency of the decompression, reversing the bits before traversal is expensive. Therefore the entries in each table are stored in REVERSE BIT ORDER. This is achieved by a reverse increment of the current table index in the huffman table construction phase (see method increment:bits:). According to my measures this speeds up the implementation by about 30-40%.b) Inplace storage of code meanings and extra bitsRather than looking up the meaning for each code during decompression of blocks we store the appropriate values directly in the huffman tables, using a pre-defined mapping. Even though this does not make a big difference in speed, it cleans up the code and allows easier translation into primitive code (which is clearly one goal of this implementation).c) Precomputed huffman tables for fixed blocksSo we don't have to compute the huffman tables from scratch. The precomputed tables are not in our superclass to avoid double storage (and my superclass is more intended for documentation anyways).!!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/5/1998 14:50'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit _ readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra _ (value bitShift: -16) - 1.			length _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ (value bitShift: -16).			distance _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length > collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length + 1 					with: collection 					startingAt: readLimit - distance + 1.			readLimit _ readLimit + length.		].	].! !!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:15'!processFixedBlock	litTable _ FixedLitTable.	distTable _ FixedDistTable.	state _ state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!distanceMap	^DistanceMap! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment value in reverse bit order, e.g. 	for a 3 bit value count as follows:		000 / 100 / 010 / 110		001 / 101 / 011 / 111	See the class comment why we need this."	| result bit |	result _ value.	"Test the lowest bit first"	bit _ 1 << (nBits - 1).	"If the currently tested bit is set then we need to	turn this bit off and test the next bit right to it"	[(result bitAnd: bit) = 0] whileFalse:[ 		"Turn off current bit"		result _ result bitXor: bit.		"And continue testing the next bit"		bit _ bit bitShift: -1].	"Turn on the right-most bit that we haven't touched in the loop above"	^result bitXor: bit! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!literalLengthMap	^LiteralLengthMap! !!FastInflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:02'!nextSingleBits: n	"Fetch the bits all at once"	^self nextBits: n.! !!FastInflateStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 19:17'!initialize	"FastInflateStream initialize"	| low high |	"Init literal/length map"	low _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 ).	high _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0 0).	LiteralLengthMap _ Array new: 256 + 32.	1 to: 257 do:[:i| LiteralLengthMap at: i put: i-1].	1 to: 29 do:[:i| LiteralLengthMap at: 257+i put: (low at:i) + ( (high at: i) + 1 << 16)].	"Init distance map"	high _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	low _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769			1025 1537 2049 3073 4097 6145 8193 12289 16385 24577).	DistanceMap _ Array new: 32.	1 to: 30 do:[:i| DistanceMap at: i put: (low at: i) + ( (high at: i) << 16)].	"Init fixed block huffman tables"	FixedLitTable _ self basicNew				huffmanTableFrom: FixedLitCodes				mappedBy: LiteralLengthMap.	FixedDistTable _ self basicNew				huffmanTableFrom: FixedDistCodes				mappedBy: DistanceMap.! !!FileContentsBrowser methodsFor: 'accessing'!contents	self updateInfoView.	(editSelection == #newClass and:[self selectedPackage notNil])		ifTrue: [^self selectedPackage packageInfo].	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!FileContentsBrowser methodsFor: 'accessing'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	self inform:'You cannot change the current selection'.	^false! !!FileContentsBrowser methodsFor: 'accessing'!packages	^packages! !!FileContentsBrowser methodsFor: 'accessing'!packages: aDictionary	packages := aDictionary.! !!FileContentsBrowser methodsFor: 'accessing'!selectedPackage	| cat |	cat := self selectedSystemCategoryName.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeClass	| class |	classListIndex = 0 ifTrue: [^ self].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:46'!removeMessage	| messageName |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	(self selectedClassOrMetaClass confirmRemovalOf: messageName) ifFalse:[^false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:51'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:52'!removePackage	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategoryName.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:41'!removeUnmodifiedCategories	| theClass |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass selectors).	].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage isNil						ifTrue:[self packages] 						ifFalse:[Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:44'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	cat := self selectedMessageCategoryName.	cat isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asSortedCollection].! !!FileContentsBrowser methodsFor: 'class list'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'wod 5/24/1998 20:37'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileContentsBrowser methodsFor: 'class list'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	self selectedClassName == nil ifTrue: [^nil].	^self selectedPackage classAt: self selectedClassName! !!FileContentsBrowser methodsFor: 'edit pane'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	^self methodDiffFor: contents class: self selectedClass selector: self selectedMessageName meta: self metaClassIndicated! !!FileContentsBrowser methodsFor: 'diffs'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta	| theClass source diff |	theClass := Smalltalk at: aPseudoClass name ifAbsent:[^aString copy].	meta ifTrue:[theClass := theClass class].	(theClass includesSelector: selector) ifFalse:[^aString copy].	source := theClass sourceCodeAt: selector.	Cursor wait showWhile:[		diff := TextDiffBuilder buildDisplayPatchFrom: source to: aString.	].	^diff! !!FileContentsBrowser methodsFor: 'diffs'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	Cursor wait showWhile:[		diff := ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInClass	Cursor read showWhile:[		self selectedClass fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileInMessage		self selectedMessageName ifNil: [^self].	Cursor read showWhile: [		self selectedClassOrMetaClass fileInMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInMessageCategories	Cursor read showWhile:[		self selectedClass fileInCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 12:50'!fileInPackage	Cursor read showWhile:[		self selectedPackage fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutClass	Cursor write showWhile:[		self selectedClass fileOut.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileOutMessage	self selectedMessageName ifNil: [^self].	Cursor write showWhile: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutMessageCategories	Cursor write showWhile:[		self selectedClass fileOutCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutPackage	Cursor write showWhile:[		self selectedPackage fileOut.	].! !!FileContentsBrowser methodsFor: 'infoView'!infoString	^infoString isNil		ifTrue:[infoString := StringHolder new]		ifFalse:[infoString]! !!FileContentsBrowser methodsFor: 'infoView'!infoViewContents	| theClass |	editSelection == #newClass ifTrue:[^self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue:[^''].	theClass := Smalltalk at: (self selectedClass name asSymbol) ifAbsent:[nil].	editSelection == #editClass ifTrue:[		^(theClass notNil)			ifTrue:['Class exists already in the system']			ifFalse:['New class']].	(editSelection == #editMessage) ifFalse:[^''].	(theClass notNil and:[self metaClassIndicated]) ifTrue:[theClass := theClass class].	^(theClass notNil and:[theClass includesSelector: self selectedMessageName])		ifTrue:['Method already exists in the system']		ifFalse:['New method']! !!FileContentsBrowser methodsFor: 'infoView'!packageInfo: p	| nClasses newClasses oldClasses |	p isNil ifTrue:[^''].	nClasses := newClasses := oldClasses := 0.	p classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue:[oldClasses := oldClasses + 1]			ifFalse:[newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'wod 5/19/1998 17:34'!updateInfoView	Smalltalk isMorphic 		ifTrue: [self changed: #infoViewContents]		ifFalse: [			self infoString contents: self infoViewContents.			self infoString changed].! !!FileContentsBrowser methodsFor: 'metaclass'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass metaClass]		ifFalse: [^ self selectedClass]! !!FileContentsBrowser methodsFor: 'metaclass'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'wod 5/25/1998 00:46'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	messageListIndex ~= 0 		ifTrue: [Smalltalk browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other' stamp: 'di 1/13/1999 09:45'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		(class exists and: [class realClass includesSelector: selector]) ifTrue:			[ChangeList			browseVersionsOf: (class realClass compiledMethodAt: selector)			class: class realClass			meta: class realClass isMeta			category: self selectedMessageCategoryName			selector: selector]]! !!FileContentsBrowser methodsFor: 'other'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/19/1998 18:24'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/24/1998 01:56'!defaultBackgroundColor	^ #tan! !!FileContentsBrowser methodsFor: 'creation' stamp: 'di 1/13/1999 09:32'!openAsMorph	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window aListExtent next |	window _ (SystemWindow labelled: 'later') model: self.	self packages size = 1		ifTrue: [			aListExtent _ 0.333333 @ 0.34.			self systemCategoryListIndex: 1.			window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton					selected: #indexIsOne changeSelected: #indexIsOne:					menu: #packageListMenu:)				frame: (0@0 extent: 1.0@0.06).			next := 0@0.06]		ifFalse: [			aListExtent _ 0.25 @ 0.4.			window addMorph: (PluggableListMorph on: self list: #systemCategoryList					selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:					menu: #packageListMenu:)				frame: (0@0 extent: aListExtent).			next := aListExtent x @ 0].	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (next extent: aListExtent - (0.0 @ 0.05)).	window addMorph: self buildMorphicSwitches		frame: (next + (0 @ (aListExtent y - 0.05)) extent: aListExtent x @ 0.05).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (next extent: aListExtent).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:			keystroke: #messageListKey:from:)		frame: (next extent: aListExtent).	window addMorph: (PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@0.94).	window addMorph: (PluggableTextMorph on: self text: #infoViewContents accept: nil			readSelection: nil menu: nil)		frame: (0@0.94 corner: 1@1).	^ window! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:18'!classListMenu: aMenu	^ aMenu 		labels:'definitioncommentclass refsfileInfileOutrename...removeremove existing'		lines: #(2 3 5 7)		selections: #(editClass editComment browseClassRefs fileInClass fileOutClass renameClass removeClass removeUnmodifiedCategories) ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 17:39'!messageCategoryMenu: aMenu	^ aMenu 		labels:'fileInfileOutreorganizeadd item...rename...removeremove existing'		lines: #(2 3 6)		selections: #(fileInMessageCategories fileOutMessageCategories editMessageCategories addCategory renameCategory removeMessageCategory removeUnmodifiedMethods)! !!FileContentsBrowser methodsFor: 'menus' stamp: 'di 1/13/1999 09:47'!messageListMenu: aMenu	^ aMenu 		labels:'fileInfileOutsendersimplementorsversionsremove'		lines: #(2 5)		selections: #(fileInMessage fileOutMessagebrowseSenders browseImplementors browseVersionsremoveMessage).! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:09'!packageListMenu: aMenu	^ aMenu 		labels:'find class...fileInfileOutremoveremove existing'		lines: #(1 3 4)		selections: #(findClass fileInPackage fileOutPackage removePackage removeUnmodifiedClasses)! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/13/1998 18:17'!browseFile: aFilename	self browseFiles: (Array with: aFilename).! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/14/1998 23:40'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package _ FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'Package Browser'.! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 9/27/1998 21:34'!fullNamesOfAllFilesInSubtree	"Answer a collection containing the full names of all the files in the subtree of the file system whose root is this directory."	| result todo dir |	result _ OrderedCollection new: 100.	todo _ OrderedCollection with: self.	[todo size > 0] whileTrue: [		dir _ todo removeFirst.		dir fileNames do: [:n | result add: (dir fullNameFor: n)].		dir directoryNames do: [:n | todo add: (dir directoryNamed: n)]].	^ result asArray! !!FileDirectory methodsFor: 'enumeration' stamp: 'wod 6/16/1998 15:07'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"wod 6/16/1998: add Cursor wait, and use 'self pathNameDelimiter asString' rather than hardwired ':' "	"FileDirectory default statsForDirectoryTree: '\smalltalk'"	| dirs files bytes todo p entries |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			entries _ self directoryContentsFor: p.			entries do: [:entry |				(entry at: 4)					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, (entry at: 1)).						dirs _ dirs + 1]					ifFalse: [						files _ files + 1.						bytes _ bytes + (entry at: 5)]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'file operations' stamp: 'wod 11/5/1998 18:41'!copyFileNamed: fileName1 toFileNamed: fileName2	"Copy the contents of the existing file with the first name into a new file with the second name. Both files are assumed to be in this directory."	"FileDirectory default copyFileNamed: 'todo.txt' toFileNamed: 'todocopy.txt'"	| file1 file2 buffer |	file1 _ (self readOnlyFileNamed: fileName1) binary.	file2 _ (self newFileNamed: fileName2) binary.	buffer _ String new: 50000.	[file1 atEnd] whileFalse:		[file2 nextPutAll: (file1 nextInto: buffer)].	file1 close.	file2 close.! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 3/21/98 18:08'!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock.	If the first deletion attempt fails do a GC to force finalization of any lost references. ar 3/21/98 17:53"	(self 		retryWithGC:[self primDeleteFileNamed: (self fullNameFor: localFileName)]		until:[:result| result notNil]) == nil			ifTrue: [^failBlock value].! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 3/21/98 18:10'!rename: oldFileName toBe: newFileName	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	(self retryWithGC:[self primRename: (self fullNameFor: oldFileName)						to: (self fullNameFor: newFileName)]		until:[:result| result notNil]) == nil ifTrue:[	self error:'Attempt to rename a non-existent file,or to use a name that is already in use'].! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:44'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [^ OrderedCollection new].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:43'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'private' stamp: 'ar 3/21/98 18:04'!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.	Changed to return nil instead of failing ar 3/21/98 18:04"	<primitive: 159>	^nil! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:54'!entryAt: fileName  	"find the entry with local name fileName"	^self entryAt: fileName ifAbsent: [ self error: 'file not indirectory: ', fileName ].! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:53'!entryAt: fileName  ifAbsent: aBlock	"find the entry with local namefileName"	^self entries 		detect: [ :entry | (entry at: 1) =fileName ] 		ifNone: [ aBlock value ]! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:32'!changeSuffix"if 'changes' is not suitable, override this message to return something that is ok"	^'changes'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:31'!imageSuffix"if 'image' is not suitable, override this message to return something that is ok"	^'image'! !!FileDirectory class methodsFor: 'system start up' stamp: 'tk 12/10/1998 11:40'!openSources: sourcesName andChanges: changesName forImage: imageName	"Initialize the default directory to the image directory and open the sources and changes files, if possible. Look for the changes file in image directory. Look for the system sources (or an alias to it) first in the VM directory, then in the image directory. Open the changes and sources files and install them in SourceFiles."	"Note: SourcesName and imageName are full paths; changesName is a local name."	| sources changes sourceAlias msg localSourcesName |	msg _'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	self setDefaultDirectoryFrom: imageName.	sources _ changes _ nil.	"look for the sources file or an alias to it in the VM's directory"	(DefaultDirectory fileExists: sourcesName)		ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourcesName]		ifFalse: [			"look for an un-renamed Macintosh alias to the sources file"			sourceAlias _ sourcesName, ' alias'.			(DefaultDirectory fileExists: sourceAlias)				ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]].	sources ifNil: [		"look for the sources file or an alias to it in the image directory"		localSourcesName _ FileDirectory localNameFor: sourcesName.		(DefaultDirectory fileExists: localSourcesName)			ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: localSourcesName]			ifFalse: [				"look for an un-renamed Macintosh alias to the sources file"				sourceAlias _ localSourcesName, ' alias'.				(DefaultDirectory fileExists: sourceAlias)					ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]]].	(DefaultDirectory fileExists: changesName)		ifTrue: [changes _ DefaultDirectory oldFileNamed: changesName].	(((sources == nil) or: [sources atEnd]) and: 		[Preferences valueOfFlag: #warnIfNoSourcesFile]) ifTrue: [			PopUpMenu notify:				(msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName).			(Smalltalk getSystemAttribute: 1001) = 'Mac OS' ifTrue:[				PopUpMenu notify: 'Make sure the sources file is not an Alias.']].	((changes == nil) and: 		[Preferences valueOfFlag: #warnIfNoChangesFile]) 		ifTrue: [PopUpMenu notify:			(msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	SourceFiles _ Array with: sources with: changes.! !!FileDirectory class methodsFor: 'system start up' stamp: 'jm 11/25/1998 21:54'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryFrom: Smalltalk imageName.! !!FileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:49'!pathNameDelimiter"return the active directory class's directory seperator character"	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList methodsFor: 'initialization' stamp: 'di 5/25/1998 10:26'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:05'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '"Please fill in the following info, then select all text and choose DoIt."| aa | aa _ ServerDirectory new.aa server: ''st.cs.uiuc.edu''.    "host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.    "<- this is optional.  Only used when *writing* update files."ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 1/14/1999 21:25'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles sortBlock |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:08'!removeServer	| choice names |	names _ ServerDirectory serverNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 16:49'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim _ directory pathNameDelimiter.				path _ String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:07'!volumeMenu: aMenu	^ aMenu		labels:'add server...remove server...'		lines: # ()		selections: #(askServerInfo removeServer)! !!FileList methodsFor: 'file list' stamp: 'di 5/26/1998 20:22'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - self folderString size.					listIndex _ 0.					brevityState _ #FileList.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'file list menu' stamp: 'ls 7/15/1998 20:59'!addNewDirectory	"Add a new directory and update the list"	| newName index ending |	self okToChange ifFalse: [^ self].	newName _ (FillInTheBlank request: 'New Directory Name?' 					initialAnswer: 'DirectoryName') asFileName.	Cursor wait showWhile: [		(directory createDirectory: newName)].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/16/1998 12:22'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: 'Really delete ' , fileName , '?') ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/24/1998 16:21'!fileAllIn	"File in all of the currently selected file, if any."	"wod 5/24/1998: open the file read only."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn.! !!FileList methodsFor: 'file list menu' stamp: 'sw 11/22/1998 23:57'!fileIntoNewChangeSet	"File in all of the contents of the currently selected file, if any, into a new change set."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ChangeSorter newChangesFromStream: ff named: fileName.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:06'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:02'!importImage	"Import the given image file and store the resulting Form in the global dictionary	ImageImports, at a key consisting of the short filename up to the first period.  "	| key image |	key _ fileName sansPeriodSuffix.	image _ Form fromFileNamed: self fullName.	Smalltalk imageImports at: key put: image.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 15:30'!itemsForAnyFile	^ #(('copy name to clipboard' 'rename' 'delete')		()		(copyName renameFile deleteFile)		)! !!FileList methodsFor: 'file list menu' stamp: 'tk 12/14/1998 18:44'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels add: 'view decompressed'.		selectors add: #viewGZipContents].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 11/19/1998 14:25'!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'browse code files'		'add new file' 'add new directory')		(3 4)		(sortByName sortBySize sortByDate		browseFiles		addNewFile addNewDirectory)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:34'!noFileSelectedMenu: aMenu	| items |	items _ self itemsForNoFile.	^ aMenu		labels: items first		lines: items second		selections: items third! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:05'!offerAllFileOptions	| items action |	items _ self itemsForFileEnding: '*'.	action _ (SelectionMenu labels: items first lines: items second selections: items third)			startUp.	action ifNotNil: [self perform: action]! !!FileList methodsFor: 'file list menu' stamp: 'ar 10/12/1998 23:44'!openAsFlash	"Open a MoviePlayerMorph on the given file (must be in .movie format)."	| f |	Smalltalk at: #Morph ifAbsent: [^ self beep].	f _ (directory readOnlyFileNamed: self fullName) binary.	(FlashMorphReader on: f) processFile.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/17/1998 17:31'!openAsMovie	"Open a MoviePlayerMorph on the given file (must be in .movie format)." 	Smalltalk at: #Morph ifAbsent: [^ self beep].	(MoviePlayerMorph new openFileNamed: self fullName) openInWorld! !!FileList methodsFor: 'file list menu' stamp: 'ar 11/14/1998 23:46'!openAsTTF	(TTFontReader parseFileNamed: self fullName) asMorph open! !!FileList methodsFor: 'file list menu' stamp: 'tk 12/14/1998 19:12'!openBookFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	book _ BookMorph new fromRemoteStream: aFileStream.	World		ifNotNil:			[World addMorphsAndModel: book]		ifNil:			[(book isKindOf: Morph)				ifFalse:					[^ self inform: 'can only load a single morph into an MVC project via this mechanism'].				book openInWorld].	book goToPage: 1.! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:03'!openImageInWindow	"Handle four file formats: GIF, JPG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image |	image _ Form fromFileNamed: self fullName.	World		ifNil: [FormView open: image named: fileName]		ifNotNil: [World addMorph: (SketchMorph new form: image)].! !!FileList methodsFor: 'file list menu' stamp: 'tk 12/14/1998 19:06'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	World		ifNotNil:			[World addMorphsAndModel: morphOrList]		ifNil:			[(morphOrList isKindOf: Morph)				ifFalse:					[^ self inform: 'can only load a single morph into an mvc project via this mechanism'].				morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/29/1998 17:09'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory oldFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FileList methodsFor: 'file list menu' stamp: 'di 5/24/1998 14:09'!putUpdate	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdate: 				(directory oldFileNamed: self fullName).! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/3/1998 17:24'!renderFile	"Render the currently selected file"	| map action file renderedFile formatPage |	listIndex = 0 ifTrue: [^ self].	map _ URLmap new.	action _ RenderedSwikiAction new.	action name: '.'.  "For image references, refer to this directory"	map action: action.	map directory: directory.	(directory fileExists: 'glossary')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'glossary') close].].	map readGlossary: (directory oldFileNamed: 'glossary').	formatPage _ SwikiPage new.	formatPage map: map.	formatPage coreID: (fileName allButFirst).	formatPage formatted: (HTMLformatter		evalEmbedded: (directory oldFileNamed: fileName)contentsOfEntireFile		with: formatPage		unlessContains: (Set new)).	formatPage name isNil		ifTrue: [self notify: 'You forgot to name the page!!<?request name: ''myname''?>'.				formatPage name: 'defaultName'.].	map pages at: (formatPage name asLowercase) put: formatPage.	formatPage formatted: (LessHTMLformatter swikify: (formatPageformatted)			linkhandler: [:link | map					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	"Make a template if one does not exist"	(directory fileExists: 'template.html')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'template.html') nextPutAll: (selftemplateFile); close].].	renderedFile _ (directory pathName),(ServerActionpathSeparator),(formatPage coreID).	(directory fileExists: renderedFile)		ifTrue: [directory deleteFileNamed: renderedFile].	file _ FileStream fileNamed: renderedFile.	file nextPutAll: (HTMLformatter evalEmbedded:		(directory oldFileNamed: 'template.html') contentsOfEntireFile			with: formatPage).	file close.	FileDirectory default setMacFileNamed: renderedFile		type: 'TEXT'		creator: 'MOSS'.	map writeGlossary. "Directory is already in the map, so write tothe glossary there"	self updateFileList.! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/1/1998 14:10'!templateFile	^'<head><title><?request name?></title></head><body><?request formatted?></body>'! !!FileList methodsFor: 'file list menu' stamp: 'ar 12/5/1998 14:57'!viewGZipContents	"View the contents of a gzipped file"	| f |	f _ (directory readOnlyFileNamed: self fullName).	contents _ f contentsOfEntireFile.	Cursor wait showWhile:[contents _ (GZipStream on: contents) upToEnd].	contents replaceAll: Character lf with: Character cr.	(StringHolder new)		contents: contents;		openLabel:'Contents of ', fileName printString! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:26'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:25'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED'; cr.					s nextPutAll: '  -- Folder Summary --'; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findFirst: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:46'!put: aText	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[PopUpMenu notify: 'No fileName is selected'.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	PopUpMenu notify: type , ' contents cannotmeaningfully be saved at present.'.	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:22'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:20'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	((size _ f size)) > 5000 & brevity		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	^ contents _ ((size > 5000) & brevity		ifTrue: ['File ''', fileName, ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', hexData , '------------------------------------------... end of the first 5000 characters.']		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'ls 9/11/1998 04:15'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents]! !!FileList methodsFor: 'private' stamp: 'wod 5/27/1998 17:47'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	"wod 5/27/1998: nil out the fileName."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [self listForPattern: pattern]			ifFalse: [				pattern isEmpty					ifTrue: [self listForPattern: '*']					ifFalse: [self listForPattern: '*', pattern, '*']].		listIndex _ 0.		volListIndex _ volList size.		fileName _ nil.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFile	FileContentsBrowser browseFile: self fullName.! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFiles	| selectionPattern fileList |	selectionPattern := FillInTheBlank request:'What files?' initialAnswer: self pattern.	fileList _ (directory fileNamesMatching: selectionPattern) 		collect: [:each | directory fullNameFor: each].	FileContentsBrowser browseFiles: fileList.! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:23'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView |	World ifNotNil: [^ self openAsMorph].	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/28/1998 10:37'!openAsMorph     "FileList openAsMorph openInMVC"	"Open a morphic view of a FileList on the default directory."	| dir aFileList window |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:22'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	window openInWorld! !!FilePackage methodsFor: 'accessing'!classAt: className	^self classes at: className! !!FilePackage methodsFor: 'accessing'!classes	^classes! !!FilePackage methodsFor: 'accessing'!fullPackageName	^fullName! !!FilePackage methodsFor: 'accessing'!packageInfo	^String streamContents:[:s|		s nextPutAll:'Package: '.		s nextPutAll: self fullPackageName; cr; cr.		sourceSystem isEmpty ifFalse:[			s nextPutAll: sourceSystem; cr; cr].		doIts isEmpty ifFalse:[			s nextPutAll:'Unresolvable doIts:'; cr; cr.			doIts do:[:chgRec|				s nextPut:$!!; nextPutAll: chgRec string; nextPut: $!!; cr]]].! !!FilePackage methodsFor: 'accessing'!packageName	^packageName! !!FilePackage methodsFor: 'accessing'!removeClass: aPseudoClass	(self classes removeKey: aPseudoClass name).	classOrder copy do:[:cls|		cls name = aPseudoClass name ifTrue:[ classOrder remove: cls].	].! !!FilePackage methodsFor: 'accessing'!renameClass: aPseudoClass to: newName	| oldName |	oldName := aPseudoClass name.	self classes removeKey: oldName.	self classes at: newName put: aPseudoClass.	aPseudoClass renameTo: newName.! !!FilePackage methodsFor: 'initialize'!fromFileNamed: aName	| stream |	fullName := aName.	packageName := FileDirectory localNameFor: fullName.	stream := FileStream readOnlyFileNamed: aName.	doIts := OrderedCollection new.	classOrder := OrderedCollection new.	sourceSystem := ''.	self fileInFrom: stream.! !!FilePackage methodsFor: 'private'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	tokens size = 11 ifFalse:[^doIts add: chgRec].	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: 'private'!getClass: className	| pseudoClass |	(classes includesKey: className) ifTrue:[		^classes at: className.	].	pseudoClass := PseudoClass new.	pseudoClass name: className.	classes at: className put: pseudoClass.	^pseudoClass.! !!FilePackage methodsFor: 'private'!metaClassDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	theClass := self getClass: (tokens at: 1).	theClass metaClass definition: string.	classOrder add: theClass metaClass.! !!FilePackage methodsFor: 'private'!msgClassComment: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 3) class == String]) ifTrue:[		theClass := self getClass: tokens first.		^theClass commentString: tokens last].	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) class == String]]) ifTrue:[		theClass := self getClass: tokens first.		theClass metaClass commentString: tokens last].! !!FilePackage methodsFor: 'private'!possibleSystemSource: chgRec	| tokens |	sourceSystem isEmpty ifTrue:[		tokens := Scanner new scanTokens: chgRec string.		(tokens size = 1 and:[tokens first class == String]) ifTrue:[			sourceSystem := tokens first.			^self]].	doIts add: chgRec.! !!FilePackage methodsFor: 'private'!removedMethod: string with: chgRec	| class tokens |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 2) == #removeSelector: ]) ifTrue:[		class := self getClass: (tokens at: 1).		^class removeSelector: (tokens at: 3).	].	(tokens size = 4 and:[(tokens at: 2) == #class and:[(tokens at: 3) == #removeSelector:]]) ifTrue:[		class := self getClass: (tokens at: 1).		^class metaClass removeSelector: (tokens at: 4).	].	doIts add: chgRec! !!FilePackage methodsFor: 'private'!sampleMethod"	In an existing method there are always a number of changes.	Other stuff		will be deleted	Or even better,		some things may be just modified."! !!FilePackage methodsFor: 'change record types'!classComment: chgRec	(self getClass: chgRec methodClassName) classComment: chgRec! !!FilePackage methodsFor: 'change record types'!doIt: chgRec	| string |	string := chgRec string.	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'		match: string) ifTrue:[^self classDefinition: string with: chgRec].	('* class*instanceVariableNames:*'		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].	('* removeSelector: *'		match: string) ifTrue:[^self removedMethod: string with: chgRec].	('* comment:*'		match: string) ifTrue:[^self msgClassComment: string with: chgRec].	('* initialize'		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"	('''From *'		match: string) ifTrue:[^self possibleSystemSource: chgRec].	doIts add: chgRec.! !!FilePackage methodsFor: 'change record types'!method: chgRec	(self getClass: chgRec methodClassName) methodChange: chgRec! !!FilePackage methodsFor: 'change record types'!preamble: chgRec	self doIt: chgRec! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu _ SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice _ menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 16:00'!fileIn	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileInDoits].	classOrder do:[:cls|		cls fileInDefinition.	].	classes do:[:cls|		Transcript cr; show:'Filing in ', cls name.		cls fileInMethods.		cls hasMetaclass ifTrue:[cls metaClass fileInMethods].	].	doitsMark = 3 ifTrue:[self fileInDoits].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileInDoits	doIts do:[:chgRec| chgRec fileIn].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'tk 1/8/1999 08:00'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.	DeepCopier new checkVariables.! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOutDoits: aStream	doIts do:[:chgRec| chgRec fileOutOn: aStream].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:59'!fileOutOn: aStream	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileOutDoits: aStream].	classOrder do:[:cls|		cls fileOutDefinitionOn: aStream.	].	classes do:[:cls|		cls fileOutMethodsOn: aStream.		cls hasMetaclass ifTrue:[cls metaClass fileOutMethodsOn: aStream].	].	doitsMark = 3 ifTrue:[self fileOutDoits: aStream].! !!FilePackage methodsFor: 'reading'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	aStream close.	classes := Dictionary new.	('Processing ', self packageName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbol with: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation'!fromFileNamed: aName	^self new fromFileNamed: aName! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:00'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!FileStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:42'!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	self fileInAnnouncing: 'Loading ', self localName! !!FileStream methodsFor: 'fileIn/Out' stamp: 'jm 8/19/1998 16:59'!fileInObjectAndCode	"Optimization: If the file is small, read the entire file into memory before processing."	| s |	self text.	((self size < 1000000) and: [Smalltalk garbageCollectMost > 3000000])		ifTrue: [			s _ RWBinaryOrTextStream with: (self contentsOfEntireFile).			s position: 0.			^ s fileInObjectAndCode]		ifFalse: [^ super fileInObjectAndCode].! !!FileStream class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 05:19'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: fName! !!FileStream class methodsFor: 'concrete classes' stamp: 'ls 7/11/1998 02:58'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream  "may change this to CrLfFileStream"! !A reference to a local file.  The url itself uses the UNIX notation of %20 for space.  path has the tokens translated to ascii, except if we have a UNIX file system. path is OC of path parts.  If last is empty string, then referring to a directory.!!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 13:05'!privateInitializeFromText: text	| bare schemeName pathString |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	path _ pathString findTokens: '/'.	path _ path collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ path addLast: '' ].	isAbsolute _ pathString beginsWith: '/'.! !!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 16:40'!privateInitializeFromText: aString relativeTo: aUrl	| bare |	bare _ aString.	(bare beginsWith: (self schemeName, ':')) ifTrue: [		bare _ bare copyFrom: (self schemeName size + 2) to: bare size ].	(bare beginsWith: '/') ifTrue: [ ^self privateInitializeFromText: aString ].	isAbsolute _ aUrl isAbsolute.	path _ aUrl path copy.	path removeLast.	"empty string that says its a directory"	(bare findTokens: '/') do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			path addLast: token unescapePercents ].		token = '..' ifTrue: [ 			path isEmpty ifFalse: [ 				path last = '..' ifFalse: [ path removeLast ] ] ].		"token = '.' do nothing" ].	(bare endsWith: '/') ifTrue: [ path add: '' ].! !!FileUrl methodsFor: 'printing' stamp: 'tk 1/14/1999 21:22'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	isAbsolute ifTrue:[ s nextPut: $/ ].	"the extra one"	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment encodeForHTTP ].	^s contents! !!FileUrl methodsFor: 'access' stamp: 'ls 8/2/1998 05:39'!isAbsolute	^isAbsolute! !!FileUrl methodsFor: 'access' stamp: 'ls 7/23/1998 07:29'!path	"return an ordered collection of the path elements"	^path! !!FileUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:57'!path: anArray	path _ anArray! !!FileUrl methodsFor: 'access' stamp: 'tk 11/24/1998 14:59'!pathDirString	"Path to directory as url, using slash as delimiter"	^ String streamContents: [ :s |		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: $/			 ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 11/23/1998 17:17'!pathForDirectory	"Path using local file system's delimiter.  $\ or $:"	^ String streamContents: [ :s |		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: FileDirectory default pathNameDelimiter			 ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 00:35'!pathForFile	"Path using local file system's delimiter.  $\ or $:"	| first |	^String streamContents: [ :s |		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: p ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 13:03'!pathString	"Path as it appears in a URL with $/ as delimiter"	| first |	^String streamContents: [ :s |		isAbsolute ifTrue:[ s nextPut: $/ ].		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first _ false.			s nextPutAll: p encodeForHTTP ] ]! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/6/1998 00:36'!default	"Use the default local Squeak file directory"	| local |	local _ FileUrl new path: (FileDirectory default pathParts), #('')		isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!FileUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/5/1998 20:42'!retrieveContents	| file pathString s dir |		pathString _ self pathForFile.	path last size > 0 ifTrue: [		file _ FileStream oldFileOrNoneNamed: pathString.		file ifNotNil: [ 			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: file contentsOfEntireFile ] ].	"assume it's a directory..."	s _ WriteStream on: String new.	dir _ FileDirectory on: pathString.	(pathString endsWith: '/') ifFalse: [ pathString _ pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	dir entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file:', pathString)! !!FileUrl methodsFor: 'private-initialization' stamp: 'ls 7/26/1998 20:43'!path: aCollection isAbsolute: aBoolean	path _ aCollection.	isAbsolute _ aBoolean! !!FileUrl methodsFor: 'classification' stamp: 'ls 7/26/1998 21:11'!schemeName	^'file'! !!FileUrl class methodsFor: 'parsing' stamp: 'tk 9/6/1998 22:48'!absoluteFromText: text	"(how does this method fit with FileUrl|privateInitializeFromText:?)"	| schemeName pathString bare thePath |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	thePath _ (pathString findTokens: '/') collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ thePath add: '' ].	^self new path: thePath isAbsolute: (pathString beginsWith: '/')! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:01'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: queryString"	^ self request: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView savedArea |	World ifNotNil:		[^ FillInTheBlankMorph			request: queryString			initialAnswer: defaultAnswer			centerAt: aPoint].	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		(Smalltalk at: #FillInTheBlankView)			on: model			message: queryString			centerAt: aPoint.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'di 9/12/1998 09:26'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane retractableOrNot.	textPane acceptOnCR: true.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 12/21/1998 13:21'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels.	This variant is only for calling from within a Morphic project."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	 ^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: World! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 12/21/1998 13:20'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| m |	m _ self new		setQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50.	aWorld addMorph: m centeredNear: aPoint.	^ m getUserResponse! !!FillStyle methodsFor: 'accessing' stamp: 'ar 1/14/1999 15:23'!scaledPixelValue32	"Return a pixel value of depth 32 for the primary color in the fill style"	^self asColor scaledPixelValue32! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isBitmapFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isGradientFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isSolidFill	^false! !!FillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:53'!asColor	^self subclassResponsibility! !!FlashBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 21:54'!remapFills	"Replace the fill style dictionary with an array"	| indexMap newFillStyles index |	(fillStyles isKindOf: Dictionary) ifFalse:[^false].	indexMap _ Dictionary new.	indexMap at: 0 put: 0. "Map zero to zero"	newFillStyles _ Array new: fillStyles size.	index _ 1.	fillStyles associationsDo:[:assoc|		indexMap at: assoc key put: index.		newFillStyles at: index put: assoc value.		index _ index + 1.	].	leftFills _ leftFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	rightFills _ rightFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	lineFills _ lineFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	fillStyles _ newFillStyles! !!FlashBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 02:30'!complexity	^points size // 3! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04'!defaultLook: aMorph	"Assign the default look"	aMorph setProperty: #defaultLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:26'!loadInitialFrame	"Resort our children"	super loadInitialFrame.	submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth].	self lookEnable: #(defaultLook) disable:#(sensitive overLook pressLook)! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25'!overLook: aMorph	"Assign the look if the mouse if over"	aMorph setProperty: #overLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25'!pressLook: aMorph	"Assign the look if the mouse is pressed"	aMorph setProperty: #pressLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04'!sensitiveLook: aMorph	"Assign the look for the sensitive area."	aMorph setProperty: #sensitive toValue: true.	self addMorph: aMorph! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 21:16'!addSound: aSound forState: state	sounds ifNil:[sounds _ Dictionary new].	sounds at: state put: aSound.! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:02'!ownerSprite	"Return the sprite owning the receiver.	The owning sprite is responsible for executing	the actions associated with the button."	| sprite |	sprite _ self.	[sprite isNil] whileFalse:[		(sprite isFlashMorph and:[sprite isFlashSprite]) ifTrue:[^sprite].		sprite _ sprite owner].	^nil! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:03'!trackAsMenu: aBoolean	"Currently unused"	aBoolean 		ifTrue:[self setProperty: #trackAsMenu toValue: true]		ifFalse:[self removeProperty: #trackAsMenu].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 15:32'!executeActions: type	| rcvr |	(events isNil or:[events isEmpty]) ifTrue:[^self].	rcvr _ self ownerSprite.	Sensor leftShiftDown ifTrue:[self inspect].	rcvr isNil ifTrue:[^self].	(events at: type ifAbsent:[^self]) do:[:action|		action sentTo: rcvr.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:32'!executeSounds: type	| sound |	(sounds isNil or:[sounds isEmpty]) ifTrue:[^self].	sound _ sounds at: type ifAbsent:[^self].	sound isPlaying ifFalse:[sound play].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:25'!handlesMouseDown: evt	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/19/1998 20:32'!handlesMouseOver: evt	"Handle mouse events only if I am visible,"	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:24'!handlesMouseOverDragging: evt	^false! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseDown: evt	self lookEnable: #(pressLook) disable:#().	self executeSounds: #mouseDown.	self executeActions: #mouseDown.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseEnter: evt	self lookEnable: #(overLook) disable:#(pressLook defaultLook).	evt hand needsToBeDrawn ifFalse:[Cursor webLink show].	self executeSounds: #mouseEnter.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseEnterDown]		ifFalse:[self executeActions: #mouseEnter].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseLeave: evt	self lookEnable: #(defaultLook) disable:#(pressLook overLook).	evt hand needsToBeDrawn ifFalse:[Cursor normal show].	self executeSounds: #mouseLeave.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseLeaveDown]		ifFalse:[self executeActions: #mouseLeave].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:08'!mouseMove: evt! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseUp: evt	self lookEnable:#(defaultLook overLook) disable:#(pressLook).	self executeSounds: #mouseUp.	self executeActions: #mouseUp.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 02:09'!on: eventName sendAll: actions	"Note: We handle more than the standard Morphic events here"	| actionList |	events ifNil:[events _ Dictionary new].	self analyzeActionsForBalloonHelp: actions.	actionList _ events at: eventName ifAbsent:[#()].	actionList _ actionList, actions.	events at: eventName put: actionList.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/24/1998 15:14'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^true! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:46'!containsPoint: aPoint	| localPt |	(self bounds containsPoint: aPoint) ifFalse:[^false].	localPt _ self transform globalPointToLocal: aPoint.	submorphs do:[:m| 		((m valueOfProperty: #sensitive) ifNil:[false]) ifTrue:[			(m bounds containsPoint: localPt) ifTrue:[^true].		].	].	^false! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:09'!lookEnable: list1 disable: list2	self changed.	submorphs do:[:m|		list2 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: false].		].		list1 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: true].		].	].	self computeBounds.	self changed.! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^true! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^true! !!FlashButtonMorph methodsFor: 'balloon help' stamp: 'ar 11/20/1998 15:15'!analyzeActionsForBalloonHelp: actionList	| helpText |	actionList do:[:msg|		helpText _ ActionHelpText at: msg selector ifAbsent:[nil].		helpText ifNotNil:[self setBalloonText: helpText].	].! !!FlashButtonMorph methodsFor: 'printing' stamp: 'ar 11/21/1998 01:36'!printOn: aStream	super printOn: aStream.	events ifNil:[^self].	aStream nextPut:$[.	events keys do:[:k| aStream print: k; space].	aStream nextPut: $].! !!FlashButtonMorph class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:58'!initialize	"FlashButtonMorph initialize"	ActionHelpText _ Dictionary new.	#(	(getURL:window: 'Jump to URL')		(gotoFrame: 'Continue playing')		(gotoLabel: 'Continue playing')		(gotoNextFrame 'Continue playing')		(gotoPrevFrame 'Continue playing')		(actionPlay 'Continue playing')		(actionStop 'Stop playing')		(stopSounds 'Stop all sounds')		(toggleQuality 'Toggle display quality')	) do:[:spec| ActionHelpText at: spec first put: spec last].! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 15:45'!initialize	super initialize.	vData _ FlashKeyframes new.	mData _ FlashKeyframes new.	dData _ FlashKeyframes new.	cmData _ FlashKeyframes new.	frame _ 1.	self matrix: MatrixTransform2x3 identity atFrame: 0.	self visible: false atFrame: 0.	self depth: 0 atFrame: 0.	self visible: true.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 19:25'!loadInitialFrame	"Force the transformations taking place in the first frame."	super loadInitialFrame.	self stepToFrame: 1.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:41'!reset	self removeAllKeyFrameData.! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/13/1998 13:40'!activationKeys	"Return the keyframes on which the receiver morph becomes visible"	^self visibleData keys select:[:key| self visibleAtFrame: key]! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 10/3/1998 21:39'!depth	^self depthAtFrame: frame! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id	^id! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id: aNumber	id _ aNumber! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder	^self hasProperty: #spriteHolder! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder: aBoolean	aBoolean		ifTrue:[self setProperty: #spriteHolder toValue: true]		ifFalse:[self removeProperty: #spriteHolder]! !!FlashCharacterMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^true! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:50'!colorTransform: aColorTransform atFrame: frameNumber	self colorTransformData at: frameNumber put: aColorTransform! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformAtFrame: frameNumber	^self colorTransformData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformData	^cmData	"^self keyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depth: aNumber atFrame: frameNumber	self depthData at: frameNumber put: aNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depthAtFrame: frameNumber	^self depthData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!depthData	^dData	"^self keyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:11'!matrix: aMatrixTransform atFrame: frameNumber	"self position: aMatrixTransform offset atFrame: frameNumber."	self matrixData at: frameNumber put: aMatrixTransform.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!matrixAtFrame: frameNumber	^(self matrixData at: frameNumber) "copy offset: (self positionAtFrame: frameNumber)"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!matrixData	^mData	"^self keyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!removeAllKeyFrameData	"Remove all of the keyframe data associated with this morph"	self removeColorMatrixData.	self removeDepthData.	self removeMatrixData.	self removeVisibleData.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeColorMatrixData	cmData _ FlashKeyframes new.	"^self removeKeyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeDepthData	dData _ FlashKeyframes new.	"^self removeKeyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeMatrixData	mData _ FlashKeyframes new.	"^self removeKeyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeVisibleData	vData _ FlashKeyframes new.	"^self removeKeyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:13'!visible: aBool atFrame: frameNumber	^self visibleData at: frameNumber put: aBool! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:23'!visibleAtFrame: frameNumber	^self visibleData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!visibleData	^vData	"^self keyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:17'!stepTime	^stepTime ifNil:[super stepTime]! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:18'!stepTime: aNumber	stepTime _ aNumber! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/24/1998 14:52'!stepToFrame: frameNumber	| m wasVisible isVisible noTransform cm |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		cm _ self colorTransformAtFrame: frame.		noTransform _ (m = transform) and:[colorTransform = cm].		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		self colorTransform: cm.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].	(isVisible ~~ wasVisible and:[self isSpriteHolder])		ifTrue:[self activateSprites: isVisible].! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:03'!stepToNextFrame	self stepToFrame: frame + 1.! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/13/1998 14:02'!wantsSteps	^false	"^stepTime notNil"! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 11/24/1998 14:34'!activateSprites: aBool	submorphs do:[:m|		(m isFlashMorph and:[m isFlashSprite]) ifTrue:[			aBool 				ifTrue:[m startPlaying]				ifFalse:[m stopPlaying].		].	].! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 8/14/1998 20:03'!keyframeData: aSymbol	| data |	data _ self valueOfProperty: aSymbol.	data isNil ifFalse:[^data].	data _ FlashKeyframes new.	self setProperty: aSymbol toValue: data.	^data! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 9/20/1998 23:41'!removeKeyframeData: aSymbol	self removeProperty: aSymbol.! !!FlashCharacterMorph methodsFor: 'printing' stamp: 'ar 11/15/1998 15:44'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:'(renderTime = '; print: renderTime;		"nextPutAll:' complexity = '; print: self complexity * bounds area // 1000 / 1000.0;"		"nextPutAll:' size = '; print: bounds area;"	 nextPutAll:')'.! !!FlashCharacterMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 17:52'!fullDrawOn: canvas	renderTime _ Time millisecondsToRun:[super fullDrawOn: canvas].! !!FlashColorTransform methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:01'!initialize	rMul _ bMul _ gMul _ aMul _ 1.0.	rAdd _ bAdd _ gAdd _ aAdd _ 0.0.! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd	^aAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd: aFixed	aAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!aMul	^aMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aMul: aFixed	aMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd	^bAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd: aFixed	bAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!bMul	^bMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bMul: aFixed	bMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd	^gAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd: aFixed	gAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!gMul	^gMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gMul: aFixed	gMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd	^rAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd: aFixed	rAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!rMul	^rMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rMul: aFixed	rMul _ aFixed! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:39'!= aCT	self class == aCT class ifFalse:[^false].	^rAdd = aCT rAdd and:[rMul = aCT rMul and:[		gAdd = aCT gAdd and:[gMul = aCT gMul and:[			bAdd = aCT bAdd and:[bMul = aCT bMul and:[				aAdd = aCT aAdd and:[aMul = aCT aMul]]]]]]]! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:40'!hash	^rAdd hash + gMul hash + bAdd hash + aMul hash! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 14:54'!composedWithGlobal: aColorTransform	^aColorTransform composedWithLocal: self.! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/25/1998 21:34'!composedWithLocal: aColorTransform	| cm |	cm _ self clone.	cm rAdd: self rAdd + (aColorTransform rAdd * self rMul).	cm rMul: self rMul * aColorTransform rMul.	cm gAdd: self gAdd + (aColorTransform gAdd * self gMul).	cm gMul: self gMul * aColorTransform gMul.	cm bAdd: self bAdd + (aColorTransform bAdd * self bMul).	cm bMul: self bMul * aColorTransform bMul.	cm aAdd: self aAdd + (aColorTransform aAdd * self aMul).	cm aMul: self aMul * aColorTransform aMul.	^cm! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 15:06'!localColorToGlobal: aColor	^Color		r: (aColor red * self rMul + self rAdd)		g: (aColor green * self gMul + self gAdd)		b: (aColor blue * self bMul + self bAdd)		alpha: (aColor alpha * self aMul + self aAdd)! !!FlashColorTransform methodsFor: 'printing' stamp: 'ar 11/24/1998 14:40'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		cr; nextPutAll:' r * '; print: rMul; nextPutAll:' + '; print: rAdd;		cr; nextPutAll:' g * '; print: gMul; nextPutAll:' + '; print: gAdd;		cr; nextPutAll:' b * '; print: bMul; nextPutAll:' + '; print: bAdd;		cr; nextPutAll:' a * '; print: aMul; nextPutAll:' + '; print: aAdd;		nextPut:$).! !!FlashColorTransform class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 23:42'!new	^super new initialize! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/17/1998 18:41'!fullDamageRect	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:54'!fullDamageRect: maxBounds	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect intersect: maxBounds! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:43'!recordInvalidRect: rect	totalRepaint ifTrue:[^self].	self updateIsNeeded ifTrue:[		fullDamageRect _ fullDamageRect merge: rect.	] ifFalse:[		fullDamageRect _ rect copy.	].	^super recordInvalidRect: rect! !!FlashFileReader methodsFor: 'initialize' stamp: 'ar 7/4/1998 20:14'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.	log _ Transcript.	log _ nil.! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 11/18/1998 21:25'!isStreaming	"Subclasses may override this"	^false! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:41'!processFile	"Read and process the entire file"	self processHeader ifFalse:[^nil].	self processFileContents.! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/19/1998 00:29'!processFileContents	"Process the contents of the flash file.	Assume that the header has been read before."	| time |	time _ Time millisecondsToRun:[	self isStreaming ifTrue:[		"Don't show progress for a streaming connection.		Note: Yielding is done someplace else."		[self processTagFrom: stream] whileTrue.	] ifFalse:[		'Reading file' displayProgressAt: Sensor cursorPoint			from: 1 to: 100			during:[:theBar|		[self processTagFrom: stream] whileTrue:[			theBar value: (stream position * 100 // stream size).			stream atEnd ifTrue:[				log ifNotNil:[					log cr; nextPutAll:'Unexpected end of data (no end tag)'.					self flushLog].				^self]].		].	].	(stream respondsTo: #close) ifTrue:[stream close].	].	Transcript cr; print: time / 1000.0; show:' secs to read file'! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 21:59'!processHeader	"Read header information from the source stream.	Return true if successful, false otherwise."	| version twipsFrameSize frameRate frameCount |	self processSignature ifFalse:[^false].	version _ stream nextByte.	"Check for the version supported"	version > self maximumSupportedVersion ifTrue:[^false].	dataSize _ stream nextLong.	"Check for the minimal file size"	dataSize < 21 ifTrue:[^false].	twipsFrameSize _ stream nextRect.	self recordGlobalBounds: twipsFrameSize.	frameRate _ stream nextWord / 256.0.	self recordFrameRate: frameRate.	frameCount _ stream nextWord.	self recordFrameCount: frameCount.	log ifNotNil:[		log cr; nextPutAll:'------------- Header information --------------'.		log cr; nextPutAll:'File version		'; print: version.		log cr; nextPutAll:'File size			'; print: dataSize.		log cr; nextPutAll:'Movie width		'; print: twipsFrameSize extent x // 20.		log cr; nextPutAll:'Movie height	'; print: twipsFrameSize extent y // 20.		log cr; nextPutAll:'Frame rate		'; print: frameRate.		log cr; nextPutAll:'Frame count	'; print: frameCount.		log cr; cr.		self flushLog].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 7/4/1998 20:08'!processSignature	"Check the signature of the SWF file"	stream nextByte asCharacter = $F ifFalse:[^false].	stream nextByte asCharacter = $W ifFalse:[^false].	stream nextByte asCharacter = $S ifFalse:[^false].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/12/1998 23:57'!processTagFrom: aStream	"Read and process the next tag from the input stream."	| tag data result |	tag _ aStream nextTag.	log ifNotNil:[		log cr; nextPutAll:'Tag #'; print: tag key.		log nextPutAll:' ('; nextPutAll: (TagTable at: tag key + 1); space; print: tag value size;			nextPutAll:' bytes)'.		self flushLog].	data _ FlashFileStream on: (ReadStream on: tag value).	result _ self dispatch: data on: tag key+1 in: TagTable ifNone:[self processUnknown: data].	(log isNil or:[data atEnd]) ifFalse:[		log 			nextPutAll:'*** ';			print: (data size - data position);			nextPutAll:' bytes skipped ***'.		self flushLog].	^result! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/13/1998 17:53'!processCurveRecordFrom: data	| nBits cx cy ax ay |	log ifNotNil:[log crtab; nextPutAll:'C: '].	nBits _ (data nextBits: 4) + 2. "Offset by 2"	"Read control point change"	cx _ data nextSignedBits: nBits.	cy _ data nextSignedBits: nBits.	log ifNotNil:[log print: cx@cy].	"Read anchor point change"	ax _ data nextSignedBits: nBits.	ay _ data nextSignedBits: nBits.	log ifNotNil:[log nextPutAll:' -- '; print: ax@ay.				self flushLog].	self recordCurveSegmentTo: ax@ay with: cx@cy! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/13/1998 20:31'!processFillStylesFrom: data	| nFills matrix nColors rampIndex rampColor id color fillStyleType ramp |	nFills _ data nextByte.	nFills = 255 ifTrue:[nFills _ data nextWord].	log ifNotNil:[log crtab; print: nFills; nextPutAll:' New fill styles'].	1 to: nFills do:[:i|		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab].		fillStyleType _ data nextByte.		(fillStyleType = 0) ifTrue:["Solid fill"			color _ data nextColor.			self recordSolidFill: i color: color.			log ifNotNil:[log nextPutAll:'solid color '; print: color].		].		(fillStyleType anyMask: 16) ifTrue:["Gradient fill"			"Read gradient matrix"			matrix _ data nextMatrix.			"Read color ramp data"			nColors _ data nextByte.			ramp _ Array new: nColors.			log ifNotNil:[log nextPutAll:'Gradient fill with '; print: nColors; nextPutAll:' colors'].			1 to: nColors do:[:j|				rampIndex _ data nextByte.				rampColor _ data nextColor.				ramp at: j put: (rampIndex -> rampColor)].			self recordGradientFill: i matrix: matrix ramp: ramp linear: (fillStyleType = 16)].		(fillStyleType anyMask: 16r40) ifTrue:["Bit fill"			"Read bitmap id"			id _ data nextWord.			"Read bitmap matrix"			matrix _ data nextMatrix.			log ifNotNil:[log nextPutAll:'Bitmap fill id='; print: id].			self recordBitmapFill: i matrix: matrix id: id clipped: (fillStyleType anyMask: 1)].		self flushLog.	].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/12/1998 23:35'!processFontShapeFrom: data	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/9/1998 20:43'!processLineRecordFrom: data	| nBits x y |	nBits _ (data nextBits: 4) + 2. "Offset by 2"	data nextBitFlag ifTrue:[		"General line"		x _ data nextSignedBits: nBits.		y _ data nextSignedBits: nBits.		self recordLineSegmentBy: x@y.	] ifFalse:[		data nextBitFlag 			ifTrue:[	"vertical line"					y _ data nextSignedBits: nBits. 					self recordLineSegmentVerticalBy: y]			ifFalse:[	"horizontal line"					x _ data nextSignedBits: nBits.					self recordLineSegmentHorizontalBy: x].	].	log ifNotNil:[log crtab; nextPutAll:'E: ';print: x; nextPut:$@; print: y.				self flushLog].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:04'!processLineStylesFrom: data	| nStyles styles lineWidth lineColor |	nStyles _ data nextByte.	nStyles = 255 ifTrue:[nStyles _ data nextWord].	log ifNotNil:[log crtab; print: nStyles; nextPutAll:' New line styles'].	styles _ Array new: nStyles.	1 to: nStyles do:[:i|		lineWidth _ data nextWord.		lineColor _ data nextColor.		self recordLineStyle: i width: lineWidth color: lineColor.		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab; 						print: lineWidth; tab; print: lineColor]].	self flushLog.	^styles! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/17/1998 00:35'!processShapeRecordFrom: data	| flags pt lineInfo fillInfo0 fillInfo1 |	data nextBitFlag ifTrue:["Boundary edge record"		data nextBitFlag			ifTrue:[self processLineRecordFrom: data]			ifFalse:[self processCurveRecordFrom: data].		^true].	flags _ data nextBits: 5.	flags = 0 ifTrue:[^false]. "At end of shape"	(flags anyMask: 1) ifTrue:["move to"		pt _ data nextPoint.		self recordMoveTo: pt.		log ifNotNil:[log crtab; nextPutAll:'MoveTo '; print: pt]].	(flags anyMask: 2) ifTrue:["fill info 0"		fillInfo0 _ data nextBits: nFillBits.		self recordFillStyle0: fillInfo0.		log ifNotNil:[log crtab; nextPutAll:'FillInfo0 '; print: fillInfo0]].	(flags anyMask: 4) ifTrue:["fill info 1"		fillInfo1 _ data nextBits: nFillBits.		self recordFillStyle1: fillInfo1.		log ifNotNil:[log crtab; nextPutAll:'FillInfo1 '; print: fillInfo1]].	(flags anyMask: 8) ifTrue:["line info"		lineInfo _ data nextBits: nLineBits.		self recordLineStyle: lineInfo.		log ifNotNil:[log crtab; nextPutAll:'LineInfo '; print: lineInfo]].	(flags anyMask: 16) ifTrue:["new styles"		self recordEndSubshape.		log ifNotNil:[log crtab; nextPutAll:'New Set of styles '].		self processShapeStylesFrom: data.		"And reset info"		data initBits.		nFillBits _ data nextBits: 4.		nLineBits _ data nextBits: 4].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:05'!processShapeStylesFrom: data	self processFillStylesFrom: data.	self processLineStylesFrom: data.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 1/4/1999 08:44'!processShapesFrom: data	"Process a new shape"	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.	self recordShapeProperty: id length: data size.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/14/1998 23:17'!processGlyphEntries: nGlyphs from: data	| index advance |	data initBits.	1 to: nGlyphs do:[:i|		index _ data nextBits: nGlyphBits.		advance _ data nextSignedBits: nAdvanceBits.		self recordNextChar: index+1 advanceWidth: advance.		log ifNotNil:[			log nextPut:$(;print: index; space; print: advance; nextPut:$).			self flushLog].	].! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 11/20/1998 02:47'!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self flag: #wrongSpec.	"From news://forums.macromedia.com/macromedia.open-swfIt is an error in the spec. There can be up to 255 characters in run. Thehigh bit does not mean anything. The text record type 0 and type 1 is poorlydescribed. The real format is that all of the info in a 'text record type 1'is always followed by the info in a 'text record type 2'. Note the high bitof 'text record type 1' is reserved and should always be zero."	self processGlyphStateChange: flags from: data.	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self processGlyphEntries: flags from: data.	"Old stuff - which is according to the f**cking spec"	"(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	]."	^true! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/15/1998 19:45'!processGlyphStateChange: flags from: data	| hasFont hasColor hasXOffset hasYOffset fontId color xOffset yOffset height |	hasFont _ flags anyMask: 8.	hasColor _ flags anyMask: 4.	hasYOffset _ flags anyMask: 2.	hasXOffset _ flags anyMask: 1.	hasFont ifTrue:[fontId _ data nextWord].	hasColor ifTrue:[color _ data nextColor].	hasXOffset ifTrue:[xOffset _ data nextWord].	hasYOffset ifTrue:[yOffset _ data nextWord].	hasFont ifTrue:[height _ data nextWord].	log ifNotNil:[		log nextPutAll:'['.		hasFont ifTrue:[log nextPutAll:' font='; print: fontId].		hasColor ifTrue:[log nextPutAll:' color='; print: color].		hasXOffset ifTrue:[log nextPutAll:' xOfs=';print: xOffset].		hasYOffset ifTrue:[log nextPutAll:' yOfs=';print: yOffset].		hasFont ifTrue:[log nextPutAll:' height='; print: height].		log nextPutAll:' ]'.		self flushLog.	].	self recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 10/15/1998 03:23'!processGlyphsFrom: data	| id bounds matrix |	id _ data nextWord.	bounds _ data nextRect.	matrix _ data nextMatrix.	self recordTextStart: id bounds: bounds matrix: matrix.	nGlyphBits _ data nextByte.	nAdvanceBits _ data nextByte.	log ifNotNil:[		log	nextPutAll:'(nGlyphBits = '; 			print: nGlyphBits; 			nextPutAll:' nAdvanceBits = '; 			print: nAdvanceBits;			nextPutAll:') '.		self flushLog].	[self processGlyphRecordFrom: data] whileTrue.	self recordTextEnd: id.! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 11/24/1998 14:22'!processButtonRecords: id from: data cxForm: haveCxForm	| flags state characterId layer matrix cxForm |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		haveCxForm ifTrue:[cxForm _ data nextColorMatrix].		self recordButton: id 			character: characterId 			state: state 			layer: layer 			matrix: matrix			colorTransform: cxForm].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:32'!processActionGetURL: data	| length position urlString winString |	length _ data nextWord.	position _ data position.	urlString _ data nextString.	winString _ data nextString.	data position = (position + length) ifFalse:[		self halt.		data position: position.		^self processUnknownAction: data].	log ifNotNil:[		log 			nextPutAll:' url='; print: urlString;			nextPutAll:', win='; print: winString].	^Message selector: #getURL:window: arguments: (Array with: urlString with: winString)! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGotoFrame: data	| length frame |	length _ data nextWord.	length = 2 ifFalse:["There is something wrong here"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	log ifNotNil:[log nextPutAll:' frame = '; print: frame.].	^Message selector: #gotoFrame: argument: frame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:31'!processActionGotoLabel: data	| length label |	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionNextFrame: data	^Message selector: #gotoNextFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39'!processActionPlay: data	^Message selector: #actionPlay! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionPrevFrame: data	^Message selector: #gotoPrevFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:39'!processActionRecordsFrom: data	| code actionList action |	actionList _ OrderedCollection new.	[code _ data nextByte.	code = 0] whileFalse:[		code _ code bitAnd: 127. "Mask out the length-follow flag"		log ifNotNil:[			log cr; nextPutAll:'	Action #'; print: code.			log nextPutAll:' ('; nextPutAll: (ActionTable at: code); nextPutAll:')'].		action _ self dispatch: data on: code in: ActionTable 					ifNone:[self processUnknownAction: data].		action ifNotNil:[actionList add: action].		log ifNotNil:[self flushLog].	].	^actionList! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/17/1998 13:37'!processActionSetTarget: data	| length target |	length _ data nextWord.	target _ data nextString.	log ifNotNil:[log nextPutAll:' target = '; print: target].	^Message selector: #actionTarget: argument: target.! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39'!processActionStop: data	^Message selector: #actionStop! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionStopSounds: data	^Message selector: #stopSounds! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionToggleQuality: data	^Message selector: #toggleQuality! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionWaitForFrame: data	| length frame skip |	length _ data nextWord.	length = 3 ifFalse:["Something is wrong"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	skip _ data nextByte.	log ifNotNil:[		log nextPutAll:'frame = '; print: frame;			nextPutAll:', skip = '; print: skip].	^Message selector: #isFrameLoaded:elseSkip: arguments: (Array with: frame with: skip).! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:37'!processUnknownAction: data	| code length |	data skip: -1. "For determining the length of the action"	code _ data nextByte.	(code anyMask: 128) ifTrue:["Two byte length following"		length _ data nextWord.		data skip: length].	log ifNotNil:[log nextPutAll:'*** skipped ***'].	^nil! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:46'!createSoundBuffersOfSize: numSamples stereo: stereo	| channels buffers |	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	^buffers! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:55'!createSoundFrom: soundStreams stereo: stereo samplingRate: samplingRate	| sound channels buffers |	buffers _ soundStreams collect:[:s| s contents].	channels _ stereo ifTrue:[2] ifFalse:[1].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) samplingRate: samplingRate.		sound setLoudness: 1.0.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:47'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| buffers |	buffers _ self createSoundBuffersOfSize: numSamples stereo: stereo.	self decompressSound: aByteArray 		stereo: stereo 		samples: numSamples 		rate: samplingRate 		into: buffers.	^self createSoundFrom: buffers stereo: stereo samplingRate: samplingRate! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/29/1998 14:53'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate into: buffers	| data nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				vpdiff _ vpdiff + step.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 15:37'!processEnvelopeFrom: data	| env |	env _ FlashSoundEnvelope new.	env mark44: data nextULong.	env level0: data nextWord.	env level1: data nextWord.	^env! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 16:11'!processSoundInfoFrom: data	| flags info nPoints |	flags _ data nextByte.	info _ FlashSoundInformation new.	info syncFlags: (flags bitShift: -4).	(flags anyMask: 1) ifTrue:[info inPoint: data nextULong].	(flags anyMask: 2) ifTrue:[info outPoint: data nextULong].	(flags anyMask: 4) ifTrue:[info loopCount: data nextWord].	(flags anyMask: 8) ifTrue:[		nPoints _ data nextByte.		info envelopes: ((1 to: nPoints) collect:[:i| self processEnvelopeFrom: data]).	].	^info! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/20/1998 22:37'!processSoundStreamHeadFrom: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	self flag: #wrongSpec.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 16:31'!processDefineBits: data	| id image |	id _ data nextWord.	image _ jpegDecoder decodeNextImageFrom: data.	"image display."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32'!processDefineBitsJPEG2: data	| id image decoder |	id _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:11'!processDefineBitsJPEG3: data	"TODO: Read zlib compressed alpha."	| id image decoder alphaOffset dataOffset |	id _ data nextWord.	self flag: #wrongSpec.	alphaOffset _ data nextWord.	dataOffset _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	"Note: We must read the zlib compressed alpha values here."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12'!processDefineBitsLossless2: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12'!processDefineBitsLossless: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:41'!processDefineButton2: data	| id flags actions condition actionOffset |	data hasAlpha: true.	id _ data nextWord.	self recordDefineButton: id.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	self flag: #wrongSpec.	actionOffset _ data nextWord.	self processButtonRecords: id from: data cxForm: true.	[actionOffset = 0] whileFalse:[		actionOffset _ data nextWord.		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 20:47'!processDefineButton: data	| id actions |	id _ data nextWord.	self recordDefineButton: id.	self processButtonRecords: id from: data cxForm: false.	actions _ self processActionRecordsFrom: data.	self recordButton: id actions: actions.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processDefineButtonCxform: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/21/1998 13:56'!processDefineButtonSound: data	| id soundID soundInfo |	id _ data nextWord.	#(0 mouseEnter mouseDown 3) do:[:state|		soundID _ data nextWord.		soundID = 0 ifFalse:[			soundInfo _ self processSoundInfoFrom: data.			self recordButton: id sound: soundID info: soundInfo state: state]].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31'!processDefineFont2: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 03:18'!processDefineFont: data	| fontId firstOffset offsets nShapes |	fontId _ data nextWord.	firstOffset _ data nextWord.	nShapes _ firstOffset // 2.	offsets _ Array new: nShapes.	offsets at: 1 put: firstOffset.	2 to: nShapes do:[:i| offsets at: i put: data nextWord].	self recordFontBegin: fontId with: nShapes.	1 to: nShapes do:[:i|		log ifNotNil:[log cr; nextPutAll:'Glyph '; print: i].		self recordFontShapeStart: fontId with: i.		self processFontShapeFrom: data.		self recordFontShapeEnd: fontId with: i].	data atEnd ifFalse:[self halt].	self recordFontEnd: fontId.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:34'!processDefineFontInfo: data	| id nameLength fontName flags charMap |	id _ data nextWord.	nameLength _ data nextByte.	fontName _ (data nextBytes: nameLength) asString.	flags _ data nextByte.	charMap _ data upToEnd.	self recordFont: id name: fontName charMap: charMap wide: (flags anyMask: 1).	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 19:46'!processDefineMorphShape: data	"self halt."	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:52'!processDefineShape2: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:48'!processDefineShape3: data	data hasAlpha: true.	self processShapesFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:22'!processDefineShape: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:29'!processDefineSound: data	| flags sampleCount sampleData id stereo bitsPerSample rate compressed sound |	id _ data nextWord.	flags _ data nextByte.	stereo _ (flags anyMask: 1).	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	rate _ #( 5512 11025 22050 44100 ) at: (flags >> 2 bitAnd: 3)+1.	compressed _ flags anyMask: 16.	sampleCount _ data nextULong.	sampleData _ data upToEnd.	compressed ifTrue:[		self isStreaming ifFalse:[Cursor wait show].		sound _ self decompressSound: sampleData 						stereo: stereo 						samples: sampleCount 						rate: rate.		self isStreaming ifFalse:[Cursor normal show].	] ifFalse:[		self halt.		sound _ nil.	].	self recordSound: id data: sound.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:42'!processDefineSprite: data	| id frameCount |	id _ data nextWord.	self flag: #wrongSpec.	frameCount _ data nextWord.	self recordBeginSprite: id frames: frameCount.	[self processTagFrom: data] whileTrue.	self recordEndSprite: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:47'!processDefineText2: data	data hasAlpha: true.	self processGlyphsFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 23:23'!processDefineText: data	self processGlyphsFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 22:57'!processDoAction: data	| actions |	actions _ self processActionRecordsFrom: data.	self recordFrameActions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:30'!processEnd: data	"At end of data"	^false! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 13:35'!processFrameLabel: data	| label |	label _ data nextString.	self recordFrameLabel: label.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31'!processFreeCharacter: data	| id |	id _ data nextWord.	data atEnd ifFalse:[self halt].	self recordFreeCharacter: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32'!processJPEGTables: data	jpegDecoder _ FlashJPEGDecoder new.	jpegDecoder isStreaming: self isStreaming.	jpegDecoder decodeJPEGTables: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processNameCharacter: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	self flag: #checkThis.	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:46'!processPlaceObject: data	| id depth matrix colorMatrix |	id _ data nextWord.	depth _ data nextWord.	matrix _ data nextMatrix.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	data atEnd ifFalse:[colorMatrix _ data nextColorMatrix].	self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: colorMatrix.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:32'!processProtect: data	self recordProtection.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43'!processRemoveObject2: data	| depth |	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: nil depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/13/1998 00:19'!processRemoveObject: data	| id depth |	id _ data nextWord.	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: id depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:33'!processSetBackgroundColor: data	| color |	color _ data nextColor.	self recordBackgroundColor: color.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processShowFrame: data	"Show the current frame"	self recordShowFrame.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:37'!processSoundStreamBlock: data	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:21'!processSoundStreamHead2: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:22'!processSoundStreamHead: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 02:47'!processStartSound: data	| id info |	id _ data nextWord.	info _ self processSoundInfoFrom: data.	self recordStartSound: id info: info.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processUnknown: data	"An unknown tag has been encountered"	^true! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/20/1998 22:11'!dispatch: argument on: aKey in: aTable ifNone: exceptionBlock	| selector |	(aKey < 1 or:[aKey > aTable size]) ifTrue:[^exceptionBlock value].	selector _ aTable at: aKey.	^self perform: selector with: argument! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/5/1998 23:42'!flushLog	(log == Transcript) ifTrue:[		log endEntry.		Sensor leftShiftDown ifTrue:[self halt].	].! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/2/1998 20:37'!maximumSupportedVersion	^3! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/12/1998 23:41'!warn: aString	Transcript cr; show: aString.! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:46'!recordCurveSegmentTo: anchorPoint with: controlPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle0: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle1: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 20:56'!recordLineSegmentBy: deltaPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentHorizontalBy: deltaX	^self recordLineSegmentBy: (deltaX@0)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentVerticalBy: deltaY	^self recordLineSegmentBy: (0@deltaY)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:48'!recordLineStyle: styleIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:47'!recordMoveTo: aPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeEnd: shapeId! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 1/4/1999 08:44'!recordShapeProperty: id length: length! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeStart: shapeId bounds: shapeBounds! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 22:35'!recordFont: id name: fontName charMap: charMap wide: isWide	"Record the name and character mapping of the font for the given id.	If isWide is set then the font is a 16bit Unicode font."! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontBegin: fontId with: nGlyphs! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontEnd: fontId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeEnd: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeStart: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:09'!recordNextChar: glyphIndex advanceWidth: advance! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextEnd: id! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextStart: id bounds: bounds matrix: matrix! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 11/13/1998 20:31'!recordBitmapFill: fillIndex matrix: bmMatrix id: bitmapID clipped: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:52'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:55'!recordLineStyle: styleIndex width: lineWidth color: lineColor! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:48'!recordSolidFill: index color: fillColor! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:22'!recordButton: buttonId actions: actionList	"Associate an action list with the given button"	^self recordButton: buttonId actions: actionList condition: 8. "OverDownToOverUp"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:34'!recordButton: buttonId actions: actionList condition: condition	"Associate an action list with the given button:		buttonId:	global ID of the button		actions:		Collection of MessageSends (e.g., actions)		condition:	bit mask describing when the actions should be applied					General conditions:						1 - IdleToOverUp (Mouse enter up)						2 - OverUpToIdle (Mouse exit up)						4 - OverUpToOverDown (Mouse down)						8 - OverDownToOverUp (Mouse up in)					Push button conditions:						16 - OverDownToOutDown (Mouse exit down)						32 - OutDownToOverDown (Mouse enter down)						64 - OutDownToIdle (Mouse up out)					Menu button conditions:						128 - IdleToOverDown (Mouse enter down)						256 - OverDownToIdle (Mouse exit down)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:23'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	"Define the character to use for a button.		buttonId:	global ID used for the button		characterId:	ID of the character defining the shape for the button		state:		bit mask for when to use the character						1 - default (e.g. no other state applies)						2 - display when the mouse is over the button but not pressed						4 - display when the button is pressed						8 - the area in which the mouse is supposed to be 'over' the button		layer:		UNKNOWN.		matrix:		Transformation to apply to the character. (Guess!!)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 8/10/1998 15:51'!recordButton: id sound: soundId info: soundInfo state: state! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:06'!recordButton: id trackAsMenu: aBoolean	"Track the button with the given ID as a menu (in contrast to a push) button. Push buttons capture the mouse until the button is released. Menu buttons don't.	Note: If defined for a button, this method will be called prior to any other #recordButton: methods."! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:47'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 10/15/1998 02:36'!recordSound: id data: aSampledSound! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordSoundStreamBlock: compressedData! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:45'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordStartSound: id info: info! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:33'!recordBackgroundColor: aColor! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:54'!recordBeginSprite: id frames: frameCount! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:27'!recordBitmap: bitmapId data: aForm! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:55'!recordEndSprite: id! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 19:41'!recordFrameActions: actionList	"Record the list of actions executed at the next showFrame"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36'!recordFrameLabel: label	"Name the current frame with the given label"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 8/10/1998 18:23'!recordFrameRate: fps! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 20:30'!recordFreeCharacter: id	"Free the character with the given id.	Not documented."! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/10/1998 15:51'!recordGlobalBounds: bounds! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 13:13'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:32'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:32'!recordProtection! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:34'!recordRemoveObject: id depth: depth! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:34'!recordShowFrame! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initialize	"FlashFileReader initialize"	self initializeTagTable.	self initializeActionTable.	self initializeStepTable.	self initializeIndexTables.! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 7/15/1998 18:53'!initializeActionTable	"Create and return a new SWF action table"	"FlashFileReader initializeActionTable"	ActionTable _ Array new: 12.	ActionTable atAllPut: #processUnknownAction:.	#(		(processActionGotoFrame:	1)		(processActionGetURL:		3)		(processActionNextFrame:	4)		(processActionPrevFrame:	5)		(processActionPlay:			6)		(processActionStop:			7)		(processActionToggleQuality:	8)		(processActionStopSounds:	9)		(processActionWaitForFrame:	10)		(processActionSetTarget:		11)		(processActionGotoLabel:		12)	) do:[:spec|			ActionTable at: spec last put: spec first.	].! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initializeIndexTables	IndexTables _ Array new: 4.	IndexTables at: 1 put:		#(-1 2).	IndexTables at: 2 put:		#(-1 -1 2 4).	IndexTables at: 3 put:		#(-1 -1 -1 -1 2 4 6 8).	IndexTables at: 4 put:		#(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:15'!initializeStepTable	StepTable _ #(7 8 9 10 11 12 13 14 16 17					19 21 23 25 28 31 34 37 41 45					50 55 60 66 73 80 88 97 107 118					130 143 157 173 190 209 230 253 279 307					337 371 408 449 494 544 598 658 724 796					876 963 1060 1166 1282 1411 1552 1707 1878 2066					2272 2499 2749 3024 3327 3660 4026 4428 4871 5358					5894 6484 7132 7845 8630 9493 10442 11487 12635 13899					15289 16818 18500 20350 22385 24623 27086 29794 32767).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:10'!initializeTagTable	"Create and return a new SWF tag table"	"FlashFileReader initializeTagTable"	TagTable _ Array new: 50.	TagTable atAllPut: #processUnknown:.	#(	(processEnd:					0)	(processShowFrame:			1)	(processDefineShape:		2)	(processFreeCharacter:		3)	(processPlaceObject:			4)	(processRemoveObject:		5)	(processDefineBits:			6)	(processDefineButton:		7)	(processJPEGTables:			8)	(processSetBackgroundColor:	9)	(processDefineFont:			10)	(processDefineText:			11)	(processDoAction:			12)	(processDefineFontInfo:		13)	"Event sound tags."	(processDefineSound:		14)	(processStartSound:			15)	(processDefineButtonSound:	17)	(processSoundStreamHead:	18)	(processSoundStreamBlock:	19)	(processDefineBitsLossless:	20)	"A bitmap using lossless zlib compression."	(processDefineBitsJPEG2:		21)	"A bitmap using an internal JPEG compression table"	(processDefineShape2:		22)	(processDefineButtonCxform:	23)	(processProtect:				24)	"This file should not be importable for editing."	"These are the new tags for Flash 3."	(processPlaceObject2:			26)	"The new style place w/ alpha color transform and name."	(processRemoveObject2:		28)	"A more compact remove object that omits the character tag (just depth)."	(processDefineShape3:		32)	"A shape V3 includes alpha values."	(processDefineText2:			33) "A text V2 includes alpha values."	(processDefineButton2:		34)	"A button V2 includes color transform) alpha and multiple actions"	(processDefineBitsJPEG3:		35)	"A JPEG bitmap with alpha info."	(processDefineBitsLossless2:	36)	"A lossless bitmap with alpha info."	(processDefineSprite:		39) "Define a sequence of tags that describe the behavior of a sprite."	(processNameCharacter:		40) "Name a character definition, character id and a string, (used for buttons) bitmaps, sprites and sounds)."	(processFrameLabel:			43) "A string label for the current frame."	(processSoundStreamHead2:	45) "For lossless streaming sound, should not have needed this..."	(processDefineMorphShape:	46) "A morph shape definition"	(processDefineFont2:			48)	) do:[:spec|			TagTable at: spec last+1 put: spec first.	].! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 19:04'!fileNamed: aString	"FlashFileReader fileNamed:'/home/isg/raab/WDI/flash/samples/top.swf'"	^self on: (FileStream readOnlyFileNamed: aString).! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 19:53'!on: aStream	^self new on: aStream! !!FlashFileReader class methodsFor: 'testing' stamp: 'ar 7/2/1998 20:30'!canRead: aStream	"Return true if instances of the receiver know how to handle the data from aStream."	| ok pos |	pos _ aStream position.	ok _ aStream next asCharacter = $F and:[			aStream next asCharacter  = $W and:[				aStream next asCharacter = $S]].	aStream position: pos.	^ok! !!FlashFileReader class methodsFor: 'accessing' stamp: 'ar 10/16/1998 00:29'!tagTable	^TagTable! !!FlashFileStream methodsFor: 'initialize' stamp: 'ar 7/15/1998 20:10'!on: aSourceStream	stream _ aSourceStream.	bitBuffer _ bitPosition _ 0.	hasAlpha _ false. "Turn on if needed"! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!atEnd	^stream atEnd! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:44'!close	self flushBits.	stream close! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha	^hasAlpha! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha: aBoolean	hasAlpha _ aBoolean! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:23'!next	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/13/1998 00:40'!nextByte	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:24'!nextByteForBits	^stream next ifNil:[0]! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:19'!nextByteForBitsPut: aByte	^stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:27'!nextBytePut: aByte	"Make sure the bit buffer is reset"	self flushBits.	stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:50'!nextBytes: n	"Return a ByteArray containing the next n bytes"	^stream next: n! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:43'!peekFor: anObject	^stream peekFor: anObject! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!position	^stream position! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:56'!position: aNumber	stream position: aNumber.! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!size	^stream size! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:01'!skip: nBytes	self initBits.	stream skip: nBytes! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!stream	^stream! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 8/10/1998 14:18'!upToEnd	^self stream upToEnd.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:38'!initBits	"Initialize the bit buffer for future bit reading operations.	Note: We do not fetch the first byte here so we can do multiple #initBits	without harming the position of the input stream."	bitPosition _ bitBuffer _ 0.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 21:39'!nextBitFlag	^(self nextBits: 1) = 1! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:27'!nextBits: n	"Return the next n bits"	| shift value remaining |	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value _ 0.	remaining _ n.	[true] whileTrue:[		shift _ remaining - bitPosition.		value _ value bitOr: (bitBuffer bitShift: shift).		shift > 0 ifTrue:["Consumes entire buffer"			remaining _ remaining - bitPosition.			"And get next byte"			bitBuffer _ self nextByteForBits.			bitPosition _ 8.		] ifFalse:["Consumes a portion of the buffer"			bitPosition _ bitPosition - remaining.			"Mask off the consumed bits"			bitBuffer _ bitBuffer bitAnd: (255 bitShift: (bitPosition - 8)).			^value]].! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/15/1998 19:44'!nextColor	| r g b baseColor |	r _ self nextByte / 255.0.	g _ self nextByte / 255.0.	b _ self nextByte / 255.0.	baseColor _ Color r: r g: g b: b.	^hasAlpha 		ifTrue:[baseColor alpha: self nextByte / 255.0]		ifFalse:[baseColor]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/24/1998 15:01'!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits) / 256.0.		transform gMul: (self nextSignedBits: nBits) / 256.0.		transform bMul: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits) / 256.0]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits) / 256.0.		transform gAdd: (self nextSignedBits: nBits) / 256.0.		transform bAdd: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits) / 256.0]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 10/16/1998 00:47'!nextLong	| ulong |	ulong _ self nextULong.	^ulong > 16r80000000		ifTrue:[ulong - 16r100000000]		ifFalse:[ulong]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/20/1998 00:29'!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a21: (self nextSignedBits: nBits) / 65536.0.		transform a12: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:42'!nextPoint	"Read a (possibly compressed) point"	| nBits point |	nBits _ self nextBits: 5.	point _ (self nextSignedBits: nBits) @ (self nextSignedBits: nBits).	^point! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:41'!nextRect	"Read a (possibly compressed) rectangle"	| nBits xMin xMax yMin yMax |	self initBits.	nBits _ self nextBits: 5.	xMin _ self nextSignedBits: nBits.	xMax _ self nextSignedBits: nBits.	yMin _ self nextSignedBits: nBits.	yMax _ self nextSignedBits: nBits.	^(xMin@yMin) corner: (xMax@yMax).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 19:11'!nextSignedBits: n	"Return the next n bits as signed integer value"	| value bits signBit |	n = 0 ifTrue:[^0].	value _ self nextBits: n.	"Use a lookup for determining whether or not the value should be sign extended"	bits _ #( 1 2 4 8 16 32 64 128 "1 ... 8"			256 512 1024 2048 4096 8192 16384 32768 "9 ... 16"			65536 131072 262144 524288 1048576 2097152 4194304 8388608 "17 ... 24"			16777216 33554432 67108864 134217728 268435456 536870912 1073741824 2147483648 "25 ... 32"			 4294967296 "33 bit -- for negation only" ).	signBit _ bits at: n.	^(value bitAnd: signBit) = 0		ifTrue:[value]		ifFalse:[value - (bits at: n+1)]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextString	| out byte |	out _ WriteStream on: (String new: 50).	[byte _ self nextByte.	byte = 0] whileFalse:		[out nextPut: (self convertChar2Squeak: byte asCharacter)].	^out contents! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:44'!nextTag	"Read the next tag. Return an association with the key being the tag id and its value the contents of the chunk following."	| word tag length |	word _ self nextWord.	"Extract tag and length from the word"	length _ word bitAnd: 16r3F.	tag _ word bitShift: -6.	"Check if an extra word follows"	length = 16r3F ifTrue:[length _ self nextULong].	^Association key: tag value: (self nextBytes: length).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextULong	^self nextByte + 		(self nextByte bitShift: 8) + 		(self nextByte bitShift: 16) + 		(self nextByte bitShift: 24).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextWord	^self nextByte + (self nextByte bitShift: 8)! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:27'!flushBits	"Flush the bit buffer for future bit writing operations."	bitPosition = 0 ifFalse:[self nextByteForBitsPut: bitBuffer].	bitPosition _ 0.	bitBuffer _ 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:36'!nextBitFlag: aBoolean	^self nextBits: 1 put: (aBoolean ifTrue:[1] ifFalse:[0])! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:41'!nextBits: n put: aNumber	"Write the next n bits"	| value remaining shift |	value _ aNumber. "Do not round - this is a sanity check"	value isInteger ifFalse:[^self error:'Not an integer number'].	value < 0 ifTrue:[^self error:'Not a positive number'].	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value < (1 bitShift: n) ifFalse:[^self error:'Unable to represent number'].	remaining _ n.	[true] whileTrue:[		shift _ 8 - bitPosition - remaining.		bitBuffer _ bitBuffer + (value bitShift: shift).		"Mask out consumed bits"		value _ value bitAnd: (1 bitShift: 0-shift) - 1.		shift < 0 ifTrue:["Buffer overflow"			remaining _ remaining - (8 - bitPosition).			"Store next byte"			self nextByteForBitsPut: bitBuffer.			bitBuffer _ 0.			bitPosition _ 0.		] ifFalse:["Store only portion of the buffer"			bitPosition _ bitPosition + remaining.			^self		].	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:44'!nextColorMatrixPut: cm	"Write a (possibly compressed) color transformation"	self flushBits.	self nextBits: 2 put: 3. "Always write full transform"	self mextBits: 4 put: 15. "Always use full accuracy"	self nextSignedBits: 15 put: cm rMul.	self nextSignedBits: 15 put: cm gMul.	self nextSignedBits: 15 put: cm bMul.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aMul].	self nextSignedBits: 15 put: cm rAdd.	self nextSignedBits: 15 put: cm gAdd.	self nextSignedBits: 15 put: cm bAdd.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aAdd].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:38'!nextColorPut: aColor	self nextBytePut: (aColor red * 255) rounded.	self nextBytePut: (aColor green * 255) rounded.	self nextBytePut: (aColor blue * 255) rounded.	hasAlpha ifTrue:[self nextBytePut: (aColor alpha * 255) rounded].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:46'!nextLongPut: value	value < 0 		ifTrue:[self nextULongPut: 16r100000000 - value]		ifFalse:[self nextULongPut: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 11/2/1998 23:00'!nextMatrixPut: matrix	"write a (possibly compressed) transformation matrix"	self flushBits.	(matrix a11 = 0.0 and:[matrix  a22 = 0.0]) ifFalse:[		"Write a/d"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a11 * 65536.		self nextSignedBits: 31 put: matrix a22 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	((matrix a12) = 0.0 and:[(matrix  a21) = 0.0]) ifFalse:[		"Write b/c"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a12 * 65536.		self nextSignedBits: 31 put: matrix a21 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	"Write tx/ty"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: matrix a13.	self nextSignedBits: 31 put: matrix a23.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:55'!nextPointPut: aPoint	"Write a (possibly compressed) point"	self nextBits: 5 put: 31. "Always write full accuracy"	self nextSignedBits: 31 put: aPoint x.	self nextSignedBits: 31 put: aPoint y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:29'!nextRectPut: aRect	"Write a (possibly compressed) rectangle"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: aRect origin x.	self nextSignedBits: 31 put: aRect corner x.	self nextSignedBits: 31 put: aRect origin y.	self nextSignedBits: 31 put: aRect corner y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:59'!nextSignedBits: n put: someValue	"Write the next n bits as signed integer value"	| value |	value _ someValue rounded. "Do rounding here if not done before"	value < 0		ifTrue:[self nextBits: n put: 16r100000000 - value]		ifFalse:[self nextBits: n put: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:01'!nextStringPut: aString	aString do:[:char| self nextBytePut: (self convertCharFromSqueak: char) asInteger].	self nextBytePut: 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:03'!nextTagPut: tag length: length	"Write the next tag."	length >= 16r3f ifTrue:[		self nextWordPut: (tag bitShift: 6) + 16r3F.		self nextULongPut: length.	] ifFalse:[		self nextWordPut: (tag bitShift: 6) + length.	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:04'!nextULongPut: long	self nextBytePut: (long bitAnd: 255).	self nextBytePut: ((long bitShift: -8) bitAnd: 255).	self nextBytePut: ((long bitShift: -16) bitAnd: 255).	self nextBytePut: ((long bitShift: -24) bitAnd: 255).! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:06'!nextWordPut: value	self nextBytePut: (value bitAnd: 255).	self nextBytePut: ((value bitShift: -8) bitAnd: 255).! !!FlashFileStream methodsFor: 'private' stamp: 'ar 7/3/1998 18:17'!convertChar2Squeak: aCharacter	"Convert aCharacter from SWF char set (whatever this may be) to Squeaks char set"	^aCharacter! !!FlashFileStream methodsFor: 'private' stamp: 'ar 10/16/1998 01:01'!convertCharFromSqueak: aCharacter	"Convert aCharacter to SWF char set (whatever this may be) "	^aCharacter! !!FlashFileStream class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 17:33'!on: aSourceStream	^self basicNew on: aSourceStream! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:23'!close	stream close! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:22'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:26'!writeHeader: bounds rate: frameRate	"Read header information from the source stream.	Return true if successful, false otherwise."	self halt.	self writeSignature.	stream nextBytePut: 3. "Always write flash3"	dataSize _ stream nextLongPut: 0.	"Place holder for data size"	stream nextRectPut: bounds.	stream nextWordPut: (frameRate * 256) truncated.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:20'!writeSignature	stream nextBytePut: $F asInteger.	stream nextBytePut: $W asInteger.	stream nextBytePut: $S asInteger.! !!FlashFileWriter class methodsFor: 'class initialization' stamp: 'ar 10/16/1998 00:31'!initialize	"FlashFileWriter initialize"	TagTable _ Dictionary new.	FlashFileReader tagTable doWithIndex:[:tag :index|		TagTable at: (tag copyWithout: $:) asSymbol put: index	].! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:23'!newFileNamed: aString	"FlashFileWriter newFileNamed:'f:\wdi\GraphicsEngine\flash\test.swf'"	^self on: (FileStream newFileNamed: aString).! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:24'!on: aStream	^self new on: aStream! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:17'!color: aColor	super color: aColor.	submorphs do:[:m| m color: aColor].! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel	^4! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!decodeJPEGTables: aStream	self setStream: aStream.	eoiSeen _ false.	self parseFirstMarker.	[eoiSeen] whileFalse:[self parseNextMarker].! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 21:33'!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	self isStreaming ifFalse:[Cursor wait show].	image _ self nextImage.	self isStreaming ifFalse:[Cursor normal show].	^image! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 23:25'!nextImageDitheredToDepth: depth	"Overwritten to yield every now and then."	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		"self isStreaming ifTrue:[Processor yield]."		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!parseEndOfInput	eoiSeen _ true.! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:42'!next	^stream nextByte! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:43'!next: n	^stream nextBytes: n! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:32'!isStreaming	^streaming! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:31'!isStreaming: aBool	streaming _ aBool! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 1/15/1999 03:35'!understandsImageFormat	"Return false so we don't get confused with ImageReadWriter's mechanism for finding the right class to read a given stream."	^false! !!FlashKeyframe methodsFor: 'initialize' stamp: 'ar 11/12/1998 22:55'!from: startValue to: stopValue data: newData	start _ startValue.	stop _ stopValue.	data _ newData.! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data	^data! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data: anObject	data _ anObject! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start	^start! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start: startValue	start _ startValue! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop	^stop! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop: stopValue	stop _ stopValue! !!FlashKeyframe methodsFor: 'testing' stamp: 'ar 11/12/1998 22:56'!contains: aNumber	^aNumber >= start and:[aNumber <= stop]! !!FlashKeyframe methodsFor: 'printing' stamp: 'ar 11/13/1998 14:33'!printOn: aStream	aStream nextPutAll: self class name;		nextPut:$(;		print: start;		nextPut:$-;		print: stop;		nextPutAll:' -> ';		print: data;		nextPut:$)! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:47'!from: startValue to: stopValue	^self new from: startValue to: stopValue! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:54'!from: startValue to: stopValue data: newData	^self new from: startValue to: stopValue data: newData! !!FlashKeyframes methodsFor: 'initialize' stamp: 'ar 8/14/1998 19:32'!initialize	kfList _ OrderedCollection new.! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 23:05'!at: frameNumber	"Return data from the keyframe list at the given frame number"	| lastEntry |	kfList isEmpty ifTrue:[^nil].	lastIndex ifNil:[lastIndex _ self searchFor: frameNumber].	lastEntry _ kfList at: lastIndex.	(lastEntry contains: frameNumber) ifTrue:[^lastEntry data].	"Do a quick check if the frame is out of range"	kfList first stop >= frameNumber 		ifTrue:[	lastIndex _ 1.				^kfList first data].	kfList last start <= frameNumber 		ifTrue:[	lastIndex _ kfList size. 				^kfList last data].	"Search linearly from lastEntry - most times we'll just be one step away"	[lastEntry stop >= frameNumber] whileFalse:[		lastIndex _ lastIndex+1.		lastEntry _ kfList at: lastIndex].	[lastEntry start <= frameNumber] whileFalse:[		lastIndex _ lastIndex-1.		lastEntry _ kfList at: lastIndex].	^lastEntry data! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!at: frameNumber put: newData	"Add newData to the keyframe list at the given frameNumber"	| kf |	kfList ifNil:[kfList _ OrderedCollection new].	kfList isEmpty ifFalse:["Check if we can extend the last interval"		kf _ kfList last.		kf stop < frameNumber 			ifFalse:[^self replaceData: newData at: frameNumber].		kf data = newData "Extend interval to include frameNumber"			ifTrue:[	kf stop: frameNumber.					^newData].		"Extend last interval to just before frameNumer"		kf stop: frameNumber - 1].	kfList add: (FlashKeyframe from: frameNumber to: frameNumber data: newData).	^newData! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!keys	^kfList collect:[:kf| kf start].! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 10/14/1998 20:27'!size	^kfList size! !!FlashKeyframes methodsFor: 'printing' stamp: 'ar 8/14/1998 19:32'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		cr.	kfList do:[:item| aStream print: item; cr].	aStream nextPut:$).! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:51'!replaceData: newData at: frameNumber	(kfList last stop = frameNumber) 		ifTrue:[^self replaceLastData: newData at: frameNumber].	self halt:'Not implemented yet'! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/18/1998 23:29'!replaceLastData: newData at: frameNumber	| kf |	lastIndex _ nil.	kf _ kfList last.	(kf stop = kf start)		ifTrue:[kfList removeLast]		ifFalse:[kf stop: kf stop-1].	^self at: frameNumber put: newData! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:54'!searchFor: frameNumber	"Return data from the keyframe list at the given frame number"	| low high mid kf |	low _ kfList at: 1.	high _ kfList at: kfList size.	"Check if in or before first keyframe interval"	frameNumber <= low stop ifTrue:[^1].	"Check if in or after last keyframe interval"	frameNumber >= high start ifTrue:[^kfList size].	"Somewhere inbetween 2nd to (n-1)th interval"	low _ 2. high _ kfList size - 1.	[mid _ high + low // 2.	low > high] whileFalse:[		kf _ kfList at: mid.		(kf contains: frameNumber) ifTrue:[^mid].		(kf start < frameNumber)			ifTrue:[low _ mid + 1]			ifFalse:[high _ mid - 1]].	kf _ kfList at: low.	(kf contains: frameNumber) ifFalse:[self error:'No keyframe found'].	^low! !!FlashKeyframes class methodsFor: 'instance creation' stamp: 'ar 8/14/1998 19:32'!new	^super new initialize! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color	^color! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor	color _ aColor! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor width: aNumber	self color: aColor.	self width: aNumber.! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width	^width! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width: aNumber	width _ aNumber! !!FlashLineStyle methodsFor: 'comparing' stamp: 'ar 8/15/1998 00:59'!= aLineStyle	self class = aLineStyle class ifFalse:[^false].	^self color = aLineStyle color and:[self width = aLineStyle width].! !!FlashLineStyle class methodsFor: 'instance creation' stamp: 'ar 7/14/1998 21:19'!color: aColor width: aNumber	^self new color: aColor width: aNumber! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:28'!loadInitialFrame	self computeBounds.! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:23'!lockChildren	submorphs do:[:m| 		m isMouseSensitive ifFalse:[m lock]].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/13/1998 16:10'!reset	submorphs do:[:m| m isFlashMorph ifTrue:[m reset]].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 8/15/1998 17:21'!unlockChildren	submorphs do:[:m| m unlock].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:41'!activationKeys	^#()! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform	^colorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:48'!defaultAALevel	^self valueOfProperty: #aaLevel! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel: aNumber	aNumber isNil 		ifTrue:[self removeProperty: #aaLevel]		ifFalse:[self setProperty: #aaLevel toValue: aNumber]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:13'!delete	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	^super delete! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00'!depth	^(self valueOfProperty: #depth) ifNil:[0]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00'!depth: d	d = 0		ifTrue:[self removeProperty: #depth]		ifFalse:[self setProperty: #depth toValue: d]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:40'!flashPlayer	| parent |	parent _ owner.	[parent isNil] whileFalse:[		(parent isFlashMorph and:[parent isFlashPlayer]) ifTrue:[^parent].		parent _ parent owner].	^nil! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:40'!id	^-1! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^true! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 1/4/1999 08:48'!originalFileSize	^(self valueOfProperty: #originalFileSize) ifNil:[0]! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:12'!isFlashMorph	^true! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:04'!isFlashPlayer	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 11:02'!canvasForSubmorphs: canvasForMe	"Note: canvasForMe is a BalloonCanvas and 	the state of it can be modified in this method"	| canvas aaLevel |	canvas _ (super canvasForSubmorphs: canvasForMe).	colorTransform ifNotNil:[canvas _ canvas colorTransformBy: colorTransform].	aaLevel _ self defaultAALevel.	aaLevel isNil		ifTrue:[^canvas]		ifFalse:[^canvas aaLevel: aaLevel]! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 19:04'!debugDraw	| vis canvas m |	vis _ self visible.	self visible: true.	canvas _ BalloonCanvas on:Display.	m _ MatrixTransform2x3 withScale: 0.05.	m offset: (self fullBounds origin // 20) negated.	canvas transformBy: m.	self fullDrawOn: canvas.	self visible: vis.! !!FlashMorph methodsFor: 'menu' stamp: 'ar 1/4/1999 08:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self defaultAALevel = nil		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self defaultAALevel = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self defaultAALevel = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].	aCustomMenu add:'show compressed size' action: #showCompressedSize.! !!FlashMorph methodsFor: 'menu' stamp: 'ar 1/5/1999 16:18'!showCompressedSize	| size string |	size _ self originalFileSize.	size = 0 		ifTrue:[string _ 'Compressed size: not available']		ifFalse:[string _ 'Compressed size: ', size asStringWithCommas, ' bytes'].	self world primaryHand attachMorph:		(TextMorph new contents: string; beAllFont: ScriptingSystem fontForTiles).! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingMore	self defaultAALevel: 4.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOff	self defaultAALevel: nil.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOn	self defaultAALevel: 2.	self changed! !!FlashMorph methodsFor: 'events' stamp: 'ar 12/30/1998 09:00'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	self transform: (self transformFrom: self world).	"If extracted from player and no default AA level is set use prefs"	(player notNil and:[self defaultAALevel == nil]) ifTrue:[		Preferences extractFlashInHighQuality ifTrue:[self defaultAALevel: 2].		Preferences extractFlashInHighestQuality ifTrue:[self defaultAALevel: 4].	].! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/18/1998 14:04'!justDroppedInto: newOwner event: evt	| ownerTransform |	ownerTransform _ (newOwner transformFrom: newOwner world).	ownerTransform isIdentity ifFalse:[		ownerTransform _ ownerTransform asMatrixTransform2x3 inverseTransformation.		self transform: (self transform composedWithGlobal: ownerTransform).	].	super justDroppedInto: newOwner event: evt.! !!FlashMorph methodsFor: 'printing' stamp: 'ar 11/16/1998 11:40'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$[;		print: self depth;		space.	self visible 		ifTrue:[aStream nextPutAll:'visible']		ifFalse:[aStream nextPutAll:'invisible'].	aStream		nextPutAll:' id = ';		print: self id;		nextPut:$];		cr.! !!FlashMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 16:44'!withAll: aCollection	^(self new) 		addAllMorphs: aCollection;		computeBounds;		yourself! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/15/1998 23:45'!doLog	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/14/1998 19:22'!logShapes	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/21/1998 00:30'!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	spriteOwners _ IdentityDictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.	streamingSound _ FlashStreamingSound new.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 20:45'!processFile	"Read and process the entire file"	super processFile.	player loadInitialFrame.	player startPlaying.	player open.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 21:54'!processFileAsync	"Read and process the entire file"	self processHeader ifFalse:[^nil].	player sourceUrl:'dummy'.	[self processFileContents] fork.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:44'!processFileAsync: aPlayer	"Read and process the entire file"	player _ aPlayer.	super processFile.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/21/1998 00:50'!processFileContents	super processFileContents.	self flushStreamingSound.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/16/1998 01:23'!recordFontShapeEnd: fontId with: charId	| font shape |	self endShape.	shape _ FlashGlyphMorph withAll: currentShape contents reversed.	shape lockChildren.	currentShape resetToStart.	font _ fonts at: fontId ifAbsentPut:[Dictionary new].	font at: charId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/12/1998 21:39'!recordFontShapeStart: fontId with: charId	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.	self recordSolidFill: 1 color: Color black.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41'!recordNextChar: glyphIndex advanceWidth: advance	| shape transform |	(activeFont includesKey: glyphIndex) ifTrue:[		shape _ (activeFont at: glyphIndex) fullCopy reset.		"Must include the textMorph's transform here - it might be animated"		transform _  ((MatrixTransform2x3 withOffset: textOffset) 							setScale: (textHeight@textHeight) / 1024.0).		transform _ transform composedWithGlobal: textMorph transform.		shape transform: transform.		shape color: textMorph color.		textMorph addMorphBack: shape.].	textOffset _ textOffset + (advance@0).! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:46'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height	fontId ifNotNil:[activeFont _ fonts at: fontId].	height ifNotNil:[textHeight _ height].	xOffset ifNotNil:[textOffset _ xOffset @ textOffset x].	yOffset ifNotNil:[textOffset _ textOffset x @ yOffset].	color ifNotNil:[textMorph color: color].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 00:50'!recordTextEnd: id	textMorph submorphs isEmpty ifFalse:[		textMorph allMorphsDo:[:m| m color: textMorph color].		textMorph transform: nil.		textMorph id: id.		textMorph stepTime: stepTime.		textMorph lockChildren.		shapes at: id put: textMorph].	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41'!recordTextStart: id bounds: bounds matrix: matrix	textOffset _ 0@0.	textMorph _ FlashTextMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.	matrix ifNotNil:[textMorph transform: matrix].! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 16:19'!recordCurveSegmentTo: anchorPoint with: controlPoint	| target midPoint |	midPoint _ location + controlPoint.	target _ midPoint + anchorPoint.	self addLineFrom: location to: target via: midPoint.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"	self endShape.	self beginShape.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle0: fillIndex	fillIndex0 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle1: fillIndex	fillIndex1 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/3/1998 16:09'!recordLineSegmentBy: deltaPoint	| target |	target _ location + deltaPoint.	self addLineFrom: location to: target via: location.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:40'!recordLineStyle: styleIndex	lineStyleIndex _ styleIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:44'!recordMoveTo: aPoint	location _ aPoint.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/16/1998 01:23'!recordShapeEnd: shapeId	| shape |	self endShape.	shape _ FlashCharacterMorph withAll: (currentShape contents reversed).	shape lockChildren.	currentShape resetToStart.	shape id: shapeId.	shape stepTime: stepTime.	shapes at: shapeId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 1/4/1999 08:47'!recordShapeProperty: id length: length	(shapes at: id ifAbsent:[^self]) setProperty: #originalFileSize toValue: length! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 23:23'!recordShapeStart: shapeId bounds: bounds	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/3/1998 18:09'!addLineFrom: start to: end via: via	canCompressPoints ifTrue:[		"Check if we can compress the incoming points"		(compressionBounds containsPoint: start) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: via) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: end) ifFalse:[canCompressPoints _ false].	].	pointList nextPut: start.	pointList nextPut: via.	pointList nextPut: end.	leftFillList nextPut: fillIndex0.	rightFillList nextPut: fillIndex1.	lineStyleList nextPut: lineStyleIndex.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:43'!beginShape	canCompressPoints _ true.	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	pointList resetToStart.	leftFillList resetToStart.	rightFillList resetToStart.	lineStyleList resetToStart.	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:24'!computeFillLists	"Compute the fill index lists"	| leftFills rightFills |	leftFills_ leftFillList contents as: ShortRunArray.	rightFills _ rightFillList contents as: ShortRunArray.	^Array with: leftFills with: rightFills! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/16/1998 13:02'!computeLineStyleLists	"Compute the line style index lists.	Each line style will be splitted into two parts, the width and the fill.	Then, the fills will be added to the fillStyles and the indexes will be adjusted.	Finally, we compute two arrays containing the width of each line and the	fill style of each line"	| widthList fillList indexMap oldIndex newIndex allFillStyles style |	allFillStyles _ Dictionary new.	fillStyles associationsDo:[:assoc| 		allFillStyles at: assoc key put: assoc value].	indexMap _ Dictionary new.	lineStyles associationsDo:[:assoc|		oldIndex _ assoc key.		style _ assoc value.		allFillStyles at: allFillStyles size+1 put: (SolidFillStyle color: style color).		newIndex _ allFillStyles size.		indexMap at: oldIndex put: newIndex.	].	widthList _ OrderedCollection new: lineStyles size.	fillList _ OrderedCollection new: lineStyles size.	lineStyleList contents do:[:index|		index = 0 ifTrue:[			widthList add: 0.			fillList add: 0.		] ifFalse:[			style _ lineStyles at: index ifAbsent:[FlashLineStyle color: Color black width: 20].			widthList add: style width.			fillList add: (indexMap at: index ifAbsent:[1]).		].	].	widthList _ widthList as: ShortRunArray.	fillList _ fillList as: ShortRunArray.	^Array with: allFillStyles with: fillList with: widthList! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/15/1998 15:32'!endShape	| points shape fillLists lineLists index |	canCompressPoints ifTrue:[		points _ ShortPointArray new: pointList size.	] ifFalse:[		points _ PointArray new: pointList size.	].	index _ 1.	pointList contents do:[:p|		points at: index put: p.		index _ index + 1].	fillLists _ self computeFillLists.	lineLists _ self computeLineStyleLists.	shape _ FlashBoundaryShape 				points: points 				leftFills: fillLists first				rightFills: fillLists last				fillStyles: lineLists first				lineWidths: lineLists last				lineFills: (lineLists at: 2).	shape remapFills.	currentShape nextPut:(FlashShapeMorph shape: shape).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 12/5/1998 22:22'!recordBitmapFill: index matrix: bmMatrix id: bitmapID clipped: aBoolean	| fillStyle form |	form _ forms at: bitmapID ifAbsent:[^nil].	fillStyle _ BitmapFillStyle form: form.	fillStyle origin: (bmMatrix localPointToGlobal: 0@0).	fillStyle direction: (bmMatrix localPointToGlobal: form extent x @ 0) - fillStyle origin.	fillStyle normal: (bmMatrix localPointToGlobal: 0 @ form extent y) - fillStyle origin.	fillStyle tileFlag: aBoolean not.	fillStyles at: index put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/18/1998 21:36'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean	| fillStyle ramp origin direction normal |	ramp _ colorRampArray collect:[:assoc| (assoc key / 255.0) -> assoc value].	origin _ gradientMatrix localPointToGlobal: (aBoolean ifFalse:[0@0] ifTrue:[-16384@0]).	direction _ (gradientMatrix localPointToGlobal: (16384@0)) - origin.	normal _ (gradientMatrix localPointToGlobal: (0@16384)) - origin.	fillStyle _ GradientFillStyle ramp: ramp.	fillStyle origin: origin.	fillStyle direction: direction.	fillStyle normal: normal.	fillStyle radial: aBoolean not.	fillStyle pixelRamp. "Force creation beforehand"	fillStyles at: fillIndex put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 8/15/1998 00:58'!recordLineStyle: styleIndex width: lineWidth color: lineColor	lineStyles at: styleIndex put: (FlashLineStyle color: lineColor width: lineWidth).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/11/1998 22:39'!recordSolidFill: index color: fillColor	fillStyles at: index put: (SolidFillStyle color: fillColor)! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:44'!recordBackgroundColor: aColor	player color: aColor! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30'!recordBeginSprite: id frames: frameCount	| sprite |	sprite _ FlashSpriteMorph new.	sprite maxFrames: frameCount.	sprite stepTime: stepTime.	spriteOwners at: sprite put: (		Array with: player 			with: frame			with: activeMorphs			with: passiveMorphs).	player _ sprite.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/12/1998 21:50'!recordBitmap: id data: aForm	aForm ifNil:[^self].	"Record the current form"	forms at: id put: aForm.	"Define a new character"! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:35'!recordEndSprite: id	| shape sprite |	sprite _ player.	player _ (spriteOwners at: sprite) at: 1.	frame _ (spriteOwners at: sprite) at: 2.	activeMorphs _ (spriteOwners at: sprite) at: 3.	passiveMorphs _ (spriteOwners at: sprite) at: 4.	spriteOwners removeKey: sprite.	sprite loadInitialFrame.	shape _ FlashCharacterMorph withAll: (Array with: sprite).	shape id: id.	shape isSpriteHolder: true.	shape stepTime: stepTime.	shapes at: id put: shape.	shape lockChildren.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 22:53'!recordFrameActions: actionList	player addActions: actionList atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames	player maxFrames: maxFrames! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36'!recordFrameLabel: label	"Name the current frame with the given label"	player addLabel: label atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 00:32'!recordFrameRate: fps	frameRate _ fps.	fps > 0.0 ifTrue:[stepTime _ (1000.0 / fps) rounded].	player stepTime: stepTime.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 20:42'!recordGlobalBounds: bounds	player localBounds: bounds.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 02:11'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:51'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorTransform	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorTransform: colorTransform atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 01:57'!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[#()]) do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	Transcript cr; nextPutAll:'Shape (id = '; print: id; nextPutAll:' depth = '; print: depth; nextPutAll:') not removed in frame '; print: frame; endEntry.	^nil! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30'!recordShowFrame	player loadedFrames: frame.	frame _ frame + 1.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/20/1998 01:04'!createSound: id info: info	| theSound loops |	theSound _ sounds at: id ifAbsent:[^nil].	loops _ info loopCount.	loops <= 1 ifTrue:[^theSound].	^RepeatingSound repeat: theSound count: loops! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:39'!myActiveMorphs	| out |	out _ WriteStream on: (Array new: 10).	activeMorphs do:[:array| out nextPutAll: array].	^out contents! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:26'!myFlush		Transcript endEntry.		Sensor leftShiftDown ifTrue:[self halt].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 17:45'!newMorphFromShape: objectIndex	"Return a new character morph from the given object index.	If the character morph at objectIndex is already used, then create and return a full copy of it"	| prototype |	prototype _ self oldMorphFromShape: objectIndex.	prototype isNil ifTrue:[^nil].	^(prototype owner notNil) 		ifTrue:[prototype fullCopy]		ifFalse:[prototype].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 20:24'!oldMorphFromShape: objectIndex	"Return an existing character morph from the given object index."	| prototype |	prototype _ shapes at: objectIndex ifAbsent:[nil].	"prototype ifNil:[prototype _ buttons at: objectIndex ifAbsent:[nil]]."	prototype ifNil:[Transcript cr; nextPutAll:'No shape for '; print: objectIndex; nextPutAll:' in frame '; print: frame; endEntry].	^prototype! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:27'!placeGlyph: aMorph at: position	aMorph privateFullMoveBy: position.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 21:55'!removeActiveMorph: aMorph	| newActive newPassive |	aMorph visible: false atFrame: frame.	newActive _ (activeMorphs at: aMorph id) copyWithout: aMorph.	newPassive _ (passiveMorphs at: aMorph id ifAbsent:[#()]) copyWith: aMorph.	activeMorphs at: aMorph id put: newActive.	passiveMorphs at: aMorph id put: newPassive.	^aMorph! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:28'!resizeGlyph: aMorph to: extent	aMorph extent: 1440@1440.	aMorph extent: extent.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/20/1998 01:59'!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self halt].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter sendAll: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave sendAll: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown sendAll: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp sendAll: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut sendAll: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:24'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	| button children shape |	button _ buttons at: buttonId ifAbsent:[^self halt].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[^nil].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape depth: layer.	shape transform: matrix.	shape colorTransform: cxForm.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/21/1998 02:20'!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self halt].	theSound _ self createSound: soundId info: soundInfo.	theSound ifNil:[^self].	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:51'!recordButton: id trackAsMenu: aBoolean	| button |	button _ buttons at: id ifAbsent:[^self halt].	button trackAsMenu: aBoolean.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"	| button |	button _ buttons at: id put: FlashButtonMorph new.	button id: id.	shapes at: id put: button.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 21:11'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashMorphReader methodsFor: 'testing' stamp: 'ar 11/18/1998 21:37'!isStreaming	^player isStreaming! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 14:08'!flushStreamingSound	| sound |	streamingSound buffers ifNil:[^self].	streamingSound buffers first position = 0 ifFalse:[		sound _ self createSoundFrom: streamingSound buffers					stereo: streamingSound stereo					samplingRate: streamingSound samplingRate.		player addSound: sound at: streamingSound firstFrame].	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.	streamingSound buffers do:[:s| s reset].! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38'!recordSound: id data: aSampledSound	aSampledSound ifNotNil:[sounds at: id put: aSampledSound]! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:47'!recordSoundStreamBlock: data	streamingSound frameNumber + 1 = frame 		ifFalse:[self flushStreamingSound].	self decompressSound: data					stereo: streamingSound stereo 					samples: streamingSound sampleCount 					rate: streamingSound samplingRate					into: streamingSound buffers.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:53'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed	streamingSound buffers isNil ifFalse:[self flushStreamingSound].	streamingSound mixFmt: mixFmt.	streamingSound stereo: stereo.	streamingSound bitsPerSample: bitsPerSample.	streamingSound sampleCount: sampleCount.	streamingSound compressed: compressed.	streamingSound samplingRate: (frameRate * sampleCount) truncated.	streamingSound buffers: (self createSoundBuffersOfSize: sampleCount stereo: stereo).	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38'!recordStartSound: id info: info	| theSound |	theSound _ self createSound: id info: info.	theSound ifNotNil:[player addSound: theSound at: frame].! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:47'!initialExtent	^player bounds extent! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!isStreaming	^player isStreaming! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:33'!loadedFrames	^player loadedFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!maxFrames	^player maxFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	player _ flashPlayer! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!progressValue	^player progressValue! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:45'!startPlaying	player startPlaying! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	player stopPlaying! !!FlashPlayerModel class methodsFor: 'instance creation' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	^self new player: flashPlayer! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:53'!downloadState	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 23:09'!downloadStateIn: aScamper	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	"Wait until the first frame is there"	[loadedFrames = 0] whileTrue:[(Delay forMilliseconds: 100) wait].	aScamper invalidateLayout.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 12/30/1998 13:26'!initialize	super initialize.	color _ Color white.	self loopFrames: true.	localBounds _ bounds.	activationKeys _ #().	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	progressValue _ ValueHolder new.	progressValue contents: 0.0.	self defaultAALevel: 2.	self deferred: true.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 20:31'!loadInitialFrame	"Note: Must only be sent to a player if not in streaming mode"	self isStreaming ifTrue:[^self].	super loadInitialFrame.	activationKeys _ self collectActivationKeys: maxFrames.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 12/30/1998 14:47'!makeControls	| b r loopSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2.	r _ AlignmentMorph newRow.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #startPlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #stopPlaying).	r addMorphBack: (b fullCopy label: 'Next';			actionSelector: #stepForward).	r addMorphBack: (b fullCopy label: 'Prev';			actionSelector: #stepBackward).	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Loop';		actionSelector: #loopFrames:;		target: self;		setSwitchState: self loopFrames.	r addMorphBack: loopSwitch.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Defer';		actionSelector: #toggleDeferred;		target: self;		setSwitchState: self deferred.	r addMorphBack: loopSwitch.	r addMorphBack: (b fullCopy label: 'Fastest'; 	actionSelector: #drawFastest).	r addMorphBack: (b fullCopy label: 'Medium';	actionSelector: #drawMedium).	r addMorphBack: (b fullCopy label: 'Nicest';		actionSelector: #drawNicest).	r addMorphBack: (b fullCopy label: '+10';		actionSelector: #jump10).	b target: self.	^ self world activeHand attachMorph: r! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 21:40'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:39'!openInMVC	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInMVCExtent: extent! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:24'!openInWorld	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInWorldExtent: extent! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 19:21'!sourceUrl: urlString	sourceUrl _ urlString! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:27'!addMorph: aMorph	aMorph isFlashMorph ifFalse:[^super addMorph: aMorph].	aMorph isMouseSensitive		ifTrue:[self addMorphFront: aMorph]		ifFalse:[self addMorphBack: aMorph].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52'!borderWidth	"Ignored here - only for keeping the window happy"	^0! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52'!borderWidth: bw	"Ignored here - only for keeping the window happy"! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 12/30/1998 11:13'!deferred	^self hasProperty:#deferred! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 12/30/1998 11:14'!deferred: aBoolean	aBoolean 		ifTrue:[self setProperty: #deferred toValue: true]		ifFalse:[self removeProperty: #deferred]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:46'!isStreaming	"Return true if we're in streaming mode"	^sourceUrl notNil! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:59'!loadedFrames: aNumber	self isStreaming ifTrue:[		activationKeys _ self collectActivationKeys: aNumber.		aNumber = 1 ifTrue:[			activeMorphs addAll: activationKeys first.			self changed].		progressValue contents: (aNumber asFloat / maxFrames).		"Give others a chance"		World == nil			ifTrue:[Processor yield]			ifFalse:[World doOneCycle].	].	loadedFrames _ aNumber.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 00:56'!localBounds	^localBounds ifNil:[localBounds _ self transform globalBoundsToLocal: self bounds]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 20:43'!localBounds: newBounds	localBounds _ newBounds.	bounds _ (self position extent: newBounds extent // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:17'!loopFrames	^(self valueOfProperty: #loopFrames) ifNil:[false]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:51'!loopFrames: aBoolean	self setProperty: #loopFrames toValue: aBoolean! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue	^progressValue! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue: aValueHolder	progressValue _ aValueHolder! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 11:30'!canvasForSubmorphs: canvasForMe	^(canvasForMe asBalloonCanvas)		transformBy: self transform; 		aaLevel: (self defaultAALevel ifNil:[1]);		deferred: self deferred! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 02:38'!debugDraw	self fullDrawOn: (FormCanvas on: Display)! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 20:28'!drawOn: aCanvas 	"Draw the background of the player"	| box |	box _ self bounds.	aCanvas fillRectangle: box color: color! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 11:06'!fullDrawOn: aCanvas	"Overridden to only the draw the currently active morphs"	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	(aCanvas copyClipRect: self bounds) 		asBalloonCanvas preserveStateDuring:[:balloonCanvas|			canvasForSubmorphs _ self canvasForSubmorphs: balloonCanvas.			activeMorphs reverseDo:  "Display submorphs back to front"				[:m | m fullDrawOn: canvasForSubmorphs].			canvasForSubmorphs deferred ifTrue:[canvasForSubmorphs flush].		].! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 20:30'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 15:32'!boundsChangedFrom: oldBounds to: newBounds	transform _ MatrixTransform2x3					transformFromLocal: localBounds					toGlobal: newBounds.! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 01:06'!computeBounds	"Do nothing."! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 16:07'!fullBounds	"The player clips its children"	^bounds! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48'!fullContainsPoint: pt	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^false].	^super fullContainsPoint: pt! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48'!unlockedMorphsAt: pt addTo: mList	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^mList].	^super unlockedMorphsAt: pt addTo: mList! !!FlashPlayerMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:05'!isFlashPlayer	^true! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/6/1998 23:56'!jump10	1 to: 10 do:[:i| self stepForward].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:54'!rewind	self frameNumber: 1.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 12/30/1998 14:46'!stepToFrame: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame = (frameNumber+1) ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	self executeActionsAt: frame.	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33'!stepToFrameForward: frame	| activeRemoved resortNeeded morph |	frameNumber+1 to: frame do:[:f|		activeRemoved _ false.		resortNeeded _ false.		1 to: activeMorphs size do:[:i|			morph _ activeMorphs at: i.			morph stepToFrame: f.			morph visible ifFalse:[activeRemoved _ true].			(i > 1 and:[(activeMorphs at: i-1) depth < morph depth])				ifTrue:[resortNeeded _ true].		].		activeRemoved ifTrue:[			activeMorphs _ activeMorphs select:[:m| m visible].			resortNeeded _ false.		].		resortNeeded ifTrue:[activeMorphs reSort].		(activationKeys at: f) do:[:m|			m stepToFrame: f.			m visible ifTrue:[activeMorphs add: m].		].	].! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/18/1998 23:21'!collectActivationKeys: frame	"Note: Must only be called after a frame has been completed"	| vis lastKey |	vis _ Array new: frame.	vis atAllPut: #().	lastKey _ activationKeys size.	vis replaceFrom: 1 to: lastKey with: activationKeys startingAt: 1.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m activationKeys do:[:key|				key > lastKey ifTrue:[					vis at: key put: ((vis at: key) copyWith: m)				].			].		].	].	^vis! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/16/1998 02:58'!noticeRemovalOf: aFlashMorph	"The flash morph is removed from the player.	Remove it's activation keys so that we don't have any problems."	| morphs |	aFlashMorph activationKeys do:[:key|		morphs _ activationKeys at: key.		activationKeys at: key put: (morphs copyWithout: aFlashMorph).	].	"And remove it from the activeMorphs"	activeMorphs remove: aFlashMorph ifAbsent:[]! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 12/30/1998 14:33'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'make controls' action: #makeControls.	"aCustomMenu add:'Toggle deferring' action: #toggleDeferred."	"aCustomMenu addLine.	aCustomMenu add: 'make controls' action: #makeControls.	aCustomMenu addLine.	aCustomMenu add: 'Low Quality' action: #drawFastest.	aCustomMenu add: 'Med Quality' action: #drawMedium.	aCustomMenu add: 'High Quality' action: #drawNicest."	"aCustomMenu add: 'make slider' action: #makeSlider."	aCustomMenu addLine.! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 12/30/1998 14:44'!drawFastest	self defaultAALevel: 1.	self changed.! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 12/30/1998 14:44'!drawMedium	self defaultAALevel: 2.	self changed.! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 12/30/1998 14:44'!drawNicest	self defaultAALevel: 4.	self changed.! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 12/30/1998 11:33'!toggleDeferred	self deferred: self deferred not.	self changed.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:25'!addMorph: aMorph frame: relFrame	"Do not change the color"	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34'!addProgressIndicator	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!addProgressIndicator: aValueHolder	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress value: aValueHolder.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34'!adjustBookControls	| inner |	startButton ifNil: [^ self].	startButton align: startButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	progress ifNotNil:[		progress align: progress topLeft with: (startButton right @ inner top) + (10@0)].	stopButton align: stopButton topRight with: inner topRight - (16@4).! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:40'!collapseOrExpand	super collapseOrExpand.	isCollapsed ifTrue:[		startButton delete.		stopButton delete.		progress ifNotNil:[progress delete].	] ifFalse:[		self addMorph: startButton.		self addMorph: stopButton.		progress ifNotNil:[self addMorph: progress].		self adjustBookControls.	].! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:45'!initialize	| aFont |	super initialize.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (startButton _ SimpleButtonMorph new borderWidth: 0;			label: 'play' font: aFont; color: Color transparent;			actionSelector: #startPlaying; target: self).	startButton setBalloonText: 'continue playing'.	self addMorph: (stopButton _ SimpleButtonMorph new borderWidth: 0;			label: 'stop' font: aFont; color: Color transparent;			actionSelector: #stopPlaying; target: self).	stopButton setBalloonText: 'stop playing'.	startButton submorphs first color: Color blue.	stopButton submorphs first color: Color red.	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 21:10'!model: aFlashPlayerModel	aFlashPlayerModel isStreaming		ifTrue:[self addProgressIndicator: aFlashPlayerModel progressValue].	^super model: aFlashPlayerModel! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInMVCExtent: extent	Smalltalk isMorphic ifTrue:[^self openInWorldExtent: extent].	super openInMVCExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInWorldExtent: extent	Smalltalk isMorphic ifFalse:[^self openInMVCExtent: extent].	super openInWorldExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:46'!startPlaying	model startPlaying! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	model stopPlaying! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor	^progressColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor: aColor	progressColor _ aColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:09'!value	^value! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!value: aModel	value removeDependent: self.	value _ aModel.	value addDependent: self.! !!FlashProgressMorph methodsFor: 'drawing' stamp: 'ar 11/18/1998 22:58'!drawOn: aCanvas	| width inner |	super drawOn: aCanvas.	inner _ self innerBounds.	width _ (inner extent x * lastValue) truncated min: inner extent x.	aCanvas fillRectangle: (inner origin extent: width @ inner extent y) color: progressColor.! !!FlashProgressMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 22:59'!initialize	super initialize.	progressColor _ Color green.	value _ ValueHolder new.	value contents: 0.0.	value addDependent: self.	lastValue _ 0.0.! !!FlashProgressMorph methodsFor: 'updating' stamp: 'ar 11/18/1998 23:04'!update: aSymbol	aSymbol == #contents ifTrue:[		lastValue _ value contents.		self changed]! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:19'!color: aColor	| fillStyle |	color _ aColor.	fillStyle _ SolidFillStyle color: aColor.	shape _ shape copyAndCollectFills:[:fill| fillStyle]! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:39'!id	^-1! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 15:31'!shape	^shape! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 16:43'!shape: newShape	shape _ newShape.	self computeBounds.! !!FlashShapeMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:47'!drawOn: aCanvas 	"Display the receiver."	| aaLevel |	shape ifNil:[^aCanvas frameRectangle: self bounds color: Color black.].	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		aaLevel _ self defaultAALevel.		aaLevel ifNotNil:[balloonCanvas aaLevel: aaLevel].		balloonCanvas drawCompressedShape: shape.	].! !!FlashShapeMorph methodsFor: 'geometry' stamp: 'ar 11/18/1998 13:59'!computeBounds	bounds _ self transform localBoundsToGlobal: (shape bounds).	fullBounds _ nil.! !!FlashShapeMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 15:32'!shape: aCompressedFlashGeometry	^self new shape: aCompressedFlashGeometry! !!FlashSoundEnvelope methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:35'!initialize	mark44 _ level0 _ level1 _ 0.! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0	^level0! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0: anInteger	level0 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1	^level1! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1: anInteger	level1 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44	^mark44! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44: anInteger	mark44 _ anInteger! !!FlashSoundEnvelope class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:35'!new	^super new initialize! !!FlashSoundInformation methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:30'!initialize	syncFlags _ 0.	inPoint _ -1.	outPoint _ -1.	loopCount _ 0.	envelopes _ #().! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes	^envelopes! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes: aCollection	envelopes _ aCollection! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint	^inPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint: anInteger	inPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!loopCount	^loopCount! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!loopCount: anInteger	loopCount _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint	^outPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint: anInteger	outPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:30'!syncFlags	^syncFlags! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!syncFlags: anInteger	syncFlags _ anInteger! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:33'!syncNoMultiple	"Don't start the sound if already playing."	^syncFlags anyMask: 1! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:34'!syncStopSound	"Stop the sound."	^syncFlags anyMask: 2! !!FlashSoundInformation class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:29'!new	^super new initialize! !!FlashSpriteMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:07'!initialize	super initialize.	playing _ false.	loadedFrames _ 0.	maxFrames _ 1.	frameNumber _ 1.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:49'!addSound: aSound at: frameNr	| oldSound newSound |	oldSound _ sounds at: frameNr ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frameNr put: newSound.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09'!frameNumber	^frameNumber! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09'!frameNumber: frame	^self stepToFrame: frame! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames	^loadedFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames: n	loadedFrames _ n.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames	^false! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames: aBool! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames	^maxFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames: n	maxFrames _ n! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!startPlaying	"Start playing from the current frame"	playing _ true.	loadedFrames = 0 ifTrue:[^nil].	frameNumber >= maxFrames ifTrue:[self frameNumber: 1].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:19'!step	playing ifFalse:[^self].	self stepForward.	damageRecorder _ nil. "Insurance"! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!stepBackward	frameNumber > 1		ifTrue:[self frameNumber: frameNumber - 1]		ifFalse:[self frameNumber: loadedFrames].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:17'!stepForward	frameNumber < maxFrames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[self loopFrames			ifTrue:[self frameNumber: 1]			ifFalse:[self stopPlaying]].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 12/30/1998 13:06'!stepTime	^stepTime // 2! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 17:07'!stepTime: time	stepTime _ time.! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:10'!stopPlaying	"Stop playing at the current frame."	playing _ false.! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 16:27'!wantsSteps	^true! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^true! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true - my children may be sensitive"	^true! !!FlashSpriteMorph methodsFor: 'change reporting' stamp: 'ar 11/16/1998 16:49'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionPlay	self startPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionStop	"Stop playing at the current frame."	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'di 1/13/1999 12:26'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print: 'actionTarget = '; print: target; endEntry.	^ nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!executeActionsAt: frame	| actionList index msg result |	actionList _ actions at: frame ifAbsent:[^self].	index _ 1.	[index <= actionList size] whileTrue:[		msg _ actionList at: index.		result _ msg sentTo: self.		result ifNotNil:[index _ index + result].		index _ index + 1].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/20/1998 02:36'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."	| browser |	browser _ self getWebBrowser.	browser ifNotNil:[		browser jumpToUrl: urlString.		^nil].	"(self confirm: ('open a browser to view\',urlString,' ?') withCRs) ifTrue: [		browser _ Scamper new.		browser jumpToUrl: urlString.		browser openAsMorph	]."	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoFrame: frame	"Jump to the given frame"	self frameNumber: frame+1.	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet."	^loadedFrames >= frameNumber 		ifTrue:[nil]		ifFalse:[nActions].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."	^nil! !!FlashSpriteMorph methodsFor: 'private' stamp: 'ar 11/19/1998 22:37'!getWebBrowser	"Return a web browser if we're running in one"	| morph |	morph _ self. "I can't really be a web browser, can I?!!"	[morph isNil] whileFalse:[		morph isWebBrowser ifTrue:[^morph].		(morph hasProperty: #webBrowserView) ifTrue:[^morph model].		morph _ morph owner].	"Not in a browser"	^nil! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!bitsPerSample	^bitsPerSample! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!bitsPerSample: aNumber	bitsPerSample _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers	^buffers! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers: anArray	buffers _ anArray! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed	^compressed! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed: aBool	compressed _ aBool! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame	^firstFrame! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame: frame	firstFrame _ frame.! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber	^frameNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber: aNumber	frameNumber _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt	^mixFmt! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt: aNumber	mixFmt _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount	^sampleCount! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount: aNumber	sampleCount _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate	^samplingRate! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate: aNumber	samplingRate _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo	^stereo! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo: aBool	stereo _ aBool! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:40'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"super addCustomMenuItems: aCustomMenu hand: aHandMorph."	aCustomMenu addLine.	aCustomMenu add: 'update from original' action: #updateFromOriginal.	aCustomMenu addList: #(('border color...' changeBorderColor:)						('border width...' changeBorderWidth:)).	aCustomMenu addLine.! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:43'!borderColor: aColor	borderColor _ aColor.	self updateFromOriginal! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:43'!borderWidth: width	borderWidth _ width asPoint.	self updateFromOriginal! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:06'!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	aHand changeColorTarget: self selector: #borderColor:.! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:48'!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand gridPointRaw.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		self borderWidth: (newPoint - origin) abs // 5].	aHand attachMorph: handle.	handle startStepping! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:54'!drawOn: aCanvas	originalForm _ nil.  "Aggressively uncache the originalForm"	^ super drawOn: aCanvas! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:35'!extent: newExtent	self loadOriginalForm.  "make sure it's not nil"	^ super extent: newExtent! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:35'!form	self loadOriginalForm.  "make sure it's not nil"	^ super form! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:35'!generateRotatedForm	self loadOriginalForm.  "make sure it's not nil"	^ super generateRotatedForm! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:37'!initialize	super initialize.	borderWidth _ 2@2.	borderColor _ Color black.! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:35'!layoutChanged	self loadOriginalForm.  "make sure it's not nil"	^ super layoutChanged! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:34'!loadOriginalForm	originalForm ifNil: [self updateFromOriginal].! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 20:19'!originalMorph: aMorph	originalMorph _ aMorph.	scalePoint _ 0.25@0.25.	self updateFromOriginal.! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 19:44'!releaseCachedState	"Clear cache of rotated, scaled Form."	originalForm _ Form extent: 10@10.  "So super hibernate won't have to work hard												but won't crash either."	super releaseCachedState.	rotatedForm _ nil.	originalForm _ nil.! !!FlexMorph methodsFor: 'all' stamp: 'di 1/11/1999 21:46'!updateFromOriginal	| intermediateForm |	intermediateForm _ originalMorph imageForm offset: 0@0.	intermediateForm border: intermediateForm boundingBox		widthRectangle: (borderWidth corner: borderWidth+1)		rule: Form over fillColor: borderColor.	self form: intermediateForm.	originalMorph fullReleaseCachedState! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ aNumber adaptToFloat: self andSend: #*! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:22'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ aNumber adaptToFloat: self andSend: #-! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0 ifTrue: [self error: 'attempt to divide by zero'].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andSend: #<! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andSend: #<=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andSend: #=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:38'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:07'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Float methodsFor: 'copying' stamp: 'tk 8/19/1998 16:08'!veryDeepCopyWith: deepCopier	"Return self.  Do not record me."	^ self clone! !FloatArrays store 32bit IEEE floating point numbers.!!FloatArray methodsFor: 'accessing' stamp: 'ar 10/11/1998 02:45'!at: index	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!FloatArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 21:54'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!FloatArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0.0! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!* anObject	^self clone *= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!*= anObject	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!+ anObject	^self clone += anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:48'!+= anObject	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!- anObject	^self clone -= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!-= anObject	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:34'!/ anObject	^self clone /= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 10/7/1998 19:58'!/= anObject	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!= aFloatArray	| length |	<primitive:'primitiveFloatArrayEqual'>	length _ self size.	(length = aFloatArray size) ifFalse:[^false].	1 to: self size do:[:i| (self at: i) = (aFloatArray at: i) ifFalse:[^false]].	^true! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/11/1998 03:10'!primAddArray: floatArray	<primitive: 'primitiveFloatArrayAddFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primAddScalar: scalarValue	<primitive: 'primitiveFloatArrayAddScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primDivArray: floatArray	<primitive: 'primitiveFloatArrayDivFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primDivScalar: scalarValue	<primitive: 'primitiveFloatArrayDivScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primMulArray: floatArray	<primitive: 'primitiveFloatArrayMulFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primMulScalar: scalarValue	<primitive: 'primitiveFloatArrayMulScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:01'!primSubArray: floatArray	<primitive: 'primitiveFloatArraySubFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primSubScalar: scalarValue	<primitive: 'primitiveFloatArraySubScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/11/1998 03:06'!primAddArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayAddFloatArrayFromTo' module: 'sqPlugin'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) + (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primMulArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayMulFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) * (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primSubArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArraySubFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) - (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asFloatArray	^self! !!FloatArray methodsFor: 'private' stamp: 'ar 10/10/1998 17:40'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!FloatArray methodsFor: 'private' stamp: 'ar 11/7/1998 20:17'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!FloatArray methodsFor: 'private' stamp: 'ar 10/9/1998 11:27'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!FloatArray class methodsFor: 'primitive generation' stamp: 'ar 10/11/1998 03:06'!cCodeString	"FloatArray cCodeString"	^PluggableCodeGenerator new codeStringForPrimitives:#(		(FloatArray primAddArray:withArray:from:to:)		(FloatArray primSubArray:withArray:from:to:)		(FloatArray primMulArray:withArray:from:to:)	)! !FloatArrayPlugin defines the basic access messages for FloatArray (e.g., floatAt: and floatAt:put:).!!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:46'!primitiveFloatArrayAt	| index rcvr floatValue floatPtr |	self export: true.	self var: #floatValue declareC:'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	index _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatValue _ (floatPtr at: index-1) asFloat.	interpreterProxy pop: 2.	interpreterProxy pushFloat: floatValue.! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 19:52'!primitiveFloatArrayAtPut	| value floatValue index rcvr floatPtr |	self export: true.	self var: #floatValue declareC: 'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	value _ interpreterProxy stackValue: 0.	(interpreterProxy isIntegerObject: value)		ifTrue:[floatValue _ (interpreterProxy integerValueOf: value) asFloat]		ifFalse:[floatValue _ interpreterProxy floatValueOf: value].	index _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatPtr at: index-1 put: (self cCoerce: floatValue to:'float').	interpreterProxy failed ifFalse:[interpreterProxy pop: 3 thenPush: value].! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayEqual	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 2.	length _ interpreterProxy stSizeOf: arg.	length = (interpreterProxy stSizeOf: rcvr) ifFalse:[^interpreterProxy pushBool: false].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		(rcvrPtr at: i) = (argPtr at: i) ifFalse:[^interpreterProxy pushBool: false].	].	^interpreterProxy pushBool: true! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayHash	| rcvr rcvrPtr length result |	self export: true.	self var: #rcvrPtr declareC:'int *rcvrPtr'.	rcvr _ interpreterProxy stackObjectValue: 0.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int *'.	result _ 0.	0 to: length-1 do:[:i|		result _ result + (rcvrPtr at: i).		rcvrPtr _ rcvrPtr + 4.	].	interpreterProxy pop: 1.	^interpreterProxy pushInteger: (result bitAnd: 16r1FFFFFFF)! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	"Check if any of the argument's values is zero"	0 to: length-1 do:[:i|		(interpreterProxy longAt: (argPtr + i)) = 0 ifTrue:[^interpreterProxy primitiveFail]].	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) / (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value inverse length |	self export: true.	self var: #value declareC:'double value'.	self var: #inverse declareC:'double inverse'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	value = 0.0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	inverse _ 1.0 / value.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * inverse.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^'SqFloatArray'! !!FloatArrayPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:30'!declareCVarsIn: cg	"Nothing to declare..."! !FontSet provides a mechanism for storing a set of fonts as a class that can be conveniently filedOut, filedIn, and installed as a TextStyle.The most common use is...	Find a font you like.	Use BitFont to convert a bunch of sizes to data files named, eg, LovelyNN.BF	Use FontSet convertFontsNamed: 'Lovely' to produce a FontSet named Lovely.	FileOut that FontSet for later use.	Use Lovely installAsTextStyle to make all sizes available in a TextStyle		named #Lovely in the TextConstants dictionary.	Use ctrl-k in any text pane to select the new Lovely style for that paragraph.	Then use cmd-1 through 5 or cmd-k to set the point-size for any selection.!!FontSet class methodsFor: 'as yet unclassified' stamp: 'di 1/13/1999 12:10'!installAsTextStyle   "HelveticaB installAsTextStyle"	(TextConstants includesKey: self name) ifTrue:		[(self confirm: self name , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	TextConstants at: self name put:		(TextStyle fontArray:			((self class selectors select: [:s | s beginsWith: 'size']) asSortedCollection				collect: [:sizeName | self perform: sizeName]))! !!Form methodsFor: 'copying' stamp: 'ar 11/25/1998 18:33'!asFormOfDepth: d	| newForm |	d = depth ifTrue:[^self].	newForm _ Form extent: self extent depth: d.	(BitBlt toForm: newForm)		colorMap: (self colormapIfNeededForDepth: d);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	^newForm! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."	^ self! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:48'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:49'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!anyShapeFill	"Fill the interior of the outtermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape: to paint a solid color.  See also convexShapeFill:"	| shape |	shape _ (self findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'di 6/11/1998 21:38'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'scaling, rotation' stamp: 'di 8/17/1998 22:17'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: self boundingBox by: scale			smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:04'!peripheralColor  "Form fromUser peripheralColor"	"Return the dominant color as sampled at four corners"	^ (self boundingBox innerCorners collect:		[:p | self colorAt: p]) asBag sortedCounts first value! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!primCountBits	"Count the non-zero pixels of this form."	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this form into the valueTable, which is	a bitmap similar to a color map.  Since the underlying BitBlt function	that performs the tally does not do bit-boundary clipping, the	tallies for any word-boundary fringes must be subtracted."	self tallyPixelValuesPrimitive: destRect into: valueTable.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:37'!tallyPixelValuesPrimitive: destRect into: valueTable	"Tally the selected pixels of this form into valueTable, a Bitmap similar to a color map, and return valueTable. Since the BitBlt function that performs the tally does not do bit-boundary clipping, the tallies for any word-boundary fringes must be subtracted by the sender."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		colorMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 01:00'!trimToPixelValue: pv orNot: not	"Return the smallest part of me that includes all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	^ self copy: (self innerPixelRectFor: pv orNot: not)"Try this to select all but the background...Form fromUser in: [:f |(f trimToPixelValue: (f peripheralColor pixelValueForDepth: f depth) orNot: true) display]Or this to select whatever is black...Form fromUser in: [:f |(f trimToPixelValue: (Color black pixelValueForDepth: f depth) orNot: false) display]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits _ ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:30'!writeUncompressedOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'private' stamp: 'ar 10/9/1998 23:47'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	self bitsSize = bitmap size ifFalse:[^self error:'Bad dimensions'].	bits _ bitmap! !!Form methodsFor: 'other' stamp: 'di 11/11/1998 13:17'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!Form methodsFor: 'as yet unclassified' stamp: 'di 7/8/1998 12:18'!baldMountainWorkspace"   -- Reset player, do this, then play -- 	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 2 do:		[:i | file position: i-1*153613+1.		ff readFrom: file.		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		Sensor yellowButtonPressed ifTrue: [^ file close]].	file close] -- Async version -- |  file ff byteCount nFrames bytesRead di |	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	byteCount _ ff bits size * 4.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: 1+13 count: byteCount.	1 to: nFrames by: (di_1) do:		[:i |		file waitForCompletion.		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		Sensor anyButtonPressed ifTrue: [^ file close].		(i+di) <= nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: (i-1+di)*(byteCount+13)+1+13 count: byteCount].		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		].	file close.	waitTime	| ps zps f32 f16 |	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		f32 _ Form fromFile: (FileStream oldFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps bmps:Bald' , zps , '.BMP').		f32 displayAt: 0@0.		f16 _ Form extent: f32 extent depth: 16.		f32 displayOn: f16 at: 0@0.		f16 displayAt: 330@0.		Transcript cr; show: i printString.		f16 writeUncompressedOnFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form'.		Sensor anyButtonPressed ifTrue: [^ nil]]	| ps zps  file |	file _ FileStream newFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fpsAll338.forms'.	file binary.	file nextPut: 2.	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form') display; writeUncompressedOn: file.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close	-- convert .forms file to .movie format --	|  out ps zps ff |	out _ FileStream newFileNamed: 'Bald2minAt10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 338) , (6 to: 32)		do: [:i | out nextInt32Put: i].			1 to: 1203 by: 1 do:		[:i | i printString displayAt: 400@0.		ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'BackStreet HD:Bald Mt Disk:Bald2 10fps Proc:Bald10.' , zps) 			displayOn: ff.		ff display; writeOnMovie: out].	out close.	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 1 do:		[:i | ff  readFrom: file.		ff display.		Sensor anyButtonPressed ifTrue: [^ file close]].	file close]	|  file ff byteCount nFrames filePosition bytesRead waitTime t |Array with: (Time millisecondsToRun: [	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	waitTime _ 0.	byteCount _ ff bits size * 4.	filePosition _ 1.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount.	1 to: nFrames by: 1 do:		[:i |		t _ Time millisecondClockValue.		file waitForCompletion.		waitTime _ waitTime + (Time millisecondClockValue - t).		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		filePosition _ filePosition+13 + bytesRead.		Sensor anyButtonPressed ifTrue: [^ file close].		i < nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount].		ff display].	file close])	with: waitTime (18400 9798 ) | ff | ff _ Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald00338.form'. Time millisecondsToRun: [1 to: 100 do: [:i | ff display]] 100000//1359 73Try out on-the-fly pixel doubling [dummied for timing]... | file f1 f2 f2a pixMap bb1 bb2 |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	f1 _ Form extent: 320@240 depth: 16.	f2 _ Form extent: 640@480 depth: 16.	f2a _ Form extent: 320@480 depth: 32.	f2a bits: f2 bits.	pixMap _ Bitmap new: 32768.	1 to: 32768 do: [:i | pixMap at: i put: (i bitOr: (i bitShift: 16))].	bb1 _ BitBlt destForm: f2a sourceForm: f1 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 320@1 clipRect: f2a boundingBox.	bb1 colorMap: pixMap.	bb2 _ BitBlt destForm: f2 sourceForm: f2 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 640@1 clipRect: f2 boundingBox.	1 to: 338 by: 1 do:		[:i | f1  readFrom: file.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		0 to: 239 do:			[:j |			bb1 sourceY: j; destY: j*2; copyBits.			bb2 sourceY: j*2; destY: j*2+1; copyBits].		f2 display.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close] 104512 53247 39812 338000.0/ 53247 6.34777546152835 6 6"! !!Form class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 23:44'!extent: extentPoint depth: bitsPerPixel bits: aBitmap	"Answer an instance of me with blank bitmap of the given dimensions and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel bits: aBitmap! !!Form class methodsFor: 'instance creation' stamp: 'jm 1/11/1999 10:43'!fromBinaryStream: aBinaryStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."	| firstByte |	firstByte _ aBinaryStream next.	firstByte = 1 ifTrue: [		"old Squeakform format"		^ self new readFromOldFormat: aBinaryStream].	firstByte = 2 ifTrue: [		"new Squeak form format"		^ self new readFrom: aBinaryStream].	firstByte = $B asciiValue ifTrue: [		"BMP format"		aBinaryStream skip: - 1.		^ self fromBMPFile: aBinaryStream].	"Try for JPG, GIF, or PCX..."	"Note: The following call closes the stream."	^ Smalltalk imageReaderClass formFromStream: aBinaryStream! !!Form class methodsFor: 'instance creation' stamp: 'jm 1/11/1999 10:42'!fromFileNamed: fileName	"Read a Form or ColorForm from the given file."	| file form |	file _ (FileStream readOnlyFileNamed: fileName) binary.	form _ self fromBinaryStream: file.	file close.	^ form! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!blendAlpha	"Answer the integer denoting BitBlt's blend-with-constant-alpha rule."	^ 30! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!paintAlpha	"Answer the integer denoting BitBlt's paint-with-constant-alpha rule."	^ 31! !!Form class methodsFor: 'BMP file reading' stamp: 'jm 1/12/1999 17:31'!bmpColorsFrom: aBinaryStream count: colorCount depth: depth	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| maxLevel colors b g r |	colorCount = 0 ifTrue: [  "this BMP file does not have a color map"		"default monochrome color map"		depth = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel _ (2 raisedTo: depth) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	colors _ Array new: (2 raisedTo: depth).	1 to: colorCount do: [:i |		b _ aBinaryStream next.		g _ aBinaryStream next.		r _ aBinaryStream next.		aBinaryStream skip: 1.		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!Form class methodsFor: 'BMP file reading' stamp: 'jm 1/12/1999 17:37'!fromBMPFile: aBinaryStream	"Read a BMP format image from the given binary stream."	"Form fromBMPFile:		(HTTPSocket			httpGet: 'http://anHTTPServer/squeak/squeakers.bmp'			accept: 'image/bmp')"	| fType fSize reserved pixDataStart hdrSize w h planes d      compressed colorCount colors colorForm |	(aBinaryStream isMemberOf: String) ifTrue: [^ nil].  "a network error message"	aBinaryStream binary.	fType _ aBinaryStream nextLittleEndianNumber: 2.	fSize _ aBinaryStream nextLittleEndianNumber: 4.	reserved _ aBinaryStream nextLittleEndianNumber: 4.	pixDataStart _ aBinaryStream nextLittleEndianNumber: 4.	hdrSize _ aBinaryStream nextLittleEndianNumber: 4.	w _ aBinaryStream nextLittleEndianNumber: 4.	h _ aBinaryStream nextLittleEndianNumber: 4.	planes _ aBinaryStream nextLittleEndianNumber: 2.	d _ aBinaryStream nextLittleEndianNumber: 2.	compressed _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biSizeImage"	aBinaryStream nextLittleEndianNumber: 4.  "biXPelsPerMeter"	aBinaryStream nextLittleEndianNumber: 4.  "biYPelsPerMeter"	colorCount _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biClrImportant"	((fType = 19778) & (reserved = 0) & (planes = 1) &	 (hdrSize = 40) & (fSize <= aBinaryStream size))		ifFalse: [self error: 'Bad BMP file header'].	compressed = 0		ifFalse: [self error: 'Can only read uncompressed BMP files'].	d = 24 ifTrue: [		aBinaryStream position: pixDataStart.		^ self bmp24BitPixelDataFrom: aBinaryStream width: w height: h].	"read the color map"	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	colorCount _ (pixDataStart - 54) // 4.	colors _ self bmpColorsFrom: aBinaryStream count: colorCount depth: d.	"read the pixel data"	aBinaryStream position: pixDataStart.	colorForm _ self bmpPixelDataFrom: aBinaryStream width: w height: h depth: d.	colorForm colors: colors.	^ colorForm! !Note that when shadowDrawing is true, shadowStipple may be either a color, for a solid shadow of the given color, or it may be a stipple used to simulate gray shading when the display cannot support alpha blending.!!FormCanvas methodsFor: 'drawing' stamp: 'di 6/26/1998 15:09'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: 0@0.! !!FormCanvas methodsFor: 'drawing' stamp: 'di 1/4/1999 00:17'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC borderRule |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [fillC == nil ifTrue: [^ self].  "both border and fill are transparent"				borderC _ nil.				rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor.				borderRule _ self drawRule: Form over color: borderColor].	port combinationRule: (self drawRule: Form over color: c).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC		borderRule: borderRule.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:33'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'di 1/3/1999 22:42'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"draw the border of the rectangle"	borderColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: borderColor).		(r area > 10000 or: [fillColor isTranslucent])			ifTrue: [port frameRect: (r translateBy: origin)						borderWidth: borderWidth						borderColor: (self drawColor: borderColor)]			ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle						than to compute and fill the border rects"					port fillRect: r						color: (self drawColor: borderColor)						offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: fillColor).		port fillRect: (r insetBy: borderWidth)			color: (self drawColor: fillColor)			offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/3/1998 14:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		port fillColor: (self drawColor: bottomRightColor);			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing' stamp: 'di 1/3/1999 21:17'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	shadowDrawing		ifTrue: [port colorMap: (Color maskingMap: aForm depth);					fillColor: shadowStipple]		ifFalse: [port colorMap: (aForm colormapIfNeededForDepth: form depth);					fillColor: nil].	port image: aForm at: aPoint + origin sourceRect: sourceRect		rule: (self drawRule: rule color: Color black)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint color: Color black);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over color: c);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'di 10/5/1998 09:32'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c) background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil])		ignoreColorChanges: shadowDrawing.	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'di 12/31/1998 13:20'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	port colorMap: (Color maskingMap: stencilForm depth).	port stencil: stencilForm		at: aPoint + origin		fillColor: (self drawColor: aColor)		rule: (self drawRule: Form paint color: aColor)! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'other' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^(BalloonCanvas on: form) setOrigin: origin clipRect: clipRect! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 15:30'!drawColor: aColor	^ shadowDrawing		ifTrue: [shadowStipple]		ifFalse: [aColor]! !!FormCanvas methodsFor: 'private' stamp: 'di 1/4/1999 00:57'!drawRule: someRule color: color	"Answer the BitBlt combination rule for the given default rule and color."	shadowDrawing		ifTrue:		[form depth < 16 ifTrue: [^ Form paint].  "Stipple merge in non-RGB"		form depth = 16 ifTrue:			[(shadowStipple isColor and: [shadowStipple isTranslucent]) ifFalse:				[^ Form paint  "no translucency"].			port alphaBits: shadowStipple privateAlpha.  "Simple alpha in 16 bits"			someRule = Form paint ifTrue: [^ Form paintAlpha]								ifFalse: [^ Form blendAlpha]].		^ Form blend  "Real alpha blend in 32 bits"]		ifFalse:		[form depth < 16 ifTrue: [^ someRule  "no RGB"].		(color isColor and: [color isTranslucent]) ifFalse: [^ someRule  "no translucency"].		form depth = 16 ifTrue:			[port alphaBits: color privateAlpha.  "Simple alpha in 16 bits"			someRule = Form paint ifTrue: [^ Form paintAlpha]								ifFalse: [^ Form blendAlpha]].		^ Form blend  "Real alpha blend in 32 bits"]! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 12:54'!setForm: aForm	self reset.	form _ aForm.	port _ GrafPort toForm: form.! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:40'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 20:46'!setShadowDrawing	| screen blackWord |	shadowDrawing _ true.	"Build a 50% stipple of black for the given depth."	form depth >= 16		ifTrue: [shadowStipple _ Color black alpha: 0.5]		ifFalse: [screen _ Color pixelScreenForDepth: form depth.				blackWord _ Color black pixelWordForDepth: form depth.				shadowStipple _ (screen collect: [:maskWord | maskWord bitAnd: blackWord])]! !!FormCanvas methodsFor: 'private' stamp: 'di 10/2/1998 22:27'!stipple	^ shadowStipple! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:41'!stipple: newStipple	shadowStipple _ newStipple.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:46'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:11'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: Color white.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:14'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: Color white.	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: Color red.	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.	canvas point: 100@100 color: Color black.	canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.	canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.	canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.	canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.	canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.	canvas showAt: 0@0.! !!FormEditor class methodsFor: 'private' stamp: 'di 9/12/1998 12:28'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder _ 2.	formView _ FormHolderView new model: aForm.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView _ View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView _ StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !an input instance for a form.  A form takes its input from a collection of FormInputs; each FormInput has a name and can retrieve a textual value.  WHen a form is submitted, these name-value associations are gathered together and passed to an HTTP server.!!FormInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^false! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:11'!active	"whether this input is currently providing an input"	^true! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!name	"name associated with this input"	^self subclassResponsibility! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!reset	"reset to a default value"	! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!value	"value associated with this input"	^self subclassResponsibility! !Holds the inputs for an instance of an HTML Form.  It has a link to the browser it will be displayed in, and it has a link to each of the input PluggableTextMorph's that it input will read from.inputs - maps HtmlInput's into the text morphs which will input their value.!!FormInputSet methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 03:57'!form: f  browser: b	inputs _ OrderedCollection new.	form _ f.	browser _ b.! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/5/1998 03:57'!addInput: anInput	inputs add: anInput! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/11/1998 03:30'!inputs	"return a list of the list of inputs"	^inputs! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/5/1998 03:58'!reset	"reset all inputs to their default value"	inputs do: [ :input | input reset ]! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/11/1998 20:11'!submit	"collect inputs and instruct the browser to do a submission"	| inputValues |	inputValues _ Dictionary new.	inputs do: [ :input |		input active ifTrue: [			(inputValues includesKey: input name) ifFalse: [				inputValues at: input name  put: (OrderedCollection new: 1) ].			(inputValues at: input name)  add: input value ] ].	browser submitFormWithInputs: inputValues  url: form url method: form method.	^true! !!FormInputSet class methodsFor: 'instance creation' stamp: 'ls 7/16/1998 22:01'!forForm: form  andBrowser: browser	"create a FormData for the given form and browser"	^super new form: form  browser: browser! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale _ self insetDisplayBox extent / model selection extent.	scale _ (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:57'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:56'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormView class methodsFor: 'examples' stamp: 'di 9/12/1998 10:17'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 _ numerator gcd: aNumber denominator.		d2 _ denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d _ denominator gcd: aNumber denominator.		n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).		d1 _ d1 * d2.		n _ n // (d2 _ n gcd: d).		(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction ifTrue:		[^ self + aNumber negated].	^ aNumber adaptToFraction: self andSend: #-! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal].	^ aNumber adaptToFraction: self andSend: #/! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [aNumber numerator = 0				ifTrue: [^ numerator = 0]				ifFalse: [^ aNumber numerator = numerator 							and: [aNumber denominator = denominator]]].	^ aNumber adaptToFraction: self andSend: #=! !!Fraction methodsFor: 'converting' stamp: 'di 11/6/1998 13:10'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Fraction."	^ rcvr asFraction perform: selector with: self! !a reference to a file which may be downloaded by anonymous ftp!!FtpUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 01:24'!retrieveContents	| server contents pathString listing |	"currently assumes directories end in /, and things that don't end in / are files.  Also, doesn't handle errors real well...."	server _ ServerDirectory new.	server server: self authority.	server directory: '/'.	server user: 'anonymous'.	server password: 'SqueakUser'.	pathString _ self pathString.	pathString _ pathString copyFrom: 2 to: pathString size. "remove the leading /"	self path last size = 0 ifFalse: [		"a file"		contents _ (server getFileNamed: pathString).		(contents respondsTo: #contents) ifTrue: [ 			"the file exists--return it"			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents contents ]		ifFalse: [			"some error"			^nil ]. ].	"a directory?"	server directory: self pathString.	listing _ String streamContents: [ :stream |		stream nextPutAll: '<title>', self pathString, '</title>'; cr.		stream nextPutAll: '<h1>Listing for ', self pathString, '</h1>'; cr.		stream nextPutAll: '<ul>'; cr.		server entries do: [ :entry |			stream nextPutAll: '<li>';				nextPutAll: '<a href="', entry name encodeForHTTP.			entry isDirectory ifTrue: [ stream nextPut: $/ ].			stream nextPutAll: '">';				nextPutAll: entry name;				nextPutAll: '</a>';				cr ] ].	^MIMEDocument contentType: 'text/html' content: listing! !!FtpUrl methodsFor: 'access' stamp: 'ls 7/24/1998 00:18'!pathString	self path isEmpty ifTrue: [ ^'/' copy ].	^String streamContents: [ :s |		self path do: [ :p |		 	s nextPut: $/.			s nextPutAll: p ] ]! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !This class can be used to read from Gnu Zip (GZIP) compressed streams. For more information see the file "algorithm.doc" from the Gnu Zip source distribution.!!GZipStream methodsFor: 'initialize' stamp: 'ar 12/4/1998 00:07'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the GZIP stream."	| method magic flags length |	super on: aCollection from: firstIndex to: lastIndex.	magic _ self nextBits: 16.	(magic = GZipMagic) 		ifFalse:[^self error:'Not a GZipped stream'].	method _ self nextBits: 8.	(method = GZipDeflated)		ifFalse:[^self error:'Bad compression method'].	flags _ self nextBits: 8.	(flags anyMask: GZipEncryptFlag) 		ifTrue:[^self error:'Cannot decompress encrypted stream'].	(flags anyMask: GZipReservedFlags)		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].	"Ignore stamp, extra flags, OS type"	self nextBits: 16; nextBits: 16. "stamp"	self nextBits: 8. "extra flags"	self nextBits: 8. "OS type"	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"		ifTrue:[self nextBits: 16]. 	(flags anyMask: GZipExtraField) "Extra fields - ignored"		ifTrue:[	length _ self nextBits: 16.				1 to: length do:[:i| self nextBits: 8]].	(flags anyMask: GZipNameFlag) "Original file name - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].	(flags anyMask: GZipCommentFlag) "Comment - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].! !!GZipStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 00:12'!initialize	"GZipStream initialize"	GZipMagic _ 16r8B1F.		"GZIP magic number"	GZipDeflated _ 8.		"Compression method"	GZipAsciiFlag _ 16r01.		"Contents is ASCII"	GZipContinueFlag _ 16r02.	"Part of a multi-part archive"	GZipExtraField _ 16r04.		"Archive has extra fields"	GZipNameFlag _ 16r08.		"Archive has original file name"	GZipCommentFlag _ 16r10.	"Archive has comment"	GZipEncryptFlag _ 16r20.		"Archive is encrypted"	GZipReservedFlags _ 16rC0.	"Reserved" ! !a URL type that can't be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.!!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ self error: 'opaque URL with no scheme--shouldn''t happen!!'. ].	locator _ aString copyFrom: (schemeName size+2) to: aString size.! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString relativeTo: aUrl	schemeName _ aUrl schemeName.	locator _ aString.! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!locator	^locator! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!schemeName	^schemeName! !!GenericUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName0  locator: locator0	schemeName _ schemeName0.	locator _ locator0.! !!GenericUrl methodsFor: 'printing' stamp: 'ls 8/4/1998 02:41'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self locator.	self fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: self fragment ].	^s contents! !!GenericUrl class methodsFor: 'parsing' stamp: 'ls 7/26/1998 21:24'!absoluteFromText: aString	| schemeName locator |	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].	locator _ aString copyFrom: (schemeName size + 2) to: aString size.	^self schemeName: schemeName locator: locator! !!GenericUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName  locator: locator	^self new schemeName: schemeName  locator: locator! !!GradientFillMorph methodsFor: 'drawing' stamp: 'jm 6/1/1998 19:24'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorArrayForDepth: aCanvas depth.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'all' stamp: 'di 1/3/1999 12:24'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	(color isColor and: [color isTranslucentColor]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 isTranslucentColor]) ifTrue: [^ true].	^ false! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:10'!colorRamp	^colorRamp! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:00'!colorRamp: anArray	colorRamp _ anArray.	pixelRamp _ nil.! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:07'!pixelRamp	^pixelRamp ifNil:[pixelRamp _ self computePixelRampOfSize: 256].! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!pixelRamp: aBitmap	pixelRamp _ aBitmap! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!radial	^radial! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:11'!radial: aBoolean	radial _ aBoolean! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isGradientFill	^true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:13'!isRadialFill	^radial == true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isSolidFill	^false! !!GradientFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 14:07'!asColor	^colorRamp first value! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 14:09'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta color lastValue ramp |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		lastIndex+1 to: nextIndex do:[:i|			theta _ (i - lastIndex) asFloat / distance asFloat.			color _ nextColor mixed: theta with: lastColor.			bits at: i put: (color pixelWordForDepth: 32).		].		lastIndex _ nextIndex.		lastColor _ nextColor.	].	lastValue _ lastColor pixelWordForDepth: 32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 16:56'!display	| f ramp |	ramp _ self pixelRamp.	f _ Form extent: ramp size @ 1 depth: 32 bits: ramp.	1 to: 100 do:[:i| f displayAt: 1@i].	[Sensor anyButtonPressed] whileFalse.	[Sensor anyButtonPressed] whileTrue.! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/9/1998 14:05'!ramp: colorRamp	^self new colorRamp: colorRamp! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/10/1998 19:13'!sample	"GradientFill sample"	^(self ramp: { 0.0 -> Color red. 0.5 -> Color green. 1.0 -> Color blue})		origin: 300 @ 300;		direction: 400@0;		normal: 0@400;		radial: true;	yourself! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 20:48'!alpha: a	"Internal alpha is BitBlt's 0-255"	self alphaBits: (255.0*a) asInteger! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 20:44'!alphaBits: a	alpha _ a! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 13:08'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!GrafPort methodsFor: 'all' stamp: 'di 1/4/1999 00:36'!displayScannerFor: para foreground: foreColor background: backColor		rule: rule halftone: halftone ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setDestForm: destForm sourceForm: destForm			fillColor: halftone combinationRule: rule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect;		alphaBits: alpha! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:55'!fillColor: aColorOrPattern	aColorOrPattern == lastColor ifTrue: [^ self].	super fillColor: aColorOrPattern.	lastColor _ aColorOrPattern.! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 23:49'!fillOval: rect color: fillColor borderWidth: borderWidth borderColor: borderColor	"Possible future optimizations:	 Compute an inset rectangle - if clipRect inside, then just paint with fillCOlor!!	 Note quadrants of clipRect, and only run code for those quadrants."	"NOTE: for some reason this crashes (!!) using the direct calls to copyBitsTranslucent.		There may be some sort of stack balance problem there."	| wp fillTone w borderTone centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dxs dx prevLeft left translucent borderAlpha |	rect area <= 0 ifTrue: [^ self].	translucent _ combinationRule >= 30 and: [combinationRule <= 31].	(translucent and: [borderColor isColor])		ifTrue: [borderAlpha _ borderColor privateAlpha]		ifFalse: [borderAlpha _ 255].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	fillColor == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: fillColor.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			"translucent" false			ifTrue: [self copyBitsTranslucent: alpha.					(dy = 0 and: [centerYBias = 0]) ifFalse:						["avoid double display for translucency"						destY _ centerY + dy.						self copyBitsTranslucent: alpha]]			ifFalse: [self copyBits.					(dy = 0 and: [centerYBias = 0]) ifFalse:						["avoid double display for translucency"						destY _ centerY + dy.						self copyBits]]]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	(translucent and: [borderColor isColor])		ifTrue: [alpha _ borderColor privateAlpha]		ifFalse: [alpha _ 255].	prevLeft _ centerX.	maxy to: 0 by: -1 do: [:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		"translucent" false		ifTrue: [self copyBitsTranslucent: borderAlpha.				destX _ centerX + dx + 1 - width.				self copyBitsTranslucent: borderAlpha.				destY _ centerY + dy - height + 1.				self copyBitsTranslucent: borderAlpha.				destX _ left.				self copyBitsTranslucent: borderAlpha.				prevLeft _ left]		ifFalse: [self copyBits.				destX _ centerX + dx + 1 - width.				self copyBits.				destY _ centerY + dy - height + 1.				self copyBits.				destX _ left.				self copyBits.				prevLeft _ left]].! !!GrafPort methodsFor: 'all' stamp: 'di 1/4/1999 00:16'!fillOval: rect color: fillColor borderWidth: borderWidth borderColor: borderColor borderRule: borderRule	"Possible future optimizations:	 Compute an inset rectangle - if clipRect inside, then just paint with fillCOlor!!	 Note quadrants of clipRect, and only run code for those quadrants."	"NOTE: for some reason this crashes (!!) using the direct calls to copyBitsTranslucent.		There may be some sort of stack balance problem there."	| wp fillTone w borderTone centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dxs dx prevLeft left |	rect area <= 0 ifTrue: [^ self].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	fillColor == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: fillColor.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			self copyBits.			(dy = 0 and: [centerYBias = 0]) ifFalse:				["avoid double display for translucency"				destY _ centerY + dy.				self copyBits]]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	combinationRule _ borderRule.	borderColor isColor		ifTrue: [alpha _ borderColor privateAlpha]		ifFalse: [alpha _ 255].	prevLeft _ centerX.	maxy to: 0 by: -1 do: [:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		self copyBits.		destX _ centerX + dx + 1 - width.		self copyBits.		destY _ centerY + dy - height + 1.		self copyBits.		destX _ left.		self copyBits.		prevLeft _ left].! !!GrafPort methodsFor: 'all' stamp: 'sw 8/5/1998 12:10'!fillRect: rect color: fillColor offset: aPoint	fillColor class == InfiniteForm ifTrue: 		[self fillColor: nil.		fillColor displayOnPort: ((self clippedBy: (rect translateBy: aPoint)) colorMap: nil) at: aPoint.		^ self].	sourceForm _ nil.	self fillColor: fillColor.	destX _ rect left + aPoint x.	destY _ rect top + aPoint y.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:36'!frameRectBottom: rect height: h	sourceForm _ nil.	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:35'!frameRectRight: rect width: w	sourceForm _ nil.	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 13:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule_ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!GrafPort methodsFor: 'all' stamp: 'di 12/31/1998 14:31'!stencil: stencilForm at: aPoint fillColor: aColor rule: rule	"Paint using aColor wherever stencilForm has non-zero pixels, and using the given combination rule"	self sourceForm: stencilForm;		fillColor: aColor;		combinationRule: rule;		destOrigin: aPoint;		sourceRect: stencilForm boundingBox.	self copyBits! !!GraphMorph methodsFor: 'initialization' stamp: 'jm 7/8/1998 20:31'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'script support' stamp: 'jm 1/14/1999 10:45'!readDataFromFile	| fileName |	fileName _ FillInTheBlank		request: 'File name?'		initialAnswer: ''.	fileName isEmpty ifTrue: [^ self].	(StandardFileStream isAFileNamed: fileName) ifFalse: [		^ self inform: 'Sorry, I cannot find that file'].	data _ (SampledSound fromAIFFfileNamed: fileName) samples.	self flushCachedForm.! !!GraphMorph methodsFor: 'private' stamp: 'jm 7/8/1998 20:32'!drawPointerOn: aCanvas	| ptr x r c |	ptr _ (cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!HTMLformatter methodsFor: 'formatting' stamp: 'ls 4/18/98 16:46'!format: requestObject	"format text with requestObject as the argument forthe code blocks"	^String streamContents: [ :stream |	formattingBlock value: requestObject value: stream ]! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'ls 4/18/98 13:23'!formattingBlock: aBlock	formattingBlock _ aBlock! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'mjg 8/28/199820:56'!initialize	specialCharacter = $*.! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/28/1998 21:03'!rangesOfAngleBrackets: sourceStrm	"Return an OrderedCollection of intervals of position within anglebrackets < and >.  Caller wants to avoid putting <br> in there."	| list char intervals start |	list _ OrderedCollection new: 10.	[sourceStrm atEnd] whileFalse: [		(char _ sourceStrm next) == $< ifTrue: [list add:sourceStrm position].	"a start"		char == $> ifTrue: [list add: sourceStrm positionnegated]].	"an end"	sourceStrm reset.	intervals _ OrderedCollection new: 10.	start _ nil.	list do: [:each |		(each > 0) & (start == nil) ifTrue: [start _ each].		(each < 0) & (start ~~ nil) ifTrue: [			intervals add: (start to: each negated). start _ nil]].	^ intervals"	HTMLformatter rangesOfAngleBrackets: (ReadStream on: '1234 <good><456 <good> 567> <ok>')	"! !!HTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:08'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1. ]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>'; cr.]]].	^targetStream contents.! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:00'!specialCharacter	^specialCharacter! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:01'!specialCharacter: someCharacter	specialCharacter _ someCharacter! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:23'!evalEmbedded: stringOrStream with: request	| formatter |	formatter _self forEvaluatingEmbedded: stringOrStream.	^formatter format: request! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 6/3/98 10:29'!fixForIE: text	| ch targetStream sourceStream |	targetStream := WriteStream on: String new.	sourceStream := ReadStream on: text.	[sourceStream atEnd] whileFalse:	[ch := sourceStream next.	ch = $> ifTrue: [targetStream nextPutAll: '&gt;']	ifFalse: [ch = $< ifTrue: [targetStream nextPutAll: '&lt;']		ifFalse: [targetStream nextPut: ch]].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 7/15/1998 12:02'!forEvaluatingEmbedded: stringOrStream	"stringOrStream is text with <?expr?> expressions intermingled.This creates a HTLMLformatter instance which will substitute the <?expr?>expressions with the value of the argument (named request), and whichleaves all other text in stringOrStream alone"	| blockStream sourceStream doingEval ch |	blockStream _ WriteStream on: String new. 	blockStream nextPutAll: '[ :request :output | output nextPutAll: '''.	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	doingEval _ false.	[sourceStream atEnd] whileFalse:  [		ch := sourceStream next.		(doingEval not and: [ ch = $<  and: [ sourceStream peek =$? ]]) ifTrue: [			"beginning of an <?...?> expression"			blockStream nextPutAll: '''.  output nextPutAll: ['.			sourceStream next.  "Skip the ?"			doingEval _ true]		ifFalse: [		(doingEval and: [ ch = $? and: [ sourceStream peek = $> ]])ifTrue: [			"end of a <?...?> expression"			blockStream nextPutAll: '] value asString.  outputnextPutAll: '''.			sourceStream next.  "Skip the >"			doingEval _ false.]		ifFalse: [			"normal char"			blockStream nextPut: ch.			(doingEval not and: [ ch = $' ]) ifTrue: [				 "double $' marks"  blockStream nextPut: $'] ] ] ].	"end the block"	doingEval		ifTrue: [ blockStream nextPutAll: '] value asString' ]		ifFalse: [ blockStream nextPutAll: '''' ].	blockStream nextPutAll: ']'.	^HTMLformatter new formattingBlock: (Compiler evaluate: blockStreamcontents)! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:38'!oldEvalEmbedded: stringOrStream with: request	| sourceStream targetStreamevalStream currentStream evalValue peekValue ch |	(stringOrStreamisKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	targetStream := WriteStream on: String new.	currentStream :=targetStream. 	[sourceStream atEnd] whileFalse: 		[ch :=sourceStream next.		ch = $< ifTrue:			[peekValue := sourceStream peek. (peekValue = $?) ifTrue:		[evalStream := WriteStream on: String new.		currentStream := evalStream.	sourceStream next. "Eat the ?"				ch :=sourceStream next.]].		((currentStream = evalStream) and: [ch =$?]) ifTrue:			[ peekValue := sourceStream peek.(peekValue = $>) ifTrue:				[sourceStream next."Eat the >"				currentStream := targetStream.			evalValue := (Compiler new evaluate: (evalStreamcontents) 					in: thisContext to: selfnotifying: nil ifFail: [^nil]).				(evalValueisKindOf: String)				ifFalse: [evalValue :=evalValue printString].				currentStreamnextPutAll: evalValue.]]			ifFalse: [currentStreamnextPut: ch].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 9/3/1998 16:58'!swikify: aStringOrStream linkhandler: aBlock	| formatter |	formatter _ self new.	formatter specialCharacter: $*.	^formatter swikify: aStringOrStream linkhandler: aBlock! !!HTMLformatter class methodsFor: 'formatting' stamp: 'pm 6/6/1998 21:39'!textAreaStart: fieldName rows: rows cols: cols       ^ '<TEXTAREA NAME="', fieldName, '" ROWS=',rows,' COLS=',cols,'>' ! !HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'all' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type _ self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type _ type withBlanksTrimmed.	i _ type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 11:39'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 12:24'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response _ RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf _ String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifTrue: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'tk 12/14/1998 21:43'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response size). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	"Transcript cr; show: 'data byte count: ', response position printString."	"Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed'])."	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail _ aRequest! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'msk 9/28/1998 15:51'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxyServer _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 10/4/97 16:11'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder _ doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!HTTPSocket class methodsFor: 'get the page' stamp: 'di 5/6/1998 16:40'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ls 9/15/1998 23:57'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGet: url  args: nil accept: mimeType! !!HTTPSocket class methodsFor: 'get the page' stamp: 'jm 9/16/1998 10:31'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:25'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url args: nil accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 17:48'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	^ self httpGetDocument: url args: args accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 12/16/1998 08:13'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, self argString: args ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; cr; show: url.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tao 10/26/97 23:21'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc _ self httpGet: url.	doc binary; reset.	(ggg _ Smalltalk jpegReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:27'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:27'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^ self httpPostDocument: url args: argsDict accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 12/14/1998 21:42'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 5/4/1998 17:00'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc _ (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc _ 'The server does not seem to be responding']."	doc class == String ifTrue: [text _ doc] ifFalse: [text _ doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'di 9/15/1998 08:22'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens image |	nameTokens _ url findTokens: '/'.	image _ self httpGif: url.	World ifNil: [FormView open: image named: nameTokens last]		ifNotNil: [World addMorph: (SketchMorph new form: image)]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tao 10/26/97 23:21'!httpShowJpeg: url	"Display the picture retrieved from the given URL, which is assumed to be a JPEG file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpJpeg: url) named: nameTokens last.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:18'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'msk 9/28/1998 15:52'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxyServer _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 9/22/1998 17:46'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!HTTPSocket class methodsFor: 'magic numbers' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 5/22/1998 16:28'!innerTarget	^ innerTarget! !!HaloMorph methodsFor: 'stepping' stamp: 'di 10/2/1998 13:35'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target renderedMorph fullBoundsInWorld].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:55'!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:28'!addHandles	| box s |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.	self bounds: target renderedMorph fullBoundsInWorld.  "update my size"	box _ (self bounds expandBy: s+1)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color transparent		on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[self addHandleAt: (box rightCenter + (0 @ ((s+2) negated)) min: box rightCenter + box bottomRight // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 12:34'!addHandlesForWorldHalos	| box s |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	s _ self handleSize.	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: target.	self addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: target.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: target)			on: #mouseUp send: #deleteBalloon to: target].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'tk 12/15/1998 14:37'!dismiss	"Remove my target from the world."	| w |	w _ self world.	w ifNotNil: [w stopStepping: target].	self delete.	target abandon.		"includes delete"! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/19/1998 11:46'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world doOneCycle.	menu _ evt hand buildDebugHandleMenuFor: innerTarget.	menu addTitle: innerTarget externalName.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 11:32'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom:		(target pointFromWorld: evt cursorPoint - positionOffset).! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/21/1998 12:25'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	evt hand setArgument: target.	self setTarget: evt hand duplicateMorph.	self removeAllHandlesBut: dupHandle! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 13:58'!doGrow: evt with: growHandle	| newExtent |	newExtent _ (target pointFromWorld: (evt cursorPoint - positionOffset)) - target topLeft.	target extent: (newExtent max: minExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 13:47'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	(degrees abs < 1.0) ifTrue: [degrees _ 0.0].	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	target rotationDegrees: (degrees						detentBy: 10.0						atMultiplesOf: 90.0 snap: false).	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:24'!doScale: evt with: scaleHandle	"Update the scale of my target if it is scalable."	| newExtent newHandlePos |	newHandlePos _ evt cursorPoint - (scaleHandle extent // 2).	newExtent _ (target pointFromWorld: newHandlePos) - target center * 2.	target scaleToFit: ((newExtent max: minExtent) min: Display extent).	target scale = 1.0		ifTrue: [scaleHandle color: Color yellow]		ifFalse: [scaleHandle color: Color orange].	scaleHandle position: newHandlePos.	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:54'!handleSize	^ 16! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 12:30'!maybeDoDup: evt with: dupHandle	^ target okayToDuplicate ifTrue:		[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 12:07'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - target positionInWorld.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 14:01'!startGrow: evt with: growHandle	"Initialize resizing of my target."	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	positionOffset _ evt cursorPoint - (target pointInWorld: target bottomRight).	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 1@1].! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 14:03'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable."	target isFlexMorph ifFalse: [target addFlexShell].	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset _ Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:26'!startScale: evt with: scaleHandle	"Initialize scaling of my target."	target isFlexMorph ifFalse: [target addFlexShell].	growingOrRotating _ true.	self removeAllHandlesBut: scaleHandle.  "remove all other handles"	positionOffset _ 0@0.	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 3@3].! !!HaloMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:37'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].innerTarget _ deepCopier references at: innerTarget ifAbsent: [innerTarget].! !!HaloMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:36'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""innerTarget _ innerTarget.		Weakly copied"positionOffset _ positionOffset veryDeepCopyWith: deepCopier.angleOffset _ angleOffset veryDeepCopyWith: deepCopier.minExtent _ minExtent veryDeepCopyWith: deepCopier.growingOrRotating _ growingOrRotating veryDeepCopyWith: deepCopier.! !!HandMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 12:23'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:45'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds shadowCanvas f1 |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	cachedCanvasHasHoles		ifTrue: ["Have to draw the real shadow of the form"				shadowCanvas image: cacheCanvas form at: subBnds origin]		ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"				(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: subBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:44'!nonCachingFullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	| shadowCanvas shadowForm |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	shadowForm _ self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."	shadowCanvas image: shadowForm at: shadowForm offset.  "draw shadows"	submorphs reverseDo: [:m | m fullDrawOn: aCanvas].  "draw morphs in front of shadows"	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 23:57'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas depth = 1			ifTrue: [aCanvas imageWithOpaqueWhite: savedPatch at: savedPatch offset]			ifFalse: [aCanvas image: savedPatch at: savedPatch offset].		((userInitials size = 0) and:		 [(submorphs size = 0) and:		 [temporaryCursor == nil]]) ifTrue: [			"Make the transition to using hardware cursor. Clear savedPatch and			 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"			savedPatch _ nil]].! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:12'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (FormCanvas extent: bnds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bnds topLeft negated.	submorphs reverseDo: [:m | m fullDrawOn: canvas].  "draw shadows"	^ canvas form offset: bnds topLeft! !!HandMorph methodsFor: 'drawing' stamp: 'di 9/10/1998 16:20'!trailMorph	"You can't draw trails when picked up by the hand."	^ nil! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:45'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| subBnds rectList c |	depth >= 16 ifTrue:		["Check for real translucency -- can't be cached in a form"		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: subBnds extent depth: depth.		c _ cacheCanvas copyOffset: subBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: subBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:48'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:45'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 15:58'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed				ifTrue: [self handleDragOver: evt]				ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:46'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:47'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'sw 11/11/1998 11:00'!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	"[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p]."  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:48'!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: ["Crock: If a menu is proffered with the mouse up						and the user clicks down outside it (as is normal in MVC),						then the menu goes away and nothing else happens."						mouseDownMorph owner deleteIfPopUp.						^ nil]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/5/1998 14:05'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].	lastEvent _ evt.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		lastEvent _ evt.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 6/17/1998 08:57'!updateMouseDownTransform	"To help with, eg, autoscrolling"	mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/15/1998 23:41'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		newOwner _ self dropTargetFor: m event: evt.		newOwner ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		morphToDrop _ newOwner morphToDropFrom: m. 		morphToDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 9/29/1998 09:50'!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto.  Return nil if we must repel the morph.  Return the world, if no other morph wants the dropping morph."	| root coreSample |	root _ nil.	owner submorphsReverseDo: [:m |		((m fullContainsPoint: evt cursorPoint) and:		 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].	root == nil ifTrue: [^ self world].	coreSample _ root morphsAt: evt cursorPoint.	(Preferences allowSysWindowEmbedding not and:		[(aMorph isKindOf: SystemWindow)]) ifTrue: [^ self world].	coreSample do:		[:m |			(m repelsMorph: aMorph event: evt) ifTrue:				[^ nil]].	coreSample do:		[:m |			(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ self world! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/24/1998 14:18'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m pointFromWorld: self position].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/9/1998 15:40'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: self world action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'authoring tools...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:57'!changesDo	"Build the changes menu for the world."	self changesMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 12/2/1998 21:21'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Change management') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: ScreenController new action: #fileOutChanges.	menu balloonTextForLastItem: 'Write the current change set out to a file whose name reflects the change set name and the current date & time.'.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu balloonTextForLastItem: 'Create a new change set and make it the current one.'.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu balloonTextForLastItem: 'Open a message-list browser showing all methods in the current change set'.	menu add: 'check for slips' target: Smalltalk changes action: #lookForSlips.	menu balloonTextForLastItem: 'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu balloonTextForLastItem: 'Open a change sorter that allows you to view one change set at a time.'.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu balloonTextForLastItem: 'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu balloonTextForLastItem: 'Open a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'.	menu add: 'recent change log' action: #openChangesLog.	menu balloonTextForLastItem: 'Open a change-list browser on the latter part of the changes log.'.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	menu balloonTextForLastItem: 'Save a file that, when reloaded, reconstitutes the current World.'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15'!debugDo	"Build the scripting menu for the world."	self debugMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15'!debugMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Debugging...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'inspect model' action: #inspectWorldModel.	menu add: 'start MessageTally' action: #startMessageTally.	menu addLine.	menu add: 'call #tempCommand' action: #callTempCommand.	menu add: 'define #tempCommand' action: #defineTempCommand.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:56'!helpDo	"Build and show the help menu for the world."	self helpMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:51'!helpMenu	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'world menu help' target: self action: #worldMenuHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #absorbUpdatesFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/5/1998 18:04'!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'from a file...' target: self action: #readMorphFromAFile.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self action: #newDrawingFromMenu.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 1/10/1999 09:49'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:16'!openWindow	self openMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17'!remoteDo	self remoteMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17'!remoteMenu	"Build the Telemorphic menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Telemorphic') defaultTarget: self.	menu addStayUpItem.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 13:39'!scriptingDo	self scriptingMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 10:48'!scriptingMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Authoring Tools') defaultTarget: self.	menu addStayUpItem.	menu add: 'standard parts bin' target: self presenter action: #createStandardPartsBin.	menu balloonTextForLastItem: 'A bin of standard parts, from which you can drag out useful morphs.'.	menu add: 'custom parts bin' target: self presenter action: #launchCustomPartsBin.	menu balloonTextForLastItem: 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'.	menu add: 'new scripting area' target: self action: #detachableScriptingSpace.	menu balloonTextForLastItem: 'A window set up for simple scripting.'.	menu add: 'control panel' target: self presenter action: #createControlPanel.	menu balloonTextForLastItem: 'A little panel that lets you choose whether or not things like the showing of balloon help should be enabled or disabled.'.	menu addLine.	menu add: 'unlock locked objects' action: #unlockWorldContents.	menu balloonTextForLastItem: 'If any items on the world desktop are currently locked, unlock them.'.	menu add: 'unhide hidden objects' action: #showHiders.	menu balloonTextForLastItem: 'If any items on the world desktop are currently hidden, make them visible.'.	menu add: 'round up stray objects' action: #roundUpStrayObjects.	menu balloonTextForLastItem: 'If any items on the desktop are currently off-screen (because their coordinates are outside the bounds of the desktop), bring them back within view.'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:18'!windowsDo	"Build the windows menu for the world."	self windowsMenu popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 11:24'!windowsMenu	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Window management') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu add: 'expand all windows' action: #expandAll.	menu add: 'close unchanged windows' action: #closeUnchangedWindows.	menu add: 'delete all non-windows' action: #deleteNonWindows.	menu addLine.	menu add: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])		target: ScreenController new action: #changeWindowPolicy.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:53'!worldMenuHelp	| aList aMenu cnts explanation |	"HandMorph new worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu remoteMenu scriptingMenu windowsMenu) 		with:	#('help' 'changes' 'open' 'debug' 'remote' 'authoring tools' 'windows')do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | ((cnts _ it contents) = 'keep this menu up')					ifFalse: [aList add: (cnts, ' - ', title)]]].	aList _ aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation _ ReadWriteStream on: ''.	aList do:		[:anItem | explanation nextPutAll: anItem; cr].	(StringHolder new contents: explanation contents)		openLabel: 'Where in the world menu is...'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/13/1998 16:16'!absorbUpdatesFromServer	Utilities updateFromServer! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/5/1998 16:53'!browseChangedMessages	Smalltalk browseChangedMessages! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!browsePlayerClass	Browser newOnClass: argument player class label: 'Compiled scripts for ', argument player externalName! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/19/1998 11:54'!buildDebugHandleMenuFor: argMorph	"Build the menu for the given morph's halo's debug handle."	argument _ argMorph.	^ argMorph debuggingMenuFor: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	Preferences noviceMode ifFalse:		[argMorph addDebuggingItemsTo: menu hand: self].	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/16/1998 08:22'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorph].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!changeVariableType	argument ifNotNil:		[argument assuredPlayer changeVariableType]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!chooseNewCostumeForArgument	argument notNil ifTrue:		[argument assuredPlayer newCostume]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/15/1998 07:58'!chooseNewFormForSketchMorph	"Only available when argument is a SketchMorph"	| reply |	reply _ (SelectionMenu selections: Smalltalk imageImports keys asSortedCollection) startUpWithCaption: 'Which element of ImageImports?'.	reply == nil ifTrue: [^ self].	argument form: (Smalltalk imageImports at: reply)! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:33'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self world satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 11:52'!copyToPasteBuffer	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	argument isMorph		ifTrue: [Cursor wait showWhile: 					[argument okayToDuplicate ifTrue:						[PasteBuffer _ argument topRendererOrSelf veryDeepCopy]]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/18/1998 08:44'!defineTempCommand	argument		ifNotNil:			[argument defineTempCommand]		ifNil:			[self world defineTempCommand]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/6/1998 11:27'!deleteNonWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all objectsthat are not in windows?')		ifFalse: [^ self].	self world submorphs copy do:		[:m | (m isKindOf: SystemWindow) ifFalse: [m delete]]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/9/1998 08:38'!detachableScriptingSpace	ScriptingSystem newScriptingSpace openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/21/1998 11:54'!duplicateMorph	| newMorph aName usedNames |	newMorph _ argument veryDeepCopy.	(aName _ argument knownName) ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo:			(Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	self grabMorphFromMenu: newMorph.	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:20'!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:22'!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!inspectArgumentsPlayerInMorphic	self attachMorph: ((Inspector openAsMorphOn: argument player) extent: 300@200)! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!inspectPlayer	argument player inspect! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/22/1998 22:07'!jumpToProject	(Project buildJumpToMenu: (MenuMorph new defaultTarget: Project))		popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 21:52'!makeAliasForArgument	| aThumbnailMorph |	(argument notNil and: [self playfield notNil]) ifTrue:		[aThumbnailMorph _ argument newThumbnailOfHeight: 40.		aThumbnailMorph  setNameTo: '^ ', argument externalName.		self attachMorph: aThumbnailMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 6/1/1998 19:15'!makeNewDrawing	"Make a new drawing in the standard playfield."	| aPlayfield bnds |	(aPlayfield _ self world playfield) ifNil: [aPlayfield _ self world].	bnds _ aPlayfield paintingBoundsAround: aPlayfield boundsInWorld center.	self makeNewDrawingInBounds: bnds pasteUpMorph: aPlayfield.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 12:30'!maybeDuplicateMorph	argument okayToDuplicate ifTrue:		[self duplicateMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/28/1998 17:48'!newDrawingFromMenu	self attachMorph: PaintInvokingMorph new markAsPartsDonor! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/14/1998 14:34'!objectToPaste	"It may need to be sent #startRunning by the client"	^ Cursor wait showWhile: [PasteBuffer veryDeepCopy]	"PasteBuffer usableDuplicateIn: self world"! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 6/12/1998 15:29'!openChangeSorter: oneOrTwo	oneOrTwo = 1		ifTrue: [ChangeSorter new open]		ifFalse: [DualChangeSorter new open]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 11:29'!openConstructionProject	| aSystemWindow |	self world addMorph: (aSystemWindow _ ProjectViewMorph newMorphicConstruction).	aSystemWindow model "the Project itself" enter: false! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/8/1998 04:57'!openEmail	"open an email interface"	Celeste openOn: 'EMAIL'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openFileList	FileList openAsMorph openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/5/1998 01:22'!openIRC	"open an interface to Internet Relay Chat"	IRCConnection new openView; openDirectMessagesObserver! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/14/1998 23:21'!openWebBrowser	Scamper openAsMorph ! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openWorkspace	Workspace new openAsMorphLabel: 'Workspace' inWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:53'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee player ifNotNil: [aPastee player startRunning]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:49'!placeArgumentIn 	"Let the user choose a new layer in the core sample for the argument to reside in, but don't allow strange loops"	|  targetMorph |	targetMorph _ self selectEmbedTargetMorph: ('Place ', argument externalName, ' in...').	targetMorph ifNotNil:		[targetMorph addMorphFront: argument fromWorldPosition: argument position]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:44'!potentialEmbeddingTargets	"Answer a list of targets into which the hand's arguement could be embedded"	| possibleTargets |	possibleTargets _ self world morphsAt: menuTargetOffset.	argument ifNotNil:		[possibleTargets removeAllFoundIn: argument allMorphs].	^ possibleTargets! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/6/1998 14:13'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream oldFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			self world addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ self drawingClass new form: f.			self attachMorph: m]! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/17/1998 16:27'!saveOnFile	"Save the guy we clicked on, not the hand"	argument saveOnFile! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:07'!selectEmbedTargetMorph: caption	"Put up a menu of morphs found in a core sample taken of the world at the receiver's menuTargetOffset, with the given caption"	|  menu |	menu _ CustomMenu new.	self potentialEmbeddingTargets  do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/3/1998 08:40'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first with: evt].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpAt: self position event: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 1/4/1999 21:17'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth |	oldDepth _ Display depth.	(result _ (SelectionMenu selections: #('1' '2' '4' '8' '16' '32')) startUpWithCaption: 'Choose a display depth(it is currently ' , oldDepth printString , ')') == nil ifFalse:		[Display newDepth: result asNumber].	(World isMorph and: [(Display depth < 4) ~= (oldDepth < 4)]) ifTrue:		["Repaint windows since they look better all white in depth < 4"		(SystemWindow windowsIn: World satisfying: [:w | true]) do:			[:w | w updatePaneColors]]! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 8/13/1998 12:56'!writeInitMethodForModel	| model |	model _ self world model.	model class chooseNewName.	model veryDeepCopy compileInitMethods.! !!HandMorph methodsFor: 'special gestures' stamp: 'di 9/30/1998 12:06'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph positionInWorld.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom:					(mouseDownMorph pointFromWorld: self position - targetOffset)].! !!HandMorph methodsFor: 'special gestures' stamp: 'di 10/6/1998 00:38'!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	self newMouseFocus: nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 9/20/1998 22:28'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette |	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 7/6/1998 13:30'!rejectDropMorph: aMorph event: evt	"aMorph has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	(formerOwner notNil and: [formerOwner isPartsBin not]) ifTrue:		[^ aMorph slideBackToFormerSituation: evt].	formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ aMorph vanishAfterSlidingTo: formerPosition event: evt].			aMorph slideToTrash: evt! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 6/25/1998 09:28'!roundUpStrayObjects	self world roundUpStrays! !!HandMorph methodsFor: 'copying' stamp: 'tk 1/4/1999 21:00'!veryDeepCopyWith: deepCopier	"Return self.  Do not copy hands this way."	^ self! !a "hidden" input.  It never actually appear on a formatted page, and the user can't change the input value.!!HiddenInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 06:37'!name: name0  value: value0	name _ name0.		value _ value0.! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!name	^name! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!value	^value! !!HiddenInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:38'!name: name0  value: value	^self new name: name0  value: value! !A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.!!HierarchicalUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:44'!hasContents	"most of these do...."	^true! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:24'!privateInitializeFromText: aString	| remainder ind nextTok s specifiedSchemeName |	remainder _ aString.	schemeName ifNil: [ 		specifiedSchemeName _ Url schemeNameForString: remainder.		specifiedSchemeName ifNotNil: [ 			schemeName _ specifiedSchemeName.			remainder _ remainder copyFrom: (schemeName size+2) to: remainder size ].		schemeName ifNil: [ "assume HTTP"  schemeName _ 'http' ] ].	"remove leading // if it's there"	(remainder beginsWith: '//') ifTrue: [		remainder _ remainder copyFrom: 3 to: remainder size ].	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ].	"get the authority"	ind _ remainder indexOf: $/.	ind > 0 ifTrue: [		ind = 1 ifTrue: [ authority _ '' ] ifFalse: [			authority _ remainder copyFrom: 1 to: ind-1.			remainder _ remainder copyFrom: ind+1 to: remainder size. ] ]	ifFalse: [		authority _ remainder.		remainder _ ''. ].	"get the path"	path _ OrderedCollection new.	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 9/10/1998 03:20'!privateInitializeFromText: aString relativeTo: aUrl	| remainder ind nextTok s |	remainder _ aString.	"set the scheme"	schemeName _ aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//') ifTrue: [		^self privateInitializeFromText: aString ].	"otherwise, use the same authority"	authority _ aUrl authority.	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ]. 	"get the path"	remainder isEmpty ifTrue: [ 		path _ aUrl path ]	ifFalse: [		(remainder beginsWith: '/')			ifTrue: [ path _ OrderedCollection new ]			ifFalse: [ path _ aUrl path shallowCopy.				path size > 0 ifTrue: [ path removeLast ] ]. 				s _ ReadStream on: remainder.		[ 			s peek = $/ ifTrue: [ s next ].			nextTok _ WriteStream on: String new.			[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].			nextTok _ nextTok contents unescapePercents.			nextTok = '..' 				ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]				ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].			s atEnd 		] whileFalse.		path isEmpty ifTrue: [ path add: '' ]	. ].! !!HierarchicalUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName0  authority: authority0  path: path0  query: query0	"initialize a new instance"	schemeName _ schemeName0.	authority _ authority0.	path _ path0.	query _ query0.! !!HierarchicalUrl methodsFor: 'printing' stamp: 'ls 7/21/1998 07:23'!toText	| ans |	ans _ WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	ans nextPutAll: self authority.	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!authority	^authority! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/6/1998 12:45'!isAbsolute		path size > 0 ifFalse: [^ false].	(path at: 1) size > 0 ifFalse: [^ false].	^ ((path at: 1) at: 1) ~~ $.! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!path	"return an ordered collection of the decoded path elements, as strings"	^path! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:56'!path: anArray	path _ anArray! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:59'!query	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"	^query ! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!schemeName	^schemeName! !!HierarchicalUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName  authority: authority  path: path  query: query	^self new schemeName: schemeName  authority: authority  path: path  query: query! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 10/26/1998 19:34'!mayContain: anEntity 	(self attributes includesKey: 'href') ifFalse: [		"if we have no href, then we can contain nothing"		^false ].	^ anEntity isTextualEntity! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!tagName	^'a'! !!HtmlAnchor methodsFor: 'formatting' stamp: 'ls 9/10/1998 03:22'!addToFormatter: formatter	| href name |	name _ self getAttribute: 'name'.	name ifNotNil: [		formatter noteAnchorStart: name ].	href _ self getAttribute: 'href'.	href isNil		ifTrue: [ super addToFormatter: formatter ]		ifFalse: [ 				formatter startLink: href.			super addToFormatter: formatter.			formatter endLink: href. ].! !!HtmlAttributes methodsFor: 'printing' stamp: 'ls 7/23/1998 19:05'!printHtmlOn: aStream	self associationsDo: 		[:element | 		aStream 			space;			nextPutAll: element key asUppercase.		element value ifNotNil: [  				aStream nextPut: $=.				aStream print: element value withoutQuoting]. ]! !an entity which supposedly increases the font size of its constituents!a moderately high level entitiy.  This includes P, FORM, and UL, among others!!HtmlBlockEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:27'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:26'!tagName	^'blockquote'! !!HtmlBlockQuote methodsFor: 'formatting' stamp: 'ls 7/17/1998 20:26'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.	formatter ensureNewlines: 1.! !!HtmlBody methodsFor: 'lint' stamp: 'ls 7/29/1998 00:24'!shouldContain: anEntity	"I don't *think* there are any elements that can be in both the header and the body..."	^anEntity isHeadElement not! !!HtmlBody methodsFor: 'testing' stamp: 'ls 7/4/1998 19:24'!mayContain: anEntity	"Body's can contain anything, so that even if we screw up the parsing, all the text will end up actually being included"	^true! !!HtmlBody methodsFor: 'testing' stamp: 'ls 6/25/1998 02:04'!tagName	^'body'! !an entity which displays its contents in boldface!!HtmlBoldEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 12:53'!addToFormatter: formatter	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!mayContain: anEntity	^false! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!tagName	^'br'! !!HtmlBreak methodsFor: 'formatting' stamp: 'ls 7/17/1998 19:21'!addToFormatter: formatter	formatter addChar: Character cr.! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!mayContain: anEntity	^false! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'button'! !A comment, eg <!!-- this is a comment -->Normally this is ignored, but it's included so that every byte in theinput gets put into one tag or another.!!HtmlComment methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self shouldNotImplement! !!HtmlComment methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isComment	^true! !!HtmlComment methodsFor: 'access' stamp: 'ls 1/25/98 04:56'!text	"return the text of the comment, the part inside the <!!-- and -->"	^self notYetImplemented! !a comment from the page!!HtmlCommentEntity methodsFor: 'private-iniitialization' stamp: 'ls 7/28/1998 20:28'!initializeWithText: aString	super initialize.	commentText _ aString.! !!HtmlCommentEntity methodsFor: 'printing' stamp: 'ls 10/26/1998 17:08'!printHtmlOn: aStream indent: indent 	indent timesRepeat: [aStream space].	aStream nextPutAll: '<!!-- '.	aStream nextPutAll: self commentText.	aStream nextPutAll: ' -->'.	aStream cr! !!HtmlCommentEntity methodsFor: 'printing' stamp: 'ls 10/26/1998 17:08'!printOn: aStream indent: indent 	self printHtmlOn: aStream indent: indent! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^true! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:27'!mayContain: anEntity	^false! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:30'!tagName		"return a bogus tag name"	^'x-comment'! !!HtmlCommentEntity methodsFor: 'formatting' stamp: 'ls 7/4/1998 12:27'!addToFormatter: formatter	"do nothing"! !!HtmlCommentEntity methodsFor: 'access' stamp: 'ls 7/4/1998 12:27'!commentText	^commentText! !!HtmlDefinitionDefinition methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:12'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:20'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ] ! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:18'!tagName	^'dd'! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!mayContain: anEntity	^anEntity isDefinitionListElement! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dl'! !!HtmlDefinitionList methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlDefinitionListElement methodsFor: 'testing' stamp: 'ls 6/25/1998 02:19'!isDefinitionListElement	^true! !!HtmlDefinitionTerm methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:19'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dt'! !an entire HTML document.  It should have exactly two sub-entities when completed: a HEAD and a BODY!!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:57'!mayContain: anElement	^true 	"not strictly true, but it makes the parser simpler"! !!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:06'!tagName	^'html'! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:38'!addToBody: anObject	"add an object to the Body entity of the receiver"	self body add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:37'!addToHead: anObject	"add an object to the head entity of the receiver"	self head add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!body	^self contents at: 2! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!head	^self contents at: 1! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:25'!formattedText	"return a version of this document as a formatted Text"	| formatter |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	^formatter text ! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/29/1998 03:01'!formattedTextForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted Text (which includes links and such)"	| formatter text |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	text _ formatter text.	^text! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/14/1998 00:35'!formattedTextMorph	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter text textMorph |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	text _ formatter text .	textMorph _ TextMorph new initialize.	textMorph contentsWrapped: text.	^textMorph! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/16/1998 22:12'!formattedTextMorphForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter textMorph |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	textMorph _ formatter textMorph .	^textMorph! !!HtmlDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 04:26'!emptyDocument	"return an empty document"	^super new add: HtmlHead new; add: HtmlBody new! !!HtmlEmbedded methodsFor: 'attributes' stamp: 'ar 11/18/1998 19:07'!extent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlEmbedded methodsFor: 'attributes' stamp: 'ar 11/18/1998 19:07'!src	^self getAttribute: 'src' default: nil! !!HtmlEmbedded methodsFor: 'testing' stamp: 'ar 11/18/1998 19:07'!mayContain: anEntity	^false! !!HtmlEmbedded methodsFor: 'testing' stamp: 'ar 11/18/1998 19:07'!tagName	^'embed'! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/18/1998 20:56'!addToFormatter: formatter	| url embeddedMorph |	self src isNil ifTrue:[^self].	url _ self src.	embeddedMorph _ self embeddedMorphFor: url.	embeddedMorph isNil ifTrue:[^self].	formatter baseUrl ifNotNil:[url _ url asUrlRelativeTo: formatter baseUrl].	embeddedMorph extent: self extent.	embeddedMorph sourceUrl: url.	embeddedMorph setProperty: #embedded toValue: true.	formatter addIncompleteMorph: embeddedMorph.! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/19/1998 22:47'!embeddedMorphClassFor: url	| lastIndex extension className |	lastIndex _ url findLast:[:c| c = $.].	lastIndex = 0 ifTrue:[^nil].	extension _ url copyFrom: lastIndex+1 to: url size.	className _ ExtensionList at: extension asLowercase ifAbsent:[^nil].	^Smalltalk at: className ifAbsent:[nil]	! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/18/1998 19:16'!embeddedMorphFor: url	| morphClass |	morphClass _ self embeddedMorphClassFor: url.	^morphClass ifNotNil:[morphClass new]! !!HtmlEmbedded class methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:46'!initialize	"HtmlEmbedded initialize"	ExtensionList _ Dictionary new.	#(		('swf'	FlashPlayerMorph)	) do:[:spec| ExtensionList at: spec first put: spec last].! !<html>When HtmlParser runs, it generates a tree whose nodes are in HtmlEntity's subclasses.  There is a separate class for most of the available elements in HTML, though some are grouped together under generic classes like HtmlBoldEntity.Methods of particular interest when modifying or adding subclasses are:<ul><li>initialize:<li>mayContain:<li>addToFormatter:</ul>!!HtmlEntity methodsFor: 'downloading' stamp: 'ls 7/29/1998 00:52'!downloadState: baseUrl	"download any state needed for full rendering.  eg, images need this"	! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrame	^false! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^false! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspect	"Open an HtmlEntityInspector on the receiver.	Use basicInspect to get a normal type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspectWithLabel: aLabel	"Open a HtmlEntityInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true withLabel: aLabel! !!HtmlEntity methodsFor: 'converting' stamp: 'djp 7/21/1998 11:58'!asHtml	| aStream |	aStream := WriteStream on: ''.	self printHtmlOn: aStream.	^aStream contents.! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:21'!add: anObject	"add an object to the receiver"	(anObject isKindOf: String)		ifTrue: [contents add: (HtmlTextEntity new text: anObject)]		ifFalse: [contents add: anObject]! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 13:51'!at: key put: anObject	self attributes ifNil: [self attributes: (HtmlAttributes new)].	(self attributes) at: key put: anObject! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:28'!attributes	^attribs ifNil: [attribs := HtmlAttributes new]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 15:01'!addToFormatter: aFormatter	"by default, just format our childer"	contents do: [ :e | e addToFormatter: aFormatter ]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 7/15/1998 18:31'!parsingFinished	"some entities need to make a final pass *after* parsing has finished and all the contents of each entity have been established; here is a place to do that"	contents do: [ :e | e parsingFinished ].! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:03'!addEntity: anEntity	"add an entity to the receiver"	contents add: anEntity! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:02'!contents	"return an ordered collection of this entity's contents"	^contents! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 10/26/1998 17:24'!removeEntity: anEntity 	"remove the specified entity"	contents remove: anEntity! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 10/26/1998 17:25'!subEntities	"return an ordered collection of this entity's contents"	^ contents! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:37'!textualContents	"return a string with the concatenated contents of all textual sub-entities"	^String streamContents: [ :s |		contents do: [ :e | s nextPutAll: e textualContents ] ]! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'ls 7/31/1998 02:57'!initialize	contents _ OrderedCollection new.	attribs _ HtmlAttributes new.! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'djp 7/20/1998 20:52'!initialize: aTag	self initialize.	attribs _ HtmlAttributes newFrom: aTag attribs.! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isDefinitionListElement	"whether receiver can appear in a DefinitionList"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/16/1998 23:18'!isFormEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:54'!isHeadElement	"whether this can appear in a header"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:18'!isListElement	"is this an HtmlListElement, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:12'!isListItem	"is this an HtmlListItem, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	"whether this is an <option> entity"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isTextualEntity	"is receiver either text, or some low-level text-like entity such as <b> or <em>"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:09'!lint	^String streamContents: [ :s | self lint: s ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:37'!lint: aStream	"do a lint check, reporting to aStream"	self lintAttributes: aStream.	contents do: [ :c |		(c isComment not   and:  [ (self shouldContain: c) not ]) ifTrue: [ 			aStream nextPutAll: '<', self tagName, '> should not contain <', c tagName, '>'.			aStream cr. ] ].	contents do: [ :c  | c lint: aStream ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:07'!lintAttributes: aStream	"check that our attributes are okay.  Print any anomalies to aStream"	! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:03'!mayContain: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:01'!mayContainEntity: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:35'!shouldContain: anEntity	"whether, according to the HTML DTD, this element should actually contain anEntity.  Used for checking the quality of a pages HTML"	^self mayContain: anEntity! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:02'!tagName	"tag name for ourself"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/26/1998 19:59'!attributes: newAttributes	"set all of the attributes at once.  newAttributes should not be modified after passing it in"	^attribs _ newAttributes! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 02:55'!doesNotUnderstand: aMessage	"treat the message as an attribute name"	| selector |	selector _ aMessage selector.	selector asLowercase = selector ifFalse: [		"attribute accesses must be in all lowercase.  This should cut down on some false doesNotUnderstand: traps"		^super doesNotUnderstand: aMessage ].	selector numArgs == 0 ifTrue: [		"return the named attribute"		^self getAttribute: selector asString default: nil ].	selector numArgs == 1 ifTrue: [		"set the named attribute"		self setAttribute: (selector asString copyFrom: 1 to: (selector size-1)) to: aMessage argument.		^self ].	^super doesNotUnderstand: aMessage! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:20'!getAttribute: name	^self getAttribute: name  default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:52'!getAttribute: name  default: anObject	^self getAttribute: name  ifAbsent: [anObject]! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:51'!getAttribute: name  ifAbsent: aBlock	^attribs at: name ifAbsent: aBlock! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/17/1998 19:04'!name	^self getAttribute: 'name' default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 03:00'!setAttribute: name  to: value	"set the given attribute to the given value"	attribs at: name asLowercase  put: value! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/20/1998 21:12'!printHtmlOn: aStream	^self printHtmlOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 10/30/1998 10:08'!printHtmlOn: aStream indent: indent 	aStream next: indent put: $ ;	 nextPutAll: '<';	 nextPutAll: self tagName.	self attributes associationsDo: [:assoc | aStream space; nextPutAll: assoc key; nextPutAll: '="'; nextPutAll: assoc value; nextPutAll: '"'].	aStream nextPut: $>;	 cr.	contents do: [:entity | entity printHtmlOn: aStream indent: indent + 1].	aStream nextPutAll: '</'; nextPutAll: self tagName; nextPutAll: '>'.! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 6/25/1998 03:13'!printOn: aStream	^self printOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 8/11/1998 03:16'!printOn: aStream  indent: indent	aStream		next: indent put: $ ;		nextPut: $<;		print: self tagName.	self attributes associationsDo: [ :assoc |		aStream			space;			nextPutAll: assoc key;			nextPutAll: '=';			nextPutAll: assoc value ].	aStream		nextPut: $>;		cr.	contents do: [ :entity | entity printOn: aStream indent: indent+1 ].! !!HtmlEntity methodsFor: 'enumeration' stamp: 'ls 7/16/1998 23:17'!allSubentitiesDo: aBlock	"perform the block recursively on all sub-entities"	contents do: [ :e | 		aBlock value: e .		e allSubentitiesDo: aBlock.	].	! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 7/29/1998 01:27'!forTag: aTag	"create a new entity based on the given tag"	^self new initialize: aTag! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 13:17'!new	^super new initialize! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'djp 7/21/1998 17:21'!fieldList	^ super fieldList, (Array with: 'asHtml')! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'ls 7/24/1998 01:40'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 300 @ 300! !!HtmlEntityInspector methodsFor: 'selecting' stamp: 'ls 7/23/1998 07:37'!selection	selectionIndex = self fieldList size 		ifTrue: [^object asHtml]		ifFalse: [^super selection]! !The Class apes StandardFileStream, but converts the text to HTML before putting it out (primarily intended for printOut).  It can be invoked with	((FileStream fileNamed: 'changes.html') asHtml) fileOutChangesUse usual FileStream methods to put out text converted to	HTML fairly approximating that text  (for best looks, use 	method:, methodHeader:, methodBody:, for code);verbatim: puts text out without conversion;command: put out HTML items, such as <br>, supplying the brackets.header: and trailer: put out an HTML wrapper (preamble and closing text)nextPut does the actual conversion, nextPutAll: defers characters to nextPut.The code is fairly dumb at present, doing a wooden straightforward conversion of the text without attempting to capture the style or fonts in which the original text was rendered.  Tabs are handled awkwardly, using &nbsp, so that probably only leading strings are working right.  Style sheets now permit us to do a much neater looking job if there is interest in improving the looks of things.!]style[(1039)f1cred;!!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/01/1999 13:59'!nextPut: char	"Put a character on the file, but translate it first. 4/6/96 tk 1/1/98 acg"	char = $< ifTrue: [^ super nextPutAll: '&lt;'].	char = $> ifTrue: [^ super nextPutAll: '&gt;'].	char = $& ifTrue: [^ super nextPutAll: '&amp;'].	char asciiValue = 13 "return" 		ifTrue: [self command: 'br'].	char = $	"tab" 		ifTrue: [self verbatim: TabThing. ^super nextPut: char].	^ super nextPut: char! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/07/1999 09:24'!trailer	"append the HTML trailer.  Call this just before file close.	4/4/96 tk"	| cr |	cr _ String with: Character cr.	self command: '/BODY'; verbatim: cr.	self command: '/HTML'; verbatim: cr.!]style[(7 192)f1bcblue;,f1! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/02/1999 00:38'!verbatim: aString	"Put out the string without HTML conversion. 1/1/99 acg"	super nextPutAll: aString	"'super verbatim:' in the 2.3beta draft didn't perform as expected -- the code was printed with conversion.  In a sense, that wouldn't make sense either -- we don't want strictly verbatim printing, just printing without the HTML conversion (that is, skipping around just the nextPut: and nextPutAll: for just this Class).  If there were intermediate conversions (say, CRLF!!), we would want those to happen as advertised -- perhaps we should use a differently named selector, perhaps something like nextPutWithoutHTMLConversion:, so that verbatim isn't overridden?"! !!HtmlFileStream class methodsFor: 'instance creation' stamp: 'acg 01/07/1999 09:24'!newFrom: aFileStream	"Answer an HtmlFileStream that is 'like' aFileStream.  As a side-effect, the surviving fileStream answered by this method replaces aFileStream on the finalization registry. 1/6/99 acg"	|inst|	inst _ super newFrom: aFileStream.	StandardFileStream unregister: aFileStream.	HtmlFileStream register: inst.	inst detectLineEndConvention.	^inst! !!HtmlFileStream class methodsFor: 'class initialization' stamp: 'acg 01/01/1999 13:57'!initialize   "HtmlFileStream initialize"	TabThing _ '&nbsp;&nbsp;&nbsp;'"I took Ted's suggestion to use &nbsp, which works far better for the HTML.  Style sheets provide an alternative, possibly better, solution since they permit finer-grain control of the HTML formatting, and thus would permit capturing the style in which text was originally rendered.  Internal tabbings would still get lost. 1/1/99 acg."! !An entity that (supposedly) displays its contents in a fixed-width font.  I don't know how to do this, though.  -ls!an entity whose effect is to change the font its constituents are displayed in in some way.  Multiple tags might generate almost any of the subclasses, so the tag name is stored explicitly.!!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 7/5/1998 01:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 12:51'!tagName	"must be stored in an i-var, because these classes work for different tags"	^tagName! !!HtmlFontChangeEntity methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:34'!initialize: aTag	super initialize: aTag.	tagName _ aTag name! !the <font> tag.  it's here for future expansion....!!HtmlForm methodsFor: 'testing' stamp: 'ls 7/4/1998 19:51'!isBlockElement	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/15/1998 00:24'!mayContain: anEntity	"allow anything.  People probably always put </form> anyway at the end of their forms.  And furthermore, it has no effect on the display, even if this is gotten wrong"	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/3/1998 23:30'!tagName	^'form'! !!HtmlForm methodsFor: 'formatting' stamp: 'ls 7/17/1998 00:26'!addToFormatter: formatter	formatter startForm: self.	super addToFormatter: formatter.	formatter currentFormData reset.	formatter endForm.! !!HtmlForm methodsFor: 'parsing' stamp: 'ls 7/16/1998 23:16'!parsingFinished	"figure out who our constituents are"	self allSubentitiesDo: [ :e |		e isFormEntity ifTrue: [ e form: self ] ].	super parsingFinished.	formEntities _ OrderedCollection new.	self allSubentitiesDo: [ :e |		(e isFormEntity and: [ e form == self ])			ifTrue: [ formEntities add: e ] ].! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!method	"method to submit with"	^self getAttribute: 'method' default: 'get'! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!url	"url to submit to"	^self getAttribute: 'action' default: nil.  ! !!HtmlForm methodsFor: 'access' stamp: 'ls 7/16/1998 23:29'!formEntities	^formEntities! !Abstract superclass for elements that only appear in forms!!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form	"return which form we are in"	^form! !!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form: aForm	"set which form we are part of"	form _ aForm! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/15/1998 00:22'!isFormEntity	^true! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/29/1998 00:15'!lint: aStream	form ifNil: [ aStream nextPutAll: '<', self tagName, '> not within a form'.		aStream cr. ].	super lint: aStream.! !a filter which formats HTML into a Text with attributes!!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:07'!currentFormData	"return the current form data, or nil if we aren't inside a form"	formDatas size > 0 		ifTrue: [ ^formDatas last ]		ifFalse: [ ^nil ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:06'!endForm	formDatas size > 0 ifTrue: [ 		formDatas removeLast. ]	ifFalse: [ self halt: 'HtmlFormatter: ended more forms that started!!?' ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 8/5/1998 07:14'!startForm: form	"a form is beginning"	formDatas addLast: (FormInputSet forForm: form  andBrowser: browser).! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/10/1998 03:20'!anchorLocations	"return a dictionary mapping lowercase-ed anchor names into the integer positions they are located at in the text"	^anchorLocations! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!baseUrl	"return the base URL for the document we are formatting, if known"	^baseUrl! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:09'!baseUrl: url	"set the base url.  All relative URLs will be determined relative to it"	baseUrl _ url.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:07'!browser	"return the browser we are formatting for, or nil if none"	^browser! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!browser: b	"set what browser we are formatting for"	browser _ b.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/5/1998 18:08'!incompleteMorphs	"list of morphs needing to download some more state"	^incompleteMorphs! !!HtmlFormatter methodsFor: 'private-initialization' stamp: 'ls 9/10/1998 03:17'!initialize	outputStream _ AttributedTextStream new.	preformattedLevel _ 0.	indentLevel _ boldLevel _ italicsLevel _ underlineLevel _ strikeLevel _ centerLevel _ 0.	listLengths _ OrderedCollection new.	listTypes _ OrderedCollection new.	formDatas _ OrderedCollection new.	precedingSpaces _ 0.	precedingNewlines _ 1000.   "more than will ever be asked for"	morphsToEmbed _ OrderedCollection new.	incompleteMorphs _ OrderedCollection new.	anchorLocations _ Dictionary new.	outputStream nextPut: Character cr.! !!HtmlFormatter methodsFor: 'private-formatting' stamp: 'ls 8/5/1998 01:41'!setAttributes	"set attributes on the output stream"	| attribs |	attribs _ OrderedCollection new.	indentLevel > 0 ifTrue: [ attribs add: (TextIndent tabs: indentLevel) ].	boldLevel > 0 ifTrue: [ attribs add: TextEmphasis bold ].	italicsLevel >  0 ifTrue: [ attribs add: TextEmphasis italic ].	underlineLevel > 0 ifTrue: [ attribs add: TextEmphasis underlined ].	strikeLevel > 0 ifTrue: [ attribs add: TextEmphasis struckOut ].	urlLink isNil ifFalse: [ attribs add: (TextURL new url: urlLink) ].	outputStream currentAttributes: attribs! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:14'!addChar: c	"add a single character, updating all the tallies"	"add the character to the output"	outputStream nextPut: c.	"update counters for preceeding spaces and preceding newlines"	(c = Character space or: [ c = Character tab ]) 	ifTrue: [ precedingSpaces _ precedingSpaces+1.  precedingNewlines _ 0 ]	ifFalse: [		(c = Character cr) ifTrue: [			precedingSpaces _ 0.			precedingNewlines _ precedingNewlines + 1 ]		ifFalse: [			precedingSpaces _ precedingNewlines _ 0 ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/5/1998 18:09'!addIncompleteMorph: aMorph	"add a morph, and note that it needs to download some more state before reaching its ultimate state"	self addMorph: aMorph.	incompleteMorphs add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 02:51'!addLink: text  url: url	"add a link with the given url and text"	| savedAttributes linkAttribute  |	"set up the link attribute"	linkAttribute _ TextURL new.	linkAttribute url: url.	"add the link to the stream"	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes, linkAttribute).	outputStream nextPutAll: text.	outputStream currentAttributes: savedAttributes.	"reset counters"	precedingSpaces _ precedingNewlines _ 0.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/29/1998 07:39'!addMorph: aMorph	"add a morph to the output"	| savedAttributes |	self addChar: Character space.	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes copyWith: (TextAnchor new anchoredMorph: aMorph)).	self addChar: $*.	outputStream currentAttributes: savedAttributes.	self addChar: Character space.	morphsToEmbed add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/25/1998 06:10'!addString: aString	"adds the text in the given string.  It collapses spaces unless we are in a preformatted region"	| space compacted lastC i |	aString isEmpty ifTrue: [ ^self ].	space _ Character space.	preformattedLevel > 0 ifTrue: [		"add all the characters as literals"		outputStream nextPutAll: aString.		"update the counters"		lastC _ aString last.		(lastC = space or: [ lastC = Character cr ]) ifTrue: [			"how many of these are there?"			i _ aString size - 1.			[ i >= 1 and: [ (aString at: i) = lastC ] ] whileTrue: [ i _ i - 1 ].			i = 0 ifTrue: [				"the whole string is the same character!!"				lastC = space ifTrue: [					precedingSpaces _ precedingSpaces + aString size.					precedingNewlines _ 0.					^self ]				ifFalse: [					precedingSpaces _ 0.					precedingNewlines _ precedingNewlines + aString size.					^self ]. ].			lastC = space ifTrue: [				precedingSpaces _ aString size - i.				precedingNewlines _ 0 ]			ifFalse: [				precedingSpaces _ 0.				precedingNewlines _ aString size - i ] ] ]	ifFalse: [		compacted _ aString withSeparatorsCompacted.		compacted = ' ' ifTrue: [			"no letters in the string--just white space!!"			(precedingNewlines = 0 and: [precedingSpaces = 0]) ifTrue: [				precedingSpaces _ 1.				outputStream nextPut: space. ].			^self ].		(compacted first = Character space and: [			(precedingSpaces > 0) or: [ precedingNewlines > 0] ])		ifTrue: [ compacted _ compacted copyFrom: 2 to: compacted size ].		outputStream nextPutAll: compacted.		"update counters"		precedingNewlines _ 0.		compacted last = space 			ifTrue: [ precedingSpaces _ 1 ]			ifFalse: [ precedingSpaces _ 0 ]. ]! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseBold	boldLevel _ boldLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseIndent	indentLevel _ indentLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseItalics	italicsLevel _ italicsLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!decreasePreformatted	preformattedLevel _ preformattedLevel - 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!decreaseStrike	strikeLevel _ strikeLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:39'!decreaseUnderline	underlineLevel _ underlineLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!endLink: url	urlLink _ nil.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/20/1998 11:34'!endListItem	"end a list item"	self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:17'!endOrderedList	"end an ordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 	self ensureNewlines: 1.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:18'!endUnorderedList	"end an unordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 		self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/25/1998 17:21'!ensureNewlines: number	"make sure there are at least number preceding newlines"	number > precedingNewlines ifTrue: [		(number - precedingNewlines) timesRepeat: [ self addChar: Character cr ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/16/1998 11:34'!ensureSpaces: number	"make sure there are at least number preceding spaces, unless we're at the beginning of a new line"	precedingNewlines > 0 ifTrue: [ ^ self ].	number > precedingSpaces ifTrue: [		(number - precedingSpaces) timesRepeat: [ self addChar: Character space ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:15'!hr	"add an (attempt at a) horizontal rule"	self ensureNewlines: 1.	25 timesRepeat: [ self addChar: $- ].	self ensureNewlines: 1.	precedingSpaces _ 0.	precedingNewlines _ 1000.    "pretend it's the top of a new page"! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseBold	boldLevel _ boldLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseIndent	indentLevel _ indentLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:13'!increaseItalics	italicsLevel _ italicsLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!increasePreformatted	preformattedLevel _ preformattedLevel + 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!increaseStrike	strikeLevel _ strikeLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:40'!increaseUnderline	underlineLevel _ underlineLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/10/1998 03:26'!noteAnchorStart: anchorName	"note that an anchor starts at this point in the output"	anchorLocations at: anchorName asLowercase put: outputStream size! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!startLink: url	urlLink _ url.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/13/1998 23:19'!startListItem	"begin a new list item"	listTypes size = 0 ifTrue: [ ^self ].	self ensureNewlines: 1.	listTypes last = #unordered		ifTrue: [ self addString: 'o ' ]		ifFalse: [ self addString: (listLengths last + 1) printString.			self addString: '. ' ].	listLengths at: (listLengths size) put: (listLengths last + 1).! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startOrderedList	"begin an ordered list"	listLengths add: 0.	listTypes add: #ordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startUnorderedList	"begin an unordered list"	listLengths add: 0.	listTypes add: #unordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 6/30/1998 01:13'!text	| text |	text _ outputStream contents.	^text! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 7/16/1998 21:55'!textMorph	| text textMorph |	text _ outputStream contents.	textMorph _ TextMorph new contents: text.	morphsToEmbed do:[ :m | textMorph addMorph: m ].	^textMorph! !!HtmlFormatter class methodsFor: 'instance creation' stamp: 'ls 6/25/1998 17:25'!new	^super new initialize! !!HtmlFormatter class methodsFor: 'example' stamp: 'ls 7/14/1998 00:42'!example1	"(HtmlFormatter example1 asParagraph compositionRectangle: (0@0 extent: 300@500) ) displayAt: 0@0"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser"]></a></body></html>'.	^(HtmlParser on: input) formattedText! !!HtmlFormatter class methodsFor: 'initialization' stamp: 'ls 8/20/1998 06:05'!initialize	"HtmlFormatter initialize"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!HtmlFrame methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:25'!isFrame	^true! !!HtmlFrame methodsFor: 'formatting' stamp: 'ls 7/26/1998 21:53'!addToFormatter: formatter	| src |	src _ self getAttribute: 'src' default: nil.	formatter ensureNewlines: 1.	src ifNotNil: [ formatter startLink: src ].	formatter addString: 'frame '.	formatter addString: (self name ifNil: ['(unnamed)']).	src ifNotNil:  [ formatter endLink: src ].	formatter ensureNewlines: 1.! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!mayContain: anEntity	^false! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!tagName	^'frame'! !!HtmlFrameSet methodsFor: 'lint' stamp: 'ls 7/29/1998 00:25'!shouldContain: anEntity	^anEntity isFrame or: [ anEntity isFrameSet ]! !!HtmlFrameSet methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/29/1998 00:26'!mayContain: anEntity	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/26/1998 21:45'!tagName	^'frameset'! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:03'!title	"return the title, or nil if there isn't one"	| te |	te _ self titleEntity.	te ifNil: [ ^nil ].	^te textualContents! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:02'!titleEntity	"return the title entity, or nil if there isn't one"	contents do: [ :e | e tagName = 'title' ifTrue: [ ^e ] ].	^nil! !!HtmlHead methodsFor: 'testing' stamp: 'ls 7/28/1998 20:25'!mayContain: anEntity	^anEntity isHeadElement or: [ anEntity isComment ]! !!HtmlHead methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'head'! !abstract superclass for entities that may appear in the HEAD section!!HtmlHeadEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 15:37'!isHeadElement	^true! !!HtmlHeadEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:38'!addToFormatter: formatter	"head elements are normally just meta-information, and thus don't add anything to the formatter"! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^true! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 6/27/1998 15:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/23/1998 05:42'!tagName	^'h', level printString! !!HtmlHeader methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:14'!addToFormatter: formatter	formatter ensureNewlines: 3.	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.	formatter ensureNewlines: 2.! !!HtmlHeader methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 05:42'!initialize: aTag	super initialize: aTag.	level _ aTag name last digitValue.! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/27/1998 15:52'!mayContain: anEntity	^false! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'hr'! !!HtmlHorizontalRule methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:57'!addToFormatter: formatter	formatter hr! !!HtmlImage methodsFor: 'downloading' stamp: 'ls 8/8/1998 03:47'!downloadState: baseUrl 	|  sourceUrl imageSource |	image ifNil: [ 		sourceUrl _ self src.		sourceUrl ifNotNil: [ 			imageSource _ HTTPSocket httpGetDocument: (sourceUrl asUrlRelativeTo: baseUrl asUrl) toText.			imageSource contentType = 'image/gif'  ifTrue: [				[image _ (GIFReadWriter on: (RWBinaryOrTextStream with: imageSource content) reset binary) nextImage ]				ifError: [ :a :b |  "could not decode--ignore it"  image _ nil ] ].			 ] ].! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 8/4/1998 21:58'!alt	^(self getAttribute: 'alt') ifNil: ['[image]']! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 9/9/1998 07:01'!imageExtent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 7/29/1998 00:56'!src	^self getAttribute: 'src' default: nil! !!HtmlImage methodsFor: 'formatting' stamp: 'ls 9/9/1998 07:05'!addToFormatter: formatter	| morph url |	self src isNil ifTrue: [ ^self ].	url _ self src.	formatter baseUrl ifNotNil: [ 		url _ url asUrlRelativeTo: formatter baseUrl ].	morph _ DownloadingImageMorph new.	morph defaultExtent: self imageExtent.	morph altText: self alt.	morph url: url.	formatter addIncompleteMorph: morph.! !!HtmlImage methodsFor: 'initializing' stamp: 'ls 7/27/1998 02:17'!initialize: aTag		super initialize: aTag.! !!HtmlImage methodsFor: 'testing' stamp: 'ls 7/1/1998 02:30'!mayContain: anEntity	^false! !!HtmlImage methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'img'! !result of an <input> tag!!HtmlInput methodsFor: 'attributes' stamp: 'ls 9/18/1998 08:22'!defaultValue	^(self getAttribute: 'value' default: '') replaceHtmlCharRefs! !!HtmlInput methodsFor: 'attributes' stamp: 'ls 7/23/1998 19:09'!type	^(self getAttribute: 'type' default: 'text') asLowercase! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:15'!isTextualEntity	^true! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!mayContain: anEntity	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/21/1998 06:51'!suppliesInput	"whether we actually have input to supply"	self type = 'text' ifTrue: [ ^true ].	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!tagName	^'input'! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 8/11/1998 20:47'!addRadioButtonToFormatter: formatter	| name formData checked buttonSet button buttonInput |	"dig up relevant attributes"	name _ self getAttribute: 'name'.	name ifNil: [ ^self ].	value _ self getAttribute: 'value'.	value ifNil: [ ^value ].		formData _ formatter currentFormData.	formData ifNil:  [ ^self ].	checked _ self getAttribute: 'checked'.	"find or create the set of buttons with our same name"	buttonSet _ formData inputs detect: [ :i | i isRadioButtonSetInput and: [ i name = name ] ] ifNone: [ nil ].	buttonSet ifNil: [ 		"create a new button set"		buttonSet _ RadioButtonSetInput name: name.		formData addInput: buttonSet. ].	"set up the form input"	buttonInput _ RadioButtonInput  inputSet: buttonSet value: value.	buttonSet addInput: buttonInput.	checked ifNotNil: [		buttonSet  defaultButton: buttonInput ].	"create the actual button"	button _ PluggableButtonMorph on: buttonInput getState: #pressed  action: #toggle.	button label: 'X'.	formatter addMorph: button.! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 9/11/1998 23:42'!addToFormatter: formatter	"is it a submit button?"	| inputMorph formData size |	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image' ifTrue: [		"fake it"		value _ self getAttribute: 'value' default: 'Submit'.		formData _ formatter currentFormData.		formatter addMorph: ((PluggableButtonMorph on: formData getState: nil action: #submit) label: value).		formData addInput: (HiddenInput name: (value,'.x') value: '0').		formData addInput: (HiddenInput name: (value,'.y') value: '0').			^self ].	self type = 'text' ifTrue: [		inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.		size _ self getAttribute: 'size' default: '12'.		size _ size asNumber.		inputMorph extent: (size*10@20).		formatter addMorph: inputMorph.		formatter currentFormData addInput: (TextInput name: self name  defaultValue: self defaultValue  textMorph: inputMorph).		^self ].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !an entity which displays its contents in italics!!HtmlItalicsEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 13:16'!addToFormatter: formatter	formatter increaseItalics.	super addToFormatter: formatter.		formatter decreaseItalics.! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/17/1998 19:20'!mayContain: anElement	"lists may only contain LI elements"	"^anElement isListItem"	"except that people write some sucky HTML out there!!!!  well, let's assume they always put the end tag.  Much safer assumption than that they only put list-items in their lists"	^true! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/28/1998 20:40'!shouldContain: anEntity	^anEntity isListItem! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:10'!isListItem	^true! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ]! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:09'!tagName	^'li'! !!HtmlListItem methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:49'!addToFormatter: formatter	formatter startListItem.	super addToFormatter: formatter.	formatter endListItem.! !some result of a meta tag; unimplemented so far!!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!mayContain: anEntity	^false! !!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!tagName	^'meta'! !!HtmlMeta methodsFor: 'formatting' stamp: 'ls 8/12/1998 05:44'!addToFormatter: formatter	| httpEquiv |	httpEquiv _ self getAttribute: 'http-equiv'.	httpEquiv ifNil: [ ^self ].	httpEquiv asLowercase = 'refresh' ifTrue: [		formatter addString: '{refresh: ', (self getAttribute:  'content' default: ''), '}' ].! !!HtmlMeta methodsFor: 'initialization' stamp: 'ls 7/5/1998 02:23'!initialize: aTag	super initialize: aTag.	theTag _ aTag.! !!HtmlMeta methodsFor: 'printing' stamp: 'ls 7/5/1998 02:24'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: 'meta: '.	theTag printOn: aStream.	aStream cr.! !!HtmlNoEmbed methodsFor: 'formatting' stamp: 'ar 11/18/1998 21:11'!addToFormatter: aFormatter	"Check if the last incomplete morph has the property #embedded set.	If so, assume that the last <EMBED> tag has been handled."	| morphs |	morphs _ aFormatter incompleteMorphs.	(morphs isEmpty not and:[(morphs last valueOfProperty: #embedded) == true])		ifTrue:[^self].	"If not handled do the usual stuff"	^super addToFormatter: aFormatter! !!HtmlNoEmbed methodsFor: 'testing' stamp: 'ar 11/18/1998 21:11'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlNoEmbed methodsFor: 'testing' stamp: 'ar 11/18/1998 21:02'!tagName	^'noembed'! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:19'!label	"label to be displayed for this morph"	^self getAttribute: 'label' ifAbsent: [self textualContents]! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 08:42'!value	"value to pass if this option is selected"	^self getAttribute: 'value' default: '(unspecified)'! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	^true! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'option'! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!mayContain: anEntity	^anEntity isOption! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'optgroup'! !!HtmlOrderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startOrderedList.	super addToFormatter: formatter.	formatter endOrderedList.! !!HtmlOrderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ol'! !!HtmlParagraph methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:16'!addToFormatter: formatter	formatter ensureNewlines: 2.	super addToFormatter: formatter.! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!tagName	^'p'! !parses a stream of HtmlToken's into an HtmlDocument.  All token become an entity of some sort in the resulting document; some things are left only as comments, though.!!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/28/1998 02:02'!parse: aStream	^self parseTokens: (HtmlTokenizer on: aStream)! !!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/29/1998 03:13'!parseTokens: tokenStream	|  entityStack document head token matchesAnything entity body |	entityStack _ OrderedCollection new.	"set up initial stack"	document _ HtmlDocument new.	entityStack add: document.		head _ HtmlHead new.	document addEntity: head.	entityStack add: head.	"go through the tokens, one by one"	[ token _ tokenStream next.  token = nil ] whileFalse: [		(token isTag and: [ token isNegated ]) ifTrue: [			"a negated token"			(token name ~= 'html' and: [ token name ~= 'body' ]) ifTrue: [				"see if it matches anything in the stack"				matchesAnything _ (entityStack detect: [ :e | e tagName = token name ] ifNone: [ nil ]) isNil not.				matchesAnything ifTrue: [					"pop the stack until we find the right one"					[ entityStack last tagName ~= token name ] whileTrue: [ entityStack removeLast ].					entityStack removeLast.				]. ] ]		ifFalse: [			"not a negated token.  it makes its own entity"			token isComment ifTrue: [				entity _ HtmlCommentEntity new initializeWithText: token source.			].			token isText ifTrue: [				entity _ HtmlTextEntity new text: token text.				(((entityStack last shouldContain: entity) not) and: 					[ token source isAllSeparators ]) ifTrue: [					"blank text may never cause the stack to back up"					entity _ HtmlCommentEntity new initializeWithText: token source ].			].			token isTag ifTrue: [				entity _ token entityFor.				entity = nil ifTrue: [ entity _ HtmlCommentEntity new initializeWithText: token source ] ].			entity = nil ifTrue: [ self error: 'could not deal with this token' ].			entity isComment ifTrue: [				"just stick it anywhere"				entityStack last addEntity: entity ]			ifFalse: [				"only put it in something that is valid"				[ entityStack last mayContain: entity ] 					whileFalse: [ entityStack removeLast ].				"if we have left the head, create a body"									entityStack size < 2 ifTrue: [ 					body _ HtmlBody new.					document addEntity: body.					entityStack add: body  ].				"add the entity"				entityStack last addEntity: entity.				entityStack addLast: entity.			].		]].	body == nil ifTrue: [		"add an empty body"		body _ HtmlBody new.		document addEntity: body ].	document parsingFinished.	^document! !!HtmlParser class methodsFor: 'example' stamp: 'ls 6/27/1998 15:32'!example1	"HtmlParser example1"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser]"></a></body></html>'.	^HtmlParser parse: input! !!HtmlPreformattedRegion methodsFor: 'lint' stamp: 'ls 7/29/1998 00:27'!shouldContain: anEntity	^anEntity isTextualEntity! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!mayContain: anEntity	^true! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!tagName	^'pre'! !!HtmlPreformattedRegion methodsFor: 'formatting' stamp: 'ls 7/13/1998 23:15'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increasePreformatted.	super addToFormatter: formatter.	formatter decreasePreformatted.	formatter ensureNewlines: 1.! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!isTextualEntity	^true! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^true  "end tag required"! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'select'! !!HtmlSelect methodsFor: 'formatting' stamp: 'ls 8/11/1998 03:12'!addToFormatter: formatter	| options defaultOption listMorph names |	names _ OrderedCollection new.	options _ OrderedCollection new.	defaultOption _ nil.	(self getAttribute: 'multiple') ifNotNil: [		self flag: #incomplete.		formatter addString: '[M option list]'.		^self ].	contents do: [ :c |  c isOption ifTrue: [		names add: c value.		options add: c label.		(c getAttribute: 'selected') ifNotNil: [ defaultOption _ c label ] ] ].	contents isEmpty ifTrue: [ ^self ].	defaultOption ifNil: [ defaultOption _ contents first ].	listMorph _ PluggableListMorph on: (ValueHolder new contents: (contents indexOf: defaultOption)) list: nil  selected: #contents  changeSelected: #contents:.	listMorph list: options.	formatter addMorph: listMorph.	formatter currentFormData addInput: (SelectionInput  name: self name  defaultValue: defaultOption  list: listMorph  values: names asArray)! !supposedly decreases the font size its constituents are displayed in!the contents should be displayed struck-through!!HtmlStrikeEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 02:05'!addToFormatter: formatter	formatter increaseStrike.	super addToFormatter: formatter.	formatter decreaseStrike.! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!tagName	^'style'! !an entity to be displayed as a subscript!an entity whose contents are to be displayed as a superscript!!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!mayContain: anEntity	^anEntity isTableRow! !!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 19:07'!tagName	^'table'! !!HtmlTable methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableDataItem methodsFor: 'formatting' stamp: 'ls 9/5/1998 03:37'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureSpaces: 1.! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^true! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:56'!mayContain: anEntity	^anEntity isTextualEntity or: [ anEntity isBlockEntity or: [ anEntity isHeader ] ]! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 19:01'!tagName	^'td'! !a TH tag.  Currently treated the same as a TD!!HtmlTableHeader methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:51'!tagName	^'th'! !!HtmlTableRow methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^true! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!mayContain: anEntity	^anEntity isTableDataItem! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 19:00'!tagName	^'tr'! !An HTML tag, eg <a href="foo.html">!!HtmlTag methodsFor: 'parser support' stamp: 'ls 6/27/1998 13:18'!entityFor	"return an empty entity corresponding to this tag"	| eClass |	eClass _ self class entityClasses at: name ifAbsent: [ ^nil ].	^eClass forTag: self ! !!HtmlTag methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isTag	^true! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:50'!attribs	"return a dictionary mapping attribute names (in lowercase) to their values"	^attribs! !!HtmlTag methodsFor: 'access' stamp: 'ls 6/24/1998 18:53'!isNegated	^isNegated! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:49'!name	"return the basic kind of tag, in lowercase"	^name! !!HtmlTag methodsFor: 'private-initialization' stamp: 'ls 7/14/1998 22:49'!name: name0  negated: isNegated0 attribs: attribs0	"initialize from the given attributes"	name _ name0.	isNegated _ isNegated0.	attribs _ attribs0 ifNil: (Dictionary new).! !!HtmlTag class methodsFor: 'parser support' stamp: 'ar 11/18/1998 21:00'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		embed	HtmlEmbedded		noembed	HtmlNoEmbed		a		HtmlAnchor		br		HtmlBreak		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		th		HtmlTableHeader		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!HtmlTag class methodsFor: 'parser support' stamp: 'ar 11/18/1998 19:27'!initialize	"HtmlTag initialize"	EntityClasses _ nil.! !!HtmlTag class methodsFor: 'instance creation' stamp: 'ls 6/24/1998 18:54'!source: source0  name: name0  negated: negated0 attribs: attribs0	^(super forSource: source0) name: name0 negated: negated0 attribs: attribs0! !A sequence of text without any tags in it.  &sp; style characters have been replaced by their actual values. !!HtmlText methodsFor: 'formatter' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"	aFormatter addText: source! !!HtmlText methodsFor: 'access' stamp: 'ls 1/25/98 04:57'!text	^text! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 8/25/1998 05:47'!initialize: source0	super initialize: source0.	self text: source0 replaceHtmlCharRefs.! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 7/21/1998 01:02'!text: text0	text _ text0.! !!HtmlText methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isText	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:28'!isBlockEntity	"not sure...."	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/29/1998 00:28'!mayContain: anEntity	^true   "really we shouldn't be interpretting tags in here at all, though...."! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/17/1998 19:05'!suppliesInput	^self name ~= nil! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:40'!tagName	^'textarea'! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:17'!columns	| a |	a _ self getAttribute: 'cols' default: '70'.	^(Integer readFrom: (ReadStream on: a)) max: 5.! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:12'!defaultValue	^self textualContents  "it would be nice to through the tags in there, too....  Easiest way would probably be to modiy the tokenizer"! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:16'!rows	| a |	a _ self getAttribute: 'rows' default: '20'.	^(Integer readFrom: (ReadStream on: a)) max: 1.! !!HtmlTextArea methodsFor: 'formatting' stamp: 'ls 8/5/1998 08:50'!addToFormatter: formatter	| inputMorph |	formatter ensureNewlines: 1.	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	inputMorph extent: (self columns * 5) @ (self rows * 8).	formatter addMorph: inputMorph.	formatter currentFormData addInput: (TextInput name: self name  defaultValue:  self textualContents  textMorph: inputMorph).	formatter ensureNewlines: 1.! !!HtmlTextEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:38'!textualContents	^text! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:26'!mayContain: anEntity	^false! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!tagName	"bogus"	^'x-text'  ! !!HtmlTextEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:24'!addToFormatter: aFormatter	aFormatter addString: text! !!HtmlTextEntity methodsFor: 'printing' stamp: 'ls 10/26/1998 17:09'!printHtmlOn: aStream indent: indent 	indent timesRepeat: [aStream space].	aStream nextPutAll: text.! !!HtmlTextEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:28'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '['.	aStream nextPutAll: text.	aStream nextPutAll: ']'.	aStream cr.! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 6/25/1998 02:58'!text	^text! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 7/14/1998 23:58'!text: text0	text _ text0! !includes raw text, font-changing entities like <b> and <em>, and special entities like <a> and <img>.  All of these are relatively low level regarding formatting; they are superceded by higher level things like <li> and <p>.  When formatted, they flow around like characters.!!HtmlTextualEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!isTextualEntity	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!isHeadElement	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:36'!tagName	^'title'! !!HtmlToken methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self subclassResponsibility! !!HtmlToken methodsFor: 'formatting' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"! !!HtmlToken methodsFor: 'printing' stamp: 'ls 1/25/98 05:45'!printOn: aStream	aStream nextPutAll: '{';		nextPutAll: self class name;		nextPut: $:;		nextPutAll: self source;		nextPut: $}.! !!HtmlToken methodsFor: 'private-initialization' stamp: 'ls 1/25/98 05:34'!initialize: s	"default initialization doesn't do much.  subclasses are free to override"	source _ s! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:47'!isComment	"whether this token is an HTML comment"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:38'!isTag	"is this an HTML tag"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:39'!isText	"return whether it is a string of text"	^false! !!HtmlToken methodsFor: 'access' stamp: 'ls 1/25/98 04:48'!source	"the raw source text that composes this token"	^source! !!HtmlToken class methodsFor: 'instance creation' stamp: 'ls 1/25/98 06:01'!forSource: source  	^super new initialize: source! !This class takes a text stream and produces a sequence of HTML tokens.It requires its source stream to support #peek.!!HtmlTokenizer methodsFor: 'private-initialization' stamp: 'ls 9/18/1998 08:06'!initialize: s	text _ s withSqueakLineEndings.	pos _ 1.	textAreaLevel _ 0.! !!HtmlTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/18/1998 08:08'!next 	"return the next HtmlToken, or nil if there are no more"	|token|	"branch, depending on what the first character is"	self atEnd ifTrue: [ ^nil ].	self peekChar = $< 		ifTrue: [ token _ self nextTagOrComment ]		ifFalse: [ token _ self nextText ].	"return the token, modulo modifications inside of textarea's"	textAreaLevel > 0 ifTrue: [		(token isTag and: [ token name = 'textarea' ]) ifTrue: [			"textarea tag--change textAreaLevel accordingly"			token isNegated				ifTrue: [ textAreaLevel _ textAreaLevel - 1 ]				ifFalse: [ textAreaLevel _ textAreaLevel -2 ].			textAreaLevel > 0				ifTrue: [ 					"still inside a <textarea>, so convert this tag to text"					^HtmlText forSource: token source ]				ifFalse: [ "end of the textarea; return the tag"  ^token ] ].			"end of the textarea"		"inside the text area--return the token as text"		^HtmlText forSource: token source ].	(token isTag and: [ token isNegated not and: [ token name = 'textarea' ]]) ifTrue: [		"beginning of a textarea"		inTextArea _ true.		^token ].			^token! !!HtmlTokenizer methodsFor: 'stream protocol' stamp: 'ls 8/20/1998 05:15'!atEnd	"are there any more tokens?  This is equivalent to whether there is any more input"	^(pos > text size)! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!nextChar	| c |	self atEnd ifTrue: [ ^nil ].	c _ text at: pos.	pos _ pos + 1.	^c! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!peekChar	self atEnd ifTrue: [ ^nil ].	^text at: pos! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:33'!nextAttributeValue	"return the next sequence of alphanumeric characters; used to read in the value part of a tag's attribute, ie <tagname  attribname=attribvalue>"	"because of the plethora of sloppy web pages, this is EXTREMELY tolerant"	| c start end |	"make sure there are at least two characters left"	pos >= text size ifTrue: [ ^self nextChar asString ].	"okay, peek at the first character"	start _ pos.	c _ text at: start.	"check whether it's either kind of quote mark"	(c = $" or: [ c = $' ]) ifTrue: [		"yes--so find the matching quote mark"		end _ text indexOf: c startingAt: start+1 ifAbsent: [ text size + 1 ].		pos _ end+1.		^text copyFrom: start to: end ].	"no--go until a space or a $> is seen"	end _ text indexOfAnyOf: CSAttributeEnders startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	pos _ end + 1.	^text copyFrom: start to: end.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextComment	"we've seen < and the next is a !!.  read until the whole comment is done"	"this isn't perfectly correct--for instance <!!--> is considered a proper comment--but it should do for now.  It also picks up <!!DOCTYPE...> tags"	| source c hyphens |		self nextChar.   "swallow the $!!"	source _ WriteStream on: String new.	source nextPutAll: '<!!'.		self peekChar = $- ifFalse: [ 		"this case is wierd.  go until we find a > at all and pray it's the correct end-of-'comment'"		[	self atEnd or: [ self peekChar = $> ] 		] whileFalse: [			c _ self nextChar.			source nextPut: c 		].		self atEnd ifFalse: [ source nextPut: self nextChar ].		^HtmlComment forSource: source contents ].		hyphens _ 0.	[ 	c _ self nextChar.		c = nil or: [			source nextPut: c.			(hyphens >=2 and: [ c = $> ])]	] whileFalse: [		c = $- ifTrue: [ hyphens _ hyphens + 1 ] ifFalse: [ hyphens _ 0 ]	].			^HtmlComment forSource: source contents.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:24'!nextName	"return the next sequence of alphanumeric characters"	"because of the plethora of sloppy web pages, this also accepts most non-space characters"	| start end |	start _ pos.	end _ text indexOfAnyOf: CSNameEnders startingAt: start ifAbsent: [ text size + 1].	end _ end - 1.	pos _ end+1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:23'!nextSpaces	"read in as many consecutive space characters as possible"	| start end |	"short cut for a common case"	self peekChar isSeparator not ifTrue: [ ^'' ].	"find the start and end of the sequence of spaces"	start _ pos.	end _ text indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	"update pos and return the sequence"	pos _ end + 1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:43'!nextTag	"we've seen a < and peek-ed something other than a !!.  Parse and return a tag"	| source negated name attribs attribName attribValue sourceStart sourceEnd c |		sourceStart _ pos-1.	attribs _ Dictionary new.	"determine if its negated"	self peekChar = $/ 		ifTrue: [ negated _ true.  self nextChar. ]		ifFalse: [ negated _ false ].	"read in the name"	self skipSpaces.	name _ self nextName.	name _ name asLowercase.	"read in any attributes"	[ 	self skipSpaces.		c _ self peekChar.		c = nil or: [c isLetter not ]	] whileFalse: [		attribName _ self nextName.		attribName _ attribName asLowercase.		self skipSpaces.		self peekChar = $= 			ifTrue: [ 				self nextChar.				self skipSpaces.				attribValue _ self nextAttributeValue withoutQuoting  ]			ifFalse: [ attribValue _ '' ].		attribs at: attribName  put: attribValue ].	self peekChar = $> ifTrue: [ self nextChar ].	sourceEnd _ pos-1.	source _ text copyFrom: sourceStart to: sourceEnd.	^HtmlTag source: source name: name asLowercase negated: negated attribs: attribs! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextTagOrComment	"next character is a $<.  So read either a tag or a token"	self nextChar.  "skip the $<"	^self peekChar = $!! 		ifTrue: [ self nextComment ]		ifFalse: [ self nextTag ]! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:34'!nextText	"returns the next textual segment"	|start end|	start _ pos.	end _ (text indexOf: $< startingAt: start ifAbsent: [ text size + 1 ]) - 1.	pos _ end+1.	^HtmlText forSource: (text copyFrom: start to: end)! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:26'!skipSpaces	"skip as many consecutive space characters as possible"	pos _ text indexOfAnyOf: CSNonSeparators startingAt: pos ifAbsent: [ text size + 1 ].! !!HtmlTokenizer class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 05:13'!on: aStream	^super basicNew initialize: aStream contents! !!HtmlTokenizer class methodsFor: 'initialization' stamp: 'ls 8/19/1998 09:09'!initialize	"HtmlTokenizer initialize"	CSAttributeEnders _ CharacterSet empty.	CSAttributeEnders addAll: Character separators.	CSAttributeEnders add: $>.		CSNameEnders _ CharacterSet empty.	CSNameEnders addAll: '=>'.	CSNameEnders addAll: Character separators.	CSNonSeparators _ CharacterSet separators complement.! !!HtmlUnderlineEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 01:41'!addToFormatter: formatter	formatter increaseUnderline.	super addToFormatter: formatter.		formatter decreaseUnderline.! !!HtmlUnorderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startUnorderedList.	super addToFormatter: formatter.	formatter endUnorderedList.! !!HtmlUnorderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ul'! !A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URLrealm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.Passwords = a Dictionary of (realm -> encoded user&password)!!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 23:08'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: Sensor cursorPoint - (50@0).	password _ FillInTheBlank request: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:25'!postFormArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self postFormArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self postFormArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:49'!privateInitializeFromText: aString relativeTo: aUrl	super privateInitializeFromText: aString relativeTo: aUrl.	realm _ aUrl realm.! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:47'!realm	^ realm! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContents	^ self retrieveContentsArgs: nil! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContentsArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpGetDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self retrieveContentsArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self retrieveContentsArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl class methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 23:13'!shutDown	"Forget all cached passwords, so they won't stay in the image"	Passwords _ nil.! !holds various info on a channel that the user is a member of.!!IRCChannelInfo methodsFor: 'messages' stamp: 'ls 9/5/1998 00:40'!sendMessage: aString	"send a message on the channel"	connection privmsgFrom: nil  to: name  text: aString! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:17'!addMember: memberName	"note that memberName is on the channel.  memberName should be given in the user's preferred capitalization"	members add: memberName.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!addMembers: list	members addAll: list.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 10:07'!changeTopic: aText	"attempt to change the topic"	connection sendMessage: (IRCProtocolMessage		command: 'TOPIC'		arguments: (Array with: self name with: aText asString)).	^true! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:44'!connection	"return the IRC connection I am watching"	^connection! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!memberNames	"names of the clients subscribing to this channel"	^members! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!name	"name of the channel, in its preferred capitalization"	^name! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:39'!removeMember: memberName	"note that memberName has left (PART-ed or QUIT-ed) the channel"	members remove: memberName ifAbsent: [ ^self ].	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:41'!subscribe: anObject	"add anObject as a subscriber.  anObject must respond to ircMessageRecieved"	subscribers isEmpty ifTrue: [ connection join: name ].	subscribers add: anObject! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!subscribers	"collection of objects watching for messages on the channel"	^subscribers! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:52'!topic	^topic ifNil: ['']! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:53'!topic: aString	topic _ aString.	self changed: #topic! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:39'!unsubscribe: anObject	"unsubscribe anObject"	subscribers remove: anObject.	subscribers isEmpty ifTrue: [ connection leave: name ].! !!IRCChannelInfo methodsFor: 'private-initialization' stamp: 'ls 9/6/1998 20:23'!initializeName: aString  connection: aConnection	name _ aString.	members _ Set new.	subscribers _ IdentitySet new.	connection _ aConnection! !!IRCChannelInfo methodsFor: 'interface' stamp: 'ls 9/17/1998 09:21'!openUserList	"open a listing with all the users on this channel"	^IRCChannelUsersBrowser openOnChannel: self! !!IRCChannelInfo class methodsFor: 'instance creation' stamp: 'ls 9/6/1998 20:22'!forChannelNamed: aString  onConnection: connection	"create an instance for the channel with the given name"	^super new initializeName: aString connection: connection! !a browser of the list of channels a given connection offers.  Allows users to easily join and create channels.!!IRCChannelListBrowser methodsFor: 'private-initialization' stamp: 'ls 9/17/1998 11:23'!initialize: anIRCConnection	connection _ anIRCConnection.	channelList _ #().	channelIndex _ 0.	sortCriterion _ #name.	anIRCConnection addDependent: self.	self refreshChannelList.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 11/24/1998 08:38'!refreshChannelList	"update the list of channels"	| sortBlock |	channelList _ connection channelList.	channelList ifNil: [ channelList _ #() ].	"sort the channels"	sortCriterion = #name ifTrue: [		sortBlock _ [ :a :b | a name asIRCLowercase < b name asIRCLowercase ] ]	ifFalse: [		sortBlock _ [ :a :b |		a numUsers = b numUsers			ifTrue: [ a name asIRCLowercase < b name asIRCLowercase ]			ifFalse: [ a numUsers > b numUsers ] ] ].	channelList _ channelList asSortedCollection: sortBlock.	channelList _ channelList asArray.		channelIndex _ 0.	self changed: #channelDescriptions.	self changed: #channelIndex.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 07:00'!update: aSymbol	aSymbol == #channelList ifTrue: [		self refreshChannelList ].! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!createChannel	|  channelName |	channelName _ FillInTheBlank request: 'channel name'.	channelName isEmpty ifTrue: [ ^self ].	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 22:07'!openMorphicView	| win descListView updateButton actionColumn openChannelButton createChannelButton |	win _ SystemWindow new.	win setLabel: 'Channel Listing'.	win model: self.	descListView _ PluggableListMorph on: self  list: #channelDescriptions selected: #channelIndex changeSelected: #channelIndex:.	win addMorph: descListView  frame: (0@0 extent: 0.8@0.9).	updateButton _ PluggableButtonMorph on: connection getState: nil action: #requestChannelList.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	actionColumn _ AlignmentMorph newColumn.	openChannelButton _ PluggableButtonMorph on: self getState: nil action: #openSelectedChannel.	openChannelButton label: 'join channel'.	actionColumn addMorphBack: openChannelButton.	createChannelButton _ PluggableButtonMorph on: self getState: nil action: #createChannel.	createChannelButton label: 'create channel'.	actionColumn addMorphBack: createChannelButton.	win addMorph: actionColumn  frame: (0.8@0 extent: 0.2@0.9).	win openInWorld! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!openSelectedChannel	| channelInfo channelName |	channelInfo _ channelList at: channelIndex ifAbsent: [ ^self ].	channelName _ channelInfo name.	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 21:28'!openView	^self openMorphicView! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/17/1998 06:59'!channelDescriptions	^channelList collect: [ :channel |		channel name, '(', channel numUsers printString, ')    ', channel topic].! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:34'!channelIndex	^channelIndex! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:53'!channelIndex: anInteger	channelIndex _ anInteger.	self changed: #channelIndex! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:35'!forConnection: connection	^super new initialize: connection! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:36'!openForConnection: connection	(self forConnection: connection) openView! !converts IRC messages forwarded to it, into a textual format that may be displayed.  Messages may additionally sent *from* it, to a specified target.!!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 17:51'!chatAreaSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 19:59'!chatText	^chatText! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatTextSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:58'!connection: anIRCConnection channelName: aString	connection _ anIRCConnection.	channel _ connection channelInfo: aString.	channel subscribe: self.	chatText _ Text new.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 12/10/1998 20:45'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	chatText _ chatText, newLine.	chatText size > 2000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 1000) to: chatText size ].	self changed: #chatText.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 10:22'!openMorphicView	"open a view for interacting with this collector"	| win textArea inputArea topicArea usersButton |	win _ SystemWindow new.	win setLabel: channel name.	win model: self.	topicArea _ PluggableTextMorph on: channel  text: #topic  accept: #changeTopic:.	topicArea acceptOnCR: true.	win addMorph: topicArea frame: (0@0 extent: 0.9@0.1).	usersButton _ PluggableButtonMorph on: channel  getState: nil  action: #openUserList.	usersButton label: 'users'.	win addMorph: usersButton frame: (0.9@0 extent: 0.1@0.1).	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	win addMorph: textArea frame: (0@0.1 extent: 1@0.8).	inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.	inputArea acceptOnCR: true.	win addMorph: inputArea frame: (0@0.9 extent: 1@0.1) .	win openInWorld.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 20:59'!openView	"open a view for interacting with this collector"	^self openMorphicView! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!release	super release.	channel unsubscribe: self! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!sendMessage: aText	channel sendMessage: aText asString.	^true! !!IRCChannelObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 08:56'!openForChannelNamed: channelName  onConnection: connection 	^(super new connection: connection  channelName: channelName) openView! !very basic info on an IRC channel; specifically, that returned by a LIST command!!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:39'!name	"the name of the channel"	^name! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!numUsers	"number of users currently on the channel"	^numUsers! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!topic	"the current topic of discussion"	^topic! !!IRCChannelSummary methodsFor: 'printing' stamp: 'ls 9/2/1998 23:35'!printOn: aStream	aStream nextPutAll: 'IRCChannel '.	aStream nextPutAll: self name.	aStream nextPutAll: ' ('.	aStream nextPutAll: numUsers printString.	aStream nextPutAll: ')'.! !!IRCChannelSummary methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 22:38'!initializeName: aString  numUsers: anInteger  topic: anotherString	name _ aString.	numUsers _ anInteger.	topic _ anotherString.! !!IRCChannelSummary class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 22:39'!name: cname  numUsers: numUsers  topic: topic	^super new initializeName: cname  numUsers: numUsers  topic: topic! !Used for browsing the list of users on a particular channel.!!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!onChannel: aChannel	channel _ aChannel.	userList _ #().	userIndex _ 0.	channel addDependent: self.	self refreshUserList.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:47'!openAsMorph	| win listView talkToButton |	win _ SystemWindow labelled: 'users in ', channel name.	win model: self.	listView _ PluggableListMorph on: self list: #userList selected: #userIndex  changeSelected: #userIndex:.	win addMorph: listView  frame: (0@0 extent: 1@0.9).	talkToButton _ PluggableButtonMorph on: self getState: nil action: #talkTo.	talkToButton label: 'talk to selected user'.	win addMorph: talkToButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:18'!openView	^self openAsMorph! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:22'!refreshUserList	"update the user list from the channel"	|oldName |	(userIndex > 0) ifTrue: [		oldName _ userList at: userIndex ].	userList _ channel memberNames asSortedCollection asArray.	userIndex _ 0.	oldName ifNotNil: [		"try to select the same user again"		userIndex _ userList indexOf: oldName ].	self changed: #userList.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:42'!selectedUser	"return the name of the selected user, or nil if none"	^userList at: userIndex ifAbsent: [nil ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:43'!talkTo	"open a window for talking to the selected user"	| user |	user _ self selectedUser.	user ifNil: [ ^self ].	^IRCDirectMessagesObserver openForConnection: channel connection   talkingTo: user! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!update: aSymbol	aSymbol == #memberNames ifTrue: [ self refreshUserList ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userIndex	"return the index in userList of the user currently selected"	^userIndex! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:25'!userIndex: anInteger	"change which user is selected"	userIndex _ anInteger.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userList	"return the current list of user names"	^userList! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!onChannel: channel	^self new onChannel: channel! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!openOnChannel: channel	^(self onChannel: channel) openView! !A connection to an IRC server.  This handles spooling messages in and out, and converts between network commands and more convenient data structures.Start up an instance along with an interface with:		IRCConnection new openView!!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCConnection methodsFor: 'access' stamp: 'jm 10/3/1998 08:37'!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/6/1998 20:23'!channelInfo: channelName	"return cached info on a channel"	| lChannelName |	lChannelName _ channelName asIRCLowercase.	^subscribedChannels at: lChannelName ifAbsent: [ 		"no info available--create and return a skeleton"		subscribedChannels at: lChannelName put:			(IRCChannelInfo forChannelNamed: channelName  onConnection: self) ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:35'!channelList	"returns the list of channels, or nil if it hasn't been retrieved yet"	^channelList! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:53'!channelListReport	"list the channels in a textual format"	| list |	list _ self channelList.	list ifNil: [ ^'(info not available)' ].	^String streamContents: [ :stream |		stream nextPutAll: 'Channel List'; cr.		stream nextPutAll: '--------------'; cr.		list do: [ :channel |			stream nextPutAll: channel name.			stream nextPutAll: '('.			stream nextPutAll: channel numUsers printString.			stream nextPutAll: ')		['.			stream nextPutAll: channel topic.			stream nextPutAll: ']'.			stream cr ] ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:18'!motd	"return the most recently seen Message of the Day, or nil if none has been seen yet"	^motd! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 06:51'!initialize	self reset.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	directMessageSubscribers _ IdentitySet new.	protocolMessageSubscribers _ IdentitySet new.	consoleText _ Text new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 08:44'!reset	"prepare for a new connection"	recieveBuffer _ String new.	protocolMessagesToSend _ OrderedCollection new.	sendBuffer _ nil.	socket _ nil.	channelList _ nil.	channelListBeingBuilt _ nil.	motd _ nil.	motdBeingBuilt _ nil.	messagesProcessed _ 0.	subscribedChannels _ Dictionary new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/4/1998 23:22'!step	self processIO! !!IRCConnection methodsFor: 'private' stamp: 'di 1/14/1999 09:12'!wantsSteps	^ true! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:38'!processChannelList: aMessage	"an item has arrived in the list of channels"	| chanName chanNumUsers chanTopic |	aMessage arguments size < 4 ifTrue: [ ^self ].	chanName _ aMessage arguments at: 2.	chanNumUsers _ (aMessage arguments at: 3) asNumber.	chanTopic _ (aMessage arguments at: 4).	chanName = '*' ifTrue: [ ^self ].	channelListBeingBuilt ifNil: [ channelListBeingBuilt _ OrderedCollection new ].	channelListBeingBuilt add: (IRCChannelSummary name: chanName numUsers: chanNumUsers topic: chanTopic). ! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:39'!processChannelListEnd: aMessage	"a complete channel listing has arrived"	"end of a channel listing"	channelList _ channelListBeingBuilt asArray.	channelListBeingBuilt _ nil.	self changed: #channelList. 	self changed: #channelListReport.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:37'!processChannelListStart: aMessage	"start of a channel listing"	channelListBeingBuilt _ OrderedCollection new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 09:33'!processJoin: aMessage	"a user is joining a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) addMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 08:48'!processMessage: aMessage	| handler |	protocolMessageSubscribers do: [ :subscriber |		subscriber ircProtocolMessage: aMessage ].	handler _ MessageHandlers at: aMessage command ifAbsent: [ nil ].	handler ifNil: [	^self ].	^self perform: handler  with: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotd: aMessage	"a new line has arrived for the MOTD"	motdBeingBuilt nextPutAll: aMessage arguments second.	motdBeingBuilt cr.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotdEnd: aMessage	"the whole MOTD has arrived"	motd _ motdBeingBuilt contents.	motdBeingBuilt _ nil.	self changed: #motd.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:35'!processMotdStart: aMessage	"MOTD is being transmitted"	motdBeingBuilt _ WriteStream on: String new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:19'!processNamReply: aMessage	"list of names for a channel, probably a channel being joined"	| names lChannelName channelInfo |	names _ aMessage arguments last findTokens: ' '.	names _ names collect: [ :origName |		('+@' includes: origName first) 			ifTrue: [ origName copyFrom: 2 to: origName size ]			ifFalse: [ origName ] ].	lChannelName _ (aMessage arguments at: 3) asIRCLowercase.	channelInfo _ subscribedChannels at: lChannelName ifAbsent: [nil].	channelInfo ifNotNil: [ channelInfo addMembers: names ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:07'!processNoTopic: aMessage	"remove a channel's topic"	(self channelInfo: (aMessage arguments at: 2)) topic: ''! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 12/10/1998 23:16'!processPart: aMessage	"a user is leaving a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) removeMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPing: aMessage	"ping request"	self sendMessage: (IRCProtocolMessage command: 'pong' arguments: aMessage arguments).! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPrivmsg: aMessage	"handle a PRIVMSG or NOTICE message"	| sender recipient text privMessage info |	"put together the message"	sender _ aMessage prefix.	recipient _ aMessage arguments at: 1.	text _ aMessage arguments at: 2.	privMessage _ IRCMessage sender: sender  recipient: recipient  text: text.	"broadcast the message to all subscribers"	info _ subscribedChannels at: recipient asIRCLowercase ifAbsent: [ nil ].	info ifNotNil: [ info subscribers do: [ :sub |		sub ircMessageRecieved: privMessage ] ].	recipient asIRCLowercase = nick asIRCLowercase ifTrue: [		directMessageSubscribers do: [ :sub |			sub ircMessageRecieved: privMessage ] ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 12/11/1998 00:15'!processQuit: aMessage	"a user has left IRC.  Remove them from all chanels"	|  user |	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	subscribedChannels do: [ :channel |		(channel memberNames includes: user) 			ifTrue: [ channel removeMember: user ] ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:14'!processTopic: aMessage	"change a channel topic"	| args |	args _ aMessage arguments.	args size < 2 ifTrue: [ "malformed message" ^self ].	(self channelInfo: (args at: (args size-1))) topic: (args at: args size).! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:18'!consoleMenu: menu	^menu		labels: 'connect\disconnect\message of the day\channel list\talk to individual\inspect me' withCRs		lines: #(2 4 5)		selections: #(openConnectionDialogue disconnect openMotd openChannelList talkTo inspect)! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:17'!talkTo	"talk to some user using 1-to-1 chat messages"	| user |	user _ FillInTheBlank request: 'user to talk to'.	user _ user withBlanksTrimmed.	user isEmpty ifTrue: [ ^self ].	IRCDirectMessagesObserver openForConnection: self  talkingTo: user! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:42'!addToConsole: aText	"add aString to the text being displayed on console."	consoleText _ consoleText, aText.	consoleText size > 2000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 1000) to: consoleText size ].	self changed: #consoleText.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:41'!consoleText	^consoleText! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:43'!consoleTextSelection	| size |	size _ self consoleText size.	^size+1 to: size! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:55'!openAsMorph	| win consolePane inputPane |	"build views"	win _ SystemWindow labelled: 'IRC'.	win model: self.	consolePane _ PluggableTextMorph on: self text: #consoleText accept: nil readSelection: #consoleTextSelection menu: #consoleMenu:.	win addMorph: consolePane frame: (0@0 extent: 1@0.9).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendRawCommand:.	inputPane acceptOnCR: true.	win addMorph: inputPane  frame: (0@0.9 extent: 1@0.1).	"subscribe to protocol messages and direct messages, so we can display them on console"	self subscribeToDirectMessages: self.	self subscribeToProtocolMessages: self.	win openInWorld! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:32'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:58'!openConnectionDialogue	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph textEntryList |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	textEntryList _ OrderedCollection new.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		textEntry acceptOnCR: true.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		textEntryList add: textEntry.		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: [			textEntryList do: [ :m | m hasUnacceptedEdits ifTrue:[ m accept ] ].			self connect 		] getState: nil action: #value.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 01:12'!openDirectMessagesObserver	IRCDirectMessagesObserver openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openMotd	"open a view on the MOTD"	| win textView updateButton |	win _ SystemWindow labelled: 'MOTD'.	textView _ PluggableTextMorph on: self text: #motd accept: nil.	win addMorph: textView  frame: (0@0 extent: 1@0.9).	updateButton _ PluggableButtonMorph on: self getState: nil action: #requestMotd.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openView	^self openAsMorph! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:45'!perform: aSelector  orSendTo: editor	(self respondsTo: aSelector) ifTrue: [		^self perform: aSelector ].	^editor perform: aSelector! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:36'!release	super release.	self disconnect.! !!IRCConnection methodsFor: 'UI' stamp: 'jm 10/3/1998 08:43'!sendRawCommand: aString	"Send a command directly."	| message |	message _ [IRCProtocolMessage fromString: aString asString] ifError: [:a :b | nil].	message ifNil: [^ false].	self sendMessage: message.	^ true! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/6/1998 20:21'!subscribe: anObject toChannel: channelName	"send all messages for channelName to anObject.  anObject must implemented #ircMessageReceieved:"	|  info |	info _ self channelInfo: channelName.	info subscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 18:06'!subscribeToDirectMessages: anObject	"send all messages directly to the user's nick to anObject.  anObject must implemented #ircMessageReceieved:"	directMessageSubscribers add: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/15/1998 06:30'!subscribeToProtocolMessages: anObject	"anObject should respond to #ircProtocolMessage:.  It will be sent all incoming messages"	protocolMessageSubscribers add: anObject! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:38'!unsubscribe: anObject fromChannel: channelName	"see subscribe:toChannel:"	|  lChannelName info |	lChannelName _ channelName asIRCLowercase.	info _ subscribedChannels at: lChannelName ifAbsent: [ ^self ].	info unsubscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:10'!unsubscribeFromDirectMessages: anObject 	"see #subscribeFromDirectMessages:"	directMessageSubscribers remove: anObject ifAbsent: []! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!join: channelName	"join a channel"	self sendMessage: (IRCProtocolMessage		command: 'join'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!leave: channelName	"leave a channel"	self sendMessage: (IRCProtocolMessage		command: 'part'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/12/1998 04:54'!privmsgFrom: from  to: to  text: text	"send a private message.  'to' can be a channel name...."	| msg |	msg _ (IRCProtocolMessage		prefix: from		command: 'privmsg'		arguments: (Array with: to  with: text)).	self processMessage: msg.	"because these aren't sent back by default"	self sendMessage: msg.! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!quit	"tell the server we are leaving"	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:36'!requestChannelList	"request a list of all channels"	self sendMessage: (IRCProtocolMessage command: 'list')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:18'!requestMotd	self sendMessage: (IRCProtocolMessage command: 'motd')! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 23:30'!connect	"connect to a server"	| addr |	Socket initializeNetwork.	socket ifNotNil: [ socket destroy ].	self reset.	Utilities informUser: 'looking up server address...' during: [		addr _ NetNameResolver addressForName: server ].	addr ifNil: [ ^PopUpMenu notify: 'could not find address for ', server ].	socket _ Socket new.	socket connectTo: addr  port: port.	self sendMessage: (IRCProtocolMessage fromString: 'NICK ', nick).	self sendMessage: (IRCProtocolMessage fromString: 'USER ', userName, ' * * :', fullName).! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 21:27'!disconnect		"disconnect from the server"	socket ifNotNil: [ socket isValid ifTrue: [ 		Transcript show: 'disconnecting from IRC', String cr.		socket close ] ].		socket _ nil.! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 17:45'!isConnected	"whether we are currently connected"	^socket ~~ nil  and: [ socket isConnected ]! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/3/1998 00:19'!processIO	"do as much network IO as is immediately possible"		| amount idx messageText message |	"do nothing if the socket isn't ready for work"	(socket isNil or: [socket isValid not or: [ socket isConnected not ]]) ifTrue: [ 		"Transcript show: 'socket not ready; no IO done'; cr."		^self ].	"first do sending"	[ socket sendDone and: [ sendBuffer isNil not or: [ protocolMessagesToSend size > 0 ] ] ]	whileTrue: [		sendBuffer ifNil: [			protocolMessagesToSend isEmpty ifFalse: [				sendBuffer _ protocolMessagesToSend removeFirst asString ] ].		sendBuffer ifNotNil: [			amount _ socket sendSomeData: sendBuffer.			sendBuffer _ sendBuffer copyFrom: amount+1 to: sendBuffer size.			sendBuffer isEmpty ifTrue: [ sendBuffer _ nil ] ].	].	"now do receiving"	[ socket dataAvailable ] whileTrue: [ 		recieveBuffer _ recieveBuffer, socket getData ].	"parse as many messages as possible"	[ idx _ recieveBuffer indexOf: Character lf.  	  idx > 0 ] whileTrue: [		messageText _ recieveBuffer copyFrom: 1 to: idx.		message _ IRCProtocolMessage fromString: messageText.				self processMessage: message.		recieveBuffer _ recieveBuffer copyFrom: idx+1 to: recieveBuffer size ].! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 21:53'!sendMessage: aMessage	"queue a message for sending"	protocolMessagesToSend addLast: aMessage.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:49'!ircMessageRecieved: aMessage	| sender newLine |	Smalltalk beep.	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToConsole: newLine.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:47'!ircProtocolMessage: msg	"a new message.  log it on the console, unless it's a channel listing"	(msg command ~= IRCConnection RPLList printString	and: [ msg command ~= IRCConnection RPLMotd ]) ifTrue: [		self addToConsole: msg asString ].! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLAway	"someone has marked themselves as away"	^301! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLBanList	""	^367! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLChannelModeIs	""	^324! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLEndOfBanList	""	^368! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfLinks	""	^365! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:10'!RPLEndOfMotd	"the MOTD has been completely transmitted"	^376! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfNames	""	^366! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLEndOfWho	"end of responses to a WHO"	^315! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLEndOfWhoIs	""	^318! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLEndOfWhoWas	""	^369! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLInviting	"inform that you are inviting someone to a channel"	^341! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLLinks	""	^364! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLList	"one item in a list command"	^322! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListEnd	"marks end of listing from a LIST command"	^323! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListStart	"start of response to a LIST command"	^321! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:45'!RPLMotd	"a line from the MOTD"	^372! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/3/1998 18:17'!RPLMotd2	"secondd version of a line from the MOTD"	^377! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLMotdStart	"a MOTD listing is beginning"	^375! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLNamReply	""	^353! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLNoTopic	"no topic is set for the given channel"	^331! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLNowaway	"something to do with AWAY"	^306! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLSummoning	"inform that you are summoning a user"	^342! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLTopic	"topic for the given channel"	^332! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLUnaway	"someone has marked themselves as unaway"	^305! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLVersion	"version info for the server"	^351! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoIsIdle	""	^317! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsOperator	""	^313! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsServer	""	^312! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsUser	""	^311! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLWhoReply	"response to a WHO"	^352! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLWhoWasUser	""	^314! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoisChannels	""	^319! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 10:10'!initialize	"IRCConnection initialize"	self initializeMessageHandlers.	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 12/11/1998 00:16'!initializeMessageHandlers	"initilize the table mapping IRC commands to processing methods"	"IRCConnection initializeMessageHandlers"	MessageHandlers _ Dictionary new.	#(		372		processMotd:		377		processMotd:		375		processMotdStart:		376		processMotdEnd:		ping	processPing:		join		processJoin:		part	processPart:		quit		processQuit:		privmsg		processPrivmsg:		notice		processPrivmsg:		321		processChannelListStart:		322		processChannelList:		323		processChannelListEnd:		331		processNoTopic:		332		processTopic:		topic	processTopic:		353		processNamReply:	) pairsDo: [ :command  :method |		MessageHandlers at: command asString put: method ].! !!IRCConnection class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:31'!new	^super new initialize! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!addToChatText: aString	chatText _ chatText, aString.	chatText size > 1000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 500) to: chatText size ].	self changed: #chatText.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatAreaSelection 	^self chatTextSelection! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:52'!chatText	^chatText! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!chatTextSelection	^chatText size+1 to: chatText size! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:01'!initialize: aConnection	connection _ aConnection.	chatText _ Text new.	connection subscribeToDirectMessages: self.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	talkingTo ifNotNil: [		"only display messages to or from talkingTo"		sender asIRCLowercase = talkingTo asIRCLowercase ifFalse: [^self ] ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToChatText: newLine.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:15'!openMorphicView	"open a view for messages sent here"	| win textArea inputArea |	win _ SystemWindow new.	win setLabel: (talkingTo ifNotNil: [ talkingTo ] ifNil: [ 'private messages' ]).	win model: self.	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	talkingTo		ifNil: [ win addMorph: textArea frame: (0@0 extent: 1@1) ]		ifNotNil: [			win addMorph: textArea  frame: (0@0 extent: 1@0.9).			inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.			inputArea acceptOnCR: true.			win addMorph: inputArea  frame: (0@0.9 extent: 1@0.1) ].	win openInWorld.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:53'!openView	^self openMorphicView! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/8/1998 04:55'!release	connection unsubscribeFromDirectMessages: self.	super release.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:09'!sendMessage: aString	"send a message to the user we are talking to"	| newLine |	talkingTo ifNil: [ Smalltalk beep.  ^self ].	connection privmsgFrom: nil  to: talkingTo  text: aString.	newLine _ (Text string: 'me' attribute: TextEmphasis bold),		': ', aString, String cr.	self addToChatText: newLine.	^true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:38'!talkingTo: aName	"set who this window is for talking to"	talkingTo _ aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!forConnection: aConnection	^super new initialize: aConnection! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!forConnection: aConnection  talkingTo: aName	^(super new initialize: aConnection) talkingTo: aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!openForConnection: aConnection	^(self forConnection: aConnection) openView! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!openForConnection: aConnection  talkingTo: aName	^(self forConnection: aConnection talkingTo: aName) openView! !A message on IRC.  It has a sender (usually a username), a recipient (usually a user or channel name), and some text.!!IRCMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:14'!initializeSender: sender0  recipient: recipient0  text: text0	sender _ sender0.	recipient _ recipient0.	text _ text0.! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!recipient	"name the message is destined to"	^recipient! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!sender	"name of the message's sender"	^sender! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!text	"message text"	^text! !!IRCMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 17:15'!sender: sender  recipient: recipient  text: text	"create a new message with the given sender, recipient, and text"	^super new initializeSender: sender  recipient: recipient text: text! !A pattern for matching IRC messages.  Currently one can only match on the sender or the reciever.!!IRCMessagePattern methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:41'!sender: sender0  recipient: recipient0	sender _ sender0.	recipient _ recipient0.! !!IRCMessagePattern methodsFor: 'filtering' stamp: 'ls 9/2/1998 17:42'!matches: aMessage	"decide whether the message matches this pattern"	sender ifNotNil: [ sender = aMessage sender ifFalse: [ ^false ] ].	recipient ifNotNil: [ recipient = aMessage recipient ifFalse: [ ^false ] ].	^true! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!recipient: recipient	"create a pattern matching messages to the given recipient"	^self sender: nil  recipient: recipient! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:10'!sender: sender	"create a pattern for messages from the given sender"	^self sender: sender  recipient: nil! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!sender: sender  recipient: recipient	"create a pattern matching messages from the given sender and to the given recipient"	^super new sender: sender  recipient: recipient! !holds some subset of the messages coming in from an IRC connection.  subclasses define specific criteria for filtering the messages.!!IRCMessageSet methodsFor: 'as yet unclassified' stamp: 'ls 8/21/1998 10:39'!acceptMessage: ircMessage	"whether the given message should be accepted by this set"	^self subclassResponsibility! !A Morph for interfacing with IRC.!!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!addToConsole: aText	consoleText _ consoleText, aText.	consoleText size > 1000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 500) to: consoleText size ].	self changed: #consoleText.! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!consoleSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:17'!consoleTextSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!step	connection processIO.! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:17'!stepTime	^0! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!wantsSteps	^true! !!IRCMorph methodsFor: 'initialization' stamp: 'ls 9/4/1998 23:13'!initialize 	|  connectButton column channelListButton motdButton consoleView inputPane |	super initialize.	connection _ IRCConnection new.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	self setLabel: 'IRC'.	self extent: 200@100.	column _ AlignmentMorph newColumn.	connectButton _ PluggableButtonMorph		on: self		getState: nil		action: #openConnection.	connectButton label: 'connect to server'.	column addMorphBack: connectButton.	motdButton _ PluggableButtonMorph		on: self		getState: nil		action: #openMotd.	motdButton label: 'view MOTD'.	column addMorphBack: motdButton.	channelListButton _ PluggableButtonMorph		on: self		getState: nil		action: #openChannelList.	channelListButton label: 'channel list'.	column addMorphBack: channelListButton.	self addMorph: column frame: (0@0 extent: 0.4@0.8).	consoleText _ Text new.	consoleView _ PluggableTextMorph on: self  text: #consoleText accept: nil readSelection: #consoleTextSelection menu: nil.	self addMorph: consoleView frame: (0.4@0 extent: 0.6@0.8).	consoleView color: (Color r: 0.937 g: 0.937 b: 0.937).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendCommand:.	self addMorph: inputPane frame: (0@0.8 corner: 1@1).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:29'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu  hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'connect to server' action: #makeConnection.	aCustomMenu addLine.	aCustomMenu add: 'view MOTD' action: #openMotd.	aCustomMenu add: 'view channel list' action: #openChannelList.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:12'!connect	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection subscribeToDirectMessages: self.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 18:10'!delete	super delete.	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 22:11'!ircMessageRecieved: aMessage	| sender |	sender _ aMessage sender ifNil: [ nick ].	self addToConsole: (		sender asText,		': ',		aMessage text,		String cr).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:57'!makeConnection	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection requestChannelList.    "this is usually necessary, so go ahead and ask for it"! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 23:11'!openChannel: name	"open a window for interacting with the given channel"	IRCChannelObserver openForChannel: name  onConnection: connection ! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:35'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: connection! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 17:57'!openConnection	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: self getState: nil action: #connect.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:44'!openMotd	connection openMotd! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/8/1998 04:55'!release	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.	super release.! !!IRCMorph methodsFor: 'interface' stamp: 'jm 10/3/1998 08:44'!sendCommand: aString	| message |	[message _ IRCProtocolMessage fromString: aString asString] ifError: [nil].	message ifNil: [^ false].	connection sendMessage: message.	^ true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/4/1998 18:49'!consoleText	^consoleText! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCMorph methodsFor: 'access' stamp: 'jm 10/3/1998 08:37'!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCMorph class methodsFor: 'misc' stamp: 'ls 9/4/1998 18:53'!hasPrototype	"it's not needed here...."	^false! !!IRCMorph class methodsFor: 'initialization' stamp: 'ls 9/3/1998 20:42'!initialize 	"set all the defaults to something reasonable"	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !A low-level IRC message; this is an internal format for what actually goes over the wire.!!IRCProtocolMessage methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:57'!quit	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!arguments	"return the arguments to the command"	^arguments! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:48'!command	"return the main command, in lowercase"	^command! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!prefix	"return the prefix of the message, or nil if none"	^prefix! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 21:49'!prefix: aString  command: anotherString  arguments: aCollection	prefix _ aString.	command _ anotherString asLowercase.	arguments _ aCollection.! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'ls 9/2/1998 21:49'!asString	"encode in the format used for transferral over the network"	^String streamContents: [ :stream |		prefix ifNotNil: [			stream nextPut: $:.			stream nextPutAll: prefix.			stream space ].		stream nextPutAll: command asUppercase.		stream space.		arguments isEmpty ifFalse: [			"print out all but the last argument"			(arguments copyFrom: 1 to: (arguments size - 1)) do: [ :arg |				stream nextPutAll: arg.				stream space ].						"print the last as a trailer, just to be safe"			stream nextPut: $:.			stream nextPutAll: arguments last. ].		stream nextPut: Character cr.		stream nextPut: Character lf. ]! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString	^self command: anotherString  arguments: Array new! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString  arguments: aCollection	^self prefix: nil  command: anotherString  arguments: aCollection! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:47'!fromString: aString	"parse an IRC message from its network format"	| remainder trailerStart trailer tokens command  arguments prefix idx |	remainder _ aString.	"strip the CRLF"	idx _ remainder indexOf: Character cr.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	idx _ remainder indexOf: Character lf.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	"check if there is a trailer"	trailerStart _ remainder indexOf: $: startingAt: 2 ifAbsent: [0].	trailerStart > 0 ifTrue: [		trailer _ remainder copyFrom: trailerStart+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: trailerStart-1 ].	"divide the rest of the string up between spaces"	tokens _ remainder findTokens: ' '.	"the command is the first token..."	command _ tokens removeFirst.	command first = $: ifTrue: [		"...unless it starts with a $:, in which case there is a prefix and the command is the second token"		prefix _ command copyFrom: 2 to: command size.  "copy without the leading :"		command _ tokens removeFirst ].	"the arguments are the remaining tokens, plus the trailer if any"	arguments _ tokens.	trailer ifNotNil: [ arguments _ arguments copyWith: trailer ].	^self prefix: prefix  command: command  arguments: arguments.! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:34'!prefix: aString  command: anotherString  arguments: aCollection	^super new prefix: aString  command: anotherString  arguments: aCollection! !a filter for messages  sent to a particular user!!ImageMorph methodsFor: 'menu commands' stamp: 'di 9/15/1998 09:58'!readFromFile	| fileName |	fileName _ FillInTheBlank		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image ona stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for imagestoragesClass Variables:	ImageNotStoredSignal		<Signal>	image not storederror signal	MagicNumberErrorSignal		<Signal>	magic number errorsignalSubclasses must implement the following messages:	accessing		nextImage		nextPutImage:	testing		canUnderstand         (added tao 10/26/97)!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access'!close	"close if you can"	(stream respondsTo: #close) ifTrue: [			stream closed ifFalse: [stream close]]! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextLongPut: a32BitW	"Write out a 32-bit integer as 32 bits."	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a32BitW bitAnd: 16rFF).	^a32BitW! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private'!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).	newBits _ ByteArray new: dstRowByteSize * height.	srcRowBase _ 1.	rowEndOffset _ dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase _ srcRowBase + srcRowByteSize].	^newBits! !!ImageReadWriter methodsFor: 'private'!hasMagicNumber: aByteArray	| position |	position _ stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!ImageReadWriter methodsFor: 'private' stamp: 'di 9/15/1998 11:42'!on: aStream	(stream _ aStream) reset.	(stream respondsTo: #binary) ifTrue: [stream binary].	"Note that 'reset' makes a file be text.  Must do this after."! !!ImageReadWriter methodsFor: 'private'!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask _ (1 bitShift: depth) - 1.	pixelInByte _ 8 / depth.	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).	stopWidth _ width * depth + 7 // 8.	trailingSize _ width - (stopWidth - 1 * pixelInByte).	upBits _ ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex _ i - 1 * bitsWidth.		upBitIndex _ i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val _ bits at: (bitIndex _ bitIndex + 1).			upBitIndex _ upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val _ val bitShift: depth negated]].		val _ (bits at: (bitIndex _ bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex _ upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val _ val bitShift: depth negated]].	^ upBits! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream _ FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:10'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | aBinaryStream reset. (subclass new on: aBinaryStream) understandsImageFormat]		ifNone: [			(aBinaryStream respondsTo: #close) ifTrue: [ aBinaryStream close ].			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !I represent an index for the messages in a mail database. I acts like a dictionary that maps unique message ID's to IndexFileEntry objects.The index file is read into memory in its entirety and kept there for the duration of a mail reading session. It should be stored back to disk at the end of the session, or after a major change, such as fetching new mail. If necessary, it can be completely recreated by scanning the messages file.!!IndexFile methodsFor: 'file operations' stamp: 'ls 11/9/1998 16:07'!openOn: aFileName messageFile: messageFile	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: (ReadStream on: fileStream contentsOfEntireFile) messageFile: messageFile.		"close and release the file stream"	fileStream _ nil.! !!IndexFile methodsFor: 'dictionary access'!at: msgID	"Answer the IndexFileEntry for the message with the given ID."	^msgDictionary at: msgID ifAbsent: [self reportInconsistency]! !!IndexFile methodsFor: 'dictionary access'!at: msgID ifAbsent: aBlock	"Answer the IndexFileEntry for the message with the given ID. Evaluate the given block if there is no entry for the given ID."	^msgDictionary at: msgID ifAbsent: aBlock! !!IndexFile methodsFor: 'dictionary access'!at: msgID put: anIndexFileEntry	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat:		[: assoc | assoc key = msgID].	"don't duplicate the entry!!"	msgDictionary at: msgID put: anIndexFileEntry.	timeSortedEntries add: (Association key: msgID value: anIndexFileEntry).! !!IndexFile methodsFor: 'dictionary access'!includesKey: msgID	"Answer true if my message dictionary contains an entry for the message with the given ID."	^msgDictionary includesKey: msgID! !!IndexFile methodsFor: 'dictionary access'!keys	"Answer a collection of message IDs for the messages in this IndexFile, sorted in ascending timestamp order. Because sorting is expensive, the sorted key list is cached."	| keys |	keys _ OrderedCollection new: timeSortedEntries size * 2.	timeSortedEntries do: [: assoc | keys addLast: assoc key].	^keys! !!IndexFile methodsFor: 'dictionary access'!remove: msgID	"Remove the entry with the given ID from my Dictionary."	timeSortedEntries removeAllSuchThat: [: assoc | assoc key = msgID].	msgDictionary removeKey: msgID ifAbsent: [].! !!IndexFile methodsFor: 'read-write'!readFrom: aStream messageFile: messageFile	"Initialize myself from the given text stream. It is assumed that the .index file was written in order of ascending message timestamps, although this method is only less efficient, not incorrect, if this is not the case."	| sorted lastTime msgID entry |	msgDictionary _ Dictionary new: 1000.	timeSortedEntries _ (SortedCollection new: 1000) sortBlock:		[: m1 : m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd] whileFalse:		[msgID _ MailDB readIntegerLineFrom: aStream.		 entry _ IndexFileEntry readFrom: aStream messageFile: messageFile msgID: msgID.		 msgDictionary at: msgID put: entry.		 timeSortedEntries addLast: (Association key: msgID value: entry).		 ((sorted & lastTime notNil) and: [lastTime > entry time]) ifTrue:			[sorted _ false].		 lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]. 	"re-sort if necessary"! !!IndexFile methodsFor: 'read-write'!writeOn: aStream	"Write my index entries to the given text stream in human-readable form."	"Note: For efficiency, this is done in order of increasing message timestamps, to save the cost of sorting when we read it back in. It is assumed that timeSortedEntries should contains exactly the same message ID's as msgDictionary."	timeSortedEntries do:		[: assoc |		 (assoc key) printOn: aStream.		"message ID"		 aStream cr.		 (assoc value) writeOn: aStream].	"index entry"! !!IndexFile class methodsFor: 'instance creation'!openOn: fileName messageFile: messageFile	"Answer a new instance of me for the given message file, backed by the file with the given name."	^(super new) openOn: fileName messageFile: messageFile! !An IndexFileEntry contains enough information to present a table-of-contents entry for the message and to support simple filtering based on a subset of the mail header information. The IndexFile maps unique message ID's to IndexFileEntries.!!IndexFileEntry methodsFor: 'access'!cc	^cc! !!IndexFileEntry methodsFor: 'access'!cc: aString	cc _ aString.! !!IndexFileEntry methodsFor: 'access'!date	"Answer a date string for this index entry."	^Date fromDays: (time + (Date newDay: 1 year: 1980) asSeconds) // 86400! !!IndexFileEntry methodsFor: 'access'!from	^from! !!IndexFileEntry methodsFor: 'access'!from: aString	from _ aString.! !!IndexFileEntry methodsFor: 'access'!location	^location! !!IndexFileEntry methodsFor: 'access'!location: anInteger	location _ anInteger.! !!IndexFileEntry methodsFor: 'access'!messageFile	^messageFile! !!IndexFileEntry methodsFor: 'access'!messageFile: aMessageFile	messageFile _ aMessageFile.! !!IndexFileEntry methodsFor: 'access'!msgID	^msgID! !!IndexFileEntry methodsFor: 'access'!msgID: anID	msgID _ anID.! !!IndexFileEntry methodsFor: 'access'!subject	^subject! !!IndexFileEntry methodsFor: 'access'!subject: aString	subject _ aString.! !!IndexFileEntry methodsFor: 'access'!textLength	^textLength! !!IndexFileEntry methodsFor: 'access'!textLength: anInteger	textLength _ anInteger.! !!IndexFileEntry methodsFor: 'access'!time	^time! !!IndexFileEntry methodsFor: 'access'!time: anInteger	time _ anInteger.! !!IndexFileEntry methodsFor: 'access'!to	^to! !!IndexFileEntry methodsFor: 'access'!to: aString	to _ aString.! !!IndexFileEntry methodsFor: 'printing' stamp: 'jm 9/21/1998 10:55'!computeTOCString	"Answer a string for the table of contents."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	| fromFieldSize s |	fromFieldSize _ 18.	s _ WriteStream on: (String new: 200).	s nextPutAll: self dateString.	[s position < 9] whileTrue: [s space].	s nextPutAll: (self fromStringLimit: fromFieldSize).	[s position <= (9 + fromFieldSize + 2)] whileTrue: [s space].	s nextPutAll: subject.	^ s contents! !!IndexFileEntry methodsFor: 'printing'!dateString	"Answer a date string for this index entry."	^self date printFormat: #(2 1 3 47 1 2)! !!IndexFileEntry methodsFor: 'printing'!flushTOCCache	"Flush my cached table-of-contents entry string."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	tocLineCache _ nil.! !!IndexFileEntry methodsFor: 'printing' stamp: 'ls 9/10/1998 21:15'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from.	s skipSeparators.	('"<' includes: s peek) ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		(('@<>)$"' includes: ch) or: [editedFrom position >= limit])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!IndexFileEntry methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self dateString; cr.	aStream nextPutAll: from; cr.	aStream nextPutAll: to; cr.	aStream nextPutAll: cc; cr.	aStream nextPutAll: subject; cr.	aStream nextPut: $(; nextPutAll: location printString; space.	aStream nextPutAll: textLength printString; nextPut: $).	aStream cr.! !!IndexFileEntry methodsFor: 'printing'!tocString	"Answer a string for the table of contents."	(tocLineCache isNil) ifTrue:		[tocLineCache _ self computeTOCString].	^tocLineCache! !!IndexFileEntry methodsFor: 'read-write'!readFrom: aStream	"Initialize myself from the given text stream."	location _ MailDB readIntegerLineFrom: aStream.	textLength _ MailDB readIntegerLineFrom: aStream.	time _ MailDB readIntegerLineFrom: aStream.	from _ MailDB readStringLineFrom: aStream.	to _ MailDB readStringLineFrom: aStream.	cc _ MailDB readStringLineFrom: aStream.	subject _ MailDB readStringLineFrom: aStream.! !!IndexFileEntry methodsFor: 'read-write' stamp: 'ls 10/6/1998 13:22'!writeOn: aStream	"Write a human-readable representation of myself on the given text stream."	aStream		nextPutAll: location printString; cr;		nextPutAll: textLength printString; cr;		nextPutAll: time printString; cr;		nextPutAll: from; cr;		nextPutAll: to; cr;		nextPutAll: cc; cr;		nextPutAll: subject; cr.! !!IndexFileEntry methodsFor: 'filtering support'!ccHas: stringOrList	^ self field: cc has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 8/14/1998 13:39'!field: field has: stringOrList	"Return true if either the given field contains the argument string or, if the argument is a collection, return true if the given field contains any of the strings in that collection."	| s |	(stringOrList isKindOf: String) ifTrue: [		^ field includesSubstring: stringOrList caseSensitive: false	] ifFalse: [		1 to: stringOrList size do: [ :i |			s _ stringOrList at: i.			s isNumber ifTrue: [s _ s printString].			(field includesSubstring: s caseSensitive: false) ifTrue: [^ true].		].		^ false	].! !!IndexFileEntry methodsFor: 'filtering support'!fromHas: stringOrList	^ self field: from has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!getMessage	"Answer the MailMessage for this index file entry."	^MailMessage from:		(messageFile			getMessage: msgID			at: location			textLength: textLength).! !!IndexFileEntry methodsFor: 'filtering support'!participantHas: stringOrList	^ (self field: from has: stringOrList) or:	   [(self field: self to has: stringOrList) or:	   [self field: self cc has: stringOrList]]! !!IndexFileEntry methodsFor: 'filtering support'!subjectHas: stringOrList	^ self field: subject has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 10/12/1998 09:34'!textHas: stringOrList	^ self field: self getMessage text has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!toHas: stringOrList	^ self field: to has: stringOrList! !!IndexFileEntry class methodsFor: 'instance creation'!message: aMailMessage location: location messageFile: aMessageFile msgID: msgID	"Answer a new instance of me for the given message and message file location."	^self new		messageFile: aMessageFile;		msgID: msgID;		location: location;		textLength: aMailMessage text size;		time: aMailMessage time;		from: aMailMessage from;		to: aMailMessage to;		cc: aMailMessage cc;		subject: aMailMessage subject! !!IndexFileEntry class methodsFor: 'instance creation'!readFrom: aStream messageFile: aMessageFile msgID: msgID	"Answer a new instance of me initialized from the given text stream."	^(self new readFrom: aStream)		messageFile: aMessageFile;		msgID: msgID! !Used in conjunction wi[th a TabbedPalette -- each TabbedPalette has one.  Each submorph of an IndexTabs is a TabMorph.  When you click on one of the tabs, a corresponding action is taken -- sometimes, the existing palette gets replaced by the new one, other times, the tab results in some selector being invoked; in any case, tab highlighting takes place accordingly.!!IndexTabs methodsFor: 'initialization' stamp: 'sw 10/15/1998 17:12'!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	basicWidth _ 200.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addActionTabWithTitle: aString	|  aTab |	aTab _ TabMorph new.	aTab contents: aString.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 11:44'!addTab: aTab	self addMorphBack: aTab.	self laySubpartsOutInOneRow! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addTabForBook: aBook	|  aTab |	aTab _ TabMorph new morphToInstall: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 12:42'!tabMorphs	"Presently all the submorphs are tabMorphs, but this still supports an earlier design where spacers are interleaved."	^ submorphs select: [:m | m isKindOf: TabMorph]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!basicHeight	^ basicHeight! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth	basicWidth ifNil: [basicWidth _ 200].	^ basicWidth! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth: w	basicWidth _ w! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) max: self basicWidth) @ self basicHeight)! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/21/1998 22:05'!openToDragNDrop	^ false! !!IndexTabs methodsFor: 'selection' stamp: 'sw 7/3/1998 18:43'!selectTab: aTab	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTab: aTab.! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:56'!highlightColor	^ highlightColor ifNil: [Color yellow]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!highlightColor: aColor	highlightColor _ aColor! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:43'!highlightColor: color1 regularColor: color2	"Apply these colors to all of the receiver's tabs"	highlightColor _ color1.	regularColor _ color2.	self tabMorphs do:		[:m | m highlightColor: color1.  m regularColor: color2]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 15:27'!highlightTab: aTab	self tabMorphs do: [:m |		m == aTab		ifTrue: [m color: m highlightColor]		ifFalse: [m color: m regularColor]]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/4/1998 14:58'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m color: m highlightColor.  theOne _ m]				ifFalse: [m color: m regularColor]].	^ theOne! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:47'!regularColor	^ regularColor ifNil: [Color r: 0.4 g: 0.2 b: 0.6]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!regularColor: aColor	regularColor _ aColor! !!IndexTabs class methodsFor: 'all' stamp: 'sw 7/2/1998 15:16'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'tabs'! !This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table _ initialTable.	bitsNeeded _ high 8 bits of (table at: 1).		"Determine initial bits"	table _ initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits _ fetch next bitsNeeded bits.			"Grab the bits"	value _ table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table _ initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded _ high 8 bit of value].		"Compute additional number of bits needed"	^value!!InflateStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 16:35'!on: aCollection	^self on: aCollection from: 1 to: aCollection size! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/4/1998 13:08'!on: aCollection from: firstIndex to: lastIndex	bitBuf _ bitPos _ 0.	"The decompression buffer has a size of at 64k,	since we may have distances up to 32k back and	repetitions of at most 32k length forward"	collection _ aCollection species new: 1 << 16.	readLimit _ 0. "Not yet initialized"	position _ 0.	source _ aCollection.	sourceLimit _ lastIndex.	sourcePos _ firstIndex-1.	state _ StateNewBlock.! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 16:32'!reset	"Position zero - nothing decoded yet"	position _ readLimit _ 0.	sourcePos _ 0.	bitBuf _ bitPos _ 0.	state _ 0.! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 22:10'!next	"Answer the next decompressed object in the Stream represented by the	receiver."	"<primitive: 65>"	position >= readLimit		ifTrue: [^self pastEndRead]		ifFalse: [^collection at: (position _ position + 1)]! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:18'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for simplicity"	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!size	"This is a compressed stream - we don't know the size beforehand"	^self shouldNotImplement! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:20'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!InflateStream methodsFor: 'testing' stamp: 'ar 12/3/1998 23:21'!atEnd	^position >= readLimit and:[state = StateNoMoreData]! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:24'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex _ 2.							"First real table"	[bits _ self nextSingleBits: bitsNeeded.	"Get bits"	value _ table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/5/1998 14:58'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit _ readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0) at: value - 256.			length _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258) at: value - 256.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13) at: value+1.			distance _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769						1025 1537 2049 3073 4097 6145 8193 12289 16385 24577) at: value+1.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length > collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length + 1 					with: collection 					startingAt: readLimit - distance + 1.			readLimit _ readLimit + length.		].	].! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedDynamicBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedFixedBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 21:12'!proceedStoredBlock	"Proceed decompressing a stored (e.g., uncompressed) block"	| length decoded |	"Literal table must be nil for a stored block"	litTable == nil ifFalse:[^self error:'Bad state'].	length _ distTable.	[length > 0 and:[readLimit <= collection size and:[sourcePos <= sourceLimit]]] 		whileTrue:[			collection at: (readLimit _ readLimit + 1) put: 				(source at: (sourcePos _ sourcePos + 1)).			length _ length - 1].	length = 0 ifTrue:[state _ state bitAnd: StateNoMoreData].	decoded _ length - distTable.	distTable _ length.	^decoded! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 01:46'!processDynamicBlock	| nLit nDist nLen codeLength lengthTable bits |	nLit _ (self nextBits: 5) + 257.	nDist _ (self nextBits: 5) + 1.	nLen _ (self nextBits: 4) + 4.	codeLength _ Array new: 19.	codeLength atAllPut: 0.	1 to: nLen do:[:i|		bits _ #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15) at: i.		codeLength at: bits+1 put: (self nextBits: 3).	].	lengthTable _ self huffmanTableFrom: codeLength mappedBy: nil.	"RFC 1951: In other words, all code lengths form a single sequence..."	codeLength _ self decodeDynamicTable: nLit+nDist from: lengthTable.	litTable _ self 				huffmanTableFrom: (codeLength copyFrom: 1 to: nLit)				mappedBy: self literalLengthMap.	distTable _ self 				huffmanTableFrom: (codeLength copyFrom: nLit+1 to: codeLength size)				mappedBy: self distanceMap.	state _ state bitOr: BlockProceedBit.	self proceedDynamicBlock.! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:13'!processFixedBlock	litTable _ self 				huffmanTableFrom: FixedLitCodes				mappedBy: self literalLengthMap.	distTable _ self 				huffmanTableFrom: FixedDistCodes				mappedBy: self distanceMap.	state _ state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 21:25'!processStoredBlock	| chkSum length |	"Skip to byte boundary"	self nextBits: (bitPos bitAnd: 7).	length _ self nextBits: 16.	chkSum _ self nextBits: 16.	chkSum bitInvert32 = length		ifFalse:[^self error:'Bad block length'].	litTable _ nil.	distTable _ length.	state _ state bitOr: BlockProceedBit.	^self proceedStoredBlock! !!InflateStream methodsFor: 'private' stamp: 'ar 12/2/1998 17:17'!assert: aBlock	aBlock value ifFalse:[^self error:'Assertion failed']! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!decompressAll	"Profile the decompression speed"	[self atEnd] whileFalse:[		position _ readLimit.		self next "Provokes decompression"	].! !!InflateStream methodsFor: 'private' stamp: 'ar 12/3/1998 17:32'!getNextBlock	^self nextBits: 3! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 13:04'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType delta |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move data to front"	readLimit > 32768 ifTrue:[		delta _ readLimit - 32767.		collection replaceFrom: 1 to: collection size - delta + 1 with: collection startingAt: delta.		position _ position - delta + 1.		readLimit _ readLimit - delta + 1.	].	state = StateNewBlock ifTrue:[state _ self getNextBlock].	state = StateNoMoreData ifTrue:[^nil].	blockType _ state bitShift: -1.	self perform: (BlockTypes at: blockType+1).	^collection at: (position _ position + 1)! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!profile	"Profile the decompression speed"	MessageTally spyOn:[self decompressAll].! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/2/1998 19:27'!computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits	"Assign numerical values to all codes.	Note: The values are stored according to the bit length"	| offsets values baseOffset codeLength |	offsets _ Array new: maxBits.	offsets atAllPut: 0.	baseOffset _ 1.	minBits to: maxBits do:[:bits|		offsets at: bits put: baseOffset.		baseOffset _ baseOffset + (counts at: bits+1)].	values _ Array new: aCollection size.	1 to: aCollection size do:[:i|		codeLength _ aCollection at: i.		codeLength > 0 ifTrue:[			baseOffset _ offsets at: codeLength.			values at: baseOffset put: i-1.			offsets at: codeLength put: baseOffset + 1]].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:21'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table _ Array new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart _ 2. "See above"	tableSize _ 1 bitShift: minBits.	tableEnd _ tableStart + tableSize.	"Store the terminal symbols"	valueIndex _ (counts at: minBits+1).	tableIndex _ 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex _ self increment: tableIndex bits: minBits].	"Fill up remaining entries with invalid entries"	tableStack _ OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex _ valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues _ counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable _ tableStack last.			lastTableStart _ lastTable at: 2.			lastTableIndex _ lastTable at: 3.			deltaBits _ bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize _ 1 bitShift: deltaBits.			tableStart _ tableEnd.			tableEnd _ tableEnd + tableSize.			tableEnd > table size 				ifTrue:[table _ self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) isNil]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries _ numValues min: tableSize.			tableIndex _ 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex _ valueIndex + 1.				numValues _ numValues - 1.				tableIndex _ self increment: tableIndex bits: deltaBits].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:25'!decodeDynamicTable: nItems from: aHuffmanTable	"Decode the code length of the literal/length and distance table	in a block compressed with dynamic huffman trees"	| values index value repCount theValue |	values _ Array new: nItems.	index _ 1.	theValue _ 0.	[index <= nItems] whileTrue:[		value _ self decodeValueFrom: aHuffmanTable.		value < 16 ifTrue:[			"Immediate values"			theValue _ value.			values at: index put: value.			index _ index+1.		] ifFalse:[			"Repeated values"			value = 16 ifTrue:[				"Repeat last value"				repCount _ (self nextBits: 2) + 3.			] ifFalse:[				"Repeat zero value"				theValue _ 0.				value = 17 					ifTrue:[repCount _ (self nextBits: 3) + 3]					ifFalse:[value = 18 								ifTrue:[repCount _ (self nextBits: 7) + 11]								ifFalse:[^self error:'Invalid bits tree value']]].			0 to: repCount-1 do:[:i| values at: index+i put: theValue].			index _ index + repCount].	].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:51'!distanceMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/3/1998 13:16'!growHuffmanTable: table	| newTable |	newTable _ table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:27'!huffmanTableFrom: aCollection mappedBy: valueMap	"Create a new huffman table from the given code lengths.	Map the actual values by valueMap if it is given.	See the class comment for a documentation of the huffman	tables used in this decompressor."	| counts  values table minBits maxBits |	minBits _ MaxBits + 1.	maxBits _ 0.	"Count the occurences of each code length and compute minBits and maxBits"	counts _ Array new: MaxBits+1.	counts atAllPut: 0.	aCollection do:[:length| 		length > 0 ifTrue:[			length < minBits ifTrue:[minBits _ length].			length > maxBits ifTrue:[maxBits _ length].			counts at: length+1 put: (counts at: length+1)+1]].	maxBits = 0 ifTrue:[^nil]. "Empty huffman table"	"Assign numerical values to all codes."	values _ self computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits.	"Map the values if requested"	self mapValues: values by: valueMap.	"Create the actual tables"	table _ self createHuffmanTables: values counts: counts from: minBits to: maxBits.	^table! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment a value of nBits length.	The fast decompressor will do this differently"	^value+1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:50'!literalLengthMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:28'!mapValues: values by: valueMap	| oldValue |	valueMap ifNil:[^values].	1 to: values size do:[:i|		oldValue _ values at: i.		"Note: there may be nil values if not all values are used"		oldValue isNil			ifTrue:[^values]			ifFalse:[values at: i put: (valueMap at: oldValue+1)]].! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:00'!nextBits: n	| bits |	[bitPos < n] whileTrue:[		bitBuf _ bitBuf + (self nextByte bitShift: bitPos).		bitPos _ bitPos + 8].	bits _ bitBuf bitAnd: (1 bitShift: n)-1.	bitBuf _ bitBuf bitShift: 0 - n.	bitPos _ bitPos - n.	^bits! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/5/1998 14:54'!nextByte	^source byteAt: (sourcePos _ sourcePos + 1)! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:01'!nextSingleBits: n	| out |	out _ 0.	1 to: n do:[:i| out _ (out bitShift: 1) + (self nextBits: 1)].	^out! !!InflateStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 19:12'!initialize	"InflateStream initialize"	MaxBits _ 16.	StateNewBlock _ 0.	StateNoMoreData _ 1.	BlockProceedBit _ 8.	BlockTypes _ #(	processStoredBlock	"New block in stored format"					processFixedBlock	"New block with fixed huffman tables"					processDynamicBlock	"New block with dynamic huffman tables"					errorBadBlock		"Bad block format"					proceedStoredBlock	"Continue block in stored format"					proceedFixedBlock	"Continue block in fixed format"					proceedDynamicBlock	"Continue block in dynamic format"					errorBadBlock		"Bad block format").	"Initialize fixed block values"	FixedLitCodes _ 	((1 to: 144) collect:[:i| 8]),					((145 to: 256) collect:[:i| 9]),					((257 to: 280) collect:[:i| 7]),					((281 to: 288) collect:[:i| 8]).	FixedDistCodes _ ((1 to: 32) collect:[:i| 5]).! !!InputSensor methodsFor: 'modifier keys' stamp: 'jm 5/29/1998 14:17'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	^ self primMouseButtons anyMask: 32! !!InputSensor methodsFor: 'user interrupts' stamp: 'di 9/23/1998 16:12'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		Smalltalk shutDownSound.		Smalltalk handleUserInterrupt]! !!Inspector methodsFor: 'accessing' stamp: 'di 1/14/1999 22:45'!step	"Continuously update the value of the selected item"	| newText |	newText _ self contentsIsString		ifTrue: [self selection]		ifFalse: [self selection printString].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector methodsFor: 'accessing' stamp: 'di 1/13/1999 14:36'!wantsSteps	^ true! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:24'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (selectionIndex = 2) | (selectionIndex = 0)! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:29'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionIndex = anInteger		ifTrue: 			["same index, turn off selection"			selectionIndex _ 0.			contents _ '']		ifFalse:			["different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selection printString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject	^ self openAsMorphOn: anObject withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:30'!openAsMorphOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject withLabel: label) openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject withLabel: aLabel	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: ((inspector isMemberOf: DictionaryInspector)						ifTrue: [#dictionaryMenu:]						ifFalse: [#fieldListMenu:])				keystroke: #inspectorKey:from:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.7 corner: 1@1).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 9/23/1998 12:38'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	World ifNotNil:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass].	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!InspectorBrowser methodsFor: 'all' stamp: 'di 11/13/1998 15:27'!msgAccept: newText from: editor	| category |	category _ msgListIndex = 0		ifTrue: [ClassOrganizer default]		ifFalse: [object class organization categoryOfElement: (msgList at: msgListIndex)].	^ (object class compile: newText classified: category notifying: editor) ~~ nil! !!InspectorBrowser methodsFor: 'all' stamp: 'di 1/14/1999 09:01'!wantsSteps	^ true! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng _ self negative == aNumber negative == false.		quo _ (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>! !!Integer methodsFor: 'truncation and round off' stamp: 'sw 6/26/1998 15:48'!atRandom	"Return a random integer from 1 to self.  Heavy users should use Interval atRandom or atRandom: directly."	self < 1 ifTrue: [^ self].	^ (1 to: self) atRandom! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: self asFraction! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!Integer methodsFor: 'converting' stamp: 'di 1/13/1999 12:45'!asFloat	"Answer a Float that represents the value of the receiver.	Optimized to process only the significant digits of a LargeInteger.	SqR: 11/30/1998 21:11"	| sum firstByte shift |	shift _ 0.	sum _ 0.0.	firstByte _ self size - 7 max: 1.	firstByte to: self size do:		[:byteIndex | 		sum _ ((self digitAt: byteIndex) asFloat timesTwoPower: shift) + sum.		shift _ shift + 8].	^sum * self sign asFloat timesTwoPower: firstByte - 1 * 8! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'printing' stamp: 'sw 11/24/1998 14:53'!asStringWithCommas	"123456789 asStringWithCommas"	"-123456789 asStringWithCommas"	| digits |	digits _ self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Integer methodsFor: 'private' stamp: 'LC 6/18/1998 10:07'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	arg = 0 ifTrue: [^ self error: 'division by 0'].	"*****We've added this line*****"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0 ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l				put: lo - (lo // 256 * 256) "sign-tolerant form of (lo bitAnd: 255)".			a _ (lo // 256) - (hi bitShift: -4).			l _ l + 1].		a < 0 ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:06'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t |	  t _ Time millisecondsToRun: [r _ 26 benchFib].	  (r * 1000) // t"	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'benchmarks' stamp: 'jm 1/13/1999 19:52'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks."	"0 tinyBenchmarks"	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"	| n t1 t2 r |	n _ 1.	t1 _ Time millisecondsToRun: [n benchmark].	t2 _ Time millisecondsToRun: [r _ 28 benchFib].	^ ((n * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !IntegerArrays store 32bit signed Integer values.Negative values are stored as 2's complement.!!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index put: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger - 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!IntegerArray methodsFor: 'converting' stamp: 'ar 10/10/1998 16:18'!asIntegerArray	^self! !This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.NOTE:  Here follows a list of things to be borne in mind when working on this code, or when making changes for the future.1.  There are a number of things that should be done the next time we plan to release a copletely incompatible image format.  These include unifying the instanceSize field of the class format word -- see instantiateClass:indexableSize:, and unifying the bits of the method primitive index (if we decide we need more than 512, after all) -- see primitiveIndexOf:.  Also, contexts should be given a special format code (see next item).2.  There are several fast checks for contexts (see isContextHeader: and isMethodContextHeader:) which will fail if the compact class indices of BlockContext or MethodContext change.  This is necessary because the oops may change during a compaction when the oops are being adjusted.  It's important to be aware of this when writing a new image using the systemTracer.  A better solution would be to reserve one of the format codes for Contexts only.3.  We have made normal files tolerant to size and positions up to 32 bits.  This has not been done for async files, since they are still experimental.  The code in size, at: and at:put: should work with sizes and indices up to 31 bits, although I have not tested it (di 12/98); it might or might not work with 32-bit sizes.4.  Note that 0 is used in a couple of places as an impossible oop.  This should be changed to a constant that really is impossible (or perhaps there is code somewhere that guarantees it --if so it should be put in this comment).  The places include the method cache and the at cache. !!Interpreter methodsFor: 'initialization' stamp: 'ikp 12/12/1998 16:09'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	self initCompilerHooks.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/10/1998 19:18'!booleanCheat: cond	| bytecode offset |	self inline: true.	bytecode _ self fetchByte.  "assume next bytecode is jumpIfFalse (99%)"	self internalPop: 2.	(bytecode < 160 and: [bytecode > 151]) ifTrue: [  "short jumpIfFalse"		cond			ifTrue: [^ self fetchNextBytecode]			ifFalse: [^ self jump: bytecode - 151]].	bytecode = 172 ifTrue: [  "long jumpIfFalse"		offset _ self fetchByte.		cond			ifTrue: [^ self fetchNextBytecode]			ifFalse: [^ self jump: offset]].	"not followed by a jumpIfFalse; undo instruction fetch and push boolean result"	localIP _ localIP - 1.	self fetchNextBytecode.	cond		ifTrue: [self internalPush: trueObj]		ifFalse: [self internalPush: falseObj].! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/7/1998 07:35'!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ self cCoerce: localIP to: 'int'.	stackPointer _ self cCoerce: localSP to: 'int'.	theHomeContext _ localHomeContext.! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/7/1998 07:35'!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	localIP _ self cCoerce: instructionPointer to: 'char *'.	localSP _ self cCoerce: stackPointer to: 'char *'.	localHomeContext _ theHomeContext.! !!Interpreter methodsFor: 'utilities' stamp: 'di 11/27/1998 21:20'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	self inline: true.	self returnTypeC: 'double'.	(self isIntegerObject: floatOrInt) ifTrue:		[^ self cCode: '((double) (floatOrInt >> 1))'].	(self fetchClassOfNonInt: floatOrInt) = (self splObj: ClassFloat)		ifTrue: [^ self floatValueOf: floatOrInt].	successFlag _ false! !!Interpreter methodsFor: 'utilities' stamp: 'ikp 12/12/1998 14:35'!transfer: count from: src to: dst	| in out lastIn |	self inline: true.	in _ src - 4.	lastIn _ in + (count * 4).	out _ dst - 4.	[in < lastIn] whileTrue: [		self longAt: (out _ out + 4) put: (self longAt: (in _ in + 4)).	].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 12/19/1998 17:09'!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self compilerMarkHook.	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	self markAndTrace: activeContext.  "traces entire stack"		"also covers theHomeContext, receiver, method"	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 12/12/1998 16:40'!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	self compilerPostGCHook.	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 1/3/1999 17:22'!preGCAction: fullGCFlag	self compilerPreGCHook: fullGCFlag.	activeContext == nilObj ifFalse: [self storeContextRegisters: activeContext].! !!Interpreter methodsFor: 'compiled methods' stamp: 'ar 10/13/1998 13:50'!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r0F! !!Interpreter methodsFor: 'contexts' stamp: 'di 11/29/1998 16:24'!fetchStackPointerOf: aContext	"Return the stackPointer of a Context or BlockContext."	| sp |	self inline: true.	sp _ self fetchPointer: StackPointerIndex ofObject: aContext.	(self isIntegerObject: sp) ifFalse: [^ 0].	^ self integerValueOf: sp! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 08:37'!internalFetchContextRegisters: activeCntx	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	localHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	localIP _ self cCoerce: method + tmp + BaseHeaderSize - 2 to: 'char *'.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	localSP _ self cCoerce: activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4) to: 'char *'.! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 15:55'!internalNewActiveContext: aContext	"The only difference between this method and newActiveContext: is that this method uses internal context registers."	self inline: true.	self internalStoreContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self internalFetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 22:57'!internalStoreContextRegisters: activeCntx	"The only difference between this method and fetchContextRegisters: is that this method stores from the local IP and SP."	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(localIP asInteger + 2 - (method + BaseHeaderSize))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(((localSP asInteger - (activeCntx + BaseHeaderSize)) >> 2) - TempFrameStart + 1)).! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/18/1998 21:38'!isContext: oop header: hdr	"NOTE: anOop is assumed not to be an integer"	| ccIndex theClass |	self inline: true.	ccIndex _ (hdr >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [theClass _ (self classHeader: oop) bitAnd: AllButTypeMask]		ifFalse: ["look up compact class"				theClass _ self fetchPointer: ccIndex - 1							ofObject: (self splObj: CompactClasses)].	^ theClass = (self splObj: ClassMethodContext)		or: [theClass = (self splObj: ClassBlockContext)]! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/27/1998 23:32'!isContextHeader: aHeader	| ccIndex |	self inline: true.	ccIndex _ (aHeader >> 12) bitAnd: 16r1F.	^ ccIndex = 13 or: [ccIndex = 14]! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/27/1998 23:32'!isMethodContextHeader: aHeader	self inline: true.	^ ((aHeader >> 12) bitAnd: 16r1F) = 14! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 15:51'!newActiveContext: aContext	"Note: internalNewActiveContext: should track changes to this method."	self storeContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self fetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'di 11/30/1998 12:31'!pop2AndPushIntegerIfOK: integerResult	successFlag ifTrue:		[(self isIntegerValue: integerResult)			ifTrue: [self pop: 2 thenPush: (self integerObjectOf: integerResult)]			ifFalse: [successFlag _ false]]! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 07:41'!sender	^ self fetchPointer: SenderIndex ofObject: localHomeContext! !!Interpreter methodsFor: 'contexts' stamp: 'ar 10/7/1998 18:16'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!Interpreter methodsFor: 'contexts' stamp: 'jm 6/24/1998 17:59'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 13:39'!storeContextRegisters: activeCntx	"Note: internalStoreContextRegisters: should track changes to this method."	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(instructionPointer - method - (BaseHeaderSize - 2))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(self stackPointerIndex - TempFrameStart + 1)).! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 07:42'!temporary: offset	^ self fetchPointer: offset + TempFrameStart ofObject: localHomeContext! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/21/98 02:37'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 4) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/15/1998 23:19'!activateNewMethod	self inline: true.	self compilerActivateMethodHook		ifFalse: [self bytecodeActivateNewMethod].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:28'!bytecodeActivateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/12/1998 14:03'!createActualMessage	| argumentArray message |	argumentArray _		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex		ofObject: message		withValue: argumentArray."---	ikp: replaced with #transfer:from:to: for optimiser compatibility	self transfer: argumentCount		fromIndex: self stackPointerIndex - (argumentCount - 1)		ofObject: activeContext		toIndex: 0		ofObject: argumentArray.---"	self transfer: argumentCount		from: stackPointer - ((argumentCount - 1) * 4)		to: argumentArray + BaseHeaderSize.	self pop: argumentCount.	self push: message.	argumentCount _ 1.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:29'!executeNewMethod	primitiveIndex > 0 ifTrue: [		self primitiveResponse.		successFlag ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self activateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/26/1998 14:40'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: false.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/15/1998 23:07'!internalActivateNewMethod	self inline: true.	compilerInitialized		ifTrue: 			[self externalizeIPandSP.			 self activateNewMethod.			 self internalizeIPandSP]		ifFalse:			[self internalBytecodeActivateNewMethod]! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:30'!internalBytecodeActivateNewMethod	| tmp newContext tempCount argCount |	self inline: true.	tmp _ self headerOf: newMethod.	freeContexts ~= NilContext		ifTrue: [newContext _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: newContext]		ifFalse: [self externalizeIPandSP.				newContext _ self allocateOrRecycleContext.				self internalizeIPandSP].	tempCount _ (tmp >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: tmp)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	tmp _ nilObj.	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: tmp].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 14:22'!internalExecuteNewMethod	| primIndex |	self inline: true.	primIndex _ primitiveIndex.	primIndex > 0		ifTrue: [(primIndex > 255 and: [primIndex < 520])				ifTrue: ["Internal return instvars"						primIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primIndex = 256 ifTrue: [^ nil "^ self"].						primIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						self primitiveResponse.						self internalizeIPandSP.						successFlag ifTrue: [^ nil]]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/26/1998 14:40'!internalFindNewMethod	"Find the compiled method to be run when the current messageSelector is sent to the class 'lkupClass', setting the values of 'newMethod' and 'primitiveIndex'."	| ok | 	self inline: true.	self sharedCodeNamed: 'commonLookup' inCase: 131.	ok _ self lookupInMethodCacheSel: messageSelector class: lkupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lkupClass.		self internalizeIPandSP.		self addToMethodCacheSel: messageSelector			class: lkupClass			method: newMethod			primIndex: primitiveIndex].! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/7/1998 09:05'!lookupMethodInClass: class	| currentClass dictionary found rclass |	self inline: false.	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	self pushRemappableOop: class.	self createActualMessage.  "may cause GC!!"	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 15:02'!lookupMethodInDictionary: dictionary	"This method lookup tolerates integers as Dictionary keys to support	execution of images in which Symbols have been compacted out" 	| length index mask wrapAround nextSelector methodArray |	self inline: true.	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	(self isIntegerObject: messageSelector)		ifTrue:		[index _ (mask bitAnd: (self integerValueOf: messageSelector)) + SelectorStart]		ifFalse:		[index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart].	"It is assumed that there are some nils in this dictionary, and search will	stop when one is encountered.  However, if there are no nils, then wrapAround	will be detected the second time the loop gets to the end of the table."	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.				primitiveIndex > MaxPrimitiveIndex ifTrue:					["If primitiveIndex is out of range, set to zero before putting in cache.						This is equiv to primFail, and avoids the need to check on every send."					primitiveIndex _ 0].				^ true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 10:26'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	lkupClass _ self fetchClassOf: rcvr.	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 10:25'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lkupClass _ self superclassOf: (self methodClassOf: method).	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/14/1998 14:31'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex	"Add the given entry to the method cache.	The policy is as follows:		Look for an empty entry anywhere in the reprobe chain.		If found, install the new entry there.		If not found, then install the new entry at the first probe position			and delete the entries in the rest of the reprobe chain.		This has two useful purposes:			If there is active contention over the first slot, the second				or third will likely be free for reentry after ejection.			Also, flushing is good when reprobe chains are getting full."	| probe hash |	self inline: false.	hash _ selector bitXor: class.  "drop low-order zeros from addresses"	0 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		(methodCache at: probe + MethodCacheSelector) = 0 ifTrue:				["Found an empty entry -- use it"				methodCache at: probe + MethodCacheSelector put: selector.				methodCache at: probe + MethodCacheClass put: class.				methodCache at: probe + MethodCacheMethod put: meth.				methodCache at: probe + MethodCachePrim put: primIndex.				^ nil]].	"OK, we failed to find an entry -- install at the first slot..."	probe _ hash bitAnd: MethodCacheMask.  "first probe"	methodCache at: probe + MethodCacheSelector put: selector.	methodCache at: probe + MethodCacheClass put: class.	methodCache at: probe + MethodCacheMethod put: meth.	methodCache at: probe + MethodCachePrim put: primIndex.	"...and zap the following entries"	1 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		methodCache at: probe + MethodCacheSelector put: 0].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/12/1998 23:37'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	1 to: AtCacheTotalSize do: [ :i | atCache at: i put: 0 ].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/14/1998 14:29'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ selector bitXor: class.  "shift drops two low-order zeros from addresses"	probe _ hash bitAnd: MethodCacheMask.  "first probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ (hash >> 1) bitAnd: MethodCacheMask.  "second probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ (hash >> 2) bitAnd: MethodCacheMask.	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	^ false! !!Interpreter methodsFor: 'interpreter shell' stamp: 'jm 12/10/1998 16:44'!fetchNextBytecode	"This method fetches the next instruction (bytecode). Each bytecode method is responsible for fetching the next bytecode, preferably as early as possible to allow the memory system time to process the request before the next dispatch."	currentBytecode _ self fetchByte.! !!Interpreter methodsFor: 'interpreter shell' stamp: 'jm 12/10/1998 17:00'!interpret	self internalizeIPandSP.	self fetchNextBytecode.	[true] whileTrue: [self dispatchOn: currentBytecode in: BytecodeTable].	self externalizeIPandSP.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:42'!duplicateTopBytecode	self fetchNextBytecode.	self internalPush: self internalStackTop.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:46'!experimentalBytecode	"Note: This bytecode is not currently generated by the compiler."	"This range of six bytecodes can replace the pushTemporaryVariable[0..5] bytecode at the beginning of a sequence of either the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		<=		longJumpIfFalseor the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		+		popIntoTemp (optional)If two values pushed are not small integers, this bytecode acts like the pushTemp bytecode it replaces. However, if they are small integers, then the given arithmetic or comparison operation is performed. The result of that operation is either pushed onto the stack or, if one of the expected bytecodes follows it, then that bytecode is performed immediately. In such cases, the entire four instruction sequence is performed without doing any stack operations."	| arg1 byte2 byte3 byte4 arg1Val arg2Val result offset |	arg1 _ self temporary: currentBytecode - 138.	byte2 _ self byteAt: localIP + 1.  "fetch ahead"	byte3 _ self byteAt: localIP + 2.  "fetch ahead"	byte4 _ self byteAt: localIP + 3.  "fetch ahead"	"check first arg"	(self isIntegerObject: arg1) ifTrue: [		arg1Val _ self integerValueOf: arg1.	] ifFalse: [		self fetchNextBytecode.		^ self internalPush: arg1.  "abort; first arg is not an integer"	].	"get and check second arg"	byte2 < 32 ifTrue: [		arg2Val _ self temporary: (byte2 bitAnd: 16rF).		(self isIntegerObject: arg2Val) ifTrue: [			arg2Val _ self integerValueOf: arg2Val.		] ifFalse: [			self fetchNextBytecode.			^ self internalPush: arg1.  "abort; second arg is not an integer"		].	] ifFalse: [		byte2 > 64 ifTrue: [			arg2Val _ 1.		] ifFalse: [			arg2Val _ self literal: (byte2 bitAnd: 16r1F).			(self isIntegerObject: arg2Val) ifTrue: [				arg2Val _ self integerValueOf: arg2Val.			] ifFalse: [				self fetchNextBytecode.				^ self internalPush: arg1.  "abort; second arg is not an integer"			].		].	].	byte3 < 178 ifTrue: [		"do addition, possibly followed by a storeAndPopTemp"		result _ arg1Val + arg2Val.		(self isIntegerValue: result) ifTrue: [			((byte4 > 103) and: [byte4 < 112]) ifTrue: [				"next instruction is a storeAndPopTemp"				localIP _ localIP + 3.				self storePointerUnchecked: (byte4 bitAnd: 7) + TempFrameStart					ofObject: localHomeContext					withValue: (self integerObjectOf: result).			] ifFalse: [				localIP _ localIP + 2.				self internalPush: (self integerObjectOf: result).			].		] ifFalse: [			self fetchNextBytecode.			^ self internalPush: arg1.  "abort; result is not an integer"		].	] ifFalse: [		"do comparison operation, followed by a longJumpIfFalse"		offset _ self byteAt: localIP + 4.		arg1Val <= arg2Val			ifTrue: [localIP _ localIP + 3 + 1]  "jump not taken; skip extra instruction byte"			ifFalse: [localIP _ localIP + 3 + 1 + offset].			self fetchNextBytecode.	].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:46'!extendedPushBytecode	| descriptor variableType variableIndex |	descriptor _ self fetchByte.	self fetchNextBytecode.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!extendedStoreAndPopBytecode	self extendedStoreBytecode.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!extendedStoreBytecode	| descriptor variableType variableIndex association |	self inline: true.	descriptor _ self fetchByte.	self fetchNextBytecode.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[^self storePointer: variableIndex			ofObject: receiver			withValue: self internalStackTop].	variableType = 1 ifTrue:		[^self storePointerUnchecked: variableIndex + TempFrameStart			ofObject: localHomeContext			withValue: self internalStackTop].	variableType = 2 ifTrue:		[self error: 'illegal store'].	variableType = 3 ifTrue:		[association _ self literal: variableIndex.		^self storePointer: ValueIndex			ofObject: association			withValue: self internalStackTop].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!popStackBytecode	self fetchNextBytecode.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushActiveContextBytecode	"Puts reclaimability of this context in question."	self fetchNextBytecode.	reclaimableContextCount _ 0.	self internalPush: activeContext.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantFalseBytecode	self fetchNextBytecode.	self internalPush: falseObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantMinusOneBytecode	self fetchNextBytecode.	self internalPush: ConstMinusOne.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantNilBytecode	self fetchNextBytecode.	self internalPush: nilObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantOneBytecode	self fetchNextBytecode.	self internalPush: ConstOne.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantTrueBytecode	self fetchNextBytecode.	self internalPush: trueObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantTwoBytecode	self fetchNextBytecode.	self internalPush: ConstTwo.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantZeroBytecode	self fetchNextBytecode.	self internalPush: ConstZero.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:56'!pushLiteralConstantBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:56'!pushLiteralVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushReceiverBytecode	self fetchNextBytecode.	self internalPush: receiver.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:57'!pushReceiverVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:57'!pushTemporaryVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:58'!storeAndPopReceiverVariableBytecode	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitely in order to help the translator produce better code."	| rcvr top |	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	rcvr _ receiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:59'!storeAndPopTemporaryVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: localHomeContext		withValue: self internalStackTop.	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/10/1998 17:11'!jump: offset	localIP _ localIP + offset + 1.	currentBytecode _ self byteAt: localIP.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/11/1998 07:24'!jumplfFalseBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].		self fetchNextBytecode.	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/11/1998 07:24'!jumplfTrueBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].		self fetchNextBytecode.	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/13/1998 11:20'!longUnconditionalJump	| offset |	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.	localIP _ localIP + offset.	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'send bytecodes' stamp: 'jm 12/10/1998 17:20'!doubleExtendedDoAnythingBytecode	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode"	| byte2 byte3 opType top |	byte2 _ self fetchByte.	byte3 _ self fetchByte.	opType _ byte2 >> 5.	opType = 0 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self normalSend	].	opType = 1 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self superclassSend	].	self fetchNextBytecode.	opType = 2 ifTrue: [^ self pushReceiverVariable: byte3].	opType = 3 ifTrue: [^ self pushLiteralConstant: byte3].	opType = 4 ifTrue: [^ self pushLiteralVariable: byte3].	opType = 5 ifTrue: [		top _ self internalStackTop.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 6 ifTrue: [		top _ self internalStackTop.		self internalPop: 1.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 7 ifTrue: [		top _ self internalStackTop.		^ self storePointer: ValueIndex ofObject: (self literal: byte3) withValue: top	].! !!Interpreter methodsFor: 'send bytecodes' stamp: 'di 12/3/1998 12:52'!sendLiteralSelectorBytecode	"Can use any of the first 16 literals for the selector and pass up to 2 arguments."	messageSelector _ self literal: (currentBytecode bitAnd: 16rF).	argumentCount _ ((currentBytecode >> 4) bitAnd: 3) - 1.	self normalSend."Note - if you ever want to try inlining these, the following will produce the code to paste into interp.c -- I found it actually slowed things down (cache size effect?).String streamContents:	[:s | 208 to: 255 do:		[:i | s tab; tab; nextPutAll: 'case ', i printString, ':'; cr.		s tab; tab; tab; nextPutAll: 'messageSelector = longAt(((char *) method) + 4 + ';			print: ((i bitAnd: 15) + 1) << 2; nextPutAll: ');'; cr.		s tab; tab; tab; nextPutAll: 'argumentCount = ';			print: (i >> 4 bitAnd: 3) - 1; nextPutAll: ';'; cr.		s tab; tab; tab; nextPutAll: 'goto commonSend;'; cr.		s tab; tab; tab; nextPutAll: 'break;'; cr; cr]]"! !!Interpreter methodsFor: 'return bytecodes' stamp: 'jm 12/10/1998 17:22'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: resultObj.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:28'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatAdd: rcvr toArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 0.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/14/1998 15:10'!bytecodePrimAt	"BytecodePrimAt will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAt will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr result atIx |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ rcvr bitAnd: AtCacheMask.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[result _ self commonVariableInternal: rcvr at: (self integerValueOf: index)							cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 2 thenPush: result]]].	messageSelector _ self specialSelector: 16.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/14/1998 15:10'!bytecodePrimAtPut	"BytecodePrimAtPut will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAtPut will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr atIx value |	value _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[self commonVariable: rcvr at: (self integerValueOf: index)							put: value cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 3 thenPush: value]]].	messageSelector _ self specialSelector: 17.	argumentCount _ 2.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitAnd	successFlag _ true.	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 14.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitOr	successFlag _ true.	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 15.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitShift	successFlag _ true.	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 12.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 1/10/1999 23:29'!bytecodePrimBlockCopy	| rcvr hdr |	rcvr _ self internalStackValue: 1.	successFlag _ true.	hdr _ self baseHeader: rcvr.	self success: (self isContextHeader: hdr).	successFlag ifTrue:		[self externalizeIPandSP.		self primitiveBlockCopy.		self internalizeIPandSP].	successFlag ifFalse:		[messageSelector _ self specialSelector: 24.		argumentCount _ 1.		^ self normalSend].	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 1/11/1999 00:09'!bytecodePrimClass	| rcvr |	rcvr _ self internalStackTop.	self internalPop: 1 thenPush: (self fetchClassOf: rcvr).	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:35'!bytecodePrimDiv	| quotient |	successFlag _ true.	quotient _ self doPrimitiveDiv: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: quotient).		^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 13.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:30'!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue:					[result _ rcvr // arg.  "generates C / operation"					(self isIntegerValue: result) ifTrue:						[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatDivide: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 9.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:39'!bytecodePrimEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr = arg].	successFlag _ true.	bool _ self primitiveFloatEqual: rcvr toArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 6.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimGreaterOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr >= arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 5.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimGreaterThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr > arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 3.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimLessOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr <= arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 4.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:41'!bytecodePrimLessThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr < arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 2.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMakePoint	successFlag _ true.	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 11.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMod	| mod |	successFlag _ true.	mod _ self doPrimitiveMod: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: mod).		^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 10.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				result _ rcvr * arg.				((arg = 0 or: [(result // arg) = rcvr])					and: [self isIntegerValue: result])					ifTrue: [self internalPop: 2 thenPush: (self integerObjectOf: result).							^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatMultiply: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 8.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:41'!bytecodePrimNotEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr ~= arg].	successFlag _ true.	bool _ self primitiveFloatEqual: rcvr toArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 7.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:34'!bytecodePrimPointX	successFlag _ true.	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 30.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:34'!bytecodePrimPointY	successFlag _ true.	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 31.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/11/1998 10:22'!bytecodePrimSize	messageSelector _ self specialSelector: 18.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 18:44'!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatSubtract: rcvr fromArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 1.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:33'!bytecodePrimValue	| block |	block _ self internalStackTop.	successFlag _ true.	argumentCount _ 0.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 25.		argumentCount _ 0.		^ self normalSend	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:33'!bytecodePrimValueWithArg	| block |	block _ self internalStackValue: 1.	successFlag _ true.	argumentCount _ 1.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 26.		argumentCount _ 1.		^ self normalSend	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 12/14/1998 09:51'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| timerPending startTime |	timerPending _ nextWakeupTick ~= 0.	timerPending ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	timerPending ifTrue: [		(self ioLowResMSecs ~= startTime) ifTrue: [			"primitive ran for more than a tick; check for possible timer interrupts"			((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [				successFlag					ifTrue: ["process the interrupt now"							self checkForInterrupts]					ifFalse: ["process the interrupt in primtive failure code"							interruptCheckCounter _ 0]]]].	^ successFlag! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:38'!checkBooleanResult: result	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:26'!checkIntegerResult: integerResult	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 11:22'!doPrimitiveDiv: rcvr by: arg	"Rounds negative results towards negative infinity, rather than zero."	| result posArg posRcvr integerRcvr integerArg |	(self areIntegers: rcvr and: arg)		ifTrue: [integerRcvr _ self integerValueOf: rcvr.				integerArg _ self integerValueOf: arg.				self success: integerArg ~= 0]		ifFalse: [self primitiveFail].	successFlag ifFalse: [^ 1 "fail"].	integerRcvr > 0		ifTrue: [integerArg > 0					ifTrue: [result _ integerRcvr // integerArg]					ifFalse: ["round negative result toward negative infinity"							posArg _ 0 - integerArg.							result _ 0 - ((integerRcvr + (posArg - 1)) // posArg)]]		ifFalse: [posRcvr _ 0 - integerRcvr.				integerArg > 0					ifTrue: ["round negative result toward negative infinity"							result _ 0 - ((posRcvr + (integerArg - 1)) // integerArg)]					ifFalse: [posArg _ 0 - integerArg.							result _ posRcvr // posArg]].	self success: (self isIntegerValue: result).	^ result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 10:02'!doPrimitiveMod: rcvr by: arg	| integerResult integerRcvr integerArg |	(self areIntegers: rcvr and: arg)		ifTrue: [integerRcvr _ self integerValueOf: rcvr.				integerArg _ self integerValueOf: arg.				self success: integerArg ~= 0]		ifFalse: [self primitiveFail].	successFlag ifFalse: [^ 1 "fail"].	integerResult _ integerRcvr \\ integerArg.	"ensure that the result has the same sign as the integerArg"	integerArg < 0		ifTrue: [integerResult > 0			ifTrue: [integerResult _ integerResult + integerArg]]		ifFalse: [integerResult < 0			ifTrue: [integerResult _ integerResult + integerArg]].	self success: (self isIntegerValue: integerResult).	^ integerResult! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:13'!primitiveAdd	self pop2AndPushIntegerIfOK: (self stackIntegerValue: 1) + (self stackIntegerValue: 0)! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:02'!primitiveBitAnd	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:02'!primitiveBitOr	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:04'!primitiveBitShift 	| integerReceiver integerArgument shifted |	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	successFlag ifTrue: [		integerArgument >= 0 ifTrue: [			"Left shift -- must fail if we lose bits beyond 32"			self success: integerArgument <= 31.			shifted _ integerReceiver << integerArgument.			self success: (shifted >> integerArgument) = integerReceiver.		] ifFalse: [			"Right shift -- OK to lose bits"			self success: integerArgument >= -31.			shifted _ integerReceiver bitShift: integerArgument.		].	].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 13:18'!primitiveBitXor	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 12/27/1998 22:52'!primitiveDiv	| quotient |	quotient _ self doPrimitiveDiv: (self stackValue: 1) by: (self stackValue: 0).	self pop2AndPushIntegerIfOK: quotient! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:25'!primitiveDivide	| integerReceiver integerArgument |	integerReceiver _ self stackIntegerValue: 1.	integerArgument _ self stackIntegerValue: 0.	(integerArgument ~= 0 and: [integerReceiver \\ integerArgument = 0])		ifTrue: [self pop2AndPushIntegerIfOK: integerReceiver // integerArgument]		ifFalse: [self primitiveFail]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveEqual	| integerReceiver integerArgument result |	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveGreaterOrEqual	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveGreaterThan	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveLessOrEqual	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveLessThan	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/28/1998 16:43'!primitiveMakePoint	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:36'!primitiveMod	| mod |	mod _ self doPrimitiveMod: (self stackValue: 1) by: (self stackValue: 0).	self pop2AndPushIntegerIfOK: mod! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:27'!primitiveMultiply	| integerRcvr integerArg integerResult |	integerRcvr _ self stackIntegerValue: 1.	integerArg _ self stackIntegerValue: 0.	successFlag ifTrue:		[integerResult _ integerRcvr * integerArg.		"check for C overflow by seeing if computation is reversible"		((integerArg = 0) or: [(integerResult // integerArg) = integerRcvr])			ifTrue: [self pop2AndPushIntegerIfOK: integerResult]			ifFalse: [self primitiveFail]]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveNotEqual	| integerReceiver integerArgument result |	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:19'!primitiveQuo	"Rounds negative results towards zero."	| integerRcvr integerArg integerResult |	integerRcvr _ self stackIntegerValue: 1.	integerArg _ self stackIntegerValue: 0.	self success: integerArg ~= 0.	successFlag ifTrue: [		integerRcvr > 0 ifTrue: [			integerArg > 0 ifTrue: [				integerResult _ integerRcvr // integerArg.			] ifFalse: [				integerResult _ 0 - (integerRcvr // (0 - integerArg)).			].		] ifFalse: [			integerArg > 0 ifTrue: [				integerResult _ 0 - ((0 - integerRcvr) // integerArg).			] ifFalse: [				integerResult _ (0 - integerRcvr) // (0 - integerArg).			].		]].	self pop2AndPushIntegerIfOK: integerResult! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:13'!primitiveSubtract	self pop2AndPushIntegerIfOK: (self stackIntegerValue: 1) - (self stackIntegerValue: 0)! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:45'!primitiveFloatAdd	^ self primitiveFloatAdd: (self stackValue: 1) toArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:10'!primitiveFloatAdd: rcvrOop toArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr + arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:45'!primitiveFloatDivide	^ self primitiveFloatDivide: (self stackValue: 1) byArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatDivide: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr // arg)  "generates C / operation"]].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:48'!primitiveFloatEqual	| bool |	bool _ self primitiveFloatEqual: (self stackValue: 1) toArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:18'!primitiveFloatEqual: rcvrOop toArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr = arg]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:42'!primitiveFloatGreater: rcvrOop thanArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr > arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:40'!primitiveFloatGreaterOrEqual	| bool |	bool _ self primitiveFloatLess: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:52'!primitiveFloatGreaterThan	| bool |	bool _ self primitiveFloatGreater: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:21'!primitiveFloatLess: rcvrOop thanArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr < arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:49'!primitiveFloatLessOrEqual	| bool |	bool _ self primitiveFloatGreater: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:51'!primitiveFloatLessThan	| bool |	bool _ self primitiveFloatLess: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:46'!primitiveFloatMultiply	^ self primitiveFloatMultiply: (self stackValue: 1) byArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatMultiply: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr * arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:49'!primitiveFloatNotEqual	| bool |	bool _ self primitiveFloatEqual: (self stackValue: 1) toArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:46'!primitiveFloatSubtract	^ self primitiveFloatSubtract: (self stackValue: 1) fromArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatSubtract: rcvrOop fromArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr - arg)].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55'!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/10/1998 14:53'!characterForAscii: ascii  "Arg must lie in range 0-255!!"	self inline: true.	^ self fetchPointer: ascii ofObject: (self splObj: CharacterTable)! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 17:04'!commonAt: stringy	"This code is called if the receiver responds primitively to at:.	If this is so, it will be installed in the atCache so that subsequent calls of at:	or next may be handled immediately in bytecode primitive routines."	| index rcvr atIx result |	index _ self positive32BitValueOf: (self stackValue: 0).  "Sets successFlag"	rcvr _ self stackValue: 1.	successFlag & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The at-cache, since it is specific to the non-super response to #at:.	Therefore we must determine that the message is #at: (not, eg, #basicAt:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 16)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ rcvr bitAnd: AtCacheMask.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue:			[result _ self commonVariable: rcvr at: index cacheIndex: atIx].		successFlag ifTrue:			[^ self pop: 2 thenPush: result]].	"The slow but sure way..."	successFlag _ true.	result _ self stObject: rcvr at: index.	successFlag ifTrue:		[stringy ifTrue: [result _ self characterForAscii: (self integerValueOf: result)].		^ self pop: 2 thenPush: result]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 17:06'!commonAtPut: stringy	"This code is called if the receiver responds primitively to at:Put:.	If this is so, it will be installed in the atPutCache so that subsequent calls of at:	or  next may be handled immediately in bytecode primitive routines."	| value index rcvr atIx |	value _ self stackValue: 0.	index _ self positive32BitValueOf: (self stackValue: 1).  "Sets successFlag"	rcvr _ self stackValue: 2.	successFlag & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 17)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue:			[self commonVariable: rcvr at: index put: value cacheIndex: atIx].		successFlag ifTrue:			[^ self pop: 3 thenPush: value]].	"The slow but sure way..."	successFlag _ true.	stringy ifTrue: [self stObject: rcvr at: index put: (self asciiOfCharacter: value)]			ifFalse: [self stObject: rcvr at: index put: value].	successFlag ifTrue: [^ self pop: 3 thenPush: value].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariable: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			result _ self positive32BitIntegerFor: result.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut _ self positive32BitValueOf: value.			successFlag ifTrue: [self storeWord: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut _ self asciiOfCharacter: value.					successFlag ifFalse: [^ nil]]			ifFalse: [valToPut _ value].		(self isIntegerObject: valToPut) ifTrue:			[^ self storeByte: index - 1 ofObject: rcvr						withValue: (self integerValueOf: valToPut)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariableInternal: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			self externalizeIPandSP.			result _ self positive32BitIntegerFor: result.			self internalizeIPandSP.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 23:17'!install: rcvr inAtCache: cache at: atIx string: stringy	"Install the oop of this object in the given cache (at or atPut), along with	its size, format and fixedSize"	| hdr fmt totalLength fixedFields |	self var: #cache declareC: 'int *cache'.	hdr _ self baseHeader: rcvr.	fmt _ (hdr >> 8) bitAnd: 16rF.	(fmt = 3 and: [self isContextHeader: hdr]) ifTrue:		["Contexts must not be put in the atCache, since their size is not constant"		^ self primitiveFail].	totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.	cache at: atIx+AtCacheOop put: rcvr.	stringy ifTrue: [cache at: atIx+AtCacheFmt put: fmt + 16]  "special flag for strings"			ifFalse: [cache at: atIx+AtCacheFmt put: fmt].	cache at: atIx+AtCacheFixedFields put: fixedFields.	cache at: atIx+AtCacheSize put: totalLength - fixedFields.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/29/1998 21:24'!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header |	self inline: true.	header _ self baseHeader: oop.	^ self lengthOf: oop baseHeader: header format: ((header >> 8) bitAnd: 16rF)! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55'!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: SizeMask ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/11/1998 10:15'!primitiveAtEnd	| stream index limit |	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream]. 	successFlag		ifTrue: [self pushBool: (index >= limit)]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 14:58'!primitiveNext	"PrimitiveNext will succeed only if the stream's array is in the atCache.	Otherwise failure will lead to proper message lookup of at: and	subsequent installation in the cache if appropriate."	| stream array index limit result atIx |	stream _ self stackTop.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ array bitAnd: AtCacheMask.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	result _ self commonVariable: array at: index cacheIndex: atIx.	"Above may cause GC, so can't use stream, array etc. below it"	successFlag ifTrue:		[stream _ self stackTop.		self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 1 thenPush: result].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 14:58'!primitiveNextPut	"PrimitiveNextPut will succeed only if the stream's array is in the atPutCache.	Otherwise failure will lead to proper message lookup of at:put: and	subsequent installation in the cache if appropriate."	| value stream index limit array atIx |	value _ self stackTop.	stream _ self stackValue: 1.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ (array bitAnd: AtCacheMask) + AtPutBase.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	self commonVariable: array at: index put: value cacheIndex: atIx.	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 2 thenPush: value].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/28/1998 15:15'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr)		ifTrue: [self primitiveFail]  "integers have no indexable fields"		ifFalse: [sz _ self stSizeOf: rcvr].	successFlag ifTrue:		[self pop: 1 thenPush: (self positive32BitIntegerFor: sz)]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ls 8/18/1998 06:24'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 1/11/1999 10:38'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self fetchStackPointerOf: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [successFlag _ false.  ^ 0].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 1/11/1999 10:39'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self fetchStackPointerOf: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [self subscript: array with: (index + fixedFields) storing: value format: fmt]		ifFalse: [successFlag _ false]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 1/11/1999 10:39'!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [^ self fetchStackPointerOf: oop]		ifFalse: [^ totalLength - fixedFields]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:37'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:38'!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 1/9/1999 15:30'!primitiveArrayBecome	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self stackTop.	rcvr _ self stackValue: 1.	self success: (self become: rcvr with: arg twoWay: true).	self flushMethodCache.	successFlag ifTrue: [ self pop: 1 ].! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 1/9/1999 15:30'!primitiveArrayBecomeOneWay	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self stackTop.	rcvr _ self stackValue: 1.	self success: (self become: rcvr with: arg twoWay: false).	self flushMethodCache.	successFlag ifTrue: [ self pop: 1 ].! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 12/27/1998 17:01'!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self positive32BitValueOf: (self stackValue: 0).	class _ self stackValue: 1.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self pop: 2 thenPush: (self instantiateClass: class indexableSize: size) ]! !!Interpreter methodsFor: 'object access primitives' stamp: 'jm 12/10/1998 18:49'!primitivePointX	| rcvr | 	self inline: false.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'object access primitives' stamp: 'jm 12/10/1998 18:50'!primitivePointY	| rcvr | 	self inline: false.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 1/11/1999 13:20'!primitiveStoreStackp	"Atomic store into context stackPointer.	Also ensures that any newly accessible cells are initialized to nil"	| ctxt newStackp stackp |	ctxt _ self stackValue: 1.	newStackp _ self stackIntegerValue: 0.	self success: (newStackp >= 0).	self success: (newStackp <= (LargeContextSize-BaseHeaderSize // 4 - CtxtTempFrameStart)).	successFlag ifFalse: [^ self primitiveFail].	stackp _ self fetchStackPointerOf: ctxt.	newStackp > stackp ifTrue:		["Nil any newly accessible cells"		stackp + 1 to: newStackp do:			[:i | self storePointer: i+CtxtTempFrameStart-1	ofObject: ctxt withValue: nilObj]].	self storeStackPointerValue: newStackp inContext: ctxt.	self pop: 1! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 12/27/1998 16:28'!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	self inline: true.	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	((self cCoerce: size to: 'unsigned ') > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/5/1998 21:28'!internalPrimitiveValue	| newContext blockArgumentCount initialIP |	self inline: true.	self sharedCodeNamed: 'commonPrimitiveValue' inCase: 201.	successFlag _ true.	newContext _ self internalStackValue: argumentCount.	self assertClassOf: newContext is: (self splObj: ClassBlockContext).	blockArgumentCount _ self argumentCountOfBlock: newContext.	self success: (argumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: newContext) = nilObj]).	successFlag ifTrue:		["This code assumes argCount can only = 0 or 1"		argumentCount = 1 ifTrue:			[self storePointer: TempFrameStart ofObject: newContext				withValue: self internalStackTop].		self internalPop: argumentCount + 1.		initialIP _ self fetchPointer: InitialIPIndex	ofObject: newContext.		self storePointerUnchecked: InstructionPointerIndex ofObject: newContext			withValue: initialIP.		self storeStackPointerValue: argumentCount	inContext: newContext.		self storePointerUnchecked: CallerIndex		ofObject: newContext			withValue: activeContext.		self internalNewActiveContext: newContext] 	ifFalse:		[messageSelector _ self specialSelector: 25+argumentCount.		self normalSend].! !!Interpreter methodsFor: 'control primitives' stamp: 'di 1/10/1999 23:29'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP |	context _ self stackValue: 1.	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context))		ifTrue: ["context is a block; get the context of its enclosing method"				methodContext _ self fetchPointer: HomeIndex ofObject: context]		ifFalse: [methodContext _ context].	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateContext: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize.	methodContext _ self popRemappableOop.	initialIP _ self integerObjectOf: instructionPointer - method.	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."	self storeWord: InitialIPIndex					ofObject: newContext		withValue: initialIP.	self storeWord: InstructionPointerIndex		ofObject: newContext		withValue: initialIP.	self storeStackPointerValue: 0				inContext: newContext.	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext		withValue: (self stackValue: 0).	self storePointerUnchecked: HomeIndex		ofObject: newContext		withValue: methodContext.	self storePointerUnchecked: SenderIndex		ofObject: newContext		withValue: nilObj.	self pop: 2 thenPush: newContext.! !!Interpreter methodsFor: 'control primitives' stamp: 'jm 12/14/1998 09:53'!primitiveDoPrimitiveWithArgs	| argumentArray arraySize index cntxSize primIdx |	argumentArray _ self stackTop.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	primIdx _ self stackIntegerValue: 1.	successFlag ifFalse: [^ self primitiveFail].  "invalid args"	"Pop primIndex and argArray, then push args in place..."	self pop: 2.	primitiveIndex _ primIdx.	argumentCount _ arraySize.	index _ 1.	[index <= argumentCount]		whileTrue:		[self push: (self fetchPointer: index - 1 ofObject: argumentArray).		index _ index + 1].	"Run the primitive (sets successFlag)"	self pushRemappableOop: argumentArray.	"prim might alloc/gc"	lkupClass _ nilObj.	self primitiveResponse.	argumentArray _ self popRemappableOop.	successFlag ifFalse:		["If primitive failed, then restore state for failure code"		self pop: arraySize.		self pushInteger: primIdx.		self push: argumentArray.		argumentCount _ 2.		"... caller (execNewMeth) will run failure code"]! !!Interpreter methodsFor: 'control primitives' stamp: 'ikp 12/15/1998 23:12'!primitivePerform	| performSelector newReceiver selectorIndex lookupClass |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	lookupClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: lookupClass.	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount.				self transfer: argumentCount					fromIndex: selectorIndex + 1					ofObject: activeContext					toIndex: selectorIndex					ofObject: activeContext.				self pop: 1.				self executeNewMethod.  "Recursive xeq affects successFlag"				successFlag _ true]		ifFalse: [argumentCount _ argumentCount + 1.				messageSelector _ performSelector]! !!Interpreter methodsFor: 'control primitives' stamp: 'ikp 12/15/1998 23:13'!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize lookupClass |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.				messageSelector _ self popStack.				thisReceiver _ self stackTop.				argumentCount _ arraySize.				index _ 1.				[index <= argumentCount]					whileTrue:					[self push: (self fetchPointer: index - 1 ofObject: argumentArray).					index _ index + 1].				lookupClass _ self fetchClassOf: thisReceiver.				self findNewMethodInClass: lookupClass.				self success: (self argumentCountOf: newMethod) = argumentCount.				successFlag					ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"							successFlag _ true]					ifFalse: [self pop: argumentCount.							self push: messageSelector.							self push: argumentArray.							argumentCount _ 2.							messageSelector _ performSelector]]	ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'processes' stamp: 'ikp 12/19/1998 03:44'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: (self splObj: ExternalObjectsArray).				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = (self splObj: ClassSemaphore)				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:34'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:37'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients that trigger interrupts should set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0)		ifTrue: [self checkForInterrupts].! !!Interpreter methodsFor: 'processes' stamp: 'ar 3/21/98 18:39'!signalFinalization: weakReferenceOop	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	interruptCheckCounter _ 0.	pendingFinalizationSignals _ pendingFinalizationSignals + 1.! !!Interpreter methodsFor: 'processes' stamp: 'ikp 12/19/1998 03:46'!transferTo: aProc	"Record a process to be awoken on the next interpreter cycle."	| sched oldProc newProc |	newProc _ aProc.	compilerInitialized ifTrue: [		self pushRemappableOop: newProc.		self compilerProcessChangeHook.		newProc _ self popRemappableOop.	].	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	self newActiveContext:		(self fetchPointer: SuspendedContextIndex ofObject: newProc).	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:11'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.		self ioForceDisplayUpdate].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 9/22/1998 23:09'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 1/10/1999 12:54'!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	rcvr _ self stackValue: 2.	xDelta _ self stackIntegerValue: 1.	yDelta _ self stackIntegerValue: 0.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue:		[self drawLoopX: xDelta Y: yDelta.		self showDisplayBits].	successFlag ifTrue:		[self pop: 2].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:10'!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left displayObj dispBits w h d dispBitsPtr |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj].	left < 0 ifTrue: [left _ 0].	right > w ifTrue: [right _ w].	top < 0 ifTrue: [top _ 0].	bottom > h ifTrue: [bottom _ h].	self success: ((left <= right) and: [top <= bottom]).	successFlag ifTrue: [		dispBitsPtr _ dispBits + BaseHeaderSize.		self cCode: 'ioShowDisplay(dispBitsPtr, w, h, d, left, right, top, bottom)'.		self ioForceDisplayUpdate].	successFlag ifTrue: [self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:14'!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.		self ioForceDisplayUpdate.	].! !!Interpreter methodsFor: 'file primitives' stamp: 'di 12/15/1998 21:55'!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [position _ self sqFileGetPosition: file].	successFlag ifTrue: [self pop: 2 thenPush: (self positive32BitIntegerFor: position)].! !!Interpreter methodsFor: 'file primitives' stamp: 'di 12/15/1998 21:58'!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	newPosition _ self positive32BitValueOf: (self stackValue: 0).	file _ self fileValueOf: (self stackValue: 1).	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].! !!Interpreter methodsFor: 'file primitives' stamp: 'di 12/15/1998 21:56'!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [size _ self sqFileSize: file].	successFlag ifTrue: [self pop: 2 thenPush: (self positive32BitIntegerFor: size)].! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 10/9/1998 11:21'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger)		* The function address (Integer)	"	| thisSession lit functionAddress addr moduleName functionName moduleLength functionLength session |	self var: #thisSession declareC:'static int thisSession = 0'.	"Make sure the session is initialized"	thisSession = 0 ifTrue:[		thisSession _ self ioMicroMSecs bitAnd: 16r1FFFFFFF.		thisSession = 0 ifTrue:[thisSession _ 1]].	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0.	"@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function address and session id in case it has been loaded before"	addr _ self positive32BitValueOf: (self fetchPointer: 3 ofObject: lit).	session _ self fetchInteger: 2 ofObject: lit.	"If so, call the function directly"	(successFlag and:[session = thisSession and:[addr ~= 0]])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'].	"Clean up session id and function address"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	addr _ self ioLoadExternalFunction: functionName + 4				OfLength: functionLength 				FromModule: moduleName + 4				OfLength: moduleLength.	self success: addr ~= 0.	"If the function has been successfully loaded process it"	successFlag ifTrue:[		"Store the session ID"		self storeInteger: 2 ofObject: lit withValue: thisSession.		"Store the address back in the literal"		self pushRemappableOop: lit.		functionAddress _ self positive32BitIntegerFor: addr.		lit _ self popRemappableOop.		self storePointer: 3 ofObject: lit withValue: functionAddress.		(successFlag and:[addr ~= 0])			ifTrue:[self cCode:' ((int (*) (void)) addr) ()'].	].! !!Interpreter methodsFor: 'other primitives' stamp: 'ikp 1/4/1999 11:31'!primitiveFlushCacheByMethod	"The receiver is a compiledMethod.  Clear all entries in the method lookup cache that refer to this method, presumably because it has been redefined, overridden or removed."	| probe oldMethod |	oldMethod _ self stackTop.	probe _ 0.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheMethod) = oldMethod ifTrue:			[methodCache at: probe + MethodCacheSelector put: 0].		probe _ probe + MethodCacheEntrySize].	self compilerFlushCacheHook: oldMethod.		"Flush the dynamic compiler's inline caches."! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 12/14/1998 14:32'!primitiveFlushCacheSelective	"The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined."	| selector probe |	selector _ self stackTop.	probe _ 0.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheSelector) = selector ifTrue:			[methodCache at: probe + MethodCacheSelector put: 0].		probe _ probe + MethodCacheEntrySize]! !!Interpreter methodsFor: 'other primitives' stamp: 'di 1/11/1999 15:25'!primitiveSnapshot	| activeProc dataSize rcvr |	self compilerPreSnapshotHook.	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters: activeContext.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self cleanUpContexts.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].	self compilerPostSnapshotHook.! !!Interpreter methodsFor: 'debug support' stamp: 'ikp 1/14/1999 14:14'!okayInterpreterObjects	| oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: activeContext.	self okayFields: method.	self okayFields: receiver.	self okayFields: theHomeContext.	self okayFields: messageSelector.	self okayFields: newMethod.	0 to: MethodCacheEntries - 1 by: MethodCacheEntrySize do: [ :i |		oopOrZero _ methodCache at: i + MethodCacheSelector.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i + MethodCacheSelector).			self okayFields: (methodCache at: i + MethodCacheClass).			self okayFields: (methodCache at: i + MethodCacheMethod).		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.! !!Interpreter methodsFor: 'debug support' stamp: 'ar 3/21/98 02:37'!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 12/13/1998 14:31'!checkImageVersionFrom: f	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."	"This code is based on C code by Ian Piumarta."	| version firstVersion |	self var: #f declareC: 'sqImageFile f'.	"check the version number"	self sqImageFile: f Seek: 0.	version _ firstVersion _ self getLongFromFile: f swap: false.	(self readableFormat: version) ifTrue: [^ false].	"try with bytes reversed"	self sqImageFile: f Seek: 0.	version _ self getLongFromFile: f swap: true.	(self readableFormat: version) ifTrue: [^ true].	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"	self sqImageFile: f Seek: 512.	version _ self getLongFromFile: f swap: false.	(self readableFormat: version) ifTrue: [^ false].	"try skipping the first 512 bytes with bytes reversed"	self sqImageFile: f Seek: 512.	version _ self getLongFromFile: f swap: true.	(self readableFormat: version) ifTrue: [^ true].	"hard failure; abort"	self print: 'This interpreter (vers. '.	self printNum: self imageFormatVersion.	self print: ' cannot read image file (vers. '.	self printNum: firstVersion.	self cr.	self print: 'Hit CR to quit'.	self getchar.	self ioExit.! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/27/1998 23:16'!cleanUpContexts	"Sweep memory, nilling out all fields of contexts above the stack pointer."	| oop header fmt sz |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			header _ self longAt: oop.			fmt _ (header >> 8) bitAnd: 16rF.			(fmt = 3 and: [self isContextHeader: header]) ifTrue:				[sz _ self sizeBitsOf: oop.				(self lastPointerOf: oop) + 4 to: sz - BaseHeaderSize by: 4					do: [:i | self longAt: oop+i put: nilObj]]].		oop _ self objectAfter: oop.	].! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/18/1998 12:24'!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6502! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/18/1998 12:25'!readableFormat: imageVersion	"Anwer true if images of the given format are readable by this interpreter. Allows a virtual machine to accept selected older image formats."	^ (imageVersion = self imageFormatVersion) or: [imageVersion = 6504]! !!Interpreter methodsFor: 'quick primitives' stamp: 'di 12/28/1998 09:28'!primitiveInstVarsPutFromStack	"Note:  this primitive has been decommissioned.  It is only here for short-term compatibility with an internal 2.3beta-d image that used this.  It did not save much time and it complicated several things.  Plus Jitter will do it right anyway."	| rcvr offsetBits |	rcvr _ self stackValue: argumentCount.	"Mark dirty so stores below can be unchecked"	(rcvr < youngStart) ifTrue: [ self beRootIfOld: rcvr ].	0 to: argumentCount-1 do:		[:i | (i bitAnd: 3) = 0 ifTrue:			[offsetBits _ self positive32BitValueOf: (self literal: i//4 ofMethod: newMethod)].		self storePointerUnchecked: (offsetBits bitAnd: 16rFF) ofObject: rcvr						withValue: (self stackValue: i).		offsetBits _ offsetBits >> 8].	self pop: argumentCount! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/25/1998 06:45'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 09:37'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 17:59'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 11:14'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 14:08'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:34'!byteSizeOf: oop	| slots |	(self isIntegerObject: oop) ifTrue:[^0].	slots _ self slotSizeOf: oop.	(self isBytes: oop)		ifTrue:[^slots]		ifFalse:[^slots * 4]! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| srcName name length |	self var: #className declareC:'char *className'.	self var: #srcName declareC:'char *srcName'.	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	length _ self stSizeOf: name.	srcName _ self cCoerce: (self arrayValueOf: name) to:'char *'.	0 to: length-1 do:[:i|		(srcName at: i) = (className at: i) ifFalse:[^false].	].	"Check if className really ends at this point"	^(className at: length) = 0! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!firstFixedField: oop	self returnTypeC:'void *'.	^self cCoerce: oop+4 to:'void *'.! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!firstIndexableField: oop	| hdr fmt totalLength fixedFields |	self returnTypeC:'void *'.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	fmt < 8 ifTrue:["32 bit field objects"		^ self cCoerce: oop+4+ (fixedFields << 2) to:'void *'.	] ifFalse:["Byte objects"		^ self cCoerce: oop+4+fixedFields to:'void *'.	]! !!Interpreter methodsFor: 'plugin support' stamp: 'di 11/16/1998 20:55'!floatObjectOf: aFloat	| resultOop |	self var: #aFloat declareC: 'double aFloat'.	resultOop _ self clone: (self splObj: FloatProto).	self storeFloatAt: resultOop + BaseHeaderSize from: aFloat.	^ resultOop.! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop KindOf: className	"Support for external primitives."	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	[oopClass == nilObj] whileFalse:[		(self classNameOf: oopClass Is: className) ifTrue:[^true].		oopClass _ self superclassOf: oopClass].	^false! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop MemberOf: className	"Support for external primitives"	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	^(self classNameOf: oopClass Is: className)! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isFloatObject: oop	^(self fetchClassOf: oop) == self classFloat! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isIndexable: oop	^(self formatOf: oop) >= 2! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:38'!methodArgumentCount	^argumentCount! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!methodPrimitiveIndex	^primitiveIndex! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/10/1998 21:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	(self isIntegerObject: oop) ifTrue:[^0].	^self lengthOf: oop! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:02'!compilerActivateMethod	^self cCode: 'compilerHooks[1]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerActivateMethodHook	self inline: true.	^compilerInitialized and: [self compilerActivateMethod]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 1/3/1999 18:00'!compilerFlushCache: aCompiledMethod	^self cCode: 'compilerHooks[2](aCompiledMethod)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 1/3/1999 17:59'!compilerFlushCacheHook: aCompiledMethod	self inline: true.	compilerInitialized ifTrue: [self compilerFlushCache: aCompiledMethod]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:00'!compilerMapFrom: memStart to: memEnd	^self cCode: 'compilerHooks[4](memStart, memEnd)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:03'!compilerMapHookFrom: memStart to: memEnd	self inline: true.	compilerInitialized ifTrue: [self compilerMapFrom: memStart to: memEnd]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/19/1998 17:08'!compilerMark	^self cCode: 'compilerHooks[9]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/19/1998 17:08'!compilerMarkHook	self inline: true.	compilerInitialized ifTrue: [self compilerMark]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:00'!compilerPostGC	^self cCode: 'compilerHooks[5]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:04'!compilerPostGCHook	self inline: true.	compilerInitialized ifTrue: [self compilerPostGC]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:43'!compilerPostSnapshot	^self cCode: 'compilerHooks[8]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:43'!compilerPostSnapshotHook	self inline: true.	compilerInitialized ifTrue: [self compilerPostSnapshot]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerPreGC: fullGCFlag	^self cCode: 'compilerHooks[3](fullGCFlag)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:03'!compilerPreGCHook: fullGCFlag	self inline: true.	compilerInitialized ifTrue: [self compilerPreGC: fullGCFlag]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 13:10'!compilerPreSnapshot	^self cCode: 'compilerHooks[7]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 13:10'!compilerPreSnapshotHook	self inline: true.	compilerInitialized ifTrue: [self compilerPreSnapshot]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerProcessChange	^self cCode: 'compilerHooks[6]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:04'!compilerProcessChangeHook	self inline: true.	compilerInitialized ifTrue: [self compilerProcessChange]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 21:44'!disableCompiler	compilerInitialized _ false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 21:45'!enableCompiler	"Calling this before loading the compiler will provoke a nullCompilerHook error"	compilerInitialized _ true! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:44'!initCompilerHooks	"Initialize hooks for the 'null compiler'"	self cCode: 'compilerHooks[1]= nullCompilerHook'.	self cCode: 'compilerHooks[2]= nullCompilerHook'.	self cCode: 'compilerHooks[3]= nullCompilerHook'.	self cCode: 'compilerHooks[4]= nullCompilerHook'.	self cCode: 'compilerHooks[5]= nullCompilerHook'.	self cCode: 'compilerHooks[6]= nullCompilerHook'.	self cCode: 'compilerHooks[7]= nullCompilerHook'.	self cCode: 'compilerHooks[8]= nullCompilerHook'.	compilerInitialized _ false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:08'!nullCompilerHook	"This should never be called: either the compiler is uninitialised (in which case the hooks should never be reached) or the compiler initialisation should have replaced all the hook with their external implementations."	self error: 'uninitialised compiler hook called'.	^false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/16/1998 01:35'!setCompilerInitialized: newFlag	| oldFlag |	oldFlag _ compilerInitialized.	compilerInitialized _ newFlag.	^oldFlag! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 1/3/1999 17:16'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.! !!Interpreter class methodsFor: 'initialization' stamp: 'di 12/14/1998 15:12'!initializeCaches 	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 1.	MethodCacheClass _ 2.	MethodCacheMethod _ 3.	MethodCachePrim _ 4.	MethodCacheEntrySize _ 4.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 1.	AtCacheSize _ 2.	AtCacheFmt _ 3.	AtCacheFixedFields _ 4.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 1/3/1999 18:02'!initializeCompilerHooks	"Interpreter initializeCompilerHooks"	"compilerHooks[] indices:	1	bool compilerActivateMethodHook(void)	2	bool compilerFlushCacheHook(CompiledMethod *oldMethod)	3	void compilerPreGCHook(int fullGCFlag)	4	void compilerMapHook(int memStart, int memEnd)	5	void compilerPostGCHook(void)	6	void compilerProcessChangeHook(void)	7	void compilerPreSnapshotHook(void)	8	void compilerPostSnapshotHook(void)	9	void compilerMarkHook(void)"	CompilerHooksSize _ 10.! !!Interpreter class methodsFor: 'initialization' stamp: 'di 1/11/1999 10:44'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'translation' stamp: 'ikp 1/3/1999 17:15'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'atCache'		declareC: 'int atCache[', (AtCacheTotalSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.	aCCodeGenerator var: 'semaphoresToSignal'		declareC: 'int semaphoresToSignal[', (SemaphoresToSignalSize + 1) printString, ']'.	aCCodeGenerator var: 'compilerHooks'		declareC: 'int (*compilerHooks[', (CompilerHooksSize + 1) printString, '])()'.! !!Interpreter class methodsFor: 'translation' stamp: 'ar 11/15/1998 23:56'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin. Matrix2x3Plugin. 	BalloonEngineBase. BalloonEnginePlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin methodsFor: 'initialize' stamp: 'ar 10/11/1998 02:06'!setInterpreter: anInterpreter	| ok |	self export: true.	self var: #anInterpreter declareC: 'struct VirtualMachine *anInterpreter'.	interpreterProxy _ anInterpreter.	"Note: 	The following is coded so that it can be run from Squeak			where the return value is ignored."	ok _ self cCode: 'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'.	ok == false ifTrue:[^false].	ok _ self cCode: 'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'.	^ok! !!InterpreterPlugin class methodsFor: 'class initialization' stamp: 'ar 9/16/1998 20:26'!initialize	"Nothing to do ..."! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 9/16/1998 20:27'!declareCVarsIn: aCCodeGenerator	"Note: This method must be implemented by all subclasses to declare variables"	aCCodeGenerator var: 'interpreterProxy'		declareC: 'struct VirtualMachine *interpreterProxy'.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName all: classes doInlining: inlineFlag	"Time millisecondsToRun: [		InterpreterPlugin translate:'all.c' all:{FloatArrayPlugin. FFTPlugin} doInlining: true.		Smalltalk beep]"	| cg theClass |	cg _ PluggableCodeGenerator new initialize.	classes do:[:cls|		theClass _ cls.		theClass initialize.		[theClass == InterpreterPlugin] whileFalse:[			cg addClass: theClass.			theClass declareCVarsIn: cg.			theClass _ theClass superclass]].	(classes includes: InterpreterPlugin) ifFalse:[		cg addClass: InterpreterPlugin.		InterpreterPlugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ PluggableCodeGenerator new initialize.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 11/3/1998 01:14'!translateDoInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translateDoInlining: true.		Smalltalk beep]"	^self translate: (self moduleName,'.c') doInlining: inlineFlag! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^''! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/30/1998 23:12'!simulatorClass	"For running from Smalltalk - return a class that can be used to simulate the receiver.	By default every plugin can simulate itself."	^self! !!InterpreterPlugin class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:45'!doPrimitive: primitiveName	| proxy plugin |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin _ self simulatorClass new.	plugin setInterpreter: proxy.	plugin perform: primitiveName asSymbol.	^proxy stackValue: 0! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 9/16/1998 01:35'!initialize	successFlag _ true.	remapBuffer _ OrderedCollection new.	stack _ OrderedCollection new.! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 10/3/1998 18:50'!loadStackFrom: aContext	self push: aContext receiver.	method _ aContext method.	argumentCount _ method numArgs.	1 to: argumentCount do:[:i| self push: (aContext at: i) ].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems	1 to: nItems do:[:i| stack removeLast].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems thenPush: oop	self pop: nItems.	self push: oop.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:42'!push: object	stack addLast: object! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushBool: trueOrFalse	(trueOrFalse == true or:[trueOrFalse == false]) ifFalse:[self error:'Not a Boolean'].	self push: trueOrFalse! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushFloat: f	self var: #f declareC: 'double f'.	f class == Float ifFalse:[^self error:'Not a Float'].	self push: f.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:20'!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/27/1998 15:22'!stackFloatValue: offset	| oop |	self returnTypeC: 'double'.	oop _ self stackValue: offset.	(self isFloatObject: oop) ifFalse: [self primitiveFail. ^0.0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackIntegerValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifFalse: [self primitiveFail. ^0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackObjectValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 11:47'!stackValue: offset	^stack at: stack size - offset.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!argumentCountOf: methodPointer	^methodPointer numArgs! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/11/1998 03:01'!arrayValueOf: oop	self returnTypeC: 'void *'.	self success: (self isWordsOrBytes: oop).	^CArrayAccessor on: oop.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:23'!byteSizeOf: oop	"Return the size of the receiver in bytes"	^oop class isBytes		ifTrue:[(self slotSizeOf: oop)]		ifFalse:[(self slotSizeOf: oop) * 4]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:22'!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:07'!fetchClassOf: oop	^oop class! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:21'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:19'!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchPointer: index ofObject: oop	^oop instVarAt: index+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchWord: fieldIndex ofObject: oop	^oop instVarAt: fieldIndex+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/18/1998 20:26'!firstFixedField: oop	self returnTypeC:'void *'.	^CObjectAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:22'!firstIndexableField: oop	self returnTypeC:'void *'.	^CArrayAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:38'!literal: offset ofMethod: methodPointer	^methodPointer literals at: offset+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!literalCountOf: methodPointer	^methodPointer numLiterals! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodArgumentCount	^argumentCount! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodPrimitiveIndex	^method primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:39'!primitiveIndexOf: methodPointer	^methodPointer primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 19:03'!sizeOfSTArrayFromCPrimitive: cPtr	"Note: Only called by translated primitive code."	self var: #cPtr declareC: 'void *cPtr'.	^self shouldNotImplement! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	^(oop basicSize) + (oop class instSize)! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index	^array at: index! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index put: value	^array at: index put: value! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:26'!stSizeOf: oop	"Return the number of indexable fields in the receiver"	^oop basicSize! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/25/1998 16:16'!storeInteger: index ofObject: oop withValue: integer	(self isIntegerValue: integer) 		ifTrue:[^self storePointer: index ofObject: oop withValue: integer]		ifFalse:[^self primitiveFail]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:25'!storePointer: index ofObject: oop withValue: valuePointer	^oop instVarAt: index+1 put: valuePointer! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:00'!is: oop KindOf: aString	"InterpreterProxy new is: 42 KindOf: 'Number'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isKindOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:01'!is: oop MemberOf: aString	"InterpreterProxy new is: 42 MemberOf:'SmallInteger'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isMemberOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isBytes: oop	^oop class isBytes! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:44'!isFloatObject: oop	^oop class == Float! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:45'!isIndexable: oop	^oop isVariable! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:12'!isIntegerObject: objectPointer	^objectPointer class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:13'!isIntegerValue: intValue	^intValue class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isPointers: oop	^oop class isPointers! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:16'!isWeak: oop	^oop class isWeak! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 10/9/1998 22:19'!isWords: oop	^oop class isPointers not and:[oop class isBytes not]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:05'!isWordsOrBytes: oop	^(self isBytes: oop) or:[self isWords: oop]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 21:27'!booleanValueOf: obj	obj == true ifTrue:[^true].	obj == false ifTrue:[^false].	self primitiveFail.	^nil! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/4/1998 15:47'!checkedIntegerValueOf: intOop	(self isIntegerObject: intOop)		ifTrue:[^self integerValueOf: intOop]		ifFalse:[self primitiveFail. ^0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:08'!floatObjectOf: aFloat	self var: #aFloat declareC: 'double aFloat'.	aFloat class == Float ifFalse:[self error:'Not a float object'].	^aFloat! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:09'!floatValueOf: oop	self returnTypeC:'double'.	oop class == Float		ifTrue:[^oop]		ifFalse:[self primitiveFail. ^0.0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:13'!integerObjectOf: value	value class == SmallInteger ifFalse:[self error:'Not a SmallInteger object'].	^value! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:10'!integerValueOf: oop	oop class == SmallInteger ifFalse:[self error:'Not a SmallInteger'].	^oop! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:11'!positive32BitIntegerFor: integerValue	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue > 0		ifTrue:[integerValue]		ifFalse:[ (1 bitShift: 32) + integerValue]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:12'!positive32BitValueOf: oop	oop isInteger ifFalse:[self error:'Not an integer object'].	oop < 0 		ifTrue:[self primitiveFail. ^0]		ifFalse:[^oop]! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:43'!characterTable	^Character characterTable! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:42'!displayObject	^Display! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!falseObject	^false! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!nilObject	^nil! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:41'!trueObject	^true! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:42'!classArray	^Array! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classBitmap	^Bitmap! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classByteArray	^ByteArray! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classCharacter	^Character! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classFloat	^Float! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classLargePositiveInteger	^LargePositiveInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classPoint	^Point! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classSemaphore	^Semaphore! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 21:43'!classSmallInteger	^SmallInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classString	^String! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/18/1998 20:11'!clone: oop	^oop clone! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:11'!instantiateClass: classPointer indexableSize: size	^size = 0 		ifTrue:[classPointer basicNew]		ifFalse:[classPointer basicNew: size]! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 10/10/1998 16:14'!makePointwithxValue: xValue yValue: yValue	(xValue class == SmallInteger and:[yValue class == SmallInteger]) 		ifFalse:[self error:'Not SmallInteger objects'].	^xValue@yValue! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!popRemappableOop	^remapBuffer removeLast! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!pushRemappableOop: oop	remapBuffer addLast: oop! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!become: array1 with: array2	array1 elementsExchangeIdentityWith: array2! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!failed	^successFlag not! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!fullDisplayUpdate	Display display! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!fullGC	Smalltalk garbageCollect.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!incrementalGC	Smalltalk garbageCollectMost.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!primitiveFail	(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt].	successFlag _ false.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	aForm == Display ifTrue:[		Display forceToScreen: (Rectangle left: l right: r top: t bottom: b)].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!signalSemaphoreWithIndex: semaIndex	((Smalltalk specialObjectsArray at: 39) at: semaIndex) signal! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/19/1998 13:30'!success: aBoolean	successFlag not ifTrue:[^self].	successFlag _ successFlag and:[aBoolean].	successFlag not ifTrue:[		(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt]].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!superclassOf: classPointer	^classPointer superclass! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!byteAt: accessor	^accessor byteAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:12'!byteAt: accessor put: value	^accessor byteAt: 0 put: value! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor	^accessor longAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor put: value	^accessor longAt: 0 put: value! !!InterpreterProxy class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 00:23'!new	^super new initialize! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 18:45'!generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass _ InterpreterProxy.	cg _ PluggableCodeGenerator new initialize.	cg addClass: proxyClass.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList _ catList collect:[:cat| cat -> (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 19:04'!validateProxyImplementation: anInterpreter	"InterpreterProxy validateProxyImplementation: Interpreter"	"InterpreterProxy validateProxyImplementation: DynamicInterpreter"	| proxyClass catList |	proxyClass _ InterpreterProxy.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList do:[:category|		(proxyClass organization listAtCategoryNamed: category) do:[:selector|			(anInterpreter canUnderstand: selector) 				ifFalse:[self notify: selector, ' is not implemented in ', anInterpreter name]]].! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 11/23/1998 16:46'!close  "close any files that ST may have opened"	filesOpen do: [:f | f close]! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 12/12/1998 22:21'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	atCache _ Array new: AtCacheTotalSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresToSignal _ Array new: SemaphoresToSignalSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'jm 12/6/1998 17:59'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	(self readableFormat: version)		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/11/1998 17:06'!findNewMethodInClass: class"	| cName |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		self cr; print: cName , '>>' , (self stringOf: messageSelector)]."(self stringOf: messageSelector) = 'doesNotUnderstand:' ifTrue: [self halt].	sendCount _ sendCount + 1."	(sendCount > 1000 and: [sendCount\\10 = 0]) ifTrue:		[Transcript print: sendCount; space.		self validate].""	(sendCount > 100150) ifTrue:		[self qvalidate.		messageQueue == nil ifTrue: [messageQueue _ OrderedCollection new].		messageQueue addLast: (self stringOf: messageSelector)]."	super findNewMethodInClass: class.! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/11/1998 17:18'!profile: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profile: 60000"	Transcript clear.	byteCount _ 0.	MessageTally spyOn: [		self internalizeIPandSP.		self fetchNextBytecode.		[byteCount < nBytecodes] whileTrue:			[self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1].		self externalizeIPandSP.	].	self close! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/28/1998 15:35'!profileSends: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"	byteCount _ 0.	MessageTally tallySendsTo: self inBlock: [		self internalizeIPandSP.		self fetchNextBytecode.		[byteCount < nBytecodes] whileTrue:			[self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.			byteCount \\ 100 = 0 ifTrue: [byteCount printString , '  ' displayAt: 0@0]].		self externalizeIPandSP.	] showTree: true.	self close! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/22/1998 23:24'!stackDepth	| ctxt n |	ctxt _ activeContext.	n _ 0.	[(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]		whileFalse: [n _ n+1].	^ n! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/11/1998 17:17'!test	Transcript clear.	byteCount _ 0.	self internalizeIPandSP.	self fetchNextBytecode.	[true] whileTrue:		[self dispatchOn: currentBytecode in: BytecodeTable.		byteCount _ byteCount + 1].	self externalizeIPandSP.! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 1/9/1999 15:31'!testBecome	"Become some young things.  AA testBecome    "	| array list1 list2 p1 p2 p3 p4 |	array _ self splObj: ClassArray.	list1 _ self instantiateClass: array indexableSize: 2.	list2 _ self instantiateClass: array indexableSize: 2.	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p1.	self storePointer: 0 ofObject: list1 withValue: p1.	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p2.	self storePointer: 1 ofObject: list1 withValue: p2.	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p3.	self storePointer: 0 ofObject: list2 withValue: p3.	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p4.	self storePointer: 1 ofObject: list2 withValue: p4.	(self become: list1 with: list2 twoWay: true) ifFalse: [self error: 'failed'].	self popStack = p2 ifFalse: [self halt].	self popStack = p1 ifFalse: [self halt].	self popStack = p4 ifFalse: [self halt].	self popStack = p3 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].! !!InterpreterSimulator methodsFor: 'testing' stamp: 'go 11/18/1998 10:51'!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		self validOop: former].! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'jm 11/23/1998 22:44'!dumpHeader: hdr	| cc |	^ String streamContents: [:strm |		cc _ (hdr bitAnd: CompactClassMask) >> 12.		strm nextPutAll: '<cc=', cc hex.		cc > 0 ifTrue:			[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].		strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: SizeMask) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>']! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'di 12/11/1998 09:31'!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue:			["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;			space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse:			[(self formatOf: oop) = 3			ifTrue:				[strm cr; tab; nextPutAll: '/ next 3 fields are above SP... /'.				lastPtr+4 to: lastPtr+12 by: 4 do:					[:a | val _ self longAt: oop+a.					strm cr; nextPutAll: a hex; 						space; space; space; nextPutAll: val hex8; space; space.					strm nextPutAll: (self shortPrint: val)]]			ifFalse:			[lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]]].	]! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 12/1/1998 00:09'!ioLowResMSecs	^ Time millisecondClockValue! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'di 12/1/1998 00:05'!primitiveRelinquishProcessor	"No-op in simulator"	^ self pop: 1! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'di 1/12/1999 15:38'!primitiveFileDelete 	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (StandardFileStream isAFileNamed: (self stringOf: namePointer)).	successFlag ifTrue: [FileDirectory deleteFilePath: (self stringOf: namePointer)].	successFlag ifTrue: [self pop: 1].  "pop fileName; leave rcvr on stack"! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:46'!floatValueOf: objectPointer	| float len long0 long1 |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	len = 2		ifFalse: [self success: false.  ^0.0].	"Make up a Float from the bits"	long0 _ self fetchWord: 0 ofObject: objectPointer.	long1 _ self fetchWord: 1 ofObject: objectPointer.	float _ Float new: 2.  "No conversion needed for Squeak"	float at: 1 put: long0.	float at: 2 put: long1.	^ float! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:47'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	(self isIntegerObject: floatOrInt) ifTrue: [^ (self integerValueOf: floatOrInt) asFloat].	self assertClassOf: floatOrInt is: (self splObj: ClassFloat).	successFlag ifTrue: [^ self floatValueOf: floatOrInt]! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/27/1998 12:14'!primitiveFloatDivide: rcvrOop byArg: argOop	"NOTE: This method had to be overridden due to the use of // in super"	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr / arg)  " / overrides // "]].! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'ikp 12/15/1998 23:33'!ioForceDisplayUpdate	"no-op"! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primBitmapcompresstoByteArray	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 11/23/1998 22:41'!primBitmapdecompressfromByteArrayat	| indexInt index baOop bmOop baSize bmSize ba bm |	indexInt _ self stackTop.	(self isIntegerValue: indexInt) ifFalse: [^ self primitiveFail].	index _ self integerValueOf: indexInt.	baOop _ self stackValue: 1.	bmOop _ self stackValue: 2.	baSize _ self stSizeOf: baOop.	bmSize _ self stSizeOf: bmOop.	ba _ ByteArray new: baSize.	bm _ Bitmap new: bmSize.	"Copy the byteArray into ba"	1 to: baSize do: [:i | ba at: i put: (self fetchByte: i-1 ofObject: baOop)].	"Decompress ba into bm"	bm decompress: bm fromByteArray: ba at: index.	"Then copy bm into the Bitmap"	1 to: bmSize do: [:i | self storeWord: i-1 ofObject: bmOop withValue: (bm at: i)].	self pop: 3! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primStringcomparewithcollated	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'ikp 12/15/1998 23:30'!primStringfindSubstringinstartingAtmatchTable	^self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 11/8/1998 13:04'!primStringindexOfAsciiinStringstartingAt	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/12/1998 08:32'!pushLiteralConstantBytecode	"Interpreter version has fetchNextBytecode out of order"	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).	self fetchNextBytecode.! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/11/1998 17:32'!pushLiteralVariableBytecode	"Interpreter version has fetchNextBytecode out of order"	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).	self fetchNextBytecode.! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/11/1998 17:34'!pushReceiverVariableBytecode	"Interpreter version has fetchNextBytecode out of order"	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).	self fetchNextBytecode.! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/11/1998 17:35'!pushTemporaryVariableBytecode	"Interpreter version has fetchNextBytecode out of order"	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).	self fetchNextBytecode.! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/12/1998 08:30'!storeAndPopReceiverVariableBytecode	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitely in order to help the translator produce better code."	"Interpreter version has fetchNextBytecode out of order"	| rcvr top |	rcvr _ receiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1.	self fetchNextBytecode.! !!InterpreterSimulator methodsFor: 'bytecode routines' stamp: 'di 12/11/1998 17:32'!storeAndPopTemporaryVariableBytecode	"Interpreter version has fetchNextBytecode out of order"	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: localHomeContext		withValue: self internalStackTop.	self internalPop: 1.	self fetchNextBytecode.! !This class overrides a few methods in InterpreterSimulator required for simulation to work on little-endian architectures (such as the x86 family of processors).  To start it up simply use InterpreterSimulatorLSB instead of InterpreterSimulator (see the class comment there for more details).  For example:	(InterpreterSimulatorLSB new openOn: Smalltalk imageName) testNote that the image must have been saved at least once on the local architecture, since the compiled VM performs some byte swapping that the simulator cannot cope with.!!InterpreterSimulatorLSB methodsFor: 'initialization' stamp: 'ikp 12/11/1998 01:35'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 1)		byte2: (bytes at: 2)		byte3: (bytes at: 3)		byte4: (bytes at: 4)! !!InterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 12/11/1998 01:35'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (0 - lowBits) * 8)		bitAnd: 16rFF! !!InterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 12/11/1998 01:35'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ lowBits * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!InterpreterSimulatorLSB methodsFor: 'debug support' stamp: 'ikp 12/11/1998 01:35'!charsOfLong: long	^ (1 to: 4) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'di 11/15/1998 16:22'!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(String findSubstring:in:startingAt:matchTable:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 11/25/1998 13:39'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'ar 10/9/1998 12:25'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self squeakVirtualMachineHeaderFile	onFileNamed: 'sqVirtualMachine.h'.	self storeString: self squeakVirtualMachineFile	onFileNamed: 'sqVirtualMachine.c'.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	self storeString: self macExternalPrimsFile		onFileNamed: 'sqMacExternalPrims.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives													onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/14/1999 22:58'!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ #(83 73 84 33 0 3 0 0 50 124 114 76 97 117 2 242 0 0 0 22 6 101 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 186 147 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 76 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 178 196 38 5 0 0 41 239 0 0 36 92 0 0 9 125 0 0 9 73 159 17 146 249 0 0 0 0 0 0 93 185 13 192 248 163 215 42 83 182 50 173 35 148 176 115 179 243 57 126 179 65 222 214 90 185 100 179 35 44 55 221 100 235 90 43 243 178 215 205 86 66 63 47 57 225 94 226 169 39 59 101 122 94 28 255 177 179 34 251 216 90 95 103 228 182 17 74 110 147 223 122 222 150 176 125 74 54 97 183 159 236 99 251 188 36 108 75 54 97 132 117 132 18 74 40 143 48 194 99 155 101 29 219 111 116 83 126 73 110 27 219 108 31 121 78 182 157 103 29 91 129 175 174 110 211 171 151 108 233 150 22 61 249 202 182 29 243 8 219 228 248 73 120 228 57 185 125 100 63 195 147 13 208 9 4 160 151 7 96 0 28 0 92 219 13 48 27 255 89 147 68 99 171 42 54 202 82 72 23 163 178 164 136 70 163 100 136 186 26 149 85 69 22 229 136 158 91 125 91 92 150 154 22 45 94 229 137 105 234 230 85 60 86 247 251 3 85 190 186 21 101 28 172 156 117 14 125 14 79 191 188 190 186 254 102 5 160 232 89 100 220 41 139 13 17 41 216 36 170 113 35 18 70 130 68 89 55 57 27 141 97 93 196 159 209 40 139 33 121 163 20 143 24 184 215 155 12 53 38 198 180 176 98 200 154 103 69 13 59 60 112 72 12 74 138 162 26 98 3 178 81 183 200 33 81 221 184 209 34 97 214 105 144 131 82 92 151 197 176 65 244 80 16 30 28 184 155 197 26 225 175 203 1 60 22 202 66 164 21 119 151 106 14 47 30 89 56 109 0 88 164 214 74 82 36 207 47 5 197 213 213 226 162 197 77 162 239 6 223 188 121 158 111 157 171 226 165 77 182 181 177 246 107 184 86 46 135 255 232 64 29 15 140 183 144 49 157 93 47 85 242 192 56 14 146 201 20 156 76 114 180 8 42 54 183 180 118 239 6 88 146 164 207 82 48 199 225 87 21 41 168 14 51 205 134 185 224 228 30 230 19 189 251 151 22 163 71 246 4 144 15 28 151 207 127 142 111 206 122 14 220 0 165 71 176 5 38 226 185 105 212 199 219 153 58 231 119 217 5 172 53 120 236 119 39 214 47 129 122 196 215 157 189 7 234 175 123 198 196 0 144 72 189 55 241 147 179 248 255 141 55 225 77 252 244 228 236 117 168 182 27 78 96 229 29 196 181 150 148 168 244 182 124 254 40 212 191 191 2 214 253 110 3 36 186 143 65 226 142 102 111 98 143 147 157 73 236 218 108 50 49 249 137 121 222 22 170 231 109 105 239 134 91 126 116 231 57 46 136 36 62 185 223 146 56 165 121 2 158 182 122 130 248 245 55 122 203 193 98 111 203 215 241 180 197 15 38 175 135 19 248 31 224 115 199 211 80 191 164 7 247 15 48 46 93 140 243 179 176 155 41 61 25 171 34 99 78 1 142 47 41 17 133 246 39 63 5 193 202 35 80 184 222 37 20 61 236 66 188 21 166 222 57 192 154 150 240 139 92 0 247 141 71 193 45 230 131 251 248 243 144 199 39 95 216 192 39 207 76 134 200 130 110 161 93 104 255 99 129 208 254 243 67 224 254 238 82 161 232 27 61 194 189 74 130 206 128 251 177 66 8 255 126 6 247 190 223 226 249 39 143 9 237 79 137 192 187 247 46 232 134 205 224 126 252 176 208 254 203 46 210 14 96 175 11 224 139 27 206 154 29 14 88 199 203 111 42 152 129 251 68 242 145 149 149 232 40 3 142 32 180 159 250 136 80 188 135 249 153 80 164 157 196 63 211 143 225 83 10 166 83 155 210 121 172 127 8 107 85 32 220 138 53 186 240 127 12 255 29 248 63 202 61 5 124 81 137 95 54 52 117 171 172 53 233 98 181 33 41 33 73 11 137 149 225 6 77 210 182 149 248 171 43 69 95 9 50 106 59 224 132 54 225 215 63 219 133 188 156 230 126 46 66 115 241 228 254 63 36 59 10 191 105 98 120 164 109 14 85 43 76 118 220 116 251 96 189 3 215 159 171 183 55 129 103 42 146 29 11 13 166 93 219 119 186 132 194 157 203 216 255 75 215 183 2 183 224 88 178 99 234 39 192 29 174 76 62 214 220 74 123 161 232 232 41 172 121 48 217 153 76 82 29 172 90 8 215 214 30 134 169 15 182 38 59 119 108 72 118 238 34 78 71 208 33 234 207 236 69 228 51 196 139 181 141 83 40 194 191 89 237 102 230 170 147 177 27 75 48 96 96 190 168 142 199 98 170 102 148 236 4 161 120 249 221 140 61 85 108 59 112 29 180 88 61 176 231 239 61 176 231 135 243 223 234 129 192 193 243 61 176 125 63 251 15 245 192 67 164 140 213 3 219 209 65 255 213 3 24 40 158 0 7 165 44 22 178 86 97 251 43 77 178 246 74 66 177 42 4 2 190 191 84 128 130 155 132 182 125 39 241 159 183 3 248 242 228 15 158 103 249 41 27 246 205 7 254 87 115 97 90 105 32 128 78 246 223 69 214 92 26 139 69 236 1 120 248 253 149 75 51 117 114 209 12 197 21 81 114 6 146 254 213 26 254 64 101 185 77 0 143 58 31 186 153 29 128 174 85 213 85 131 4 223 230 81 83 182 182 38 203 211 208 24 196 142 102 29 204 220 105 95 129 208 118 239 49 114 26 152 59 45 226 90 42 69 34 170 170 136 21 114 36 102 217 9 214 0 58 47 228 156 98 169 133 120 240 158 224 8 95 151 191 206 76 247 67 221 97 242 200 246 4 231 205 179 5 224 145 229 9 142 8 242 15 30 150 236 54 0 186 198 134 137 92 230 33 55 143 8 242 230 50 251 181 241 63 253 154 215 203 35 173 198 68 228 17 144 244 160 20 185 32 172 169 107 76 210 237 2 120 4 135 149 205 232 74 134 70 60 28 196 227 117 39 26 227 193 123 206 231 168 254 149 85 37 223 126 169 95 245 17 159 118 160 12 165 122 148 249 180 85 246 21 159 94 235 91 125 49 199 228 81 145 242 116 146 9 169 193 248 255 44 136 229 15 77 215 210 161 97 148 135 222 24 105 200 212 201 13 148 189 161 42 242 48 226 54 1 60 104 101 123 176 75 254 173 107 128 122 49 147 217 109 80 18 57 74 255 106 141 43 137 124 136 135 109 64 34 95 189 116 37 221 205 167 245 240 7 234 50 122 216 125 36 251 215 84 189 146 236 211 60 46 39 251 139 60 70 147 253 69 93 71 147 125 134 135 253 66 178 31 212 227 159 201 126 72 216 183 147 125 134 199 104 178 31 164 241 78 178 79 243 176 15 72 246 217 30 93 222 244 186 79 67 25 248 17 239 49 241 107 112 102 169 223 167 95 96 3 49 246 31 137 252 181 198 191 146 200 47 56 172 109 64 34 175 11 43 11 62 32 54 47 94 244 110 34 119 190 149 168 144 232 136 115 140 37 170 52 143 203 73 232 162 30 163 73 40 195 99 204 233 7 121 188 227 244 105 30 89 158 180 43 142 71 30 104 12 23 163 251 85 7 234 227 17 9 15 219 98 255 205 199 133 78 35 30 106 3 14 115 93 224 177 186 97 115 134 71 142 127 104 92 228 146 35 142 247 251 125 56 191 100 7 176 254 230 172 227 81 45 214 241 111 240 64 39 139 12 103 214 73 196 35 34 233 186 232 83 163 177 112 228 101 245 83 206 129 29 47 111 180 5 208 245 170 115 244 101 250 244 221 192 24 143 140 67 103 250 172 207 89 141 225 54 27 91 14 156 120 100 0 191 229 205 217 207 113 155 213 70 37 42 69 229 119 217 34 67 142 54 60 78 89 218 188 44 106 4 251 151 30 232 93 83 96 28 142 90 51 31 98 51 195 8 90 83 189 52 143 107 185 6 174 92 16 6 58 8 160 19 79 112 19 205 73 117 177 214 63 114 137 49 180 202 75 171 107 204 219 126 79 79 30 142 207 94 93 75 112 245 130 127 158 182 6 247 222 94 5 25 130 107 49 228 164 252 23 71 23 42 112 46 95 214 244 209 200 225 98 83 234 125 157 241 99 140 136 3 39 76 174 86 159 212 250 3 90 56 170 227 63 108 132 183 200 58 253 109 99 140 40 189 110 189 85 55 36 141 13 162 218 55 44 154 129 206 167 222 182 108 177 127 145 87 178 88 193 14 118 128 195 14 192 202 150 216 64 40 206 77 97 111 54 216 211 172 7 105 202 63 243 2 4 101 17 51 219 112 120 113 64 127 122 19 98 173 45 64 202 201 52 238 159 82 208 224 139 19 228 101 248 230 194 24 33 222 133 181 2 236 250 192 116 56 155 151 149 63 199 183 122 89 217 28 113 206 178 210 154 82 220 6 86 248 106 230 216 173 180 128 139 94 28 233 91 231 94 183 25 55 63 116 255 123 232 149 139 66 238 203 192 199 106 217 45 227 180 152 134 87 138 56 223 95 93 83 53 19 43 238 232 167 163 157 102 87 116 44 109 84 61 2 215 224 214 67 216 242 187 128 174 226 22 19 86 17 0 186 202 61 74 88 236 56 224 60 30 55 141 176 232 118 168 66 140 205 11 222 248 40 224 5 51 119 11 97 238 123 32 140 24 190 48 0 240 225 58 192 215 112 240 101 9 92 213 107 224 99 136 157 33 108 202 3 112 23 186 91 1 97 183 61 4 123 80 130 133 132 161 184 95 0 152 158 207 52 216 9 95 67 172 152 176 121 95 129 67 248 170 206 221 132 45 252 44 230 60 40 194 247 18 0 62 254 61 120 28 49 230 236 227 78 67 15 98 199 9 219 150 128 211 248 8 75 59 97 179 190 15 47 34 118 146 176 53 19 241 181 19 40 126 134 176 137 249 220 36 0 177 147 176 27 190 205 21 33 134 93 4 176 232 62 14 123 64 196 250 0 31 10 114 31 4 120 239 253 132 121 79 112 165 0 51 30 101 122 220 199 249 1 102 126 154 48 229 69 14 223 77 152 121 152 53 84 23 189 6 51 155 213 152 158 32 140 123 130 245 68 0 95 19 146 131 134 136 61 169 135 85 37 151 93 255 247 94 6 79 160 1 17 159 26 146 151 203 138 179 111 88 132 29 179 42 187 173 145 167 84 201 20 94 39 105 74 88 217 164 59 202 66 97 67 213 178 203 85 197 200 77 177 45 107 54 52 73 119 251 226 186 161 70 197 85 242 182 173 170 22 210 93 165 193 160 140 87 209 1 201 104 212 29 53 146 182 73 54 92 75 227 225 72 200 42 152 83 235 195 231 47 100 35 30 155 64 179 164 150 48 121 132 45 11 235 120 139 45 71 27 80 2 103 223 160 41 171 99 177 206 53 71 36 82 66 89 112 175 78 190 114 63 22 155 64 207 70 164 136 17 54 64 172 239 77 9 129 32 28 216 97 245 44 130 46 115 116 25 245 83 228 136 11 167 166 122 185 254 31 0 13 0 107 189 150 249 57 41 79 238 68 126 222 62 105 61 29 240 247 228 148 191 183 153 215 154 215 160 245 106 101 90 19 178 201 113 55 158 173 39 125 252 102 235 121 133 255 250 246 132 25 217 199 200 96 179 142 28 39 188 35 163 77 70 91 178 37 155 236 167 50 91 201 128 187 9 39 19 46 217 100 147 223 228 55 217 39 217 118 228 246 73 56 217 100 147 77 246 41 217 54 32 155 252 102 155 220 38 183 41 112 111 148 123 155 1 68 187 212 124 230 113 60 225 215 17 90 116 147 193 38 163 77 134 155 146 141 39 43 240 5 148 131 110 141 26 70 156 16 226 129 223 45 132 236 248 19 33 59 203 160 23 134 223 213 240 59 76 138 72 11 252 54 120 35 70 202 140 170 22 241 252 244 39 228 179 196 63 60 125 173 157 120 1 129 126 37 88 211 15 241 202 67 74 180 62 168 157 50 21 83 3 212 46 134 87 140 24 2 151 227 209 223 134 138 142 190 72 207 187 128 103 93 60 66 118 79 145 210 103 43 137 231 23 95 37 228 236 180 231 147 85 111 147 61 36 12 245 55 175 163 145 34 58 3 195 195 143 242 199 234 230 11 69 21 100 181 39 90 123 252 6 30 195 220 87 180 255 236 52 249 29 89 69 72 101 3 169 37 221 76 33 84 35 12 153 82 0 164 107 186 173 154 201 166 168 3 239 124 39 176 126 139 252 18 170 218 153 57 24 149 132 148 91 35 1 45 174 134 77 45 97 45 12 179 3 235 64 250 234 228 151 96 138 242 244 75 23 58 160 238 197 254 26 172 107 210 111 218 69 80 87 64 237 133 186 27 223 117 65 125 30 234 98 172 189 88 151 96 189 22 235 178 244 167 127 254 26 212 61 216 63 136 245 234 204 149 237 151 160 222 155 233 93 117 2 234 125 153 137 173 67 80 7 51 231 46 254 1 234 191 51 98 55 57 252 110 176 70 192 11 58 172 51 122 116 145 103 255 251 252 110 152 220 254 103 218 175 253 206 3 19 148 31 151 239 106 228 209 229 253 73 156 231 127 252 255 133 252 21 216 219 232 240 95 201 248 239 212 76 53 106 27 230 153 188 196 193 109 22 248 95 185 130 119 71 247 232 143 181 140 119 255 56 152 164 174 196 11 246 118 88 242 30 70 94 86 206 224 255 55 228 109 106 115 142 238 215 51 254 123 141 51 150 173 69 79 23 156 93 224 58 186 95 135 252 172 24 225 239 158 98 15 205 121 117 142 206 43 24 207 125 170 61 102 152 119 105 38 31 151 60 63 132 126 46 248 93 63 57 117 141 246 75 39 95 186 120 13 234 72 250 157 11 91 110 243 46 248 110 64 125 220 227 253 126 196 115 120 223 244 237 87 255 216 2 245 125 23 223 250 86 234 67 29 124 193 51 1 44 54 56 122 223 196 116 16 81 77 77 137 119 232 177 80 79 103 79 216 48 237 91 138 104 207 250 221 1 233 123 143 77 102 186 105 223 135 239 132 94 158 192 119 78 46 18 250 17 62 25 194 119 125 89 223 124 28 231 16 62 114 8 241 28 31 173 68 156 42 156 163 35 125 245 202 151 255 237 175 187 151 124 182 5 231 252 175 254 202 184 254 140 148 30 91 204 228 59 165 254 30 69 126 54 98 253 240 228 143 223 121 79 135 142 238 26 81 111 243 250 115 245 214 140 56 142 222 154 240 157 240 55 71 127 66 119 187 144 167 71 176 158 215 225 202 3 250 123 214 243 41 166 34 153 3 96 143 1 250 59 166 233 49 99 108 65 128 31 203 234 111 222 223 132 158 218 176 222 60 121 241 27 180 238 68 28 55 47 8 221 57 58 123 10 231 109 77 255 106 199 215 175 235 236 233 165 92 225 228 199 61 216 223 154 205 25 75 250 42 236 137 66 154 21 253 96 79 244 137 21 47 246 68 89 126 171 172 145 67 241 24 243 239 69 142 159 89 169 131 95 200 201 31 146 11 223 254 21 47 248 125 153 208 13 107 185 227 255 213 214 200 81 205 180 83 74 28 98 192 176 166 171 243 28 247 75 126 29 94 255 195 163 195 223 251 251 200 53 49 221 252 96 105 59 3 7 27 61 153 203 231 243 222 3 88 111 145 57 229 65 236 215 99 237 232 118 62 103 215 97 189 29 235 109 50 95 136 125 134 208 177 179 199 8 144 238 85 191 133 90 240 136 58 173 11 41 246 48 44 218 125 129 80 107 219 193 250 134 221 90 115 91 108 87 19 188 144 252 15 8 157 206 205 81 19 58 198 71 232 79 233 182 150 80 111 79 192 191 35 139 115 84 135 77 99 16 22 195 102 107 219 105 24 40 55 6 57 186 56 71 89 15 221 199 15 42 81 53 55 1 255 142 45 206 177 57 20 9 214 251 154 80 30 1 197 156 87 200 141 187 1 54 69 123 185 187 243 75 191 241 163 47 122 38 6 252 199 7 104 7 48 1 181 106 167 235 72 83 159 47 250 30 71 165 29 216 19 179 89 221 189 242 212 231 254 118 9 81 161 3 215 28 12 117 181 53 210 52 92 16 7 245 126 142 202 82 192 154 118 64 237 109 45 78 128 103 20 112 153 99 115 94 105 167 152 163 122 45 59 166 25 121 88 230 215 2 245 60 241 114 212 18 64 141 107 167 114 176 18 181 100 6 213 212 244 161 123 168 107 145 87 102 92 11 188 222 64 45 109 135 29 125 119 77 25 232 174 91 85 98 170 105 221 193 102 251 8 134 202 58 235 40 106 87 219 218 78 213 58 125 32 53 7 9 31 115 115 134 202 58 101 28 213 59 112 38 169 230 48 129 33 234 253 156 33 218 41 231 168 53 62 67 143 105 182 102 192 230 29 200 50 13 57 1 75 50 28 149 118 42 56 234 186 144 54 174 198 66 70 44 43 9 150 87 56 42 237 172 231 168 37 254 81 85 183 243 20 177 148 196 213 64 59 149 56 235 225 20 56 100 204 84 198 230 128 89 22 226 168 180 83 197 81 215 207 160 14 168 227 246 45 100 169 161 106 84 222 161 200 17 91 139 231 40 146 26 170 65 94 67 106 130 250 106 206 81 104 138 19 106 40 34 181 168 87 122 227 82 208 171 100 104 131 208 144 105 26 89 55 97 106 160 137 147 171 129 118 238 227 185 161 4 164 61 224 11 231 80 105 14 228 94 206 18 225 70 84 94 71 50 25 87 7 148 248 233 57 96 201 208 38 62 107 101 71 44 102 170 150 117 60 168 80 91 153 133 166 217 147 207 202 82 104 29 206 218 175 90 252 110 236 95 179 222 47 60 207 84 146 203 26 218 140 42 239 82 45 91 137 223 118 5 212 16 77 227 92 67 180 179 5 81 3 70 60 103 228 183 102 221 138 188 14 192 217 92 193 83 36 234 54 129 10 166 181 140 186 29 189 33 18 53 181 100 142 86 7 181 30 157 18 210 112 188 160 62 137 250 128 80 131 54 78 215 3 75 106 120 16 245 218 19 53 244 101 189 238 224 73 212 189 123 155 242 158 8 98 126 133 14 236 155 25 170 187 229 207 52 126 101 63 230 87 232 192 174 89 204 186 176 155 206 92 217 123 94 164 222 189 231 225 82 133 161 186 151 45 153 215 58 207 33 42 116 200 67 51 57 111 84 203 57 222 172 151 55 160 55 192 22 4 64 173 37 167 220 133 202 227 66 200 41 143 93 6 240 89 105 231 97 142 90 230 51 18 73 67 207 165 54 137 250 8 162 178 89 123 244 100 106 206 139 36 234 163 28 181 156 165 141 124 68 148 188 54 114 212 98 127 56 236 43 228 114 153 41 155 144 33 0 165 198 124 202 24 191 131 45 103 109 230 168 21 125 134 173 13 106 209 185 92 51 139 218 130 42 231 102 146 87 249 205 252 250 24 71 45 133 92 110 155 70 46 138 74 212 199 81 229 33 85 207 239 13 102 81 159 16 62 4 135 72 198 208 61 134 118 35 67 52 163 248 97 119 144 133 149 106 216 35 18 27 236 81 204 143 18 64 43 69 13 252 160 52 137 155 191 44 48 187 203 224 9 155 118 158 68 94 35 108 211 115 47 177 181 137 92 14 202 91 206 40 79 33 106 216 24 187 203 171 244 242 167 133 43 71 33 192 126 52 235 51 60 109 184 247 15 83 63 251 245 203 152 135 160 67 246 114 212 82 107 4 60 101 80 155 223 124 209 29 62 102 20 232 144 125 28 21 110 51 195 113 197 30 52 204 68 36 169 70 169 253 253 3 159 110 252 17 21 58 112 81 50 147 162 238 94 160 100 70 143 100 16 21 58 112 199 32 82 212 194 221 67 166 241 185 231 69 98 123 238 121 184 142 99 168 238 53 221 165 87 223 156 228 168 180 67 58 68 86 102 128 133 45 32 92 174 225 62 15 58 7 48 43 67 30 74 44 103 101 31 71 173 246 245 135 248 184 115 129 79 162 118 34 67 65 99 12 22 75 249 77 207 77 87 246 115 53 184 55 212 153 198 23 3 66 67 47 6 72 128 111 55 203 20 221 210 78 38 21 19 192 222 155 87 110 109 187 196 38 85 251 140 122 50 191 111 144 59 209 110 142 90 172 167 226 121 221 205 206 218 195 81 215 142 42 39 227 154 149 27 86 206 218 203 81 189 49 109 180 64 144 51 235 65 156 117 44 58 172 152 121 92 57 107 144 43 239 214 85 203 77 120 122 107 130 202 131 14 9 161 202 15 194 209 179 154 215 131 204 13 125 28 181 6 71 244 143 71 213 36 77 163 82 182 210 81 14 137 252 170 36 212 126 117 8 100 116 103 91 41 103 13 207 120 94 76 13 152 202 80 98 46 153 203 89 15 207 228 134 133 155 238 204 185 203 47 8 53 92 126 1 46 125 178 26 186 153 2 164 134 34 124 203 94 249 238 150 157 223 98 56 122 165 215 126 19 161 144 175 155 117 6 40 170 239 13 247 186 37 125 245 149 215 61 19 161 112 16 174 143 94 121 157 28 161 168 157 237 238 45 75 250 234 101 85 160 94 86 201 81 54 107 157 123 185 2 169 21 110 41 24 42 116 200 49 134 90 227 222 169 164 15 255 176 221 51 97 217 169 83 180 67 142 83 247 242 53 187 87 41 233 223 127 237 187 56 43 116 224 63 39 152 242 254 249 31 21 92 121 215 251 240 63 32 164 40 28 81 135 166 167 103 30 193 27 56 84 134 55 80 146 53 45 131 109 208 223 70 255 29 35 28 180 108 10 0 111 224 63 54 170 2 112 207 243 253 112 32 110 209 55 255 7 0 0 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 103 99 116 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 39 34 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 196 37 239 0 0 42 205 0 0 36 92 0 0 10 77 0 0 9 25 105 70 116 109 0 0 0 0 0 0 103 96 13 192 248 163 239 49 175 149 233 177 219 43 215 227 52 251 149 13 210 46 175 149 29 225 110 194 79 178 18 30 187 181 179 223 52 57 181 147 211 147 121 201 211 139 226 169 225 153 103 173 249 28 127 197 143 214 187 111 45 194 202 179 200 62 38 225 73 54 217 172 232 54 186 223 142 108 22 97 100 235 62 178 7 198 200 115 66 201 62 186 41 161 252 98 100 75 201 102 151 155 109 59 218 102 117 146 109 199 46 111 191 132 17 126 110 182 245 240 192 87 93 114 154 229 229 185 165 69 51 143 176 77 152 71 216 38 183 117 179 77 126 147 223 100 63 195 147 13 140 247 76 47 15 15 124 0 28 0 100 220 1 48 11 207 184 187 252 202 161 15 221 207 129 242 122 16 110 176 43 135 241 124 179 124 227 124 171 242 170 122 43 76 46 185 171 94 20 86 187 92 14 107 80 10 212 2 143 213 157 78 87 177 163 108 105 14 7 249 73 189 217 67 141 248 252 68 108 89 89 61 13 244 222 23 1 174 175 155 177 196 170 252 102 243 99 249 57 171 116 203 54 110 126 202 54 21 51 105 121 126 165 101 190 21 76 120 26 240 28 83 184 237 168 174 232 247 96 170 48 44 219 72 111 131 186 39 139 221 69 11 18 10 14 166 31 86 130 133 43 11 235 23 0 36 48 108 9 236 139 143 129 37 114 123 35 62 1 3 10 75 1 242 94 225 82 103 225 11 30 116 244 142 81 73 247 56 243 119 241 174 82 75 193 235 131 130 103 181 80 45 158 226 82 141 177 145 247 86 121 77 221 233 247 227 74 214 200 33 177 206 225 19 100 89 148 207 64 152 249 14 83 167 67 7 60 22 138 195 76 19 222 46 214 28 8 30 81 96 207 106 6 68 62 49 98 114 10 30 75 81 137 5 37 194 226 152 239 152 59 215 250 237 222 42 118 181 205 212 75 228 190 140 107 226 18 249 251 142 215 193 214 239 239 226 190 48 156 168 100 133 4 148 50 37 154 86 20 142 130 82 83 212 43 197 166 77 0 75 20 250 34 12 38 234 156 1 191 224 9 12 32 141 135 217 144 196 125 159 15 119 223 79 4 131 167 42 136 25 56 206 205 63 192 255 48 238 105 48 2 100 182 98 11 140 195 119 105 212 199 31 99 236 156 186 197 167 178 214 224 177 223 147 176 190 13 202 49 191 226 216 227 80 126 253 111 213 28 0 2 41 183 135 127 126 12 207 131 246 176 61 220 181 251 186 21 200 182 17 118 98 229 117 132 21 85 14 184 2 123 227 231 183 67 249 13 121 176 226 245 10 8 239 233 132 240 3 13 246 240 99 73 236 77 120 125 173 138 68 197 103 49 217 27 169 158 189 177 121 15 220 241 179 135 122 177 96 38 252 224 215 34 20 71 57 15 195 203 145 158 32 124 61 141 222 184 117 138 189 241 41 124 29 193 7 19 86 194 78 60 143 227 121 224 101 40 95 178 23 239 223 97 88 58 24 230 215 96 19 99 122 2 86 69 196 156 31 56 222 102 179 232 155 95 218 0 158 130 86 72 95 105 208 79 73 216 139 249 38 72 121 232 56 106 10 253 43 201 0 198 155 183 131 209 98 6 227 79 14 131 137 87 254 84 193 43 71 38 128 111 225 30 125 179 190 249 104 170 190 249 215 216 143 207 101 233 39 127 99 175 254 203 254 48 189 1 227 142 116 240 190 49 157 155 115 8 223 191 212 169 111 254 149 5 120 99 203 194 61 232 7 140 47 60 163 111 254 93 7 113 7 208 98 0 248 82 197 177 136 71 192 58 118 190 58 117 58 222 195 202 179 249 5 168 40 199 21 65 223 188 175 80 63 229 11 38 150 155 44 237 198 147 241 199 242 19 83 39 81 155 210 123 172 255 52 214 202 195 116 19 214 232 192 179 19 207 54 60 183 163 162 240 70 27 138 43 106 107 73 125 48 24 144 66 54 210 54 59 112 181 175 118 130 57 185 3 198 63 49 59 38 64 243 212 174 196 170 92 237 129 5 96 94 182 23 207 157 53 202 27 118 204 207 33 57 4 243 53 243 48 119 24 79 19 76 104 116 99 253 214 153 16 31 143 121 203 91 245 17 223 1 151 154 159 23 226 230 254 168 69 246 72 94 72 201 70 101 187 102 30 83 213 218 131 200 54 242 195 234 143 193 250 196 71 106 172 3 102 188 182 206 254 232 183 66 152 65 33 32 60 7 191 14 230 169 91 184 108 131 11 115 187 16 95 19 147 204 241 79 220 175 214 71 62 168 190 121 90 48 130 32 21 166 145 90 114 197 192 79 182 57 197 144 20 184 71 148 86 203 150 146 144 224 175 18 164 42 75 129 183 82 18 164 53 54 103 73 129 197 97 195 74 207 239 78 130 135 245 7 126 185 30 171 39 169 119 106 142 217 248 242 167 111 42 109 233 223 84 115 248 228 225 218 32 86 75 87 218 22 223 219 87 111 247 188 222 122 58 19 190 201 83 218 62 72 140 226 155 253 29 156 235 72 43 157 250 22 79 5 112 11 59 149 182 148 143 131 209 91 160 236 104 104 162 59 119 91 106 45 214 220 170 180 99 183 96 29 172 234 130 89 165 207 64 202 182 38 165 125 93 133 210 190 62 140 239 91 81 37 203 143 180 96 230 83 132 139 49 159 132 149 232 164 106 183 171 205 96 254 5 232 200 101 69 76 86 129 215 191 90 148 78 58 148 225 10 48 177 157 123 126 199 110 60 77 235 128 207 85 118 29 102 254 41 126 251 142 5 192 239 159 13 105 153 46 23 42 217 127 131 164 57 51 24 244 105 3 224 112 58 11 178 134 234 36 163 16 88 150 214 145 58 18 245 103 106 56 93 5 185 26 1 56 202 28 40 130 90 0 188 22 151 20 247 1 124 31 135 59 103 185 59 206 90 89 227 233 234 234 2 174 253 81 246 112 255 35 76 165 236 15 214 162 126 199 101 27 178 4 159 47 16 240 91 242 68 31 19 215 15 44 226 97 255 198 173 208 146 177 8 54 219 58 233 9 225 224 173 158 115 120 13 206 50 213 221 247 119 135 138 35 222 234 153 59 87 19 0 71 156 213 115 142 144 191 225 136 122 138 171 188 6 7 128 92 194 33 54 156 35 228 66 168 253 90 243 159 126 37 107 170 226 24 100 99 28 226 112 9 178 71 240 157 37 86 229 53 40 244 253 234 250 7 14 207 0 179 67 188 146 9 37 28 58 194 241 158 18 141 226 224 173 167 124 84 79 196 21 139 247 94 236 87 249 156 78 235 144 134 76 185 142 233 52 123 255 142 78 47 119 20 13 251 24 19 21 201 29 116 50 85 1 79 253 255 36 136 249 15 73 150 6 77 195 8 14 185 198 87 57 84 39 217 149 115 158 85 196 17 170 215 8 192 65 17 111 197 46 249 55 175 46 234 69 213 145 223 180 232 86 237 22 71 142 212 159 169 113 217 145 247 227 208 12 112 228 69 89 249 150 97 62 156 174 178 33 62 180 62 156 253 187 172 94 118 246 131 56 46 57 251 97 28 35 206 126 152 215 17 103 63 132 67 123 193 217 247 241 241 79 103 223 79 236 251 206 126 8 199 136 179 239 131 113 197 217 15 226 208 14 112 246 241 86 89 172 126 79 167 113 118 96 14 205 13 204 134 172 153 168 207 173 189 58 157 203 116 90 251 195 145 191 219 248 151 29 249 89 133 213 12 112 228 101 94 255 194 27 45 13 139 110 250 151 35 79 250 187 163 66 160 231 148 99 212 81 13 226 184 228 132 134 249 24 113 66 67 56 70 149 190 15 199 21 165 31 196 17 103 29 84 197 49 136 3 133 97 216 186 95 85 160 24 14 159 119 64 22 123 254 124 156 237 52 194 17 168 196 97 174 179 56 138 42 107 135 112 36 58 251 199 69 46 42 226 24 167 211 129 243 75 90 0 241 87 101 29 131 108 177 142 63 143 3 149 204 55 224 89 199 19 14 26 207 180 56 2 117 65 175 239 109 246 163 202 129 29 47 174 210 4 224 245 170 114 196 60 253 224 191 129 81 28 67 10 61 212 103 49 101 13 13 180 217 104 232 112 226 145 37 248 187 47 204 126 38 212 6 106 252 117 66 93 255 124 238 249 64 132 28 93 120 156 178 212 120 9 106 4 237 151 30 232 142 137 52 59 220 221 23 61 25 154 199 165 78 81 179 201 160 199 12 59 34 239 219 65 127 97 10 250 124 44 193 80 255 246 115 225 229 39 167 139 175 4 225 233 78 158 158 182 70 156 39 139 46 130 196 40 249 72 103 158 40 84 137 146 60 98 57 12 16 199 134 173 153 186 226 249 98 207 88 254 219 125 165 229 19 119 222 41 135 4 137 253 96 212 110 8 106 99 51 196 241 17 89 228 162 123 19 40 72 43 187 133 17 218 216 166 5 13 16 198 185 137 200 35 237 96 56 17 227 212 221 24 165 78 151 228 173 147 189 126 11 221 189 33 239 221 127 89 250 160 73 18 219 72 229 35 125 96 41 117 146 253 161 93 33 180 41 36 22 185 153 37 110 213 219 216 62 139 99 250 45 248 4 79 19 155 13 215 58 104 220 183 92 80 223 198 9 210 46 220 185 48 10 136 55 96 45 156 141 143 124 154 47 97 206 112 20 101 231 100 88 50 178 51 221 153 120 117 45 117 184 51 180 86 90 192 16 251 107 64 209 187 91 39 97 129 8 215 210 150 139 116 238 199 192 7 75 217 95 198 180 160 132 191 20 167 194 172 18 119 241 12 172 248 213 30 56 137 153 236 23 29 115 77 183 255 0 104 107 3 46 182 0 184 237 62 160 255 52 19 41 151 191 1 104 38 144 246 22 64 253 181 240 17 188 110 161 220 56 55 84 227 149 240 194 180 235 0 177 114 249 148 211 255 1 62 138 57 84 94 128 181 93 64 155 6 158 163 156 240 71 120 156 249 116 140 218 187 225 43 76 221 48 50 191 8 79 98 142 237 216 48 167 192 247 48 215 192 184 81 224 89 204 125 134 114 233 115 96 23 210 132 59 18 0 110 121 1 186 0 38 61 66 185 80 10 236 195 92 51 229 114 118 194 33 92 188 194 56 243 183 81 103 76 193 189 61 232 1 36 110 60 230 22 83 174 226 40 151 142 57 26 205 0 211 62 14 23 48 76 77 99 181 19 184 155 49 199 86 134 132 220 28 206 10 78 101 191 97 87 47 230 156 200 46 155 249 203 255 36 87 142 57 236 52 128 85 127 230 208 112 76 99 166 35 237 211 28 206 210 76 191 145 114 142 79 112 107 113 29 5 155 161 156 147 193 109 192 197 59 108 251 205 218 207 113 200 227 204 91 88 211 117 208 86 141 89 172 198 164 48 229 120 182 119 193 232 66 23 35 122 66 22 236 91 217 27 240 167 58 133 106 175 199 226 16 130 39 126 29 227 175 159 232 67 245 79 250 248 216 131 8 134 100 54 94 208 93 113 44 13 160 56 2 85 226 135 69 127 82 108 24 133 61 139 84 52 70 70 170 162 37 163 249 50 65 242 123 253 213 178 46 167 202 27 10 72 241 185 1 127 40 57 202 84 78 67 72 18 100 163 163 94 14 5 234 44 183 138 107 238 9 72 85 178 33 211 227 17 145 47 151 16 170 145 117 110 65 170 22 67 134 172 122 175 175 42 82 48 177 212 129 43 70 196 80 125 112 44 205 170 70 136 49 81 46 219 43 35 213 98 93 37 82 144 20 27 100 101 117 162 220 170 35 24 81 162 34 233 110 158 28 185 78 44 54 150 253 23 139 0 163 220 113 96 177 157 21 122 74 225 64 16 171 23 1 104 80 71 163 145 63 191 232 51 224 84 86 55 214 255 3 0 0 0 13 0 84 246 90 230 40 175 73 126 126 202 61 249 128 94 114 123 55 219 158 151 30 95 59 153 223 122 236 86 166 199 6 18 78 182 110 60 91 79 250 248 205 214 243 10 255 245 109 178 7 52 194 99 100 176 53 114 156 176 77 102 155 140 182 100 75 54 217 39 181 107 37 155 60 35 199 35 191 149 108 178 201 38 155 252 38 251 200 111 178 201 109 194 9 39 155 108 178 9 239 24 97 53 32 155 252 246 200 113 114 155 1 247 182 110 118 81 128 40 55 117 194 233 133 39 252 34 71 111 211 77 6 155 140 54 25 110 74 246 26 30 248 2 26 100 71 163 134 17 39 132 148 193 119 11 33 59 255 66 72 83 21 244 66 240 93 9 223 33 226 33 109 240 221 66 172 115 219 25 198 228 230 223 64 77 72 250 189 147 172 150 191 50 142 215 188 136 7 88 244 219 76 222 246 62 215 178 247 171 55 137 231 70 51 33 222 231 224 213 122 248 35 63 124 141 244 145 13 51 152 128 33 122 55 154 87 165 250 127 112 151 219 109 126 235 87 254 132 11 244 126 36 251 246 121 242 130 231 115 187 134 62 192 243 2 220 65 207 33 80 226 6 89 65 72 93 51 105 36 221 204 33 212 35 40 49 253 85 104 186 173 154 201 214 104 129 58 254 250 177 126 139 80 39 52 102 121 16 15 235 84 91 195 126 45 174 134 76 45 97 205 145 57 132 117 119 250 250 196 215 128 133 55 253 202 139 29 80 7 176 191 29 235 234 244 155 182 7 234 10 168 189 80 247 226 187 30 168 47 66 189 3 235 7 176 222 137 117 19 214 229 233 47 252 250 13 168 143 96 63 136 245 182 204 181 109 87 160 222 151 233 93 209 15 245 254 204 248 214 65 168 187 50 23 38 255 4 245 223 153 156 27 111 249 132 117 214 89 195 65 37 218 97 157 215 163 243 58 183 223 211 183 118 98 219 95 105 191 230 181 29 227 84 31 87 239 42 212 209 213 253 73 228 243 63 253 255 70 222 3 245 54 56 254 174 99 250 119 106 166 26 181 13 243 124 209 226 91 239 233 191 124 133 238 57 223 55 50 221 187 198 96 72 234 74 188 52 222 58 165 238 126 212 101 249 12 253 223 38 127 160 99 206 241 125 45 211 191 215 56 111 217 90 244 92 105 178 127 54 231 251 167 80 159 101 35 230 123 89 121 89 5 168 180 201 241 121 13 211 249 168 106 143 26 230 199 50 147 195 82 231 221 56 207 133 190 171 39 166 222 165 253 7 39 94 153 124 23 234 93 233 119 94 220 125 71 119 161 119 51 250 99 81 247 70 196 115 116 95 251 189 215 255 220 6 117 221 228 91 223 77 125 234 131 175 148 141 131 138 205 142 15 54 50 31 132 85 83 83 226 29 122 44 216 211 217 19 50 76 251 67 71 60 157 155 119 7 229 220 123 108 34 211 77 251 207 224 59 225 151 199 241 157 147 139 132 127 196 156 60 138 239 142 229 230 230 94 228 33 230 72 8 241 156 57 90 137 56 107 144 199 129 244 245 107 95 255 247 124 125 98 97 206 182 33 207 255 250 175 138 251 207 72 233 177 249 76 126 191 244 223 163 168 79 61 214 15 79 252 226 157 143 124 232 248 174 5 253 150 247 159 235 183 61 136 227 248 173 21 223 137 249 230 248 79 248 238 33 212 233 17 172 243 62 92 126 192 127 207 151 125 30 220 211 228 248 15 246 24 224 191 83 154 30 51 70 231 12 216 151 243 95 126 190 9 63 133 177 94 55 49 249 109 90 71 16 199 205 11 194 119 142 207 78 32 223 211 233 223 238 252 214 45 159 157 92 200 21 78 126 60 133 253 13 185 156 177 224 175 153 61 209 45 127 105 86 244 147 61 81 199 178 23 123 162 156 190 245 214 240 177 120 140 205 239 121 141 63 179 92 135 190 144 147 63 21 23 126 207 46 123 161 239 171 228 59 116 28 57 250 174 181 134 79 106 166 157 82 226 16 3 134 52 93 205 107 236 147 250 58 186 254 71 71 71 191 123 123 169 85 49 221 252 100 105 75 129 176 22 185 80 248 48 159 247 54 99 189 94 230 148 45 216 191 15 107 199 183 249 156 221 128 245 38 172 55 202 124 33 246 25 194 199 206 30 195 79 186 87 252 30 106 190 174 206 238 165 106 130 167 124 125 41 221 214 18 106 107 64 59 91 212 31 182 223 236 231 240 16 121 36 24 14 108 247 181 134 66 190 121 26 228 120 142 7 234 225 13 42 246 208 60 3 132 155 231 81 213 67 247 241 3 74 84 189 71 70 204 131 28 143 218 164 105 12 192 162 218 164 202 198 75 84 232 125 68 150 83 59 176 240 53 184 26 164 143 255 172 189 108 220 178 83 103 105 135 120 56 170 235 0 137 186 130 162 118 94 114 125 156 190 126 245 114 217 120 48 20 240 211 14 89 201 184 110 114 213 133 44 252 125 68 133 14 204 64 64 173 111 114 103 230 212 151 61 63 42 27 143 116 157 142 208 14 41 167 92 15 239 247 70 206 39 85 171 117 250 190 226 54 87 58 183 24 42 235 120 57 106 131 207 208 99 154 173 25 176 53 134 36 97 26 146 1 155 194 28 149 118 42 56 234 154 160 54 166 198 130 70 76 157 229 203 102 45 71 165 157 213 28 181 162 107 68 213 237 162 68 108 194 51 84 214 169 68 174 199 83 176 209 141 153 202 232 44 48 155 227 28 149 118 214 112 212 218 44 106 68 29 179 63 68 102 211 156 161 178 78 21 71 93 125 44 124 194 214 226 5 137 164 135 170 81 215 160 154 160 183 6 121 93 89 2 17 110 240 144 26 244 43 189 207 40 249 85 42 84 43 60 100 154 134 89 242 16 77 75 220 13 180 83 199 39 74 5 88 59 226 11 21 80 105 134 225 19 133 165 153 122 116 94 71 50 25 87 35 74 252 220 44 176 84 104 45 231 90 215 17 139 153 170 101 157 14 40 116 172 204 64 211 220 196 185 178 4 213 128 92 251 84 203 72 153 209 188 35 36 215 70 49 243 76 37 185 228 161 117 232 242 195 170 101 43 241 59 83 1 61 68 147 36 247 16 237 172 71 84 191 17 143 169 69 235 73 174 27 80 215 8 156 124 149 102 138 68 221 40 80 97 104 45 161 110 194 217 16 142 154 90 178 32 171 131 122 31 78 74 72 81 241 146 251 36 234 102 225 6 109 140 6 169 5 55 108 65 191 246 68 13 125 201 175 91 233 68 105 175 118 111 122 166 190 244 254 21 204 67 208 129 141 51 67 117 55 212 153 150 111 28 226 168 180 67 182 113 212 149 214 112 81 30 138 10 219 26 68 133 14 217 222 14 185 189 119 95 121 162 100 5 154 0 232 142 133 39 0 218 217 193 81 189 150 29 211 140 82 98 163 27 22 129 122 145 60 192 81 43 0 21 162 100 49 109 76 163 238 204 162 154 154 62 184 136 218 132 186 178 188 59 167 235 109 212 7 169 203 187 27 170 192 119 221 170 82 24 150 108 131 204 231 43 237 236 226 168 213 255 64 133 180 124 135 43 221 55 143 7 131 190 110 214 217 141 115 168 83 29 209 10 169 97 38 15 53 227 124 13 153 6 128 90 11 105 227 33 156 94 124 152 20 236 192 46 3 56 87 218 121 152 163 86 249 140 68 210 208 11 201 87 162 62 130 168 140 107 143 158 76 205 206 115 137 250 40 71 173 102 137 173 24 179 165 174 45 28 181 188 139 174 39 138 46 151 185 188 21 21 2 80 26 110 206 26 99 119 177 37 215 61 28 181 230 168 97 107 3 90 116 54 27 206 160 182 161 203 249 161 67 209 229 211 59 128 199 56 106 37 236 54 108 211 40 196 121 137 186 23 93 30 84 245 84 41 163 72 212 199 197 28 130 67 36 99 112 81 161 39 80 33 154 243 186 96 255 146 131 149 110 120 18 185 134 217 44 95 76 162 251 120 178 169 180 134 193 15 3 90 62 3 208 253 51 38 27 232 192 222 159 161 186 119 2 83 191 250 221 171 152 189 160 67 246 115 84 184 70 12 197 21 123 192 48 19 225 164 26 165 134 255 128 53 221 113 35 87 232 192 77 30 67 117 111 248 210 191 252 249 11 28 149 118 200 83 217 4 96 157 123 182 232 88 233 134 167 57 87 247 126 236 202 235 111 78 112 174 180 67 14 136 132 205 0 75 41 10 110 181 48 15 65 231 32 38 108 72 0 137 165 132 253 12 71 93 235 235 11 114 186 179 17 71 162 30 226 186 186 247 205 83 222 254 0 250 21 58 112 5 204 80 221 171 225 76 203 101 191 200 202 151 253 112 243 34 184 206 221 200 100 70 78 100 16 21 58 112 105 193 80 221 203 140 76 203 165 151 4 215 75 47 193 253 2 67 117 239 29 232 21 2 162 66 7 174 92 197 28 154 187 138 205 92 184 250 178 64 189 250 50 233 202 115 157 118 158 228 234 207 186 60 166 250 77 101 48 49 155 190 164 95 15 103 221 48 119 207 153 121 163 243 2 114 133 14 233 230 185 188 74 209 45 237 76 82 49 65 207 143 102 145 220 55 244 136 29 128 246 69 245 76 113 63 36 211 124 47 71 45 215 83 241 226 196 155 225 122 132 163 174 30 81 206 196 53 171 64 86 114 13 112 84 111 76 27 41 9 228 112 13 34 215 209 232 144 98 22 113 37 215 163 56 203 143 192 80 80 139 202 202 205 193 49 142 218 128 35 161 107 44 170 38 105 134 149 6 148 46 15 137 212 171 36 212 62 117 16 12 113 119 79 44 185 30 167 186 250 246 184 55 31 233 63 126 51 130 215 3 208 129 75 191 236 84 254 248 50 48 115 237 192 69 177 193 58 112 145 132 197 54 26 178 242 210 102 46 130 30 10 24 163 176 252 46 122 104 58 245 158 64 174 33 99 84 53 75 9 123 218 13 39 17 21 182 155 74 242 95 10 157 66 212 8 108 176 74 92 37 234 105 138 234 255 105 165 184 219 200 1 179 27 70 62 81 104 167 159 59 239 159 255 163 130 59 239 86 31 254 15 8 241 132 194 234 224 205 155 217 71 240 6 14 132 225 13 148 100 85 155 26 131 62 220 209 214 53 135 2 150 77 1 224 13 8 83 239 135 59 176 31 135 252 113 139 190 249 63 0 0 0 13 13 19 83 113 117 101 97 107 80 114 105 109 115 80 80 67 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 75 202 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19 76 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 194 64 147 0 0 41 201 0 0 3 236 0 0 9 117 0 0 1 117 252 200 122 229 0 0 0 0 0 0 40 123 13 192 85 103 131 86 230 231 94 57 77 78 55 237 215 54 155 88 94 43 59 194 47 194 163 132 146 219 186 118 246 155 38 95 175 147 211 207 75 126 177 75 60 53 60 167 231 229 132 227 175 138 214 160 91 139 176 50 221 228 54 147 108 194 201 126 22 217 39 161 228 121 71 54 139 48 194 79 178 223 142 108 70 126 19 70 246 49 66 55 219 47 217 74 142 29 97 155 110 59 202 159 60 39 251 201 102 121 251 37 108 27 35 60 182 25 30 248 234 74 78 243 184 151 231 150 22 253 60 194 246 49 143 176 77 110 235 102 155 252 38 191 201 38 155 225 201 6 198 159 64 0 122 89 30 0 3 128 37 235 0 22 227 223 116 95 72 61 254 209 135 24 168 111 68 224 102 135 122 2 255 39 155 182 175 180 171 175 105 167 234 140 186 251 58 36 177 221 227 113 218 35 114 216 15 2 102 119 187 61 181 206 198 53 229 12 170 210 135 208 227 93 120 125 56 118 109 104 45 128 20 223 139 0 55 5 23 174 182 171 191 220 249 68 85 249 189 230 181 219 119 62 91 188 0 145 188 202 144 218 179 210 14 89 248 183 224 63 181 122 207 159 205 53 191 133 172 141 150 181 219 233 110 196 252 116 109 125 205 170 100 215 177 252 19 106 164 122 67 117 199 42 128 100 206 45 153 127 73 9 178 36 238 80 36 37 99 64 117 3 64 229 175 88 238 18 188 33 128 153 238 113 41 233 108 178 126 27 207 154 180 20 66 74 68 244 182 139 173 210 89 45 181 152 165 223 183 43 155 131 231 238 207 174 219 172 68 165 160 51 32 42 138 164 156 167 176 232 29 165 206 133 25 4 76 100 66 164 27 79 151 115 142 133 128 44 176 102 13 3 162 138 20 201 114 139 94 91 77 157 13 45 194 230 92 233 92 190 220 254 220 80 22 135 86 102 218 65 63 175 101 221 44 77 120 240 116 30 44 253 209 42 30 9 203 112 38 59 36 163 149 169 113 88 85 25 5 65 243 181 35 197 142 29 0 171 85 250 116 5 211 204 238 112 72 244 134 199 152 38 65 33 164 179 239 9 177 129 243 112 112 122 154 131 88 129 9 162 176 77 248 131 233 11 144 9 80 178 23 75 96 54 222 203 163 58 254 36 87 231 236 201 100 229 165 193 176 222 211 129 177 98 104 66 124 253 169 39 161 233 166 95 107 24 0 18 105 114 196 126 126 10 255 199 28 49 71 172 191 111 241 122 84 59 19 14 97 230 45 196 21 93 14 152 203 209 245 229 231 161 233 230 74 88 255 198 70 136 189 116 0 98 143 116 58 98 79 164 243 59 177 173 126 141 137 198 207 150 229 232 162 124 142 174 47 189 4 31 255 217 167 135 184 32 18 123 244 107 186 196 113 205 99 240 170 94 19 196 111 176 208 187 118 207 119 116 61 139 183 117 126 144 189 1 14 225 255 52 159 71 94 133 166 213 175 224 249 91 156 203 126 206 249 117 216 193 149 206 198 172 200 24 171 73 200 44 70 99 65 95 169 235 136 68 194 114 180 152 234 218 1 204 255 218 1 176 102 236 135 57 79 21 38 138 111 133 166 8 102 101 254 163 171 192 186 246 21 252 31 106 83 255 232 64 124 25 89 1 88 111 88 129 216 9 252 103 65 118 87 61 230 223 187 8 146 146 16 183 189 149 31 249 29 245 104 248 138 40 91 254 227 30 197 43 251 96 110 25 86 245 13 43 184 163 248 143 97 29 160 62 60 127 42 230 39 61 114 19 126 176 240 245 45 142 199 191 25 69 4 139 128 248 28 123 6 172 11 118 177 50 139 7 177 195 200 175 155 215 249 156 167 30 210 242 163 30 148 223 90 16 209 25 228 66 1 57 5 171 5 97 94 177 91 138 202 225 251 37 185 93 177 213 69 197 80 139 40 183 216 92 190 102 89 148 55 23 187 235 92 54 103 49 102 122 161 47 29 182 165 28 125 121 43 102 79 215 206 84 28 133 120 243 167 39 213 125 249 95 215 48 188 178 205 31 193 108 249 234 190 219 31 24 201 215 183 98 40 159 57 11 239 84 170 251 62 76 138 226 157 35 251 153 231 205 189 244 79 233 241 110 4 118 235 1 117 223 220 79 65 166 207 165 30 236 236 166 51 187 51 215 143 57 119 171 189 88 45 152 7 179 122 96 73 195 119 97 238 158 110 181 119 203 70 181 119 107 12 239 239 69 135 104 122 179 7 145 207 18 47 174 124 58 102 162 63 101 187 75 43 6 235 47 192 76 29 134 222 96 184 124 161 118 73 62 227 206 83 25 32 167 151 189 112 176 15 255 89 91 64 168 80 15 159 224 189 67 210 243 7 87 129 112 164 16 242 74 60 30 215 245 118 136 204 176 36 18 9 24 3 240 112 187 93 165 147 121 50 208 8 108 107 130 228 142 36 253 249 28 110 143 171 194 32 128 71 163 19 77 208 8 64 215 218 186 218 17 130 239 243 168 47 95 87 111 178 55 183 121 251 251 251 129 245 62 206 47 30 249 28 119 41 199 163 126 244 111 83 153 165 84 12 4 194 225 144 173 82 10 112 115 253 64 145 0 71 182 239 134 158 165 69 176 179 248 0 93 33 30 130 221 59 206 215 226 110 212 58 219 209 234 208 120 36 217 189 203 151 27 2 240 48 217 189 227 130 252 157 71 188 167 184 174 107 100 140 200 21 30 82 231 184 32 151 66 171 215 182 255 214 107 214 0 143 9 53 102 35 15 143 168 120 197 192 5 97 53 93 35 226 200 51 207 63 121 120 199 148 157 212 149 154 80 226 97 38 30 239 57 209 12 15 193 126 182 143 26 12 83 173 244 192 229 122 85 198 125 218 140 50 148 40 65 238 211 252 254 59 62 189 206 89 51 213 199 100 81 146 138 137 78 166 37 236 237 248 159 5 241 254 67 86 228 137 166 97 154 135 210 22 104 158 204 147 225 41 191 168 42 242 136 118 24 4 240 160 72 178 99 149 252 71 87 15 213 162 214 145 223 86 116 135 113 75 71 142 210 159 207 113 181 35 31 229 97 24 208 145 215 148 86 217 166 244 112 123 26 39 245 48 250 232 236 223 85 245 106 103 63 193 227 74 103 63 197 99 186 179 159 210 117 186 179 159 228 97 188 208 217 143 232 241 175 206 126 84 216 247 59 251 73 30 211 157 253 8 141 107 157 253 4 15 227 128 206 62 201 174 72 173 239 249 52 64 207 178 83 56 21 81 8 165 139 208 159 247 14 249 116 5 247 105 227 143 142 252 221 194 191 218 145 95 112 88 195 128 142 188 209 23 186 245 22 91 103 209 109 255 238 200 211 255 209 81 33 209 113 231 152 233 168 38 120 92 233 132 166 244 152 238 132 38 121 204 56 253 8 143 107 78 63 193 195 100 159 112 197 84 228 129 198 48 213 186 95 119 160 4 143 128 111 204 22 7 95 62 46 84 26 241 8 55 227 32 211 5 30 53 205 254 73 30 105 238 209 113 145 203 142 152 234 118 59 43 13 1 138 226 111 111 21 169 168 22 175 248 139 60 208 201 2 99 61 235 28 226 65 163 137 54 103 56 24 241 5 222 86 63 238 28 88 241 210 189 134 0 186 94 119 142 68 79 63 241 54 48 195 99 210 161 39 235 44 225 172 209 177 50 155 9 51 78 251 113 64 216 116 105 238 49 217 31 110 11 5 197 224 232 108 234 197 64 134 140 14 2 78 24 26 188 4 21 130 241 75 13 12 68 14 205 205 14 212 197 32 66 179 168 84 41 26 154 1 41 136 240 159 126 191 23 82 46 77 0 95 140 213 24 218 107 63 139 173 59 51 89 123 45 136 207 0 120 110 210 24 121 158 73 90 4 105 113 241 81 206 74 73 108 145 100 101 186 229 176 128 137 15 26 235 249 217 139 131 35 233 111 215 149 145 79 220 115 143 18 21 101 254 192 104 220 16 84 198 86 48 9 186 45 178 248 206 0 10 242 202 132 89 238 227 91 6 12 0 36 55 126 80 156 229 160 142 180 127 96 56 102 233 123 33 100 95 80 241 133 60 178 141 16 95 212 183 233 47 11 15 12 73 98 15 186 60 27 172 131 115 73 42 74 234 234 255 250 162 108 68 80 184 111 117 65 35 219 22 200 187 132 129 173 23 83 33 88 48 23 206 198 235 159 225 75 88 151 58 107 202 202 151 218 150 150 149 212 151 224 209 179 198 89 191 212 104 165 4 44 250 18 22 61 134 246 202 164 44 248 65 101 14 109 26 201 103 63 1 33 210 192 95 25 243 34 50 62 41 46 128 37 117 245 181 11 49 227 87 7 243 167 149 240 39 58 222 53 221 245 125 160 173 13 25 132 221 249 32 208 59 77 14 97 85 143 1 205 4 210 222 2 232 184 17 238 198 227 46 194 102 215 67 43 30 105 163 4 20 44 6 228 202 170 8 75 249 29 124 2 177 47 18 246 112 63 208 166 129 31 17 38 254 30 158 228 125 58 134 127 19 124 133 187 27 73 42 193 211 136 241 173 22 174 207 192 119 16 235 36 44 91 129 31 34 246 121 194 22 62 7 135 241 33 238 25 194 156 39 161 31 101 69 94 0 55 110 133 223 32 198 185 186 186 224 56 192 188 108 194 26 242 168 50 230 225 246 8 128 214 187 217 28 196 248 187 147 195 205 242 17 227 51 142 235 95 102 184 128 97 62 215 56 103 21 251 8 98 181 92 215 118 134 179 130 243 121 247 96 250 19 115 3 216 248 54 21 105 39 107 66 12 43 13 96 238 55 24 62 132 219 248 83 237 237 199 25 206 210 20 216 9 219 216 199 30 6 248 16 127 159 238 172 99 143 161 114 188 182 54 45 99 168 227 194 34 94 116 251 105 171 198 98 158 227 131 49 194 4 190 119 33 211 131 187 126 36 111 212 134 117 171 248 194 161 92 183 216 234 243 218 156 98 100 248 233 24 159 126 226 23 181 151 244 57 137 11 58 135 12 62 94 48 144 113 22 13 160 56 195 45 210 199 164 80 122 98 24 133 95 211 51 102 234 35 85 241 148 113 188 81 148 67 190 80 171 98 46 111 241 69 195 114 82 69 56 20 205 136 43 85 222 25 149 69 37 211 217 161 68 195 65 219 29 210 230 251 195 114 139 98 41 241 122 37 212 203 35 70 219 20 115 189 40 183 74 81 75 105 135 47 208 162 39 76 107 112 226 138 17 41 218 17 153 69 179 170 186 48 89 132 149 249 20 148 90 10 54 163 4 233 137 65 86 158 39 174 173 54 130 17 23 74 135 7 116 114 86 184 49 217 44 254 46 166 19 35 236 52 177 196 206 138 20 130 112 32 136 231 211 9 90 180 209 104 212 47 36 5 44 56 149 53 192 245 255 0 0 65 109 177 88 4 208 212 91 0 174 148 122 119 43 86 175 94 69 189 85 202 89 129 206 76 18 155 13 39 227 253 135 63 174 102 224 166 3 45 206 156 146 228 188 37 220 174 127 244 27 51 45 11 253 119 51 245 143 222 209 101 91 239 88 252 31 243 254 179 223 254 236 237 179 238 142 125 8 253 217 153 144 189 93 185 114 213 7 149 94 142 101 252 193 188 177 153 188 92 247 189 14 39 111 52 15 121 207 231 52 253 131 211 157 221 36 228 85 113 103 235 43 118 90 60 139 75 197 117 144 69 192 185 16 122 35 172 1 93 1 48 118 249 246 88 111 220 232 137 135 187 195 201 240 22 51 113 76 113 219 95 55 166 102 230 185 4 92 79 255 109 143 140 186 166 90 163 178 184 161 161 178 184 54 188 233 175 13 156 205 255 180 135 94 19 77 154 241 142 80 155 249 95 106 36 114 255 169 135 183 46 148 236 250 231 10 76 244 255 240 211 30 217 246 94 27 122 163 201 112 183 249 159 151 139 87 230 236 38 162 194 103 143 253 175 187 188 245 184 31 248 180 84 34 217 187 201 38 160 251 84 135 217 37 255 245 146 110 253 253 103 154 181 84 93 67 237 74 155 128 203 238 90 123 206 127 221 211 173 191 191 242 166 193 212 119 222 132 59 189 161 95 92 201 137 13 169 246 245 70 70 254 203 63 131 164 154 171 215 13 255 163 64 83 255 101 208 27 154 204 78 245 55 181 133 30 130 237 161 87 231 53 178 239 80 188 208 254 91 213 215 38 146 206 21 155 217 247 168 216 55 42 79 102 195 202 72 194 246 8 0 0 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:24'!macAsyncFilePrimsFile	^ '/*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>#include "sq.h"/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 13:41'!macExternalPrimsFile	^ '#include <CodeFragments.h>#include <Strings.h>#include "sq.h"/*** Variables ***/CFragConnectionID squeakVMLib = nil;  /* connection to the VM itself as a shared library *//*** Function Type Declaration ***/typedef int (*RecordVMProxyProc)(struct VirtualMachine *interpreterProxy);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag) {	CFragLoadOptions action;	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg;	OSErr err;	action = loadFlag ? kLoadCFrag : kFindCFrag;	err = GetSharedLibrary(		c2pstr(libName), kCurrentCFragArch, action, &libHandle, &mainAddr, errorMsg);	p2cstr((unsigned char *) libName);  /* undo C to Pascal conversion */	if (err) {		return null;	}	return libHandle;}int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength, int moduleNameIndex, int moduleNameLength){	Str255 functionName, moduleName;	CFragConnectionID libHandle;	CFragSymbolClass ignored;	Ptr functionPtr;	OSErr err;	int i;	/* copy function and module names into C strings */	for (i = 0; i < functionNameLength; i++) {		functionName[i] = ((char *) functionNameIndex)[i];	}	functionName[functionNameLength] = 0;	for (i = 0; i < moduleNameLength; i++) {		moduleName[i] = ((char *) moduleNameIndex)[i];	}	moduleName[moduleNameLength] = 0;	/* find the library */	if (moduleNameLength > 0) {		/* look for the primitive in named library */		/* first try to find it */		libHandle = FindOrLoadLib((char *) moduleName, false);		if (!!libHandle) {			/* then try to load it */			libHandle = FindOrLoadLib((char *) moduleName, true);		}	} else {		/* look for the primitive in the Squeak VM itself */		if (!!squeakVMLib) {			/* try to get a handle on the Squeak VM itself, viewed as a library */			squeakVMLib = FindOrLoadLib("SqueakVMPrims", false);		}		libHandle = squeakVMLib;	}	if (!!libHandle) return success(false);  /* could not open the library */	/* if library is external, initialize its VMProxy pointer */	if (libHandle !!= squeakVMLib) {		/* get the setInterpreter() function */		err = FindSymbol(libHandle, "\psetInterpreter", &functionPtr, &ignored);		if (err) return success(false);		/* call setInterpreter() */		((RecordVMProxyProc) functionPtr)(sqGetInterpreterProxy());	}	/* get the address of the desired primitive function */	c2pstr((char *) functionName);	err = FindSymbol(libHandle, functionName, &functionPtr, &ignored);	if (err) return success(false);	return (int) functionPtr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/23/1998 00:06'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Macintosh virtual machine.	Many primitives are "stubbed-out", meaning that if they are invoked from the	image they will return a "primitive failed" error. Among the stubbed out primitives	are those that support sound input and output, serial and MIDI ports, networking,	joystick, and file directory operations. The basic file read/write operations are	NOT stubbed out, although they could be as long as the image loading mechanism	still works. In this case, you''ll need to modify the method "openSourceFiles"	in the image to skip opening the changes and sources files at startup time.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been implemented, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioSetCursorWithMask() -- install a masked cursor		ioBeep()			-- make a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- some other behavior appropriate to this platform							-- (if this is a noop you won''t be able to quit from Squeak)		ioRelinquishProcessorForMicroseconds()							-- called when Squeak is idle to return time to the OS  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that that directory is the default working directory	for file operations. The "shortImageName" is used to display the image file	name (but not its full path) in the title bar of the Macintosh window.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- return the number of seconds since Jan 1, 1901	   						-- may return 0, but then the current date and time	   						-- will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqFilePrims.c	-- file primitives (can be stubbed out)		sqMacMinimal.c	-- this file		sqMiscPrims.c	-- automatically generated primitives (optional)	plus the appropriate support libraries. To build a PowerPC	virtual machine using CodeWarrior 8, these are:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		MathLib		MWCRuntime.Lib*/#include <MacHeaders.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#define STUBBED_OUT { success(false); }/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	success(false);  /* stubbed out */}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* Process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top) - 20;		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 20, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	return 0;}int clipboardSize(void) {	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	return 0;}/*** Directory ***/int dir_Delimitor(void) {	return '':'';}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												{/* noop */}/*** Joystick Stubs ***/int joystickRead(int stickIndex)											STUBBED_OUT/*** MIDI Stubs ***/int sqMIDIClosePort(int portNum)											STUBBED_OUTint sqMIDIGetClock(void)													STUBBED_OUTint sqMIDIGetPortCount(void)												STUBBED_OUTint sqMIDIGetPortDirectionality(int portNum)								STUBBED_OUTint sqMIDIGetPortName(int portNum, int namePtr, int length)					STUBBED_OUTint sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate)	STUBBED_OUTint sqMIDIParameter(int whichParameter, int modify, int newValue)			STUBBED_OUTint sqMIDIPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time)	STUBBED_OUT/*** Networking Stubs ***/int sqNetworkInit(int resolverSemaIndex)									STUBBED_OUTvoid sqNetworkShutdown(void)												STUBBED_OUTvoid sqResolverAbort(void)													STUBBED_OUTvoid sqResolverAddrLookupResult(char *nameForAddress, int nameSize)			STUBBED_OUTint sqResolverAddrLookupResultSize(void)									STUBBED_OUTint sqResolverError(void)													STUBBED_OUTint sqResolverLocalAddress(void)											STUBBED_OUTint sqResolverNameLookupResult(void)										STUBBED_OUTvoid sqResolverStartAddrLookup(int address)									STUBBED_OUTvoid sqResolverStartNameLookup(char *hostName, int nameSize)				STUBBED_OUTint sqResolverStatus(void)													STUBBED_OUTvoid sqSocketAbortConnection(SocketPtr s)									STUBBED_OUTvoid sqSocketCloseConnection(SocketPtr s)									STUBBED_OUTint sqSocketConnectionStatus(SocketPtr s)									STUBBED_OUTvoid sqSocketConnectToPort(SocketPtr s, int addr, int port)					STUBBED_OUTvoid sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex)							STUBBED_OUTvoid sqSocketDestroy(SocketPtr s)											STUBBED_OUTint sqSocketError(SocketPtr s)												STUBBED_OUTvoid sqSocketListenOnPort(SocketPtr s, int port)							STUBBED_OUTint sqSocketLocalAddress(SocketPtr s)										STUBBED_OUTint sqSocketLocalPort(SocketPtr s)											STUBBED_OUTint sqSocketReceiveDataAvailable(SocketPtr s)								STUBBED_OUTint sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize)			STUBBED_OUTint sqSocketRemoteAddress(SocketPtr s)										STUBBED_OUTint sqSocketRemotePort(SocketPtr s)											STUBBED_OUTint sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize)				STUBBED_OUTint sqSocketSendDone(SocketPtr s)											STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** Serial Port Functions Stubs ***/int serialPortClose(int portNum)											STUBBED_OUTint serialPortOpen(  int portNum, int baudRate, int stopBitsType,  int parityType, int dataBits, int inFlowCtrl, int outFlowCtrl,  int xOnChar, int xOffChar)												STUBBED_OUTint serialPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint serialPortWriteFrom(int portNum, int count, int bufferPtr)				STUBBED_OUT/*** Sound Output Stubs ***/int snd_AvailableSpace(void)												STUBBED_OUTint snd_PlaySamplesFromAtLength(  int frameCount, int arrayIndex, int startIndex)							STUBBED_OUTint snd_InsertSamplesFromLeadTime(  int frameCount, int srcBufPtr, int samplesOfLeadTime)						STUBBED_OUTint snd_PlaySilence(void)													STUBBED_OUTint snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_Stop(void)															STUBBED_OUT/*** Sound Input Stubs ***/int snd_SetRecordLevel(int level)											STUBBED_OUTint snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_StopRecording(void)													STUBBED_OUTdouble snd_GetRecordingSampleRate(void)										STUBBED_OUTint snd_RecordSamplesIntoAtLength(  int buf, int startSliceIndex, int bufferSizeInBytes)						STUBBED_OUT/*** Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void)			STUBBED_OUTint primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)	STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUTint primReverbSoundapplyReverbTostartingAtcount(void)						STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUT/*** Old Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtpan(void)						STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primWaveTableSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUT/*** Experimental Asynchronous File I/O ***/int asyncFileClose(AsyncFile *f)											STUBBED_OUTint asyncFileOpen(  AsyncFile *f, int fileNamePtr, int fileNameSize,  int writeFlag, int semaIndex)												STUBBED_OUTint asyncFileRecordSize()													STUBBED_OUTint asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize)		STUBBED_OUTint asyncFileReadStart(AsyncFile *f, int fPosition, int count)				STUBBED_OUTint asyncFileWriteResult(AsyncFile *f)										STUBBED_OUTint asyncFileWriteStart(  AsyncFile *f, int fPosition, int bufferPtr, int bufferSize)				STUBBED_OUT/*** Main ***/void main(void) {	sqImageFile f;	int reservedMemory, availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	SetUpMenus();	SetUpWindow();	SetUpPixmap();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following to open the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:12'!macSerialAndMIDIPortFile	^ '#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <Serial.h>#include <Strings.h>#include "sq.h"/*** Constants ***/#define INPUT_BUF_SIZE 1000/*** Imported Variables ***/extern int successFlag;/*** Local Variables ***/short inRefNum[4] = {0, 0, 0, 0};short outRefNum[4] = {0, 0, 0, 0};char inputBuffer[4][INPUT_BUF_SIZE];/*** Private Functions ***/int portCount(void);int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);int portCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			strcpy(portName, p2cstr(*(serialPtr->name)));			strcpy(inName, p2cstr(*(serialPtr->inputDriverName)));			strcpy(outName, p2cstr(*(serialPtr->outputDriverName)));			c2pstr((void *) *(serialPtr->name));			c2pstr((void *) *(serialPtr->inputDriverName));			c2pstr((void *) *(serialPtr->outputDriverName)); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	osErr = OpenDriver(c2pstr(outName), &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	osErr = OpenDriver(c2pstr(inName), &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	return serialPortClose(portNum);}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return portCount();}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */	success((portNum == 0) || (portNum == 1));	return 3;}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int count;	if ((portNum > 4) || (portNum >= portCount())) {		return success(false);	}	portNames(portNum, userName, inName, outName);	count = strlen(userName);	success(count > 0);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	return serialPortWriteFrom(portNum, count, bufferPtr);}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:31'!macSoundFile	^ '#include <Sound.h>#include <SoundInput.h>#include "sq.h"/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 4)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, NULL, NULL, true, 0};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/13/1999 12:09'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & 0xFF;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	serialPortClose(0);	serialPortClose(1);	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */	ioProcessEvents();  /* process all pending events */}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/14/1999 22:52'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built from five header and fourteen source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqVirtualMachine.h	-- support for dynamic primitives	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacExternalPrims.c  -- support for dynamic primitives	sqMacJoystick.c		-- Mac primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	sqVirtualMachine.c	-- support for dynamic primitives	interp.c				-- automatically generated code for the virtual machineThe platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrior 11. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		dnr.c		InterfaceLib		MathLibCFM68K (4i/8d).Lib		MSL C.CFM68K Far(4i/8d).Lib		MWCFM68KRuntime.Lib		Profiler68kCFM.lib	Libraries for PowerPC Project:		dnr.c		InterfaceLib		MathLib		MSL C.PPC.Lib		MWCRuntime.Lib		profilerPPC.libThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrior will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs.Note: I have not been able to build a fat binary since converting to the Code Fragement Manager. Until this problem is resolved, there will be separate executables for PPC and 68K.To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.Note: In The release, we''ve updated the CodeWarrior project files to release 11 of CodeWarrior. If you have a current version of CodeWarrior, you will should be able to automatically convert these project files to your release. If you have a release of CodeWarrior earlier than release 11 (which is quite old), you will need to either build new project files from scratch, start with the release 8 project files included with Squeak 2.2 and bring them up to date by hand, or update to a newer version of CodeWarrior.Note: In order to support dynamically loaded primitives, we have switched to using Code Fragement Manager model for the 68K VM. This has several ramifications:  1. You now need to use the CFM versions of the library files. The 68K project file has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''t support CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler" is in the Extensions folder of the system folder on your 68K Mac. *** Warning: Older versions of "CFM-68K Runtime Enabler" had bugs that will probably prevent Squeak from even starting!! ***.  4. You will need to figure out how to make a CFM68K shared library project if you wish to build dynamic primitives that can be run on the 68K. Ideally, one would create a "fat" library containing both 68K and PPC versions of the dynamically loadable primitives. So far, I have not tried doing that. 	-- John Maloney, Jan 12, 1999'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 00:21'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define LITTLE_ENDIAN_BITBLT# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  define  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   if defined(ITSY)#     define LITTLE_ENDIAN_BITBLT#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/13/1999 10:48'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** pluggable primitive support ***/int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 00:24'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*//* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"#ifdef macintosh/* macintosh memory allocation */#include <Memory.h>#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) NewPtr(desiredHeapSize)/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWritetypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num) #endif /* ACORN */#ifdef LITTLE_ENDIAN_BITBLT#define ifLittleEndianDoelseDo(a, b) a#else#define ifLittleEndianDoelseDo(a, b) b#endif#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#ifdef _MSC_VER#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif #endif /* WIN32 */'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ikp 1/5/1999 16:21'!squeakVirtualMachineFile^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"/*** Function prototypes ***//* InterpreterProxy methodsFor: ''stack access'' */int pop(int nItems);int popthenPush(int nItems, int oop);int push(int object);int pushBool(int trueOrFalse);int pushFloat(double f);int pushInteger(int integerValue);double stackFloatValue(int offset);int stackIntegerValue(int offset);int stackObjectValue(int offset);int stackValue(int offset);/*** variables ***/extern int (*compilerHooks[])();extern int setCompilerInitialized(int flagValue);/* InterpreterProxy methodsFor: ''object access'' */int argumentCountOf(int methodPointer);void * arrayValueOf(int oop);int byteSizeOf(int oop);void * fetchArrayofObject(int fieldIndex, int objectPointer);int fetchClassOf(int oop);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);int fetchPointerofObject(int index, int oop);int fetchWordofObject(int fieldIndex, int oop);void * firstFixedField(int oop);void * firstIndexableField(int oop);int literalofMethod(int offset, int methodPointer);int literalCountOf(int methodPointer);int methodArgumentCount(void);int methodPrimitiveIndex(void);int primitiveIndexOf(int methodPointer);int sizeOfSTArrayFromCPrimitive(void *cPtr);int slotSizeOf(int oop);int stObjectat(int array, int index);int stObjectatput(int array, int index, int value);int stSizeOf(int oop);int storeIntegerofObjectwithValue(int index, int oop, int integer);int storePointerofObjectwithValue(int index, int oop, int valuePointer);/* InterpreterProxy methodsFor: ''testing'' */int isKindOf(int oop, char *aString);int isMemberOf(int oop, char *aString);int isBytes(int oop);int isFloatObject(int oop);int isIndexable(int oop);int isIntegerObject(int objectPointer);int isIntegerValue(int intValue);int isPointers(int oop);int isWeak(int oop);int isWords(int oop);int isWordsOrBytes(int oop);/* InterpreterProxy methodsFor: ''converting'' */int booleanValueOf(int obj);int checkedIntegerValueOf(int intOop);int floatObjectOf(double aFloat);double floatValueOf(int oop);int integerObjectOf(int value);int integerValueOf(int oop);int positive32BitIntegerFor(int integerValue);int positive32BitValueOf(int oop);/* InterpreterProxy methodsFor: ''special objects'' */int characterTable(void);int displayObject(void);int falseObject(void);int nilObject(void);int trueObject(void);/* InterpreterProxy methodsFor: ''special classes'' */int classArray(void);int classBitmap(void);int classByteArray(void);int classCharacter(void);int classFloat(void);int classLargePositiveInteger(void);int classPoint(void);int classSemaphore(void);int classSmallInteger(void);int classString(void);/* InterpreterProxy methodsFor: ''instance creation'' */int clone(int oop);int instantiateClassindexableSize(int classPointer, int size);int makePointwithxValueyValue(int xValue, int yValue);int popRemappableOop(void);int pushRemappableOop(int oop);/* InterpreterProxy methodsFor: ''other'' */int becomewith(int array1, int array2);int byteSwapped(int w);int failed(void);int fullDisplayUpdate(void);int fullGC(void);int incrementalGC(void);int primitiveFail(void);int showDisplayBitsLeftTopRightBottom(int aForm, int l, int t, int r, int b);int signalSemaphoreWithIndex(int semaIndex);int success(int aBoolean);int superclassOf(int classPointer);struct VirtualMachine *VM = NULL;static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}static CompilerHook *compilerHookVector(void) {  return compilerHooks;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;	/* InterpreterProxy methodsFor: ''stack access'' */	VM->pop = pop;	VM->popthenPush = popthenPush;	VM->push = push;	VM->pushBool = pushBool;	VM->pushFloat = pushFloat;	VM->pushInteger = pushInteger;	VM->stackFloatValue = stackFloatValue;	VM->stackIntegerValue = stackIntegerValue;	VM->stackObjectValue = stackObjectValue;	VM->stackValue = stackValue;		/* InterpreterProxy methodsFor: ''object access'' */	VM->argumentCountOf = argumentCountOf;	VM->arrayValueOf = arrayValueOf;	VM->byteSizeOf = byteSizeOf;	VM->fetchArrayofObject = fetchArrayofObject;	VM->fetchClassOf = fetchClassOf;	VM->fetchFloatofObject = fetchFloatofObject;	VM->fetchIntegerofObject = fetchIntegerofObject;	VM->fetchPointerofObject = fetchPointerofObject;	VM->fetchWordofObject = fetchWordofObject;	VM->firstFixedField = firstFixedField;	VM->firstIndexableField = firstIndexableField;	VM->literalofMethod = literalofMethod;	VM->literalCountOf = literalCountOf;	VM->methodArgumentCount = methodArgumentCount;	VM->methodPrimitiveIndex = methodPrimitiveIndex;	VM->primitiveIndexOf = primitiveIndexOf;	VM->sizeOfSTArrayFromCPrimitive = sizeOfSTArrayFromCPrimitive;	VM->slotSizeOf = slotSizeOf;	VM->stObjectat = stObjectat;	VM->stObjectatput = stObjectatput;	VM->stSizeOf = stSizeOf;	VM->storeIntegerofObjectwithValue = storeIntegerofObjectwithValue;	VM->storePointerofObjectwithValue = storePointerofObjectwithValue;		/* InterpreterProxy methodsFor: ''testing'' */	VM->isKindOf = isKindOf;	VM->isMemberOf = isMemberOf;	VM->isBytes = isBytes;	VM->isFloatObject = isFloatObject;	VM->isIndexable = isIndexable;	VM->isIntegerObject = isIntegerObject;	VM->isIntegerValue = isIntegerValue;	VM->isPointers = isPointers;	VM->isWeak = isWeak;	VM->isWords = isWords;	VM->isWordsOrBytes = isWordsOrBytes;		/* InterpreterProxy methodsFor: ''converting'' */	VM->booleanValueOf = booleanValueOf;	VM->checkedIntegerValueOf = checkedIntegerValueOf;	VM->floatObjectOf = floatObjectOf;	VM->floatValueOf = floatValueOf;	VM->integerObjectOf = integerObjectOf;	VM->integerValueOf = integerValueOf;	VM->positive32BitIntegerFor = positive32BitIntegerFor;	VM->positive32BitValueOf = positive32BitValueOf;		/* InterpreterProxy methodsFor: ''special objects'' */	VM->characterTable = characterTable;	VM->displayObject = displayObject;	VM->falseObject = falseObject;	VM->nilObject = nilObject;	VM->trueObject = trueObject;		/* InterpreterProxy methodsFor: ''special classes'' */	VM->classArray = classArray;	VM->classBitmap = classBitmap;	VM->classByteArray = classByteArray;	VM->classCharacter = classCharacter;	VM->classFloat = classFloat;	VM->classLargePositiveInteger = classLargePositiveInteger;	VM->classPoint = classPoint;	VM->classSemaphore = classSemaphore;	VM->classSmallInteger = classSmallInteger;	VM->classString = classString;		/* InterpreterProxy methodsFor: ''instance creation'' */	VM->clone = clone;	VM->instantiateClassindexableSize = instantiateClassindexableSize;	VM->makePointwithxValueyValue = makePointwithxValueyValue;	VM->popRemappableOop = popRemappableOop;	VM->pushRemappableOop = pushRemappableOop;		/* InterpreterProxy methodsFor: ''other'' */	VM->becomewith = becomewith;	VM->byteSwapped = byteSwapped;	VM->failed = failed;	VM->fullDisplayUpdate = fullDisplayUpdate;	VM->fullGC = fullGC;	VM->incrementalGC = incrementalGC;	VM->primitiveFail = primitiveFail;	VM->showDisplayBitsLeftTopRightBottom = showDisplayBitsLeftTopRightBottom;	VM->signalSemaphoreWithIndex = signalSemaphoreWithIndex;	VM->success = success;	VM->superclassOf = superclassOf;		VM->compilerHookVector= compilerHookVector;	VM->setCompilerInitialized= setCompilerInitialized;	return VM;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ikp 1/5/1999 16:20'!squeakVirtualMachineHeaderFile^ '#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 1typedef int (*CompilerHook)();struct VirtualMachine* sqGetInterpreterProxy(void);typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);	/* InterpreterProxy methodsFor: ''stack access'' */	int (*pop)(int nItems);	int (*popthenPush)(int nItems, int oop);	int (*push)(int object);	int (*pushBool)(int trueOrFalse);	int (*pushFloat)(double f);	int (*pushInteger)(int integerValue);	double (*stackFloatValue)(int offset);	int (*stackIntegerValue)(int offset);	int (*stackObjectValue)(int offset);	int (*stackValue)(int offset);		/* InterpreterProxy methodsFor: ''object access'' */	int (*argumentCountOf)(int methodPointer);	void * (*arrayValueOf)(int oop);	int (*byteSizeOf)(int oop);	void * (*fetchArrayofObject)(int fieldIndex, int objectPointer);	int (*fetchClassOf)(int oop);	double (*fetchFloatofObject)(int fieldIndex, int objectPointer);	int (*fetchIntegerofObject)(int fieldIndex, int objectPointer);	int (*fetchPointerofObject)(int index, int oop);	int (*fetchWordofObject)(int fieldIndex, int oop);	void * (*firstFixedField)(int oop);	void * (*firstIndexableField)(int oop);	int (*literalofMethod)(int offset, int methodPointer);	int (*literalCountOf)(int methodPointer);	int (*methodArgumentCount)(void);	int (*methodPrimitiveIndex)(void);	int (*primitiveIndexOf)(int methodPointer);	int (*sizeOfSTArrayFromCPrimitive)(void *cPtr);	int (*slotSizeOf)(int oop);	int (*stObjectat)(int array, int index);	int (*stObjectatput)(int array, int index, int value);	int (*stSizeOf)(int oop);	int (*storeIntegerofObjectwithValue)(int index, int oop, int integer);	int (*storePointerofObjectwithValue)(int index, int oop, int valuePointer);		/* InterpreterProxy methodsFor: ''testing'' */	int (*isKindOf)(int oop, char *aString);	int (*isMemberOf)(int oop, char *aString);	int (*isBytes)(int oop);	int (*isFloatObject)(int oop);	int (*isIndexable)(int oop);	int (*isIntegerObject)(int objectPointer);	int (*isIntegerValue)(int intValue);	int (*isPointers)(int oop);	int (*isWeak)(int oop);	int (*isWords)(int oop);	int (*isWordsOrBytes)(int oop);		/* InterpreterProxy methodsFor: ''converting'' */	int (*booleanValueOf)(int obj);	int (*checkedIntegerValueOf)(int intOop);	int (*floatObjectOf)(double aFloat);	double (*floatValueOf)(int oop);	int (*integerObjectOf)(int value);	int (*integerValueOf)(int oop);	int (*positive32BitIntegerFor)(int integerValue);	int (*positive32BitValueOf)(int oop);		/* InterpreterProxy methodsFor: ''special objects'' */	int (*characterTable)(void);	int (*displayObject)(void);	int (*falseObject)(void);	int (*nilObject)(void);	int (*trueObject)(void);		/* InterpreterProxy methodsFor: ''special classes'' */	int (*classArray)(void);	int (*classBitmap)(void);	int (*classByteArray)(void);	int (*classCharacter)(void);	int (*classFloat)(void);	int (*classLargePositiveInteger)(void);	int (*classPoint)(void);	int (*classSemaphore)(void);	int (*classSmallInteger)(void);	int (*classString)(void);		/* InterpreterProxy methodsFor: ''instance creation'' */	int (*clone)(int oop);	int (*instantiateClassindexableSize)(int classPointer, int size);	int (*makePointwithxValueyValue)(int xValue, int yValue);	int (*popRemappableOop)(void);	int (*pushRemappableOop)(int oop);		/* InterpreterProxy methodsFor: ''other'' */	int (*becomewith)(int array1, int array2);	int (*byteSwapped)(int w);	int (*failed)(void);	int (*fullDisplayUpdate)(void);	int (*fullGC)(void);	int (*incrementalGC)(void);	int (*primitiveFail)(void);	int (*showDisplayBitsLeftTopRightBottom)(int aForm, int l, int t, int r, int b);	int (*signalSemaphoreWithIndex)(int semaIndex);	int (*success)(int aBoolean);	int (*superclassOf)(int classPointer);		/* InterpreterProxy methodsFor: ''compiler'' */	CompilerHook *(*compilerHookVector)(void);	int (*setCompilerInitialized)(int initFlag);} VirtualMachine;#endif /* _SqueakVM_H */'! !!InterpreterSupportCode class methodsFor: 'compiler' stamp: 'ikp 1/4/1999 01:36'!comparativeBenchmarks	"InterpreterSupportCode comparativeBenchmarks"	Smalltalk compilerDisable.	self compilerBenchmarks.	Transcript show: '  interpreted'.	Smalltalk compilerEnable.	self compilerBenchmarks.	Transcript show: '  compiled'.! !!InterpreterSupportCode class methodsFor: 'compiler' stamp: 'ikp 1/5/1999 03:43'!compilerBenchmarks	"InterpreterSupportCode compilerBenchmarks"	| r t f b |	f _ SortedCollection new.	5 timesRepeat:		[t _ Time millisecondsToRun: [r _ 30 benchFib].		 f add: r*1000//t].	b _ SortedCollection new.	5 timesRepeat:		[b add: (20000000 * 1000 // (Time millisecondsToRun: [40 benchmark]))].	Transcript cr; print: f; cr; print: b.	f _ (f removeFirst; removeLast; inject: 0 into: [:sum :elt | sum + elt]) // f size.	b _ (b removeFirst; removeLast; inject: 0 into: [:sum :elt | sum + elt]) // b size.	Transcript cr;		show: f printString; tab;		show: b printString! !!InterpreterSupportCode class methodsFor: 'compiler'!primitiveTableDeclaration	"InterpreterSupportCode primitiveTableDeclaration"	| primitives internal external declared |	primitives _ Interpreter initialize; primitiveTable.	internal _ #(		primitiveBlockCopy primitiveDoPrimitiveWithArgs		primitivePerform primitivePerformWithArgs		primitiveValue primitiveValueWithArgs).	external _ Interpreter primitiveTable reject: [:prim | internal includes: prim].	declared _ IdentitySet new.	^String streamContents: [:str |	str	nextPutAll:	'// generated automatically at ';		print:		Time now;		nextPutAll:	' on ';		print:		Date today;		cr;		nextPutAll:	'// DO NOT EDIT!!!!!!';		cr; cr;		nextPutAll:	'#define MaxPrimitiveIndex ';		print:		primitives size - 1;		cr; cr.	internal do: [:prim |		str	nextPutAll: 'extern void ';			nextPutAll: prim;			nextPutAll: '(void);'; cr].	str	cr;		nextPutAll:	'extern "C" {'; cr;		nextPutAll:	'  void primitiveFail(void);'; cr.	external do: [:prim |	(declared includes: prim)		ifFalse: [str	nextPutAll: '  void ';					nextPutAll:	prim;					nextPutAll: '(void);'; cr].	declared add: prim].	str	nextPutAll:	'};'; cr.	]! !!InterpreterSupportCode class methodsFor: 'compiler'!primitiveTableDefinition	"InterpreterSupportCode primitiveTableDefinition"	| primitives |	primitives _ Interpreter initialize; primitiveTable.	^String streamContents: [:str |	str	nextPutAll:	'// generated automatically at ';		print:		Time now;		nextPutAll:	' on ';		print:		Date today;		cr;		nextPutAll:	'// DO NOT EDIT!!!!!!';		cr; cr;		nextPutAll:	'primitive primitiveTable[MaxPrimitiveIndex + 1]= {'; cr.	primitives doWithIndex: [:prim :index |		str nextPutAll: '  '; print: prim.		index == primitives size ifFalse: [str nextPut: $,].		str cr].	str	nextPutAll:	'};'; cr.	]! !!InterpreterSupportCode class methodsFor: 'compiler'!writeCompilerSourceFiles	"Store into this image's directory the C sources files required to support the runtime compiler."	"InterpreterSupportCode writeCompilerSourceFiles"	self storeString: self primitiveTableDeclaration	onFileNamed: 'primitiveTable.decl'.	self storeString: self primitiveTableDefinition		onFileNamed: 'primitiveTable.defn'.! !I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder. !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!acTableIndex	^acTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!acTableIndex: anInteger	acTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!dcTableIndex	^dcTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!dcTableIndex: anInteger	dcTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!heightInBlocks	^heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!heightInBlocks: anInteger	heightInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id	^id! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id: anObject	id _ anObject! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:29'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth _ mw.	mcuHeight _ mh.	dctSize _ ds.	hSampleFactor _ mcuWidth // widthInBlocks.	vSampleFactor _ mcuHeight // heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!priorDCValue: aNumber	priorDCValue _ aNumber! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:43'!qTableIndex	^qTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!qTableIndex: anInteger	qTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:18'!totalMcuBlocks	^ heightInBlocks * widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!updateDCValue: aNumber	priorDCValue _ priorDCValue + aNumber.	^priorDCValue! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!widthInBlocks	^widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!widthInBlocks: anInteger	widthInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!initializeSampleStreamBlocks: aCollection	mcuBlocks _ aCollection.	self resetSampleStream! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 14:23'!nextSample	| dx dy blockIndex sampleIndex sample |	dx _ currentX // hSampleFactor.	dy _ currentY // vSampleFactor.	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.	currentX _ currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX _ 0.			currentY _ currentY + 1].	^ sample! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!resetSampleStream	currentX _ 0.	currentY _ 0! !I represent the table of values used to decode Huffman entropy-encoded bitstreams.  From the JFIF file header entropy values, I build a derived table of codes and values for faster decoding.!!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!bits: anObject	bits _ anObject! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:31'!lookaheadBits	^lookaheadBits! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:38'!lookaheadSymbol	^lookaheadSymbol! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:59'!maxcode	^maxcode! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!values: anObject	values _ anObject! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!makeDerivedTables	| huffSize huffCode code si index lookbits |	mincode _ Array new: 16.	maxcode _ Array new: 17.	valptr _ Array new: 17.	huffSize _ OrderedCollection new.	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].	huffSize add: 0.	code _ 0.	huffCode _ Array new: huffSize size.	si _ huffSize at: 1.	index _ 1.	[(huffSize at: index) ~= 0] whileTrue:		[[(huffSize at: index) = si] whileTrue:			[huffCode at: index put: code.			index _ index + 1.			code _ code + 1].		code _ code << 1.		si _ si + 1].	index _ 1.	1 to: 16 do:		[:l |		(bits at: l) ~= 0			ifTrue:				[valptr at: l put: index.				mincode at: l put: (huffCode at: index).				index _ index + (bits at: l).				maxcode at: l put: (huffCode at: index-1)]			ifFalse:				[maxcode at: l put: -1]].	maxcode at: 17 put: 16rFFFFF.	lookaheadBits _ (Array new: 1 << Lookahead) atAllPut: 0.	lookaheadSymbol _ Array new: 1 << Lookahead.	index _ 1.	1 to: Lookahead do:		[:l |		1 to: (bits at: l) do:			[:i |			lookbits _ (huffCode at: index) << (Lookahead - l) + 1.			(1 << (Lookahead - l) to: 1 by: -1) do:				[:ctr |				lookaheadBits at: lookbits put: l.				lookaheadSymbol at: lookbits put: (values at: index).				lookbits _ lookbits + 1].			index _ index + 1]]! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/21/97 22:44'!valueForCode: code length: length	^ values at: ((valptr at: length) + code - (mincode at: length))! !!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!initialize	Lookahead _ 8.	BitBufferSize _ 16! !!JPEGHuffmanTable class methodsFor: 'constants' stamp: 'tao 10/21/97 22:15'!lookahead	^ Lookahead! !I am a subclass of ImageReadWriter that understands JFIF file streams, and can decode JPEG images.This code is based upon the Independent Joint Photographic Experts Group (IJPEG) software, originally written in C by Tom Lane, Philip Gladstone, Luis Ortiz, Jim Boucher, Lee Crocker, Julian Minguillon, George Phillips, Davide Rossi, Ge' Weijers, and other members of the Independent JPEG Group.!!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:53'!nextImage	^ self nextImageDitheredToDepth: Display depth! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 12/8/1998 21:40'!nextImageDitheredToDepth: depth	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	"Fixup the alpha channel in the 32bit form"	(BitBlt toForm: form)		destRect: form boundingBox;		fillColor: (Bitmap with: 16rFF000000);		combinationRule: 7; "bitOr:with:"		copyBits.			^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 10/26/97 21:41'!setStream: aStream	"Feed it in from an existing source"	stream _ aStream! !!JPEGReadWriter methodsFor: 'preferences' stamp: 'tao 10/26/97 22:09'!useFloatingPoint	^ false! !!JPEGReadWriter methodsFor: 'testing' stamp: 'jm 10/3/1998 08:33'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!initialSOSSetup	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:		[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	hACTable , hDCTable do: [:t | t ifNotNil: [t makeDerivedTables]].	bitBuffer _ 0.	bitsInBuffer _ 0.	lookahead _ JPEGHuffmanTable lookahead.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:31'!okToIgnoreMarker: aMarker	^ ((16rE0 to: 16rEF) includes: aMarker) "unhandled APPn markers"		or: [aMarker = 16rDC or: [aMarker = 16rFE]] "DNL or COM markers"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!parseAPPn	| length buffer thumbnailLength markerStart |	markerStart _ self position.	length _ self nextWord.	buffer _ self next: 4.	(buffer asString = 'JFIF') ifFalse: [self error: 'APP header is incorrect'].	self next.	majorVersion _ self next.	minorVersion _ self next.	densityUnit _ self next.	xDensity _ self nextWord.	yDensity _ self nextWord.	thumbnailLength _ self next * self next * 3.	length _ length - (self position - markerStart).	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].	self next: length! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!parseDecoderRestartInterval	| length |	length _ self nextWord.	length = 4 ifFalse: [self error: 'DRI length incorrect'].	restartInterval _ self nextWord.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 22:31'!parseFirstMarker	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].	self next = 16rD8 ifFalse: [self error: 'SOI marker expected'].	self parseStartOfInput.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:49'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[index _ self next.		isACTable _ (index bitAnd: 16r10) ~= 0.		index _ (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits _ self next: 16.		count _ bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal _ self next: count.		(hTable _ JPEGHuffmanTable new)			bits: bits;			values: huffVal.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:32'!parseNOP	"don't need to do anything, here"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:40'!parseNextMarker	| byte discardedBytes |	discardedBytes _ 0.	[(byte _ self next) = 16rFF] whileFalse: [ self debug. discardedBytes _ discardedBytes + 1].		[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes _ discardedBytes + 2].	discardedBytes > 0 ifTrue: [self notify: 'warning: extraneous data discarded'].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte hex , ' cannot be handled']])! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:31'!parseQuantizationTable	| length markerStart n prec value table |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[value _ self next.		n _ (value bitAnd: 16r0F) + 1.		prec _ (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table _ Array new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value _ (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!parseStartOfFile	| length markerStart value n |	markerStart _ self position.	length _ self nextWord.	dataPrecision _ self next.	dataPrecision = 8		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].	height _ self nextWord.	width _ self nextWord.	n _ self next.	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].	(length - (self position - markerStart)) ~= (n * 3)		ifTrue: [self error: 'component length is incorrect'].	components _ Array new: n.	1 to: components size do:		[:i |		components			at: i			put:				(JPEGColorComponent new					id: self next;					"heightInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					widthInBlocks: (value bitAnd: 16r0F);"					widthInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					heightInBlocks: (value bitAnd: 16r0F);					qTableIndex: self next + 1)]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!parseStartOfInput	restartInterval _ 0.	densityUnit _ 0.	xDensity _ 1.	yDensity _ 1! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!parseStartOfScan	| length n id value dcNum acNum comp |	length _ self nextWord.	n _ self next.	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].	currentComponents _ Array new: n.	1 to: n do: [:i |		id _ self next.		value _ self next.		dcNum _ (value >> 4) bitAnd: 16r0F.		acNum _ value bitAnd: 16r0F.		comp _ components detect: [:c | c id = id].		comp			dcTableIndex: dcNum+1;			acTableIndex: acNum+1.		currentComponents at: i put: comp].	ss _ self next.	se _ self next.	value _ self next.	ah _ (value >> 4) bitAnd: 16r0F.	al _ value bitAnd: 16r0F.	self initialSOSSetup.	self perScanSetup.	sosSeen _ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 9/17/1998 01:02'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | Array new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!skipMarker	| length markerStart |	markerStart _ self position.	length _ self nextWord.	self next: length - (self position - markerStart)! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 17:10'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte _ self decodeByteWithTable: huffmanDC.	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte _ aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i _ 2.	[i <= DCTSize2] whileTrue:		[byte _ self decodeByteWithTable: huffmanAC.		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i _ i + zeroCount.				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].		i _ i + 1]		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:24'!decodeByteWithTable: aHuffmanTable	| look nb length code |	look _ self peekBits: lookahead.	(look >= 0 and: [(nb _ aHuffmanTable lookaheadBits at: look+1) ~= 0])		ifTrue:			[self getBits: nb.			^ aHuffmanTable lookaheadSymbol at: look+1].	length _ 1.	code _ self getBits: length.	[code > (aHuffmanTable maxcode at: length)] whileTrue:		[code _ code << 1 + (self getBits: 1).		length _ length + 1].	length > 16 ifTrue: [self error: 'bad encoding value in bit stream'].	^ aHuffmanTable valueForCode: code length: length.				! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/23/97 13:50'!decodeMCU	| comp |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	mcuMembership withIndexDo:		[:ci :i |		comp _ currentComponents at: ci.		self			decodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)].	restartsToGo _ restartsToGo - 1.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:56'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:			[byte _ self next.			(byte = 16rFF and: [(stream peekFor: 16r00) not])					ifTrue:						[stream position: stream position - 1.						^0].			bitBuffer _ bitBuffer << 8 bitOr: byte.			bitsInBuffer _ bitsInBuffer + 8].	^ bitsInBuffer! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:54'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer				ifTrue:					[self error: 'not enough bits available to decode']].	value _ bitBuffer >> (bitsInBuffer - requestedBits).	bitBuffer _ bitBuffer bitAnd: (1 << (bitsInBuffer - requestedBits) -1).	bitsInBuffer _ bitsInBuffer - requestedBits.	^ value		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 12:46'!peekBits: requestedBits	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer ifTrue: [^ -1]].	^ bitBuffer >> (bitsInBuffer - requestedBits)		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 19:40'!processRestart	bitBuffer _ 0.	bitsInBuffer _ 0.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 09:43'!scaleAndSignExtend: aNumber inFieldWidth: w	^ aNumber < (1 << (w - 1))		ifTrue: [aNumber + (1 << w) negated + 1]		ifFalse: [aNumber]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:16'!dctFloatRangeLimit: value	^ (value / 8.0) + FloatSampleOffset.! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 _ (anArray at: i) * (qt at: i).		t1 _ (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 _ (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 _ (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 _ t0 + t2.		t11 _ t0 - t2.		t13 _ t1 + t3.		t12 _ (t1 - t3) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		t4 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 _ (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 _ (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 _ (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 _ t6 + t5.		z10 _ t6 - t5.		z11 _ t4 + t7.		z12 _ t4 - t7.		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |		t10 _ (ws at: (i+1)) + (ws at: (i+5)).		t11 _ (ws at: (i+1)) - (ws at: (i+5)).		t13 _ (ws at: (i+3)) + (ws at: (i+7)).		t12 _ ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		z13 _ (ws at: (i+6)) + (ws at: (i+4)).		z10 _ (ws at: (i+6)) - (ws at: (i+4)).		z11 _ (ws at: (i+2)) + (ws at: (i+8)).		z12 _ (ws at: (i+2)) - (ws at: (i+8)).		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'di 9/15/1998 14:29'!idctBlockInt: anArray component: aColorComponent	|  qt ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	shift _ 1 bitShift: ConstBits - Pass1Bits.	1 to: DCTSize do:		[:i |		anACTerm _ (1 to: DCTSize-1)			detect: [:row | (anArray at: (row * DCTSize + i)) ~= 0]			ifNone: [nil].		anACTerm isNil			ifTrue:				[dcval _ (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.				(0 to: DCTSize-1) do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 _ (z2 + z3) * FIXn0n541196100.				t2 _ z1 + (z3 * FIXn1n847759065 negated).				t3 _ z1 + (z2 * FIXn0n765366865).				z2 _ (anArray at: i) * (qt at: i).				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 _ (z2 + z3) bitShift: ConstBits.				t1 _ (z2 - z3) bitShift: ConstBits.				t10 _ t0 + t3.				t13 _ t0 - t3.				t11 _ t1 + t2.				t12 _ t1 - t2.				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 _ t0 + t3.				z2 _ t1 + t2.				z3 _ t0 + t2.				z4 _ t1 + t3.				z5 _ (z3 + z4) * FIXn1n175875602.				t0 _ t0 * FIXn0n298631336.				t1 _ t1 * FIXn2n053119869.				t2 _ t2 * FIXn3n072711026.				t3 _ t3 * FIXn1n501321110.				z1 _ z1 * FIXn0n899976223 negated.				z2 _ z2 * FIXn2n562915447 negated.				z3 _ z3 * FIXn1n961570560 negated.				z4 _ z4 * FIXn0n390180644 negated.				z3 _ z3 + z5.				z4 _ z4 + z5.				t0 _ t0 + z1 + z3.				t1 _ t1 +z2 +z4.				t2 _ t2 + z2 + z3.				t3 _ t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].	"Pass 2: process rows from work array, store back into anArray"	shift _ 1 bitShift: ConstBits + Pass1Bits + 3.	(0 to: DCTSize2-DCTSize by: DCTSize) do:		[:i |		z2 _ ws at: i + 3.		z3 _ ws at: i + 7.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * FIXn1n847759065 negated).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 8).		t1 _ ws at: (i + 6).		t2 _ ws at: (i + 4).		t3 _ ws at: (i + 2).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * FIXn0n899976223 negated.		z2 _ z2 * FIXn2n562915447 negated.		z3 _ z3 * FIXn1n961570560 negated.		z4 _ z4 * FIXn0n390180644 negated.		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 21:25'!idctMCU	| comp |	self useFloatingPoint		ifTrue:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockFloat: (mcuSampleBuffer at: i) component: comp]]		ifFalse:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockInt: (mcuSampleBuffer at: i) component: comp]]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!scaleQuantizationTable: table	| index |	index _ 1.	1 to: DCTSize do:		[:row |		1 to: DCTSize do:			[:col |			table at: index				put: ((table at: index) * (QTableScaleFactor at: row) *					(QTableScaleFactor at: col)) rounded.			index _ index + 1]].	^ table! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 18:53'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - FloatSampleOffset.		cr _ crSampleStream nextSample - FloatSampleOffset.		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:55'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample) + greenResidual.		y > MaxSample ifTrue: [y _ MaxSample].		greenResidual _ y bitAnd: ditherMask.		y _ y bitAnd: MaxSample - ditherMask.		y < 1 ifTrue: [y _ 1].		bits at: i put: (y<<16) + (y<<8) + y].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:58'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - SampleOffset.		cr _ crSampleStream nextSample - SampleOffset.		red _ y + ((FIXn1n40200 * cr) // 65536) + redResidual.		red > MaxSample			ifTrue: [red _ MaxSample]			ifFalse: [red < 0 ifTrue: [red _ 0]].		redResidual _ red bitAnd: ditherMask.		red _ red bitAnd: MaxSample - ditherMask.		red < 1 ifTrue: [red _ 1].		green _ y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + greenResidual.		green > MaxSample			ifTrue: [green _ MaxSample]			ifFalse: [green < 0 ifTrue: [green _ 0]].		greenResidual _ green bitAnd: ditherMask.		green _ green bitAnd: MaxSample - ditherMask.		green < 1 ifTrue: [green _ 1].		blue _ y + ((FIXn1n77200 * cb) // 65536) + blueResidual.		blue > MaxSample			ifTrue: [blue _ MaxSample]			ifFalse: [blue < 0 ifTrue: [blue _ 0]].		blueResidual _ blue bitAnd: ditherMask.		blue _ blue bitAnd: MaxSample - ditherMask.		blue < 1 ifTrue: [blue _ 1].		bits at: i put: (red bitShift: 16) + (green bitShift: 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 21:27'!colorConvertMCU	^ currentComponents size = 3		ifTrue:			[self useFloatingPoint				ifTrue: [self colorConvertFloatYCbCrMCU]				ifFalse: [self colorConvertIntYCbCrMCU]]		ifFalse: [self colorConvertGrayscaleMCU]! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:43'!sampleFloatRangeLimit: aNumber	^ (aNumber rounded max: 0) min: MaxSample! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'di 9/15/1998 14:30'!sampleRangeLimit: aNumber	aNumber < 0 ifTrue: [^ 0].	aNumber > MaxSample ifTrue: [^ MaxSample].	^ aNumber! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hACTable	hACTable ifNil: [hACTable _ Array new: HuffmanTableSize].	^ hACTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hDCTable	hDCTable ifNil: [hDCTable _ Array new: HuffmanTableSize].	^ hDCTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!qTable	qTable ifNil: [qTable _ Array new: QuantizationTableSize].	^ qTable! !!JPEGReadWriter methodsFor: 'error handling' stamp: 'tao 10/19/97 12:25'!notSupported: aString	self error: aString , ' is not currently supported'! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'tao 9/18/1998 09:06'!initialize	"general constants"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	FloatSampleOffset _ SampleOffset asFloat.	DCTSize2 _ DCTSize squared.	QuantizationTableSize _ 4.	HuffmanTableSize _ 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits _ 13.	Pass1Bits _ 2.	DCTK1 _ 2 sqrt.	DCTK2 _ 1.847759065.	DCTK3 _ 1.082392200.	DCTK4 _ -2.613125930.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder _ #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor _ (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dithering masks"	(DitherMasks _ Dictionary new)		add: 0 -> 0;		add: 1 -> 127;		add: 2 -> 63;		add: 4 -> 63;		add: 8 -> 31;		add: 16 -> 7;		add: 32 -> 0.	"dictionary of marker parsers"	(JFIFMarkerParser _ Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:05'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. stop stepping if realJoystickIndex is nil; that means we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt m mCenter r scaledPt |	realJoystickIndex ifNil: [^ self stopStepping].	threshold _ 30.	joyMax _ 350.	joyPt _ Sensor joystickXY: realJoystickIndex.	joyPt x abs < threshold ifTrue: [joyPt _ 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt _ joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue _ joyPt.	m _ handleMorph.	mCenter _ m center.	r _ m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt _ r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:00'!stepTime	^ 0! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set X range' action: #setXRange.	aCustomMenu add: 'set Y range' action: #setYRange.	autoCenter		ifTrue: [aCustomMenu add: 'turn auto-center off' action: #toggleAutoCenter]		ifFalse: [aCustomMenu add: 'turn auto-center on' action: #toggleAutoCenter].	realJoystickIndex		ifNil: [aCustomMenu add: 'track real joystick' action: #trackRealJoystick]		ifNotNil: [aCustomMenu add: 'stop tracking joystick' action: #stopTrackingJoystick].! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex _ nil.	self stopStepping.! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:59'!trackRealJoystick	| s |	s _ FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex _ Number readFromString: s.	self startStepping.! !I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!I am a 7-segment LED that can display a decimal digit!!LedDigitMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:01'!initialize	super initialize.	color _ Color green.	highlighted _ false.	digit _ 0.! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit	^ digit! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit _ anInteger \\ 10	"make sure it stays between 0 and 9"! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 17:00'!highlighted	^ highlighted! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 17:03'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor _ highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor _ color darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ ((hThickness - thickness) // 2) max: 0.	hOffset _ ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 13:58'!drawOnFills: aRectangle	^ true! !!LedDigitMorph class methodsFor: 'initialization' stamp: 'tao 5/18/1998 12:29'!initialize	HSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments _ {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}}.	VSegments _ {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}}.! !I am a collection of LED digits that can display a decimal value.  The display can be set to flash by sending flash: true.!!LedMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:38'!initialize	super initialize.	flashing _ false.	flash _ false.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:51'!color: aColor	color _ aColor.	self submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!digits	^ digits! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits _ aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash	^ flash! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!value	^ value! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value _ aNumber.	val _ value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val _ val // 10].	self changed.! !!LedMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 14:00'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color darker darker.! !!LedMorph methodsFor: 'change reporting' stamp: 'tao 5/18/1998 13:53'!layoutChanged	super layoutChanged.	submorphs withIndexDo:		[:m :i |		m			position: self position + (((i-1) * self width / digits) rounded @ 0);			extent: (self width / digits) rounded @ self height]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:42'!step	(flash or: [flashing])		ifTrue:			[flashing _ flashing not.			self submorphsDo: [:m | m highlighted: flashing]]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:44'!stepTime	^ 500! !The LessHTMLformatter provides a few more plaintext notations to swikify,to avoid typing HTML a bit more.  Used in rendering -- see FileListrenderFile!]style[(133 19)f1,f1LFileList renderFile;!!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/30/1998 13:39'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start 						to: start+1 with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString)  					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',					(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',					(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',					(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',					aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [				((aLine beginsWith: '|') and: [(aLine count: [:c | c= $|]) > 2])							"Then treat it as a table"				ifTrue: [targetStream nextPutAll: '<tr><td>',					(aLine allButFirst allButLast copyReplaceAll: '|' with:						'</td><td>'),'</td></tr>'.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.].]			ifTrue: [targetStream cr.].].	^targetStream contents.! !This class represents a straight line segment between two pointsInstance variables:	start	<Point>	start point of the line	end		<Point>	end point of the line!!LineSegment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:12'!from: startPoint to: endPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!bounds	"Return the bounds containing the receiver"	^(start min: end) corner: (start max: end)! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!end	"Return the end point"	^end! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!start	"Return the start point"	^start! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:12'!hasZeroLength	"Return true if the receiver has zero length"	^start = end! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^false! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isLineSegment	"Return true if the receiver is a line segment"	^true! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:08'!isStraight	"Return true if the receiver represents a straight line"	^true! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!length	"Return the length of the receiver"	^start dist: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	aBlock value: start value: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	^end - start! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtEnd	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtStart	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	^start + (end - start * parameter)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtEnd	"Evaluate the receiver at it's end point (e.g., self valueAtEnd = (self valueAt: 1.0))"	^end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtStart	"Evaluate the receiver at it's start point (e.g., self valueAtEnd = (self valueAt: 0.0))"	^start! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^Bezier2Segment from: start to: end! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asIntegerSegment	"Convert the receiver into integer representation"	^self species from: start asIntegerPoint to: end asIntegerPoint! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asLineSegment	"Represent the receiver as a straight line segment"	^self! !!LineSegment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:13'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' to: ';		print: end;		space.! !!LineSegment methodsFor: 'private' stamp: 'ar 11/6/1998 15:05'!debugDraw	| canvas |	canvas _ FormCanvas on: Display.	self lineSegmentsDo:[:p1 :p2|		canvas line: p1 rounded to: p2 rounded width: 1 color: Color black.	].! !!LineSegment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:10'!from: startPoint to: endPoint	^self new from: startPoint to: endPoint! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 9/21/1998 23:03'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse: [			source _ class sourceMethodAt: selector.			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 18:59'!font	| style |	textStyle		ifNil: [style _ TextStyle default]		ifNotNil: [style _ textStyle].	^ style fontNamed: style fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle _ nil]		ifNotNil: [			textStyle _ TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'list access' stamp: 'jm 9/20/1998 17:10'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy style: textStyle.	selection _ 0.	self positionList.! !I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 10/14/1998 16:04'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease _ (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease _ 0].	releaseCount _ sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/2/1998 19:54'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples _ FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample: aNumber	firstSample _ (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain: aNumber	gain _ aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples: aSampleBuffer	leftSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26'!originalSamplingRate	^ originalSamplingRate! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!pitch: p	scaledIndexIncr _		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount _ 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples: aSampleBuffer	rightSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/19/1998 10:43'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive: 184>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo _ leftSamples ~~ rightSamples.	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.	i _ (2 * startIndex) - 1.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex _ sampleIndex]				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m _ scaledIndex bitAnd: LoopIndexFractionMask.		rightVal _ leftVal _			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal _				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		rightVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0].			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].	count _ count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38'!reset	super reset.	count _ initialCount.	scaledIndex _ firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:30'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen _ scaledLoopLength asFloat / LoopIndexScaleFactor.	ed _ WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 07:49'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples _ (leftSamples size - startIndex) + 1.	fftWinSize _ 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize _ fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize _ fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i _ self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:26'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft _ self fftAt: startIndex.	powerArray _ self normalizedResultsFromFFT: fft.	threshold _ powerArray max / 50.0.	indices _ (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i].				s _ rightSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:47'!comeFullyUpOnReload	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ leftSamples]		ifFalse: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ SoundBuffer fromByteArray: self rightSamples].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:48'!objectToStoreOnDataStream    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	| objToStore |	objToStore _ self clone.	objToStore leftSamples: leftSamples asByteArray.	self isStereo		ifTrue: [objToStore rightSamples: rightSamples asByteArray]		ifFalse: [objToStore rightSamples: objToStore leftSamples].	^ objToStore! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 08:11'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo _ self isStereo.	leftSamples _ leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples _ rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples _ leftSamples].	originalSamplingRate _ originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength _ (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength _ self loopLength / 2.0].	firstSample _ (firstSample + 1) // 2.	lastSample _ (lastSample + 1) // 2.	loopEnd _ (loopEnd + 1) // 2.	scaledLoopLength _ (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 07:48'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu _ ((windowSize - 1) log: 2) truncated + 1.	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/16/1998 17:48'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r _ (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg _ r sum / r size.	^ r collect: [:v | v / avg].! !!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor _ 512.	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !I am a parser for mail files in the format output by the Unix 'mh' program.!!MHMailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream textStart textSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue:			["if possible, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile).			 fileStream _ nil]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue:		["skip the three-line message delimiter"		 3 timesRepeat: [MailDB skipRestOfLine: stream].		 textStart _ stream position.		 self scanToNextMessageIn: stream.		 textSize _ stream position - textStart.		 stream position: textStart.		 msgText _ stream next: textSize.		 aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MHMailInboxFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message delimiter (if there is one) or at the end of the stream."	| msgStart |	[true] whileTrue:		[(aStream skipTo: $:) ifFalse: [^false].	"end of stream"		 msgStart _ aStream position - 1.		 ((MailDB readStringLineFrom: aStream) = ':::::::::::::') ifTrue:			["looking good..."			 MailDB skipRestOfLine: aStream.	"skip message number"			 ((MailDB readStringLineFrom: aStream) = '::::::::::::::') ifTrue:				["found a message!!"				 aStream position: msgStart. ^true]].		 "false alarm, keep scanning"		 aStream position: msgStart + 1].! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'jm 9/28/1998 22:38'!initialize	| slider |	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ vResizing _ #shrinkWrap.	self color: (Color r: 0.484 g: 0.613 b: 0.0).	self borderWidth: 1.	channel _ 0.	controller _ 7.  "channel volume"	slider _ SimpleSliderMorph new		target: self;		actionSelector: #newSliderValue:;		minVal: 0;		maxVal: 127;		extent: 128@10.	self addMorphBack: slider.	self addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!channel	^ channel! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!channel: anInteger	channel _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!controller	^ controller! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!controller: anInteger	controller _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:54'!midiPort	^ midiPort! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:55'!midiPort: anInteger	midiPort _ anInteger.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set channel' action: #setChannel:.	aCustomMenu add: 'set controller' action: #setController:.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!controllerList	"Answer a list of controller name, number pairs to be used in the menu."	^ #((1 modulation)		(2 'breath control')		(7 volume)		(10 pan)		(11 expression)		(92 'tremolo depth')		(93 'chorus depth')		(94 'celeste depth')		(95 'phaser depth'))! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:09'!controllerName: controllerNumber	"Answer a name for the given controller. If no name is available, use the form 'CC5' (CC is short for 'continuous controller')."	self controllerList do: [:pair |		pair first = controllerNumber ifTrue: [^ pair last]].	^ 'CC', controllerNumber asString! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:46'!setChannel: evt	| menu |	menu _ MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!setController: evt	| menu |	menu _ MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 10/12/1998 16:02'!newSliderValue: newValue	"Send a control command out the MIDI port."	| val |	midiPort ifNil: [^ self].	val _ newValue asInteger.	lastValue = val ifTrue: [^ self].	lastValue _ val.	midiPort midiCmd: 16rB0 channel: channel byte: controller byte: val.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 9/29/1998 09:10'!updateLabel	| label |	(label _ self findA: StringMorph) ifNil: [^ self].	label contents: (self controllerName: controller), ', ch: ', (channel + 1) printString.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/27/1998 21:44'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	((chunkSize < 6) or: [chunkSize > 100])		ifTrue: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/27/1998 22:15'!metaEventAt: ticks	"Read a meta event. Event types appear roughly in order of expected frequency."	| type length tempo |	type _ trackStream next.	length _ self readVarLengthIntFrom: trackStream.	type = 16r51 ifTrue: [  "tempo"		tempo _ 0.		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].		track add: (TempoEvent new tempo: tempo; time: ticks).		^ self].	type = 16r2F ifTrue: [  "end of track"		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].		self endAllNotesAt: ticks.		trackStream skip: length.		^ self].	type = 16r58 ifTrue: [  "time signature"		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].		trackStream skip: length.		^ self].	type = 16r59 ifTrue: [  "key signature"		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].		trackStream skip: length.		^ self].	((type >= 1) and: [type <= 7]) ifTrue: [  "string"		strings add: (trackStream next: length) asString.		^ self].	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"	 [(type = 16r7F) or:  "sequencer specific meta event"	 [(type = 16r00) or:  "sequence number"	 [(type = 16r20)]]])  "MIDI channel prefix"		ifTrue: [			trackStream skip: length.			^ self].	type = 16r54 ifTrue: [		"SMPTE offset"		self report: 'Ignoring SMPTE offset'.		trackStream skip: length.		^ self].	"skip unrecognized meta event"	self report:		'skipping unrecognized meta event: ', (type printStringBase: 16),		' (', length printString, ' bytes)'.	trackStream skip: length.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:10'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			"Note: Tracks without note events are currently not saved to			 eliminate clutter in the score player. In control applications,			 this can be easily changed by modifying the following test."			(self trackContainsNotes: track) ifTrue: [				tracks add: track asArray.				info _ WriteStream on: (String new: 100).				strings do: [:s | info nextPutAll: s; cr].				trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:00'!guessMissingInstrumentNames	"Attempt to guess missing instrument names from the first program change in that track."	| progChange instrIndex instrName |	1 to: tracks size do: [:i |		(trackInfo at: i) isEmpty ifTrue: [			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: [nil].			progChange ifNotNil: [				instrIndex _ progChange program + 1.				instrName _ self class standardMIDIInstrumentNames at: instrIndex.				trackInfo at: i put: instrName]]].! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!readChunkType	"Read a chunk ID string from the next 4 bytes."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 19:19'!scanForMIDIHeader	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."	| asciiM p lastSearchPosition byte restOfHeader |	asciiM _ $M asciiValue.	stream skip: -3.	p _ stream position.	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [		[(byte _ stream next) ~= asciiM and: [byte ~~ nil]] whileTrue.  "find the next 'M' or file end"		restOfHeader _ (stream next: 3) asString.		restOfHeader = 'Thd'			ifTrue: [^ self]			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].		p _ stream position].	self error: 'MIDI header chunk not found'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!splitIntoTracks	"Split a type zero MIDI file into separate tracks by channel number."	| newTempoMap newTracks |	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].	newTempoMap _ OrderedCollection new.	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].	tracks first do: [:e |		e isTempoEvent			ifTrue: [newTempoMap addLast: e]			ifFalse: [(newTracks at: e channel + 1) addLast: e]].	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].	newTracks _ newTracks select: [:t | self trackContainsNotes: t].	tracks _ newTracks collect: [:t | t asArray].	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!playStream: binaryStream	ScorePlayerMorph		openOn: (self scoreFromStream: binaryStream)		title: 'a MIDI stream'! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 5/29/1998 17:12'!playURLNamed: urlString	| titleString |	titleString _ urlString		copyFrom: (urlString findLast: [:c | c=$/]) + 1		to: urlString size.	ScorePlayerMorph		openOn: (self scoreFromURL: urlString)		title: titleString.! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!scoreFromStream: binaryStream	|  score |	score _ (self new readMIDIFrom: binaryStream) asScore.	^ score! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 9/12/1998 19:57'!standardMIDIInstrumentNames	"Answer an array of Standard MIDI instrument names."	^ #(		'Grand Piano'		'Bright Piano'		'Electric Grand Piano'		'Honky-tonk Piano'		'Electric Piano 1'		'Electric Piano 2'		'Harpsichord'		'Clavichord'		'Celesta'		'Glockenspiel'		'Music Box'		'Vibraphone'		'Marimba'		'Xylophone'		'Tubular Bells'		'Duclimer'		'Drawbar Organ'		'Percussive Organ'		'Rock Organ'		'Church Organ'		'Reed Organ'		'Accordion'		'Harmonica'		'Tango Accordion'		'Nylon Guitar'		'Steel Guitar'		'Electric Guitar 1'		'Electric Guitar 2'		'Electric Guitar 3'		'Overdrive Guitar'		'Distorted Guitar'		'Guitar Harmonics'		'Acoustic Bass'		'Electric Bass 1'		'Electric Bass 2'		'Fretless Bass'		'Slap Bass 1'		'Slap Bass 2'		'Synth Bass 1'		'Synth Bass 2'		'Violin'		'Viola'		'Cello'		'Contrabass'		'Tremolo Strings'		'Pizzicato Strings'		'Orchestral Harp'		'Timpani'		'String Ensemble 1'		'String Ensemble 2'		'Synth Strings 1'		'Synth Strings 2'		'Choir Ahhs'		'Choir Oohs'		'Synth Voice'		'Orchestra Hit'		'Trumpet'		'Trombone'		'Tuba'		'Muted Trumpet'		'French Horn'		'Brass Section'		'Synth Brass 1'		'Synth Brass 2'		'Soprano Sax'		'Alto Sax'		'Tenor Sax'		'Baritone Sax'		'Oboe'		'English Horn'		'Bassoon'		'Clarinet'		'Piccolo'		'Flute'		'Recorder'		'Pan Flute'		'Blown Bottle'		'Shakuhachi'		'Whistle'		'Ocarina'		'Lead 1 (square)'		'Lead 2 (sawtooth)'		'Lead 3 (calliope)'		'Lead 4 (chiff)'		'Lead 5 (charang)'		'Lead 6 (voice)'		'Lead 7 (fifths)'		'Lead 8 (bass+lead)'		'Pad 1 (new age)'		'Pad 2 (warm)'		'Pad 3 (polysynth)'		'Pad 4 (choir)'		'Pad 5 (bowed)'		'Pad 6 (metallic)'		'Pad 7 (halo)'		'Pad 8 (sweep)'		'FX 1 (rain)'		'FX 2 (soundtrack)'		'FX 3 (crystals)'		'FX 4 (atmosphere)'		'FX 5 (brightness)'		'FX 6 (goblins)'		'FX 7 (echoes)'		'FX 8 (sci-fi)'		'Sitar'		'Banjo'		'Shamisen'		'Koto'		'Kalimba'		'Bagpipe'		'Fiddle'		'Shanai'		'Tinkle Bell'		'Agogo'		'Steel Drum'		'Woodblock'		'Taiko Drum'		'Melodic Tom'		'Synth Drum'		'Reverse Cymbal'		'Guitar Fret Noise'		'Breath Noise'		'Seashore'		'Bird Tweet'		'Telephone Ring'		'Helicopter'		'Applause'		'Gunshot')! !I am a parser for a MIDI data stream. I support:	real-time MIDI recording,	overdubbing (recording while playing),	monitoring incoming MIDI, and	interactive MIDI performances.Note: MIDI controllers such as pitch benders and breath controllers generate large volumes of data which consume processor time. In cases where this information is not of interest to the program using it, it is best to filter it out as soon as possible. I support various options for doing this filtering, including filtering by MIDI channel and/or by command type.!!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:39'!ignoreChannel: channel	"Don't record any events arriving on the given MIDI channel (in the range 1-16)."	((channel isInteger not) | (channel < 1) | (channel > 16))		ifTrue: [^ self error: 'bad MIDI channel number', channel printString].	"two-arg channel messages"	#(128 144 160 176 224) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreTwo:].	"one-arg channel messages"	#(192 208) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreOne:].! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:40'!ignoreCommand: midiCmd	"Don't record the given MIDI command on any channel."	| cmd sel | 	((midiCmd isInteger not) | (midiCmd < 128) | (midiCmd > 255))		ifTrue: [^ self error: 'bad MIDI command'].	midiCmd < 240 ifTrue: [  "channel commands; ignore on all channels"		cmd _ midiCmd bitAnd: 2r11110000.		sel _ (#(128 144 160 176 224) includes: cmd)			ifTrue: [#ignoreTwo:]			ifFalse: [#ignoreOne:].		 1 to: 16 do: [:ch | cmdActionTable at: (cmd bitOr: ch - 1) put: sel].		^ self].	(#(240 241 244 245 247 249 253) includes: midiCmd) ifTrue: [		^ self error: 'You can''t ignore the undefined MIDI command: ', midiCmd printString].	midiCmd = 242 ifTrue: [  "two-arg command"		cmdActionTable at: midiCmd put: #ignoreTwo:.		 ^ self].	midiCmd = 243 ifTrue: [  "one-arg command"		cmdActionTable at: midiCmd put: #ignoreOne:.		^ self].	(#(246 248 250 251 252 254 255) includes: midiCmd) ifTrue:	[  "zero-arg command"		cmdActionTable at: midiCmd put: #ignore.		 ^ self].	"we should not get here"	self error: 'implementation error'.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:38'!ignoreSysEx: aBoolean	"If the argument is true, then ignore incoming system exclusive message."	ignoreSysEx _ aBoolean.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:46'!ignoreTuneAndRealTimeCommands	"Ignore tuning requests and real-time commands."	cmdActionTable at: 246 put: #ignoreZero:.	"tune request"	cmdActionTable at: 248 put: #ignoreZero:.	"timing clock"	cmdActionTable at: 250 put: #ignoreZero:.	"start"	cmdActionTable at: 251 put: #ignoreZero:.		"continue"	cmdActionTable at: 252 put: #ignoreZero:.	"stop/Clock"	cmdActionTable at: 254 put: #ignoreZero:.	"active sensing"	cmdActionTable at: 255 put: #ignoreZero:.	"system reset"! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:37'!noFiltering	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."	cmdActionTable _ DefaultMidiTable deepCopy.	ignoreSysEx _ false.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:50'!recordOnlyChannels: channelList	"Record only MIDI data arriving on the given list of channel numbers (in the range 1-16)."	channelList do: [:ch |		((ch isInteger not) | (ch < 1) | (ch > 16))			ifTrue: [^ self error: 'bad Midi channel specification: ', ch printString]].	1 to: 16 do: [:ch | (channelList includes: ch) ifFalse: [self ignoreChannel: ch]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 1/6/1999 08:24'!clearBuffers	"Clear the MIDI record buffers. This should be called at the start of recording or real-time MIDI processing."		received _ received species new: 5000.	rawDataBuffer _ ByteArray new: 1000.	sysExBuffer _ WriteStream on: (ByteArray new: 100).	midiPort ifNotNil: [midiPort ensureOpen; flushInput].	startTime _ Time millisecondClockValue.	state _ #idle.! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 21:06'!processMIDIData	"Process all MIDI data that has arrived since the last time this method was executed. This method should be called frequently to process, filter, and timestamp MIDI data as it arrives."	| bytesRead |	[(bytesRead _ midiPort readInto: rawDataBuffer) > 0] whileTrue: [		timeNow _ (midiPort bufferTimeStampFrom: rawDataBuffer) - startTime.		5 to: bytesRead do: [:i | self processByte: (rawDataBuffer at: i)]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 20:24'!received	"Answer my current collection of all MIDI commands received. Items in this list have the form (<time><cmd byte>[<arg1>[<arg2>]]). Note that the real-time processing facility, midiDo:, removes items from this list as it processes them."	^ received! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/9/1998 07:53'!midiDo: aBlock	"Poll the incoming MIDI stream in real time and call the given block for each complete command that has been received. The block takes one argument, which is an array of the form (<time><cmd byte>[<arg1>[<arg2>]]). The number of arguments depends on the command byte. For system exclusive commands, the argument is a ByteArray containing the system exclusive message."	self processMIDIData.	[received isEmpty] whileFalse:		[aBlock value: received removeFirst].! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/8/1998 21:21'!midiDoUntilMouseDown: midiActionBlock	"Process the incoming MIDI stream in real time by calling midiActionBlock for each MIDI event. This block takes three arguments: the MIDI command byte and two argument bytes. One or both argument bytes may be nil, depending on the MIDI command. If not nil, evaluatue idleBlock regularly whether MIDI data is available or not. Pressing any mouse button terminates the interaction."	| time cmd arg1 arg2 |	self clearBuffers.	[Sensor anyButtonPressed] whileFalse: [		self midiDo: [:item |			time _ item at: 1.			cmd _ item at: 2.			arg1 _ arg2 _ nil.			item size > 2 ifTrue: [				arg1 _ item at: 3.				item size > 3 ifTrue: [arg2 _ item at: 4]].				midiActionBlock value: cmd value: arg1 value: arg2]].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/8/1998 21:22'!monitor	"Print MIDI messages to the transcript until any mouse button is pressed."	self midiDoUntilMouseDown: [:cmd :arg1 :arg2 |		self printCmd: cmd with: arg1 with: arg2].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/9/1998 10:19'!printCmd: cmdByte with: arg1 with: arg2	"Print the given MIDI command."	| cmd ch bend |	cmdByte < 240		ifTrue: [  "channel message" 			cmd _ cmdByte bitAnd: 2r11110000.			ch _ (cmdByte bitAnd: 2r00001111) + 1]		ifFalse: [cmd _ cmdByte].  "system message"	cmd = 128 ifTrue: [		^ Transcript show: ('key up ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 144 ifTrue: [		^ Transcript show: ('key down: ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 160 ifTrue: [		^ Transcript show: ('key pressure: ', arg1 printString, ' val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 176 ifTrue: [		^ Transcript show: ('CC', arg1 printString, ': val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 192 ifTrue: [		^ Transcript show: ('prog: ', (arg1 + 1) printString, ' chan: ', ch printString); cr].	cmd = 208 ifTrue: [		^ Transcript show: ('channel pressure ', arg1 printString, ' chan: ', ch printString); cr].	cmd = 224 ifTrue: [		bend _ ((arg2 bitShift: 7) + arg1) - 8192.		^ Transcript show: ('bend: ', bend printString, ' chan: ', ch printString); cr].	cmd = 240 ifTrue: [		^ Transcript show: ('system exclusive: ', (arg1 at: 1) printString, ' (', arg1 size printString, ' bytes)'); cr].	Transcript show: 'cmd: ', cmd printString, ' arg1: ', arg1 printString, ' arg2: ', arg2 printString; cr.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 18:34'!endSysExclusive: cmdByte	"Error!! Received 'end system exclusive' command when not receiving system exclusive data."	self error: 'unexpected ''End of System Exclusive'' command'.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreOne: cmdByte	"Ignore a one argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreOne:.	state _ #ignore1.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreTwo: cmdByte	"Ignore a two argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreTwo:.	state _ #ignore2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:45'!ignoreZero: cmdByte	"Ignore a zero argument command, such as tune request or a real-time message. Stay in the current and don't change active status. Note that real-time messages can arrive between data bytes without disruption."		"do nothing"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:36'!processByte: aByte	"Process the given incoming MIDI byte and record completed commands."	"Details: Because this must be fast, it has been hand-tuned. Be careful!!"	aByte > 247 ifTrue: [  "real-time message; can arrive at any time"		^ self perform: (cmdActionTable at: aByte) with: aByte].	#idle = state ifTrue: [		aByte >= 128			ifTrue: [  "command byte in idle state: start new command"				^ self perform: (cmdActionTable at: aByte) with: aByte]			ifFalse: [  "data byte in idle state: use running status if possible"				lastCmdByte ifNil: [^ self].  "running status unknown; skip byte"				"process this data as if it had the last command byte in front of it"				 self perform: lastSelector with: lastCmdByte.				"the previous line put us into a new state; we now 'fall through'				 to process the data byte given this new state."]].	#ignore1 = state ifTrue: [^ state _ #idle].	#ignore2 = state ifTrue: [^ state _ #ignore1].	#want1of2 = state ifTrue: [		argByte1 _ aByte.		^ state _ #want2of2].	#want2of2 = state ifTrue: [		argByte2 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1 with: argByte2).		^ state _ #idle].	#want1only = state ifTrue: [		argByte1 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1).		^ state _ #idle].	#sysExclusive = state ifTrue: [		aByte < 128 ifTrue: [			"record a system exclusive data byte"			ignoreSysEx ifFalse: [sysExBuffer nextPut: aByte].			^ self]		ifFalse: [			aByte < 248 ifTrue: [				"a system exclusive message is terminated by any non-real-time command byte"				ignoreSysEx ifFalse: [					received addLast: (Array with: timeNow with: lastCmdByte with: sysExBuffer contents)].				state _ #idle.				aByte = 247					ifTrue: [^ self]							"endSysExclusive command, nothing left to do"					ifFalse: [^ self processByte: aByte]]]].  	"no endSysExclusive; just start the next command"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordOne: cmdByte	"Record a one argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordOne:.	state _ #want1only.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordTwo: cmdByte	"Record a two argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordTwo:.	state _ #want1of2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:43'!recordZero: cmdByte	"Record a zero-byte message, such as tune request or a real-time message. Don't change active status. Note that real-time messages can arrive between data bytes without disruption."		received addLast: (Array with: timeNow with: cmdByte).! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:38'!startSysExclusive: cmdByte	"The beginning of a variable length 'system exclusive' command."	sysExBuffer resetContents.	lastCmdByte _ nil.  "system exclusive commands clear running status"	lastSelector _ nil.	state _ #sysExclusive.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 17:12'!undefined: cmdByte	"We have received an unexpected MIDI byte (e.g., a data byte when we were expecting a command). This should never happen."	self error: 'unexpected MIDI byte ', cmdByte printString.! !!MIDIInputParser methodsFor: 'private-other' stamp: 'jm 10/9/1998 07:56'!setMIDIPort: aMIDIPort	"Initialize this instance for recording from the given MIDI port. Tune and real-time commands are filtered out by default; the client can send noFiltering to receive these messages."	midiPort _ aMIDIPort.	received _ OrderedCollection new.	self noFiltering.  "initializes cmdActionTable"	self ignoreTuneAndRealTimeCommands.! !!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:25'!midiPort	^ midiPort! !!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:24'!midiPort: aMIDIPort	"Use the given MIDI port."	midiPort _ aMIDIPort.	self clearBuffers.! !!MIDIInputParser class methodsFor: 'class initialization' stamp: 'jm 10/9/1998 07:35'!initialize	"Build the default MIDI command-byte action table. This table maps MIDI command bytes to the action to be performed when that is received. Note that MIDI data bytes (bytes whose value is < 128) are never used to index into this table."	"MIDIInputParser initialize"	DefaultMidiTable _ Array new: 255 withAll: #undefined:.	128 to: 143 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key off"	144 to: 159 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key on"	160 to: 175 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"polyphonic after-touch"	176 to: 191 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"control change"	192 to: 207 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"program change"	208 to: 223 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"channel after-touch"	224 to: 239 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"pitch bend"	DefaultMidiTable at: 240 put: #startSysExclusive:.		"start a system exclusive block"	DefaultMidiTable at: 241 put: #recordOne:.			"MIDI time code quarter frame"	DefaultMidiTable at: 242 put: #recordTwo:.			"song position select"	DefaultMidiTable at: 243 put: #recordOne:.			"song select"	DefaultMidiTable at: 244 put: #undefined:.	DefaultMidiTable at: 245 put: #undefined:.	DefaultMidiTable at: 246 put: #recordZero:.			"tune request"	DefaultMidiTable at: 247 put: #endSysExclusive:.		"end a system exclusive block"	DefaultMidiTable at: 248 put: #recordZero:.			"timing clock"	DefaultMidiTable at: 249 put: #undefined:.	DefaultMidiTable at: 250 put: #recordZero:.			"start"	DefaultMidiTable at: 251 put: #recordZero:.			"continue"	DefaultMidiTable at: 252 put: #recordZero:.			"stop/Clock"	DefaultMidiTable at: 253 put: #undefined:.	DefaultMidiTable at: 254 put: #recordZero:.			"active sensing"	DefaultMidiTable at: 255 put: #recordZero:.			"system reset"! !!MIDIInputParser class methodsFor: 'instance creation' stamp: 'jm 10/8/1998 20:29'!on: aSimpleMIDIPort	"Answer a new MIDI parser on the given port."	^ super new setMIDIPort: aSimpleMIDIPort! !I implement a piano keyboard that can be played with the mouse. I can output to a MIDI port, if MIDI is supported on this platform. I can also spawn controllers for other MIDI parameters, such as pitch bend.!!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:13'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	midiPort		ifNil: [aCustomMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aCustomMenu add: 'play via built in synth' action: #closeMIDIPort.			aCustomMenu add: 'new MIDI controller' action: #makeMIDIController:].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:57'!closeMIDIPort	midiPort _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:30'!initialize	super initialize.	SimpleMIDIPort midiIsSupported		ifTrue: [midiPort _ SimpleMIDIPort openDefault].	channel _ 1.	velocity _ 100.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:11'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: midiPort).! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [^ super mouseDownEvent: event noteMorph: noteMorph pitch: midiKey - 1].	noteMorph color: playingKeyColor.	soundPlaying		ifNil: [midiPort ensureOpen]		ifNotNil: [self turnOffNote].	self turnOnNote: midiKey + 23.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:43'!mouseUpEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [		^ super mouseUpEvent: event noteMorph: noteMorph pitch: midiKey].	noteMorph color:		((#(0 1 3 5 6 8 10) includes: midiKey \\ 12)			ifTrue: [whiteKeyColor]			ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [self turnOffNote].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:44'!turnOffNote	midiPort notNil & soundPlaying notNil ifTrue: [		soundPlaying isInteger ifTrue: [			midiPort midiCmd: 16r90 channel: channel byte: soundPlaying byte: 0]].	soundPlaying _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!turnOnNote: midiKey	midiPort midiCmd: 16r90 channel: channel byte: midiKey byte: velocity.	soundPlaying _ midiKey.! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 14:55'!addAmbientEvent: evt	| i |	ambientTrack == nil ifTrue: [^ ambientTrack _ Array with: evt].	i _ ambientTrack findFirst: [:e | e time >= evt time].	i = 0 ifTrue: [^ ambientTrack _ ambientTrack , (Array with: evt)].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i-1 with: (Array with: evt)! !!MIDIScore methodsFor: 'all' stamp: 'di 8/1/1998 15:31'!ambientEventAfter: eventIndex ticks: scoreTicks	| evt |	(ambientTrack == nil or: [eventIndex > ambientTrack size]) ifTrue: [^ nil].	evt _ ambientTrack at: eventIndex.	evt time <= scoreTicks ifTrue: [^ evt].	^ nil! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 20:34'!ambientTrack	^ ambientTrack! !!MIDIScore methodsFor: 'all' stamp: 'jm 9/10/1998 17:22'!eventForTrack: trackIndex after: eventIndex ticks: scoreTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time > scoreTick ifTrue: [^ nil].	^ evt! !!MIDIScore methodsFor: 'all' stamp: 'jm 8/6/1998 21:16'!jitterStartAndEndTimesBy: mSecs	| r range halfRange oldEnd newEnd newStart |	r _ Random new.	range _ 2.0 * mSecs.	halfRange _ mSecs.	tracks do: [:t |		t do: [:e |			e isNoteEvent ifTrue: [				oldEnd _ e time + e duration.				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).				newStart _ e time + ((r next * range) asInteger - halfRange).				e time: newStart.				e duration: (newEnd - newStart)]]].				! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 08:04'!otherPlayersDo: playerBlock	"Not elegant -- scan for any players registered in the ambientTrack,	and evaluate the block for them."	| players p |	ambientTrack == nil ifTrue: [^ self].	players _ Set new.	ambientTrack do:		[:evt | p _ evt relatedPlayer.		p ifNotNil: [players add: p]].	players do: playerBlock! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!pauseFrom: scorePlayer	self otherPlayersDo: [:p | p pauseFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 21:52'!removeAmbientEventWithMorph: aMorph	| i |	ambientTrack == nil ifTrue: [^ self].	i _ ambientTrack findFirst: [:e | e morph == aMorph].	i = 0 ifTrue: [^ self].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i with: Array new! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resetFrom: scorePlayer	self otherPlayersDo: [:p | p resetFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resumeFrom: scorePlayer	self otherPlayersDo: [:p | p resumeFrom: scorePlayer]! !I implement a simple real-time MIDI synthesizer on platforms that support MIDI input. I work best on platforms that allow the sound buffer to be made very short--under 50 milliseconds is good and under 20 milliseconds is preferred (see below). The buffer size is changed by modifying the class initialization method of SoundPlayer and executing the do-it there to re-start the sound player.Each instance of me takes input from a single MIDI input port. Multiple instances of me can be used to handle multiple MIDI input ports. I distribute incoming commands among my sixteen MIDISynthChannel objects. Most of the interpretation of the MIDI commands is done by these channel objects. Buffer size notes: At the moment, most fast PowerPC Macintosh computers can probably work with buffer sizes down to 50 milliseconds, and the Powerbook G3 works down to about 15 milliseconds. You will need to experiment to discover the minimum buffer size that does not result in clicking during sound output. (Hint: Be sure to turn off power cycling on your Powerbook. Other applications and extensions can steal cycles from Squeak, causing intermittent clicking. Experimentation may be necessary to find a configuration that works for you.)!!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 22:16'!channel: i	^ channels at: i! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 10:50'!closeMIDIPort	midiParser midiPort ifNil: [^ self].	midiParser midiPort close.	midiParser midiPort: nil.! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 08:29'!initialize	midiParser _ MIDIInputParser on: nil.	channels _ (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 08:13'!instrumentForChannel: channelIndex	^ (channels at: channelIndex) instrument! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 08:14'!instrumentForChannel: channelIndex put: aSoundProto	(channels at: channelIndex) instrument: aSoundProto.! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 10:27'!isOn	^ process notNil! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 21:52'!midiParser	^ midiParser! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 08:26'!midiPort	^ midiParser midiPort! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 16:32'!midiPort: aMIDIPortOrNil	midiParser midiPort: aMIDIPortOrNil.! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 12:09'!midiTrackingLoop	midiParser clearBuffers.	[true] whileTrue: [		self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]].! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 20:12'!mutedForChannel: channelIndex put: aBoolean	^ (channels at: channelIndex) muted: aBoolean! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 19:45'!panForChannel: channelIndex	^ (channels at: channelIndex) pan! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 19:45'!panForChannel: channelIndex put: newPan	(channels at: channelIndex) pan: newPan.! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:13'!processMIDI	"Process some MIDI commands. Answer true if any commands were processed."	| didSomething cmdByte byte1 byte2 cmd chan |	didSomething _ false.	midiParser midiDo: [:item |		didSomething _ true.		cmdByte _ item at: 2.		byte1 _ byte2 _ nil.		item size > 2 ifTrue: [			byte1 _ item at: 3.			item size > 3 ifTrue: [byte2 _ item at: 4]].		cmdByte < 240			ifTrue: [  "channel message" 				cmd _ cmdByte bitAnd: 2r11110000.				chan _ (cmdByte bitAnd: 2r00001111) + 1.				(channels at: chan) doChannelCmd: cmd byte1: byte1 byte2: byte2]			ifFalse: [  "system message"				"process system messages here"			]].	^ didSomething! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:14'!processMIDIUntilMouseDown	"Used for debugging. Do MIDI processing until the mouse is pressed."	midiParser clearBuffers.	[Sensor anyButtonPressed] whileFalse: [self processMIDI].! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 16:36'!setAllChannelMasterVolumes: aNumber	| vol |	vol _ (aNumber asFloat min: 1.0) max: 0.0.	channels do: [:ch | ch masterVolume: vol].! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/13/1999 08:16'!startMIDITracking	midiParser ifNil: [^ self].	midiParser midiPort ifNil: [^ self].	midiParser midiPort ensureOpen.	self stopMIDITracking.	SoundPlayer useShortBuffer.	process _ [self midiTrackingLoop] newProcess.	process priority: Processor userInterruptPriority.	process resume.! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 10:34'!stopMIDITracking	process ifNotNil: [		process terminate.		process _ nil].	SoundPlayer shutDown; initialize.  "revert to normal buffer size"! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 16:40'!volumeForChannel: channelIndex	^  (channels at: channelIndex) masterVolume! !!MIDISynth methodsFor: 'all' stamp: 'jm 1/6/1999 16:40'!volumeForChannel: channelIndex put: newVolume	(channels at: channelIndex) masterVolume: newVolume.! !!MIDISynth class methodsFor: 'examples' stamp: 'jm 1/6/1999 16:39'!example	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."	"MIDISynth example"	| portNum synth |	portNum _ SimpleMIDIPort inputPortNumFromUser.	portNum ifNil: [^ self].	SoundPlayer useShortBuffer.	synth _ MIDISynth new		midiPort: (SimpleMIDIPort openOnPortNumber: portNum).	synth midiParser ignoreCommand: 224.  "filter out pitch bends"	1 to: 16 do: [:i |		(synth channel: i) instrument: 			 (AbstractSound soundNamed: 'oboe1')].	1 to: 16 do: [:ch | synth volumeForChannel: ch put: 0.2].	synth processMIDIUntilMouseDown.	SoundPlayer shutDown; initialize.  "revert to normal buffer size"! !!MIDISynth class methodsFor: 'instance creation' stamp: 'jm 1/6/1999 08:15'!new	^ super new initialize! !I implement one polyphonic channel of a 16-channel MIDI synthesizer. Many MIDI commands effect all the notes played on a particular channel, so I record the state for a single channel, including a list of notes currently playing.This initial implementation is extremely spartan, having just enough functionality to play notes. Things that are not implemented include:  1. program changes  2. sustain pedal  3. aftertouch (either kind)  4. most controllers  5. portamento  6. mono-mode!!MIDISynthChannel methodsFor: 'initialization' stamp: 'jm 1/6/1999 20:10'!initialize	instrument _ FMSound default.	muted _ false.	masterVolume _ 0.5.	channelVolume _ 1.0.	pan _ 0.5.	pitchBend _ 0.0.	activeSounds _ OrderedCollection new.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument	^ instrument! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument: aSound	instrument _ aSound.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:47'!masterVolume	^ masterVolume! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 11:49'!masterVolume: aNumber	"Set the master volume the the given value (0.0 to 1.0)."	masterVolume _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:10'!muted	^ muted! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:11'!muted: aBoolean	muted _ aBoolean.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!pan	^ pan! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!pan: aNumber	"Set the left-right pan to the given value (0.0 to 1.0)."	pan _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:40'!channelPressure: newPressure	"Handle a channel pressure (channel aftertouch) change."	self newVolume: newPressure.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:48'!control: control value: newValue	"Handle a continuous controller change."	control = 2 ifTrue: [self newVolume: newValue].  "breath controller"! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:44'!doChannelCmd: cmdByte byte1: byte1 byte2: byte2	"Dispatch a channel command with the given arguments."	"Details: Cases appear in order of expected frequency, most frequent cases first."	cmdByte = 144 ifTrue: [		byte2 = 0			ifTrue: [^ self keyUp: byte1 vel: 0]			ifFalse: [^ self keyDown: byte1 vel: byte2]].	cmdByte = 128 ifTrue: [^ self keyUp: byte1 vel: byte2].	cmdByte = 224 ifTrue: [^ self pitchBend: ((byte2 bitShift: 7) + byte1) - 8192].	cmdByte = 176 ifTrue: [^ self control: byte1 value: byte2].	cmdByte = 208 ifTrue: [^ self channelPressure: byte1].	cmdByte = 160 ifTrue: [^ self key: byte1 pressure: byte2].	cmdByte = 192 ifTrue: [^ self programChange: byte1].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!key: key pressure: press	"Handle a key pressure (polyphonic aftertouch) change. Rarely implemented."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/10/1999 08:42'!keyDown: key vel: vel	"Handle a key down event with non-zero velocity."	| pitch snd |	muted ifTrue: [^ self].	pitch _ AbstractSound pitchForMIDIKey: key.	snd _ instrument		soundForPitch: pitch		dur: 10000.0  "sustain a long time, or until turned off"		loudness: masterVolume * channelVolume * (self convertVelocity: vel).	snd _ (MixedSound new add: snd pan: pan) reset.	SoundPlayer resumePlaying: snd quickStart: false.	activeSounds add: (Array with: key with: snd with: pitch).! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!keyUp: key vel: vel	"Handle a key up event."	| snd |	activeSounds copy do: [:entry |		(entry at: 1) = key ifTrue: [			snd _ entry at: 2.			snd stopGracefully.			activeSounds remove: entry]].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/11/1999 11:32'!pitchBend: bend	"Handle a pitch-bend change."	self adjustPitch: bend.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:50'!programChange: newProgram	"Handle a program (instrument) change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 21:45'!adjustPitch: bend	"Handle a pitch-bend change."	| snd pitchAdj centerPitch |	pitchBend _ bend.	pitchAdj _ 2.0 raisedTo: (bend asFloat / 8192.0) / 6.0.	activeSounds copy do: [:entry |		snd _ entry at: 2.		centerPitch _ entry at: 3.		snd pitch: pitchAdj * centerPitch.		snd internalizeModulationAndRatio].! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:43'!convertVelocity: valueByte	"Map a value in the range 0..127 to a volume in the range 0.0..1.0."	"Details: A quadratic function seems to give a good keyboard feel."	| r |	r _ (valueByte * valueByte) / 12000.0.	r > 1.0 ifTrue: [^ 1.0].	r < 0.08 ifTrue: [^ 0.08].	^ r! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:41'!newVolume: valueByte	"Set the channel volume to the level given by the given number in the range 0..127."	| snd newVolume |	channelVolume _ valueByte asFloat / 127.0.	newVolume _ masterVolume * channelVolume.	activeSounds do: [:entry |		snd _ entry at: 2.		snd adjustVolumeTo: newVolume overMSecs: 10].! !a MIME object, along with its type and the URL it was found at (if any)!!MIMEDocument methodsFor: 'printing' stamp: 'ls 7/23/1998 20:12'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', ';		nextPutAll: self content size printString;		nextPutAll: ' bytes)'.! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url _ aUrl! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!content	"return the raw data in this object"	^content! !!MIMEDocument methodsFor: 'access' stamp: 'ls 9/18/1998 05:41'!contentStream	"return a RWBinaryOrTextStream on the contents"	^(RWBinaryOrTextStream with: self content) reset! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!contentType	^self mainType, '/', self subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!mainType	#XXX.  "is there a better name?"	^mainType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!subType	^subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!type	^mainType, '/', subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 8/12/1998 00:25'!url	"returns the URL this object was downloaded from.  It may legitimately be nil"	^url! !!MIMEDocument class methodsFor: 'content-types' stamp: 'ls 8/8/1998 03:15'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension _ url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension _ (extension findTokens: '.') last asLowercase.	extension = 'html' ifTrue: [ ^'text/html' ].	extension = 'htm' ifTrue:[ ^'text/html' ].	extension = 'txt' ifTrue: [ ^'text/plain' ].	extension = 'gif' ifTrue: [ ^'image/gif' ].	extension = 'jpg' ifTrue: [ ^'image/jpeg' ].	extension = 'jpeg' ifTrue: [ ^'image/jpeg' ].	extension = 'mid' ifTrue: [ ^'audio/midi' ].	^self defaultContentType! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!content: aString	^self contentType: self defaultContentType  content: aString! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 08:00'!contentType: aString  content: content	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/12/1998 00:26'!contentType: aString  content: content  url: aUrl	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl asUrl.	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!defaultContentType	^'application/octet-stream'! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/22/1998 14:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !Parse mail addresses.  The basic syntax is:	addressList := MailAddressParser addressesIn: aStringThis currently only returns the bare addresses, but it could also return a list of the address "source codes".  For example, if you give it "Joe <joe@foo>, <jane>", it will currently return a list ('joe@foo' 'jane').  It would be nice to also get a list ('Joe <joe@foo>'  '<jane>').!!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:31'!addToAddress	"add the last token to the address.  removes the token from the collection"	curAddrTokens addFirst: (tokens removeLast)! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!finishAddress	"we've finished one address.  Bundle it up and add it to the list of addresses"	| address |	address _ String streamContents: [ :str |		curAddrTokens do: [ :tok | str nextPutAll: tok text ] ].	addresses addFirst: address.	curAddrTokens _ nil.! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!startNewAddress	"set up data structures to begin a new address"	(curAddrTokens ~~ nil) ifTrue: [		self error: 'starting new address before finishing the last one!!' ].	curAddrTokens _ OrderedCollection new.	! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!grabAddressWithRoute	"grad an address of the form 'Descriptive Text <real.address@c.d.e>"		self startNewAddress.	tokens removeLast.	"remove the >"	"grab until we see a $<"	[ 		tokens isEmpty ifTrue: [			self error: '<> are not matched' ].		tokens last type = $<	] whileFalse: [ self addToAddress ].	tokens removeLast.  "remove the <"	self removePhrase.	self finishAddress! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:25'!grabAddresses	"grab all the addresses in the string"	| token |	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token _ tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 10/23/1998 13:39'!grabBasicAddress	"grad an address of the form a.b@c.d.e"	self startNewAddress.	"grab either the domain if specified, or the domain if not"	self addToAddress.	[tokens isEmpty not and: [ tokens last type = $.] ] 		whileTrue: 			["add name-dot pairs of tokens"			self addToAddress.			(#(Atom QuotedString ) includes: tokens last type)				ifFalse: [self error: 'bad token in address: ' , tokens last text].			self addToAddress].	(tokens isEmpty or: [tokens last type ~= $@])		ifTrue: ["no domain specified"			self finishAddress]		ifFalse: 			["that was the domain.  check that no QuotedString's slipped in"			curAddrTokens do: [:tok | tok type = #QuotedString ifTrue: [self error: 'quote marks are not allowed within a domain name (' , tok text , ')']].			"add the @ sign"			self addToAddress.			"add the local part"			(#(Atom QuotedString ) includes: tokens last type)				ifFalse: [self error: 'invalid local part for address: ' , tokens last text].			self addToAddress.			"add word-dot pairs if there are any"			[tokens isEmpty not and: [tokens last type = $.]]				whileTrue: 					[self addToAddress.					(tokens isEmpty not and: [#(Atom QuotedString ) includes: tokens last type])						ifTrue: [self addToAddress]].			self finishAddress]! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:07'!grabGroupAddress	"grab an address of the form 'phrase : address, address, ..., address;'"	"I'm not 100% sure what this format means, so I'm just returningthe list of addresses between the : and ;   -ls  (if this sounds right to someone, feel free to remove this comment :)"	"remove the $; "	tokens removeLast.	"grab one address each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		tokens isEmpty ifTrue: [			"no matching :"			^self error: 'stray ; in address list'. ].		tokens last type = $:	] whileFalse: [		"delegate to either grabAddressWithRoute, or grabBasicAddress.  nested groups are not allowed"		tokens last type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: tokens last type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ]	].	tokens removeLast.   "remove the :"	self removePhrase.! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!removePhrase	"skip most characters to the left of this"	[		tokens isEmpty not and: [			#(Atom QuotedString $. $@) includes: (tokens last type) ]	] whileTrue: [ tokens removeLast ].! !!MailAddressParser methodsFor: 'private-initialization' stamp: 'ls 9/13/1998 01:25'!initialize: tokenList	tokens _ tokenList asOrderedCollection copy.	addresses _ OrderedCollection new.! !!MailAddressParser class methodsFor: 'examples' stamp: 'ls 9/13/1998 02:08'!example	"test out several correct formats"	"MailAddressParser example"	^self addressesIn: 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'! !!MailAddressParser class methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:34'!addressesIn: aString	"return a collection of the bare addresses listed in aString"	| tokens |	tokens _ MailAddressTokenizer tokensIn: aString.	^(self new initialize: tokens) grabAddresses! !a single token from an RFC822 mail address.  Used internally in MailAddressParser!!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!text	^text! !!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!type	^type! !!MailAddressToken methodsFor: 'private' stamp: 'ls 9/12/1998 20:24'!type: type0  text: text0	type _ type0.	text _ text0.! !!MailAddressToken methodsFor: 'printing' stamp: 'ls 9/12/1998 20:40'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self type asString.	aStream nextPut: $|.	aStream nextPutAll: self text.	aStream nextPut: $].! !!MailAddressToken class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:31'!type: type  text: text	^self new type: type text: text! !Divides an address into tokens, as specified in RFC 822.  Used by MailAddressParser.!!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!atEndOfChars	^pos > text size! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextAtom	| start end |	start _ pos.	pos _ text indexOfAnyOf: CSNonAtom startingAt: start ifAbsent: [ text size + 1].	end _ pos - 1.	^MailAddressToken		type: #Atom		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:52'!nextChar	self atEndOfChars ifTrue: [ ^nil ].	pos _ pos + 1.	^text at: (pos-1)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:39'!nextDomainLiteral	| start end |	start _ pos.	end _ text indexOf: $] startingAt: start ifAbsent: [ 0 ].	end = 0 ifTrue: [		"not specified"		self error: 'saw [ without a matching ]' ].	pos _ end+1.	^MailAddressToken		type: #DomainLiteral		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!nextQuotedString	| res c |	res _ WriteStream on: String new.	res nextPut: self nextChar.   "record the starting quote"	[ self atEndOfChars ] whileFalse: [		c _ self nextChar.		c = $\ ifTrue: [			res nextPut: c.			res nextPut: self nextChar ]		ifFalse: [			c = $" ifTrue: [				res nextPut: c.				^MailAddressToken type: #QuotedString  text: res contents ]			ifFalse: [				res nextPut: c ] ] ].	"hmm, never saw the final quote mark"	^MailAddressToken type: #QuotedString  text: (res contents, '"')! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextSpecial	| c |	c _ self nextChar.	^MailAddressToken type: c  text: c asString.! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!nextToken	| c |	self skipSeparatorsAndComments.	c _ self peekChar.	c ifNil: [ ^nil ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:15'!peekChar	^text at: pos ifAbsent: [ nil ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 02:02'!skipComment	| nestLevel paren |	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]. ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:14'!skipSeparators	pos _ text indexOfAnyOf: CSNonSeparators  startingAt: pos  ifAbsent: [ text size + 1 ].! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!skipSeparatorsAndComments	[	self skipSeparators.		self peekChar = $(	] whileTrue: [ self skipComment ]! !!MailAddressTokenizer methodsFor: 'initialization' stamp: 'ls 9/12/1998 20:13'!initialize: aString	text _ aString.	pos _ 1.! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!atEnd	^self peek == nil! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:51'!next	| ans |	cachedToken ifNil: [ ^self nextToken ].	ans _ cachedToken.	cachedToken _ nil.	^ans! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!peek	cachedToken ifNil: [ cachedToken _ self nextToken. ].		^cachedToken	! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:54'!forString: aString	^super basicNew initialize: aString! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/13/1998 01:34'!tokensIn: aString	"return a collection of the tokens in aString"	^(self forString: aString) upToEnd! !!MailAddressTokenizer class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:02'!initialize	"MailAddressTokenizer initialize"	CSNonSeparators _ CharacterSet separators complement.	CSSpecials _ CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonAtom _ CharacterSet separators.	CSNonAtom addAll: CSSpecials.	0 to: 31 do: [ :c |		CSNonAtom add: (Character value: c) ].	CSNonAtom add: (Character value: 127).	CSParens _ CharacterSet empty.	CSParens addAll: '()'.! !I am the in-memory representation of a Celeste mail database. A mail database named "current" consists of three files:	current.messages	-- an append-only file containing the full content of all messages	current.index		-- an index of all messages in the messages file that maps unique						   message ID's to index entries containing some header information						   and the offset of the full message in the .messages file	current.categories	-- maps category names to collections of message ID'sEach open mail database has a MailDB object that manages these three files. Operations such as fetching a message given its unique ID and finding out which messages are in which category are supported by the MailDB object. It also supports incorporating new messages (reading mail), message editing and deletions, and message file compaction and recovery.!!MailDB methodsFor: 'initialize-release'!close	"Save and close the messageFile."	self saveDB.	(messageFile notNil) ifTrue: [messageFile close].	rootFilename _ nil.	messageFile _ indexFile _ categoriesFile _ nil.! !!MailDB methodsFor: 'initialize-release'!openOn: rootNameString	"Open a mail database with the given root file name."	| status |	rootFilename _ rootNameString.	status _ self dbStatus.	messageFile _ indexFile _ categoriesFile _ nil.	(status = #exists) ifTrue: [^self openDB].	(status = #partialDatabase) ifTrue: [^self recoverDB].	(status = #doesNotExist) ifTrue: [^self createDB].! !!MailDB methodsFor: 'open-create-save'!createDB	"Create a new mail database."	(self confirm:'Shall I create a new mail databasenamed: ', rootFilename, '?')		ifFalse:	"abort create operation"			[rootFilename _ nil.			 self release.			^nil].	self openDB.							"creates new DB files"	self saveDB.							"save the new mail database to disk"! !!MailDB methodsFor: 'open-create-save' stamp: 'jm 10/12/1998 13:53'!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	| dir localName |	dir _ FileDirectory forFileName: rootFilename.	localName _ FileDirectory localNameFor: rootFilename.	messageFile _ dir includesKey: localName, '.messages'.	indexFile _ dir includesKey: localName, '.index'.	categoriesFile _ dir includesKey: localName, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'open-create-save'!openDB	"Open an existing mail database."	Transcript show: 'Opening mail database ''', rootFilename, '''...'.	messageFile _ MessageFile openOn: rootFilename, '.messages'.	indexFile _ IndexFile openOn: rootFilename, '.index' messageFile: messageFile.	categoriesFile _ CategoriesFile openOn: rootFilename, '.categories'.	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'open-create-save'!recoverDB	"Open a mail database with the given root file name."	(self confirm:'The mail database named:    ', rootFilename, 'appears to be damaged. Shall I fix it?')		ifFalse: [^self release].	self openDB.	self compact.! !!MailDB methodsFor: 'open-create-save'!rootFilename	"Answer my root filename."	^rootFilename! !!MailDB methodsFor: 'open-create-save'!saveDB	"Write all database files to disk."	(rootFilename notNil)		ifTrue: [Transcript show: 'Saving mail database ''', rootFilename, '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	(messageFile notNil) ifTrue: [messageFile save].	(indexFile notNil) ifTrue: [indexFile save].	(categoriesFile notNil) ifTrue: [categoriesFile save].	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/14/1998 12:31'!fetchMailFromPOP: server userName: userName password: password doFormatting: doFormatting deleteFromServer: deleteFromServer	"Download mail from the given POP3 mail server and append it this mail database. Answer the number of messages fetched. If doFormatting is true, messages will be formatted as they are received. If deleteFromServer is true, then messages will be removed from the POP3 server after being successfully retrieved. (Note: If there is a failure while fetching mail, all messages will be left on the server.)"	| popConnection msgCount |	Socket initializeNetwork.	popConnection _ POPSocket new		serverName: server;			userName: userName;		password: password;		addProgressObserver: Transcript.	Utilities		informUser: 'connecting to ', server		during: [popConnection connectToPOP].	popConnection isConnected ifFalse: [^ -1].	msgCount _ popConnection numMessages.	msgCount > 0 ifTrue: [		self fetchMessageCount: msgCount			fromPOPConnection: popConnection			doFormatting: doFormatting.		deleteFromServer ifTrue: [			self removeMessageCount: msgCount fromPOPConnection: popConnection]].	popConnection disconnectFromPOP.	^ msgCount! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 16:10'!fetchMessageCount: msgCount fromPOPConnection: popConnection doFormatting: doFormatting	"Download the given number of messages from the given open POP3 connection. If doFormatting is true, messages will be formatted as they are received."	| nextID msgText msg location |	nextID _ self nextUnusedID.	messageFile beginAppend.	('Downloading ', msgCount printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					messageFile endAppend.					LastID _ nextID.					self saveDB.					^ self inform: 'Server connection unexpectedly closed.'].				"get a message"				msgText _ popConnection retrieveMessage: messageNum.				"save that message"				msg _ MailMessage from: msgText.				doFormatting ifTrue: [msg format].				location _ messageFile basicAppend: msg text id: nextID.				indexFile					at: nextID					put: (IndexFileEntry						message: msg						location: location						messageFile: messageFile						msgID: nextID).				categoriesFile file: nextID inCategory: 'new'.				nextID _ nextID + 1]].	messageFile endAppend.	LastID _ nextID.	self saveDB.! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 8/14/1998 16:47'!fetchNewsFrom: inboxPathName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given news inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any news?"	((FileDirectory on: inboxPathName) includesKey: 'news') ifFalse: [^ 0].	inbox _ RNInboxFile openOn: inboxPathName, ':news'.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox newsMessagesDo:		[: newsgroup : msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: newsgroup.		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^ count! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:39'!importMailFrom: inboxFileName intoCategory: category	"Append the messages from the given mail file to this mail database, and store them in the given category. Answer the number of messages imported."	| inbox nextID count msg location |	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo: [:msgText |		 msg _ MailMessage from: msgText.		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: category.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	self saveDB.	^ count! !!MailDB methodsFor: 'fetch-import-export'!mergeMessages: msgIDList from: sourceDB	"Merge the given collection of messages from the source database into the receiver. When a message being added has the same message ID as an existing message, check to see if the two message texts are identical. If so, do not store the duplicate message. If the texts are different, make a new ID for the message being added. This operation will also copy the category information from the sourceDB, creating new catetories if necessary."	| msgText newMsgID saveIt msg location entry |	messageFile beginAppend.	msgIDList do:		[: oldMsgID |		 msgText _ sourceDB getText: oldMsgID.		 "resolve ID conflicts"		 (indexFile includesKey: oldMsgID)			ifFalse:	"no ID conflict"				[newMsgID _ oldMsgID.				 saveIt _ true]			ifTrue:	"resolve an ID conflict"				[(msgText = (self getText: oldMsgID))					ifTrue:	"identical text; don't save again"						[newMsgID _ oldMsgID.						 saveIt _ false]					ifFalse:	"different text; save with new ID"						[newMsgID _ self nextUnusedID.						 saveIt _ true]].		 "save the message in the destination DB"		 saveIt ifTrue:			[msg _ MailMessage from: msgText.			 location _ messageFile basicAppend: msg text id: newMsgID.			 entry _ IndexFileEntry						message: msg						location: location 						messageFile: messageFile						msgID: newMsgID.			 indexFile at: newMsgID put: entry].		 "update the categories for the message in the destination DB"		 (sourceDB categoriesThatInclude: oldMsgID) do:			[: categoryName |			 self file: newMsgID inCategory: categoryName]].	messageFile endAppend.! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:51'!removeMessageCount: msgCount fromPOPConnection: popConnection	"Remove messages 1 through msgCount from the given POP3 server."	('Removing ', msgCount printString, ' messages from the server...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					^ self inform: 'Server connection unexpectedly closed.'].				popConnection deleteMessage: messageNum]].! !!MailDB methodsFor: 'housekeeping'!appendMessages: msgBuffer messageFile: msgFile indexFile: idxFile	"Append the given collection of messages to the message file. msgBuffer is a collection of (message ID, message text) pairs."	| id msgText location entry |	msgBuffer do:		[: idAndText |		 id _ idAndText at: 1.		 msgText _ idAndText at: 2.		 location _ msgFile basicAppend: msgText id: id.		 entry _ indexFile			at: id			ifAbsent:				[IndexFileEntry					message: (MailMessage from: msgText)					location: location					messageFile: msgFile					msgID: id].		 entry _ (entry copy) location: location; textLength: msgText size.		 idxFile at: id put: entry].! !!MailDB methodsFor: 'housekeeping'!cleanUpCategories	"Prune the dead wood out of all categories."	categoriesFile categories do:		[: category |		 categoriesFile removeMessagesInCategory: category butNotIn: indexFile].! !!MailDB methodsFor: 'housekeeping'!compact	"Compact the message file and rebuild the index file. Answer an array containing with the number of messages and the number of bytes recovered."	| newMessageFile newIndexFile stats |	newMessageFile _ MessageFile openOn: rootFilename, '.messages.tmp'.	newIndexFile _ IndexFile openOn: rootFilename, '.index.tmp' messageFile: newMessageFile.	stats _ self copyUndeletedTo: newMessageFile indexFile: newIndexFile.	newMessageFile save.	newIndexFile save.	messageFile rename: rootFilename, '.messages.bak'.	indexFile rename: rootFilename, '.index.bak'.	newMessageFile rename: rootFilename, '.messages'.	newIndexFile rename: rootFilename, '.index'.	indexFile delete.	messageFile delete.	indexFile _ newIndexFile.	messageFile _ newMessageFile.	self cleanUpCategories.	categoriesFile save.	^stats! !!MailDB methodsFor: 'housekeeping'!copyUndeletedTo: newMsgFile indexFile: newIndexFile	"Copy all the undeleted messages in my current message file into the new message file, recording their locations in the new index file. Answer an array containing with the number of messages and the number of bytes recovered."	"Note: To minimize disk seeks, messages are buffered and written in large batches. You may wish to tune the amount of buffering if you have a particular shortage or abundance of physical memory. bufferLimit is the approximate number of bytes of messages that will be accumulated before writing the buffered messages to disk."	| bufferLimit msgBuffer bufferSize deletedCount deletedBytes |	Smalltalk garbageCollect.	bufferLimit _ Smalltalk bytesLeft // 2.	"use half of the available memory"	msgBuffer _ OrderedCollection new: 1000.	bufferSize _ 0.	deletedCount _ deletedBytes _ 0.	newMsgFile beginAppend.	messageFile messagesDo:		[: deleted : msgID : msgText |		 (deleted)			ifTrue:				[deletedCount _ deletedCount + 1.				 deletedBytes _ deletedBytes + msgText size]			ifFalse:				[msgBuffer addLast: (Array with: msgID with: msgText).				 bufferSize _ bufferSize + msgText size.				 (bufferSize >= bufferLimit) ifTrue:					[self						appendMessages: msgBuffer						messageFile: newMsgFile						indexFile: newIndexFile.					 msgBuffer _ OrderedCollection new: 1000.					 bufferSize _ 0]]].	"flush remaining buffered messages"	self		appendMessages: msgBuffer		messageFile: newMsgFile		indexFile: newIndexFile.	newMsgFile endAppend.	"return statistics"	^Array with: deletedCount with: deletedBytes! !!MailDB methodsFor: 'housekeeping'!fileDuplicatesIn: categoryName	"MailDB someInstance fileDuplicatesIn: '.duplicates.'"	self fileAll: self findDuplicates inCategory: categoryName.! !!MailDB methodsFor: 'housekeeping' stamp: 'ls 9/15/1998 22:30'!findDuplicates	"MailDB someInstance findDuplicates"	| msgsAtTime m duplicates list text1 msg1 msg2 id1 id2 |	msgsAtTime _ Dictionary new.	(self messagesIn: '.all.') do: [ :msgID |		m _ indexFile at: msgID.		(msgsAtTime includesKey: m time) ifFalse: [			msgsAtTime at: m time put: OrderedCollection new.		].		(msgsAtTime at: m time) add: (Array with: msgID with: m).	].	duplicates _ Set new.	msgsAtTime associationsDo: [ :assoc |		list _ assoc value asOrderedCollection.		list do: [ :arr1 |  			id1 _ arr1 at: 1.			msg1 _ arr1 at: 2.			text1 _ self getText: id1.			list do: [ :arr2 |				id2 _ arr2 at: 1.				msg2 _ arr2 at: 2.				(id1 < id2 and: 				 [ (duplicates includes: id2) not and:				 [ msg2 _ self getMessage: id2.  msg1 to = msg2 to and:				 [ msg1 subject = msg2 subject and: 				 [ msg1 from = msg2 from and:				 [ text1 = (self getText: id2) ] ] ] ] ]) ifTrue: [ duplicates add: id2 ]. ] ] ].	^duplicates asArray! !!MailDB methodsFor: 'housekeeping' stamp: 'jm 10/4/1998 11:06'!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).  "never go backwards!!"	LastID _ id.	^ id! !!MailDB methodsFor: 'categories'!addCategory: categoryName	"Create a category with the given name if one doesn't already exist."	categoriesFile addCategory: categoryName.! !!MailDB methodsFor: 'categories'!allCategories	"Answer a list of categories sorted in alphabetical order, including the special categories."	^categoriesFile categories asSortedCollection asOrderedCollection! !!MailDB methodsFor: 'categories'!categoriesThatInclude: msgID	"Answer a collection of names for real categories that include the message with the given ID. Pseudo-categories (such as '.unclassified.') are not considered real categories."	^categoriesFile categories select:		[: catName |		 (categoriesFile messagesIn: catName) includes: msgID]! !!MailDB methodsFor: 'categories'!file: msgID inCategory: categoryName	"File the message with the given ID in the given category."	categoriesFile file: msgID inCategory: categoryName.! !!MailDB methodsFor: 'categories'!fileAll: msgIDList inCategory: categoryName	"File all the messages with ID's in the given list in the given category."	msgIDList do:		[: msgID |		 categoriesFile file: msgID inCategory: categoryName].! !!MailDB methodsFor: 'categories'!messagesIn: categoryName	"Answer a collection of message ID's for the messages in the given category, sorted in ascending time order.  If the category does not exist, answer an empty collection. The pseudo-categories '.all.' and '.unclassified.' are computed dynamically, which may take a little time."	| msgList category |	(categoryName = '.unclassified.') ifTrue:		[Cursor execute showWhile:			[msgList _ categoriesFile unclassifiedFrom: indexFile keys].		 ^msgList].	(categoryName = '.all.') ifTrue:		[^indexFile keys].	"otherwise, it is a real category"	category _ categoriesFile messagesIn: categoryName.	^indexFile keys select:		"indexFile keys is sorted"		[: msgID | category includes: msgID]! !!MailDB methodsFor: 'categories'!remove: msgID fromCategory: categoryName	"Remove the message with the given ID from the given category."	categoriesFile remove: msgID fromCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeAll: msgIDList fromCategory: categoryName	"Remove all the messages with ID's in the given list from the given category."	msgIDList do:		[: msgID |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!removeCategory: categoryName	"Remove the category with the given name. This does nothing if the category does not exist or if it is a pseudo-category."	categoriesFile removeCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeFromAllCategories: msgID	"Remove the message with the given ID from all categories. The message will appear in 'unclassified'."	categoriesFile categories do:		[: categoryName |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories' stamp: 'jm 10/4/1998 11:16'!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('.all.' or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages' stamp: 'jm 10/4/1998 11:13'!addNewMessage: message	"Add the given message to the database, and answer its message id."	| id location |	id _ self nextUnusedID.	location _ messageFile append: message text id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	^ id! !!MailDB methodsFor: 'messages'!delete: msgID	"Delete the messages with the given ID from the message file. In contrast to simply removing a message from a category, this is permanent!!"	messageFile		deleteMessageAt: (indexFile at: msgID) location		id: msgID.	indexFile remove: msgID.	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!deleteAll: msgIDList	"Delete all the messages with ID's in the given list from the message file. This is permanent!!"	msgIDList do:		[: msgID |		 messageFile			deleteMessageAt: (indexFile at: msgID) location			id: msgID.		 indexFile remove: msgID].	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!getMessage: msgID	"Answer the MailMessage with the given ID."	^MailMessage from: (self getText: msgID)! !!MailDB methodsFor: 'messages'!getTOCentry: msgID	"Answer the table-of-contents entry for the message with the given ID."	^indexFile at: msgID! !!MailDB methodsFor: 'messages'!getTOCstring: msgID	"Answer the table-of-contents string for the message with the given ID."	^(indexFile at: msgID) tocString! !!MailDB methodsFor: 'messages'!getText: msgID	"Answer the text for the message with the given ID."	| entry |	entry _ indexFile at: msgID.	^messageFile		getMessage: msgID		at: entry location		textLength: entry textLength! !!MailDB methodsFor: 'messages'!newText: newText for: msgID	"Replace the text for the message with the given ID."	| oldLocation newLocation newEntry |	oldLocation _ (indexFile at: msgID) location.	newLocation _ messageFile update: newText at: oldLocation id: msgID.	newEntry _ IndexFileEntry		message: (MailMessage from: newText)		location: newLocation		messageFile: messageFile		msgID: msgID.	indexFile at: msgID put: newEntry.! !!MailDB methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a MailDB on ''', rootFilename, ''''.! !!MailDB class methodsFor: 'instance creation'!openOn: rootFilename	"Open or create a mail database with the given root filename. If an instance of me exists with the given root filename, return a reference to that instance rather than creating a new one. This allows multiple MailReaders to be open on the same database without synchronization problems."	| alreadyOpenDB |	alreadyOpenDB _ self allInstances		detect:			[: db |			 (db rootFilename notNil) and:			 [db rootFilename = rootFilename]]		ifNone: [nil].	(alreadyOpenDB notNil)		ifTrue: [^alreadyOpenDB]		ifFalse: [^(self new) openOn: rootFilename].! !!MailDB class methodsFor: 'utilities'!readIntegerLineFrom: aStream	"Read a positive integer from the given stream. Answer zero if there are no digits. Consume the stream through the next carriage return."	| digit value |	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		 ((digit >= 0) & (digit <= 9))			ifTrue: 				[value _ (value * 10) + digit]			ifFalse:				[(digit == Character cr digitValue) ifFalse:					[self skipRestOfLine: aStream].				 ^value]].	^value! !!MailDB class methodsFor: 'utilities' stamp: 'ls 9/8/1998 05:19'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	| |	^aStream upTo: Character cr! !!MailDB class methodsFor: 'utilities'!skipRestOfLine: aStream	"Consume characters from the given stream through the next carriage return."	| crValue |	crValue _ Character cr asciiValue.	[aStream atEnd or:	 [aStream next asciiValue == crValue]] whileFalse:		["consume until end of stream or a carriage return"].! !I am an abstract class that collects some of the operations common to all mail database files.!!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:40'!delete	"Delete this file."	FileDirectory splitName: filename to: [:dirPath :name |		(FileDirectory forFileName: filename) 			deleteFileNamed: name ifAbsent: []].! !!MailDBFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:35'!rename: newFileName	"Rename this file."	FileDirectory splitName: filename to: [:dirPath :oldFileName |		(FileDirectory forFileName: filename) 			rename: oldFileName toBe: newFileName].	filename _ newFileName.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:00'!save	"Atomically save a representation of this object to its file. The old file is renamed to '<oldname>.bak' before the new file is written. If the write operation fails, the old file may be restored by renaming it. If it succeeds, the .bak file is deleted."	| f dir shortName |	"create the file if it doesn't already exist"	(StandardFileStream isAFileNamed: filename) ifFalse: [		f _ StandardFileStream new open: filename forWrite: true.		f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir rename: shortName toBe: shortName, '.bak'.	f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.	dir deleteFileNamed: (shortName, '.bak') ifAbsent: [].! !!MailDBFile methodsFor: 'read-write'!readFrom: aStream	"Subclasses must override this method to provide a means of reading themselves into memory."	self subclassResponsibility! !!MailDBFile methodsFor: 'read-write'!writeOn: aStream	"Subclasses must override this method to provide a means of writing themseves out on their files."	self subclassResponsibility! !!MailDBFile methodsFor: 'error reporting'!reportInconsistency	"Report that the index file is not consistent with the messages file."	self error:'The .index file is not consistent with the .messages file. Thismay be fixed by compacting the mail database, whichwill rebuild the index file from scratch.'! !!MailDBFile class methodsFor: 'instance creation'!openOn: fileName	"Answer a new instance of me, backed by the file with the given name."	^(super new) openOn: fileName! !I am a parser for mail inboxes in a form found in the Unix '/var/spool' inboxes. This is also the format used by Eudora 3.0 on the Macintosh (and perhaps by other versions of Eudora as well).!!MailInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for mail inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!MailInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for mail inboxes."	self error: 'Mail inboxes are read only!!'! !!MailInboxFile methodsFor: 'scanning'!delimitersDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText delim |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue: [		aBlock value: (MailDB readStringLineFrom: stream)].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!findPossibleMessageStart: aStream	"Find the next line starting with the string 'From' followed by a space. Leave the input stream positioned at the character following the space."	(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].	[true] whileTrue: [		aStream skipTo: Character cr.		[aStream peek = Character cr] whileTrue: [aStream next].		(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].		aStream atEnd ifTrue: [^false].	].! !!MailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	self scanToNextMessageIn: stream.	MailDB skipRestOfLine: stream.  "skip message delimiter"	msgStart _ stream position.	[self scanToNextMessageIn: stream] whileTrue: [		msgSize _ stream position - msgStart.		stream position: msgStart.		msgText _ stream next: msgSize.		MailDB skipRestOfLine: stream.  "skip message delimiter"		msgStart _ stream position.		aBlock value: msgText].	"process final message"	msgSize _ stream position - msgStart.	msgSize > 0 ifTrue: [		stream position: msgStart.		msgText _ stream next: msgSize.		aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!nextStringIs: aString in: aStream	"If the next characters of the given stream form the given string, then advance the stream position by the size of the string and return true. Otherwise, leave the stream untouched and return false."	| oldPosition |	oldPosition _ aStream position.	1 to: aString size do: [ :i |		aStream next = (aString at: i) ifFalse: [			aStream position: oldPosition.			^false		].	].	aStream position: oldPosition.	^true! !!MailInboxFile methodsFor: 'scanning' stamp: 'ls 8/21/1998 10:21'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message or at the end of the stream."	| msgStart line dayOfWeek year |	[aStream atEnd] whileFalse: [		(self findPossibleMessageStart: aStream) ifFalse: [^false].		msgStart _ aStream position.		aStream next: 5.  "skip 'From '"		"skip address"		[aStream peek isSeparator] whileFalse: [aStream next].		[aStream peek = Character space] whileTrue: [aStream next].		line _ MailDB readStringLineFrom: aStream.		line size >= 7 ifTrue: [			dayOfWeek _ (line copyFrom: 1 to: 3) asLowercase.			year _ (line copyFrom: line size - 3 to: line size) asNumber.			((#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: dayOfWeek) and:			[(year > 1900) and: [year < 2100]]) ifTrue: [				aStream position: msgStart.				^true  "found a message!!"			].		].	].	^false! !I represent a mail or news message. I parse the message header and keep certain header fields in instance variables for rapid access.!!MailMessage methodsFor: 'initialize-release' stamp: 'ls 10/27/1998 23:28'!from: aString 	"Parse the given string to initialize myself. The given string will become 	my text."	| parseStream isMime contentType bodyText contentTransferEncoding |	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	parseStream _ ReadStream on: text.	isMime _ false.	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	self fieldsFrom: parseStream do: 		[:fName :fValue | 		fName = 'date' ifTrue: [time _ self timeFrom: fValue].		fName = 'from' ifTrue: [from _ fValue].		fName = 'to'			ifTrue: [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].		fName = 'cc'			ifTrue: [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].		fName = 'subject' ifTrue: [subject _ fValue].		fName = 'mime-version' ifTrue: [isMime _ true].		fName = 'content-type' ifTrue: [contentType _ fValue].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding _ fValue asLowercase]].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText _ Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [ bodyText _ bodyText decodeQuotedPrintable ].	isMime		ifTrue: [body _ MIMEDocument contentType: contentType content: bodyText]		ifFalse: [body _ MIMEDocument contentType: 'text/plain' content: bodyText]! !!MailMessage methodsFor: 'initialize-release'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^aString copyFrom: 1 to: i]		ifFalse: [^''].! !!MailMessage methodsFor: 'access' stamp: 'ls 1/3/1999 15:48'!body	"return just the body of the message"	^body! !!MailMessage methodsFor: 'access' stamp: 'ls 1/3/1999 15:52'!bodyText	"return the text of the body of the message"	^body content! !!MailMessage methodsFor: 'access'!cc	^cc! !!MailMessage methodsFor: 'access'!date	"Answer a date string for this message."	^(Time aTime: (time + (Date newDay: 1 year: 1980) asSeconds)) first		printFormat: #(2 1 3 47 1 2)! !!MailMessage methodsFor: 'access'!from	^from! !!MailMessage methodsFor: 'access'!subject	^subject! !!MailMessage methodsFor: 'access'!text	^text! !!MailMessage methodsFor: 'access'!time	^time! !!MailMessage methodsFor: 'access'!to	^to! !!MailMessage methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:27'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value."	| savedLine line s |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators; skip: -1.			line _ line, s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!MailMessage methodsFor: 'parsing'!readDateFrom: aStream	"Parse a date from the given stream and answer nil if the date can't be parsed. The date may be in any of the following forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>		(4/5/82)	In addition, the date may be preceded by the day of the week and an optional comma, such as:		Tue, November 14, 1989"	| day month year |	self skipWeekdayName: aStream.	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"month name or weekday name"			[month _ WriteStream on: (String new: 10).			 [aStream peek isLetter] whileTrue: [month nextPut: aStream next].			 month _ month contents.			 day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				 (aStream peek isDigit) ifFalse: [^nil].				 day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			 day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	(aStream peek isDigit) ifFalse: [^nil].	year _ Integer readFrom: aStream.	^Date newDay: day month: month year: year! !!MailMessage methodsFor: 'parsing'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field has an empty value part."	| s fieldName fieldValue |	s _ ReadStream on: aString.	fieldName _ (s upTo: $:) asLowercase.	s skipSeparators.	(s atEnd) ifFalse: [		"field is not empty"		fieldValue _ s upToEnd.		aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'parsing'!skipWeekdayName: aStream	"If the given stream starts with a weekday name or its abbreviation, advance the stream to the first alphaNumeric character following the weekday name."	| position name abbrev |	aStream skipSeparators.	(aStream peek isDigit) ifTrue: [^self].	(aStream peek isLetter) ifTrue:		[position _ aStream position.		 name _ WriteStream on: (String new: 10).		 [aStream peek isLetter] whileTrue: [name nextPut: aStream next].		 abbrev _ (name contents copyFrom: 1 to: (3 min: name position)).		 abbrev _ abbrev asLowercase.		 (#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: abbrev asLowercase)			ifTrue:				["found a weekday; skip to the next alphanumeric character"				 [aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]			ifFalse:				["didn't find a weekday so restore stream position"				 aStream position: position]].! !!MailMessage methodsFor: 'parsing'!timeFrom: aString	"Parse the date and time and answer the result as the number of seconds since the start of 1980. The time is interpreted in the sender's time-zone; it should really be converted to GMT, depending on the timezone of the sender..."	| s t |	s _ ReadStream on: aString.	t _ (self readDateFrom: s) asSeconds.  "date part"	[s atEnd or: [s peek isAlphaNumeric]] whileFalse: [s next].	(s atEnd) ifFalse:		["read time part (interpreted as local, regardless of sender's timezone)"		 t _ t + (Time readFrom: s) asSeconds].	^t - (Date newDay: 1 year: 1980) asSeconds		"time started with 1980..."! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 1/3/1999 15:46'!cleanedHeader		| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do:		[: fName : fValue |		 (#('received'			'return-path'			'newsgroups'			'message-id'			'path'			'reply-to'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from') includes: fName) ifFalse:				[new nextPutAll: fName capitalized.				 new nextPutAll: ': '.				 new nextPutAll: fValue; cr]].	new cr.	^new contents! !!MailMessage methodsFor: 'printing/formatting'!eudoraOutboxText	"Return this message formatted for inclusion in a Eudora outbox."	| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	MailMessage new fieldsFrom: old do: [ :fName :fValue | "skip header fields" ].	new nextPutAll: 'To: ';		nextPutAll: to; cr.	new nextPutAll: 'From: ';	nextPutAll: from; cr.	new nextPutAll: 'Subject: ';	nextPutAll: subject; cr.	new nextPutAll: 'Cc: ';		nextPutAll: cc; cr.	new nextPutAll: 'Bcc: '; cr.	new nextPutAll: 'X-attachments: '; cr.	new cr.	new nextPutAll: old upToEnd.	^new contents! !!MailMessage methodsFor: 'printing/formatting'!format	"Replace the text of this message with a formatted version."	"NOTE: This operation discards extra header fields."	text _ self formattedText.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 10/27/1998 13:38'!formattedText	"Answer a version of my text with a cleaned up header"	^self cleanedHeader, self bodyText! !!MailMessage methodsFor: 'printing/formatting'!replace: oldString with: newString in: aString	"Replace all occurances of oldString in the given string with newString."	| target where |	target _ aString.	where _ 1.	[(where _ target findString: oldString startingAt: where) = 0] whileFalse:		[target _ target					copyReplaceFrom: where					to: where + oldString size - 1					with: newString].	^target! !!MailMessage class methodsFor: 'instance creation'!from: aString	"Initialize a new instance from the given string."	^(self new) from: aString! !a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.!!MailtoUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 21:05'!activate	(Smalltalk includesKey: #EmailWindow) ifTrue: [		(Smalltalk at: #EmailWindow) beginNewMessageTo: self locator	].	self notify: 'no mail reader present'! !I represent an access mechanism for a sequencable collection re-ordering or filtering its elements.!!MappedCollection methodsFor: 'accessing'!at: anIndex	^domain at: (map at: anIndex)! !!MappedCollection methodsFor: 'accessing'!at: anIndex put: anObject	^domain at: (map at: anIndex) put: anObject! !!MappedCollection methodsFor: 'accessing'!contents	"Answer the receiver's domain for mapping, a Dictionary or 	SequenceableCollection."	^map collect: [:mappedIndex | domain at: mappedIndex]! !!MappedCollection methodsFor: 'accessing'!size	^map size! !!MappedCollection methodsFor: 'adding'!add: newObject	self shouldNotImplement! !!MappedCollection methodsFor: 'copying'!copy	"This returns another MappedCollection whereas copyFrom:to: will return	an object like my domain."	^MappedCollection collection: domain map: map! !!MappedCollection methodsFor: 'enumerating'!collect: aBlock 	"Refer to the comment in Collection|collect:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do:		[:domainValue | 		aStream nextPut: (aBlock value: domainValue)].	^aStream contents! !!MappedCollection methodsFor: 'enumerating'!do: aBlock 	"Refer to the comment in Collection|do:."	map do:		[:mapValue | aBlock value: (domain at: mapValue)]! !!MappedCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do:		[:domainValue | 		(aBlock value: domainValue)			ifTrue: [aStream nextPut: domainValue]].	^aStream contents! !!MappedCollection methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	domain storeOn: aStream.	aStream nextPutAll: ' mappedBy: '.	map storeOn: aStream.	aStream nextPut: $)! !!MappedCollection methodsFor: 'private'!setCollection: aCollection map: aDictionary	domain _ aCollection.	map _ aDictionary! !!MappedCollection methodsFor: 'private'!species	^domain species! !!MappedCollection class methodsFor: 'instance creation'!collection: aCollection map: aSequenceableCollection 	"Answer an instance of me that maps aCollection by 	aSequenceableCollection."	^self basicNew setCollection: aCollection map: aSequenceableCollection! !!MappedCollection class methodsFor: 'instance creation'!new	self error: 'MappedCollections must be created using the collection:map: message'! !!MappedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ self collection: aCollection map: (1 to: aCollection size)"	MappedCollection newFrom: {1. 2. 3}	{4. 3. 8} as: MappedCollection"! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:30'!m23PrimitiveComposeMatrix	| m1 m2 m3 result |	self export: true.	self inline: false.	self var: #m1 declareC:'float *m1'.	self var: #m2 declareC:'float *m2'.	self var: #m3 declareC:'float *m3'.	m3 _ self loadArgumentMatrix: (result _ interpreterProxy stackObjectValue: 0).	m2 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	m1 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3ComposeMatrix: m1 with: m2 into: m3.	interpreterProxy pop: 3.	interpreterProxy push: result.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/29/1998 15:49'!m23PrimitiveInvertPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3InvertPoint: matrix.	interpreterProxy failed ifFalse:[self roundAndStoreResultPoint: 2].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/29/1998 15:50'!m23PrimitiveInvertRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	interpreterProxy failed ifFalse:[		dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:27'!m23PrimitiveIsIdentity	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 2) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 5) = (self cCoerce: 0.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:27'!m23PrimitiveIsPureTranslation	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/2/1998 19:27'!m23PrimitiveTransformPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3TransformPoint: matrix.	self roundAndStoreResultPoint: 2.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 14:09'!m23PrimitiveTransformRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 9/28/1998 00:55'!matrix2x3ComposeMatrix: m1 with: m2 into: m3	"Multiply matrix m1 with m2 and store the result into m3."	| a11 a12 a13 a21 a22 a23 |	self var: #m1 declareC:'const float *m1'.	self var: #m2 declareC:'const float *m2'.	self var: #m3 declareC:'float *m3'.	self var: #a11 declareC:'double a11'.	self var: #a12 declareC:'double a12'.	self var: #a13 declareC:'double a13'.	self var: #a21 declareC:'double a21'.	self var: #a22 declareC:'double a22'.	self var: #a23 declareC:'double a23'.	a11 _ ((m1 at: 0) * (m2 at: 0)) + ((m1 at: 1) * (m2 at: 3)).	a12 _ ((m1 at: 0) * (m2 at: 1)) + ((m1 at: 1) * (m2 at: 4)).	a13 _ ((m1 at: 0) * (m2 at: 2)) + ((m1 at: 1) * (m2 at: 5)) + (m1 at: 2).	a21 _ ((m1 at: 3) * (m2 at: 0)) + ((m1 at: 4) * (m2 at: 3)).	a22 _ ((m1 at: 3) * (m2 at: 1)) + ((m1 at: 4) * (m2 at: 4)).	a23 _ ((m1 at: 3) * (m2 at: 2)) + ((m1 at: 4) * (m2 at: 5)) + (m1 at: 5).	m3 at: 0 put: (self cCoerce: a11 to: 'float').	m3 at: 1 put: (self cCoerce: a12 to: 'float').	m3 at: 2 put: (self cCoerce: a13 to: 'float').	m3 at: 3 put: (self cCoerce: a21 to: 'float').	m3 at: 4 put: (self cCoerce: a22 to: 'float').	m3 at: 5 put: (self cCoerce: a23 to: 'float').! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 11/2/1998 03:37'!matrix2x3InvertPoint: m	"Invert the pre-loaded argument point by the given matrix"	| x y det detX detY |	self var: #m declareC:'float *m'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #det declareC:'double det'.	self var: #detX declareC:'double detX'.	self var: #detY declareC:'double detY'.	x _ m23ArgX - (m at: 2).	y _ m23ArgY - (m at: 5).	det _ ((m at: 0) * (m at: 4)) - ((m at: 1) * (m at: 3)).	det = 0.0 ifTrue:[^interpreterProxy primitiveFail]."Matrix is singular."	det _ 1.0 / det.	detX _ (x * (m at: 4)) - ((m at: 1) * y).	detY _ ((m at: 0) * y) - (x * (m at: 3)).	m23ResultX _ detX * det.	m23ResultY _ detY * det.! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 11/9/1998 16:23'!matrix2x3TransformPoint: m	"Transform the pre-loaded argument point by the given matrix"	self var: #m declareC:'float *m'.	m23ResultX _ (m23ArgX * (m at: 0)) + (m23ArgY * (m at: 1)) + (m at: 2).	m23ResultY _ (m23ArgX * (m at: 3)) + (m23ArgY * (m at: 4)) + (m at: 5).! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/9/1998 15:17'!loadArgumentMatrix: matrix	"Load the argument matrix"	self returnTypeC:'float *'.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: matrix) and:[(interpreterProxy slotSizeOf: matrix) = 6]) 		ifFalse:[interpreterProxy primitiveFail.				^nil].	^self cCoerce: (interpreterProxy firstIndexableField: matrix) to:'float *'.! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/9/1998 16:17'!loadArgumentPoint: point	"Load the argument point into m23ArgX and m23ArgY"	| oop isInt |	interpreterProxy failed ifTrue:[^nil].	"Check class of point"	(interpreterProxy fetchClassOf: point) = (interpreterProxy classPoint) 		ifFalse:[^interpreterProxy primitiveFail].	"Load X value"	oop _ interpreterProxy fetchPointer: 0 ofObject: point.	isInt _ interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgX _ interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgX _ interpreterProxy floatValueOf: oop].	"Load Y value"	oop _ interpreterProxy fetchPointer: 1 ofObject: point.	isInt _ interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgY _ interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgY _ interpreterProxy floatValueOf: oop].! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:37'!okayIntValue: value	^(value >= -1073741824 asFloat and:[m23ResultX <= 1073741823 asFloat]) ! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:39'!roundAndStoreResultPoint: nItemsToPop	"Store the result of a previous operation.	Fail if we cannot represent the result as SmallInteger"	m23ResultX _ m23ResultX + 0.5.	m23ResultY _ m23ResultY + 0.5.	(self okayIntValue: m23ResultX) ifFalse:[^interpreterProxy primitiveFail].	(self okayIntValue: m23ResultY) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: nItemsToPop.	interpreterProxy push:		(interpreterProxy makePointwithxValue: m23ResultX asInteger 							yValue: m23ResultY asInteger).! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:38'!roundAndStoreResultRect: dstOop x0: x0 y0: y0 x1: x1 y1: y1	"Check, round and store the result of a rectangle operation"	| minX maxX minY maxY originOop cornerOop rectOop |	self var: #x0 declareC:'double x0'.	self var: #y0 declareC:'double y0'.	self var: #x1 declareC:'double x1'.	self var: #y1 declareC:'double y1'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	minX _ x0 + 0.5.	(self okayIntValue: minX) ifFalse:[^interpreterProxy primitiveFail].	maxX _ x1 + 0.5.	(self okayIntValue: maxX) ifFalse:[^interpreterProxy primitiveFail].	minY _ y0 + 0.5.	(self okayIntValue: minY) ifFalse:[^interpreterProxy primitiveFail].	maxY _ y1 + 0.5.	(self okayIntValue: maxY) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: dstOop.	originOop _ interpreterProxy makePointwithxValue: minX asInteger yValue: minY asInteger.	interpreterProxy pushRemappableOop: originOop.	cornerOop _ interpreterProxy makePointwithxValue: maxX asInteger yValue: maxY asInteger.	originOop _ interpreterProxy popRemappableOop.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: originOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: cornerOop.	^rectOop! !!Matrix2x3Plugin class methodsFor: 'class initialization' stamp: 'ar 11/2/1998 03:39'!declareCVarsIn: cg	cg var: 'm23ResultX' declareC:'double m23ResultX'.	cg var: 'm23ResultY' declareC:'double m23ResultY'.	cg var: 'm23ArgX' declareC:'double m23ArgX'.	cg var: 'm23ArgY' declareC:'double m23ArgY'.! !This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix containing the transformation from the local coordinate system in the global coordinate system. Thus, transforming points from local to global coordinates is fast and cheap whereas transformations from global to local coordinate systems are relatively expensive.Implementation Note: It is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here).!!MatrixTransform2x3 methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:17'!setIdentiy	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	self		a11: 1.0; a12: 0.0; a13: 0.0;		a21: 0.0; a22: 1.0; a23: 0.0.! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 16:28'!at: index	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 16:28'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/18/1998 14:03'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r3.	r2 _ (self invertPoint: 0@1) - r3.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:19'!offset	^self a13 @ self a23! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:05'!offset: aPoint	self a13: aPoint x asFloat.	self a23: aPoint y asFloat.! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a11	^self at: 1! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a11: value	 self at: 1 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a12	^self at: 2! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a12: value	 self at: 2 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a13	^self at: 3! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a13: value	 self at: 3 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a21	 ^self at: 4! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a21: value	 self at: 4 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a22	 ^self at: 5! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a22: value	 self at: 5 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a23	 ^self at: 6! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a23: value	 self at: 6 put: value! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:05'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	<primitive: 'm23PrimitiveIsIdentity'>	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:15'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^true! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:06'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	<primitive: 'm23PrimitiveIsPureTranslation'>	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 11/2/1998 19:32'!= MatrixTransform2x3	| length |	<primitive:'primitiveFloatArrayEqual'>	self class = MatrixTransform2x3 class ifFalse:[^false].	length _ self size.	(length = MatrixTransform2x3 size) ifFalse:[^false].	1 to: self size do:[:i| (self at: i) = (MatrixTransform2x3 at: i) ifFalse:[^false]].	^true! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 11/2/1998 19:31'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 19:50'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in"	aTransformation isMatrixTransform2x3 ifFalse:[^super composedWith: aTransformation].	^self composedWithLocal: aTransformation asMatrixTransform2x3 into: self class new! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 23:08'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'm23PrimitiveComposeMatrix'>	matrix _ aTransformation asMatrixTransform2x3.	a11 _ self a11.		b11 _ matrix a11.	a12 _ self a12.		b12 _ matrix a12.	a13 _ self a13.		b13 _ matrix a13.	a21 _ self a21.		b21 _ matrix a21.	a22 _ self a22.		b22 _ matrix a22.	a23 _ self a23.		b23 _ matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/9/1998 13:46'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	<primitive: 'm23PrimitiveInvertPoint'>	^(self invertPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/16/1998 23:46'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a12.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/3/1998 03:04'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'm23PrimitiveTransformPoint'>	^(self transformPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/2/1998 23:09'!transformPoint: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!globalBounds: srcRect toLocal: dstRect	"Transform aRectangle from global coordinates into local coordinates"	<primitive:'m23PrimitiveInvertRectInto'>	^super globalBoundsToLocal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^self globalBounds: aRectangle toLocal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!localBounds: srcRect toGlobal: dstRect	"Transform aRectangle from local coordinates into global coordinates"	<primitive:'m23PrimitiveTransformRectInto'>	^super localBoundsToGlobal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^self localBounds: aRectangle toGlobal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'converting' stamp: 'ar 11/2/1998 15:34'!asMatrixTransform2x3	^self! !!MatrixTransform2x3 methodsFor: 'printing' stamp: 'ar 11/2/1998 23:11'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		cr; print: self a11; tab; print: self a12; tab; print: self a13;		cr; print: self a21; tab; print: self a22; tab; print: self a23;		cr; nextPut:$).! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 16:28'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/15/1998 23:12'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setAngle: angle	"Set the raw rotation angle in the receiver"	| rad s c |	rad := angle degreesToRadians.	s := rad sin.	c := rad cos.	self a11: c.	self a12: s negated.	self a21: s.	self a22: c.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setOffset: aPoint	"Set the raw offset in the receiver"	| pt |	pt _ aPoint asPoint.	self a13: pt x asFloat.	self a23: pt y asFloat.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:16'!setScale: aPoint	"Set the raw scale in the receiver"	| pt |	pt _ aPoint asPoint.	self a11: pt x asFloat.	self a22: pt y asFloat.! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 22:50'!identity	^self new setScale: 1.0! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 7/9/1998 20:09'!new	^self new: 6! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 01:25'!transformFromLocal: localBounds toGlobal: globalBounds	^((self withOffset: (globalBounds center)) composedWithLocal:		(self withScale: (globalBounds extent / localBounds extent) asFloatPoint))			composedWithLocal: (self withOffset: localBounds center negated)"	^(self identity)		setScale: (globalBounds extent / localBounds extent) asFloatPoint;		setOffset: localBounds center negated asFloatPoint;		composedWithGlobal:(self withOffset: globalBounds center asFloatPoint)"! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withAngle: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 02:52'!withOffset: aPoint	^self identity setOffset: aPoint! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:17'!withRotation: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withScale: aPoint	^self new setScale: aPoint! !!MatrixTransformMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 22:21'!asFlexOf: aMorph	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	self addMorph: aMorph.	self computeBounds! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:50'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: self referencePosition color: Color lightGray on: #mouseStillDown send: #changeRotationCenter:with: to: self! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:50'!balloonHelpTextForHandle: aHandle	aHandle eventHandler firstMouseSelector == #changeRotationCenter:with:		ifTrue:[^'set center of rotation'].	^super balloonHelpTextForHandle: aHandle! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!transform	^transform ifNil:[IdentityTransform]! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!transform: aMatrixTransform	transform _ aMatrixTransform.	self computeBounds.! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:52'!visible	extension == nil ifTrue:[^true].	^extension visible! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!visible: aBool	extension == nil ifTrue:[		aBool ifTrue:[^self].		self assureExtension].	extension visible: aBool.! !!MatrixTransformMorph methodsFor: 'submorphs accessing' stamp: 'ar 11/15/1998 21:52'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self visible ifFalse:[^mList].	p _ self transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	(self containsPoint: aPoint) 		ifTrue:[mList addLast: self].	^ mList! !!MatrixTransformMorph methodsFor: 'submorphs accessing' stamp: 'ar 11/15/1998 21:52'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue:[^mList].	self visible ifFalse:[^mList].	p _ self transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	(self containsPoint: aPoint) 		ifTrue:[mList addLast: self].	^ mList! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:17'!boundsChangedFrom: oldBounds to: newBounds	transform ifNil:[transform _ MatrixTransform2x3 identity].	oldBounds extent = newBounds extent ifFalse:[		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withOffset: oldBounds origin negated).		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withScale: newBounds extent / oldBounds extent).		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withOffset: newBounds origin).	].	transform offset: transform offset + (newBounds origin - oldBounds origin)! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:01'!computeBounds	| subBounds |	(submorphs isNil or:[submorphs isEmpty]) ifTrue:[^self].	bounds _ nil.	submorphs do:[:m|		subBounds _ self transform localBoundsToGlobal: m bounds.		bounds 			ifNil:[bounds _ subBounds]			ifNotNil:[bounds _ bounds quickMerge: subBounds].	].	bounds ifNil:[bounds _ 0@0 corner: 20@20].	fullBounds _ bounds.! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:57'!containsPoint: aPoint	self visible ifFalse:[^false].	^bounds containsPoint: aPoint! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!extent: extent	self handleBoundsChange:[super extent: extent]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!fullBounds	| subBounds |	fullBounds ifNil:[		fullBounds _ self bounds.		submorphs do:[:m|			subBounds _ (self transform localBoundsToGlobal: m fullBounds).			fullBounds _ fullBounds quickMerge: subBounds.		].	].	^fullBounds! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!fullContainsPoint: aPoint	| p |	self visible ifFalse:[^false].	(self fullBounds containsPoint: aPoint) ifFalse:[^false].	(self containsPoint: aPoint) ifTrue:[^true].	p _ self transform globalPointToLocal: aPoint.	submorphs do:[:m|		(m fullContainsPoint: p) ifTrue:[^true].	].	^false! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!handleBoundsChange: aBlock	| oldBounds newBounds |	oldBounds _ bounds.	aBlock value.	newBounds _ bounds.	self boundsChangedFrom: oldBounds to: newBounds.! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:53'!position: pos	self handleBoundsChange:[super position: pos]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:14'!privateFullMoveBy: delta	self handleBoundsChange:[super privateMoveBy: delta]! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 11:00'!canvasForSubmorphs: canvasForMe	"Note: canvasForMe is a BalloonCanvas and 	the state of it can be modified in this method"	^canvasForMe transformBy: self transform! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:54'!changed	^super invalidRect: (self fullBounds insetBy: -1)! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:20'!drawOn: aCanvas! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:59'!fullDrawOn: aCanvas	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:[^ self].	(aCanvas isVisible: bounds) ifTrue:[self drawOn: aCanvas].	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		canvasForSubmorphs _ self canvasForSubmorphs: balloonCanvas.		submorphs reverseDo:  "Display submorphs back to front"			[:m | m fullDrawOn: canvasForSubmorphs].  	].! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:54'!invalidRect: rect	owner ifNil:[^self].	^owner invalidRect:(self transform localBoundsToGlobal: rect).! !!MatrixTransformMorph methodsFor: 'events' stamp: 'ar 11/15/1998 21:55'!transformFrom: uberMorph	(owner isNil or:[owner == uberMorph]) ifTrue:[^self transform].	^(owner transformFrom: uberMorph) asMatrixTransform2x3 composedWithLocal: self transform! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:55'!addFlexShell	"No flex shell necessary"	self lastRotationDegrees: 0.0.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:19'!changeRotationCenter: evt with: rotHandle	| pos |	pos _ evt cursorPoint.	rotHandle referencePosition: pos.	self referencePosition: pos.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:55'!hasNoScaleOrRotation	^true! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!isFlexMorph	^false! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!lastRotationDegrees	^(self valueOfProperty: #lastRotationDegrees) ifNil:[0.0].! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!lastRotationDegrees: deg	deg = 0.0 		ifTrue:[self removeProperty: #lastRotationDegrees]		ifFalse:[self setProperty: #lastRotationDegrees toValue: deg]! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:20'!referencePosition	| refPos |	refPos _ self valueOfProperty: #referencePosition.	refPos ifNil:[refPos _ self transform globalPointToLocal: super referencePosition].	^self transformFromWorld localPointToGlobal: refPos! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:18'!referencePosition: pos	self setProperty: #referencePosition toValue: 		(self transformFromWorld globalPointToLocal: pos)! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!removeFlexShell	"Do nothing"! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:14'!rotateBy: delta	| pt m |	delta = 0.0 ifTrue:[^self].	self changed.	pt _ self transformFromWorld globalPointToLocal: self referencePosition.	m _ MatrixTransform2x3 withOffset: pt.	m _ m composedWithLocal: (MatrixTransform2x3 withAngle: delta).	m _ m composedWithLocal: (MatrixTransform2x3 withOffset: pt negated).	transform _ self transform composedWithLocal: m.	self computeBounds.	self changed.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!rotationDegrees: degrees	| last delta |	last _ self lastRotationDegrees.	delta _ degrees - last.	self rotateBy: delta.	self lastRotationDegrees: degrees.! !!MatrixTransformMorph class methodsFor: 'class initialization' stamp: 'ar 11/15/1998 22:09'!initialize	"MatrixTransformMorph initialize"	IdentityTransform _ MatrixTransform2x3 identity.! !!MenuItemMorph methodsFor: 'drawing' stamp: 'di 1/14/1999 20:29'!drawOn: aCanvas	| selectionColor |	selectionColor _ Display depth <= 2						ifTrue: [Color gray]						ifFalse: [owner color darker].	(isSelected & isEnabled) ifTrue: [		aCanvas fillRectangle: self bounds color: selectionColor].	super drawOn: aCanvas.	subMenu == nil ifFalse: [		aCanvas			image: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))].! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 6/15/1998 12:18'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self boundsInWorld containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:])			ifFalse: [owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				evt hand world displayWorld.				owner invokeItem: self]]].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 8/8/1998 09:22'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAdjacentTo: (Array with: self bounds topRight + (10@0)									with: self bounds topLeft)			forHand: aHand			from: self].! !!MenuItemMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:54'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!MenuItemMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 07:40'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.isInTransition _ isInTransition veryDeepCopyWith: deepCopier.isEnabled _ isEnabled veryDeepCopyWith: deepCopier.subMenu _ subMenu veryDeepCopyWith: deepCopier.isSelected _ isSelected veryDeepCopyWith: deepCopier."target _ target.		Weakly copied""selector _ selector.		a Symbol"arguments _ arguments.		"All weakly copied"! !!MenuLineMorph methodsFor: 'drawing' stamp: 'sw 11/3/1998 11:35'!drawOn: aCanvas	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: Preferences menuLineUpperColor.	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: Preferences menuLineLowerColor! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:25'!initialize	super initialize.	self setDefaultParameters.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:19'!setDefaultParameters	self setColor: Preferences menuColor borderWidth: Preferences menuBorderWidth borderColor: Preferences menuBorderColor.	inset _ 3! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:23'!setTitleParametersFor: aMenuTitle	aMenuTitle setColor: Preferences menuTitleColor borderWidth: Preferences menuTitleBorderWidth borderColor: Preferences menuTitleBorderColor! !!MenuMorph methodsFor: 'construction' stamp: 'di 9/22/1998 20:29'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'keep this menu up'		target: self		selector: #toggleStayUp:		argumentList: EmptyArray.	self addLine! !!MenuMorph methodsFor: 'construction' stamp: 'sw 10/9/1998 16:00'!addTitle: aString	"Add a title line at the top of this menu."	| title |	title _ AlignmentMorph new.	self setTitleParametersFor: title.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	(aString asString findTokens: String cr) do:		[:line | title addMorphBack: (StringMorph new contents: line)].	self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/5/1998 21:13'!balloonTextForLastItem: balloonText	submorphs last setBalloonText: balloonText! !!MenuMorph methodsFor: 'construction' stamp: 'di 8/20/1998 09:30'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:26'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:27'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:26'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect:		 [:each | each == lastSelection] ifNone: [self items first].	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].! !!MenuMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:37'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.defaultTarget _ deepCopier references at: defaultTarget ifAbsent: [defaultTarget].popUpOwner _ deepCopier references at: popUpOwner ifAbsent: [popUpOwner].! !!MenuMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 07:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."defaultTarget _ defaultTarget.		Weakly copied"lastSelection _ lastSelection veryDeepCopyWith: deepCopier.stayUp _ stayUp veryDeepCopyWith: deepCopier.originalEvent _ originalEvent veryDeepCopyWith: deepCopier.popUpOwner _ popUpOwner.		"Weakly copied"! !I represent the messages file of a mail database. This file is treated as (mostly) append-only. All new messages or edited messages are appended to the end of this file.Messages are stored as ASCII text with seperator strings and some additional information between each message. If necessary, this file can be inspected or edited with a text editor; after editing, the index file should be recreated using the "compact" command. (This is necessary because the offsets kept in the index file will probably be different after the edits.)When a message is deleted, its delimiter is changed to mark it as deleted, but it is left in the mail file until the next time "compact" command is executed. Generally, the reduction in disk fragmentation resulting from keeping the messages in a single file more than offsets the temporary space lost by having a few deleted messages hanging around between compactions. Compaction is done into a new copy of the file, followed by a renaming operation. Thus, if compaction fails, the original messages file will not be lost.!!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:26'!close	"Close the file."	file ifNil: [^ self].	file		ensureOpen;		setToEnd;		close.	file _ nil.! !!MessageFile methodsFor: 'file operations'!delete	"I must close my file handle before the file can be deleted."	self close.	super delete.! !!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:30'!ensureFileIsOpen	"Make sure that my file is open. The file is automatically closed on snapshots."	file		ifNil: [file _ FileStream fileNamed: filename]		ifNotNil: [file ensureOpen].! !!MessageFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself for the message file with the given name."	filename _ aFileName.	file _ nil.	self ensureFileIsOpen.! !!MessageFile methodsFor: 'file operations'!rename: newFileName	"I must close my file handle before the file can be renamed."	self close.	super rename: newFileName.! !!MessageFile methodsFor: 'file operations' stamp: 'di 9/29/1998 16:01'!save	"Make sure the message file is flushed to disk. This is NOT atomic because MessageFiles can get large and there might not be enough disk space to save them atomically. Besides, it would be very slow."	file ifNil: [^ self].	file ensureOpen.	file closed  "Will still be closed if no file present"		ifFalse: [file setToEnd; close; reopen].! !!MessageFile methodsFor: 'message operations'!append: messageText id: messageID	"Append the given message text with the given unique identifier. Answer the new location of the message."	| location |	self beginAppend.	location _ self basicAppend: messageText id: messageID.	self endAppend.	^location! !!MessageFile methodsFor: 'message operations'!assertValidMessageAt: filePosition id: msgID	"Verify that the given filePosition is, indeed, the start of a message (possibly deleted) with the given ID and raise an error if this assertion is false."	| delimiter fileMsgID |	"assume file is open"	file position: filePosition.	delimiter _ file next: 10.	((delimiter = '&&&&&start') or: [delimiter = '&&&&&XXXXX']) ifFalse:		[^self reportInconsistency].	file next. "skip cr"	fileMsgID _ MailDB readIntegerLineFrom: file.	(msgID = fileMsgID) ifFalse:		[^self reportInconsistency].! !!MessageFile methodsFor: 'message operations'!basicAppend: messageText id: messageID	"Append the given message text with the given message ID. Answer the new location of the message."	"WARNING: This operation assumes:		1. the sender positioned the stream to the end of the file (using beginAppend), and		2. the sender will do an endAppend operation after all messages are appended to flush all file buffers to disk."	| location |	file setToEnd.	location _ file position.	file nextPutAll: '&&&&&start'.	"message delimiter"	file cr.	messageID printOn: file.		"message ID"	file cr.	file nextPutAll: messageText.	^location! !!MessageFile methodsFor: 'message operations'!beginAppend	"Set the file to the end prior to performing a sequence of basicAppend operations."	self ensureFileIsOpen.	file setToEnd.! !!MessageFile methodsFor: 'message operations'!deleteMessageAt: filePosition id: msgID	"Mark as deleted the message with the given ID located at the given file position."	self ensureFileIsOpen.	self assertValidMessageAt: filePosition id: msgID.	file position: filePosition.	file nextPutAll: '&&&&&XXXXX'.		"delimiter for deleted messages"	file flush.! !!MessageFile methodsFor: 'message operations'!endAppend	"Complete an append transaction by flushing the file to disk."	self save.! !!MessageFile methodsFor: 'message operations'!getMessage: msgID at: start textLength: textSize	"Retrieve the message with the given ID, location, and text size."	self ensureFileIsOpen.	self assertValidMessageAt: start id: msgID.	^file next: textSize! !!MessageFile methodsFor: 'message operations'!update: messageText at: oldMessagePosition id: msgID	"Atomically update the message having the old location and ID with the given new text (e.g. when the user has edited a message). Answer the new location of the message."	| newLocation |	newLocation _ self append: messageText id: msgID.	self deleteMessageAt: oldMessagePosition id: msgID.	^newLocation! !!MessageFile methodsFor: 'scanning'!messagesDo: aBlock	"Scan the message file and invoke the given block for each message in it. The block arguments are:	deleted			true if this message is marked deleted	msgID			the message ID	msgBody			the message textThis operation is very expensive."	| more deleted msgID textStart textSize msgBody |	self ensureFileIsOpen.	file position: 0.	more _ self scanToNextMessageIn: file.	[more] whileTrue:		[deleted _								"deleted"			(MailDB readStringLineFrom: file) = '&&&&&XXXXX'.		 msgID _ MailDB readIntegerLineFrom: file.	"msgID"		 textStart _ file position.		 more _ self scanToNextMessageIn: file.		 textSize _ file position - textStart.		 file position: textStart.		 msgBody _ file next: textSize.				"msgBody"		 aBlock valueWithArguments:			(Array				with: deleted				with: msgID				with: msgBody)].! !!MessageFile methodsFor: 'scanning'!scanToNextAndSigns: aStream	"Scan the given stream for a pair of and-sign (&) characters and answer true if they are found before the end of the stream is reached. The stream is left positioned after the second and-sign or at the end of the stream."	| ch |	[true] whileTrue:		[ch _ aStream next.		 ((ch == $&) and:		   [aStream next == $&]) ifTrue: [^true].	"found"		 (ch == nil) ifTrue: [^false]].	"end of file"! !!MessageFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message. Answer true if we find a message delimiter, false if we hit the end of the file first. The stream is left positioned at the start of the next message (at the message delimiter) or at the end of the stream."	| delimiter |	[self scanToNextAndSigns: aStream] whileTrue:		[delimiter _ aStream next: 8.		 ((delimiter = '&&&start') or: [delimiter = '&&&XXXXX'])			ifTrue: [aStream skip: -10. ^true]			ifFalse: [(delimiter includes: $&) ifTrue: [aStream skip: -8]]].	^false	"end of file"! !!MessageSet methodsFor: 'message list' stamp: 'di 9/21/1998 23:04'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'message list' stamp: 'wod 6/16/1998 15:08'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'contents' stamp: 'di 6/26/1998 09:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 12:23'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView |	World ifNotNil: [^ self openAsMorph: aMessageSet name: aString].	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/19/1998 13:51'!openAsMorph: aMessageSet name: labelString 	"Create a SystemWindow aMessageSet, with the label labelString, in a Morphic project"	^ self openAsMorph: aMessageSet name: labelString inWorld: World! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 17:05'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph |	self flag: #newBrowsers.	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 extent: 1@0.2).	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.2 corner: 1@1).	window openInWorld: aWorld! !My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.[Subtle detail] A class is know by name to an environment.  Typically this is the SystemDictionary named Smalltalk.  If we ever make lightweight classes that are not in Smalltalk, they must be in some environment.  Specifically, the code that sets 'wasPresent' in name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed: must continue to work.!!Metaclass methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				weak: false				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'initialize-release' stamp: 'tk 8/22/1998 07:45'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. oldClass is a metaclass, so we know there is just one instance.  Permute variables as necessary."	| oldInstVarNames map variable new instSize oldInstances |	oldClass soleInstance == nil ifTrue: [^self].	"no instances to convert"	oldInstVarNames _ oldClass allInstVarNames.	map _ self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].	variable _ self isVariable.	instSize _ self instSize.	"Now perform a bulk mutation of old instances into new ones"	oldInstances _ Array with: oldClass soleInstance.	oldInstances elementsExchangeIdentityWith:		(oldInstances collect: 		[:old | 		variable			ifTrue: [new _ self basicNew: old basicSize]			ifFalse: [new _ self basicNew].		1 to: instSize do: 			[:offset |  (map at: offset) > 0 ifTrue:				[new instVarAt: offset						put: (old instVarAt: (map at: offset))]].		variable 			ifTrue: [1 to: old basicSize do: 						[:offset |						new basicAt: offset put: (old basicAt: offset)]].		new])! !!Metaclass methodsFor: 'accessing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!Metaclass methodsFor: 'copying' stamp: 'tk 8/19/1998 16:16'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 10/7/1998 14:14'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	self flag: #obsolete.	^self 		name: newName 		inEnvironment: environ 		subclassOf: sup 		instanceVariableNames: instVarString 		variable: v 		words: w 		pointers: p 		weak: false		classVariableNames: classVarString 		poolDictionaries: poolString 		category: categoryName 		comment: commentString 		changed: changed ! !!Metaclass methodsFor: 'class hierarchy' stamp: 'di 11/9/1998 20:18'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName].			(oldClass checkForInstVarsOK: instVarString)				ifFalse: [^ false]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !!MethodContext methodsFor: 'initialize-release' stamp: 'di 1/11/1999 10:24'!restart	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	self stackp: method numTemps! !!MethodContext methodsFor: 'private' stamp: 'di 1/14/1999 22:30'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!MethodContext methodsFor: 'private' stamp: 'di 1/11/1999 10:23'!setSender: s receiver: r method: m arguments: args 	"Create the receiver's initial state."	sender _ s.	receiver _ r.	method _ m.	pc _ method initialPC.	self stackp: method numTemps.	1 to: args size do: [:i | self at: i put: (args at: i)]! !!MethodContext class methodsFor: 'instance creation' stamp: 'di 1/14/1999 22:06'!basicNew: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super basicNew: CompiledMethod fullFrameSize! !!MethodContext class methodsFor: 'instance creation' stamp: 'di 1/11/1999 22:20'!new	^ super new: CompiledMethod fullFrameSize! !!MethodContext class methodsFor: 'instance creation' stamp: 'di 1/11/1999 22:42'!new: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super new: CompiledMethod fullFrameSize! !!MethodDictionary methodsFor: 'enumeration' stamp: 'SqR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 11/27/1998 02:14'!keyValueDo: aBlock 	"Faster associationsDo:. SqR!! 11/27/1998 02:14"	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: key value: (array at: i)]		]! !!MethodNode methodsFor: 'code generation' stamp: 'di 12/26/1998 21:35'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	encoder maxTemp > 31		ifTrue: [^self error: 'Too many temporary variables'].		literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'printing' stamp: 'di 12/4/1998 14:29'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing' stamp: 'ar 11/5/1998 17:42'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ encoder literals at: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>.! !I am the user interface for a simple software MIDI synthesizer that is driven by external MIDI input. I come with controls for a single MIDI channel (channel 1), but allow channel controls for additional MIDI channels to be added by the user. The volume, pan, and instrument of each channel can be controlled independently.!!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 20:05'!addChannel	"Add a set of controls for another channel. Prompt the user for the channel number."	| menu existingChannels newChannel |	menu _ CustomMenu new.	existingChannels _ Set new.	1 to: 16 do: [:ch | (instrumentSelector at: ch) ifNotNil: [existingChannels add: ch]].	1 to: 16 do: [:ch |		(existingChannels includes: ch) ifFalse: [			menu add: ch printString action: ch]].	newChannel _ menu startUp.	newChannel ifNotNil: [self addChannelControlsFor: newChannel].! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 19:59'!addChannelControlsFor: channelIndex	| r divider col |	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	r addMorphBack: (self channelNumAndMuteButtonFor: channelIndex).	r addMorphBack: (Morph new extent: 10@5; color: color).  "spacer"	r addMorphBack: (self panAndVolControlsFor: channelIndex).	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	col _ self lastSubmorph.	col addMorphBack: divider.	col addMorphBack: r.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 19:58'!atChannel: channelIndex from: aPopUpChoice selectInstrument: selection	| oldSnd name snd instSelector |	oldSnd _ midiSynth instrumentForChannel: channelIndex.	(selection beginsWith: 'edit ') ifTrue: [		name _ selection copyFrom: 6 to: selection size.		aPopUpChoice contentsClipped: name.		(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd title: name].		(oldSnd isKindOf: SampledInstrument) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].		^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((channelIndex ~= i) and:		 [(instSelector _ instrumentSelector at: i) notNil and:		 [selection = instSelector contents]])			ifTrue: [snd _ midiSynth instrumentForChannel: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	midiSynth instrumentForChannel: channelIndex put: snd.	(instrumentSelector at: channelIndex) contentsClipped: selection.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 08:19'!channelNumAndMuteButtonFor: channelIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: midiSynth;		actionSelector: #mutedForChannel:put:;		arguments: (Array with: channelIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atChannel:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForChannel:;		getItemsArgs: (Array with: channelIndex).	instSelector arguments:		(Array with: channelIndex with: instSelector).	instrumentSelector at: channelIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: channelIndex printString			font: (TextStyle default fontOfSize: 24)).	channelIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/13/1999 07:33'!closeMIDIPort	midiSynth isOn ifTrue: [midiSynth stopMIDITracking].	midiSynth closeMIDIPort.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 07:55'!disableReverb: aBoolean	aBoolean		ifTrue: [SoundPlayer stopReverb]		ifFalse: [SoundPlayer startReverb].! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 19:51'!initialize	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 3.	color _ Color veryLightGray.	self borderWidth: 2.	midiPortNumber _ nil.	midiSynth _ MIDISynth new.	instrumentSelector _ Array new: 16.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack:		(AlignmentMorph newColumn color: color; inset: 0).	self addChannelControlsFor: 1.	self extent: 20@20.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 10:20'!instrumentChoicesForChannel: channelIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	names add: 'edit ', (instrumentSelector at: channelIndex) contents.	^ names asArray! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/13/1999 07:47'!invokeMenu	"Invoke a menu of additonal commands."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'add channel' action: #addChannel.	aMenu add: 'reload instruments' action: #updateInstrumentsFromLibrary.	midiSynth isOn ifFalse: [		aMenu add: 'set MIDI port' action: #setMIDIPort.		midiSynth midiPort			ifNotNil: [aMenu add: 'close MIDI port' action: #closeMIDIPort]].		aMenu invokeOn: self defaultSelection: nil.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 07:55'!makeControls	| b r reverbSwitch onOffSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (		b fullCopy			label: '<>';			actWhen: #buttonDown;			actionSelector: #invokeMenu).	onOffSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'On';		actionSelector: #toggleOnOff;		target: self;		setSwitchState: false.	r addMorphBack: onOffSwitch.	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: self;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	^ r! !!MidiInputMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:11'!makeRow	^ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 08:03'!panAndVolControlsFor: channelIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: midiSynth;		arguments: (Array with: channelIndex);		actionSelector: #volumeForChannel:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (midiSynth volumeForChannel: channelIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForChannel:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (midiSynth panForChannel: channelIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/13/1999 07:59'!setMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	midiPortNumber _ portNum.! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/13/1999 07:23'!toggleOnOff	midiSynth isOn		ifTrue: [			midiSynth stopMIDITracking]		ifFalse: [			midiPortNumber ifNil: [self setMIDIPort].			midiPortNumber ifNil: [midiPortNumber _ 0].			midiSynth midiPort: (SimpleMIDIPort openOnPortNumber: midiPortNumber).			midiSynth startMIDITracking].! !!MidiInputMorph methodsFor: 'all' stamp: 'jm 1/6/1999 08:17'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		midiSynth instrumentForChannel: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur max: snd duration].	^ dur! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/10/1999 08:45'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	super stopGracefully.	sounds do: [:s | s stopGracefully].! !A morph (from the Greek "shape" or "form") is an interactive graphical object.All morphs owned by a morph are held in submorphs.  All coordinates are global screen coordinates.  (Except those that are flexed, contained inside a FlexMorph.)All show unless they are 'hidden'.  Hidden morphs: are still in submorphs have a position of about 1000000@100000 have a property #relPos that is its relative position inside its owner. has a property #hidden set to true. when fullBounds of a morph is computed, don't include morphs that have the property hidden = true. "Stop" must not move hidden morphs back onto the playfield (PasteUpMorph)!!Morph methodsFor: 'initialization' stamp: 'di 8/10/1998 13:08'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.! !!Morph methodsFor: 'initialization' stamp: 'jm 7/5/1998 12:40'!openInMVC	MorphWorldView		openWorldWith: self		labelled: self defaultLabelForInspector.! !!Morph methodsFor: 'initialization' stamp: 'sw 10/9/1998 08:41'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	self openInWorld: World! !!Morph methodsFor: 'initialization' stamp: 'sw 10/9/1998 08:40'!openInWorld: aWorld	"Add this morph to the requested World."	aWorld addMorph: self.	aWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'initialization' stamp: 'sw 9/11/1998 11:13'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	(aPresenter _ self presenter) ifNil: [^ nil].	^ (pal _ aPresenter ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner _ aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'classification' stamp: 'ar 8/10/1998 18:50'!isFlashMorph	^false! !!Morph methodsFor: 'accessing' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state _ self actorStateOrNil.	state ifNil:		[state _ ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:05'!actorState: anActorState	extension == nil ifTrue: [self assureExtension].	extension actorState: anActorState! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:06'!actorStateOrNil	extension == nil ifTrue: [^ nil].	^ extension actorState! !!Morph methodsFor: 'accessing' stamp: 'sw 8/19/1998 11:55'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(maybeDoDup:with:			'Duplicate')		(doGrab:with:				'Pick up')		(startDrag:with:				'Move')		(doMenu:with:				'Menu')		(doDebug:with:				'Debug')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'accessing' stamp: 'sw 11/9/1998 18:44'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ (ScriptingSystem helpStringFor: val) withNoLineLongerThan: Preferences maxBalloonHelpLineLength].	^ nil! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!balloonTextSelector: aSelector	extension == nil ifTrue: [self assureExtension].	extension balloonTextSelector: aSelector! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!beSticky	extension == nil ifTrue: [self assureExtension].	extension sticky: true! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler	extension == nil ifTrue: [^ nil].	^ extension eventHandler! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "	extension == nil ifTrue: [self assureExtension].	extension eventHandler: anEventHandler! !!Morph methodsFor: 'accessing' stamp: 'tk 7/31/1998 13:47'!forwardDirection	"Default implementation."	^ 0.0! !!Morph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:25'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	^ color isColor and: [color isTranslucentColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:47'!highlightColor		| val |	^ (val _ self valueOfProperty: #highlightColor)		ifNotNil:			[val]		ifNil:			[owner highlightColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!highlightColor: aColor	self setProperty: #highlightColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:09'!isLocked	extension == nil ifTrue: [^ false].	^ extension locked! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!isSticky	extension == nil ifTrue: [^ false].	^ extension sticky! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!lock: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension locked: aBoolean! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player	extension == nil ifTrue: [^ nil].	^ extension player! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player: anObject	extension == nil ifTrue: [self assureExtension].	extension player: anObject! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:48'!regularColor		| val |	^ (val _ self valueOfProperty: #regularColor)		ifNotNil:			[val]		ifNil:			[owner regularColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!regularColor: aColor	self setProperty: #regularColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:06'!sqkPage	^ self valueOfProperty: #SqueakPage! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:12'!toggleStickiness	extension == nil ifTrue: [^ self beSticky].	extension sticky: extension sticky not! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 12:33'!unlock	self lock: false! !!Morph methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:08'!url	"If I have been assigned a url, return it.  For PasteUpMorphs mostly."	| sq |	(sq _ self sqkPage) ifNotNil: [^ sq url].	^ nil		! !!Morph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:54'!userString	"Do I have a text string to be searched on?"	^ nil! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:09'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	extension == nil ifTrue: [^ false].	^ extension hasProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/16/1998 11:13'!removeProperty: propName	extension == nil ifTrue: [^ self].	extension removeProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:12'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].	extension == nil ifTrue: [self assureExtension].	extension setProperty: propName toValue: aValue! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName	extension == nil ifTrue: [^ nil].	^ extension valueOfProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName ifAbsent: aBlock	extension == nil ifTrue: [^ aBlock value].	^ extension valueOfProperty: propName ifAbsent: aBlock! !!Morph methodsFor: 'copying' stamp: 'di 8/11/1998 22:13'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].	extension == nil ifFalse: [extension updateReferencesUsing: aDictionary]! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:55'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutPlayer here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'copying' stamp: 'tk 1/6/1999 17:27'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  See veryDeepInner:, veryDeepFixupWith:"	self prepareToBeSaved.	^ super veryDeepCopyWith: deepCopier! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:56'!veryDeepCopyWithoutPlayer	| hold copy holdState |	hold _ self player.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	self player: nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self player: hold.	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'copying' stamp: 'tk 1/7/1999 12:32'!veryDeepFixupWith: deepCopier	"If some fields were weakly copied, fix new copy here.""super veryDeepFixupWith: deepCopier.""My owner should already have been fixed up."! !!Morph methodsFor: 'copying' stamp: 'tk 1/7/1999 12:30'!veryDeepInner: deepCopier	"The inner loop, so it can be overridden when a field should not be traced."	"super veryDeepInner: deepCopier.	know Object has no inst vars"	bounds _ bounds clone.	"Points are shared with original"	"owner _ owner.	special, see veryDeepFixupWith:"	submorphs _ submorphs veryDeepCopyWith: deepCopier.	self submorphsDo: [:mySub | mySub privateOwner: self].		"I am the owner!!"		"My owner field:  If owner is in tree being copied, he will set it.  		If not, if I am top object, caller will addMorph: me to another morph.			if I am not in the submorph tree, I should not be copied.  The field I			am in needs to be weakly copied."	"fullBounds _ fullBounds.	fullBounds is shared with original!!"	color _ color veryDeepCopyWith: deepCopier.		"color, if simple, will return self. may be complex"	extension _ extension veryDeepCopyWith: deepCopier.		"extension is treated like any generic inst var"! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:45'!ownerThatIsAHandOrA: aClass	"Return the first enclosing morph that is either a HandMorph or a kind of aClass, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[((current isKindOf: aClass) or: [current isHandMorph]) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:46'!owningHandOrPasteUpMorph	"Answer the closest containing morph that is a Hand or a PasteUp morph"	^ self ownerThatIsAHandOrA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 18:02'!pasteUpMorph	"Answer the closest containing morph that is a PasteUp morph"	^ self ownerThatIsA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 8/30/1998 09:47'!topPasteUp	"If the receiver is in a world, return that; otherwise return the outermost pasteup morph"	^ self outermostMorphThat: [:m | m isKindOf: PasteUpMorph]! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 12:15'!world	^ owner ifNil: [nil] ifNotNil: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 17:11'!hasSubmorphWithProperty: aSymbol	submorphs detect: [:m | m hasProperty: aSymbol] ifNone: [^ false].	^ true! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 18:47'!submorphWithProperty: aSymbol	^ submorphs detect: [:aMorph | aMorph hasProperty: aSymbol] ifNone: [nil]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'tk 12/15/1998 14:23'!abandon	"Like delete, but we really intend not to use this morph again.  Clean up a few things."	self delete! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/29/1998 15:39'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp	self addMorphFront: aMorph.	aMorph position: (self transformFromWorld globalPointToLocal: wp)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 6/17/1998 16:04'!addMorphNearBack: aMorph	| bg |	(submorphs size > 0 and: [submorphs last mustBeBackmost]) ifTrue:		[bg _ submorphs last.		bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 8/13/1998 10:09'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[(extension == nil or: [self player == nil])		ifTrue: [owner privateRemoveMorph: self.				owner _ nil]		ifFalse: ["Player must be notified"				aWorld _ self world.				owner privateRemoveMorph: self.				owner _ nil.				self player noteDeletionOf: self fromWorld: aWorld]		].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 7/3/1998 11:02'!deleteSubmorphsWithProperty: aSymbol	submorphs copy do:		[:m | (m hasProperty: aSymbol) ifTrue: [m delete]]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 8/20/1998 17:32'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	newMorph arrangeToStartStepping! !!Morph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:10'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:09'!canvasForSubmorphs: canvasForMe	"Provide a canvas for drawing my submorphs.  This may be overridden	to provide for clipping and other related behavior."	^ canvasForMe! !!Morph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:33'!doesOwnRotation	"Some morphs don't want to TransformMorph to rotate their images, but we do"	^ false! !!Morph methodsFor: 'drawing' stamp: 'di 11/10/1998 10:15'!flash	| c w |	c _ self color.	self color: Color black.	(w _ self world) ifNotNil: [w doOneCycle].	self color: c! !!Morph methodsFor: 'drawing' stamp: 'tk 12/15/1998 14:04'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		submorphs size > 0 ifTrue: [			submorphs do: [:m | (m visible)					ifTrue: [fullBounds _ fullBounds quickMerge: m fullBounds]]]].	^ fullBounds! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:28'!fullDrawOn: aCanvas	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'drawing' stamp: 'di 1/4/1999 10:57'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	self visible ifFalse: [^ false].	(aCanvas isVisible: self fullBounds) ifFalse: [^ false].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		["draw back-to-front"		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere)								ifTrue: [^ true]]]].  	^ false! !!Morph methodsFor: 'drawing' stamp: 'sw 10/30/1998 18:27'!hide	owner ifNil: [^ self].	self visible ifTrue: [self visible: false.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:43'!imageForm: depth forRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent depth: depth.	self fullDrawOn: (canvas copyOffset: rect topLeft negated).	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:42'!imageFormDepth: depth	^ self imageForm: depth forRectangle: self fullBounds! !!Morph methodsFor: 'drawing' stamp: 'di 9/9/1998 22:25'!imageFormForRectangle: rect	^ self imageForm: Display depth forRectangle: rect! !!Morph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:53'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect hitStop |	rect _ self fullBounds.	canvas _ FormCanvas extent: rect extent depth: Display depth.	hitStop _ self fullDrawOn: (canvas copyOffset: rect topLeft negated)					without: stopMorph andStopThere: stopThere.	^ Array with: (canvas form offset: rect topLeft)			with: hitStop! !!Morph methodsFor: 'drawing' stamp: 'di 9/10/1998 12:29'!shadowForm	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fullDrawOn: canvas.	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:29'!show	"Make sure this morph is on-stage."	self visible ifFalse: [self visible: true.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'sw 10/19/1998 22:21'!visible	extension ifNil: [^ true].	^ extension visible! !!Morph methodsFor: 'drawing' stamp: 'sw 10/20/1998 00:28'!visible: aBoolean	extension ifNil: [aBoolean ifTrue: [^ self]].	self visible == aBoolean ifTrue: [^ self].	self assuredExtension visible: aBoolean.	self changed! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!bottomLeft: aPoint	self bottom: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:08'!bottomRight: aPoint	self bottom: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) localBoundsToGlobal: bounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) localBoundsToGlobal: self fullBounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:43'!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) localPointToGlobal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 12:11'!positionInWorld	^ self pointInWorld: self position.! !!Morph methodsFor: 'geometry' stamp: 'sw 10/9/1998 08:56'!positionSubmorphs	self submorphsDo:		[:aMorph | aMorph snapToEdgeIfAppropriate]! !!Morph methodsFor: 'geometry' stamp: 'di 1/4/1999 20:07'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta boundingMorph |	trialRect _ aPoint extent: self bounds extent.	boundingMorph _ self nearestOwnerThat:		[:o | (o isKindOf: DropShadowMorph) not].		" -- would be nice to just use topRendererOrSelf, but making			DropShadows respond to isRenderer makes them hard to select."	delta _ boundingMorph			ifNil:    [aPoint]			ifNotNil: [trialRect amountToTranslateWithin: boundingMorph bounds].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!topLeft: aPoint	self top: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:29'!topRight: aPoint	self top: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/15/1998 22:19'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ self newTransformationMorph asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^false! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/15/1998 22:19'!newTransformationMorph	^TransformationMorph new! !!Morph methodsFor: 'geometry testing' stamp: 'di 10/4/1998 20:53'!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"	submorphs do: [:m |		m allMorphsDo: [:n |			(n fullContainsPoint: aPoint) ifTrue: [^ true]]].	^ false! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:00'!addTransparentSpacerOfSize: aPoint	self addMorphBack: (self transparentSpacerOfSize: aPoint)! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:01'!beTransparent	self color: Color transparent! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:10'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map patchBelowMe tfm morphAsFlexed i1 |	"Make a mask with black where sensitiveColor is, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	myImage _ morphAsFlexed imageForm offset: 0@0.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ Bitmap new: (1 bitShift: (myImage depth min: 15)).	map at: (i1 _ sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form at: 0@0 colorMap: map.	"get an image of the world below me"	patchBelowMe _ self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false."sensitivePixelMask displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: i1 put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: patchBelowMe boundingBox		from: patchBelowMe at: 0@0 clippingBox: patchBelowMe boundingBox		rule: Form and fillColor: nil map: map."sensitivePixelMask displayAt: 200@0."	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/9/1998 22:49'!colorUnder	"Return the color of under the receiver's center."	self isInWorld		ifTrue: [^ self world colorAt: (self pointInWorld: self referencePosition) belowMorph: self]		ifFalse: [^ Color black].! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 12/15/1998 14:03'!goHome	| box |	(owner isInMemory and: [owner ~~ nil]) ifTrue: [		self visible ifTrue: [			box _ owner.			self left < box left ifTrue: [self position: box left@self position y].			self right > box right ifTrue: [self position: (box right - self width)@self position y].			self top < box top ifTrue: [self position: self position x@box top].			self bottom > box bottom ifTrue: [				self position: self position x@(box bottom - self height)]]].! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:54'!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm tfm morphAsFlexed |	"Make a sahdow mask with black in my shape, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	shadowForm _ morphAsFlexed shadowForm offset: 0@0.	"get an image of the world below me"	patchBelowMe _ (self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false) offset: 0@0."shadowForm displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map."shadowForm displayAt: 200@0."	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 11:50'!transparentSpacerOfSize: aPoint	^ (Morph new extent: aPoint) color: Color transparent! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/8/1998 23:47'!wrap	| myBox box newX newY wrapped |	owner ifNil: [^ self].	myBox _ self fullBounds.	myBox corner < (50000@50000) ifFalse: [		self inform: 'Who is trying to wrap a hidden object?'. ^ self].	box _ owner bounds.	newX _ self position x.	newY _ self position y.	wrapped _ false.	((myBox right < box left) or: [myBox left > box right]) ifTrue: [		newX _ box left + ((self position x - box left) \\ box width).		wrapped _ true].	((myBox bottom < box top) or: [myBox top > box bottom]) ifTrue: [		newY _ box top + ((self position y - box top) \\ box height).		wrapped _ true].	self position: newX@newY.	(wrapped and: [owner isPlayfieldLike])		ifTrue: [owner changed].  "redraw all turtle trails if wrapped"! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 14:35'!newThumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new height: aHeight; morphRepresented: self! !!Morph methodsFor: 'thumbnail' stamp: 'sw 12/21/1998 14:20'!representativeNoTallerThan: maxHeight norWiderThan: maxWidth thumbnailHeight: thumbnailHeight	"Return a morph representing the receiver but which is no taller than aHeight.  If the receiver is already small enough, just return it, else return a MorphThumbnail companioned to the receiver, enforcing the maxWidth"	(self height <= maxHeight and: [self width <= maxWidth]) ifTrue: [^ self].	^ MorphThumbnail new extent: maxWidth @ (thumbnailHeight min: self height); morphRepresented: self! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 15:40'!thumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new extent: aHeight @ aHeight; morphRepresented: self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 08:21'!aboutToBeGrabbedBy: aHand	| extentToHandToHand |	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!closeDragAndDrop	self setProperty: #openToDragAndDrop toValue: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/30/1998 16:22'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow |	self isPartsDonor: false.	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	self isInWorld ifTrue:		[self world startSteppingSubmorphsOf: self]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!openDragAndDrop	self setProperty: #openToDragAndDrop toValue: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 1/11/1999 20:07'!repelsMorph: aMorph event: ev	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 17:02'!rootForGrabOf: aMorph	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 12:34'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	owner privateRemoveMorph: self.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 16:29'!substituteForMorph: aMorph beingDroppedOn: aPage	"Allows a morph that is one level above aPage in the containment hierarchy to have a say on which morph should be dropped"	^ nil ! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 8/4/1998 18:41'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld origin startPoint endPoint aPresenter |	aForm _ self imageForm offset: 0@0.	aPresenter _ self presenter.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition + origin.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	aPresenter soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:43'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^ (self valueOfProperty: #openToDragAndDrop) == true! !!Morph methodsFor: 'event handling' stamp: 'sw 7/3/1998 16:45'!cursorPoint	"A convenience"	^ self primaryHand lastEvent cursorPoint! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOverDragging: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:00'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:33'!mouseEnterDragging: evt	"Handle a mouseEnterDragging event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs.  The default response is to let my eventHandler, if any, handle it, or else to do nothing."	self eventHandler ifNotNil:		[^ self eventHandler mouseEnterDragging: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:38'!mouseLeaveDragging: evt	"Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it; else to do nothing."	self eventHandler ifNotNil:		[self eventHandler mouseLeaveDragging: evt fromMorph: self]! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!on: eventName send: selector to: recipient	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!removeLink: actionCode	self eventHandler ifNotNil:		[self eventHandler on: actionCode send: nil to: nil]! !!Morph methodsFor: 'event handling' stamp: 'sw 11/16/1998 08:06'!restoreSuspendedEventHandler	| savedHandler |	(savedHandler _ self valueOfProperty: #suspendedEventHandler) ifNotNil:		[self eventHandler: savedHandler].	submorphs do: [:m | m restoreSuspendedEventHandler]! !!Morph methodsFor: 'event handling' stamp: 'sw 11/16/1998 08:07'!suspendEventHandler	self eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: self eventHandler.		self eventHandler: nil].	submorphs do: [:m | m suspendEventHandler].  "All those rectangles"! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenColor: evt	self assuredPlayer choosePenColor: evt! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenSize	self assuredPlayer choosePenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenColor	^ self player ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenDown	self player ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenSize	self player ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!liftPen	self assuredPlayer liftPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!lowerPen	self assuredPlayer lowerPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!penColor: aColor	self assuredPlayer penColor: aColor! !!Morph methodsFor: 'pen' stamp: 'di 9/3/1998 10:38'!penUpWhile: changeBlock 	"Suppress any possible pen trail during the execution of changeBlock"	self getPenDown		ifTrue: ["If this is a costume for a player with its pen down, suppress any line."				self liftPen.				changeBlock value.				self lowerPen]		ifFalse: ["But usually, just do it."				changeBlock value]! !!Morph methodsFor: 'pen' stamp: 'di 9/10/1998 16:18'!trailMorph	"You can't draw trails on me, but try my owner."	owner == nil ifTrue: [^ nil].	^ owner trailMorph! !!Morph methodsFor: 'naming' stamp: 'sw 8/11/1998 16:46'!choosePartNameSilently	^ self world model namePartSilently: self assuredPlayer! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:46'!externalName	^ self knownName ifNil: [self innocuousName]! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:10'!knownName	extension == nil ifTrue: [^ nil].	^ extension externalName! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:47'!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:11'!setNamePropertyTo: aName	extension == nil ifTrue: [self assureExtension].	extension externalName: aName! !!Morph methodsFor: 'naming' stamp: 'tk 1/12/1999 19:25'!setNameTo: aName	self setNamePropertyTo: aName asString	"no Texts here!!"! !!Morph methodsFor: 'naming' stamp: 'tk 8/10/1998 16:00'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			self eventHandler ifNotNil: [				self eventHandler mouseDownSelector ifNotNil: [					hh _ self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				self eventHandler mouseUpSelector ifNotNil: [					hh _ self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/21/1998 16:31'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld startStepping: self.	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 11/18/1998 21:53'!isStepping	"Return true if the receiver is currently stepping in its world"	| world |	world _ self world.	^world isNil		ifTrue:[false]		ifFalse:[world isStepping: self]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 7/19/1998 11:51'!startSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld"	self step.  "one to get started!!"	aWorld ifNotNil: [aWorld startStepping: self].	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message"	self player ifNotNil: [self player step]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ self player ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/8/1998 17:18'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menus' stamp: 'sw 11/16/1998 08:13'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	"aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument]."	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:32'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left topLeft topRight bottomRight bottomLeft none) do:		[:anEdge |			menu add: anEdge asString selector: #setToAdhereToEdge: argument: anEdge.			((anEdge == #left) | (anEdge == #bottomLeft))				ifTrue:					[menu addLine]].	menu popUpAt: self position forHand: self primaryHand! !!Morph methodsFor: 'menus' stamp: 'sw 7/15/1998 21:16'!adhereToEdge: edgeSymbol	(owner == nil or: [owner isHandMorph]) ifTrue: [^ self].	self perform: (edgeSymbol, ':') asSymbol withArguments: (Array with: (owner bounds perform: edgeSymbol))! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:25'!setToAdhereToEdge: anEdge	anEdge ifNil: [^ self].	anEdge == #none ifTrue: [^ self removeProperty: #edgeToAdhereTo].	self setProperty: #edgeToAdhereTo toValue: anEdge.	self layoutChanged! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds _ bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld _ self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/5/1998 12:08'!addFontHandlesTo: aHalo box: box	"Add handles for controlling font, style, and emphasis choices to the halo"	| s |	s _ aHalo handleSize.	aHalo addHandleAt: (box bottomLeft + ((s+2)@0))		color: Color lightGreen on: #mouseDown send: #chooseFont to: self.	aHalo addHandleAt: (box bottomLeft + ((s+2*2)@0))		color: Color lightRed on: #mouseDown send: #chooseStyle to: self.	aHalo addHandleAt: (box bottomRight - ((s+2)@0))		color: Color lightBrown darker on: #mouseDown send: #chooseEmphasis to: self.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/6/1998 11:32'!addHalo	| halo |	halo _ HaloMorph new bounds: self fullBoundsInWorld.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 12:43'!editBalloonHelpText	| str  |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:32'!setBalloonText: stringOrText	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: Preferences maxBalloonHelpLineLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:29'!setBalloonText: stringOrText maxLineLength: aLength	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: aLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:39'!showBalloon: msgString	"Pop up a balloon containing the given string, first removing any existing BalloonMorphs in the world."	| w balloon worldBounds |	w _ self world.	w ifNil: [^ self].	balloon _ BalloonMorph string: msgString for: self corner: #bottomRight.	w submorphsDo: [:m |  "delete any existing balloons"		(m isKindOf: BalloonMorph) ifTrue: [m delete]].	balloon lock.  "So that if the translation below makes it overlap the receiver, it won't interfere with the rootMorphsAt: logic and hence cause flashing.  Without this, flashing happens, believe me!!"	w addMorphFront: balloon.	((worldBounds _ w bounds) containsRect: balloon bounds) ifFalse:		[balloon bounds: (balloon bounds translatedToBeWithin: worldBounds)].	self setProperty: #balloon toValue: balloon.! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!colorChangedForSubmorph: aSubmorph	"The color associated with aSubmorph was changed through the UI; react if needed"! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'sw 7/8/1998 13:21'!ownerChanged	"The receiver's owner, some kind of a pasteup, has changed its layout."	self snapToEdgeIfAppropriate! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!userSelectedColor: aColor	"The user, via the UI, chose aColor to be the color for the receiver; set it, and tell my owner in case he wishes to react"	self color: aColor.	owner ifNotNil: [owner colorChangedForSubmorph: self]! !!Morph methodsFor: 'player' stamp: 'sw 10/21/1998 09:30'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!Morph methodsFor: 'player' stamp: 'sw 9/15/1998 13:33'!newPlayerInstance	^ UnscriptedPlayer newUserInstance! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!okayToDuplicate	self player ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!showPlayerMenu	self player ifNotNil:		[self player showPlayerMenu]! !!Morph methodsFor: 'player commands' stamp: 'sw 8/4/1998 18:41'!makeFenceSound	self presenter soundsEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!Morph methodsFor: 'player viewer' stamp: 'sw 6/25/1998 08:32'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts.  This remains somewhat awkward -- color is normally there, but for objects that only wear an image/sketch costume, offering color would be perplexing, so it's left to the costumes to decide.""		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:))]		ifFalse:			[Array new]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:53'!jettisonScripts	self player ifNotNil: [self player class jettisonScripts]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	self player ifNotNil:		[self player justClonedFrom: aDonor player]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:59'!restoreTypeColor	self player ifNotNil: [self player allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:46'!scriptEditorFor: aScriptName	^ self assuredPlayer scriptEditorFor: aScriptName! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!scriptPerformer	^ self player ifNil: [self]! !!Morph methodsFor: 'scripting' stamp: 'sw 10/6/1998 17:10'!tearOffTile	^ self assuredPlayer tearOffTileForSelf! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:	[NumericReadoutTile new typeColor: aColor]		ifFalse:	[StringReadoutTile new typeColor: aColor]. 	viewer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat]		ifFalse:			[viewer useDefaultFormat].	aTile addMorphBack: viewer.	putSelector == #unused ifFalse: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!useUniformTileColor	self player ifNotNil:		[self player allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:56'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	self player updateAllViewers.	self world addMorph: (anEditor _ self player scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'e-toy support' stamp: 'tk 12/17/1998 11:16'!allMorphsAndBookPagesInto: aSet	"Return a set of all submorphs.  Don't forget the hidden ones like BookMorph pages that are not showing.  Consider only objects that are in memory (see allNonSubmorphMorphs)." 	submorphs do: [:m | m allMorphsAndBookPagesInto: aSet].	self allNonSubmorphMorphs do: [:m | 			(aSet includes: m) ifFalse: ["Stop infinite recursion"				m allMorphsAndBookPagesInto: aSet]].	aSet add: self.	^ aSet	! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/30/1998 09:53'!clearPaletteArea	| pal |	(pal _ self standardPalette) ~~ nil ifTrue:		[pal showNoPalette]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/22/1998 20:28'!currentPlayerDo: aBlock	"If the receiver is a viewer/scriptor associated with a current Player object, evaluate the given block against that object"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/30/1998 16:07'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: self frame: (0@0 extent: 1@1).	^ window! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 09:51'!enforceTileColorPolicy	| aPresenter |	(aPresenter _ self presenter) ifNotNil: [^ aPresenter harmonizeTileColorPolicyFor: self].	self makeAllTilesGreen "fallback - ack current preference"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 15:54'!isAViewer	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid _ Compiler evaluate: (FillInTheBlank request: 'Enter grid size' initialAnswer: '16').	Utilities informUser: 'Choose a background color' during: [backColor _ Color fromUser].	Utilities informUser: 'Choose a line color' during: [lineColor _ Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/30/1998 09:41'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do: [:i |		gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.		gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm.	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 12/7/1998 09:58'!objectViewed	^ (self outermostMorphThat: [:o | (o isKindOf: Viewer orOf: ScriptEditorMorph) or: [o isKindOf: PartsViewer]])  objectViewed! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/26/1998 16:05'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/1/1998 18:01'!referencePlayfield	| former |	owner isPlayfieldLike ifTrue: [^ owner].	((owner isKindOf: HandMorph) and: [(former _ owner formerOwner) ~~ nil])		ifTrue:			[^ former isPlayfieldLike 				ifTrue:					[former]				ifFalse:					[former referencePlayfield]].	self isInWorld ifFalse: [^ nil].	^ self world submorphNamed: 'playfield'! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:18'!setStandardTexture	| parms |	parms _ self textureParameters.	self makeGraphPaperGrid: parms first		background: parms second		line: parms third! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:55'!succeededInRevealing: aPlayer	aPlayer == self player ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!textureParameters	"Answer a triplet giving the preferred grid size, background color, and line color.  The choices here are as suggested by Alan, 9/13/97"	^ Array with: 16 with: Color lightYellow with: Color lightGreen lighter lighter! !!Morph methodsFor: 'e-toy support' stamp: 'sw 1/5/1999 16:30'!updateCachedThumbnail	"If I have a cached thumbnail, then update it.  Copied up from Dan's original version in PasteUpMorph so it can be used by all morphs."	| cachedThumbnail |	(cachedThumbnail _ self valueOfProperty: #cachedThumbnail) ifNotNil:		[cachedThumbnail computeThumbnail].! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 12:48'!inPartsBin	| o |	self isPartsDonor ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:09'!isPartsDonor	extension == nil ifTrue: [^ false].	^ extension isPartsDonor! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:10'!isPartsDonor: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension isPartsDonor: aBoolean! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 13:02'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self isPartsDonor: true! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 18:00'!printStructureOn: aStream indent: tabCount	tabCount timesRepeat: [aStream tab].	self printOn: aStream.	aStream cr.	self submorphsDo: [:m | m printStructureOn: aStream indent: tabCount + 1].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s _ WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:27'!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:28'!assuredExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 22:08'!copyPropertiesFrom: donorMorph dict: dict	(extension _ donorMorph extension copy) == nil ifTrue: [^ self].	extension copyPropertiesFrom: donorMorph dict: dict! !!Morph methodsFor: 'property extension' stamp: 'di 8/10/1998 14:25'!extension	^ extension! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 12:01'!otherProperties	extension == nil ifTrue: [^ nil].	^ extension otherProperties! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'tk 1/4/1999 11:04'!allStrings	"return an Array of strings of text in my submorphs"	| list string |	list _ OrderedCollection new.	self allMorphsDo: [:sub | 		(string _ sub userString) ifNotNil: [			(string isKindOf: String) 				ifTrue: [list add: string]				ifFalse: [list addAll: string]]].	^ list! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu addLine.	aMenu add: 'call #tempCommand' action: #callTempCommand.	aMenu add: 'define #tempCommand' action: #defineTempCommand.	aMenu addLine.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:54'!defineTempCommand	"To use this, comment out what's below here, and substitute your own code.You will then be able to invoke it from the standard debugging menus.  If invoked from the world menu, you'll always get it invoked on behalf of the world, but if invoked from an individual morph's meta-menu, it will be invoked on behalf of that individual morph.Note that you can indeed reimplement tempCommand in an individual morph's class if you wish"	Browser openMessageBrowserForClass: Morph		selector: #tempCommand editString: nil! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:31'!inspectOwnerChain	self ownerChain inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:28'!ownerChain	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	^ c asArray! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:51'!tempCommand	"Generic backstop.  If you care to, you can comment out what's below here, and substitute your own code, though the intention of design of the feature is that you leave this method as it is, and instead reimplement tempCommand in the class of whatever individual morph you care to.  In any case, once you have your own #tempCommand in place, you will then be able to invoke it from the standard debugging menus."	self inform: 'Before calling tempCommand, youshould first give it a definition.  Todo this, choose "define tempCommand"from the debug menu.'! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color _ aColor.! !!Morph methodsFor: 'private' stamp: 'tk 8/30/1998 09:58'!privateFullBounds: boundsRect	"Private!! Computed automatically."	fullBounds _ boundsRect.! !!Morph methodsFor: 'private' stamp: 'di 9/10/1998 16:21'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| trailMorph start |	(extension == nil or: [extension player == nil]) ifFalse:		["Most cases eliminated fast by above test"		self getPenDown ifTrue:			["If this is a costume for a player with its pen down, draw a line."			(trailMorph _ self trailMorph) ifNotNil:				[start _ self referencePosition.				trailMorph drawPenTrailFor: self from: start to: start + delta]]].	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"				fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [bounds _ bounds translateBy: delta.				fullBounds _ nil]! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 5/26/1998 15:33'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream |	aFileName _ ('my ', self class name) asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name? (".morph" will be added to end)' 			initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: aFileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/3/1998 20:56'!saveOnURL	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| um pg |	pg _ self saveOnURLbasic.	um _ URLMorph newForURL: pg url.	um setURL: pg url page: pg.	um isBookmark: true.	self primaryHand attachMorph: um.! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47'!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [url _ pg urlNoOverwrite: suggestedUrlString].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 12/29/1998 22:47'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [		url _ ServerDirectory defaultStemUrl, '1.sp'.	"A new legal place"		url _ FillInTheBlank 				request: 'url of a place to store this object.Must begin with file:// or ftp://' 				initialAnswer: url.		url size == 0 ifTrue: [^ self beep]].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 7/11/1998 18:53'!storeDataOn: aDataStream	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."	| cntInstVars cntIndexedVars ti localInstVars |	"block my owner unless he is written out by someone else"	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	localInstVars _ Morph instVarNames.	ti _ 2.  	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:			[self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPutWeak: owner.	"owner only written if in our tree"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Morph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:34'!convertbosfcepc0: varDict bosfce0: smartRefStrm	"These variables are automatically stored into the new instance ('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information in ('eventHandler' 'properties' 'costumee' )""This method moves all property variables as well as eventHandler, and costumee into a morphicExtension."	| propVal |	"Move refs to eventhandler and costumee into extension"	(varDict at: 'eventHandler') == nil ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') == nil ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') == nil ifFalse:		[(varDict at: 'properties') keys do:			[:key |  "Move property extensions into extension"			propVal _ (varDict at: 'properties') at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [key ifNotNil: [					self assureExtension.					extension convertProperty: key toValue: propVal]]]].			].! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/29/1998 21:28'!newBounds: bounds color: color	^ (self new privateBounds: bounds) privateColor: color! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 16:51'!morphsUnknownToTheirOwners	"Return a list of all morphs (other than HandMorphs) whose owners do not contain them in their submorph lists"	"Morph morphsUnknownToTheirOwners"	| problemMorphs itsOwner |	problemMorphs _ OrderedCollection new.	self allSubInstances do:		[:m | (m isHandMorph not and: [((itsOwner _ m owner) ~~ nil and: [(itsOwner submorphs includes: m) not])])			ifTrue:				[problemMorphs add: m]].	^ problemMorphs! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 17:31'!repairMorphsUnknownToTheirOwners	"Morph repairMorphsUnknownToTheirOwners"	| aList |	(aList _ self morphsUnknownToTheirOwners) do:		[:m | m privateOwner: nil].	^ aList size printString, ' morph(s) repaired'! !MorphExtension provides access to extra instance state that is not required in most simple morphs.  This allows simple morphs to remain relatively lightweight while still admitting more complex structures as necessary.  The otherProperties field takes this policy to the extreme of allowing any number of additional named attributes, albeit at a certain cost in speed and space.!!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!actorState	^ actorState! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!actorState: newValue	actorState _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonText	^ balloonText! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonText: newValue	balloonText _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonTextSelector	^ balloonTextSelector! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonTextSelector: newValue	balloonTextSelector _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!eventHandler	^ eventHandler! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!eventHandler: newValue	eventHandler _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName	^ externalName! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName: newValue	externalName _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!isPartsDonor	^ isPartsDonor! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:52'!isPartsDonor: newValue	isPartsDonor _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!locked	^ locked! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!locked: newValue	locked _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!player	^ player! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!player: newValue	player _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!sticky	^ sticky! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!sticky: newValue	sticky _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!visible	^ visible! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!visible: newValue	visible _ newValue! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	otherProperties == nil ifTrue: [^ false].	prop _ otherProperties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 12:02'!otherProperties	^ otherProperties! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!removeProperty: propName	otherProperties == nil ifTrue: [^ self].	otherProperties removeKey: propName ifAbsent: [].	otherProperties size == 0 ifTrue: [otherProperties _ nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!setProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName	otherProperties == nil ifTrue: [^ nil].	^ otherProperties at: propName ifAbsent: [nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName ifAbsent: aBlock	otherProperties == nil ifTrue: [^ aBlock value].	^ otherProperties at: propName ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:14'!copyPropertiesFrom: donorMorph dict: dict	| val |	otherProperties _ donorMorph otherProperties copy.	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | val _ assn value.			val isMorph ifTrue: [				val owner ifNil: [assn value: (val copyRecordingIn: dict)]]]].					"note side effecting.  Any un-owned morph belongs to us."! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:16'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot."	| old |	eventHandler == nil ifFalse:		[self eventHandler: self eventHandler copy.		1 to: self eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | assn value: (aDictionary at: assn value ifAbsent: [assn value])]].			"note side effecting"! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 14:19'!comeFullyUpOnReload	"inst vars have default booplean values."	locked ifNil: [locked _ false].	visible ifNil: [visible _ true].	sticky ifNil: [sticky _ false].	isPartsDonor ifNil: [isPartsDonor _ false].	^ self! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:31'!convertProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	propName == #locked ifTrue: [^ locked _ aValue].	propName == #visible ifTrue: [^ visible _ aValue].	propName == #sticky ifTrue: [^ sticky _ aValue].	propName == #balloonText ifTrue: [^ balloonText _ aValue].	propName == #balloonTextSelector ifTrue: [^ balloonTextSelector _ aValue].	propName == #actorState ifTrue: [^ actorState _ aValue].	propName == #player ifTrue: [^ player _ aValue].	propName == #name ifTrue: [^ externalName _ aValue].  "*renamed*"	propName == #partsDonor ifTrue: [^ isPartsDonor _ aValue].  "*renamed*"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'initialization' stamp: 'di 8/16/1998 12:02'!initialize	"Init all booleans to default values"	locked _ false.	visible _ true.	sticky _ false.	isPartsDonor _ false.! !!MorphExtension methodsFor: 'other' stamp: 'sw 10/20/1998 00:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == false ifTrue: [aStream nextPutAll: '[not visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 12/14/1998 15:22'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| aMorph myUrl oldFlag response |	"Transcript show: thisContext sender selector; cr." "useful for debugging"	oldFlag _ recursionFlag.	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	oldFlag == true ifTrue: [		response _ (PopUpMenu labels: 'proceed normally\debug' withCRs)			startUpWithCaption: 'Object being fetched for a second time.Should not happen, and needs to be fixed later.'.		response = 2 ifTrue: [self halt]].	"We are already the new object"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ aMessage sentTo: aMorph! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 10/22/1998 15:43'!fullReleaseCachedState	"do nothing, especially don't bring in my object!!"! !A morph whose appearance is a thumbnail of some other morph.!!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'reveal original morph' action: #revealOriginal.	aCustomMenu add: 'grab original morph' action: #grabOriginal.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 11/13/1998 09:53'!computeThumbnail	"Assumption on entry:       The receiver's width represents the maximum width allowable.       The receiver's height represents the exact height desired."	| f scaleX scaleY |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scaleY _ self height / f height.  "keep height invariant"	scaleX _ ((morphRepresented width * scaleY) <= self width)		ifTrue:			[scaleY]  "the usual case; same scale factor, to preserve aspect ratio"		ifFalse:			[self width / f width].	self form: (f magnify: f boundingBox by: (scaleX @ scaleY) smoothing: 2).	self extent: originalForm extent! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:08'!grabOriginal	self primaryHand attachMorph: morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'all' stamp: 'jm 11/17/97 17:30'!morphRepresented	^ morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:04'!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail])		ifTrue:			[^ self beep].	morphRepresented owner == nil ifTrue:		[^ owner replaceSubmorph: self by: morphRepresented].	self beep.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!smaller	self form: (self form copy: (0@0 extent: self form extent // 2))! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.morphRepresented _ deepCopier references at: morphRepresented 		ifAbsent: [morphRepresented].! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.morphRepresented _ morphRepresented.		"Weakly copied"! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/21/1998 17:54'!openOn: aWorldMorph label: aString cautionOnClose: aBoolean	"Open a view with the given label on the given WorldMorph."	| aModel |	aModel _ aBoolean		ifTrue:		[CautiousModel new]		ifFalse:		[WorldViewModel new].	^ self openOn: aWorldMorph label: aString model: (aModel initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 11:40'!openWorldWith: aMorph labelled: labelString	| w |	w _ WorldMorph new addMorph: aMorph.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!MorphicEvent methodsFor: 'mouse' stamp: 'ar 11/15/1998 23:42'!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform globalPointToLocal: cursorPoint)! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:16'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:20'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicModel methodsFor: 'initialization' stamp: 'jm 8/20/1998 09:08'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!MorphicModel methodsFor: 'menu' stamp: 'sw 10/5/1998 14:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	model ifNotNil: [model addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph].	self isOpen ifTrue: [aCustomMenu add: 'close editing' action: #closeToEdits]			ifFalse: [aCustomMenu add: 'open editing' action: #openToEdits].! !!MorphicModel class methodsFor: 'instance creation' stamp: 'tk 8/13/1998 12:58'!new	"Return a copy of the prototype, if there is one.	Otherwise create a new instance normally."	self hasPrototype ifTrue: [^ prototype veryDeepCopy].	^ super new! !!MorphicModel class methodsFor: 'prototype access' stamp: 'tk 8/13/1998 12:58'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph veryDeepCopy.	(prototype isKindOf: MorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !This class implements simple translation, scaling and rotation for points, as well as inverse transformations.  These transformations are used in TransformMorphs (clipping scrollers) and TransformationMorphs (general flex-morph wrappers) to map, eg, global mouse coords into local coords, and to invert, eg, local damage rectangles into global damage rectangles.!!MorphicTransform methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:33'!inverseTransformation	"Return the inverse transformation of the receiver"	^MorphicTransform		offset: (self transform: 0@0) - (self transform: offset)		angle: angle negated		scale: scale reciprocal! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/2/1998 08:54'!invertRect: aRectangle	self error: 'method name changed to emphasize enclosing bounds'.	^ self invertBoundsRect: aRectangle! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!transformBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from global to local coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self transform: aRectangle topLeft)			corner: (self transform: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self transform: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!MorphicTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 20:58'!setIdentiy	scale _ 1.0.	offset _ 0@0.	angle _ 0.0.! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ self isPureTranslation and: [offset = (0@0)]! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 19:51'!isMorphicTransform	^true! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^ angle = 0.0 and: [scale = 1.0]! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:13'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self transform: aPoint! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:32'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self invert: aPoint! !!MorphicTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:14'!asMatrixTransform2x3	^((MatrixTransform2x3 withRotation: angle radiansToDegrees negated) composedWithLocal:		(MatrixTransform2x3 withScale: scale))			offset: offset negated! !!MouseDownMorph methodsFor: 'menu' stamp: 'sw 11/16/1998 08:22'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph."template..."	aCustomMenu addLine.	aCustomMenu add: 'set variable name...' action: #renameMe.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model slot' action: #plugMouseDownToSlot.	aCustomMenu add: 'plug mouseMove to model slot' action: #plugMouseMoveToSlot.	aCustomMenu add: 'plug all to model slots' action: #plugAllToSlots.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model' action: #plugMouseDownToModel.	aCustomMenu add: 'plug mouseMove to model' action: #plugMouseMoveToModel.	aCustomMenu add: 'plug all to model' action: #plugAllToModel.	aCustomMenu addLine.	aCustomMenu add: 'set target...' action: #setTarget.	aCustomMenu add: 'set mouseDown selector...' action: #setMouseDownSelector.	aCustomMenu add: 'set mouseMove selector...' action: #setMouseMoveSelector.	aCustomMenu add: 'set mouseUp selector...' action: #setMouseUpSelector.! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 22:44'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber.	moviePlayerMorph msSinceStart: scorePlayer msecsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 14:13'!frameNumber	^ frameNumber! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 17:04'!image: aForm player: aMoviePlayer frameNumber: n	self image: aForm.	moviePlayerMorph _ aMoviePlayer.	frameNumber _ n! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'sw 12/30/1998 19:52'!moviePlayerMorph	^ moviePlayerMorph! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 21:57'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		(evt morph isMemberOf: MovieFrameSyncMorph) ifTrue: [^ evt]].	^ nil! !!MovieMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:21'!fullControlSpecs	^ #(				('<<>>'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			('->'			nextPage		'Forward one frame')			('>>'			playForward	'Play forward')			( '-->'		lastPage			'Go to final page'))! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 14:05'!insertPage	^ self makeMyPage! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:56'!makeMyPage	currentPage ifNotNil: [currentPage releaseCachedState; delete].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	pages _ OrderedCollection with: currentPage.	self addMorphBack: currentPage.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 22:01'!openFileNamed: fName	| f w h d n m |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ m/1000.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/13/1998 14:46'!openMovieFile	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.movie')					withCaption: 'Choose a movie file to open'.	fileName ifNotNil: [self openFileNamed: fileName]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 23:37'!position: newPos	super position: newPos.	(currentPage ~~ nil and: [currentPage left odd])		ifTrue: ["crude word alignment for depth = 16"				super position: newPos + (1@0)]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/14/1998 15:50'!setInitialState	super setInitialState.	self borderWidth: 2.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!frameNumber: n	frameNumber _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msPerFrame: n	msPerFrame _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msSinceStart: n	msSinceStart _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/8/1998 11:53'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self primaryHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:32'!firstPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 19:02'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step  "will stop after first step"! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!lastPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: frameCount! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!nextPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber + 1 min: frameCount).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playForward	(playDirection ~= 0 or: [frameNumber >= frameCount]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ 1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playReverse	(playDirection ~= 0 or: [frameNumber <= 1]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ -1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!previousPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber - 1 max: 1).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/5/1998 23:40'!stopPlay	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 22:59'!pauseFrom: player	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 08:46'!resetFrom: player	self pauseFrom: player.	frameNumber _ 1! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/17/1998 19:02'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self startRunning! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:47'!startRunning	| ff byteCount |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.	scorePlayer == nil ifTrue: [msSinceStart _ Time millisecondClockValue].! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:49'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If it is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  In either case, ssome calls on step will skip their  action until the right time."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	|  ff byteCount ms |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				ms < msSinceStart ifTrue: [msSinceStart _ ms "clock rollover"].				ms < (msSinceStart + msPerFrame) ifTrue: [^ self]]		ifFalse: [msSinceStart > scorePlayer msecsSinceStart ifTrue: [^ self]].	ff _ currentPage image. 	byteCount _ ff bits size * 4.	frameNumber _ frameNumber + playDirection.	msSinceStart _ msSinceStart + msPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.	currentPage changed.	(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].		"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:57'!stepTime	^ 0  "step as fast as possible"! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 19:01'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil:		[movieFile close.		movieFile _ nil].	playDirection _ 0.! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/13/1998 14:42'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('make thumbnail'		thumbnailForThisPage)			('open movie file'		openMovieFile)		).	(sel _ aMenu invokeAt: self primaryHand position in: self world)		ifNotNil: [self perform: sel].! !(out of date class....)!!MswUrl methodsFor: 'misc' stamp: 'ls 7/1/1998 02:23'!httpUrlOfServer	"return the HTTP address to make queries to"		#XXX.  "should come up with a better name for this when I'm less tired"	^HttpUrl schemeName: 'http'  authority: authority  path: path  query: nil.! !!MswUrl methodsFor: 'access' stamp: 'ls 7/12/1998 23:34'!query	"return the query.  There is never a MuSwiki URL without a query; the query defaults to 'top' if none is explicitly specified"	| q |	q _ super query.	q isNil ifTrue: [ q _ 'top' ].	^q! !!NetNameResolver class methodsFor: 'lookups' stamp: 'ls 9/5/1998 01:14'!addressForName: aString	^self addressForName: aString timeout: 60! !!NewHandleMorph methodsFor: 'all' stamp: 'sw 11/5/1998 10:24'!initialize	waitingForClickInside _ true.	super initialize.	Preferences noviceMode ifTrue: [self setBalloonText: 'stretch']! !!NewParagraph methodsFor: 'composition' stamp: 'di 6/22/1998 12:37'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						hitCR ifTrue:							["If text ends with CR, add a null line at the end"							((lineY + lineHeightGuess) <= container bottom) ifTrue:								[row _ container rectanglesAt: lineY height: lineHeightGuess.								row size > 0 ifTrue:									[line _ (TextLine start: charIndex stop: charIndex-1										internalSpaces: 0 paddingWidth: 0)									rectangle: row first;									lineHeight: lineHeightGuess baseline: textStyle baseline.									lines addLast: line]]].						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/22/1998 12:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/6/1998 11:17'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/20/1998 10:45'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [:i | rects addLast: (lines at: i) rectangle].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NewParagraph methodsFor: 'editing' stamp: 'tk 1/13/1999 07:55'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."| startBlock action target |action _ false.startBlock _ self characterBlockAtPoint: clickPoint.(text attributesAt: startBlock stringIndex) 	do: [:att | att mayActOnClick ifTrue:			["			range _ text rangeOf: att startingAt: startBlock stringIndex.			boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 						to: (self characterBlockForIndex: range last).			box _ boxes detect: [:each | each containsPoint: clickPoint].				*This doesn't work in morphic*			Need to replace by a highlighting morph that waits for moueUp.			Utilities awaitMouseUpIn: (editor transform invertRect: box)					repeating: []					ifSucceed: [(att actOnClickFor: model) ifTrue: [action _ true]]."			(target _ model) ifNil: [target _ editor morph].			(att actOnClickFor: target)				ifTrue: [Sensor waitNoButton.  "FIX THIS"						action _ true]			].		].^ action! !!NewParagraph methodsFor: 'display' stamp: 'di 1/14/1999 20:49'!displaySelectionInLine: line on: aCanvas	| leftX rightX w caretColor |	selectionStart ifNil: [^ self].  "No selection"	selectionStart = selectionStop		ifTrue: ["Only show caret on line where clicked"				selectionStart textLine ~= line ifTrue: [^ self]]		ifFalse: ["Test entire selection before or after here"				(selectionStop stringIndex < line first					or: [selectionStart stringIndex > (line last+1)])					ifTrue: [^ self].  "No selection on this line"				(selectionStop stringIndex = line first					and: [selectionStop textLine ~= line])					ifTrue: [^ self].  "Selection ends on line above"				(selectionStart stringIndex = (line last+1)					and: [selectionStop textLine ~= line])					ifTrue: [^ self]].  "Selection begins on line below"	selectionStart stringIndex < line first		ifTrue: [leftX _ line left]		ifFalse: [leftX _ selectionStart left].	(selectionStop stringIndex > (line last+1)			or: [selectionStop stringIndex = (line last+1)					and: [selectionStop textLine ~= line]])		ifTrue: [rightX _ line right]		ifFalse: [rightX _ selectionStop left].	selectionStart = selectionStop		ifTrue:		[rightX _ rightX + 1.		w _ self caretWidth.		caretColor _ Display depth <= 2					ifTrue: [Color black]					ifFalse: [self selectionColor].		1 to: w do:			[:i |  "Draw caret triangles at top and bottom"			aCanvas fillRectangle: ((leftX-w+i-1)@(line top+i-1) extent: (w-i*2+3)@1)				color: caretColor.			aCanvas fillRectangle: ((leftX-w+i-1)@(line bottom-i) extent: (w-i*2+3)@1)				color: caretColor].		aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: caretColor]	ifFalse:		[aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: self selectionColor]! !!NewParagraph methodsFor: 'display' stamp: 'di 1/14/1999 20:56'!selectionColor	Display depth = 1 ifTrue: [^ Color veryLightGray].	Display depth = 2 ifTrue: [^ Color gray].	^ (Color r: 0.4 g: 1.0 b: 0)! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:30'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr |	cr _ Character cr.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:04'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex ! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	^ time + duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!pitch	"Convert my MIDI key number to a pitch and return it."	^ AbstractSound pitchForMIDIKey: midiKey! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!endNoteOnMidiPort: aMidiPort	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: 0.! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!startNoteOnMidiPort: aMidiPort	"Output a noteOn event to the given MIDI port."	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: velocity.! !!Number methodsFor: 'mathematical functions' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Number class methodsFor: 'instance creation' stamp: 'bf 12/9/1998 19:21'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign _ sign negated].			value _ Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!Object methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:51'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'testing' stamp: 'di 11/9/1998 09:38'!isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'len 1/13/98 21:18'!isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'tk 10/30/1998 15:10'!isInMemory	"All normal objects are."	^ true! !!Object methodsFor: 'testing' stamp: 'di 11/6/1998 08:04'!isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing' stamp: 'ls 7/14/1998 21:45'!isWebBrowser	"whether this object is a web browser.  See class: Scamper"	^false! !!Object methodsFor: 'testing' stamp: 'di 1/8/1999 15:04'!wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'comparing' stamp: 'sw 8/20/1998 12:34'!identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:01'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver.  These will be remapped in mapUniClasses, if needed."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying' stamp: 'tk 11/27/1998 09:00'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	mine _ self class allInstVarNames.	his _ anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'tk 1/6/1999 19:41'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new |	copier _ DeepCopier new initialize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | assoc value veryDeepFixupWith: copier].	^ new! !!Object methodsFor: 'copying' stamp: 'tk 1/6/1999 16:30'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new uc sup has mine |	deepCopier references at: self ifPresent: [:newer | ^ newer]. 	"already did him"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup _ class.  index _ class instSize.	[has _ sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	mine _ sup instVarNames.	has ifNotNil: [index _ index - mine size]		ifNil: [1 to: mine size do: [:xx |				sub _ self instVarAt: index.				(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index _ index - 1]].	(sup _ sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'copying' stamp: 'tk 1/6/1999 17:39'!veryDeepFixupWith: deepCopier	"I have no fields and no superclass.  Catch the super call."! !!Object methodsFor: 'copying' stamp: 'tk 1/6/1999 15:47'!veryDeepInner: deepCopier	"I have no fields and no superclass"! !!Object methodsFor: 'updating' stamp: 'jm 8/20/1998 18:26'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'printing' stamp: 'sw 5/2/1998 13:55'!stringForReadout	^ self stringRepresentation! !!Object methodsFor: 'class membership' stamp: 'tk 10/21/1998 12:38'!xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Object methodsFor: 'message handling' stamp: 'sw 10/30/1998 18:27'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ otherTarget perform: selector! !!Object methodsFor: 'user interface' stamp: 'sw 10/5/1998 14:39'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!modelWakeUp	"A window with me as model is being entered.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'system primitives' stamp: 'di 1/9/1999 15:19'!becomeForward: otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'private' stamp: 'di 5/28/1998 12:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System error handling failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		20 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	Smalltalk isMorphic ifTrue:		[^ World install "To init hand events and redisplay world"].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToFloat: rcvr andSend: selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:14'!adaptToFraction: rcvr andSend: selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToInteger: rcvr andSend: selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'jm 6/1/1998 12:58'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ (OrderedCollection new: 1) add: self; yourself! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!Object methodsFor: 'translation support' stamp: 'ar 9/18/1998 23:27'!export: aBoolean	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'objects from disk' stamp: 'tk 8/19/1998 15:03'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:22'!initialInstance	"Answer the first instance of the receiver, generate an error if there is one already"	"self instanceCount > 0 ifTrue: [self error: 'instance(s) already exist.']."		"Debugging test that is very slow"	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:27'!instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString	"Create a unique class for the receiver, and answer an instance of it"	^ (self newUniqueClassInstVars: instVarString 		classInstVars: classInstVarString) initialInstance! !!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!ObjectMemory methodsFor: 'initialization' stamp: 'di 12/18/1998 13:25'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	"ar 10/7/1998 - Clear the RootBit of all objects"	| oop header |	"Note: Don't bypass this method even if bytesToShift is zero 		until the RootBit problem has been fixed in the appropriate places."	"bytesToShift = 0 ifTrue: [ ^ nil ]."	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			header _ self longAt: oop.			self longAt: oop put: (header bitAnd: AllButRootBit).			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		oop _ self objectAfter: oop.	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'jm 11/25/1998 16:35'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	DoAssertionChecks ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'jm 12/6/1998 17:26'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.	statRootTableOverflows _ 0.	displayBits _ 0.  "support for the Acorn VM; ignored if zero"! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 11/27/1998 11:19'!fetchClassOf: oop	| ccIndex |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: ["look up compact class"				^ self fetchPointer: ccIndex - 1					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 11/27/1998 11:18'!fetchClassOfNonInt: oop	| ccIndex |	self inline: true.	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: ["look up compact class"				^ self fetchPointer: ccIndex - 1					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)]! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'jm 12/6/1998 17:12'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	DoAssertionChecks ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: ((hash << HashBitsOffset) bitAnd: HashBits).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize _ (header1 bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: AllButTypeMask. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 doFill: true with: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 12/4/1998 02:36'!instantiateContext: classPointer sizeInBytes: sizeInBytes	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: false with: 0! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 12/4/1998 01:33'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: true with: fillValue! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 00:30'!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)        4      both fixed and indexable weak fields (possibly containing pointers).        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 02:38'!isWeak: oop	"Answer true if the argument has only weak fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) = 4! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/18/1998 11:04'!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: SizeMask) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: CompactClassMask) = 0				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04'!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57'!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57'!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04'!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: AllButTypeMask! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'di 12/27/1998 23:17'!lastPointerOf: oop	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader header |	self inline: true.	header _ self baseHeader: oop.	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			^ (CtxtTempFrameStart + (self fetchStackPointerOf: oop)) * 4].		sz _ self sizeBitsOfSafe: oop.		^ sz - BaseHeaderSize  "all pointers"].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'jm 11/25/1998 16:34'!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	self inline: true.	DoAssertionChecks ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 12/6/1998 17:12'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize doFill: doFill with: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	doFill ifTrue:		[end _ newObj + byteSize.		i _ newObj + 4.		[i < end] whileTrue:			[self longAt: i put: fillWord.			i _ i + 4]].	DoAssertionChecks ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 19:36'!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= allocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		lowSpaceThreshold _ 0.  "disable additional interrupts until lowSpaceThreshold is reset by image"		interruptCheckCounter _ 0.	].	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		< (self cCoerce: (byteSize + BaseHeaderSize) to: 'unsigned ') ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/18/1998 08:45'!allocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling."	| cntxt |	freeContexts ~= NilContext ifTrue:		[cntxt _ freeContexts.		freeContexts _ self fetchPointer: 0 ofObject: cntxt.		^ cntxt].		cntxt _ self instantiateContext: (self splObj: ClassMethodContext)					sizeInBytes: LargeContextSize.	"Required init -- above does not fill w/nil.  All others get written."	self storePointerUnchecked: 4 "InitialIPIndex" ofObject: cntxt					withValue: nilObj.	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 23:34'!recycleContextIfPossible: cntxOop	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss.  The recycled context lists are cleared at every garbage collect."	self inline: true.	"only recycle young contexts (which should be most of them)"	(cntxOop >= youngStart		and: [self isMethodContextHeader: (self baseHeader: cntxOop)])		ifTrue:		[self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeContexts.		freeContexts _ cntxOop].! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 16:35'!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self inline: false.	self incrementalGC.  "try to recover some space"	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		< (self cCoerce: minFree to: 'unsigned ')		ifTrue:		[signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')			< ((self cCoerce: minFree to: 'unsigned ') + 15000)			ifTrue: [ ^ false ].  "still not enough"	].	^ true! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 19:30'!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		>= (self cCoerce: minFree to: 'unsigned ')		ifTrue: [^ true]		ifFalse: [^ self sufficientSpaceAfterGC: minFree].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'go 11/17/1998 15:56'!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: SizeMask ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'jm 12/6/1998 17:26'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'go 11/18/1998 11:04'!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: CompactClassMask) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/23/98 22:46'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object's indexed fields if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Set lastFieldOffset before the weak fields in the receiver"			lastFieldOffset := (self nonWeakFieldsOf: oop) << 2.		] ifFalse:[			"Do it the usual way"			lastFieldOffset _ self lastPointerOf: oop.		].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 1/12/1999 12:25'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit: 8.  "Two-word blocks".	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: SizeMask.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: SizeMask.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: AllButTypeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:41'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 14:09'!fwdBlockGet: blkSize	"Return the address of a two- or four-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + blkSize.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 1/13/1999 10:55'!fwdTableInit: blkSize	"Set the limits for a table of two- or three-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"Note: Forward blocks must be quadword aligned."	fwdTableNext _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdTableLast _ memoryLimit - blkSize.  "last forwarding table entry"	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // blkSize  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 12:25'!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	self inline: false.	"reserve memory for forwarding table"	self fwdTableInit: 8.  "Two-word blocks"	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 12:32'!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet: 8.  "Two-word block"			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop withBackPtr: false.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:45'!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.			DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	DoAssertionChecks ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 14:08'!initForwardBlock: fwdBlock mapping: oop to: newOop withBackPtr: backFlag	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. (The forwarding block address is actually shifted right by one bit so that its top-most bit does not conflict with the header's mark bit; since fowarding blocks are stored on word boundaries, the low two bits of the address are always zero.) The first word of the forwarding block is the new oop; the second word is the oop's orginal header. In the case of a forward become, a four-word block is used, with the third field being a backpointer to the old oop (for header fixup), and the fourth word is unused.  The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	DoAssertionChecks ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	backFlag ifTrue:		[self longAt: fwdBlock + 8 put: oop].	self longAt: oop put: (fwdBlock >> 1 bitOr: (MarkBit bitOr: originalHeaderType)).! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 12/27/1998 23:18'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			^ (CtxtTempFrameStart + (self fetchStackPointerOf: oop)) * 4].		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'ikp 12/18/1998 22:49'!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| oop |	self inline: false.	self compilerMapHookFrom: memStart to: memEnd.	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:59'!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.	DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ realHeader bitAnd: SizeMask ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:00'!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	self inline: false.	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:00'!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ ((self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:01'!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ ((self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask) << 1.			DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/9/1999 17:12'!become: array1 with: array2	^ self become: array1 with: array2 twoWay: true! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/12/1999 14:17'!become: array1 with: array2 twoWay: twoWayFlag	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2 twoWay: twoWayFlag)		ifFalse: [^ false].  "fail; not enough space for forwarding table"	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	twoWayFlag		ifTrue: [self restoreHeadersAfterBecoming: array1 with: array2]		ifFalse: [self restoreHeadersAfterForwardBecome].	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"! !!ObjectMemory methodsFor: 'become' stamp: 'jm 1/13/1999 10:56'!prepareForwardingTableForBecoming: array1 with: array2 twoWay: twoWayFlag	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock fwdBlkSize |	entriesNeeded _ (self lastPointerOf: array1) // 4.  "need enough entries for all oops"	twoWayFlag		ifTrue: ["Double the number of blocks for two-way become"				entriesNeeded _ entriesNeeded * 2.				fwdBlkSize _ 8  "Note: Forward blocks must be quadword aligned."]		ifFalse: ["One-way become needs backPointers in fwd blocks."				fwdBlkSize _ 16  "Note: Forward blocks must be quadword aligned."].	entriesAvailable _ self fwdTableInit: fwdBlkSize.	entriesAvailable < entriesNeeded ifTrue: 		[self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: 		[oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet: fwdBlkSize.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2 withBackPtr: twoWayFlag not.		twoWayFlag ifTrue:			["Second block maps oop2 back to oop1 for two-way become"			fwdBlock _ self fwdBlockGet: fwdBlkSize.			self initForwardBlock: fwdBlock mapping: oop2 to: oop1 withBackPtr: twoWayFlag not].		fieldOffset _ fieldOffset - 4].	^ true! !!ObjectMemory methodsFor: 'become' stamp: 'jm 11/25/1998 19:41'!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ (fwdHeader bitAnd: AllButMarkBitAndTypeMask) << 1.	DoAssertionChecks ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/12/1999 14:06'!restoreHeadersAfterForwardBecome	"Forward become leaves us with no original oops in the mutated object list,	so we must enumerate the (four-word) forwarding blocks	where we have stored backpointers."	| oop1 fwdBlock |	"This loop start is copied from fwdBlockGet:"	fwdBlock _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdBlock _ fwdBlock + 16.  "fwdBlockGet: did a pre-increment"	[fwdBlock <= fwdTableNext]  "fwdTableNext points to the last active block"		whileTrue:		[oop1 _ self longAt: fwdBlock + 8.  "Backpointer to mutated object."		self restoreHeaderOf: oop1.		fwdBlock _ fwdBlock + 16].! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/21/98 23:14'!aFinalizationComment	"This finalization scheme assumes to have weak classes in which the fields are not traced during the mark phase of a GC. This means, if an object is referenced only by any instances of weak classes it can be collected. In turn, we need to find out if an object referenced by a weak class is actually being collected because we have to invalidate the weak object pointer and to signal that the object has gone.	How do we know that an object referenced by a weak class is being collected? Well,  this is based on two observations. First, objects will not change their relative locations in memory, meaning that if object A is created BEFORE object B it will always have a physical memory address which is LESS than B. Secondly, GC always works from a given starting address (youngStart during incremental GC; startOfMemory during fullGC) up to end of memory. If we can somehow garantuee that the weak reference is created after the object it points to we can easily implement the following simple scheme:	1) Mark phase		Do not trace the fields of any instances of weak classes.	2) Sweep phase:		a) Explicitly mark all free objects.		b) 	If a weak reference is encountered check the the object it points to. 			If the object is marked as free than we know that this weak reference's object is gone.			Signal that it is gone.	There is, however, one small problem with this approach. We cannot always garantuee that WeakReferences point backwards such as in the following piece of code:		| o1 o2 w1 w2 |		o1 _ Object new.		w1 _ WeakReference on: o1.		o2 _ Object new.		w2 _ WeakReference on: o2.		o1 become: o2.The become: operation makes w1 point to o2 and because o2 has been created AFTER w1 the object reference in w1 points forward. Why might this be a problem? Well, if the GC would start after the weak reference AND free the object then the weak reference would simply point to an invalid memory location (since we've not been checking the weak reference during sweep phase).	Fortunately, this can not happen in the current ObjectMemory implementation. Why? Well, the only GC not starting at the beginning of the memory is incremental GC. Incremental GC however is only executed in so-called youngSpace. If both, the weak reference AND the object it points to reside in youngSpace then we can still check the weak reference. If however, the weak reference is not in youngSpace but the object is, then the object is itself a root in young space and will be marked by the GC even if it is only referenced by the WeakReference.	In the end, we just need a little adjustment in step 2b) of the above procedure which looks as follows:		If the weak reference points 			* backwards: check if the object header is marked free			* forwards: check if the object has been marked in markPhase.	Note that a number of finalizations will only be executed during a fullGC. This happens if either the WeakReference or the object reside outside youngSpace. So, if you must garantuee that some object has been finalized you definitely need to do a fullGC.ar 3/20/98 17:20"	self error:'Comment only'.! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/23/98 22:39'!finalizeReference: oop	"During sweep phase we have encountered a weak reference. Check if	its object has gone away (or is about to) and if so, signal a semaphore."	| weakOop oopGone chunk firstField lastField |	"Do *not* inline this in sweepPhase - it is quite an unlikely case to run into a weak reference"	self inline: false.	firstField := BaseHeaderSize + ((self nonWeakFieldsOf: oop) << 2).	lastField := self lastPointerOf: oop.	firstField to: lastField by: 4 do:[:i|		weakOop := self longAt: oop+i.		((weakOop == nilObj) or:[(self isIntegerObject: weakOop)]) ifFalse:[			"Check if the object is being collected.			If the weak reference points 				* backward: check if the weakOops chunk is free				* forward: check if the weakOoop has been marked by GC"			weakOop < oop 				ifTrue:[	chunk _ self chunkFromOop: weakOop.						oopGone _ ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]				ifFalse:[oopGone _ ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].			oopGone ifTrue:[					"Store nil in the pointer and signal the interpreter"					self longAt: oop+i put: nilObj.					self signalFinalization: oop].		].	].! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!characterTable	^self splObj: CharacterTable! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classArray	^self splObj: ClassArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classBitmap	^self splObj: ClassBitmap! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classByteArray	^self splObj: ClassByteArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classCharacter	^self splObj: ClassCharacter! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classFloat	^self splObj: ClassFloat! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classLargePositiveInteger	^self splObj: ClassLargePositiveInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classPoint	^self splObj: ClassPoint! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSemaphore	^self splObj: ClassSemaphore! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSmallInteger	^self splObj: ClassInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!classString	^self splObj: ClassString! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!displayObject	^self splObj: TheDisplay! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!falseObject	^falseObj! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:16'!trueObject	^trueObj! !!ObjectMemory class methodsFor: 'initialization' stamp: 'di 12/18/1998 13:01'!initialize	"ObjectMemory initialize"	"Translation flags (booleans that control code generation via conditional translation):"	DoAssertionChecks _ false.  "generate assertion checks"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	CtxtTempFrameStart _ 6.  "Copy of TempFrameStart in Interp"	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 2500.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'go 11/18/1998 10:42'!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	SizeMask _ 16rFC.	CompactClassMask _ 16r1F000.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'jm 11/16/1998 18:36'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	FloatProto _ 31.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.! !I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]!!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 12/14/1998 15:19'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| realObject oldFlag response |	oldFlag _ recursionFlag.	recursionFlag _ true.	"fetch the object"	realObject _ self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	oldFlag == true ifTrue: [		response _ (PopUpMenu labels: 'proceed normally\debug' withCRs)			startUpWithCaption: 'Object being fetched for a second time.Should not happen, and needs to be fixed later.'.		response = 2 ifTrue: [self halt]].	"We are already the new object"	^ aMessage sentTo: realObject! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57'!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing _ SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page _ truePage _ existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage _ SqueakPageCache atURL: url oldPage: page].	object _ truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag _ false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page _ truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/15/1998 19:59'!xxxFixup	"There is already an object in memory for my url.  All pointers to me need to be pointers to him.  Can't use become, because other pointers to him must stay valid."	| real temp list |	real _ page contentsMorph.	real == self ifTrue: [page error: 'should be converted by now'].	temp _ self.	list _ (Smalltalk pointersTo: temp) asOrderedCollection.	list add: thisContext.  list add: thisContext sender.	list do: [:holder |		1 to: holder class instSize do:			[:i | (holder instVarAt: i) == temp ifTrue: [holder instVarAt: i put: real]].		1 to: holder basicSize do:			[:i | (holder basicAt: i) == temp ifTrue: [holder basicAt: i put: real]].		].	^ real! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 10/21/1998 13:01'!xxxSetUrl: aString page: aSqkPage	url _ aString.	page _ aSqkPage.! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store"	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!objectToStoreOnDataStream    "Return an object to store on a data stream (externalize myself)."    ^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:37'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method. Return self."	| cntInstVars |	cntInstVars _ self xxxClass instSize.	self xxxClass isVariable		ifTrue: [self xxxClass error: 'needs updating']	"assume no variable subclasses"		ifFalse: [cntInstVars _ varsOnDisk].	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self xxxInstVarAt: i put: aDataStream next]."	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next]."	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:18'!storeDataOn: aDataStream	"Store myself on a DataStream. See also objectToStoreOnDataStream.	must send 'aDataStream beginInstance:size:'"	| cntInstVars |	cntInstVars _ self class instSize.	"cntIndexedVars _ self basicSize."	aDataStream		beginInstance: self xxxClass		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self xxxInstVarAt: i)]."	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]"! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:29'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self xxxClass.	class isMeta ifTrue: [^ self].		"a class"	new _ self xxxClone.	"not a uniClass"	deepCopier references at: self put: new.	"remember"	"class is not variable"	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self xxxInstVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new xxxInstVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new xxxInstVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/20/1998 15:30'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	"This is just a comment, since this message is never looked up"	<primitive: 110>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/15/1998 18:11'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/20/1998 10:45'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 12/8/1998 21:51'!ifNotNil: aBlock	"know its not nil, since we can't stand for a nil"	^ aBlock value! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/30/1998 15:11'!isInMemory	"We are a place holder for an object that is out."	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:15'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:40'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/21/1998 12:28'!xxxClass	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:31'!xxxClone	<primitive: 148>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:19'!xxxInstVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	self primitiveFailed ! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:39'!xxxInstVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	self primitiveFailed ! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/4/1998 13:01'!sqkPage	^ page! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/4/1998 13:01'!url	^ url! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/18/1998 21:29'!xxxReset	"mark as never brought in"	recursionFlag _ nil! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 8/15/1998 15:26'!initialize	"remove all old class vars that are not instance-specific classes being renamed"	self clear.	"Most importantly, return self, so a fileIn will let ObjectScanner seize control.  So UniClasses can be remapped.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(10 247 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!OrderedCollection methodsFor: 'adding'!add: newObject beforeIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding index. Answer newObject."	self insert: newObject before: firstIndex + index.	^newObject! !!OrderedCollection methodsFor: 'enumerating' stamp: 'TAG 10/13/1998 22:47'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction	^direction! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction: aPoint	direction _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:31'!normal	^normal ifNil:[normal _ direction y negated @ direction x]! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!normal: aPoint	normal _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin	^origin! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin: aPoint	origin _ aPoint.! !!PCXReadWriter methodsFor: 'accessing' stamp: 'tao 10/6/97 10:11'!nextImage	"Read in the next PCX image from the stream."	| bytes form |	self readHeader.	bytes _ self readBody.	colorPalette _ self readPalette.	self close.	form _ ColorForm extent: width@height depth: bitsPerPixel.	(Form new hackBits: bytes) displayOn: (Form new hackBits: form bits).	form colors: colorPalette.	^ form! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:38'!nextWord	^self next + (self next bitShift: 8)! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 10:07'!readBody	| array scanLine rowBytes position byte count pad |	pad _ #(0 3 2 1) at: (width \\ 4 + 1).	array _ ByteArray new: ((width + pad) * height * bitsPerPixel) // 8.	scanLine _ ByteArray new: rowByteSize.	position _ 1.	1 to: height do:		[:line |		rowBytes _ 0.		[rowBytes < rowByteSize] whileTrue:			[byte _ self next.			byte < 16rC0				ifTrue:					[rowBytes _ rowBytes + 1.					scanLine at: rowBytes put: byte]				ifFalse:					[count _ byte - 16rC0.					byte _ self next.					1 to: count do: [:i | scanLine at: rowBytes + i put: byte].					rowBytes _ rowBytes + count]].		array			replaceFrom: position			to: position + width - 1			with: scanLine			startingAt: 1.		position _ position + width + pad].	^ array! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 09:42'!readHeader	| xMin xMax yMin yMax |	self next.	"skip over manufacturer field"	version _ self next.	encoding _ self next.	bitsPerPixel _ self next.	xMin _ self nextWord.	yMin _ self nextWord.	xMax _ self nextWord.	yMax _ self nextWord.	width _ xMax - xMin + 1.	height _ yMax - yMin + 1.	self next: 4. "skip over device resolution"	self next: 49. "skip over EGA color palette"	colorPlanes _ self next.	rowByteSize _ self nextWord.	isGrayScale _ (self next: 2) = 2.	self next: 58. "skip over filler".! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:29'!readPalette	| r g b array |	self next = 12 ifFalse: [self error: 'no Color Palette!!'].	array _ Array new: (1 bitShift: bitsPerPixel).	1 to: array size do:		[:i |		r _ self next.  g _ self next.  b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)].	^ array.! !Post Office Protocol.  This is used to download email over the network, usually from an intermittent connection.  To see how to use it, see POPSocket classe>>example.!!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:14'!addProgressObserver: anObserver	"progress will be sent to anObserver.  anObserver should respond to show:, endEntry, cr....  Transcript things"	progressObservers add: anObserver! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:27'!initialize	super initialize.	progressObservers _ IdentitySet new.! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!password: aString	"set the password to use"	password _ aString ! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:22'!serverName: aString	"set the server name to connect to"	serverName _ aString! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!userName: aString	"set the username to use"	userName _ aString! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:51'!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find host address'].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:55'!deleteAllMessages	"delete all messages"	1 to: self numMessages do: [ :num |		self deleteMessage: num ]! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:07'!deleteMessage: num	"delete the numbered message"	self sendCommand: 'DELE ', num printString.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/2/1998 16:05'!disconnectFromPOP	"Send a QUIT message, then disconnect."	self isValid ifFalse: [^ self].  "already closed"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:54'!messagesDo: aBlock	"perform aBlock on each message text"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		aBlock value: thisMessage.	].	! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/3/1998 07:55'!numMessages	"Query the server and answer the number of messages that are in the user's mailbox."	| response answerString |	numMessages ifNotNil: [^ numMessages].  "cached result of earlier query"	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [^ 0].  "error"	answerString _ (response findTokens: Character separators) second.	^ answerString asNumber asInteger! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:04'!retrieveMessage: number	"retrieve the numbered message"	| response |	self sendCommand: 'RETR ', number printString.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [		self error: 'error: ', response ].	^self getMultilineResponse.! !!POPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 19:57'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString.		aString last = Character cr ifFalse: [ observer show: String cr ]].! !!POPSocket class methodsFor: 'all' stamp: 'ls 9/10/1998 19:44'!example	"POPSocket example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 9/10/1998 15:35'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(request fields includesKey: 'text') ifTrue: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			username: (request fields at: 'username' ifAbsent:[''])			password: (request fields at: 'password' ifAbsent: [''])			privs: (request fields at: 'privs' ifAbsent: [''])			text: (request fields at: 'text' ifAbsent: ['blanktext'])			from: request peerName.		page user: request userID.  "Address is machine, user onlyif logged in"		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!PSwikiAction methodsFor: 'all' stamp: 'tk 9/16/1998 16:21'!process: request	"URLs are of the form:	{swikiname} to browse Front Page	{swikiname}.{coreID} to browse the page	{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.{coreID}.versions displays the last three versions of the page	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case) 		return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, Versions, or Edit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded:							(self fileContents: source , 'results.html')						with: (urlmap searchFor: pageRef name)).			^ self].		command = 'all' ifTrue:			[formattedPage _ urlmap allPagesFrom: pageRef for: request.			request reply: (HTMLformatter evalEmbedded:							(self fileContents: source, 'page.html')						with: formattedPage).			^ self].		(request message at: 1) = (request message at: 2) ifTrue: [			request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.			request message: (request message copyFrom: 2 to: request message size).			^ self process: request].	"(success and contentHTML will be sent twice!!)"		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !!PSwikiPage methodsFor: 'all' stamp: 'BJP 9/10/1998 14:33'!outputFormat	| formatCollection textBlock |"Ah, yes, my first experience with class vars. I need to think about thisscheme a bit, but it's only	 a placeholder anyway. BJP"	formatCollection _ OrderedCollection newFrom: super outputFormat.	textBlock _ formatCollection last.	^ formatCollection		add: [:thePage | 'authName: ', thePage usernameprintString, '; ']before: textBlock;		add: [:thePage | 'authPW: ', thePage password printString,'; ']before: textBlock;		add: [:thePage | 'privs: ', thePage privs printString, '; ']before: textBlock.! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:40'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		(page privs includesSubString: 'read') ifTrue:			[(action auth user: request userID) = page coreID			ifFalse: [self error: (PWS unauthorizedFor: (pagename))]].		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:36'!newpage: label from: peer	| newpage newfile |		newpage _ PSwikiPage new.		self at: label put: newpage.		newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage username: ''.		newpage password: ''.		newpage privs: ''.		newpage pageStatus: #new.		newpage file: ((ServerAction serverDirectory),			directory, (ServerAction pathSeparator), newfile).		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	^newpage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:39'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new].	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL:page),'...',(page address).		(page privs includesSubString: 'read') ifTrue:			[response nextPutAll: '  <b>Read protected</b>'.].		(page privs includesSubString: 'write') ifTrue:			[response nextPutAll: '  <b>Write protected</b>'.].].	response nextPutAll: '</ul>'.	^response contents! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:41'!storeID: id  username: theUsername password: thePassword privs: thePrivstext: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page address: peer.	(theUsername size > 1) ifTrue: [		page username: theUsername.		page password: thePassword.		page privs: thePrivs.		"Set up the authorization"		action auth mapName: theUsername password: thePassword			to: id.].	page text: text.	^ page! !!PWS methodsFor: 'Accessing' stamp: 'tk 9/16/1998 15:50'!message: anArray   message _ anArray! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:47'!initializeFrom: aSocket	"Initialize me from aSocket."	| request idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	"sets header"	header _ header substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at:idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ self clientName: connection remoteAddress.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	request last notNil		ifTrue: [ fields := self decodeFields: request last ]		ifFalse: [ (url includes: $?) ifTrue: [			idx _ url indexOf: $?.			idx = url size				ifTrue: [ "empty request" fields _Dictionary new ]				ifFalse: [					fields _ self decodeFields:						(url copyFrom: idx+1 to:url size) ].			url _ url copyFrom: 1 to: idx-1 ] ].	message := url findTokens: '/.\?:='.! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:44'!readRequest	"Read the request and return an array of header and query."	| idx request query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf)startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString:'CONTENT-LENGTH:' startingAt: 1) = 0			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to:		  (request indexOf: Character cr startingAt: lengthifAbsent: []))			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request,connection getData ].		query := (request copyFrom: idx + 3 to: request size)withBlanksTrimmed ].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'tk 7/15/1998 12:06'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request -- ', self classcrlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS methodsFor: 'Processing' stamp: 'ls 7/28/1998 01:09'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut:			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $%					ifTrue: [ (Number readFrom: (rsnext: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents ! !!PWS class methodsFor: 'HTTPcodes' stamp: 'tk 6/24/1998 16:24'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body></html>'! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:36'!checkVersion	"This is Squeak 2.2.  Make sure that the Server:swiki folder is the version for 2.2."	| fName |	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'page.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'The path to the Server folder is wrong.Please modify the following method ...'. 	Browser openMessageBrowserForClass: ServerAction class 		selector: #serverDirectory editString: nil.	^ false].	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'render.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'Initialization failed.  ''swiki'' folder is out of date.Get one from:http://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.tar orhttp://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.sea'. ^ false].	^ true! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:03'!howToStart	"To set up your new Swiki, you need a copy of the 'Server' folderfound at:http://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/Put the 'Server' folder into the folder that your image is in.Modify this method to be a path to your Server folder, select it, andchoose fileItIn:!!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!!serverDirectory	^ 'Hard Disk:Squeak1.31:Server:'!! !!Then do:	PWS initializeAll.To enable a new Swiki called OurOwnArea.Make a folder named OurOwnArea in the Server folder.  Then do:	SwikiAction setUp: 'OurOwnArea'.	(its main URL is http://thisMachine:80/OurOwnArea.1)<<<<There has been a major change between Squeak 2.1 and 2.2.  If you are reloading an existing Swiki for the first time in Squeak 2.2, Do this instead of the normal reload.	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	(PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineEndings ].	PWS serveOnPort: 80 loggingTo: 'log.txt'.(This to converts LineFeeds to CarriageReturns in all of your swiki data files.  Only do this the first time!!)>>>>>Suppose you already have a Swiki called 'myswiki'.To start up:	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	PWS serveOnPort: 80 loggingTo: 'log.txt'.To stop the server:	PWS stopServer.-----------------------To purge a particular file of all except the latest version:	((PWS actions at: 'myswiki' asLowercase) urlmap atID: '3') condenseChanges.To roll the entire wiki back to a previous time:	""This does not erase data, it just copies the older page to the end""	(PWS actions at: 'myswiki' asLowercase) rollBack: '1/28/98' asDate			at: '1:30 am' asTime.The look of a served page is controlled by a template.  Templates live inthe 'swiki' folder in the 'Server' folder.  Beware that templates arecached by HTMLformatter.  If you change a template, you will not see theeffect until you reload the Swiki.To set up a Swiki with a password (same for all users), seeAuthorizedSwikiAction comment.To enable a privledged user to execute code remotely (on a workspace page):	(PWS actions at: 'authorized') mapName: 'JSmith' password:'hard2guess' to: 'JSmith'.	(URL is http://thisMachine:80/authorized.workspace.html)To backup the user data to the disk, do nothing.  All info is alreadyinside the page files on the disk.To enable a new Swiki that evaluates Squeak code submitted by the user.Make a folder named SqkEval in the Server folder.  Then do:	ActiveSwikiAction setUp: 'SqkEval'.	(this is dangerous, because there are still ways a user could crashyour server)To convert a Swiki with LineFeed line endings to CarriageReturn lineendings, execute these lines:          (PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineENdings ]To convert from an old pre-Squeak1.3 Swiki to the new page format:	(In the old image, do a backup:)		| mine | mine _ PWS actions at: 'myswiki'.		mine saveTo: mine path,'backup28JanA'.	(Quit.  Start the new image which has this version of the Swiki code)	(Do not start the server!!!!!!)		PWS initializeAll.		SwikiAction restore: 'myswiki' from:			(ServerAction serverDirectory), 'myswiki:backup28JanA'.		(PWS actions at: 'myswiki' asLowercase) convert.	(do these steps for each Swiki you have)	(now, start the server)	PWS serveOnPort: 80 loggingTo: 'log.txt'."!]style[(10 712 46 2904)f1b,f1,f3,f1! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:20'!initializeAll	| anAuthorizer |	(self checkVersion) ifFalse: [^ false].	anAuthorizer _ Authorizer new.	anAuthorizer realm: 'AuthorizedSpace'."	anAuthorizer mapName: 'JSmith' password: 'hard2guess' to: 'JSmith'.  "		"No default account!!  See howToStart to enable remote code execution."	self link: 'authorized' to: (AuthorizedServerAction new authorizer: anAuthorizer).	self link: 'chat' to: ChatPage new.	self link: 'default' to: ServerAction new.	self link: 'embedded' to: EmbeddedServerAction new.	self link: 'smtlk' to: CodeServer new.	self link: 'chunk' to: CodeServer new.	Comment setUpExample.	self link: 'comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).! !!PWS class methodsFor: 'Serving' stamp: 'jm 10/3/1998 08:48'!doBackupJobs	"This is just a wrapper so we don't have to restart the server loop when we add/remove jobs."	| problemReport |	BackupJobs do: [:block |		problemReport _ nil.		[block value] ifError: [:msg :rec |			problemReport _ '*** ', rec asString, ': ', msg asString].		problemReport ifNotNil: [^ problemReport]].	^ 'Backup jobs completed'! !!PWS class methodsFor: 'Serving' stamp: 'tk 7/15/1998 11:27'!serveShowingErrorsOnPort: portNumber	"Start up the HTTP server loop for debugging!!  Operate in thisprocess, synchronously.  Force errors to stop the server and show on thescreen.."	| socket logEntry inst |	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: 'dummy.log'.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil			ifTrue: ["serve:"				inst _ self new.				inst initializeFrom: socket.				inst getReply.				socket closeAndDestroy: 30.				logEntry _ inst log contents]		"nologging for now"			ifFalse: [(Delay forMilliseconds: 100) wait]].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:02'!loadOnImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadOnImage: 'NoSh_on.bmp'.		AllOnImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button onImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:02'!loadPressedImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadPressedImage: 'NoSh_on.bmp'.		AllPressedImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button pressedImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:01'!loadRotScalePics	"Load up class vars with .bmp files for the images of the Rotation control button and the Scale control button."	rotationTabForm _ (Form fromBMPFileNamed: 'Rotaball.bmp') asFormOfDepth: 16.	scaleTabForm _ (Form fromBMPFileNamed: 'Scalball.bmp') asFormOfDepth: 16.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:01'!loadoffImage: fileName	"Read in and convert the background image for the paintBox.  Allbuttons off.  A .bmp 24-bit image."	"	Prototype loadoffImage: 'roundedPalette3.bmp'	"	| pic16Bit blt type getBounds |	type _ 'bmp'.  " gif or bmp  "	getBounds _ 'fromPic'.	"fromUser = draw out rect of paintbox on image"		"fromOB = just read in new bits, keep same size and place as last time."		"fromPic = picture is just the PaintBox, use its bounds"type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].	getBounds = 'fromPic' ifTrue: [OriginalBounds _ pic16Bit boundingBox].	].		"Use OriginalBounds as it was last time".type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].		"Use OriginalBounds as it was last time".	(getBounds = 'fromPic') ifTrue: [OriginalBounds _ pic16Bit boundingBox].	AllOffImage _ Form extent: OriginalBounds extent depth: 16.	].type = 'gif' ifTrue: [	AllOffImage _ ColorForm extent: OriginalBounds extent depth: 8.	AllOffImage colors: pic16Bit colors].	blt _ BitBlt toForm: AllOffImage.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.type = 'bmp' ifTrue: [AllOffImage removeZeroPixelsFromForm].	self image: AllOffImage.	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 6/11/1998 11:25'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting.				self setAction: #paint:]].! !!PaintBoxMorph class methodsFor: 'all' stamp: 'sw 10/19/1998 23:17'!flushPrototype	"Later we will be a subclass of Model, and it will have a general version of this"	Prototype _ self new! !!PaintBoxMorph class methodsFor: 'all' stamp: 'tk 8/13/1998 13:00'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ FormCanvas on: button onImage.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 7/16/1998 00:02'!initialize	super initialize.	self image: (ScriptingSystem formAtKey: 'Painting')! !!PaintInvokingMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:03'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor ifFalse: [^ self].	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !!PaintInvokingMorph class methodsFor: 'all' stamp: 'sw 7/15/1998 21:24'!authoringPrototype	^ self new image: (ScriptingSystem formAtKey: 'Painting'); markAsPartsDonor; yourself! !!Paragraph methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:48'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'composition' stamp: 'jm 5/29/1998 14:48'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/6/1998 08:41'!initialize	"Initialize a new ParagraphEditor."	super initialize.	self initializeYellowButtonMenu.! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 23:57'!stateArray	^ (Array with: ChangeText		with: FindText		with: UndoInterval		with: UndoMessage) ,	(Array  with: UndoParagraph		with: UndoSelection		with: Undone) ,	(Array with: self selectionInterval		with: self startOfTyping		with: emphasisHere)! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing' stamp: 'di 10/6/1998 00:02'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/5/1998 21:55'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 11/2/1998 09:43'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	startBlock = stopBlock ifTrue: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/29/1998 20:09'!prettyPrint	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model selectedMessageName ifNil: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 12/20/1998 22:41'!selectedSelector	"Try to make a selector out of the current text selection.	Incorporated Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel _  self selection string withBlanksTrimmed.	(sel includes: $:) ifTrue:		[possibleParens _ sel findTokens: Character separators.		sel _ String streamContents:			[:s | level _ 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n _ token occurrencesOf: $( ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $[ ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $] ) > 0 ifTrue: [level _ level - n].							(n _ token occurrencesOf: $) ) > 0 ifTrue: [level _ level - n]]]]].	sel isEmpty ifTrue: [^ nil].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 1/13/1999 13:25'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down. 3/13/96 sw	 5/27/96 sw: added font menu"	^ PopUpMenu labels: 'set font... (k)set style... (K)explainpretty printfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with it (E)method source with itspecial menu...more...' 		lines: #(2 7 14).! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 8/24/1998 09:56'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  Inconvenient to have it here in this separate method; when/if we consolidate via a class variable, as for unshifted, the problem will go away.  1/17/96 sw	 3/7/96 sw: added methodSourceContainingIt	 3/13/96 sw: merged ParagraphEditor and StringHolderController versions into ParagraphEditor, and deleted the StringHolderController versions	 5/27/96 sw: added offerFontMenu	 8/20/96 sw: makeover"	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu unshiftedYellowButtonActivity)"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 6/26/1998 15:04'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesAndSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'wod 11/3/1998 15:44'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	sensor keyboard.	self selectFrom: startIndex to: startIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:43'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [self startOfTyping].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ startBlock stringIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:31'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin start stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			start _ startBlock stringIndex.			stop _ stopBlock stringIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:39'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ startBlock stringIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 12/16/1998 13:14'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	startBlock = stopBlock ifFalse: [UndoSelection _ self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	startBlock _ stopBlock copy.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 12/17/1998 09:41'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'private' stamp: 'di 11/25/1998 14:40'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: stopBlock stringIndex				caseSensitive: ChangeText ~~ FindText.	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'di 1/13/1999 13:34'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	Marked this method changed to trigger reinit" 	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 1/13/1999 13:29'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].	ShiftCmdActions _ cmdMap.! !!ParseNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:08'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	"Show comments in red"	aStream withAttribute: (TextColor color: Color red)		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!Parser methodsFor: 'public access' stamp: 'di 10/9/1998 16:22'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth |	self init: sourceStream notifying: req failBlock: [^aBlock value].	doitFlag _ noPattern.	encoder _ Encoder new init: class context: ctxt notifying: self.	failBlock_ aBlock.	meth _ self method: noPattern context: ctxt.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^meth! !!Parser methodsFor: 'scanning' stamp: 'sn 9/19/97 19:32'!advance    | this |    prevMark _ hereMark.    prevToken _ "Now means prev size"        self previousTokenSize.    this _ here.    here _ token.    hereType _ tokenType.    hereMark _ mark.    self scanToken.    ^this! !!Parser methodsFor: 'error handling' stamp: 'di 10/9/1998 16:23'!notify: string at: location	requestor isNil		ifTrue: [encoder == self ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxError 					errorInClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser methodsFor: 'error correction' stamp: 'tk 8/11/1998 21:52'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Parser methodsFor: 'private' stamp: 'sn 9/19/97 19:31'!previousTokenSize    "Answer the size of the previous token. Bugfix for Strings."    hereType == #number ifTrue: [^mark - prevMark].    hereType == #string ifTrue: [^here size + 2].    "One for eachsingle quote"    ^here size! !!Parser methodsFor: 'primitives' stamp: 'ar 10/7/1998 20:15'!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse:[^0].	prim _ here.	(self match: #number) ifTrue:[^prim].	"Indexed primitives"	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^117! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'tk 8/13/1998 16:52'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy isPartsDonor: false]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PartsBinMorph class methodsFor: 'all' stamp: 'sw 8/19/1998 15:18'!includeInNewMorphMenu	"Not to be instantiated from the menu. The PartsBinMorph is misleadingly named, and is extremely special-purpose"	^ false! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 10/21/1998 09:39'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 11/7/1998 22:36'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: self morph;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  30@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ self morph updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 1/11/1999 22:17'!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self enforceTileColorPolicy. "prematurely here to avoid momentarily flashing wrong policy"	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self enforceTileColorPolicy.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self layoutChanged.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 10/21/1998 16:44'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 11/9/1998 18:27'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 09:54'!coloredTilesEnabled	self flag: #isThisEverCalled.	^ self presenter coloredTilesEnabled! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!PartsViewer methodsFor: 'misc' stamp: 'sw 12/4/1998 15:46'!objectViewed	^ scriptedPlayer costume! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/15/1998 15:22'!presenter	^ super presenter ifNil:		[scriptedPlayer costume presenter]! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:55'!caretColor	^ CaretColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 11/9/1998 18:27'!commandTiles	"Return a list of tiles for my scriptedPlayer's commands."	| resultType cmd m argType argTile selfTile aRow names bank  |	names _ scriptedPlayer class namedTileScriptSelectors.	bank _ self scriptsBank.	^ (scriptedPlayer typedCommandsForBank: bank) collect: [:entry |		aRow _ PartsBinMorph newRow borderWidth: 0;			color: self color.		resultType _ (entry at: 1).		cmd _ (entry at: 2).		entry size = 2			ifTrue:				[m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player.				(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]			ifFalse: 				[argType _ entry at: 3.				m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ scriptedPlayer tileForArgType: argType.				argTile position: m lastSubmorph position.				m lastSubmorph addMorph: argTile.				m markAsPartsDonor].		selfTile _ self tileForSelf.		selfTile position: m firstSubmorph position.		m firstSubmorph addMorph: selfTile.			aRow addMorph: (ScriptingSystem tryButtonFor: m).		aRow addMorphBack: (Morph new extent: 4@2; color: self color).		aRow addMorphBack: m.		aRow beSticky; openToDragNDrop: false.		aRow]	"	m addMorphFront: (Morph new color: self color; extent: 2@10). "! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/22/1998 00:13'!commandTilesPartsBin	| bin |	bin _ PhraseWrapperMorph new		color: self color;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: self commandTiles.	^ bin! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:56'!controlButtonColor	^ ControlButtonColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/23/1998 14:12'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot]).	^ aButton! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/15/1998 13:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:08'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:09'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/15/1998 17:23'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeScripts	| r aButton aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'add script' font: (aFont _ StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'add inst var' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	r addMorphBack: aButton.	^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/10/1998 14:32'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(TilePadMorph colorForType: #color)).	^ outerPhrase! !!PartsViewer methodsFor: 'private' stamp: 'sw 7/3/1998 17:31'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ TilePadMorph colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!PartsViewer methodsFor: 'type coercion' stamp: 'sw 11/9/1998 18:26'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel _ (retrieverType == #number)		ifTrue:		[#<]		ifFalse:		[#=].	outerPhrase _ PhraseTileMorph new setOperator: rel type: #boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase _  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #player.	getterPhrase submorphs last setSlotRefOperator: (Utilities inherentSelectorForGetter: retrieverOp).	receiverTile _ (self tileForPlayer: aPlayer) bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile _ aPlayer tileForArgType: retrieverType.	retrieverType == #number ifTrue: [finalTile addArrows].	outerPhrase submorphs last addMorph: finalTile.	^ outerPhrase! !!PartsViewer methodsFor: 'copying' stamp: 'tk 1/7/1999 16:38'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.scriptedPlayer _ deepCopier references at: scriptedPlayer ifAbsent: [scriptedPlayer].! !!PartsViewer methodsFor: 'copying' stamp: 'tk 1/7/1999 16:37'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."scriptedPlayer _ scriptedPlayer.		Weakly copied"partsBank _ partsBank veryDeepCopyWith: deepCopier.scriptsBank _ scriptsBank veryDeepCopyWith: deepCopier.! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 17:55'!includeInNewMorphMenu	^ false! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 18:00'!initialize	"PartsViewer initialize"	CaretColor _ Color green muchLighter.	ControlButtonColor _  Color green muchLighter! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 16:41'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'parts window controls...' action: #invokePartsWindowMenu! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:48'!adjustBookControls	| inner |	prevButton ifNil: [^ self].	prevButton align: prevButton topLeft with: (inner _ self innerBounds) topLeft + (20@0).	nextButton align: nextButton topRight with: inner topRight - (20@0).	menuButton align: menuButton topLeft with: inner topLeft + (40@5).! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/1/1998 10:10'!book: aBook	book _ aBook.	self addMorph: aBook frame: (0@0 extent: 1@1).	book beSticky.	book hResizing: #none; vResizing: #none.	nextButton target: aBook.	prevButton target: aBook! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!closeEditing	openForEditing _ false.	self color: Color white.	book pages do:		[:aPage | aPage setPartsBinStatusTo: true]! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:44'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!initialize	| aFont aForm |	super initialize.	color _ Color white.	openForEditing _ false.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (prevButton _ SimpleButtonMorph new borderWidth: 0;			label: '<' font: aFont; color: Color transparent;			setBalloonText: 'previous page';			actionSelector: #previousPage; target: self; extent: 16@16).	self addMorph: (nextButton _ SimpleButtonMorph new borderWidth: 0;			label: '>' font: aFont; color: Color transparent;			setBalloonText: 'next page';			actionSelector: #nextPage; target: self; extent: 16@16).	menuButton _ ThreePhaseButtonMorph new onImage: (aForm _ ScriptingSystem formAtKey: 'OfferToUnlock'); offImage: (ScriptingSystem formAtKey: 'OfferToLock'); pressedImage: (ScriptingSystem formAtKey: 'OfferToLock'); extent: aForm extent; state: #on.	menuButton target: self; actionSelector: #toggleStatus; actWhen: #buttonUp.	menuButton setBalloonText: 'open for editing'.	self addMorph: menuButton."	self addMorph: (menuButton _ SimpleButtonMorph new borderWidth: 0;			label: '' font: aFont; color: Color transparent;			actWhen: #buttonDown;			actionSelector: #invokePartsWindowMenu; target: self; extent: 16@16)."	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 17:35'!invokePartsWindowMenu	| aMenu sel |	aMenu _ MVCMenuMorph new.	openForEditing		ifTrue:			[aMenu add: 'resume being a parts bin' action:	#toggleStatus]		ifFalse:			[aMenu add: 'open for editing'			action:	#toggleStatus].	aMenu add: 'sort pages'	action: #sortPages.	aMenu add: 'save as Custom Parts Bin' action: #saveAsCustomPartsBin.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!openEditing	openForEditing _ true.	self color: Color green.	book pages do:		[:aPage | aPage setPartsBinStatusTo: false]! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/12/1998 17:46'!saveAsCustomPartsBin	| aBin |	self closeEditing.	labelString = 'Standard Parts' ifTrue: [self setLabel: 'Custom Parts'].	aBin _ self veryDeepCopy.	ScriptingSystem setCustomPartsBinFrom: aBin.	self inform: 'Okay; from now on, when you request''custom parts bin'' from the ''authoring tools...''menu, you will obtain a copy of this parts bin'! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:57'!setBoundsOfPaneMorphs	| panelRect bookBorder bookExtent |	panelRect _ self panelRect.	book ifNotNil:		[book bounds: ((panelRect origin + (bookBorder _ book borderWidth asPoint)) 			extent: (bookExtent _ panelRect extent - (2 * bookBorder))).		book resizePagesTo: (bookExtent - (7 @ 7))]! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:12'!sortPages	book sortPages! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!toggleStatus	openForEditing _ openForEditing not.	openForEditing		ifTrue:			[self openEditing.			menuButton state: #off.			menuButton setBalloonText: 'resume being a parts bin']		ifFalse:			[self closeEditing.			menuButton state: #on.			menuButton setBalloonText: 'open for editing']! !!PasteUpMorph methodsFor: 'initialization' stamp: 'di 9/3/1998 09:19'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	gradientDirection _ #vertical.	color _ Color r: 0.8 g: 1.0 b: 0.6.	fillColor2 _ color.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	openToDragNDrop _ true.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'display' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!PasteUpMorph methodsFor: 'display' stamp: 'di 9/3/1998 09:16'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	turtleTrailsForm ifNotNil: [aCanvas image: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 7/2/1998 15:09'!padding	^ padding! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:56'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/18/1998 09:10'!automaticPhraseExpansion	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/17/1998 12:58'!automaticViewing	^ (self standardPalette ~~ nil) and: [self hasProperty: #automaticViewing]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 11/13/1998 09:54'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing norWiderThan: self maximumThumbnailWidth thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 1/11/1999 20:05'!repelsMorph: aMorph event: ev	(Preferences allowSysWindowEmbedding not and:		[aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	self visible ifFalse: [^ false].	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 11/12/1998 18:01'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy restoreSuspendedEventHandler ]].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/2/1998 14:51'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 1/11/1999 17:50'!wantsDroppedMorph: aMorph event: evt	self visible ifFalse: [^ false].	(self isPartsBin or: [self openToDragNDrop]) not ifTrue: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences allowSysWindowEmbedding not])		ifTrue:	[^ false].	((aMorph isKindOf: BookPageSorterMorph) and: [self isWorldMorph not])		ifTrue:	[^ false].	^ true! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 8/3/1998 13:43'!laySubpartsOutInOneRow	| aPosition |	aPosition _ 0 @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition _ aMorph topRight]! !!PasteUpMorph methodsFor: 'layout' stamp: 'tk 10/22/1998 13:55'!layoutChanged	super layoutChanged.	(self valueOfProperty: #SqueakPage) ifNotNil: [		self setProperty: #pageDirty toValue: true].		"I am the morph of a SqueakPage, I have changed and 		need to be written out again"! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/1998 13:22'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self addStackMenuItems: menu hand: aHandMorph.	self addPenMenuItems: menu hand: aHandMorph.	self addPlayfieldMenuItems: menu hand: aHandMorph.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #paintBackground to: self."	aHalo addHandleAt: box leftCenter color: Color veryVeryLightGray on: #mouseDown send: #makeNewDrawingWithin to: self."! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:11'!addPenMenuItems: menu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tk 11/23/1998 15:09'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:10'!addStackMenuItems: menu hand: aHandMorph	| subMenu |	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 9/9/1998 13:21'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ super debuggingMenuFor: aHandMorph.	aMenu add:  'abandon costume history' target: self action: #abandonCostumeHistory.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 1/11/1999 17:51'!wantsHaloFor: aSubMorph	^ self visible and: [(isPartsBin ~~ true and: [openToDragNDrop ~~ false]) and:		[self wantsMouseOverHalos]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/28/1998 13:15'!automaticViewing: aBoolean	self setProperty: #automaticViewing toValue: aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 11/13/1998 09:55'!replaceTallSubmorphsByThumbnails	|  itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails _ self maximumThumbnailWidth.	self submorphs do:		[:aMorph |			itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[self replaceSubmorph: aMorph by: itsThumbnail]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/8/1998 16:46'!setPartsBinStatusTo: aBoolean	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ aBoolean.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m stopStepping.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:16'!setThumbnailHeight	|  reply |	reply _ FillInTheBlank		request: 'New height for thumbnails? '		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply _ reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!'].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:26'!toggleAlwaysShowThumbnail	(self hasProperty: #alwaysShowThumbnail)		ifTrue:			[self removeProperty: #alwaysShowThumbnail]		ifFalse:			[self setProperty: #alwaysShowThumbnail toValue: true].	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand _ self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current _ self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/30/1998 17:24'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	self setPartsBinStatusTo: self isPartsBin not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/8/1998 10:58'!toggleMouseOverHalos	wantsMouseOverHalos _ self wantsMouseOverHalos not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 11/13/1998 09:56'!updateSubmorphThumbnails	| thumbsUp itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	thumbsUp _ self alwaysShowThumbnail.	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails _ self maximumThumbnailWidth.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos	^ wantsMouseOverHalos == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos _ aBoolean! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 19:16'!makeNewDrawingWithin	| bnds |	bnds _ self paintingBoundsAround: self boundsInWorld center.	self primaryHand makeNewDrawingInBounds: bnds pasteUpMorph: self.! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 9/22/1998 12:26'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ self reasonablePaintingExtent.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 9/29/1998 07:35'!reasonablePaintingExtent	^ Preferences unlimitedPaintArea		ifTrue:			[3000 @ 3000]		ifFalse:			[Preferences defaultPaintingExtent]! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 09:27'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds. On return, turtleTrailsForm exists and is the correct size."	| newForm |	turtleTrailsForm ifNil: [		"create new turtleTrailsForm if needed"		turtleTrailsForm _ Form extent: self extent depth: 8.		turtlePen _ Pen newOnForm: turtleTrailsForm.		^ self].	turtleTrailsForm extent = self extent ifFalse: [		"resize turtleTrailsForm if my size has changed"		newForm _ Form extent: self extent depth: 8.		newForm copy: self bounds from: turtleTrailsForm					to: 0@0 rule: Form paint.		turtleTrailsForm _ newForm.		turtlePen _ Pen newOnForm: turtleTrailsForm].! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 10:44'!drawPenTrailFor: aMorph from: oldPoint to: newPoint	"Draw a pen trail for aMorph, using its pen state (the pen is assumed to be down)."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin mPenSize offset |	self createOrResizeTrailsForm.	origin _ self topLeft.	mPenSize _ aMorph getPenSize.	turtlePen sourceForm width ~= mPenSize		ifTrue: [turtlePen squareNib: mPenSize].	offset _ (mPenSize // 2)@(mPenSize // 2).	turtlePen color: aMorph getPenColor.	turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint.	self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!liftAllPens	submorphs do: [:m | m assuredPlayer liftPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!lowerAllPens	submorphs do: [:m | m assuredPlayer lowerPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/10/1998 16:17'!trailMorph	"Yes, you can draw trails on me."	^ self! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 8/30/1998 09:44'!allTileScriptingElements	^ self allMorphs select:		[:s | s isTileScriptingElement]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 9/15/1998 13:37'!emptyAnonymousScriptorFrom: aPlaceHoldingMorph	| aScriptor aPlayer |	aPlayer _ aPlaceHoldingMorph valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer anonymousScriptEditorFor: nil.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 6/18/1998 09:17'!expandPhrasesToScripts	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:47'!becomeStack	currentDataInstance _ self assuredPlayer.	dataInstances _ OrderedCollection with: currentDataInstance.	isStackLike _ true.	self borderWidth: (self borderWidth + 1).	submorphs do:		[:aMorph | aMorph holdsDataForEachInstance			ifTrue:				[aMorph becomeField]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:50'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	self player: anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 9/9/1998 10:45'!abandonCostumeHistory	self allMorphsDo:		[:m | m player ifNotNil: [m player forgetOtherCostumes]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:46'!allScriptEditors	^ self allMorphs select:		[:s | s isKindOf: ScriptEditorMorph]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:19'!alwaysShowThumbnail	^ self hasProperty: #alwaysShowThumbnail! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 12/23/1998 14:44'!cachedOrNewThumbnailFrom: newThumbnail	"If I have a cached thumbnail, and it is of the desired extent, then ruturn it.	Otherwise produce one in newThumbnail and return it (after caching).	This code parallels what happens in page: to match resultant extent."	| cachedThumbnail scale ext |	scale _ newThumbnail height / self fullBounds height.	ext _ (self fullBounds extent * scale) truncated.	(cachedThumbnail _ self valueOfProperty: #cachedThumbnail) ifNotNil:		[cachedThumbnail extent = ext ifTrue: [^ cachedThumbnail]].	self setProperty: #cachedThumbnail toValue: (newThumbnail page: self).	^ newThumbnail! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/8/1998 16:50'!heightForThumbnails	^ self valueOfProperty: #heightForThumbnails ifAbsent: [50]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/11/1998 13:45'!impartPrivatePresenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles.		presenter standardPlayer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'jm 9/11/1998 09:40'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	owner ifNotNil: [owner invalidRect: (damageRect intersect: bounds)].! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/11/1998 16:13'!makeDetachable	presenter ifNil:		[self impartPrivatePresenter.		self borderWidth: 1;  borderColor: Color green darker]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/8/1998 16:50'!maxHeightToAvoidThumbnailing	^ self valueOfProperty: #maxHeightToAvoidThumbnailing ifAbsent: [80]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/13/1998 10:06'!maximumThumbnailWidth	^ self valueOfProperty: #maximumThumbnailWidth ifAbsent: [200 min: (self width - 10)]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/5/1999 16:07'!mouseX	^ self isInWorld		ifTrue:			[(self cursorPoint x) - self left]		ifFalse:			[0]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/5/1999 16:55'!mouseY	^ self isInWorld		ifTrue:			[self bottom - (self cursorPoint y)]		ifFalse:			[0]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/17/1998 12:06'!navigateTo	self inform: 'Not quite yet!!Later, you can directly retargetthis area so that it displays thecontents of any url'.! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 9/3/1998 09:19'!prepareToBeSaved	super prepareToBeSaved.	turtlePen _ nil! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 22:02'!removeScriptingControls	self deleteSubmorphsWithProperty: #scriptingControl! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/1998 22:53'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	self autoLineLayout		ifTrue:			[self fixLayout]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/25/1998 09:26'!roundUpStrays	self submorphsDo:		[:m |			m goHome.			m isPlayfieldLike ifTrue: [m roundUpStrays]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 18:13'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:")].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 12/23/1998 14:45'!smallThumbnailForPageSorter	^ self cachedOrNewThumbnailFrom: BookPageThumbnailMorph new smaller! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:34'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self presenter flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self presenter allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/1/1999 16:08'!stepAll	self presenter allExtantPlayers do:		[:aPlayer | 			aPlayer startRunning; step; stopRunning]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/1/1999 16:08'!stopRunningAll	"Stop running all scripted morphs.  Triggered by user hitting STOP button"	self presenter allExtantPlayers do: [:aPlayer |		aPlayer stopRunning].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 12/23/1998 14:44'!thumbnailForPageSorter	^ self cachedOrNewThumbnailFrom: BookPageThumbnailMorph new! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/1/1999 16:04'!unhideHiddenObjects	self allMorphsDo:		[:m | m show]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:47'!updateStatusForAllScriptEditors	self allScriptEditors do: [:anEditor | anEditor updateStatus]! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcep0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepcbbfgcc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from BookPageMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 6/18/1998 10:31'!convertbosfcepcbbfgccpmcpbttloiairfidcuw0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"These variables are automatically stored into the new instance ('presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'openToDragNDrop' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle')."	"Incoming morphs have extra inst var: 'wantsMouseOverHalos'"! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 11/11/1998 17:33'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter;  extent: 100 @ 80; borderColor: (Color r: 0.645 g: 0.935 b: 0.161).	proto setProperty: #expandedExtent toValue: 300 @ 240.	proto beSticky.	^ proto! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points == nil ifTrue:		[points _ OrderedCollection new: 1000.		points addLast: p1].	points addLast: p2! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!actualObject	"Answer the player that's the object of my attention"	^ self associatedPlayer! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!associatedPlayer	"Answer the player that's the object of my attention"	^ self firstSubmorph firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:00'!brightenTiles	brightenedOnEnter _ true.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem brightColorFor: m color)]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!catchDivideByZero: aStream indent: tabCount	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	(submorphs at: 2) type = #operator ifFalse: [^ false].		"not me"	(submorphs at: 2) operatorOrExpression == #/ ifFalse: [^ false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs at: 3) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| aStream |	aStream _ ReadWriteStream on: ''.	self storeCodeOn: aStream indent: 1.	^ aStream contents! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:24'!handlesDragOver: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:57'!handlesMouseOverDragging: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 12/21/1998 12:10'!isCommand	"Answer whether the receiver is a true line of phrase-command.  If not, it is a fragment that will not be able to serve as a line of script on its own"	| rcvrTile pad |	pad _ submorphs first.	(pad isKindOf: TilePadMorph) ifTrue:		[(submorphs second isKindOf: AssignmentTileMorph) ifTrue: [^ true].		(((rcvrTile _ pad submorphs first) isKindOf: TileMorph) and: [rcvrTile isPossessive]) ifTrue: [^ false]].	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:15'!isPossessive	^ false! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/21/1998 09:41'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	| aPartsViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aPartsViewer _ PartsViewer new invisiblySetPlayer: aPlayer.		aPhrase _ aPartsViewer booleanPhraseFromPhrase: self.		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:46'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((TileMorph new setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: argType)]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01'!setSlotRefOperator: opSymbol type: opType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	"Add in some smarts for division by zero."	aStream nextPut: $(.	(submorphs at: 1) storeCodeOn: aStream indent: tabCount.	aStream space.	(submorphs at: 2) storeCodeOn: aStream indent: tabCount.	submorphs size > 2 ifTrue: [		(self catchDivideByZero: aStream indent: tabCount) ifFalse: [			aStream space.			(submorphs at: 3) storeCodeOn: aStream indent: tabCount]].	aStream nextPut: $).! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:57'!try	| aPlayer |	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false].	(Delay forMilliseconds: 200) wait! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:48'!unbrightenTiles	brightenedOnEnter ifFalse: [^ self].	brightenedOnEnter _ false.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem unbrightColorFor: m color)]]! !An alignment morph designed for use in scripting Viewers; it wraps a set of phrases in a category viewer, and repels attempts to drop phrases upon it.!!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 5/6/1998 18:13'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or: [aMorph hasProperty: #newAnonymousScript]! !!PhraseWrapperMorph class methodsFor: 'all' stamp: 'sw 11/9/1998 16:16'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 17:05'!initialize	super initialize.	self color: Color black.	whiteKeyColor _ Color veryLightGray.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 11/13/1998 08:43'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	event hand hasSubmorphs ifTrue: [^ self  "no response if drag something over me"].	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 23.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/9/1998 10:45'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [soundPlaying stopGracefully].! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 12:57'!soundPrototype: aSound	soundPrototype _ aSound! !PianoRollNoteMorphs, as their name implies, are used to display musical notes on a piano roll.  The design is centered around speed of display, compact representation through sharing, and the ability to display in any color without having to make new note forms.The note shapes are stored as ColorForms, which are then displayed in paint mode (0 is transparent) using the individual note color in the color map.Each note carries an offset which can be used to display complex note shapes so that the center of the note ellipse appears in the proper location.!!PianoRollNoteMorph methodsFor: 'all' stamp: 'di 8/28/1998 15:51'!drawOn: aCanvas	image replaceColorAtIndex: NoteColorIndex with: color.	super drawOn: aCanvas! !!PianoRollNoteMorph methodsFor: 'all' stamp: 'di 8/31/1998 11:31'!newBounds: boundRect color: fillColor image: noteForm	"This message incorporates all necessary initialization for enhanced performance"	bounds _ boundRect.	owner _ nil.	submorphs _ EmptyArray.	color _ fillColor.	image _ noteForm! !!PianoRollNoteMorph class methodsFor: 'class initialization' stamp: 'di 8/29/1998 06:07'!initialize  "PianoRollNoteMorph initialize"	| j1 dot j2 noteColor |	NoteForms _ Array new: 200.	NoteColorIndex _ 250.	noteColor _ Color indexedColors at: NoteColorIndex.	j1 _ 1.	6 to: 28 do: 		[:i | dot _ ((EllipseMorph newBounds: (0@0 extent: i@i) color: noteColor)					imageFormDepth: 8) as8BitColorForm.		j2 _ i*i//4.		j1 to: j2 do: [:j | NoteForms at: j put: dot].		j1 _ j2+1].	j1 to: NoteForms size do: [:j | NoteForms at: j put: dot].! !!PianoRollNoteMorph class methodsFor: 'instance creation' stamp: 'di 8/31/1998 11:32'!newBounds: boundsRect color: trackColor	"boundsRect is the rectangle for old-style piano roll notes."	| noteForm locPoint |	noteForm _ NoteForms atPin: boundsRect width.	locPoint _ boundsRect topLeft + (0@(1 - (noteForm height//2))).	^ self basicNew		newBounds: (locPoint extent: noteForm extent)		color: trackColor		image: noteForm! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:08'!acceptDroppingMorph: aMorph event: evt	"In addition to placing this morph in the pianoRoll, add a corresponding	event to the score so that it will always appear when played, in addition	to possibly triggering other actions"	| ambientEvent |	ambientEvent _ AmbientEvent new morph: aMorph;							time: (self timeForX: aMorph left).	super acceptDroppingMorph: aMorph event: evt.	score addAmbientEvent: ambientEvent.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 15:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #openToDragAndDrop) == true	ifTrue: [aCustomMenu add: 'close drag anddrop' action: #closeDragAndDrop]	ifFalse: [aCustomMenu add: 'open drag and drop' action: #openDragAndDrop]! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 10/20/1998 15:15'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"		track _ score ambientTrack.		i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								("PianoRollNoteMorph"  Morph  "<-- Change comment quotes here**"									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!contractTime	timeScale _ timeScale / 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:20'!drawOn: aCanvas	| innerBox center |	super drawOn: aCanvas.	self drawStaffOn: aCanvas.	innerBox _ self innerBounds.	center _ innerBox center x.	aCanvas		fillRectangle: (center@innerBox top corner: (center + 1)@innerBox bottom)		color: Color red.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:01'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	blackKeyColor _ Color gray: 0.7.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!expandTime	timeScale _ timeScale * 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:33'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	fullBounds ifNil: [fullBounds _ bounds].	^ bounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 8/27/1998 16:39'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 18:59'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 07:52'!isBlackKey: midiKey	"Answer true if the given MIDI key corresponds to a black key on the piano keyboard."	| note |	note _ midiKey \\ 12.	note = 1 ifTrue: [^ true].	note = 3 ifTrue: [^ true].	note = 6 ifTrue: [^ true].	note = 8 ifTrue: [^ true].	note = 10 ifTrue: [^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:20'!layoutChanged	"Override this to avoid propagating 'layoutChanged' when just adding/removing note objects."	fullBounds = bounds ifTrue: [^ self].	super layoutChanged.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:03'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	lowestNote _ 24.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:48'!privateRemoveMorph: aMorph	score removeAmbientEventWithMorph: aMorph.	^ super privateRemoveMorph: aMorph! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/22/1998 09:33'!step	| t fudge |	score ifNil: [^ self].	approximateScreenUpdateTime ifNil: [approximateScreenUpdateTime _ 1000].	lastStepMSec ifNotNil: [		"compute the approximate redisplay time"		"Details: lastStepMSecs is set only when we've updated the piano roll, so		 this display time estimate is done on the cycle following an actual piano roll		 update. The goal is to adjust for different processor speeds automatically."		t _ Time millisecondClockValue - lastStepMSec.		(t > 0 and: [t < (4 * approximateScreenUpdateTime)]) ifTrue: [			"ignore clock wrap (i.e., t < 0) and very large values of t for stability"			approximateScreenUpdateTime _ (approximateScreenUpdateTime + t) // 2].		lastStepMSec _ nil].  "don't do this calculation again until the next real piano roll update"	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		lastStepMSec _ Time millisecondClockValue.		fudge _ 5.  "alignment tweak, in pixels"		self goToTime:			t - (((self width // 2) - borderWidth + fudge) asFloat / timeScale) truncated +			(scorePlayer ticksForMSecs: approximateScreenUpdateTime).		self addNotes.		lastUpdateTick _ t].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:07'!stepTime	^ 0! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:35'!timeForX: aNumber	^ ((aNumber - bounds left - borderWidth) asFloat / timeScale + leftEdgeTime) asInteger! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:29'!xForTime: aNumber	^ ((aNumber - leftEdgeTime) asFloat * timeScale) asInteger + bounds left + borderWidth! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:35'!yForMidiKey: midiKey	^ (bounds bottom - borderWidth - 4) - (3 * (midiKey - lowestNote))! !!PinMorph methodsFor: 'events' stamp: 'jm 5/29/1998 14:33'!handlesMouseDown: evt	^ (evt yellowButtonPressed | evt blueButtonPressed) not! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!bend	^ bend! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend	bend _ midiPitchBend.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend channel: midiChannel	bend _ midiPitchBend.	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isPitchBend	^ true! !!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rE0		channel: channel		byte: (bend bitAnd: 16r7F)		byte: (bend bitShift: -7).! !!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': bend '.	bend printOn: aStream.	aStream nextPut: $).! !!Player methodsFor: 'card/stack commands' stamp: 'sw 8/17/1998 17:23'!deleteCard	"Still underway"	true ifTrue: [^ self beep].	self costume deleteCard! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!firstPage	self sendMessageToCostume: #firstPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!goto: aPlayer	self sendMessageToCostume: #goto: with: aPlayer! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!lastPage	self sendMessageToCostume: #lastPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!nextPage	self sendMessageToCostume: #nextPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!previousPage	self sendMessageToCostume: #previousPage! !!Player methodsFor: 'clone' stamp: 'tk 8/31/1998 15:46'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this in mapUniClasses"	newCls slotInfo: self class privateSlotInfo deepCopy.	newCls copyAddedStateFrom: self class.  "All class inst vars for inter Player refs"	^ newCls! !!Player methodsFor: 'clone' stamp: 'sw 9/15/1998 13:12'!initializeCostumesFrom: aPlayer	"Used to copy costume info over from an UnscriptedPlayer to a Player UniClass"	costume _ aPlayer costume.	costumes _ aPlayer costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:42'!availableCostumesForArrows	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 9/21/1998 11:50'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds _ costume bounds.		costume owningHandOrPasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'sw 8/18/1998 11:47'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph _ self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes size > 0 ifTrue:  "This catches the nil and empty cases both"		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 9/15/1998 13:12'!costumes	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/21/1998 17:19'!costumesDo: aBlock	"Evaluate aBlock against every real (not flex) costume known to the receiver)"	aBlock value: costume renderedMorph.	costumes ifNotNil:		[(costumes copyWithout: costume) do:			[:aCostume | aBlock value: aCostume]]! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:57'!forgetOtherCostumes	costumes _ nil.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 11/10/1998 15:43'!hasCostumeOfClass: aClass	(costume renderedMorph class == aClass) ifTrue: [^ true].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ true]]].	^ false! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 16:37'!knownSketchCostumeWithSameFormAs: aSketchMorph	| itsForm rend |	itsForm _ aSketchMorph form.	(((rend _ costume renderedMorph) isKindOf: SketchMorph) and: [rend form == itsForm])		ifTrue:	[^ rend].	^ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:48'!newCostume	| aMenu reply |	aMenu _ SelectionMenu selections: self availableCostumeNames.	(reply _ aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume _ aMorph! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember _ aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes _ OrderedCollection new].	existing _ (costumeToRemember isKindOf: SketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes _ costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 11/10/1998 17:03'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner replaceSubmorph: costume by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			aMorph setNameTo: costume knownName.			costume _ aMorph]! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:55'!sendMessageToCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:54'!sendMessageToCostume: aSelector with: arg	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector with: arg].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume _ self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:51'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	| itsCostume |	itsCostume _ anotherPlayer costume renderedMorph.	(itsCostume isKindOf: SketchMorph)		ifTrue:			[self wearSketchCostumeResembling: itsCostume]		ifFalse:			[anotherPlayer costume player: nil.			self renderedCostume: itsCostume veryDeepCopy.			anotherPlayer costume player: anotherPlayer].	costume layoutChanged! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:39'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume _ aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 9/11/1998 16:02'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm cur degs chgd |	itsForm _ aSketchMorph form.	((cur _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cur form == itsForm ifTrue: [^ self]].	costumes size > 0 ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	chgd _ false.	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume originalForm: itsForm;		rotationCenter: aSketchMorph rotationCenter;		framesToDwell: aSketchMorph framesToDwell.		chgd _ true].	((cur isKindOf: SketchMorph) and: [cur rotationStyle ~~ #normal])			ifTrue:				[newCostume rotationStyle: cur rotationStyle.				newCostume rotationDegrees: cur rotationDegrees.				degs _ cur valueOfProperty: #setupAngle ifAbsent: [nil].				degs ifNotNil: [newCostume setupAngle: degs].				chgd _ true].	chgd ifTrue: [newCostume layoutChanged].	self renderedCostume: newCostume! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:12'!assureExternalName	| aCostume |	(aCostume _ self costume) knownName ifNil:		[aCostume setNameTo: aCostume externalName]! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:20'!renameTo: aName	self costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:22'!choosePenColor: evt	evt hand changeColorTarget:  self costume  selector: #penColor:! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!clearTurtleTrails	self costume clearTurtleTrails! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:12'!colorUnder	^ self costume colorUnder! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!liftAllPens	self costume liftAllPens! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!lowerAllPens	self costume lowerAllPens! !!Player methodsFor: 'slots-kernel' stamp: 'sw 12/31/1998 13:20'!categories	| aList aRef |	(self hasCostumeOfClass: WorldMorph)		ifTrue:	[^ self categoriesForWorld].	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack' 'playfield')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	self flag: #deferred."	((aRef _ self existingCostumeOfClass: ReferenceMorph) notNil and:		[aRef referent isKindOf: PaintBoxMorph])			ifTrue:	[aList add: 'paintbox'].      coming SOON, un-comment-out as soon                                                        as ReferenceMorph is shipped"	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 12/31/1998 12:49'!categoriesForWorld	"Answer the list of categories given that the receiver is the Player representing a World"	| aList |	aList _ #('basic' 'color & border' 'pen trails' 'playfield') asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/7/1998 22:31'!commandPhraseFor: commandSpec inViewer: aViewer	"Too lazy at the moment to do this cleanly"	| entry aRow resultType cmd m names argType argTile selfTile |	entry _ (commandSpec copy asOrderedCollection removeFirst; yourself) asArray.	names _ self class namedTileScriptSelectors.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	resultType _ (entry at: 1).	cmd _ (entry at: 2).	entry size = 2		ifTrue:			[m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player.			(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]		ifFalse: 			[argType _ entry at: 3.			m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	m markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	aRow addMorph: (ScriptingSystem tryButtonFor: m).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: m.	aRow beSticky; openToDragNDrop: false.	aRow addDetailButton.	^ aRow! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/30/1998 18:33'!phraseSpecFor: aPair	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| info prefix |	info _ (prefix _ aPair first) == #slot		ifTrue:			[ScriptingSystem slotInfoFor: aPair second]		ifFalse:			[ScriptingSystem scriptInfoFor: aPair second].	^ (Array with: prefix), info! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/21/1998 15:27'!slotPhraseFor: aSpec inViewer: aViewer	^ aViewer phraseForSlot: aSpec second type: aSpec third readOnly: aSpec fourth == #readOnly getSelector: aSpec fifth putSelector: aSpec sixth! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/7/1998 09:12'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/1998 16:46'!standardWorldSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver, special-cased for the situation where the receiver's costume is the World""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	aBank = 1 ifTrue: [^ #(		(x 			number		readOnly	getX					unused)		(y			number		readOnly	getY				unused))].	aBank = 4 ifTrue: [^ #(		(colorSees	boolean		readOnly	dummy				unused)		(width 		number		readOnly	getWidth			unused)		(height 		number		readOnly	getHeight			unused)		(left 		number		readOnly	getLeft				unused)		(right 		number		readOnly	getRight			unused)		(top 		number		readOnly	getTop				unused)		(bottom 		number		readOnly	getBottom			unused)		)].	^ #()! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 16:29'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/5/1998 19:59'!tileForArgType: typeSymbol inViewer: aViewer	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 15:51'!tilePhraseSpecsForPlayerCategory: aCategory	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| aList specList toks prefix |	aList _ (Player organization listAtCategoryNamed: aCategory asSymbol) collect:		[:aSelector |			prefix _ #(script).			specList _ ScriptingSystem scriptInfoFor: aSelector.			specList ifNil:				[specList _ OrderedCollection with: #command.				toks _ aSelector keywords.				toks do:					[:aTok |						specList add: aTok.						(aTok endsWith: ':') ifTrue: [specList add: #object]]].			prefix, specList].	^ aList select: [:spec | spec size < 5]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/22/1998 20:41'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return an array of phrases, each in one of the following two formats:		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	^ (self tilePhrasesSpecsForCategory: aCategory) collect:		[:aSpec |			aSpec first == #slot				ifTrue:					[self slotPhraseFor: aSpec inViewer: aViewer]				ifFalse:					[self commandPhraseFor: aSpec inViewer: aViewer]]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 1/1/1999 16:01'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString isWorld |	isWorld _ self hasCostumeOfClass: WorldMorph.	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))]			ifTrue:				[#((script beep:))]].	(aCategory = 'tests') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot isOverColor) (slot isUnderMouse) (slot colorSees))]			ifTrue:				[#()]].	(aCategory = 'color & border') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))]			ifTrue:				[#((slot color))]].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ isWorld			ifFalse:				[#((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]			ifTrue:				[#((script startScript:) (script stopScript:) (script pauseScript:))]].	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY)(script roundUpStrays) (script unhideHiddenObjects))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/6/1998 10:43'!typeForSlot: aSlotName	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	^ ScriptingSystem typeForSystemSlotNamed: aSlotName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 10/24/1998 23:15'!getAmount	^ self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAngle	^ self getValueFromCostume: #angle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderColor	^ self getValueFromCostume: #borderColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderWidth	^ self getValueFromCostume: #borderWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColor	^ self costume renderedMorph color! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColorUnder	^ self costume colorUnder! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getCursor	^ self getValueFromCostume: #cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:51'!getHeadingUnrounded	^ self costume forwardDirection asSmallAngleDegrees! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 10/7/1998 09:31'!getIsUnderMouse	costume isInWorld ifFalse: [^ false].	^ costume containsPoint: (costume pointFromWorld: costume primaryHand lastEvent cursorPoint)! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getLeft	^ self costume left! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getLeftRight	^ self getValueFromCostume: #leftRight! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!getMouseX	^ self costume mouseX! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getMouseY	^ self costume mouseY! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!getRotationStyle	^ self getValueFromCostume: #rotationStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getScaleFactor	| aCostume |	^ (aCostume _ self costume) isFlexMorph		ifTrue: [aCostume scale]		ifFalse: [1.0]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:42'!getUpDown	^ self getValueFromCostume: #upDown! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:50'!getY	^ self costume y! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderColor: aColor	self setCostumeSlot: #borderColor: toValue: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderWidth: aWidth	self setCostumeSlot: #borderWidth: toValue: aWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:24'!setColor: aColor	self costume renderedMorph color: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:16'!setCostume: someOtherMorph	^ self costume wearCostume: someOtherMorph! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:47'!setCursor: aNumber	self setCostumeSlot: #cursor: toValue: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'di 9/9/1998 20:13'!setHeading: newHeading	| aCostume |	aCostume _ self costume.	newHeading = 0.0		ifTrue: 			[self getScaleFactor = 1.0 ifTrue:				[aCostume isFlexMorph ifTrue:					[aCostume rotationDegrees: newHeading.					aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	self costume rotationDegrees: newHeading.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setName: aName	^ self costume renameTo: aName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!setRotationStyle: aStyle	self setCostumeSlot: #rotationStyle toValue: aStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/26/1998 21:40'!setScaleFactor: aNumber	| aCostume |	aCostume _ self costume.	1.0 = aNumber		ifTrue:			[0.0 = self getHeading ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	costume scale: (aNumber asFloat max: 0.125)! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume _ self costume.	((renderedMorph _ aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setX: val	^ self costume x: val! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:22'!setY: val	^ self costume y: val! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:33'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:36'!addSlotNamedLike: suggestedName withValue: aValue	| otherNames numericSuffix nameToUse  stem itsInfo |	stem _ suggestedName first asLowercase asString , suggestedName allButFirst.	stem _ stem stemAndNumericSuffix first.	nameToUse _ stem.	otherNames _ self class allInstVarNames.	numericSuffix _ 1.	[otherNames includes: nameToUse]		whileTrue: [numericSuffix _ numericSuffix + 1. (nameToUse _ stem, numericSuffix printString)].	self class addInstVarName: nameToUse.	self instVarAt: self class instSize put: aValue.  "Assumes added as last field"	self compileAccessorsFor: nameToUse.	itsInfo _ SlotInformation new type: aValue basicType.	self slotInfo at: nameToUse asSymbol put: itsInfo.	^ nameToUse! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:41'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	typeChoices _ #(number player boolean color point string costume).	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 8/11/1998 12:47'!compileInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self class compileUnlogged: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self class compileUnlogged: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil.! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:06'!initialValueForSlotOfType: aType	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color random].	aType == #string ifTrue: [^ 'abc'].	aType == #sound ifTrue: [^ 'croak'].	aType == #point ifTrue: [^ 20 @ 30].	^ nil! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:40'!slotInfoAt: slotName	| info |	info _ self slotInfo at: slotName ifAbsent: [nil].	info ifNil:		[self slotInfo at: slotName put: (info _ SlotInformation new)].	(info isKindOf: Symbol) "bkward compat"		ifTrue:			[self slotInfo at: slotName put: (info _ SlotInformation new type: info)].	^ info! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:20'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true.	aWatcher growable: true;		getSelector: (getSel _ Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName).	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	self costume primaryHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:23'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true;		getSelector: (Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	self costume primaryHand attachMorph: aWatcher! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:03'!valueOfType: aType from: oldValue	"The user has changed a slot's type to aType; convert its former value, oldValue, to something of the appropriate type.  For now, does not take oldValue into account"	^ self initialValueForSlotOfType: aType! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/11/1998 12:45'!acceptScript: aScriptEditorMorph for: aSelector	| classif |	classif _ aScriptEditorMorph isAnonymous ifTrue: ['anonymous scripts'] ifFalse: ['named scripts'].	self class		compileUnlogged: aScriptEditorMorph methodString		classified: classif		notifying: nil.	self class atSelector: aSelector putScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 11/19/1998 12:33'!anonymousScriptEditorFor: aPhraseTileMorph	| aScriptEditor aUserScript |	self isFlagshipForClass ifFalse:		[^ aPhraseTileMorph].	aUserScript _ self class anonymousUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph		ifNotNil:			[aScriptEditor scriptName: aUserScript selector phrase: aPhraseTileMorph]		ifNil:			[aScriptEditor startOutEmptyForScriptName: aUserScript selector].	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/18/1998 11:56'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym reply aType |	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MVCMenuMorph new.	aType == #number "later others" ifTrue:		[aMenu add: 'simple watcher' action: #simpleWatcher.		aMenu add: 'fancier watcher' action: #fancyWatcher].	(self slotInfo includesKey: (slotSym _ aSlotName asSymbol))		ifTrue:  "User slot"			[aMenu add: 'change data type' action: #chooseSlotType.			aMenu add: 'remove "', aSlotName, '"' action: #removeSlot.			aMenu add: 'rename  "', aSlotName, '"' action: #renameSlot].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	reply _  aMenu invokeAt: self costume primaryHand position in: self costume world.	reply == nil ifTrue: [^ self].	reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: slotSym].	reply == #removeSlot ifTrue: [^ self removeSlotNamed:  slotSym].	reply == #renameSlot ifTrue: [^ self renameSlot: slotSym].	reply == #simpleWatcher ifTrue: [^ self tearOffWatcherFor: slotSym].	reply == #fancyWatcher ifTrue: [^ self tearOffFancyWatcherFor: slotSym]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/20/1998 17:40'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self costume actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:13'!okayToDestroyScriptNamed: scriptName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:21'!okayToRemoveSlotNamed: aSlotName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 11/5/1998 10:33'!sourceCodeFor: sel	^ self class sourceCodeAt: sel ifAbsent: 		[Player sourceCodeAt: sel ifAbsent: ['this space for rent']]	! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/24/1998 22:31'!tileScriptCommands	"Return a list of typed-command arrays of the form:		#script <result type> <command> <argType>"	^  self class namedTileScriptSelectors asSortedArray collect:			[:sel | Array with: #script with: #command with: sel]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunning	self costume arrangeToStartStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunningScripts	self startRunning.	self costume arrangeToStartStepping.  "emergency patch, if not going already"	self costume presenter startRunningScripts! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!beep: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:22'!bounce: soundName	| box bounced aCostume |	(aCostume _ self costume) ifNil: [^ self].	(aCostume owner == nil or: [aCostume owner isHandMorph]) ifTrue: [^ self].	box _ aCostume owner bounds.	bounced _ false.	(aCostume left < box left)			ifTrue: [self headRight. bounced _ true].	(aCostume right > box right)		ifTrue: [self headLeft. bounced _ true].	(aCostume top < box top)			ifTrue: [self headDown. bounced _ true].	(aCostume bottom > box bottom)	ifTrue: [self headUp. bounced _ true].	bounced ifTrue: [^ self makeBounceSound: soundName].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!changeScript: scriptName toStatus: statusSymbol	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: statusSymbol.					^ self costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'scripts-standard' stamp: 'di 9/3/1998 00:43'!forward: dist 	| rho radians delta didStray p fractionalP newP aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	rho _ (aCostume asNumber: dist) asFloat.	radians _ (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta _ (radians cos @ radians sin) * rho.	((aCostume owner isHandMorph not) and:	 [aCostume presenter fenceEnabled]) ifTrue:		[(aCostume owner bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my owner, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray _ false.			((aCostume left < aCostume owner left and: [delta x < 0]) or:			 [aCostume right > aCostume owner right and: [delta x > 0]]) ifTrue: [				delta _ delta x negated @ delta y.				didStray _ true].			((aCostume top < aCostume owner top and: [delta y < 0]) or:			 [aCostume bottom > aCostume owner bottom and: [delta y > 0]]) ifTrue: [				delta _ delta x @ delta y negated.				didStray _ true].			didStray ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p _ aCostume referencePosition.	fractionalP _ aCostume actorState fractionalPosition.	(fractionalP == nil or: [fractionalP asIntegerPoint ~= p])		ifTrue: [newP _ p asFloatPoint + delta]		ifFalse: [newP _ fractionalP + delta]."Transcript cr; print: p; space; print: fractionalP;cr; cr; print: newP asIntegerPoint; space; print: newP; show: ''."	aCostume actorState fractionalPosition: newP.	aCostume referencePosition: newP asIntegerPoint.! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!goToRightOf: aPlayer	| hisCostume aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(hisCostume _ aPlayer costume) isInWorld ifFalse: [^ self].	((aCostume _ self costume) owner == hisCostume owner) ifFalse:		[hisCostume owner addMorphFront: aCostume].	aCostume position:		(hisCostume bounds rightCenter - (0 @ (aCostume height // 2)))! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!hide	self costume hide! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!initiatePainting	(self costume isKindOf: PasteUpMorph) ifTrue:		[self costume makeNewDrawingWithin]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!moveToward: aPlayer	| angle aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	((aCostume _ self costume) bounds intersects: aPlayer costume bounds) ifTrue: [^ self].	angle _ aCostume referencePosition bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!pauseScript: scriptName	self changeScript: scriptName toStatus: #paused! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!show	self costume show! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/18/1998 11:52'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	self costume isWorldOrHandMorph ifTrue:		[^ #((command beep: sound)			(command stopScript: string)			(command pauseScript: string)			(command startScript: string)			(command initiatePainting))].	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)		"	(command stopProgramatically)  "			(command stopScript: string)			(command pauseScript: string)			(command startScript: string))].	(aBank == 3 and: [self costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command liftAllPens)			(command lowerAllPens)			(command clearTurtleTrails)			(command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard)			(command initiatePainting))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!startScript: scriptName	self changeScript: scriptName toStatus: #ticking! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!stopScript: scriptName	self changeScript: scriptName toStatus: #normal! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:13'!wrap	self costume wrap! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!actorState	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 13:19'!assureUniClass	"If I am not currently a member of a UniClass, become one now"! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:44'!checkCostume	| found |	costumes ifNotNil:		[found _ costumes detect: [:c | c isInWorld] ifNone: [nil].		(found ~~ nil and: [found ~~ costume renderedMorph]) ifTrue:			[self halt: 'wrong costume'.			costume _ found]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!color: myColor sees: externalColor	^ self costume color: myColor sees: externalColor! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 17:14'!getInfo	"Open up some kind of editing window on the receiver's class comment, perhaps -- to be hooked up, perhaps, both via the viewer thumbnail and from the player's costume's red-dot menu" 	self notYetImplemented	"self class comment editxxx"! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!grabPlayerIn: aWorld	aWorld primaryHand attachMorph: self costume		! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!lastEvent	"A convenience for user scripts written in Squeak to call"	^ self costume primaryHand lastEvent! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:12'!makeBounceSound: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName].! !!Player methodsFor: 'misc' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors |	viewers _ OrderedCollection new.	scriptors _ OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	viewers do: [:v |  v noteDeletionOf: aMorph].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'misc' stamp: 'sw 8/18/1998 11:54'!owningPlayer	"Answer the player who wears my costume's owner as its costume.  Speculative, not currently used"	| itsOwner |	self costume ifNotNil:		[(itsOwner _ self costume owner) ifNotNil:			[^ itsOwner player]].	^ nil! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!presenter	"Convenience for calling from user scripts"	^ self costume presenter! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:14'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' (', self asOop printString, ')').	self costume ifNil: [aStream nextPutAll: ' (with nil costume)'.  ^ self].	aStream nextPutAll: ' named ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!renderedCostumeRespondsTo: aSelector	^ self costume renderedMorph respondsTo: aSelector! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 08:42'!revealPlayerIn: aWorld	| aMorph |	(aMorph _ self costume) isInWorld ifTrue: [^ aMorph goHome].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue: [^ self]].	self inform: 'Sorry.  Unaccountably, this objectseems to be irretrievably lost'			! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 14:39'!revertToUnscriptedPlayerIfAppropriate	| anInstance |	((self class selectors size > 0) or: [self class instVarNames size > 0]) ifTrue: [^ self].	anInstance _ UnscriptedPlayer new.	anInstance initializeCostumesFrom: self.	self become: anInstance! !!Player methodsFor: 'misc' stamp: 'sw 1/1/1999 22:28'!roundUpStrays	self sendMessageToCostume: #roundUpStrays! !!Player methodsFor: 'misc' stamp: 'sw 10/26/1998 15:45'!seesColor: aColor	costume isInWorld ifFalse: [^ false].	^ costume touchesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:25'!tearOffTileForSelf	self costume world primaryHand attachMorph: self tileReferringToSelf! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:00'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume]])		ifTrue:			[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add an empty new script' target: aViewer action: #newEmptyScript.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'misc' stamp: 'sw 10/29/1998 16:05'!tileReferringToSelf	| aTile |	aTile _ TileMorph new		setObjectRef: nil "disused parm" actualObject: self;		typeColor: (ScriptingSystem colorForType: #player).	self costume presenter harmonizeTileColorPolicyFor: aTile.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 1/1/1999 22:27'!unhideHiddenObjects	self sendMessageToCostume: #unhideHiddenObjects! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:22'!updateAllViewers	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter viewers all |	(aPresenter _ self costume presenter) ifNil: [^ self].	all _ self costume world allMorphs.	viewers _ all select:		[:m | (m isKindOf: PartsViewer)  and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updatePartsViewer: m].	viewers _ all select:		[:m | (m isKindOf: StandardViewer) and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updateViewer: m]! !!Player methodsFor: 'object fileIn' stamp: 'ack 8/27/1998 13:33'!convertdc0: varDict dcc0: smartRefStrm	"These variables are automatically stored into the new instance ('costume' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('costumes' ) and deal with the information in ()"! !!Player class methodsFor: 'initialization' stamp: 'sw 6/16/1998 15:32'!copyStateFrom: anotherClass	| dupScript |	scripts _ IdentityDictionary new.	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]].	slotInfo _ anotherClass slotInfo deepCopy.	self copyAddedStateFrom: anotherClass.  "The player-ref jump table"! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 8/2/1998 22:52'!tileScriptNames	scripts ifNil: [^ OrderedCollection new].	"The following is an emergency workaround for damaged script dictionaries occurring in Alan's demo image 8/2/98; no selector should be nil but somehow some is, so here we filter such damaging things out"	^ scripts collect: [:aScript | aScript selector] thenSelect: [:n | n ~~ nil]! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:45'!privateSlotInfo	"for copying"	^ slotInfo! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:44'!slotInfo: aDict	"for copying"	slotInfo _ aDict! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii _ BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className _ (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii _ ii + 1].	BiggestSubclassNumber _ ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ name endsWithDigit not! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:35'!anonymousUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializeAnonymousScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:42'!privateScripts	"for copying"	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'sw 8/11/1998 12:52'!removeScriptNamed: aScriptName	aScriptName ifNotNil:		[scripts removeKey: aScriptName.		self removeSelectorUnlogged: aScriptName]! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:41'!scripts: aDict	"for copying"	scripts _ aDict! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:33'!userScriptForPlayer: aPlayer selector: aSelector	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ scripts at: aSelector ifAbsent: [nil].	entry ifNil:		[entry _ UserScript new player: aPlayer selector: aSelector.		scripts at: aSelector put: entry].	^ entry! !!Player class methodsFor: 'namespace' stamp: 'sw 8/11/1998 12:46'!compileReferenceAccessorFor: varName	self class compileUnlogged: ((self referenceAccessorSelectorFor: varName), '	^ ', varName)		classified: 'reference' notifying: nil! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 16:28'!abandonUnnecessaryUniclasses	"Player abandonUnnecessaryUniclasses"	| oldCount oldFree newFree newCount report |	oldCount _ self subclasses size - 1.	oldFree _ Smalltalk garbageCollect.	self allSubInstances do:		[:aPlayer | aPlayer revertToUnscriptedPlayerIfAppropriate].	aPlayer _ nil.  "encourage last one to get garbage-collected"	ScriptingSystem spaceReclaimed.	newFree _ Smalltalk garbageCollect.	newCount _ self subclasses size - 1.	report _ 'Before: ', oldCount printString, ' uniclasses, ', oldFree printString, ' bytes freeAfter:  ', newCount printString, ' uniclasses, ', newFree printString, ' bytes free'.	Transcript cr; show: 'abandonUnnecessaryUniclasses:'; cr; show: report.	^ report	! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:25'!cleansePlayersWithDamagedScripts	"Track down all Players with damaged scripts and repair their script dictionaries.  Report how many were fixed."	"Player cleansePlayersWithDamagedScripts"	| aList |	aList _ self class allSubInstances select:		[:c | c scripts ~~ nil and: [c scripts includesKey: nil]].	aList do:		[:c | c scripts removeKey: nil].	^ aList size printString, ' uniclasses fixed up'! !!Player class methodsFor: 'housekeeping' stamp: 'jm 5/20/1998 20:54'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are housekeepingwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have not references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c |		((c name asString beginsWith: 'Player') and:		 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0])			ifTrue: [Smalltalk removeKey: c name ifAbsent: []. false]			ifFalse: [true]].	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not]) ifTrue: [			newSubclasses add: c.			Smalltalk at: c name put: c]].	subclasses _ newSubclasses.	SystemOrganization removeMissingClasses.! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:06'!playersWithDamagedScripts	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithDamagedScripts"	^ self allSubInstances select:		[:p | p class scripts ~~ nil and: [p class scripts includesKey: nil]]! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 14:33'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self class allSubInstances select:		[:p | p isSystemDefined not and: [p scripts size == 0 and: [p instVarNames size == 0]]] ! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/11/1998 13:23'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval _ candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 8/11/1998 16:47'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredPlayer.	self changed! !!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/8/1998 16:18'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledNextIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 6/26/1998 11:07'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !!PluggableButtonMorph methodsFor: 'accessing'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol.! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:53'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.model _ deepCopier references at: model ifAbsent: [model].! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:53'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied"label _ label veryDeepCopyWith: deepCopier."getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"shortcutCharacter _ shortcutCharacter veryDeepCopyWith: deepCopier.askBeforeChanging _ askBeforeChanging veryDeepCopyWith: deepCopier.triggerOnMouseDown _ triggerOnMouseDown veryDeepCopyWith: deepCopier.offColor _ offColor veryDeepCopyWith: deepCopier.onColor _ onColor veryDeepCopyWith: deepCopier.feedbackColor _ feedbackColor veryDeepCopyWith: deepCopier.showSelectionFeedback _ showSelectionFeedback veryDeepCopyWith: deepCopier.allButtons _ nil.		"a cache"! !!PluggableButtonMorph class methodsFor: 'instance creation'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !I generate code that can be loaded dynamically from external libraries (e.g., DSOs on Unix or DLLs on Windows)!!PluggableCodeGenerator methodsFor: 'testing' stamp: 'ar 10/7/1998 17:54'!isGeneratingPluginCode	^true! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 16:00'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define successFlag (!!interpreterProxy->failed())#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayValueOf(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value)#pragma export onEXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter);#pragma export off/*** Variables ***/struct VirtualMachine *interpreterProxy;EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == false) {		return false;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 08:27'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */';cr.	aStream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/7/1998 20:31'!storeVirtualMachineProxyHeader: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr; crtab.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitProxyFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; crtab]].	stream nextPutAll:'} VirtualMachine;#endif /* _SqueakVM_H */'.	stream close.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/11/1998 00:52'!storeVirtualMachineProxyImplementation: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"'; cr;cr.	stream nextPutAll:'/*** Function prototypes ***/'.	categoryList do:[:assoc|		stream cr; cr; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitCFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; cr]].	stream cr; nextPutAll:'struct VirtualMachine *VM = NULL;'; cr.	stream cr; nextPutAll:'static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; crtab.		assoc value asSortedCollection do:[:sel|		stream nextPutAll:'VM->';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:' = ';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:';';			crtab]].	stream cr; crtab; nextPutAll:'return VM;'; cr; nextPutAll:'}'; cr.	stream close.! !Class PluggableDictionary allows the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the dictionary. See the class comment of PluggableSet for an example.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.!!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	equalBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/20/1998 16:24'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	aSet equalBlock: self equalBlock fixTemps.	aSet hashBlock: self hashBlock fixTemps.	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!copy	^super copy postCopyBlocks! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2].! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/20/1998 16:08'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:14'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:28'!font	^ font! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	font _ aFontOrNil.	self list: self getList.  "update display"! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:30'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item font: font].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: (index = 0 ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 11/10/1998 09:31'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:11'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	"Set up for one line, or a full pane less one line"	scrollBar scrollDelta: (scroller firstSubmorph height / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph height / range) asFloat ! !!PluggableListMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) localBoundsToGlobal: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableListMorph methodsFor: 'object fileIn' stamp: 'tk 11/27/1998 20:41'!convertbosfcebbmsopssrsggslssggska0: varDict bosfcebbmsopssrsggslssggskaf0: smartRefStrm	"These variables are automatically stored into the new instance ('list' 'selectedMorph' 'selection' 'getListSelector' 'getIndexSelector' 'setIndexSelector' 'keystrokeActionSelector' 'autoDeselect' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('font' ) and deal with the information in ()"! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'jm 8/20/1998 09:44'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(model listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) localBoundsToGlobal: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:46'!list: listOfStrings	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 1/15/1999 01:03'!mouseDown: event onItem: aMorph	| index oldIndex oldVal |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	"Set meaning for subsequent dragging of selection"	dragOnOrOff _ (model listSelectionAt: index) not.	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 1/15/1999 00:49'!mouseEnterDragging: event onItem: aMorph	| index oldIndex oldVal |	dragOnOrOff ifNil: [^ self "spurious drag did not start with mouseDown"].	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	index _ scroller submorphs indexOf: aMorph.	dragOnOrOff ifTrue: [self setSelectedMorph: aMorph].	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	"Extend the selection with the current state of dragOnOrOff"	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:47'!mouseUp: event onItem: aMorph	dragOnOrOff _ nil.  "So improperly started drags will have not effect"! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:44'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:12'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector _ getMenuTitleSel! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu _ model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu _ model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'sw 10/9/1998 08:24'!setSelectionSelectorIs: aSelector	^ aSelector == setSelectionSelector! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableListViewByItem methodsFor: 'all' stamp: 'jm 9/20/1998 17:13'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.Example: Adding 1000 integer points in the range (0@0) to: (100@100) to a set.	| rnd set max pt |	set _ Set new: 1000.	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].The above is way slow since the default hashing function of points leads to an awful lot of collisions in the set. And now the same, with a somewhat different hash function:	| rnd set max pt |	set _ PluggableSet new: 1000.	set hashBlock:[:item| (item x bitShift: 16) + item y].	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].!!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock _ aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:47'!copy	^super copy postCopyBlocks! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2]! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:40'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableTest methodsFor: 'music type pane' stamp: 'sw 8/18/1998 12:31'!musicTypeListTitle	^ 'Choose a command'! !!PluggableTest methodsFor: 'menu commands' stamp: 'sw 8/18/1998 12:29'!perform: sel orSendTo: otherObject	(self respondsTo: sel) ifTrue: [self perform: sel] ifFalse: [otherObject perform: sel]! !!PluggableTest class methodsFor: 'example' stamp: 'sw 8/18/1998 12:25'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	listView1  menuTitleSelector: #musicTypeListTitle.	listView2 _		PluggableListView on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open.! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:13'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'di 1/13/1999 13:25'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down. 3/13/96 sw	 5/27/96 sw: added font menu"	^ PopUpMenu labels: 'set font... (k)set style... (K)explainpretty printfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with it (E)method source with itspecial menu...more...' 		lines: #(2 7 14).! !!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'di 8/24/1998 09:57'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  "	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu yellowButtonActivity "<-note change")"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 9/11/1998 15:46'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:55'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	scrollBar scrollDelta: (scroller firstSubmorph defaultLineHeight / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph defaultLineHeight / range) asFloat ! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'wod 5/26/1998 17:03'!setSelection: sel	selectionInterval _ sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [scroller changed].! !!PluggableTextMorph methodsFor: 'model access' stamp: 'ls 7/20/1998 22:50'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ TextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02'!fileItIn	self handleEdit: [textMorph editor fileItIn]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02'!implementorsOfIt	self handleEdit: [textMorph editor implementorsOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodNamesContainingIt	self handleEdit: [textMorph editor methodNamesContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodSourceContainingIt	self handleEdit: [textMorph editor methodSourceContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodStringsContainingit	self handleEdit: [textMorph editor methodStringsContainingit]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:59'!referencesToIt	self handleEdit: [textMorph editor referencesToIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 6/26/1998 11:09'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:31'!sendersOfIt	self handleEdit: [textMorph editor sendersOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/2/1998 17:49'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu event |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		event _ self primaryHand lastEvent.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'updating' stamp: 'ls 7/23/1998 03:47'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #autoSelect ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self world ifNotNil: [ self world displayWorld]].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self world displayWorld].! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 11/2/1998 15:57'!handleEdit: editBlock	| result |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'ar 11/15/1998 23:45'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'jm 8/20/1998 08:39'!mouseLeave: event	textMorph ifNotNil: [selectionInterval _ textMorph editor selectionInterval].	super mouseLeave: event.	event hand newKeyboardFocus: nil.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y@x! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !This class stores 32bit Integer points in place. It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0@0! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!size	"Return the number of elements in the receiver"	^super size // 2! !!PointArray class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 00:04'!new: n	^super new: n*2! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/17/1998 12:32'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[^ (self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0].	self lineSegmentsDo:		[:p1 :p2 |		(aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)				ifTrue: [^ true]].	self arrowForms do:		[:f | (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [^ true]].	^ false! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:36'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 12/17/1998 12:33'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[aCanvas stencil: self filledForm at: bounds topLeft-1 color: color].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset color: borderColor]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 10/9/1998 14:35'!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)].	self addHandles! !!PolygonMorph methodsFor: 'editing' stamp: 'jm 6/3/1998 14:29'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1).! !!PolygonMorph methodsFor: 'menu' stamp: 'di 10/9/1998 14:30'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	closed		ifTrue:		[aCustomMenu add: 'open polygon' action: #makeOpen.		quickFill			ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]			ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true]]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:31'!arrowForms	"ArrowForms are computed only upon demand"	arrowForms ifNotNil: [^ arrowForms].	arrowForms _ Array new.	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ arrowForms].	(arrows == #forward or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices last from: self nextToLastPoint)].	(arrows == #back or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices first from: self nextToFirstPoint)].	^ arrowForms! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:25'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ Form extent: box extent asIntegerPoint.	bb _ (BitBlt toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:09'!computeBounds	self changed.	self releaseCachedState.	bounds _ self curveBounds.	self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:22'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ Form extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ filledForm anyShapeFill].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:33'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta]! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !!PopUpChoiceMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:44'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].getItemsArgs _ getItemsArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]].choiceArgs _ choiceArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!PopUpChoiceMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:43'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		a Symbol""arguments _ arguments.		All weakly copied""getItemsSelector _ getItemsSelector.		a Symbol""getItemsArgs _ getItemsArgs.		All weakly copied""choiceSelector _ choiceSelector.		a Symbol"choiceArgs _ choiceArgs.		"All weakly copied"     ! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 6/3/1998 16:43'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	nLines _ (frame height - 4) // marker height.	allLabels := labelString findTokens: Character cr asString.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines) startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 12/20/1998 22:15'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released, answer the index of the current selection, or zero if the mouse is not released over any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	frame height > maxHeight ifTrue:		[^ self startUpSegmented: maxHeight withCaption: captionOrNil at: location].	World ifNotNil:		[selection _ Cursor normal showWhile:			[(MVCMenuMorph from: self title: captionOrNil) invokeAt: location in: World].		^ selection].	Cursor normal showWhile:		[self displayAt: location			withCaption: captionOrNil			during: [[Sensor anyButtonPressed] whileFalse: [].					[Sensor anyButtonPressed] whileTrue: [self manageMarker]]].	^ selection! !!PositionableStream methodsFor: 'positioning' stamp: 'di 5/25/1998 15:16'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| aString length |	"read the length in binary mode"	self binary.	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ length - 192.		1 to: 3 do: [:ii | length _ length * 256 + self next]].	aString _ String new: length.	"read the characters in ASCII mode"	self ascii.	self nextInto: aString.	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ (length - 192) * 256 + self next].	aString _ String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 5/29/1998 09:41'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s.	^s! !!PositionableStream methodsFor: 'converting' stamp: 'ar 12/3/1998 22:06'!asZLibStream	^ZLibStream on: collection from: position+1 to: readLimit! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 14:23'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	debugButton align: debugButton topRight with: inner topRight - (16@4).! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!debug	model debug! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 09:50'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 12/2/1998 16:51'!initialize	| aFont proceedLabel debugLabel aWidth |	super initialize.	(aWidth _ self widthOfFullLabelText) > 280 ifTrue: [^ self].   "No proceed/debug buttons if title too long"	aWidth > 210		ifTrue: "Abbreviated buttons if title pretty long"			[proceedLabel _ 'p'.			debugLabel _ 'd']		ifFalse: "Full buttons if title short enough"			[proceedLabel _ 'proceed'.			debugLabel _ 'debug'].	aFont _ Preferences fontForScriptorButtons.	self addMorph: (proceedButton _ SimpleButtonMorph new borderWidth: 0;			label: proceedLabel font: aFont; color: Color transparent;			actionSelector: #proceed; target: self).	proceedButton setBalloonText: 'continue execution'.	self addMorph: (debugButton _ SimpleButtonMorph new borderWidth: 0;			label: debugLabel font: aFont; color: Color transparent;			actionSelector: #debug; target: self).	debugButton setBalloonText: 'bring up a debugger'.	proceedButton submorphs first color: Color blue.	debugButton submorphs first color: Color red.	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!proceed	model proceed! !!PreDebugWindow class methodsFor: 'all' stamp: 'sw 11/4/1998 09:20'!includeInNewMorphMenu	^ false! !!Preferences methodsFor: 'read me' stamp: 'sw 10/1/1998 14:45'!readMe	"All the code for Preferences is on the class side"! !!Preferences class methodsFor: 'initialization' stamp: 'di 12/20/1998 21:10'!chooseInitialSettings 	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(inboardScrollbars					false)		(logDebuggerStackToFile				true)		(noviceMode							false)		(printAlternateSyntax				false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showScriptSource					false)		(showTimeStampsInMenuTitles		false)		(showProjectZoom					false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 9/19/1998 22:47'!initialize	"Preferences initialize"	"Sometimes placed in a change-set even though unchanged, to trigger reinitialization upon update."	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'initialization' stamp: 'di 12/20/1998 21:10'!initializeHelpMessages 	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic, SystemWindows should automatically be droppable into willing receptors')(browseWithPrettyPrint'If true, browsers will automatically format their contents')(cautionBeforeClosing 'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts are edited in place in Scriptors (still imperfectly implemented)')(eToyScheme'If true, new scripting spaces place the Playfield to the left and the the palette to the right of the window; if false, the opposite is true.')(fastDragWindowForMorphic'If true, morphic window drag will be done by dragging an outline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(inboardScrollbars'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit')(logDebuggerStackToFile'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(noviceMode 'If true, certain novice-mode accommodations are made.')(printAlternateSyntax'If true, thenprettyPrint using experimental syntax.Otherwise use normal ST-80 syntax.')(reverseWindowStagger'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')(showPlayerSource'If true, then all Player methods with fewer than 2 arguments are included in Viewers, whether or not they are intended for end-user use.  This can be dangerous')(showProjectZoom'If true, then show a zoom effect when entering or leaving projects.  This can be costly of memory (at least an extra screen buffer) so dont use it in low space situations.  But it is cool.')(showScriptSource'If true, then the actual Smalltalk source code for methods is shown in the detail panes for scripts in a viewer; if false, then a help message for scripts is shown instead.')(showTimeStampsInMenuTitles'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')(suppressCheckForSlips 'If false, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choice when updating code from the server is suppressed.  Set this to true to leave the server choice unchanged from update to update.')(thoroughSenders'If true, then ''senders'' browsers will dive inside structured literals in their search')(uniformWindowColors'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequence number from the filename before automatically saving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.')(useNewViewers'If true, then the new kinds of viewers introduced in Squeak 2.3 are used; if false, then the old style, from earlier releases, are still used.  Old viewers will hopefully soon be removed from the system.')(warnIfNoChangesFile'If true, then you will be warned, whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned, whenever you start up, if no sources file can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/10/1998 16:09'!defaultAuthorName	"Answer the author name to be planted, by default, in a changeset-preamble template.  You can hard-code this to hold your name, thus saving you time when writing the preambles of subsequent changesets"	^ 'Your Name'! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/5/1998 15:04'!defaultPaintingExtent	"Answer the preferred size for the onion-skin paint area when launching a new painting within a paste-up morph.  Feel free to change the parameters to suit your configuration."	^ 400 @ 300! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 19:50'!initializeParameters	"Preferences initializeParameters"	Parameters _ IdentityDictionary new.	self restoreDefaultMenuParameters.	Parameters at: #maxBalloonHelpLineLength put: 28! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 16:49'!maxBalloonHelpLineLength	^ Parameters at: #maxBalloonHelpLineLength! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/11/1998 11:58'!viewerEditingPaneHeight	^ 30! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/8/1998 12:46'!deletePreferenceIfFalse: aSymbol	"If aSymbol is currently in the FlagDictionary and the corresponding value is currently false, then remove that element from the dictionary.  The result is that the preference will remain false when interrogated from the outside, but it will not show up in a Preferences control panel.  This keeps obscure preferences from distracting the user"	| val |	val _ FlagDictionary at: aSymbol ifAbsent: [^ self].	val == false ifTrue: [self deletePreference: aSymbol]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!disable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: false! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 11/11/1998 11:40'!doesNotUnderstand: aMessage	"Look up the message selector as a flag."	aMessage arguments size > 0 ifTrue: [^ super doesNotUnderstand: aMessage].	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!enable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: true! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/5/1998 13:09'!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present"	"Preferences inspectPreferences"	FlagDictionary inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/5/1998 13:10'!openPreferencesInspector	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"		Smalltalk hasMorphic		ifFalse:	[self inspectPreferences]		ifTrue:	[self openPreferencesControlPanel]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/1/1998 15:24'!helpMessageForPreference: aSymbol	HelpDictionary ifNil: [self initializeHelpMessages].	^ HelpDictionary at: aSymbol ifAbsent: ['No help available for ', aSymbol]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/5/1998 12:35'!initialExtent	^ 216 @ ((FlagDictionary size * 19) + 20)! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/5/1998 19:55'!openPreferencesControlPanel	"Preferences openPreferencesControlPanel"	| aPanel aWindow aRow wrapper but aList odd aColor w width1 width2 spacer |	Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].	aPanel _ AlignmentMorph newColumn.	aPanel beSticky.	aList _ OrderedCollection new.	FlagDictionary associationsDo: [:assoc | aList add: (Array				with: assoc key				with: assoc value				with: (self helpMessageForPreference: assoc key))].	odd _ false.	width1 _ 172.	spacer _ 4.	width2 _ 14.	(aList asSortedCollection: [:a :b | a first < b first])		do: 			[:triplet | 			aPanel addMorphBack: (aRow _ AlignmentMorph newRow).			aRow color: (aColor _ odd							ifTrue: [Color green muchLighter]							ifFalse: [Color red veryMuchLighter]).			odd _ odd not.			aRow addMorph: (wrapper _ Morph new color: aColor).			wrapper setBalloonText: triplet third.			wrapper extent: width1 @ 15.			wrapper addMorph: (StringMorph new contents: triplet first).			aRow addMorphBack: (Morph new color: aColor; extent: (spacer @ 15)).			aRow addMorphBack: (wrapper _ Morph new color: aColor).			wrapper extent: width2 @ 15.			wrapper addMorphBack: (but _ UpdatingBooleanStringMorph new contents: triplet second printString).			but getSelector: triplet first;			 putSelector: #setPreference:toValue:;			 target: self].	Smalltalk isMorphic		ifTrue:			[aWindow _ SystemWindow new model: self.			aWindow addMorph: aPanel frame: (0 @ 0 extent: 1 @ 1).			aWindow setLabel: 'Preferences'.			aWindow openInWorld]		ifFalse:			[w _ WorldMorph new addMorph: aPanel.			w startSteppingSubmorphsOf: aPanel.			MorphWorldView openOn: w				label: 'Preferences'				extent: w fullBounds extent]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/1/1998 16:55'!scriptPerformer	^ self! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/11/1998 16:39'!setHelpFor: prefName toString: aString	HelpDictionary ifNil: [self initializeHelpMessages].	HelpDictionary at: prefName put: aString! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:16'!menuBorderColor	Display depth <= 2 ifTrue: [^ Color black].	^ Parameters at: #menuBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuBorderWidth	^ Parameters at: #menuBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:17'!menuColor	Display depth <= 2 ifTrue: [^ Color white].	^ Parameters at: #menuColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:37'!menuLineLowerColor	^ Parameters at: #menuLineLowerColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:36'!menuLineUpperColor	^ Parameters at: #menuLineUpperColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:19'!menuTitleBorderColor	Display depth <= 2 ifTrue: [^ Color black].	^ Parameters at: #menuTitleBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderWidth	^ Parameters at: #menuTitleBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:18'!menuTitleColor	Display depth = 1 ifTrue: [^ Color white].	Display depth = 2 ifTrue: [^ Color gray].	^ Parameters at: #menuTitleColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:33'!restoreDefaultMenuParameters	"Preferences restoreDefaultMenuParameters"	"Restore the four color choices of the original implementors of MorphicMenus"	Parameters at: #menuColor put: (Color r: 0.8 g: 0.8 b: 0.8).	Parameters at: #menuBorderColor put: #raised.	Parameters at: #menuBorderWidth put: 2.	Parameters at: #menuTitleColor put: (Color r: 0.5 g: 1 b: 0.75).	Parameters at: #menuTitleBorderColor put: #inset.	Parameters at: #menuTitleBorderWidth put: 1.	Parameters at: #menuLineUpperColor put: (Color r: 0.667 g: 0.667 b: 0.667).	Parameters at: #menuLineLowerColor put: (Color r: 0.833 g: 0.833 b: 0.833).! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:38'!setAltMenuChoices	"Preferences setAltMenuChoices"	Parameters at: #menuTitleColor put: (Color r: 0.4 g: 0.8 b: 0.9).	Parameters at: #menuColor put: (Color r: 0.97 g: 0.97 b: 0.97).	Parameters at: #menuTitleBorderColor put: Color blue muchLighter.	Parameters at: #menuBorderColor put: Color blue lighter.	Parameters at: #menuLineUpperColor put: Color blue lighter.	Parameters at: #menuLineLowerColor put: (Color r: 0.97 g: 0.97 b: 0.97)! !Optionally associated with a PasteUpMorph, provides presentation services.Holds control buttons:	stopButton stepButton goButton.Holds state flags:	mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabledHolds a viewerCache Holds, optionally three 'standard items' originally providing idiomatic support of ongoing squeak-team internal work, but now extended to more general applicability:   standardPlayer standardPlayfield standardPalette !!Presenter methodsFor: 'button creation' stamp: 'sw 11/11/1998 15:06'!addStopStepGoButtonsTo: aPasteUpMorph	| controls |	controls _ ScriptingSystem scriptControlButtons.	controls setToAdhereToEdge: #bottomLeft.	aPasteUpMorph addMorphBack: controls.	stopButton _ controls submorphs first.	stepButton _ controls submorphs second.	goButton _ controls submorphs third! !!Presenter methodsFor: 'button creation' stamp: 'sw 9/14/1998 12:38'!addTrashCan	| aPosition aCan |	(aCan _ associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan _ TrashCanMorph newSticky.	aPosition _ associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setProperty: #scriptingControl toValue: true.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 17:27'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		( RecordingControlsMorph PianoKeyboardMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/22/1998 13:35'!controlPanel	|  aPanel itsWorld |	(itsWorld _ associatedMorph world) ifNotNil:		[(aPanel _ itsWorld allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel]].	aPanel _ PasteUpMorph new extent:  128 @ 48.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/6/1998 14:07'!createControlPanel	associatedMorph primaryHand attachMorph: self controlPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 1/14/1999 01:12'!createStandardPartsBin	associatedMorph primaryHand attachMorph: self standardPartsWindow ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/9/1998 13:08'!customPagesForPartsBin	| aPage aWindow anotherPage pu |	aPage _ self newPageForStandardPartsBin.	aPage addMorphBack: BookMorph authoringPrototype.	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	#(TabbedPalette BasicButton JoystickMorph ClockMorph) do:		[:aName | aPage addMorphBack: (Smalltalk at: aName) authoringPrototype].	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow.	aPage addMorphBack: FileList openAsMorph.	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	anotherPage _ self newPageForStandardPartsBin.	anotherPage addMorphBack: ScriptingSystem newScriptingSpace.	anotherPage addMorphBack: ScriptingSystem scriptControlButtons.	anotherPage addMorphBack: TrashCanMorph new.	anotherPage addMorphBack: PasteUpMorph authoringPrototype.	anotherPage addMorphBack: ((pu _ PasteUpMorph newSticky) embeddedInMorphicWindowLabeled: 'assembly window').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	anotherPage replaceTallSubmorphsByThumbnails.	anotherPage fixLayout.	^ Array with: aPage with: anotherPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/16/1998 08:49'!launchCustomPartsBin	| aBin |	(aBin _ ScriptingSystem customPartsBin) ifNotNil:		[associatedMorph primaryHand attachMorph: aBin]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/13/1998 10:03'!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new extent:  361@175.	aPage color: Color white; padding: 6.	aPage autoLineLayout: true.	aPage isPartsBin: true; openToDragNDrop: false.	aPage setProperty: #alwaysShowThumbnail toValue: true.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 15:16'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook openToDragNDrop: false.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette _ aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/15/1998 19:44'!standardPaletteIsAlready: aPalette	^ standardPalette == aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/10/1998 17:57'!standardPartsWindow	| aPartsWindow aWorld |	aPartsWindow _ ScriptingSystem newStandardPartsBin wrappedInPartsWindowWithTitle: 'Standard Parts'.	aWorld _ (associatedMorph == nil or: [associatedMorph isInWorld not])		ifTrue:		[World]		ifFalse:		[associatedMorph world].	aWorld addMorph: aPartsWindow.  "So that closeEditing won't bomb"	aPartsWindow closeEditing.  "a bit redundant but gets the last details right"	^ aPartsWindow! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/21/1998 09:44'!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	self harmonizeTileColorPolicyFor: aPage.	aPage fixLayout.	aPage replaceTallSubmorphsByThumbnails.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 10/16/1998 09:17'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 7/4/1998 14:29'!positionStandardPlayer	standardPlayer costume position: (associatedMorph bottomLeft - (0 @ standardPlayer costume height))! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:44'!borderColorWhenRunning	borderColorWhenRunning ifNil:		[borderColorWhenRunning _ ScriptingSystem runningPlayfieldBorderColor].	^ borderColorWhenRunning! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 15:27'!borderColorWhenStopped	borderColorWhenStopped ifNil:		[borderColorWhenStopped _ ScriptingSystem frozenPlayfieldBorderColor].	^ borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 10/30/1998 15:36'!goUp: evt with: aMorph	self startRunningScripts! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:58'!startRunningScripts	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:18'!startRunningScriptsFrom: aGoButton	(goButton == nil or: [goButton isInWorld not]) ifTrue: [goButton _ aGoButton].	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:51'!stepStillDown: dummy with: theButton	(stepButton == nil or: [stepButton isInWorld not]) ifTrue: [stepButton _ theButton].	self stepButtonState: true.	self stopButtonState: false.	associatedMorph stepAll.	associatedMorph world displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:50'!stepUp: evt with: aMorph	(stepButton == nil or: [stepButton isInWorld not]) ifTrue: [stepButton _ aMorph].	stepButton state: #off! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:45'!stopRunningScripts	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:16'!stopRunningScriptsFrom: aStopButton	(stopButton == nil or: [stopButton isInWorld not]) ifTrue: [stopButton _ aStopButton].	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 10/30/1998 18:33'!balloonHelpEnabled	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	^ associatedMorph world ifNotNil: [associatedMorph world balloonHelpEnabled] ifNil: [true]! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 6/8/1998 11:06'!mouseOverHalosEnabled	^ mouseOverHalosEnabled == true! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 8/5/1998 07:37'!toggleShowBalloons	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	self world toggleShowBalloons! !!Presenter methodsFor: 'tile support' stamp: 'sw 11/9/1998 18:48'!constantTile: anObject	(anObject isKindOf: Color) ifTrue:		[^ ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)].	^ anObject newTileMorphRepresentative		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'tile support' stamp: 'sw 10/29/1998 16:06'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/22/1998 20:36'!nascentPartsViewer	"EToyPlayer creates one that is sticky, here it's movable"	^ Preferences useNewViewers		ifTrue:			[StandardViewer new]		ifFalse:			[PartsViewer new]! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 14:53'!updatePartsViewer: aPartsViewer	| aPlayer aPosition aNewPartsViewer oldOwner wasSticky |	aPlayer _ aPartsViewer scriptedPlayer.	aPosition _ aPartsViewer position.	wasSticky _ aPartsViewer isSticky.	aNewPartsViewer _ aPartsViewer species new visible: false.	wasSticky ifTrue: [aNewPartsViewer beSticky].	oldOwner _ aPartsViewer owner.	aPartsViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: aNewPartsViewer].	aNewPartsViewer obtainBankInfoFrom: aPartsViewer.	aNewPartsViewer setPlayer: aPlayer.	aNewPartsViewer position: aPosition.	self harmonizeTileColorPolicyFor: aNewPartsViewer.	aNewPartsViewer visible: true.	aNewPartsViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 21:14'!updateViewer: aViewer	| aPlayer aPosition newViewer oldOwner wasSticky |	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	newViewer initializeFor: aPlayer.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	aViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: newViewer].	newViewer obtainBankInfoFrom: aViewer.	newViewer position: aPosition.	self harmonizeTileColorPolicyFor: newViewer.	newViewer visible: true.	newViewer world startSteppingSubmorphsOf: newViewer.	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 11/10/1998 15:36'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	self harmonizeTileColorPolicyFor: aViewer.	aMorph primaryHand attachMorph: (aViewer visible: true)! !!Presenter methodsFor: 'misc' stamp: 'sw 7/8/1998 13:04'!drawingJustCompleted: aSketchMorph	| pal aPaintBox |	(aPaintBox _ associatedMorph world paintBox) ifNotNil:		[aPaintBox delete].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[(pal _ aSketchMorph standardPalette) ifNotNil:				[pal viewMorph: aSketchMorph]]! !!Presenter methodsFor: 'misc' stamp: 'sw 10/30/1998 14:48'!harmonizeTileColorPolicyFor: aMorph	self coloredTilesEnabled		ifTrue:			[aMorph makeAllTilesColored]		ifFalse:			[aMorph makeAllTilesGreen]! !!Presenter methodsFor: 'misc' stamp: 'sw 10/21/1998 09:47'!harmonizeTilesWithColorSetting	self harmonizeTileColorPolicyFor: self world! !!Presenter methodsFor: 'misc' stamp: 'sw 8/5/1998 07:38'!initializeToggles	mouseOverHalosEnabled _ true.	soundsEnabled _ true.	fenceEnabled _ true.	coloredTilesEnabled _ false! !!Presenter methodsFor: 'misc' stamp: 'sw 10/16/1998 18:34'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	((aMorph isKindOf: PaintInvokingMorph) and: [aMorph isPartsDonor])		ifTrue: "Ugly, I know, but we don't want automatic viewing if we're going to trigger painting"			[^ self].	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield _ aPlayfield! !!Presenter methodsFor: 'misc' stamp: 'sw 11/5/1998 16:54'!toggleButtons	| aButton  aList |	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help: If green, then when the cursor pauses over an object that has balloon help, that help balloon is shown''Sounds: If green, sounds will be  heard when appropriate; if red, sounds are suppressed.''Fence: If green, an invisible "fence" keeps your objects from straying outside their containers when their scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (ScriptingSystem formAtKey: q second);				offImage: (ScriptingSystem formAtKey: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown;				target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (ScriptingSystem formAtKey: q second) extent.			aButton].	^ aList! !!Presenter methodsFor: 'playerList' stamp: 'tk 12/17/1998 10:19'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ ((associatedMorph allMorphsAndBookPagesInto: Set new) select: 		[:m | m player ~~ nil] thenCollect: [:m | m player]) asArray! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList _ nil! !!Presenter methodsFor: 'playerList' stamp: 'sw 12/30/1998 19:50'!repairPlayerList	"Presenter allInstancesDo: [:p | p repairPlayerList]"	playerList ifNotNil:		[playerList _ playerList select: [:p | p isKindOf: Player]]! !!Presenter methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:51'!convertassgbmsfcvsssspbb0: varDict assgmsfcvsssspbb0: smartRefStrm	"These variables are automatically stored into the new instance ('associatedMorph' 'stopButton' 'stepButton' 'goButton' 'mouseOverHalosEnabled' 'soundsEnabled' 'fenceEnabled' 'coloredTilesEnabled' 'viewerCache' 'standardPlayer' 'standardPlayfield' 'standardPalette' 'standardHolder' 'playerList' 'borderColorWhenRunning' 'borderColorWhenStopped' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('balloonHelpEnabled' )"! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!program	^ program! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange	program _ midiProgramChange.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange channel: midiChannel	program _ midiProgramChange.	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46'!isProgramChange	^ true! !!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rC0		channel: channel		byte: program.! !!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': prog '.	program printOn: aStream.	aStream nextPut: $).! !!Project methodsFor: 'initialization' stamp: 'sw 11/12/1998 14:29'!backgroundColorForMorphicProject	^ Color lightOrange! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMvcProject	^ Color r: 1.0 g: 1.0 b: 0.065! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!defaultBackgroundColor	^ (world isKindOf: WorldMorph) ifTrue: [self backgroundColorForMorphicProject] ifFalse: [self backgroundColorForMvcProject]! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'menu messages' stamp: 'di 1/2/1999 21:58'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom priorProject |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	priorProject _ CurrentProject.	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				entering					ifTrue: [vanishingPoint _ Sensor cursorPoint]					ifFalse: [vanishingPoint _ self viewLocFor: priorProject].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 14:14'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'di 6/23/1998 09:36'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	world isMorph		ifTrue: [world _ World.				self dependents do:					[:d | (d isKindOf: SystemWindow)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]].				world sleep "Release all space possible in old world"]		ifFalse: [world _ ScheduledControllers.				ScheduledControllers unCacheWindows.				self dependents do:					[:d | (d isKindOf: StandardSystemView)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]].	transcript _ Transcript.	displayDepth _ Display depth.	activeProcess _ nil! !!Project methodsFor: 'menu messages' stamp: 'di 1/2/1999 21:56'!viewLocFor: exitedProject	"Look for a view of the exitedProject, and return its center"	World isMorph		ifTrue: [exitedProject dependents do:					[:v | (v isKindOf: SystemWindow)						ifTrue: [^ v center]]]		ifFalse: [exitedProject dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [^ v windowBox center]]].	^ Sensor cursorPoint.  "default result"! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project methodsFor: 'release' stamp: 'di 6/22/1998 09:40'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	ProjectViewMorph allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'sw 9/15/1998 16:42'!maybeForkInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[self interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'class initialization' stamp: 'di 6/20/1998 10:31'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	NavList _ OrderedCollection with: CurrentProject.	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!Project class methodsFor: 'instance creation' stamp: 'sw 7/6/1998 11:23'!newMorphicConstruction	"ProjectView open: Project newMorphicConstruction"	| aProject |	aProject _ self newMorphic.	aProject world configureForConstruction.	^ aProject! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:29'!addItem: item toMenu: menu selection: action	(menu isKindOf: MenuMorph)		ifTrue: [menu add: item selector: #jumpToSelection: argument: action]		ifFalse: [menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'sw 10/6/1998 13:48'!buildJumpToMenu: menu	"Present a list of potential projects, excluding the current one"	| prev |	"First a FIFO list -- inelegantly, this may include repeats."	(prev _ CurrentProject previousProject) ifNotNil:		[1 to: 5 do:			[:i | 			prev ifNotNil: 				[self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: '%back' , i printString.				prev _ prev previousProject]].		menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent.		menu addLine].	"Finally all the projects, other than the current one"	(Project allNames asSortedCollection: [:n1 :n2 | n1 asLowercase < n2 asLowercase]) do: [:n | self addItem: n toMenu: menu selection: n].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:24'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUp! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:03'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."	"Project jumpToProject"	| nBack prev |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true]].	selection = #parent ifTrue: [CurrentProject parent enter: false. ^ self].	(Project named: selection) enter: false! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self maybeRelabel: model labelString].	^ super update: aSymbol! !!ProjectView methodsFor: 'displaying' stamp: 'di 5/27/1998 16:58'!displayView	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 19:44'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!ProjectViewMorph methodsFor: 'all' stamp: 'sw 11/5/1998 14:45'!drawOn: aCanvas	(project ~~ nil and: [project thumbnail ~~ lastProjectThumbnail]) ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	project ifNotNil: [project thumbnail ifNil: [image fill: (0@0 extent: image extent) rule: Form over fillColor: project defaultBackgroundColor]].	super drawOn: aCanvas.! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/15/1998 16:21'!enter	"Enter my project."	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	project enter: false.! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 12:36'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and:	 [image depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP "scaleP x asFloat max: scaleP y asFloat".				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self image: (Form extent: newExtent depth: Display depth).		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 11:46'!mouseDown: evt	"Quick hack: use old-fashioned menu."	| menu selection |	menu _ CustomMenu new		add: 'enter' action: #enter;		add: 'jump to project...' action: #jumpToProject.	selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: nil.	selection = #enter ifTrue: [^ self enter].	selection = #jumpToProject ifTrue: [Project jumpToProject. ^ self].! !!ProjectViewMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 08:56'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.project _ deepCopier references at: project ifAbsent: [project].lastProjectThumbnail _ deepCopier references at: lastProjectThumbnail 				ifAbsent: [lastProjectThumbnail].! !!ProjectViewMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 08:55'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."project _ project.		Weakly copied"lastProjectThumbnail _ lastProjectThumbnail.		"Weakly copied"! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'sw 7/6/1998 11:27'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!PseudoClass methodsFor: 'class'!classComment: aChangeRecord	self organization classComment: aChangeRecord! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!classPool 	self exists ifFalse: [^ nil].	^ self realClass classPool! !!PseudoClass methodsFor: 'class'!comment	| rStr |	rStr := self organization commentRemoteStr.	^rStr isNil		ifTrue:[self name,' has not been commented']		ifFalse:[rStr string]! !!PseudoClass methodsFor: 'class'!comment: aString	self commentString: aString.! !!PseudoClass methodsFor: 'class' stamp: 'wod 4/15/98 17:21'!commentString	^self organization classComment asString! !!PseudoClass methodsFor: 'class'!commentString: aString	self classComment: aString asText. "Just wrap it"! !!PseudoClass methodsFor: 'class'!definition	^definition ifNil:['There is no class definition for this class'].! !!PseudoClass methodsFor: 'class'!definition: aString	definition := aString! !!PseudoClass methodsFor: 'class'!metaClass	^metaClass ifNil:[metaClass := PseudoMetaclass new name: (self name)].! !!PseudoClass methodsFor: 'class'!renameTo: aString	self hasDefinition ifTrue:[		self isMetaClass ifTrue:[			self definition: (self definition				copyReplaceAll: name,' class'				with: aString, ' class').		] ifFalse:[			self definition: (self definition 					copyReplaceAll:'ubclass: #',name					with:'ubclass: #', aString)]].	name := aString.	metaClass ifNotNil:[metaClass renameTo: aString].! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!sharedPools 	self exists ifFalse: [^ nil].	^ self realClass sharedPools! !!PseudoClass methodsFor: 'accessing'!fullName	^self name! !!PseudoClass methodsFor: 'accessing'!name	^name! !!PseudoClass methodsFor: 'accessing'!name: anObject	name _ anObject! !!PseudoClass methodsFor: 'accessing'!organization	^organization ifNil:[organization := PseudoClassOrganizer defaultList: SortedCollection new].! !!PseudoClass methodsFor: 'accessing'!realClass	^Smalltalk at: self name asSymbol! !!PseudoClass methodsFor: 'accessing' stamp: 'wod 5/19/1998 17:42'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!PseudoClass methodsFor: 'removing'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass isNil ifFalse:[metaClass removeAllUnmodified].! !!PseudoClass methodsFor: 'removing'!removeUnmodifiedMethods: aCollection	| stClass |	self exists ifFalse:[^self].	stClass := self realClass.	aCollection do:[:sel|		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asString ifTrue:[			self removeMethod: sel.		].	].	self organization removeEmptyCategories.! !!PseudoClass methodsFor: 'private'!confirmRemovalOf: aString	^self confirm:'Remove ',aString,' ?'! !!PseudoClass methodsFor: 'private'!evaluate: aString	^Compiler evaluate: aString for: nil logged: true! !!PseudoClass methodsFor: 'private'!makeSureClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!makeSureSuperClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: 'The super class ',aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!parserClass	^Parser! !!PseudoClass methodsFor: 'testing'!exists	^(Smalltalk at: self name asSymbol ifAbsent:[^false]) isKindOf: Behavior! !!PseudoClass methodsFor: 'testing'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition isNil ifFalse:[^true].	metaClass isNil ifFalse:[^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'testing'!hasComment	^self organization commentRemoteStr notNil! !!PseudoClass methodsFor: 'testing'!hasDefinition	^definition notNil! !!PseudoClass methodsFor: 'testing'!hasMetaclass	^metaClass notNil! !!PseudoClass methodsFor: 'testing'!isMetaClass	^false! !!PseudoClass methodsFor: 'testing'!nameExists	^Smalltalk includesKey: self name asSymbol! !!PseudoClass methodsFor: 'testing'!needsInitialize	^self hasMetaclass and:[		self metaClass selectors includes: #initialize]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileIn	"FileIn the receiver"	self hasDefinition ifTrue:[self fileInDefinition].	self fileInMethods: self selectors.	metaClass ifNotNil:[metaClass fileIn].	self needsInitialize ifTrue:[		self evaluate: self name,' initialize'.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInCategory: aCategory	^self fileInMethods: (self organization listAtCategoryNamed: aCategory)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInDefinition	(self makeSureSuperClassExists: (definition copyUpTo: Character space)) ifFalse:[^self].	self hasDefinition ifTrue:[		Transcript cr; show:'Defining ', self name.		self evaluate: self definition].	self exists ifFalse:[^self].	self hasComment ifTrue:[self realClass classComment: self comment].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethod: selector	^self fileInMethods: (Array with: selector)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods	^self fileInMethods: self selectors! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods: aCollection	"FileIn all methods with selectors taken from aCollection"	| theClass cat |	self exists ifFalse:[^self classNotDefined].	theClass := self realClass.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			theClass 				compile: (self sourceCodeAt: sel) 				classified: cat				withStamp: (self stampAt: sel)				notifying: nil.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOut	| f |	f := (FileStream newFileNamed: self name,'.st').	self fileOutOn: f.	self needsInitialize ifTrue:[		f cr; nextChunkPut: self name,' initialize'.	].	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutCategory: categoryName	| f |	f := (FileStream newFileNamed: self name,'-',categoryName,'.st').	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment ifTrue:[		aStream cr; nextPut: $!!; nextChunkPut: self name,' comment: '; cr.		aStream nextChunkPut: self commentString printString.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethod: selector	| f |	f := (FileStream newFileNamed: self name,'-', selector, '.st').	self fileOutMethods: (Array with: selector)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethods: aCollection on: aStream	"FileOut all methods with selectors taken from aCollection"	| cat categories |	categories := Dictionary new.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			(categories includesKey: cat) 				ifFalse:[categories at: cat put: Set new].			(categories at: cat) add: sel].	].	categories associationsDo:[:assoc|		cat := assoc key.		aStream cr; cr; nextPut:$!!; nextChunkPut:(String streamContents:[:s|			s nextPutAll: self fullName; nextPutAll:' methodsFor: '; print: cat asString]).		assoc value do:[:sel|			aStream cr.			aStream nextChunkPut: (self sourceCodeAt: sel).		].		aStream space; nextPut:$!!.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethodsOn: aStream	^self fileOutMethods: self selectors on: aStream.! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutOn: aStream	"FileOut the receiver"	self fileOutDefinitionOn: aStream.	metaClass ifNotNil:[metaClass fileOutDefinitionOn: aStream].	self fileOutMethods: self selectors on: aStream.	metaClass ifNotNil:[metaClass fileOutMethods: metaClass selectors on: aStream].! !!PseudoClass methodsFor: 'errors'!classNotDefined	^self inform: self name,' is not defined in the system.You have to define this class first.'.! !!PseudoClass methodsFor: 'categories'!removeCategory: selector	(self organization listAtCategoryNamed: selector) do:[:sel|		self organization removeElement: sel.		self sourceCode removeKey: sel.	].	self organization removeCategory: selector.! !!PseudoClass methodsFor: 'categories'!removedCategoryName	^'*** removed methods ***' asSymbol! !!PseudoClass methodsFor: 'categories'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	^ self organization categoryOfElement: aSelector! !!PseudoClass methodsFor: 'methods'!addMethodChange: aChangeRecord	| selector |	selector := Parser new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'methods'!methodChange: aChangeRecord	aChangeRecord isMetaClassChange ifTrue:[		^self metaClass addMethodChange: aChangeRecord.	] ifFalse:[		^self addMethodChange: aChangeRecord.	].! !!PseudoClass methodsFor: 'methods'!removeMethod: selector	self organization removeElement: selector.	self sourceCode removeKey: selector.! !!PseudoClass methodsFor: 'methods'!removeSelector: aSelector	| catName |	catName := self removedCategoryName.	self organization addCategory: catName before: self organization categories first.	self organization classify: aSelector under: catName.	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !!PseudoClass methodsFor: 'methods'!selectors	^self sourceCode keys! !!PseudoClass methodsFor: 'methods'!sourceCode	^source ifNil:[source := Dictionary new]! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel	^(self sourceCode at: sel) string! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel put: object	self sourceCode at: sel put: object! !!PseudoClass methodsFor: 'methods'!sourceCodeTemplate	^''! !!PseudoClass methodsFor: 'methods'!stampAt: selector	^(self sourceCode at: selector) stamp! !!PseudoClassOrganizer methodsFor: 'all' stamp: 'wod 4/15/98 17:08'!classComment	"Answer the comment associated with the object that refers to the receiver."	globalComment == nil ifTrue: [^''].	^globalComment! !!PseudoClassOrganizer methodsFor: 'all'!classComment: aChangeRecord	globalComment := aChangeRecord! !!PseudoClassOrganizer methodsFor: 'all'!setDefaultList: aCollection	super setDefaultList: aCollection.	self classComment: nil.! !!PseudoMetaclass methodsFor: 'accessing'!fullName	^self name,' class'! !!PseudoMetaclass methodsFor: 'accessing'!realClass	^super realClass class! !!PseudoMetaclass methodsFor: 'testing'!isMetaClass	^true! !I am a parser for news files in the format output by the Unix 'rn' program.!!RNInboxFile methodsFor: 'scanning'!nextStringOf: aStream equals: aString	aString do:		[: c | (c == (aStream next) ) ifFalse: [^false]].	^true! !!RNInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by delimiters that includes the newsgroup name. Ignore text before the first article delimiter."	| done line groupName |	currentNewsgroup _ nil.  "have not found start of article"	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 groupName _ self startOfArticle: line.		 (groupName notNil) ifTrue:			[self endOfArticleDo: aBlock.			 currentNewsgroup _ groupName.			 line _ MailDB readStringLineFrom: aStream].		 (currentNewsgroup notNil) ifTrue: [self appendLine: line]].! !!RNInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer the newsgroup name if the given string is the start of a news article, for example:		Article 2958 of comp.lang.smalltalk:	Otherwise, answer nil."	| s name |	s _ ReadStream on: aString.	(self nextStringOf: s equals: 'Article ') ifFalse: [^nil].	[s next isDigit] whileTrue.	"consumes digits plus the following space"	(self nextStringOf: s equals: 'of ') ifFalse: [^nil].	name _ s through: $:.	((name size > 1) & (s atEnd)) ifFalse: [^nil].	^name copyFrom: 1 to: (name size - 1)! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 1/14/1999 20:16'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 10/1/1998 11:54'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!RadioButtonInput methodsFor: 'access' stamp: 'ls 8/11/1998 19:52'!valueIfPressed	^value! !!RadioButtonInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:46'!inputSet: anInputSet  value: aString	inputSet _ anInputSet.	value _ aString.	state _ false.! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed	^state! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed: aBoolean	state _ aBoolean.	self changed: #pressed.	^true! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 20:28'!toggle	"my button has been clicked on!!"	self pressed: self pressed not.	inputSet  buttonToggled: self.	^true! !!RadioButtonInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:47'!inputSet: anInputSet  value: aString	^self new inputSet: anInputSet  value: aString! !!RadioButtonSetInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:25'!name: aString	name _ aString.	buttons _ OrderedCollection new.! !!RadioButtonSetInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^true! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:48'!addInput: buttonInput	buttons add: buttonInput! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:30'!defaultButton: aButton	"set which button to toggle on after a reset"	defaultButton _ aButton! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:24'!name	^name! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!active	"we are active if and only if one of our buttons is pressed"	buttons do: [ :b |		b pressed ifTrue: [ ^true ] ].	^false! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:27'!buttonToggled: aButton	"a button was toggled; turn all other buttons off"	buttons do: [ :b |		b == aButton ifFalse: [			b pressed: false  ] ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:30'!reset	buttons do: [ :b |		b pressed: (b == defaultButton) ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!value	buttons do: [ :b |		b pressed ifTrue: [ ^b valueIfPressed ] ].	self error: 'asked for value when inactive!!'.! !!RadioButtonSetInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:29'!name: aString	^self new name: aString! !!RandomEnvelope methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:15'!initialize	rand _ Random new.	lowLimit _ 0.994.	highLimit _ 1.006.	delta _ 0.0002.	currValue _ 1.0.	scale _ 1.0.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18'!centerPitch: aNumber	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."	updateSelector = #pitch: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta	^ delta! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta: aNumber	delta _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit	^ highLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit: aNumber	highLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!lowLimit	^ lowLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!lowLimit: aNumber	lowLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17'!volume: aNumber	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."	updateSelector = #volume: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'applying' stamp: 'jm 8/13/1998 18:25'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| r |	r _ rand next.	r > 0.5		ifTrue: [			currValue _ currValue + delta.			currValue > highLimit ifTrue: [currValue _ highLimit]]		ifFalse: [			currValue _ currValue - delta.			currValue < lowLimit ifTrue: [currValue _ lowLimit]].	currValue = lastValue ifTrue: [^ false].	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].	target		perform: updateSelector		with: scale * currValue.	lastValue _ currValue.	^ true! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29'!duration	^ 1.0! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!duration: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 1/14/1999 13:17'!name	^ 'random ', updateSelector! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30'!sustainEnd: seconds	"Do nothing."! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!for: aSelector	"Answer a random envelope for the given selector."	^ self new updateSelector: aSelector! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 17:09'!new	^ super new initialize! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:06'!initialize	| m1 m2 |	super initialize.	self typeColor: (ScriptingSystem colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:44'!numericValue	^ super numericValue atRandom! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:45'!storeCodeOn: aStream indent: tabCount	aStream			nextPut: $(;			nextPutAll: literal printString;			nextPutAll: ' atRandom)'.! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:14'!updateLiteralLabel	|  desiredW leader myLabel myReadout |	(myLabel _ self labelMorph) ifNil: [^ self].	myReadout _ submorphs reversed detect: [:m | m isKindOf: StringMorph].	myReadout contents: literal stringForReadout.	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width + myReadout width + 5.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myReadout position: (self left + (leader + 0)) @ (bounds top + 2); fullBounds.	myLabel position: myReadout topRight + (5@0).	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !I am a parser for news files in the format output by the Unix 'readnews' program.!!ReadNewsInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for news inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!ReadNewsInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for news inboxes."	self error: 'News inboxes are read only!!'! !!ReadNewsInboxFile methodsFor: 'scanning'!allDashes: aString	"Answer true if the given string is not empty and consists entirely of dash characters."	(aString isEmpty) ifTrue: [^false].	aString detect: [: ch | ch ~= $-] ifNone: [^true].	^false	"we must have detected a non-dash"! !!ReadNewsInboxFile methodsFor: 'scanning'!appendLine: aString	"Append the given line to the buffer."	msgBuffer nextPutAll: aString; cr.! !!ReadNewsInboxFile methodsFor: 'scanning'!endOfArticleDo: aBlock	"We've just hit the end of an article. Evaluate the given block on the article we've been accumulating in the buffer (if any) and reset the buffer for the next article."	| msgText end |	"get text and remove trailing separators (blanks, cr's, etc)"	msgText _ msgBuffer contents.	end _ msgText size.	[(end > 0) and: [(msgText at: end) isSeparator]] whileTrue: [end _ end - 1].	(end > 1) ifTrue:		[aBlock value: currentNewsgroup value: (msgText copyFrom: 1 to: end)].	msgBuffer reset.	"reset the buffer for the next message"! !!ReadNewsInboxFile methodsFor: 'scanning'!newsMessagesDo: aBlock	"Invoke the given block for each message in the news inbox file. The block arguments are the newsgroup name and the text of a new message."	| fileStream stream |	fileStream _ FileStream fileNamed: filename.	(fileStream size < 50000)		ifTrue:			["for small inboxes, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile)]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	self parse: stream do: aBlock.	fileStream close.! !!ReadNewsInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by two kinds of delimiters. The first kind indicates the start of a new newsgroup and includes the newsgroup name. The second kind indicates the start of a new article within a newsgroup."	| done line nextLine |	currentNewsgroup _ 'unknown newsgroup'.	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 (self allDashes: line) ifTrue:	"leading line of dashes"			["could be a newsgroup header"			 nextLine _ MailDB readStringLineFrom: aStream.			 ((nextLine size >= 10) and:			  [(nextLine copyFrom: 1 to: 10) = 'Newsgroup '])				ifTrue:					["yep, it is a newsgroup header"					 self endOfArticleDo: aBlock.					 self setNewsGroup: nextLine.					 MailDB skipRestOfLine: aStream.	"skip trailing line of dashes"					 MailDB skipRestOfLine: aStream.	"skip blank line"					 MailDB skipRestOfLine: aStream.	"skip next article delimiter"					 line _ MailDB readStringLineFrom: aStream]				ifFalse:					["nope, it's not a newsgroup header"					 self appendLine: line.					 line _ nextLine]].		 (self startOfArticle: line) ifTrue:			[self endOfArticleDo: aBlock.			 line _ MailDB readStringLineFrom: aStream].		 self appendLine: line].	"normal line: append it to the message buffer"! !!ReadNewsInboxFile methodsFor: 'scanning'!setNewsGroup: aLine	"Set the current newsgroup name from the given line of text, which is of the form:		Newsgroup comp.lang.smalltalk"	(aLine size > 11)		ifTrue: [currentNewsgroup _ aLine copyFrom: 11 to: aLine size]		ifFalse: [currentNewsgroup _ 'unknown newsgroup'].! !!ReadNewsInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer true if the given string is the start of a new news article. That is, does it start with the string 'Article ' and end with a period?"	^((aString size >= 8) and:	   [((aString copyFrom: 1 to: 8) = 'Article ') & (aString last = $.)])! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:20'!size	"Compatibility with other streams (e.g., FileStream)"	^readLimit! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:47'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [Smalltalk changes preambleString == nil])		ifTrue: [Smalltalk changes preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [Smalltalk changes postscriptString == nil])		ifTrue: [Smalltalk changes postscriptString: chunk].							! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:31'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	^ self fileInAnnouncing: 'Reading ' , self name! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:29'!fileInAnnouncing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:59'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen.  5/22/96 sw"	| allOrigins screenRight screenBottom initialExtent putativeOrigin putativeFrame allowedArea staggerOrigin |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView].	allowedArea _ Display usableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	initialExtent _ aView initialExtent.	allOrigins _ ScheduledControllers windowOriginsInUse.	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'tk 11/26/1998 09:34'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.	StandardSize _ 600@400.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!screenTopSetback	Smalltalk isMorphic		ifTrue: [^ 0]		ifFalse: [^ 18]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!scrollBarSetback	Smalltalk isMorphic		ifTrue: [^ 16-3]  "width = 16; inset from border by 3"		ifFalse: [^ 24]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:00'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'tk 11/26/1998 09:35'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self scrollBarSetback @ self screenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: StandardSize "600@400"].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:01'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self scrollBarSetback @ self screenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:43'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 1/14/1999 10:39'!makeTile	| newStyleTile sndName tile |	recorder pause.	newStyleTile _ true.	newStyleTile		ifTrue: [			sndName _ FillInTheBlank				request: 'Please enter a name this sound'				initialAnswer: 'sound'.			sndName isEmpty ifTrue: [^ self].			sndName _ SampledSound unusedSoundNameLike: sndName.			SampledSound				addLibrarySoundNamed: sndName				samples: recorder condensedSamples				samplingRate: recorder samplingRate.			tile _ SoundTile new literal: sndName]		ifFalse: [			tile _ InterimSoundMorph new sound: 				(SampledSound					samples: recorder condensedSamples					samplingRate: recorder samplingRate)].	self world hands first attachMorph: tile.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 8/17/1998 20:35'!show	"Show my samples in a WaveEditor."	| ed w |	recorder pause.	ed _ WaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w _ self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 7/4/1998 14:49'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side _ self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 7/12/1998 13:30'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	ref isInteger ifFalse: [short _ false].	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:38'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references _ IdentityDictionary new: 4096 * 5."	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new."	blockers ifNil: [blockers _ IdentityDictionary new]. ! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:58'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream class methodsFor: 'all' stamp: 'tk 5/26/1998 14:51'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	" 4 = If UniClasses (subclasses of Player) have class instance variables, append their values in the form (#Class43 (val1 val2 vla3)).  An array of those.  Can still read version 3."	^ 4! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 22:43'!padToEndWith: aChar	"On the Mac, files do not truncate, so pad it with a harmless character.  But Remote FTP files always replace, so no need to pad."	self atEnd ifFalse: [self inform: 'Why is this stream not at its end?'].! !!RemoteHandMorph methodsFor: 'other' stamp: 'di 7/5/1998 21:07'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt anyButtonPressed and:		 [evt controlKeyPressed and:		 [lastEvent anyButtonPressed not]]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent]! !Used for creating the right HTML links for Rendered Files!!RenderedSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID! !This class only exists to provide a different pageURL for the rendered pagesHere's how to set them up:For FTP rendering:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server:'cleon.cc.gatech.edu';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.For local rendering:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RendererSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID,'.html'! !An authorized Swiki that can generate cached pages with no link back to theSwikiExamples of setting them up:Here's one that renders to an external, FTP-accessible website:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server: 'flintstone.com';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction new restore: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.Here's one that renders to a local directory accessible from a webserver:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RenderingSwikiAction methodsFor: 'accessing' stamp: 'mjg 8/31/1998 14:40'!serverDirectory: anObject	serverDirectory _ anObject. "Should be an instance ofServerDirectory, or a path string."! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg8/31/1998 12:57'!browse: pageRef from: request	"Just reply with a page in HTML format -- use the rendering pagetemplate rpage.html"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'rpage') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''rpage.html'' not found'].	request reply: htmlForUser.! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/23/1998 09:14'!generate: pageRef	"Generate the page to the serverDirectory. Use the render.html page as a template"	| formattedPage renderedFile newmap file|	"Make a copy, then format the text."	formattedPage _ pageRef copy.	newmap _ urlmap copy.		" Create a new action with different action for cached form."	newmap action: (RendererSwikiAction new).	newmap action name: '.'.	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | newmap					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	(serverDirectory isKindOf: String)	ifTrue: [ "Just save the file into the directory"		renderedFile _ (serverDirectory),(pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.]	ifFalse: [ "Assume it's FTP and send it off"		renderedFile _ (pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.		serverDirectory putFile: (FileStream fileNamed: renderedFile) named: renderedFile.		"FileDirectory deleteFilePath: renderedFile"]! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'BJP9/9/1998 21:35'!pageURL: aPage	"make the URL suited to aPage"	^(self name),'.',aPage coreID! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/9/1998 14:24'!process: request	"Handle requests of the form {swikiname}.{coreRef}.render"	(request message size > 2) ifTrue: [		((request message at: 3) = 'render') ifTrue:		[ self generate: (urlmap atID: (request message at: 2)).		request reply: (PWS success) ; reply: (PWS contentHTML).		^self browse: (urlmap atID: (request message at: 2)) from:request].		((request message at: 3) = 'html') ifTrue: "Handle 1.html refs"		[^self browse: (urlmap atID: (request message at: 2)) from:request]].	super process: request.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28'!reset	super reset.	sound reset.	samplesPerIteration _ sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:29'!samplesRemaining	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!RunArray methodsFor: 'accessing' stamp: 'di 1/15/1999 00:04'!= otherArray 	"Test if all my elements are equal to those of otherArray"	(otherArray isMemberOf: RunArray) ifFalse: [^ self hasEqualElements: otherArray].	"Faster test between two RunArrays" 	^ (runs hasEqualElements: otherArray runs)		and: [values hasEqualElements: otherArray values]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:16'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs addFirst: 1.		values addFirst: value]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs addLast: 1.		values addLast: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs add: times.		values add: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs addLast: times.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs addLast: 1.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ls 8/20/1998 10:56'!copyFrom: start to: stop	| newRuns | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new	^self runs: OrderedCollection new values: OrderedCollection new! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (OrderedCollection with: size) values: (OrderedCollection with: value)! !!RunArray class methodsFor: 'instance creation' stamp: 'tk 1/13/1999 08:28'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds."	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv _ OrderedCollection new.	"Value array"	aa _ OrderedCollection new.	"Attributes list"	[(this _ strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].		this == $f ifTrue: [aa add: 			(TextFontChange new fontNumber: (Number readFrom: strm))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)].		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !This is used to post email messages to an SMTP server. See my class messages for examples of how to use it.!!SMTPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:52'!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	Socket initializeNetwork.	addr _ NetNameResolver addressForName: serverName.	addr ifNil: [self error: 'Could not find host address'].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:38'!data: messageData	"send the data of a message"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkSMTPResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:13'!getSMTPResponse	"wait for an SMTP response, and return the number of the response"	| line |	[ line _ self getResponse.	Transcript show: line.	(line at: 4) = $- ] whileTrue.	^(line copyFrom: 1 to: 3) asNumber! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:21'!mailFrom: fromAddress	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:31'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	self sendCommand: 'QUIT'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:20'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 22:37'!checkSMTPResponse	"get an SMTP response, and check that it's in the 200's or 300's.  If it's not, close the socket and issue an error:"	(#(2 3) includes: self getSMTPResponse // 100) ifFalse: [		self close.		self error: 'server responded with an error' ].! !!SMTPSocket class methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:49'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"deliver mail to a list of users.  NOTE: the recipient list should be a collection of bare addresses--no '<>' or '()' stuff"	| sock |	Socket initializeNetwork.	sock _ self new.	(sock connectToSMTPServer: serverName)		ifFalse: [ ^false ].	sock mailFrom: fromAddress.	recipientList do: [ :recipient |		sock recipient: recipient ].	sock data: messageText.	sock quit.	sock closeAndDestroy.	^true! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:40'!example	"SMTPSocket example"	"send a message over SMTP"	self deliverMailFrom: 'lex@cc.gatech.edu' to: #(root src) text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'localhost'.! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:36'!example2	"SMTPSocket example2"	"send a message using the low-level protocol methods.  Normally one would just use the high-level class message"	| sock |	sock _ self new.	sock connectToSMTPServer: 'localhost'.	sock mailFrom: 'lex@cc.gatech.edu'.	sock recipient: 'lex@localhost'.	sock recipient: 'root'.	sock data:'From: testTo: "not listed"Subject: this is a testHi, this is a test message.'.	sock quit.	sock close.! !See SameGame>>helpString for an explanation of how to play!!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 19:36'!initialize	| |	super initialize.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self addMorph: self makeControls.	self addMorph: self board.	helpText _ nil.	self newGame.! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		inset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; centering: #center; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:40'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		inset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'access' stamp: 'tao 5/23/1998 10:32'!helpString^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'actions' stamp: 'tao 5/23/1998 10:51'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count _ self board selectionCount.	count = 0 ifTrue:		[score _ scoreDisplay value + (selectionDisplay value - 2) squared.		board findSelection ifNil:			[count _ board tilesRemaining.			count = 0				ifTrue: [score _ score + (5 * board rows * board columns)]				ifFalse: [score _ score - count].			scoreDisplay flash: true].		scoreDisplay value: score].	selectionDisplay value: count.! !I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:25'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	hResizing _ #rigid.	vResizing _ #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self fixLayout.	self resetBoard.! !!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:39'!resetBoard	selection _ nil.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom]! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'geometry' stamp: 'tao 5/18/1998 20:41'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	(bounds extent // protoTile extent) = (aPoint // protoTile extent)		ifFalse:			[self changed.			bounds _ bounds topLeft extent: (aPoint truncateTo: protoTile extent).			self layoutChanged.			self changed]! !!SameGameBoard methodsFor: 'dropping/grabbing' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 17:57'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MorphicEvent new]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 16:53'!removeSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) disabled: true; setSwitchState: false].		self collapseColumns: (selection collect: [:loc | loc x]) asSet asSortedCollection.		selection _ nil.		flash _ false.		(target ~~ nil and: [actionSelector ~~ nil])			ifTrue: [target perform: actionSelector withArguments: arguments]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 20:20'!tileClickedAt: location newSelection: isNewSelection	| tile |	isNewSelection		ifTrue:			[self deselectSelection.			tile _ self tileAt: location.			selectionColor _ tile color.			selection _ OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1				ifTrue: [self deselectSelection]				ifFalse:					[(target ~~ nil and: [actionSelector ~~ nil])					ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse:			[self removeSelection].! !!SameGameBoard methodsFor: 'private' stamp: 'tao 5/18/1998 20:42'!fixLayout	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !I am a single tile for the SameGame.  I act much like a switch.!!SameGameTile methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:59'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/18/1998 20:51'!color: aColor	color _ aColor.	onColor _ aColor.	offColor _ aColor.	self changed.! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!SameGameTile methodsFor: 'drawing' stamp: 'tao 5/15/1998 12:31'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color darker			bottomRightColor: color lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/17/1998 09:53'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		target			perform: actionSelector			withArguments: (arguments copyWith: switchState)].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!allSampleSets: sortedNotes	| keyMap |	keyMap _ self midiKeyMapFor: sortedNotes.	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04'!initialize	sustainedThreshold _ 0.15.	loudThreshold _ 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!loudThreshold: aNumber	loudThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.	staccatoSoft _ staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoLoudSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoSoftSampleSet: sortedNotes	staccatoSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedLoudSampleSet: sortedNotes	sustainedLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedSoftSampleSet: sortedNotes	sustainedSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!sustainedThreshold: aNumber	sustainedThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedLoud]				ifFalse: [keymap _ staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedSoft]				ifFalse: [keymap _ staccatoSoft]].	keymap ifNil: [keymap _ sustainedLoud].	note _ (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 12:39'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r _ IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i _ 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i _ i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower _ sortedNotes at: i - 1.	higher _ sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r _ OrderedCollection new: aNoteList size.	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch _ 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch _ n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud _ self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft _ self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud _ self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft _ self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap _ Array new: 128 withAll: aNote.	sustainedLoud _ oneNoteMap.	sustainedSoft _ oneNoteMap.	staccatoLoud _ oneNoteMap.	staccatoSoft _ oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 18:22'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd _ LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 20:32'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all _ OrderedCollection new.	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		info _ AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 17:15'!tempTest	(AbstractSound bachFugueVoice1On: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern _ (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 10/6/1998 23:47'!buildSmallOrchestra	"Example of how to build a skeleton orchestra that uses less memory."	"SampledInstrument buildSmallOrchestra"	AbstractSound unloadSampledTimbres.	#(clarinet oboe bassoon trombone tympani) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].	#(flute bass) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:27'!new	^ super new initialize! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir _ orchestraDir, ':', instName.	memBefore _ Smalltalk garbageCollect.	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd _ SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 18:06'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' f'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:10'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 1/14/1999 10:34'!fromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name, merging stereo to mono if necessary."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	"| snd |	 FileDirectory default fileNames do: [:n |		(n endsWith: '.aif')			ifTrue: [				snd _ SampledSound fromAIFFfileNamed: n.				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: true		skipDataChunk: false.	^ self		samples: (aiffFileReader channelData at: 1)		samplingRate: aiffFileReader samplingRate! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:59'!addLibrarySoundNamed: aString fromAIFFfileNamed: fileName	"Add a sound from the given AIFF file to the library."	"SampledSound		addLibrarySoundNamed: 'shutterClick'		fromAIFFfileNamed: '7.aif'"	"Add all .aif files in the current directory to the sound library:	| fileNames |	fileNames _ FileDirectory default fileNamesMatching: '*.aif'.	fileNames do: [:fName |		SampledSound			addLibrarySoundNamed: (fName copyUpTo: $.)			fromAIFFfileNamed: fName]"	| snd |	snd _ self fromAIFFfileNamed: fileName.	self addLibrarySoundNamed: aString		samples: snd samples		samplingRate: snd originalSamplingRate.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:41'!addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples. If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:04'!playSoundNamed: aString	"Play the sound with given name. Do nothing if there is no sound of that name in the library."	"SampledSound playSoundNamed: 'croak'"	| snd |	snd _ self soundNamed: aString.	snd ifNotNil: [snd play].	^ snd! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:40'!putCoffeeCupClinkInSoundLibrary	"SampledSound putCoffeeCupClinkInSoundLibrary"	self addLibrarySoundNamed: 'clink'		samples: self coffeeCupClink		samplingRate: 11025! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:06'!soundLibrary	"Answer the sound library dictionary."	^ SoundLibrary! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:07'!soundNamed: aString	"Answer the sound of the given name, or nil if there is no sound of that name."	"(SampledSound soundNamed: 'shutterClick') play"	| entry samples |	entry _ SoundLibrary		at: aString		ifAbsent:			[self inform: aString, ' not found in the Sound Library'.			^ nil].	entry ifNil: [^ nil].	samples _ entry at: 1.	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].	^ self samples: samples samplingRate: (entry at: 2)! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:08'!soundNames	"Answer a list of sound names for the sounds stored in the sound library."	"| s |	 SampledSound soundNames asSortedCollection do: [:n |		n asParagraph display.		s _ SampledSound soundNamed: n.		s ifNotNil: [s playAndWaitUntilDone]]"	^ SoundLibrary keys asArray! !a basic web browser.It downloads things in a background thread; the background thread puts downloaded objects onto downloadQueue as they arrive.  The queue is checked in the step method.A custom start page is provided for.  It's not as convenient as bookmarks are, but it does have a lot of flexibility--the user can put anything on the start page that is desired.There is a hook for displaying the "lint" of a page; currently it's not a very effective linter.!!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItContext	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItReceiver	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 7/29/1998 03:28'!release	self stopEverything.	super release.! !!Scamper methodsFor: 'lint' stamp: 'ls 8/1/1998 03:10'!hasLint	"whether the current page has any questionable HTML in it"	document ifNil: [ ^false ].	^document lint ~= ''! !!Scamper methodsFor: 'lint' stamp: 'ls 9/14/1998 20:38'!lint	"return a string describing any questionable HTML that was noticed in the current page"	"(not currently very comprehensive)"	document ifNil: [ ^'' ].	^document lint! !!Scamper methodsFor: 'lint' stamp: 'ls 7/29/1998 00:07'!showLint	(StringHolder new contents: self lint) openLabel: 'lint for ', self currentUrl printString.! !!Scamper methodsFor: 'testing' stamp: 'ls 7/14/1998 21:44'!isWebBrowser	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 01:43'!displayHistory	"let the user selecet a previous page to view"	| menu |	menu _ MenuMorph entitled: 'Recent URLs'.	menu defaultTarget: self.	menu addStayUpItem.	menu addLine.	recentDocuments reverseDo: [ :doc |		menu add: doc url toText selector: #displayDocument: argument: doc ].	menu popUpAt: Sensor mousePoint  forHand: World primaryHand! !!Scamper methodsFor: 'menus' stamp: 'ls 8/8/1998 03:59'!editStartPage	| win textMorph |	World ifNil: [ self error: 'only works for morphic currently' ].	win _ SystemWindow labelled: 'edit Bookmark page'.	textMorph _ PluggableTextMorph on: self text: #startPage  accept: #startPage:.	win addMorph: textMorph frame: (0@0 extent: 1@1).	win openInWorld.	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 17:54'!inspectParseTree	"inspect a parse tree of the current page's source"	document ifNotNil: [ document inspect ]! !!Scamper methodsFor: 'menus' stamp: 'ls 9/7/1998 07:48'!menu: menu  shifted: shifted	| lines selections linePositions |	lines _ 'new URLhistoryview sourceinspect parse treego to start pageedit start page'.	linePositions _ #(2 4).	selections _ #(jumpToNewUrl displayHistory viewSource inspectParseTree visitStartPage editStartPage ).	downloadingProcess ifNotNil: [ 		lines _ lines, String cr, 'stop downloading'.		linePositions _ linePositions, selections size.		selections _ selections, #(stopEverything) ].	menu labels: lines lines: linePositions selections: selections.	^menu.! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 02:28'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!Scamper methodsFor: 'menus' stamp: 'ls 7/27/1998 23:16'!viewSource	"view the source HTML of this page"	(StringHolder new contents: (pageSource withSqueakLineEndings)) openLabel: 'source for ',currentUrl printString.! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 02:01'!visitStartPage	self jumpToAbsoluteUrl: 'browser:start'.	^true! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/13/1998 07:14'!jumpToAbsoluteUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	|  newUrl newSource |	self stopEverything.	"get the new url"	newUrl _ urlText asUrl.	"if it fundamentally doesn't fit the pages-and-contents model used internally, spawn off an external viewer for it"	newUrl hasContents ifFalse: [ newUrl activate.  ^true ].	"fork a Process to do the actual downloading, parsing, and formatting.  It's results will be picked up in #step"	self status: 'downloading ', newUrl toText, '...'.	downloadingProcess _ [ 	  	newSource _ [ newUrl retrieveContentsForBrowser: self ] ifError: [ :msg :ctx |			MIMEDocument contentType: 'text/plain' content: msg ].		newSource 			ifNil: [ newSource _ MIMEDocument contentType: 'text/plain' content: 'Error retrieving this URL' ].			newSource url ifNil: [				newSource _ MIMEDocument contentType: newSource contentType  content: newSource content  url: newUrl ].			documentQueue nextPut: newSource.			downloadingProcess _ nil.	] newProcess.	downloadingProcess resume.	^true! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 08:56'!jumpToNewUrl	"change to a new, user-specified page"	| newUrl |	newUrl _ FillInTheBlank request: 'url to visit' initialAnswer: currentUrl toText.	(newUrl isNil or: [ newUrl isEmpty ]) ifTrue: [ ^self ].	self jumpToAbsoluteUrl: newUrl! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 11:22'!jumpToUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	self jumpToAbsoluteUrl: (urlText asUrlRelativeTo: currentUrl)! !!Scamper methodsFor: 'changing page' stamp: 'ar 11/19/1998 23:12'!startDownloadingMorphState: morphs	downloadingProcess _ [		morphs do: [ :m | m downloadStateIn: self].	] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/12/1998 00:56'!startDownloadingStateIn: aDocument  url: aUrl	"download the state for the given document in a background thread.  signal the foreground when the data has arrived"	downloadingProcess _ [			aDocument allSubentitiesDo: [ :e |			e downloadState: aUrl ].		documentQueue nextPut: #stateDownloaded.		downloadingProcess _ nil. ] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 7/24/1998 01:28'!stopEverything	"stop all background threads and empty queues for communicating with them; bring this Scamper to a sane state before embarking on something new"		downloadingProcess ifNotNil: [		downloadingProcess terminate.		downloadingProcess _ nil. ].	[ documentQueue isEmpty ] whileFalse: [ documentQueue next ].	self status: 'sittin'.! !!Scamper methodsFor: 'changing page' stamp: 'tk 9/22/1998 20:26'!submitFormWithInputs: inputs  url: url  method: method	| newUrl newSource | 	self stopEverything.	(method asLowercase ~= 'get' and: [ method asLowercase ~= 'post' ]) ifTrue: [		self notify: 'unkown FORM method: ', method.		^false ].	newUrl _ url asUrlRelativeTo: currentUrl.		newUrl schemeName ~= 'http' ifTrue: [		self notify: 'I can only submit forms via HTTP'.		^false ].	self status: 'submitting form...'.	downloadingProcess _ [			method asLowercase = 'get' 				ifTrue: [newSource _ newUrl retrieveContentsArgs: inputs] 				ifFalse: [newSource _ newUrl postFormArgs: inputs].			documentQueue nextPut:  newSource.			downloadingProcess _ nil.		] newProcess.		downloadingProcess resume.		^true! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 03:18'!currentUrl	^currentUrl! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 02:47'!document	"return the current parsed HTML document, or nil if we aren't viewing a page"	^document! !!Scamper methodsFor: 'access' stamp: 'ls 7/21/1998 01:16'!formattedPage	"format the current page and return it as a Text" 	^formattedPage ifNil: [ ^Text new ].	! !!Scamper methodsFor: 'access' stamp: 'ls 9/10/1998 03:38'!formattedPageSelection	currentAnchorLocation ifNil: [ ^0 to: -1 ].	^currentAnchorLocation to: currentAnchorLocation! !!Scamper methodsFor: 'access' stamp: 'ls 8/1/1998 03:10'!title	"return the title of the current page, or nil if there is none"	document == nil		ifTrue: [ ^nil ]		ifFalse: [ ^self document head title ifNil: ['(untitled)'] ]! !!Scamper methodsFor: 'stepping' stamp: 'ls 8/12/1998 01:39'!step	"check if a new document has arrived"	| results |	[documentQueue isEmpty] whileFalse: [		results _ documentQueue next.		results == #stateDownloaded ifTrue: [ 			"images and such have been downloaded; update the page"			self status: 'reformatting page...'.			formattedPage _ document formattedTextForBrowser: self defaultBaseUrl: currentUrl.			self changed: #formattedPage.			self status: 'sittin'. ]		 ifFalse: [					self displayDocument: results 			] ]! !!Scamper methodsFor: 'stepping' stamp: 'di 1/14/1999 09:00'!wantsSteps	^ true! !!Scamper methodsFor: 'initialization' stamp: 'ls 8/12/1998 01:21'!initialize	documentQueue _ SharedQueue new.	recentDocuments _ OrderedCollection new.	currentUrl _ 'http://minnow.cc.gatech.edu/squeak.1' asUrl.	pageSource _ ''.	document _ HtmlParser parse: (ReadStream on: '').	self status: 'sittin'.	self jumpToUrl: currentUrl.! !!Scamper methodsFor: 'browser urls' stamp: 'ls 8/12/1998 01:23'!browserUrlContents: aRequest	aRequest = 'start' ifTrue: [ 		^MIMEDocument contentType: 'text/html' content: self startPage ].	^ nil! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status	^status! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status: aSymbol	status _ aSymbol.	self changed: #status.! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:01'!startPage	"return the contents of the user's personal start page"	| file |	file _ FileStream oldFileOrNoneNamed: 'StartPage.html'.	file 		ifNil: [ ^'<title>Personal Start Page</title>\<h1>Personal Start Page</h1>\This space is empty' withCRs ]		ifNotNil: [ ^file contentsOfEntireFile ]! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:02'!startPage: newPage	"fill in the contents of the user's personal start page"	| file |	FileDirectory default deleteFileNamed: 'StartPage.html'.	file _ FileStream fileNamed: 'StartPage.html'.	file ifNil: [ self error: 'could not save file' ].	file nextPutAll: newPage asString.	file close.		self changed: #startPage.	^true! !!Scamper methodsFor: 'user interface' stamp: 'ls 9/18/1998 06:43'!openAsMorph	"open a set of windows for viewing this browser"	|win urlMorph |	"create a window for it"	win _ SystemWindow labelled: 'Scamper'.	win model: self.	win setProperty: #webBrowserView toValue: true.	"create a title view"	win addMorph: (PluggableTextMorph on: self text: #title accept: nil) frame: (0.0@0 extent: 1@0.1).	"create a view of the current url"	"win addMorph: (RectangleMorph new) frame: (0@0.1 extent: 0.3@0.1)."	urlMorph _  PluggableTextMorph on: self text: #currentUrl accept: #jumpToAbsoluteUrl:.	urlMorph acceptOnCR: true.	win addMorph: urlMorph frame: (0@0.1 extent: 1@0.1).	"create a status view"	win addMorph: (PluggableTextMorph on: self text: #status accept: nil) frame: (0@0.9 extent: 1.0@0.1).	"create the text area"	win addMorph: (PluggableTextMorph on: self text: #formattedPage accept: nil readSelection: #formattedPageSelection menu: #menu:shifted:)		frame: (0@0.2 extent: 1@0.7).		win openInWorld.	^win! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 21:51'!displayDocument: mimeDocument	"switch to viewing the given MIMEDocument"	|  handled  urlString |	handled _ false.	"add it to the history"	recentDocuments removeAllSuchThat: [ :d | d url = mimeDocument url ].	recentDocuments addLast: mimeDocument.	recentDocuments size > 20 ifTrue: [ recentDocuments removeFirst ].			mimeDocument mainType = 'image' 		ifTrue: [handled _ self displayImagePage: mimeDocument].	mimeDocument contentType = 'text/html' 		ifTrue: [handled _ self displayTextHtmlPage: mimeDocument].	mimeDocument contentType = 'x-application/shockwave-flash'		ifTrue:[handled _ self displayFlashPage: mimeDocument].	(#('audio/midi' 'audio/x-midi') includes: mimeDocument contentType) 		ifTrue: [handled _ self processMidiPage: mimeDocument].	"Before we display plain text files we should look at the extension of the URL"	(handled not and:[ mimeDocument mainType = 'text']) ifTrue:[		urlString _ mimeDocument url toText.		(urlString endsWithAnyOf: #('.gif' '.jpg' '.pcx')) 			ifTrue:[handled _ self displayImagePage: mimeDocument].		(handled not and:[urlString endsWithAnyOf: #('.mid' '.midi')])			ifTrue:[handled _ self processMidiPage: mimeDocument].		(handled not and:[urlString endsWith: '.swf'])			ifTrue:[handled _ self displayFlashPage: mimeDocument].	].	(handled not and: [ mimeDocument mainType = 'text']) ifTrue: [		self displayPlainTextPage: mimeDocument.		handled _ true].	handled ifFalse: [self processUnhandledPage: mimeDocument].! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:29'!displayFlashPage: newSource	"A shockwave flash document -- embed it in a text"	| attrib stream player |	stream _ (RWBinaryOrTextStream with: newSource content) binary reset.	(FlashFileReader canRead: stream) ifFalse:[^false]. "Not a flash file"	player _ (FlashMorphReader on: stream) processFileAsync.	player sourceUrl: newSource url.	player startPlaying.	attrib _ TextAnchor new anchoredMorph: player.	formattedPage _ ' * ' asText.	formattedPage addAttribute: attrib from: 2 to: 2.	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."	recentDocuments removeLast.	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	self status: 'sittin'.	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayImagePage: newSource	"an image--embed it in a text"	| image imageMorph attrib text handled |	handled _ true.	formattedPage _ [		image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.		imageMorph _ ImageMorph new image: image.		attrib _ TextAnchor new anchoredMorph: imageMorph.		text _ ' * ' asText.		text addAttribute: attrib from: 2 to: 2.		text] ifError: [ :msg :ctx | handled _ false ].	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."	recentDocuments removeLast.	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	self status: 'sittin'.	^handled! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayPlainTextPage: newSource	"treat as plain text"	pageSource _ newSource content.	document _ nil.	formattedPage _ pageSource withSqueakLineEndings.	currentUrl _ newSource url.	self status: 'sittin'.	self changeAll: 	#(currentUrl title hasLint lint formattedPage).	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayTextHtmlPage: newSource	"HTML page--format it"	| formatter |	currentUrl _ newSource url.	pageSource _ newSource content.	self status: 'parsing...'.	document _ (HtmlParser parse: (ReadStream on: pageSource)).	self status: 'laying out...'.	formatter _ HtmlFormatter new.	formatter browser: self.	formatter baseUrl: currentUrl.	document addToFormatter: formatter.	formattedPage _ formatter text.	currentUrl fragment		ifNil: [ currentAnchorLocation _ nil ]		ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].	self startDownloadingMorphState: (formatter incompleteMorphs).	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!processMidiPage: newSource	Smalltalk at: #MIDIFileReader ifPresent:		[:reader |		reader playStream: (RWBinaryOrTextStream with: newSource content) reset binary.		self status: 'sittin'.		^true].	^false! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:01'!processUnhandledPage: newSource	"offer to save it to a file"	| fileName file |	self status: 'sittin'.	(self confirm: 'unkown content-type ', newSource contentType,'--Would you like to save to a file?') ifFalse: [ ^false ].	fileName _ ''.	[		fileName _ FillInTheBlank request: 'file to save in' initialAnswer: fileName.		fileName isEmpty ifTrue: [ ^self ].		file _ FileStream fileNamed: fileName.		file == nil	] whileTrue.	file reset.	file binary.	file nextPutAll: newSource content.	file close.	^true! !!Scamper methodsFor: 'change/update' stamp: 'ar 11/19/1998 21:37'!changeAll: aspects	"We have changed all of the aspects in the given array"	aspects do:[:symbol| self changed: symbol].! !!Scamper methodsFor: 'change/update' stamp: 'ar 11/19/1998 23:10'!invalidateLayout	self changeAll: #( formattedPage formattedPageSelection ).! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 7/17/1998 23:02'!new	^super new initialize! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 23:21'!openAsMorph	"Scamper openAsMorph"	^self new openAsMorph! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!StartUrl: aUrl	"specify the URL to start from"	StartUrl _ aUrl asUrl.! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!initialize	self StartUrl: 'http://minnow.cc.gatech.edu/squeak'.  "the Squeak home page"! !This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.!!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 08:38'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 09:54'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07'!doControl	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	self processAllAtTick: ticksSinceStart asInteger.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/5/1998 23:07'!isPlaying	^ SoundPlayer isPlaying: self! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |	myLeftVol _ (leftVol * overallVolume) asInteger.	myRightVol _ (rightVol * overallVolume) asInteger.	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:06'!processAllAtTick: scoreTick	self processTempoMapAtTick: scoreTick.	midiPort		ifNil: [self processNoteEventsAtTick: scoreTick]		ifNotNil: [self processMIDIEventsAtTick: scoreTick].	self processAmbientEventsAtTick: scoreTick.	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:50'!processAmbientEventsAtTick: scoreTick	"Process ambient events through the given tick."	| i evt |	i _ trackEventIndex at: trackEventIndex size.	[evt _ score ambientEventAfter: i ticks: scoreTick.	 evt ~~ nil] whileTrue: [		i _ i + 1.		evt occurAtTime: scoreTick inScorePlayer: self atIndex: i inEventTrack: score ambientTrack secsPerTick: secsPerTick].	trackEventIndex at: trackEventIndex size put: i.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:49'!processNoteEventsAtTick: scoreTick	"Process note events through the given score tick using internal Squeak sound synthesis."	| instr j evt snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [				snd _ instr					soundForMidiKey: evt midiKey					dur: secsPerTick * evt duration					loudness: evt velocity asFloat / 127.0.				activeSounds add: (Array with: snd with: i)].			j _ j + 1.			trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:51'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	activeMIDINotes _ OrderedCollection new.	score resetFrom: self.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 17:13'!closeMIDIPort	"Stop using MIDI for output. Music will be played using the built-in sound synthesis."	self pause.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/24/1998 22:33'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 5.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 15:56'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 18:31'!processMIDIEventsAtTick: scoreTick	"Process note events through the given score tick using MIDI."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			evt isNoteEvent				ifTrue: [					(muted at: i) ifFalse: [						evt startNoteOnMidiPort: midiPort.						activeMIDINotes add: (Array with: evt with: i)]]				ifFalse: [evt outputOnMidiPort: midiPort].			j _ j + 1.			trackEventIndex at: i put: j]].	self turnOffActiveMIDINotesAt: scoreTick.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:45'!startMIDIPlaying	"Start up a process to play this score via MIDI."	midiPort ensureOpen.	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ [self midiPlayLoop] newProcess.	midiPlayerProcess		priority: Processor userInterruptPriority;		resume.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!stopMIDIPlaying	"Terminate the MIDI player process and turn off any active notes."	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ nil.	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].	activeMIDINotes _ activeMIDINotes species new.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!turnOffActiveMIDINotesAt: scoreTick	"Turn off any active MIDI notes that should be turned off at the given score tick."	| evt someNoteEnded |	midiPort ifNil: [^ self].	someNoteEnded _ false. 	activeMIDINotes do: [:pair |		evt _ pair first.		evt endTime <= scoreTick ifTrue: [			evt endNoteOnMidiPort: midiPort.			someNoteEnded _ true]].	someNoteEnded ifTrue: [		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:58'!midiPort	^ midiPort! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:54'!msecsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 17:25'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!overallVolume	^ overallVolume! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!overallVolume: aNumber	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!panForTrack: i	| left right fullVol pan |	left _ leftVols at: i.	right _ rightVols at: i.	left = right ifTrue: [^ 0.5].  "centered"	fullVol _ left max: right.	left < fullVol		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].	^ pan roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:58'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	fullVol _ (leftVols at: i) max: (rightVols at: i).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: i put: right asInteger.	leftVols at: i put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!ticksForMSecs: mSecs	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!ticksSinceStart	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!volumeForTrack: i	| vol |	vol _ (leftVols at: i) max: (rightVols at: i).	^ (vol asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/30/1998 20:22'!volumeForTrack: i put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: i.	oldRight _ rightVols at: i.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: i put: left asInteger.	rightVols at: i put: right asInteger.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:46'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	score pauseFrom: self.	super pause.	activeSounds _ activeSounds species new.	midiPort ifNotNil: [self stopMIDIPlaying].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:45'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	score resumeFrom: self.	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!tempoOrRateChanged	"This method should be called after changing the tempo or rate."	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/14/1998 15:53'!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection	| oldSnd name snd |	oldSnd _ scorePlayer instrumentForTrack: trackIndex.	(selection beginsWith: 'edit ') ifTrue: [		name _ selection copyFrom: 6 to: selection size.		aPopUpChoice contentsClipped: name.		(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd title: name].		(oldSnd isKindOf: SampledInstrument) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].		^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((trackIndex ~= i) and:		 [selection = (instrumentSelector at: i) contents])			ifTrue: [snd _ scorePlayer instrumentForTrack: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:14'!closeMIDIPort	scorePlayer closeMIDIPort.	LastMIDIPort _ nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!instrumentChoicesForTrack: trackIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	names add: 'edit ', (instrumentSelector at: trackIndex) contents.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/18/1998 06:53'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'reload instruments' action: #updateInstrumentsFromLibrary.	aMenu add: 'open a MIDI file' action: #openMIDIFile.	scorePlayer midiPort		ifNil: [			aMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aMenu add: 'play via built in synth' action: #closeMIDIPort.			aMenu add: 'new MIDI controller' action: #makeMIDIController:].	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/14/1998 15:30'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	scorePlayer ifNotNil:		[repeatSwitch _ SimpleSwitchMorph new			offColor: color;			onColor: (Color r: 1.0 g: 0.6 b: 0.6);			borderWidth: 2;			label: 'Repeat';			actionSelector: #repeat:;			target: scorePlayer;			setSwitchState: scorePlayer repeat.		r addMorphBack: repeatSwitch].	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/28/1998 23:05'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: scorePlayer midiPort).! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:05'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll h |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	h _ self world activeHand.	h		ifNil: [self world addMorph: pianoRoll]		ifNotNil: [h attachMorph: pianoRoll].	pianoRoll startStepping.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/18/1998 09:07'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer.	scorePlayer ifNotNil:		[scorePlayer  reset.		instrumentSelector _ Array new: scorePlayer score tracks size].	self addMorph: self makeControls.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	scorePlayer ifNil: [^ self].	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/14/1998 15:46'!openMIDIFile	"Open a MIDI score and re-init controls..."	| score fileName f player |	fileName _ Utilities chooseFileWithSuffixFromList: #('.mid' '.midi')					withCaption: 'Choose a MIDI file to open'.	fileName ifNil: [^ self].	f _ FileStream readOnlyFileNamed: fileName.	score _ (MIDIFileReader new readMIDIFrom: f binary) asScore.	f close.	player _ ScorePlayer onScore: score.	self onScorePlayer: player title: fileName! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	scorePlayer openMIDIPort: portNum.	LastMIDIPort _ portNum.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:29'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:18'!rewind	scorePlayer pause; reset.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:10'!scorePlayer	^ scorePlayer! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:09'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!ScorePlayerMorph class methodsFor: 'all' stamp: 'jm 10/12/1998 16:29'!openOn: aScore title: aString	| player |	player _ ScorePlayer onScore: aScore.	(self new onScorePlayer: player title: aString) openInWorld.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 14:32'!aboutThisSystem 	"Identify software version"	| aString eToySystem aNumber |	aString _ Smalltalk version.	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'EToy System: ', eToySystem version, ' of ', eToySystem versionDate].	aNumber _ ChangeSorter highestNumberedChangeSet.	(aNumber notNil and: [aNumber > 0]) ifTrue:		[aString _ aString, 'Highest-numbered update: ', aNumber printString].	aString _ aString, 'Current Change Set: ', Smalltalk changes name.	^ self inform: aString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/13/1998 16:03'!absorbUpdatesFromServer 	Utilities updateFromServer! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 8/5/1998 18:40'!browseChangedMessages	Smalltalk browseChangedMessages! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:09'!durableChangesMenu 	Utilities windowFromMenu: self changesMenu target: self title: 'Changes'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:29'!durableHelpMenu 	Utilities windowFromMenu: self helpMenu target: self title: 'Help'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 11/25/1998 12:21'!durableOpenMenu 	| colorPattern |	colorPattern _ #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 14:36'!durableScreenMenu 	Utilities windowFromMenu: self projectScreenMenu target: self title: 'Squeak'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:15'!durableWindowMenu 	Utilities windowFromMenu: self windowMenu target: self title: 'Window controls'! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/5/1998 16:17'!fileOutChanges	"File out changes to a file whose name is a function of the current date and time."	Smalltalk changes fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/23/1998 02:06'!fontSizeSummary	Utilities fontSizeSummary! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/27/1998 14:27'!lookForSlips	Smalltalk changes lookForSlips! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 10:17'!newChangeSet	ChangeSorter newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:07'!openConstructionProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView openAndEnter: Project newMorphicConstruction! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicConstructionWorld 	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph openWithStandardPartsBinShowing! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:06'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: Project newMorphic.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph new open.! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 8/31/1998 16:18'!openSelectorBrowser	"Create and schedule a selector fragment window."	SelectorBrowser new open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 12/8/1998 15:48'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Display extent = DisplayScreen actualScreenSize ifFalse:		[DisplayScreen startUp.		World 			ifNil:[ScheduledControllers unCacheWindows]			ifNotNil:[^World extent: Display extent] "Will redraw automatically"].	World 		ifNil:[ScheduledControllers restore]		ifNotNil:[World invalidRect: World bounds]! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/2/1998 15:37'!soundOnOrOff	Preferences setPreference: #disableSounds		toValue: (Preferences valueOfFlag: #disableSounds) not! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/14/1998 10:14'!viewImageImports	"Open an inspector on forms imported from Image files."	Smalltalk viewImageImports! !!ScreenController methodsFor: 'nested menus' stamp: 'di 12/5/1998 21:00'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'simple change sorter'			'dual change sorter'			'file out changes'			'create new change set...'			'browse changed methods'			'check for slips'			'browse recent submissions'			'recent change log'			)		lines: #(1 3 7)		selections: #(durableChangesMenuopenSimpleChangeSorter openChangeManagerfileOutChanges newChangeSet browseChangedMessages lookForSlipsbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/23/1998 02:07'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'keep this menu up'			'edit preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view image imports'			'full screen on'			'full screen off'			'set display depth...'			'set desktop color...' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) ,		#(	'update code from server'			'about this system'			'set author initials...'			'vm statistics'			'space left')		lines: #(1 6 11)		selections: #(durableHelpMenueditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsfullScreenOn fullScreenOff setDisplayDepth setDesktopColor soundOnOrOffabsorbUpdatesFromServer aboutThisSystem setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 1/10/1999 13:43'!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'simple change sorter'			'dual change sorter'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 6 8)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowseropenSimpleChangeSorter openChangeManageropenProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:05'!popUpMenuFor: aSymbol	| reply |	reply _ (self perform: aSymbol) startUp.	reply ifNil: [^ self].	self perform: reply! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/24/1998 08:18'!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(	'keep this menu up'			'previous project'			'jump to project...'			'restore display'			'open...'			'windows...'			'changes...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 9)		selections: #(durableScreenMenureturnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 15:14'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'keep this menu up'			'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows' ) , 			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(1 4 7)		selections: #(durableWindowMenufindWindow chooseDirtyBrowser chooseDirtyWindowcollapseAll expandAll closeUnchangedWindowsfastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:06'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[^ self popUpMenuFor: reply].	^ self perform: reply! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted _ anActorMorph player! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 11/3/1998 17:20'!myMorph	"Answer the morph that serves as the costume of my associated player.  If for some reason I have no associated player, answer nil"	| aPlayer |	^ (aPlayer _ self playerScripted) ifNotNil: [aPlayer costume]! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 12/4/1998 15:46'!objectViewed	^ self playerScripted costume! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/21/1998 09:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/29/1998 16:06'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii |	hand _ self primaryHand.	(hand lastEvent redButtonPressed)		ifTrue:		[hand submorphCount > 0 ifTrue:			[insertion _ hand firstSubmorph.			insHt _ insertion height.			self removeSpaces.			i _ (ii _ self indexOfMorphAbove: insertion fullBounds topLeft)					min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty					ifTrue: [insertion]					ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))					color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]		ifFalse:		[self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)]]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 11/9/1998 18:37'!buttonRowForEditor	| r aString aButtonMorph buttonFont aStatusMorph aStatus |	buttonFont _ ScriptingSystem fontForScriptorButtons.	r _ AlignmentMorph newRow color: Color transparent; inset: 0.	r addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	r addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	r addMorphBack:		(aButtonMorph _ SimpleButtonMorph new label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	r addTransparentSpacerOfSize: 6@10.	aStatus _ self scriptInstantiation status.	r addMorphBack:			(aStatusMorph _ SimpleButtonMorph new label: aStatus font: buttonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger;				setBalloonText: (ScriptingSystem helpStringFor: #chooseTrigger) maxLineLength: 65;				balloonTextSelector: #chooseTrigger).	r addTransparentSpacerOfSize: 10@10.	r addMorphBack:		((SimpleButtonMorph new label: '' font: buttonFont)			target: self;			color: Color veryLightGray;			actWhen: #buttonDown;			actionSelector: #addYesNoToHand;			balloonTextSelector: #addYesNoToHand).	r addTransparentSpacerOfSize: 12@10.	self addDismissButtonTo: r.	self updateStatusMorph: aStatusMorph.	^ r! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/22/1998 11:25'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal'		" -- run when called"				'paused' 		"ready to run all the time"		'ticking'		"run all the time"		'mouseDown'	"run when mouse goes down on me"		'mouseStillDown'	"while mouse still down"		'mouseUp'		"when mouse comes back up"		'mouseEnter'	"when mouse enters my bounds, button up"		'mouseLeave'	"when mouse exits my bounds, button up"		'mouseEnterDragging'	"when mouse enters my bounds, button down"		'mouseLeaveDragging'	"when mouse exits my bounds, button down"		'opening'	"when I am being opened"		'closing'	"when I am being closed"	"	'keyStroke'	run when user hits a key"		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/8/1998 09:19'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	(Preferences valueOfFlag: #editPlayerScriptsInPlace)		ifTrue:			[self addTextualScript: newBrowser]		ifFalse:			[Browser openBrowserView: (newBrowser openMessageEditString: nil) label: ('textual script for "', scriptName, '" in ', playerScripted externalName)]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:11'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/3/1998 15:08'!isTextuallyCoded	(self topEditor isKindOf: ScriptEditorMorph) ifFalse: [^ false].  "workaround for the case where the receiver is embedded in a free-standing CompoundTileMorph.  Yecch!!"	^ self userScriptObject isTextuallyCoded! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/31/1998 17:54'!setTimeStamp	timeStamp _ Date today mmddyyyy, ' ', (Time now print24 copyFrom: 1 to: 8).	^ timeStamp! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/29/1998 10:43'!storeCodeOn: aStream indent: tabCount	| lastOwner |	lastOwner _ nil.	self tileRows do: [:r |		r do: [:m |			((m isKindOf: TileMorph) or:			 [(m isKindOf: CompoundTileMorph) or:			 [m isKindOf: PhraseTileMorph]]) ifTrue: [				tabCount timesRepeat: [aStream tab].				((m owner ~= lastOwner) and: [lastOwner ~= nil])					ifTrue:						[aStream nextPut: $.; cr; tab.						m storeCodeOn: aStream indent: tabCount]					ifFalse:						[(lastOwner ~= nil) ifTrue: [aStream space].						m storeCodeOn: aStream indent: tabCount].				lastOwner _ m owner]]].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 17:40'!userScriptObject	^ self topEditor playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 11/2/1998 14:23'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color colorFrom: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.playerScripted _ deepCopier references at: playerScripted ifAbsent: [playerScripted].! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 07:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.scriptName _ scriptName veryDeepCopyWith: deepCopier.firstTileRow _ firstTileRow veryDeepCopyWith: deepCopier.timeStamp _ timeStamp veryDeepCopyWith: deepCopier.playerScripted _ playerScripted.		"Weakly copied"! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 7/4/1998 18:02'!wantsDroppedMorph: aMorph	^ false   "though later we could drop onto formal args in the header"! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:20'!runIfClosing	| result |	(result _ status == #closing) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:19'!runIfOpening	| result |	(result _ status == #opening) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 5/7/1998 22:06'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 10/5/1998 14:47'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	super addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph.  "nominally nothing"	aCustomMenu add: 'take out of window' action: #takeOutOfWindow	! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 9/30/1998 13:00'!initialExtent	^ 640 @ 480! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 23:43'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #resetTimer to: self.	pagingArea on: #mouseStillDown send: #scrollByPage: to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeUpButton	upButton := RectangleMorph		newBounds: ((bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'geometry' stamp: 'di 11/11/1998 09:27'!extent: p	p x > p y		ifTrue: [super extent: (p max: 36@8)]		ifFalse: [super extent: (p max: 8@36)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!nextPage: event	"Note: this method is no longer called, except by old scrollBars"	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	event cursorPoint y >= slider center y		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!scrollByPage: event	nextPageDirection == nil ifTrue:		[nextPageDirection _ event cursorPoint y >= slider center y].	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollDown	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:44'!scrollDownInit	downButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollUp	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:45'!scrollUpInit	upButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/14/1998 15:19'!setValue: newValue	^ super setValue: (newValue truncateTo: scrollDelta)! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:22'!resetTimer	timeOfMouseDown _ Time millisecondClockValue.	timeOfLastScroll _ timeOfMouseDown - 1000 max: 0.	nextPageDirection _ nil.	currentScrollDelay _ nil! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:38'!waitForDelay1: delay1 delay2: delay2	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll == nil ifTrue: [self resetTimer]. "Only needed for old instances"	now _ Time millisecondClockValue.	now < timeOfLastScroll ifTrue: [self resetTimer  "rare clock rollover"].	(scrollDelay _ currentScrollDelay) == nil ifTrue: [scrollDelay _ delay1  "initial delay"].	now > (timeOfLastScroll + scrollDelay) ifFalse: [^ false  "not time yet"].	currentScrollDelay _ scrollDelay*9//10 max: delay2.  "decrease the delay"	timeOfLastScroll _ now.	^ true! !!ScrollController methodsFor: 'control defaults' stamp: 'di 6/26/1998 13:11'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's menu."	| menu sel |	menu _ view getMenu: shiftKeyState.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !The scroller (a transform) of a scrollPane is driven by the scrollBar.  The scroll values vary from 0.0, meaning zero offset to 1.0 meaning sufficient offset such that the bottom of the scrollable material appears halfway down the pane.  The total distance to achieve this range is called the totalScrollRange.!!ScrollPane methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:05'!fullCopy	| copy |	self mouseEnter: nil.		 "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.		"So that references are updated properly"		"Will fail of any Players with scripts are in the ScrollPane"	self mouseLeave: nil.	^ copy mouseLeave: nil! !!ScrollPane methodsFor: 'initialization' stamp: 'di 11/11/1998 09:53'!initialize	super initialize.	borderWidth _ 2.  borderColor _ #inset.	retractableScrollBar _ scrollBarOnLeft _		(Preferences valueOfFlag: #inboardScrollbars) not.	scrollBar := ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 2; borderColor: #inset.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	scroller := TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	self on: #mouseEnter send: #mouseEnter: to: self.	self on: #mouseLeave send: #mouseLeave: to: self.	self extent: 150@120! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 08:59'!extent: newExtent	super extent: (newExtent max: (self scrollbarWidth + 20)@16).	self resizeScrollBar; resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:52'!innerBounds	| inner w |	inner _ super innerBounds.	w _ self scrollbarWidth.	retractableScrollBar		ifTrue: [^ inner]		ifFalse: [^ (scrollBarOnLeft					ifTrue: [inner topLeft + ((w-1)@0) corner: inner bottomRight]					ifFalse: [inner topLeft corner: inner bottomRight - ((w-2)@0)])]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:11'!resizeScrollBar	| w topLeft |	w _ self scrollbarWidth.	topLeft _ scrollBarOnLeft		ifTrue: [retractableScrollBar ifTrue: [bounds topLeft - ((w-1)@0)]									ifFalse: [bounds topLeft]]		ifFalse: [retractableScrollBar ifTrue: [bounds topRight]									ifFalse: [bounds topRight - ((w-1)@0)]].	scrollBar bounds: (topLeft extent: w @ bounds height)! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:48'!resizeScroller	scroller bounds: self innerBounds! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/16/1998 01:09'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar bounds containsRect: aRectangle]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 7/6/1998 13:11'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset r |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	(r _ self totalScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:54'!scrollbarWidth  "Includes border"	^ 16! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/14/1998 15:52'!totalScrollRange	^ (scroller submorphBounds encompass: 0@0) height - (bounds height * 3 // 4) max: 0! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:22'!mouseEnter: event	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event].	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self privateAddMorph: scrollBar atIndex: 1.				self resizeScrollBar.				scrollBar changed]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:24'!mouseLeave: event	retractableScrollBar ifTrue:		[self privateRemoveMorph: scrollBar.		scrollBar privateOwner: nil].	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:29'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !!ScrollPane methodsFor: 'menu' stamp: 'sw 11/5/1998 14:14'!retractable: aBoolean	retractableScrollBar == aBoolean ifFalse: [self retractableOrNot "toggles it"]! !allows a user to select from a number of options!!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:38'!active	^listMorph getCurrentSelectionIndex > 0! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:15'!name	^name! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:16'!reset	listMorph selection: defaultValue! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:39'!value	^values at: listMorph getCurrentSelectionIndex! !!SelectionInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue0  list: list0 values: values0	name _ name0.	defaultValue _ defaultValue0.	listMorph _ list0.	values _ values0.! !!SelectionInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue  list: list  values: values	^self new name: name0  defaultValue: defaultValue  list: list  values: values! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'di 8/20/1998 09:18'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	"Labels can be either a sting with embedded crs, or a collection of strings"	| labelString |	(labels isMemberOf: String)		ifTrue: [labelString _ labels]		ifFalse: [labelString _ String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:20'!classList	^ classList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:23'!classListIndex	^ classListIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 10/9/1998 08:26'!classListIndex: anInteger	classListIndex _ anInteger.	classListIndex > 0 ifTrue:		[self dependents do:			[:dep | ((dep isKindOf: PluggableListView) and:				[dep setSelectionSelectorIs: #classListIndex:])					ifTrue: [dep controller controlTerminate]].		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex _ 0"]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:33'!classListSelectorTitle	^ 'Class List Menu'! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 16:08'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	contents _ aString.	classList _ #().  classListIndex _ 0.	selectorIndex _ 0.   	selectorList _ Cursor wait showWhile: [		(Symbol selectorsContaining: contents asString) asSortedArray].	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/21/1998 17:35'!defaultBackgroundColor	^ #lightCyan! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!implementors	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllImplementorsOf: aSelector]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:19'!messageList	"Find all the selectors containing what the user typed in."	^ selectorList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 10:58'!messageListIndex	"Answer the index of the selected message selector."	^ selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 19:28'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger.  Find all classes it is in."	selectorIndex _ anInteger.	selectorIndex = 0 ifFalse: [		classList _ Smalltalk allImplementorsOf: (selectorList at: selectorIndex).		classListIndex _ 0.		self changed: #messageListIndex.		"update my selection"		self changed: #classList]! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 17:04'!open	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	|  selectorListView typeInView topView classListView |	World ifNotNil: [^ self openAsMorph].	selectorIndex _ classListIndex _ 0.	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	typeInView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView window: (0@0 extent: 100@14);		askBeforeDiscardingEdits: false.	topView addSubView: typeInView.	selectorListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	selectorListView window: (0 @ 0 extent: 100 @ 86).	topView addSubView: selectorListView below: typeInView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil	"never anything selected"		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	classListView window: (0 @ 0 extent: 100 @ 100).	topView addSubView: classListView toRightOf: typeInView.	topView label: 'Full Browser from Selector Fragment'.	topView minimumSize: 300 @ 200; maximumSize: 450@200.	topView subViews do: [:each | each controller].	topView controller open.! !!SelectorBrowser methodsFor: 'all' stamp: 'di 12/17/1998 09:47'!openAsMorph	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	| window typeInView selectorListView classListView |	window _ (SystemWindow labelled: 'later') model: self.	selectorIndex _ classListIndex _ 0.	typeInView _ PluggableTextMorph on: self 		text: #contents accept: #contents:notifying:		readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView acceptOnCR: true.	window addMorph: typeInView frame: (0@0 corner: 0.5@0.14).	selectorListView _ PluggableListMorph on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	window addMorph: selectorListView frame: (0@0.14 corner: 0.5@1).	classListView _ PluggableListMorph on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	window addMorph: classListView frame: (0.5@0 corner: 1@1).	window setLabel: 'Full Browser from Selector Fragment'.	window openInWorldExtent: 450@200! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:50'!selectedClass	"Answer the currently selected class."	classListIndex = 0 ifTrue: [^nil].	MessageSet parse: (classList at: classListIndex) 		toClassAndSelector: [:cls :sel | ^ cls].! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:48'!selectedClassName	"Answer the name of the currently selected class."	classListIndex = 0 ifTrue: [^nil].	^ self selectedClass name! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:29'!selectedMessageName	"Answer the name of the currently selected message."	selectorIndex = 0 ifTrue: [^nil].	^ selectorList at: selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:32'!selectorMenu: aMenu	^ aMenu labels: 'sendersimplementors'	lines: #()	selections: #(senders implementors)! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:37'!selectorMenuTitle	^ self selectedMessageName ifNil: ['<no selection>']! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!senders	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllCallsOn: aSelector]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/8/1998 11:16'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	self wait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	^blockValue! !!SequenceableCollection methodsFor: 'comparing' stamp: 'di 1/15/1999 00:03'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's size, and each of the receiver's elements equal the corresponding element of otherCollection.  This should probably replace the current definition of = ."	| size |	(size _ self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index | (self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true! !!SequenceableCollection methodsFor: 'accessing' stamp: 'TAG 11/6/1998 16:06'!anyOne	^ self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:32'!atPin: index 	"Return the index'th element of me if possible.	Return the first or last element if index is out of bounds."	index < 1 ifTrue: [^ self first].	index > self size ifTrue: [^ self last].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:42'!atWrap: index 	"Return the index'th element of me.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds."	(index < 1 or: [index > self size]) ifTrue:		[^ self at: (index - 1 \\ self size) + 1].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:46'!atWrap: index put: value	"Store value into the index'th element of me.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds."	(index < 1 or: [index > self size]) ifTrue:		[^ self at: (index - 1 \\ self size) + 1 put: value].	^ self at: index put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:20'!identityIndexOf: anElement 	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer 0."	^self identityIndexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:21'!identityIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | (self at: i) == anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:36'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index _ self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index _ self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:27'!sixth	"Answer the sixth element of the receiver. Create an error notification if 	the receiver contains fewer than five elements."	^ self at: 6 ifAbsent: [self error: 'element not found']! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsCollect: aBlock 	"Evaluate aBlock with my elements taken two at a time, and return an Array with the results"	^ (1 to: self size // 2) collect:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect:	[:a :b | b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsDo: aBlock 	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"	1 to: self size // 2 do:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'converting' stamp: 'TAG 11/6/1998 15:55'!@ aCollection 	^ self with: aCollection collect: [:a :b | a @ b]! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray _ FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray _ IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'djm 11/20/1998 05:44'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: String)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray _ WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'di 11/6/1998 09:35'!isSequenceable	^ true! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:04'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur + snd duration].	^ dur! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/1998 16:49'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1),		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName)		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.			(for file://, directory is converted to local delimiters.)type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.altURL		When a FTP server holds some web pages, the altURL of those pages is often			different from the FTP directory.  Put the altURL here.  If the directory is 			'public_html/Squeak/', the altURL might be 'www.webPage.com/~kaehler2/			Squeak/'.urlObject	An instance of a subclass of Url.  It is very good at parsing complex urls.			Relative references.  file:// uses this.  Use this in the future instead of 			server and directory inst vars.			!]style[(677 8 685)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:47'!getDirectory	"Return a stream with a listing of the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'LIST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'getting directory LIST'; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:48'!getFileList	"Return a stream with a list of files in the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'NLST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'getting file list NLST'; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:49'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; space;		show: fileNameOnServer; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"a RWBinaryOrTextStream"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:50'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		^ dataStream].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 20:29'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: 'ftp: '; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 ') == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	"Transcript show: resp; cr."	(resp beginsWith: '227 ') ifFalse: [ "Check for Entering Passive Mode"		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:50'!openNoDataFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  No dataPort is opened.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: 'ftp: ', server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 12/14/1998 21:52'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'STOR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'storing file ', fileNameOnServer; cr.	"Transcript show: 'store via port ', dd portNum printString; cr."	dd sendData: fileStream contentsOfEntireFile.	dd close.	(rr _ so responseOK) == true ifFalse: [		(rr beginsWith: '426 ') ifTrue: [^ rr, ' (Server may be full.)'].			"Connection closed, transfer aborted"		^ rr].	"150 Opening BINARY mode data connection"	(resp _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"226 Transfer complete."! !!ServerDirectory methodsFor: 'do ftp' stamp: 'ar 11/24/1998 14:02'!putFile: fileStream named: fileNameOnServer retry: aBool	"ar 11/24/1998 Do the usual putFile:named: operation but retry if some error occurs and aBool is set. Added due to having severe transmission problems on shell.webpage.com."	| resp |	[[resp _ self putFile: fileStream named: fileNameOnServer] 		ifError:[:err :rcvr| resp _ '5xx ',err]. "Report as error"	aBool and:[resp size > 0 and:[resp first ~= $2]]] whileTrue:[		(self confirm:('Error storing ',fileNameOnServer,' on the server.\(',resp,',)\Retry operation?') withCRs) ifFalse:[^resp].	].	^resp! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:20'!checkNames: list	"Look at these names for update and see if they are OK"list do: [:local |	(local count: [:char | char == $.]) > 1 ifTrue: [		self inform: 'File name ',local,'may not have more than one period'.	^ false].	(local at: 1) isDigit ifTrue: [		self inform: 'File name ',local,'may not begin with a number'.	^ false].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		self inform: 'File name ',local,'may not contain % / * or space'.	^ false]].^ true! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 1/14/1999 21:54'!checkServers	"Check that all servers are up and have the latest Updates.list.  Warn user when can't write to a server that can still be read."	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (aServer altUrl size > 0) ifTrue: ["no ftp"			strm _ HTTPSocket httpGet: aServer altUrl, 'updates/updates.list' 						accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'ar 11/24/1998 13:52'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2075)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'ar 11/24/1998 13:53'!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 1/13/1999 12:37'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (#Squeak2.3) at the end of the file.  Current version of Squeak must be the old one when this is done.	ServerDirectory new updateInstallVersion: 'Squeak2.3'      "	| myServers updateStrm names choice |[names _ ServerDirectory groupNames asSortedArray.choice _ (SelectionMenu labelList: names selections: names) startUp.choice == nil] whileFalse: [	myServers _ (ServerDirectory groupNamed: choice) checkServers.	myServers size = 0 ifTrue: [self inform: 'checkServers failed on one of those'].	updateStrm _ myServers first getFileNamed: 'updates.list'.	Utilities position: updateStrm 	"checks for current OLD version"			atVersion: (Smalltalk at: #EToySystem) version.			"append name to updates"	updateStrm setToEnd.	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: '#', newVersion; nextPut: Character cr.	myServers do: [:aServer |		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Update.list written on server ', aServer moniker].			]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:01'!altUrl	"When a ftp server also has http access, use this to store the http url"	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 20:56'!altUrl: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:24'!bareDirectory	^ directory first == $/ 		ifTrue: [directory copyFrom: 2 to: directory size]		ifFalse: [directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/19/1998 18:54'!copy	| new |	new _ self clone.	new urlObject: urlObject copy.	^ new! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 15:00'!directory	"String of part of url that is the directory. Has slashes as separators"	urlObject ifNotNil: [^ urlObject pathDirString].	^ directory! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/26/1998 09:48'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash score match best sd |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].	"If this server is already known, copy in its userName and password"	type == #ftp ifFalse: [^ self].	score _ -1.	ServerDirectory serverNames do: [:name |		sd _ ServerDirectory serverNamed: name.		server = sd server ifTrue: [			match _ directory asLowercase charactersExactlyMatching: sd directory asLowercase.			match > score ifTrue: [score _ match.  best _ sd]]].	best 		ifNil: [self fromUser]		ifNotNil: [user _ best user.  self password: best password].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 12/14/1998 19:45'!moniker	"a plain language name for this directory"	moniker ifNotNil: [^ moniker].	directory ifNotNil: [^ self server].	urlObject ifNotNil: [^ urlObject toText].	^ ''! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/23/1998 09:41'!printOn: aStrm	aStrm nextPutAll: self class name; nextPut: $<.	aStrm nextPutAll: self moniker.	aStrm nextPut: $>.! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:25'!realUrl	"a fully expanded version of the url we represent.  Prefix the path with http: or ftp: or file:"	type = #file ifTrue: [self fileNameRelativeTo: self.				^ urlObject toText].	^ type asString, '://', self pathName	! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 18:18'!server	^ server! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:22'!slashDirectory	^ directory first == $/ 		ifTrue: [directory]		ifFalse: ['/', directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:43'!type	^ type! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:01'!url	"This was mis-named at the beginning.  Eventually convert over to altUrl and use this for the real url."	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:44'!urlObject	^ urlObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:56'!urlObject: aUrl	urlObject _ aUrl! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 22:16'!user	^ user! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:04'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	type == #file ifTrue: [FileDirectory createDirectory: localName].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:20'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	type == #file ifTrue: [FileDirectory deleteFileNamed: localName].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:49'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:58'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	urlObject ifNotNil: [		new urlObject path: (new urlObject path) copy.		(new urlObject path) removeLast; addLast: localFileName; addLast: ''.		^ new].	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 13:21'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry first]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 12/10/1998 11:56'!fileNamed: fullName	"Create a RemoteFileStream for writing.  If the file exists, do not complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream fileNamed: (file fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	^ remoteStrm	"no actual writing till close"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 19:29'!fullNameFor: aFileName	"Convention: 	If it is an absolute path, directory stored with a leading slash, and url has no user@.	If relative path, directory stored with no leading slash, and url begins user@.	Should we include ftp:// on the front?"	urlObject ifNotNil: [^ urlObject pathString, aFileName].	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	directory isEmpty ifTrue: [^ server, 		self pathNameDelimiter asString, aFileName].	^ (directory first == $/ ifTrue: [''] ifFalse: [user,'@']), 		server, self slashDirectory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	^ self fileAndDirectoryNames includes: localName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:27'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:40'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:25'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readOnly.	file type == #file ifTrue: [		^ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)].	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:59'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 1/14/1999 20:54'!pathName	"Path name as used in reading the file.  with slashes for ftp, with local file delimiter (:) for a file: url"	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [user, '@', server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:34'!pathNameDelimiter	"the separator that is used in URLs"	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:12'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	urlObject ifNotNil: [^ (urlObject path copy) removeLast; yourself].	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'di 12/5/1998 22:37'!readOnlyFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 15:11'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:36'!serverDelimiter	"the separator that is used in the place where the file actually is.  ftp server or local disk."	^ type == #file: ifTrue: [FileDirectory default pathNameDelimiter]		ifFalse: [^ $/]	"for ftp, http"! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group	"NOTE: This is an association whose key is the anme of the group, and	whose value is an array of serverDirectories, the first of which is	deemed to be the group directory."	^ group! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:54'!removeFromGroup	"Allowable if not in a group presently"	group ifNotNil:		["Group is an association shared by all members.		Therefore all will feel this removal"		group value: (group value copyWithout: self).		group _ nil  "...and I'm outa here"]! !!ServerDirectory methodsFor: 'initialize' stamp: 'tk 11/26/1998 09:50'!fromUser	"Ask the user for all data on a new server.  Save it in a named server."  ! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 12/29/1998 22:46'!defaultStemUrl	"For writing on an FTP directory.  Users should insert their own server url here.""ftp://jumbo.rd.wdi.disney.com/raid1/people/dani/Books/Grp/Grp""	ServerDirectory defaultStemUrl	"| rand dir |rand _ String new: 4.1 to: rand size do: [:ii |	rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].dir _ self serverNamed: 'DaniOnJumbo'.^ 'ftp://', dir server, dir slashDirectory, '/BK', rand! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 9/8/1998 11:57'!newFrom: aSimilarObject	"Must copy the urlObject, so they won't be shared"	| inst |	inst _ super newFrom: aSimilarObject.	inst urlObject: aSimilarObject urlObject copy.	^ inst! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 16:01'!addGroup: serverArray named: nameString	| groupAssn |	serverArray do: [:server | server removeFromGroup].	groupAssn _ nameString -> serverArray asArray copy.	serverArray do: [:server | server group: groupAssn].! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:24'!addServer: server named: nameString	Servers at: nameString put: server! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:15'!groupNamed: nameString	"Return the first server in the group of this name."	| grp server |	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [nameString = server groupName						ifTrue: [^ server]]].	^ self error: 'Server name not found'! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:03'!groupNames	"Return the names of all registered groups of servers, including individual servers not in any group.  Note: A serverDirectory that is a member of a group will return an array of the servers in its group.  The first server in that array represents the group, and its name is the name of the goup."	| grp names server |	names _ OrderedCollection new.	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [names add: server groupName]].	^ names asSortedArray! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 14:29'!removeServerNamed: nameString	Servers removeKey: nameString! !!ServerDirectory class methodsFor: 'available servers' stamp: 'tk 12/10/1998 12:29'!serverNamed: nameString	^ Servers at: nameString asString		ifAbsent: [self error: 'Server name not found']! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 13:30'!serverNames	^ Servers keys asSortedArray! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 10/2/1998 07:46'!asStream	"Return a RemoteFileStream (subclass of RWBinaryOrTextStream) on the contents of the remote file I represent.  For reading only."	^ self oldFileNamed: self fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 15:01'!fileName	"should this be local or as in a url?"	urlObject ifNotNil: [^ urlObject path last].	"path last encodeForHTTP ?"	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 14:45'!fileName: aStringurlObject ~~ nil  "type == #file" 	ifTrue: [urlObject path at: urlObject path size put: aString]	ifFalse: [fileName _ aString]! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/23/1998 17:24'!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForDirectory, self fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/6/1998 17:29'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	type == #file ifTrue: [fileName _  ''. ^ self].	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!Set methodsFor: 'converting' stamp: 'ar 11/20/1998 16:34'!asSet	^self! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!defaultElement	^0! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!size	^super size * 2! !This class stores points that are in short integer range (e.g., -32767 <= value <= 32768). It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!defaultElement	"Return the default element of the receiver"	^0@0! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!size	^self basicSize! !This class is run-length encoded representation of short integer (e.g., 16bit signed integer values)!!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:26'!at: index	"Return the short value at the given index"	| rlIndex |	index < 1 ifTrue:[^self errorSubscriptBounds: index].	rlIndex _ index.	self lengthsAndValuesDo:[:runLength :runValue|		rlIndex <= runLength ifTrue:[^runValue].		rlIndex _ rlIndex - runLength].	"Not found. Must be out of range"	^self errorSubscriptBounds: index! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:18'!at: index put: value	"ShortRunArrays are read-only"	^self shouldNotImplement.! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:39'!compressionRatio	"Return the compression ratio.	The compression ratio is computed based	on how much space would be needed to	store the receiver in a ShortIntegerArray"	^(self size asFloat * 0.5) "Would need only half of the amount in ShortIntegerArray"		/ (self runSize max: 1)! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:21'!lengthAtRun: index	"Return the length of the run starting at the given index"	^(self basicAt: index) bitShift: -16! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!runSize	"Return the number of runs in the receiver"	^self basicSize! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!size	"Return the number of elements stored in the receiver"	| n |	n _ 0.	"Note: The following loop is open-coded for speed"	1 to: self basicSize do:[:i|		n _ n + ((self basicAt: i) bitShift: -16).	].	^n! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:29'!species	"Answer the preferred class for reconstructing the receiver."	^ShortIntegerArray! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:22'!valueAtRun: index	"Return the value of the run starting at the given index"	| uShort |	uShort _ (self basicAt: index) bitAnd: 16rFFFF.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:31'!do: aBlock	"Evaluate aBlock with all elements of the receiver"	self lengthsAndValuesDo:[:runLength :runValue|		"Use to:do: instead of timesRepeat: for compiler optimization"		1 to: runLength do:[:i|			aBlock value: runValue.		].	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:25'!lengthsAndValuesDo: aBlock	"Evaluate aBlock with the length and value of each run in the receiver"	| basicValue length value |	1 to: self basicSize do:[:i|		basicValue _ self basicAt: i.		length _ basicValue bitShift: -16.		value _ basicValue bitAnd: 16rFFFF.		value _ (value bitAnd: 16r7FFF) - (value bitAnd: 16r8000).		aBlock value: length value: value.	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 21:05'!valuesCollect: aBlock	"Evaluate aBlock with each of the receiver's values as the argument. 	Collect the resulting values into a collection like the receiver. Answer 	the new collection."	| newArray newValue |	newArray _ self class basicNew: self basicSize.	1 to: self runSize do:[:i|		newValue _ aBlock value: (self valueAtRun: i).		newArray setRunAt: i toLength: (self lengthAtRun: i) value: newValue.	].	^newArray! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/15/1998 17:22'!valuesDo: aBlock	self lengthsAndValuesDo:[:runLength :runValue| aBlock value: runValue]! !!ShortRunArray methodsFor: 'printing' stamp: 'ar 11/3/1998 17:41'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll:' ( '.	self lengthsAndValuesDo:[:runLength :runValue |		aStream			nextPutAll:' (';			print: runLength;			space;			print: runValue;			nextPut:$).	].	aStream nextPutAll:' )'.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:02'!setRunAt: i toLength: runLength value: value	(value < -16r7FFF or:[value > 16r8000]) ifTrue:[^self errorImproperStore].	(runLength < 0 or:[runLength > 16rFFFF]) ifTrue:[^self errorImproperStore].	self basicAt: i put: (runLength bitShift: 16) + 		((value bitAnd: 16r7FFF) - (value bitAnd: -16r8000)).! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:00'!setRuns: runArray values: valueArray	| runLength value |	1 to: runArray size do:[:i|		runLength _ runArray at: i.		value _ valueArray at: i.		self setRunAt: i toLength: runLength value: value.	].! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!new: n	"ShortRunArrays must be created with either		someCollection as: ShortRunArray	or by using		ShortRunArray runs: runCollection values: valueCollection.	"	^self shouldNotImplement! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:35'!newFrom: aCollection	"Compress aCollection into a ShortRunArray"	| lastValue lastRun runs values |	aCollection isEmpty ifTrue:[^self runs:#() values: #()].	runs _ WriteStream on: (WordArray new: 100).	values _ WriteStream on: (ShortIntegerArray new: 100).	lastValue _ aCollection first.	lastRun _ 0.	aCollection do:[:item|		(item = lastValue and:[lastRun < 16r8000]) ifTrue:[			lastRun _ lastRun + 1.		] ifFalse:[			runs nextPut: lastRun.			values nextPut: lastValue.			lastRun _ 1.			lastValue _ item.		].	].	runs nextPut: lastRun.	values nextPut: lastValue.	^self runs: runs contents values: values contents! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!runs: runCollection values: valueCollection	^(self basicNew: runCollection size) setRuns: runCollection values: valueCollection! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:52'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	(target isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' action: #setPageSound:.			aCustomMenu add: 'set page visual' action: #setPageVisual:]		ifFalse:			[aCustomMenu add: 'change action selector' action: #setActionSelector.			aCustomMenu add: 'change arguments' action: #setArguments.			aCustomMenu add: 'change when to act' action: #setActWhen.			((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue:				[aCustomMenu add: 'set target' action: #setTarget:]].! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:55'!setPageSound: event	^ target menuPageSoundFor: self event: event! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:55'!setPageVisual: event	^ target menuPageVisualFor: self event: event! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sw 10/22/1998 20:37'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [oldColor ifNotNil: [self color: (oldColor mixed: 1/2 with: Color white)].				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [oldColor ifNotNil: [self color: oldColor]].! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 17:55'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		a Symbol""arguments _ arguments.		All weakly copied"actWhen _ actWhen veryDeepCopyWith: deepCopier.oldColor _ oldColor veryDeepCopyWith: deepCopier.! !This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.The 'get' commands above make use of an internal buffer.  So intermixing these two commands and regular Socket recieve commands can cause problems.!!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done _ (chunk = ('.', String cr)) ].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 02:10'!getResponse	"Get a one-line response from the server.  The final LF is removed from the line, but the CR is left, so that the line is in Squeak's text format"	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line _ WriteStream on: String new.	buffer ifNil: [		buffer _ String new.		bufferPos _ 0 ].	[		"look for a LF in the buffer"		idx _ buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos _ idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos _ 0.		buffer _ String new.		self waitForDataQueryingUserEvery: 30.		buffer _ self getData.		true	] whileTrue.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/16/1998 14:37'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				self isConnected ifFalse: [					self destroy.					self error: 'server closed connection'].				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 6/8/1998 16:05'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !This is a first cut at a simple MIDI output port.!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:10'!close	"Close this MIDI port."	portNumber ifNotNil: [self primMIDIClosePort: portNumber].	accessSema _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:23'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	portNumber ifNil: [^ self error: 'Use "openOn:" to open a MIDI port initially'].	self primMIDIClosePort: portNumber.	self primMIDIOpenPort: portNumber readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	accessSema _ Semaphore forMutualExclusion.	lastCommandByteOut _ Array new: 16 withAll: 0.  "clear running status"! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:09'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	portNumber _ portNum.	accessSema _ Semaphore forMutualExclusion.	self ensureOpen.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 15:48'!portNumber	"Answer my port number."	^ portNumber! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte1					with: dataByte2)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber from: aByteArray at: 0].! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:47'!bufferTimeStampFrom: aByteArray	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."	^ ((aByteArray at: 1) bitShift: 24) +	  ((aByteArray at: 2) bitShift: 16) +	  ((aByteArray at: 3) bitShift: 8) +	   (aByteArray at: 4)! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:53'!flushInput	"Read any lingering MIDI data from this port's input buffer."	| buf |	buf _ ByteArray new: 1000.	[(self readInto: buf) > 0] whileTrue.! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/12/1998 15:49'!readInto: aByteArray	"Read any data from this port into the given buffer."	^ self primMIDIReadPort: portNumber into: aByteArray! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/12/1998 16:04'!primMIDIClosePort: portNum	"Close the given MIDI port. Don't fail if port is already closed."	<primitive: 521>! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:48'!primMIDIReadPort: portNum into: byteArray	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."	<primitive: 528>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:49'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33'!initialize	"SimpleMIDIPort initialize"	InterfaceClockRate _ 1000000.	DefaultPortNumber _ 0.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!openDefault	"Answer a new instance of me opened on the default MIDI port."	^ self openOnPortNumber: DefaultPortNumber! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 10/12/1998 16:36'!openOnPortNumber: portNum	"Answer a new instance of me for the given MIDI port number."	"Details: All clients of a particular MIDI port should share the same instance of me. This allows accesses to the port to be serialized and shared port-related state state to be maintained."	SimpleMIDIPort allInstancesDo: [:p |		p portNumber = portNum ifTrue: [			"share the existing port object for this port number"			^ p]].	^ super new openOnPortNumber: portNum! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 1/13/1999 08:11'!closeAllPorts	"Close all MIDI ports."	"SimpleMIDIPort closeAllPorts"	| lastPortNum |	lastPortNum _ self primPortCount - 1.	0 to: lastPortNum do: [:portNum | self basicNew primMIDIClosePort: portNum].! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:57'!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for input:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:10'!midiIsSupported	"Answer true if this platform supports MIDI."	^ self primPortCount > 0! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:58'!outputPortNumFromUser	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort outputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for output:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 2) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:46'!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName _ self primPortNameOf: portNum.	dir _ self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:22'!primPortCount	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."	<primitive: 523>	^ 0! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:27'!primPortDirectionalityOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 524>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:23'!primPortNameOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 525>	self primitiveFailed.! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 19:24'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""arguments _ arguments.		All weakly copied"minVal _ minVal veryDeepCopyWith: deepCopier.		"will be fast if integer"maxVal _ maxVal veryDeepCopyWith: deepCopier.truncate _ truncate veryDeepCopyWith: deepCopier.! !Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph's registration point, rotation center, or ticksToDwell.New -- using transform morphs to rotate the finished player.  How get it rotated back and the rotationDegrees to be right?  We cancel out rotationDegrees, so how remember it?Registration point convention:  In a GraphicFrame, reg point is relative to this image's origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 20:12'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| w aPaintBox aPal  aPosition |	(w _ aPasteUpMorph world) addMorphFront: self.	aPaintBox _ w paintBox.	(aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPosition _ aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[aPosition _ aPaintBox position].	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	aPaintBox position: aPosition.	palette _  aPaintBox.	w addMorphFront: aPaintBox.  "bring to front"	palette position: aPosition.	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 8/2/1998 13:39'!addRotationScaleHandles	"Rotation and scaling handles"	| fwdButton pt toggle |	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView setupAngle direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 8/5/1998 20:13'!cancelOutOfPainting	self delete.	dimForm ifNotNil: [dimForm delete].	emptyPicBlock value.	"note no args to block!!"	hostView changed.	^ nil	"Tell them we cancelled"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 7/30/1998 16:21'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^true! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^true! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/30/1998 17:30'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !!SketchEditorMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:24'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.hostView _ deepCopier references at: hostView ifAbsent: [hostView].enclosingPasteUpMorph _ deepCopier references at: enclosingPasteUpMorph 			ifAbsent: [enclosingPasteUpMorph].! !!SketchEditorMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:23'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."hostView _ hostView.		Weakly copied"stampForm _ stampForm veryDeepCopyWith: deepCopier.canvasRectangle _ canvasRectangle veryDeepCopyWith: deepCopier.palette _ palette veryDeepCopyWith: deepCopier.currentColor _ currentColor veryDeepCopyWith: deepCopier.ticksToDwell _ ticksToDwell veryDeepCopyWith: deepCopier.rotationCenter _ rotationCenter veryDeepCopyWith: deepCopier.registrationPoint _ registrationPoint veryDeepCopyWith: deepCopier.newPicBlock _ newPicBlock veryDeepCopyWith: deepCopier.emptyPicBlock _ emptyPicBlock veryDeepCopyWith: deepCopier.action _ action veryDeepCopyWith: deepCopier.paintingForm _ paintingForm veryDeepCopyWith: deepCopier.dimForm _ dimForm veryDeepCopyWith: deepCopier.buff _ buff veryDeepCopyWith: deepCopier.brush _ brush veryDeepCopyWith: deepCopier.paintingFormPen _ paintingFormPen veryDeepCopyWith: deepCopier.formCanvas _ formCanvas veryDeepCopyWith: deepCopier.picToBuff _ picToBuff veryDeepCopyWith: deepCopier.brushToBuff _ brushToBuff veryDeepCopyWith: deepCopier.buffToBuff _ buffToBuff veryDeepCopyWith: deepCopier.buffToPic _ buffToPic veryDeepCopyWith: deepCopier.rotationButton _ rotationButton veryDeepCopyWith: deepCopier.scaleButton _ scaleButton veryDeepCopyWith: deepCopier.strokeOrigin _ strokeOrigin veryDeepCopyWith: deepCopier.cumRot _ cumRot veryDeepCopyWith: deepCopier.cumMag _ cumMag veryDeepCopyWith: deepCopier.undoBuffer _ undoBuffer veryDeepCopyWith: deepCopier.lastEvent _ lastEvent veryDeepCopyWith: deepCopier.currentNib _ currentNib veryDeepCopyWith: deepCopier.enclosingPasteUpMorph _ enclosingPasteUpMorph.	"weakly copied"                              ! !The morph that results when the user draws a color bitmap using the PaintBox (SketchEditorMorph and PaintBoxMorph).  forwardDirection is the angle at which the object will go forward.  When the rotationStyle is not #normal, then forwardDirection is any angle, while the rotation is highly restricted.  If flexed, this is remembered by the Transform morph.  For non-normal rotationStyle, it is rotationDegrees.setupAngle (a property) is where the user put the green arrow to indicate which direction on the picture is forward.  When #normal, draw the morph initially at (0.0 - setupAngle).  The enclosing TransformationMorph then rotates it to the true angle. rotationDegrees  In a #normal object, rotationDegrees is constant an equal to setupAngle.	For non-normal, it is the direction the object is going.When repainting, set it back to its original state. The green arrow is set to setupAngle, and the sketch is shown as drawn originally (rotationDegrees = 0). rotationStyle = normal (turns), leftRight, upDown, fixed.  When leftRight upDown or fixed, bit map has severe restrictions.!!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:11'!forwardDirection	"Return my forward direction.  If #normal I am not flexed."	^ rotationStyle == #normal 		ifTrue: [0.0]		ifFalse: [rotationDegrees]	"fwd dir kept here when leftRight, upDown, none"! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:52'!forwardDirection: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #forwardDirection]		ifFalse: [self setProperty: #forwardDirection toValue: degrees].! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/9/1998 13:15'!originalForm: aForm	originalForm _ aForm! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 11:54'!setupAngle	"Return the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	^ (self valueOfProperty: #setupAngle) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:53'!setupAngle: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #setupAngle]		ifFalse: [self setProperty: #setupAngle toValue: degrees].! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:35'!doesOwnRotation	"When not #normal, don't let to TransformMorph to rotate my image"	^ rotationStyle ~~ #normal! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 12:05'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ 0.0 - self setupAngle]			"let TransformationMorph do directional image turn, we subtract green arrow angle"		ifFalse: [adjustedAngle _ 0.0].	"leftRight, upDown, none"	((adjustedAngle = 0.0) and: [0.0@0.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: ["do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!SketchMorph methodsFor: 'menu' stamp: 'tk 7/6/1998 15:31'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	"costumee ifNotNil: [self forwardDirection: costumee direction]."  "how say this?"	self editDrawingIn: self pasteUpMorph forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/5/1998 12:54'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w oldRotation bnds sketchEditor pal |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	oldRotation _ rotationDegrees.	forBackground		ifTrue:			[bnds _ aPasteUpMorph boundsInWorld]		ifFalse:			[bnds _ (self boundsInWorld expandBy: (60 @ 60)) intersect: self world bounds.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds pasteUpMorph: aPasteUpMorph.		"self rotationDegrees: 0.  inside the init"	self rotationDegrees: oldRotation.  "restore old rotation so that cancel leaves it right"	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self topRendererOrSelf position: aRect origin.			self rotationStyle: sketchEditor rotationStyle.			self setupAngle: sketchEditor forwardDirection.			self rotationDegrees: sketchEditor forwardDirection.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			((pal _ aPasteUpMorph standardPalette) notNil and: [pal isInWorld]) ifTrue:				[pal viewMorph: self]]! !!SketchMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'change reporting' stamp: 'tk 7/6/1998 14:26'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form.			All normal rotation handled by TransformMorph.rotationDegrees:"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #editDrawing to: aHalo innerTarget! !!SketchMorph class methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1998 17:15'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !Holds information about user-defined instance variables in Players.!!SlotInformation methodsFor: 'all' stamp: 'sw 11/9/1998 14:09'!documentation	documentation ifNil: [documentation _ 'This is an instance variable defined by you.  Please edit this into your own meaningful documentation.'].	^ documentation! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:33'!documentation: d	documentation _ d! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type	type ifNil: [type _ #number].	^ type! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type: aType	type _ aType! !My instances are 30-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:12'!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 1>	aNumber isInteger ifTrue: [^ super + aNumber].	^ aNumber adaptToInteger: self andSend: #+! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmallInteger methodsFor: 'copying' stamp: 'tk 8/19/1998 16:04'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 14:47'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:09'!moreObjects	"Return true if there appears to be another object following this one on the file."	| byte |	byteStream atEnd ifTrue: [^ false].	"off end of file"	(byte _ byteStream peek) ifNil: [^ false].	"off end of file"	byte = 33 "$!! asciiValue" ifTrue: [^ false].	byte = 0 ifTrue: [^ false].	^ byte <= RefTypes size		"between 1 and 16"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/4/1998 19:47'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ #marked.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/14/1999 11:32'!readInstance	"Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject _ anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/14/1999 23:40'!readShortInst	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	className _ self readShortRef.	"class symbol in two bytes of file pos"	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject _ anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/13/1999 16:02'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses (i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo) ...).  Thank you Mark Wai for the bug fix."	| normal aName newName newCls trans rList |	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars" 	classInstVars _ super next.	"Array of arrays"	normal _ Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: [#()]) = #(0 'dependents' 'costume') ifTrue: [		trans _ 1].	"now (0 costume costumes).  Do the conversion of Player class 			inst vars in Update 509."	classInstVars do: [:list |		aName _ (list at: 1) asSymbol.		rList _ list.		newName _ renamed at: aName ifAbsent: [aName].		newCls _ Smalltalk at: newName 				ifAbsent: [self error: 'UniClass definition missing'].		(trans == 1 and: [newCls inheritsFrom: Player]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList _ rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		newCls class instSize = (normal+(rList size)-1) ifFalse: [			self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		2 to: rList size do: [:ii |			newCls instVarAt: normal+ii-1 put: (rList at: ii)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:28'!saveClassInstVars	"Install the values of the instance variables of UniClasses.  classInstVars is an array of arrays (#Player3 (Player3 class's inst var scripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	self uniClasesDo: [:aUniClass | 		mySize _ aUniClass class instSize.		mySize = normal ifFalse: [			list _ OrderedCollection new.			list add: aUniClass name.	"a symbol"			normal+1 to: mySize do: [:ii | 				list addLast: (aUniClass instVarAt: ii)]].		classInstVars add: list asArray].	classInstVars _ classInstVars asArray.	! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:02'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream reading: true.	ScannedObject _ self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:56'!setStream: aStream reading: isReading	"Initialize me. "	super setStream: aStream reading: isReading.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new].		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:32'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class." | uniClasses normal more aUniClass mySize |"Any classes used in the structure of classInstVars must be written out also!!	dummy nextPut: (OrderedCollection new).But for now, only uses Arrays."uniClasses _ Set new.normal _ Object class instSize.more _ true.[more] whileTrue: [	more _ false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass _ each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize _ aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more _ true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 1/14/1999 13:16'!transparentColorrcc0	^ TranslucentColor! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 10/7/1998 14:42'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isValid ifTrue: [self primSocketDestroy: socketHandle].			Smalltalk unregisterExternalObject: semaphore.			socketHandle _ nil.			semaphore _ nil.			self unregister].! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 10/7/1998 14:43'!initialize	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex |	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: 0			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket methodsFor: 'primitives' stamp: 'ar 3/21/98 17:43'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 210>! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:40'!register	^self class register: self! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:41'!unregister	^self class unregister: self! !!Socket methodsFor: 'finalization' stamp: 'ar 3/21/98 17:44'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObject: semaphore.! !!Socket methodsFor: 'printing' stamp: 'jm 11/23/1998 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!Socket class methodsFor: 'instance creation' stamp: 'tk 10/9/1998 16:05'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'jm 10/14/1998 12:08'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	^ super new initialize! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList _ #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry _ portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!Socket class methodsFor: 'utilities' stamp: 'jm 11/23/1998 17:19'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"	Socket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock _ Socket new.	sock connectTo: serverAddr port: tcpPort.	[sock waitForConnectionUntil: (Socket deadlineSecs: 10).	 sock isConnected] whileFalse: [		(self confirm: 'Continue to wait for connection to ', hostName, '?') ifFalse: [			sock destroy.			^ self]].	sock sendData: 'echo!!'.	startTime _ Time millisecondClockValue.	[sock waitForDataUntil: (Socket deadlineSecs: 15).	 sock dataAvailable] whileFalse: [		(self confirm: 'Packet sent but no echo yet; keep waiting?') ifFalse: [			sock destroy.			^ self]].	echoTime _ Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:24'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	Socket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		self inform: 'Could not find an address for ', hostName.		^ #()].	sockets _ portList collect: [:portNum |		sock _ Socket new.		sock connectTo: serverAddr port: portNum].	deadline _ self deadlineSecs: timeOutSecs.	done _ false.	[done] whileFalse: [		unconnectedCount _ 0.		connectedCount _ 0.		waitingCount _ 0.		sockets do: [:s |			s isUnconnectedOrInvalid				ifTrue: [unconnectedCount _ unconnectedCount + 1]				ifFalse: [					s isConnected ifTrue: [connectedCount _ connectedCount + 1].					s isWaitingForConnection ifTrue: [waitingCount _ waitingCount + 1]]].		waitingCount = 0 ifTrue: [done _ true].		connectedCount = sockets size ifTrue: [done _ true].		Time millisecondClockValue > deadline ifTrue: [done _ true]].	result _ (sockets select: [:s | s isConnected])		collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^ result! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:25'!pingPortsOn: hostName	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"Socket pingPortsOn: 'www.disney.com'"	^ Socket		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:22'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 1/14/1999 15:24'!color: aColor	color _ aColor.	pixelValue32 _ aColor scaledPixelValue32! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 03:29'!display	^color display! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 1/14/1999 15:25'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	^pixelValue32! !!SolidFillStyle methodsFor: 'testing' stamp: 'ar 11/8/1998 18:34'!isSolidFill	^true! !!SolidFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:55'!asColor	^color! !!SolidFillStyle methodsFor: 'printing' stamp: 'ar 11/17/1998 00:29'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: color; nextPut:$).! !!SolidFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/8/1998 18:31'!color: aColor	^self new color: aColor! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount _ self monoSampleCount.	bytes _ ByteArray new: 2 * sampleCount.	dst _ 0.	1 to: sampleCount do: [:src |		s _ self at: src.		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 8/15/1998 14:35'!fromByteArray: aByteArray	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."	| n buf src w |	n _ aByteArray size // 2.	buf _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		w _ ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).		w > 32767 ifTrue: [w _ w - 65536].		buf at: i put: w.		src _ src + 2].	^ buf! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:13'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate _ 22050.	BufferMSecs _ 120.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:14'!useShortBuffer	"Experimental support for real-time MIDI input. This only works on platforms whose hardware allows very short buffer sizes. It has been tested on a Macintosh Powerbook G3."	"SoundPlayer useShortBuffer"	self shutDown.	BufferMSecs _ 15.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'ar 12/5/1998 16:38'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences disableSounds ifTrue: [^ self].	doQuickStart _ quickStart.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		"Check if startup was successful"		SoundSupported ifFalse:[^self].		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 12/5/1998 16:37'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	ActiveSounds _ OrderedCollection new.	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	SoundSupported _ true. "Assume so"	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 8/19/1998 08:11'!startReverb	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 12/5/1998 16:36'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	"ar 12/5/1998 Turn off the sound if not supported"	<primitive: 170>	SoundSupported _ false.! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:32'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordLevel _ 0.5.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel _ (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 7/4/1998 14:35'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 13:37'!convertssrrbpmmscn0: varDict ssrrrbpmmscn0: smartRefStrm	"These variables are automatically stored into the new instance ('stereo' 'samplingRate' 'recordedBuffers' 'recordProcess' 'bufferAvailableSema' 'paused' 'meteringBuffer' 'meterLevel' 'soundPlaying' 'currentBuffer' 'nextIndex' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('recordLevel' ) and deal with the information in ()"! !A SqueakPage is holder for a page of morphs that live on the disk or on a server.A URLMorph is a thumbnail sized stand-in for the page.  Clicking on it gets the page.An ObjectOut is a fake object that stands for an object that is out on the disk.  (Like ObjectTracer or ObjectViewer.)A MorphObjectOut is a subclass that stands for a Morph that is out on the disk.To find out how to make the pages of any BookMorph go out to the disk (or a server), see 	http://minnow.cc.gatech.edu/SqueakDoc.1 then go to 'SqueakPages'.A SqueakPage is always in-memory.  Its contentsMorph will be 'become-ed' to a MorphObjectOut tombstone when it goes out.  (A page may or may not be in the cache.  First put it in, then ask it for the data.)  Sending any message to the contentsMorph triggers the fetch.  Many URLMorphs may hold onto one page.  A page has a thumbnail.  A URLMorph points at its page object.States of a SqueakPage, and the transitions to another state:1) have a url as a string.  Then: (URLMorph grabURL: 'file://Ted''s/books/tryThis/p1').  	Drop it into any morph.2) have a URLMorph, with page==nil.     Click it.  (makes an empty page, installs 	it in the global page cache)3) have a URLMorph with a SqueakPage, with contentsMorph==nil, 	but page is not in the cache (this is a rare case).  ask page contentsMorph.4) OUT: have a URLMorph with a SqueakPage, with contentsMorph being a MorphObjectOut, 	and its page is in the cache.  Sending the contentsMorph any message brings it in and	becomes it to the morph.  (fix up morph's pointer to the page.)5) Totally IN:  a morph, owned by a SqueakPage, has a page in the cache.  	The morph is clean.   	Whenever someone triggers a purge (when?), contentsMorph is becomed	to a MorphObjectOut. (go to 4)	Causing the morph to execute layoutChanged marks the morph as dirty.	(morph's property #pageDirty is set to true) (go to 6)6) Totally IN and dirty.  	Whenever any other page is fetched from the disk or the net, all other 	dirty pages are written and marked clean.  (go to 5)Note that the entire tree of submorphs goes out -- hundreds of objects.  Bringing the object back in brings in the SqueakPage, installs it in the cache.  Classes other than PasteUpMorph can easily be made to send their contents out if there is any need.Note that every book is now automatically a WebBook.  We simply give a page a url and tell it to purge.url		a stringtitle		comment		thumbnail		contentsMorph		(1) a pasteUpMorph with other morphs in it.					(2) a MorphObjectOut.  Sending any message brings it in. 					(3) nil if the page has never been in this image.creationTime		creationAuthor		lastChangeTime		lastChangeAuthor policy		#alwaysWrite, #neverWrite, #ask.  (cache can override with a global policy)			(Explicit writing by user has policy #neverWrite)dirty 		(Morph>>layoutChanged sends changed: #SqueakPage. If policy==#check, 				then the page sets dirty_true.)			(If policy==#alwaysWrite, then set dirty when the page is retrieved from the cache.)Class MorphObjectOut has an instance variable called page.All messages to an MorphObjectOut cause it to be brought in.  Except the messages needed to write the MorphObjectOut on the disk as part of a parent's being sent out.  (size, class, instSize, instVar:at:.  Can rename these and call from its own version of the writing routine.)	To purge, go through the clean pages, and any that have world not equal to this world, entomb them.  	(If an object in the subtree is held by an object outside the tree, it will remain,  And will be duplicated when the tree comes back in.  This is a problem already in normal uses of SmartRefStream.)!]style[(458 39 3184)f1,f1Rhttp://minnow.cc.gatech.edu/SqueakDoc.1;,f1!!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!comment	comment ifNil: [^ ''] ifNotNil: [^ comment].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!comment: aString	aString isEmpty		ifTrue: [comment _ nil]		ifFalse: [comment _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:27'!contentsMorph	"Return what it is now.  If the morph is out on the disk, return nil.  Use fetchContents to get the data for sure."	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/11/1998 12:54'!contentsMorph: aPasteUpMorph	contentsMorph _ aPasteUpMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!fetchContents	"Make every effort to get contentsMorph."	self isContentsInMemory ifTrue: [^ contentsMorph].	^ self fetchInformIfError! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:48'!fetchContentsIfAbsent: failBlock	"Make every effort to get contentsMorph.  Assume I am in the cache already."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [^ failBlock value].			page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	url _ temp.	"don't care what it says"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 12/10/1998 11:46'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"	(url beginsWith: 'file:') ifTrue: [Transcript show: 'Fetching  ', url; cr].		page _ strm fileInObjectAndCode.	page isMorph 		ifTrue: [contentsMorph _ page]	"may be a bare morph"		ifFalse: ["copy over the state"			temp _ url.			temp2 _ policy.			self copyFrom: page.	"including contentsMorph"			url _ temp.	"I know best!!"			temp2 ifNotNil: [policy _ temp2]].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	contentsMorph setProperty: #SqueakPage toValue: self.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!isContentsInMemory	"Is my contentsMorph in memory, or is it an ObjectOut tombstone?  Be careful not to send it any message."	^ (contentsMorph xxxClass inheritsFrom: Object) and: [(contentsMorph == nil) not]! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 12/4/1998 01:00'!lastChangeTime	^ lastChangeTime! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:33'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds]."	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	do it when actually write"	self updateThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 17:45'!thumbnail	^ thumbnail! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!title	title ifNil: [^ ''] ifNotNil: [^ title].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!title: aString	aString isEmpty		ifTrue: [title _ nil]		ifFalse: [title _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/4/1998 20:34'!url	^ url! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 1/14/1999 23:50'!url: aString	| sd |	aString isEmpty ifTrue: [url _ nil. ^ self].	"Expand ./ and store as an absolute url"	sd _ ServerFile new.	sd fullPath: aString.	url _ sd realUrl.! !!SqueakPage methodsFor: 'private' stamp: 'tk 11/23/1998 17:31'!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/18/1998 11:31'!updateThumbnail	"Update my thumbnail from my morph."	| f scale scaleX scaleY shrunkF |	contentsMorph ifNil: [thumbnail _ nil. ^ self].	f _ contentsMorph imageForm.	scaleX _ MaxThumbnailWidthOrHeight asFloat / f height.	scaleY _ MaxThumbnailWidthOrHeight asFloat/ f width.	scale _ scaleX min: scaleY.  "choose scale that maintains aspect ratio"	shrunkF _ (f magnify: f boundingBox by: scale@scale smoothing: 2).	thumbnail _ Form extent: shrunkF extent depth: 8.  "force depth to be 8"	shrunkF displayOn: thumbnail.	contentsMorph allMorphsDo: [:m | m releaseCachedState].! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:40'!dirty: aBool	dirty _ aBool! !!SqueakPage methodsFor: 'saving' stamp: 'tk 10/8/1998 13:18'!policy	^ policy! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:39'!policy: aSymbol	policy _ aSymbol! !!SqueakPage methodsFor: 'saving' stamp: 'tk 12/16/1998 08:32'!prePurge	"Return self if ready to be purged, or nil if not"	self isContentsInMemory ifFalse: [^ nil].	contentsMorph ifNil: [^ nil].  "out already"	url ifNil: [^ nil].	"just to be safe"	^ (World ~~ nil and: [contentsMorph world == World]) 		ifTrue: [nil "showing now"] ifFalse: [self]! !!SqueakPage methodsFor: 'saving' stamp: 'tk 12/16/1998 08:24'!purge	"Replace my morph with a tombstone, if I am not in a world that is being shown."	(self prePurge) ifNotNil: [		contentsMorph become: (MorphObjectOut new xxxSetUrl: url page: self)].		"Simple, isn't it!!"! !!SqueakPage methodsFor: 'saving' stamp: 'tk 12/4/1998 01:48'!urlNoOverwrite: suggested	"Look in the directory.  If there is a file of this name, create a new name.  Keep track of highest numbers used as a hint."	| dir ll stem num local trial |	dir _ ServerFile new fullPath: suggested.	(dir includesKey: dir fileName) ifFalse: [^ url _ suggested].	"File already exists!!  Create a new name"	"Find the stem file name"	ll _ suggested findLast: [:char | char == $.].	ll = 0 ifFalse: [stem _ suggested copyFrom: 1 to: ll-1].	"remove .sp"	stem _ (stem stemAndNumericSuffix) at: 1.		"remove trailing number"	[stem last == $x] whileTrue: [stem _ stem allButLast].	num _ stem = RecentStem ifTrue: [RecentMaxNum+1] ifFalse: [1].	local _ dir fileName.	"ugh, take stem again..."	ll _ local findLast: [:char | char == $.].	ll = 0 ifFalse: [local _ local copyFrom: 1 to: ll-1].	"remove .sp"	local _ (local splitInteger) at: 1.		"remove trailing number"	local last == $x ifFalse: [local _ local , 'x'].	[trial _ local, num printString, '.sp'.		dir includesKey: trial] whileTrue: [num _ num + 1].	RecentStem _ stem.  RecentMaxNum _ num.	^ url _ stem, 'x', num printString, '.sp'! !!SqueakPage methodsFor: 'saving' stamp: 'tk 1/14/1999 12:30'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		lastChangeAuthor _ Utilities authorInitialsPerSe ifNil: ['*'].		lastChangeTime _ Time totalSeconds.		Cursor wait showWhile: [			remoteFile _ sf fileNamed: url.	"no notification when overwriting"			remoteFile fileOutClass: nil andObject: self.			"remoteFile close"].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPage class methodsFor: 'all' stamp: 'jm 6/18/1998 11:15'!initialize	"SqueakPage initialize"	MaxThumbnailWidthOrHeight _ 60.! !!SqueakPage class methodsFor: 'all' stamp: 'sw 7/6/1998 11:49'!newURLAndPageFor: aMorph	"Create a new SqueakPage whose contents is the given morph. Assign a URL for that page, record it in the page cache, and answer its URL."	| pg newURL stamp |	pg _ self new.	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: aMorph author: stamp.	newURL _ SqueakPageCache generateURL.	SqueakPageCache atURL: newURL put: pg.	^ newURL ! !A global cache of web pages known to this Squeak image.  Since there is a single, global page cache, it is implemented entirely as class methods.Once a page has an entry, keep it.  (url string -> A SqueakPage)  The SqueakPage has a thumbnail and other info, but may not have the contentsMorph.  The morph is purged when space is needed, and fetched from the server as needed.See SqueakPage's comment for the stages of in/out.!]style[(383 10 36)f1,f1LSqueakPage Comment;,f1!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'tk 11/24/1998 14:53'!initialize	"SqueakPageCache initialize"	GlobalPolicy _ #neverWrite.	PageCache _ Dictionary new: 100.		"forgets urls of pages, but ObjectOuts still remember them"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:06'!allURLs	"Answer a collection of URLs for all pages in the cache."	^ PageCache keys! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	| pg |	^ PageCache at: aURLString ifAbsent: [		pg _ SqueakPage new.		"stamp _ Utilities authorInitialsPerSe ifNil: ['*']."		"pg author: stamp."		"Need to deal with inst vars if we turn out to be new!!"		"pg url: aURLString. 	done by atURL:put:"		self atURL: aURLString put: pg.		pg]! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:06'!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	self halt.  "use atURL:"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:51'!atURL: aURLString oldPage: aPage	"Bring in page and return the object.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| myPage |	(myPage _ PageCache at: aURLString ifAbsent: [nil]) ifNotNil: [		^ myPage].	aPage url: aURLString.	"for consistancy"	PageCache at: aPage url put: aPage.	^ aPage! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 12/8/1998 21:51'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	aSqueakPage contentsMorph isInMemory ifTrue: [		aSqueakPage contentsMorph ifNotNil: [			aSqueakPage contentsMorph setProperty: #SqueakPage 				toValue: aSqueakPage]].	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/30/1998 15:08'!doPagesInMemory: aBlock	"Evaluate aBlock for each page whose contentsMorph is in-memory.  Don't add or remove pages while in this loop."	PageCache do: [:sqkPage |		sqkPage isContentsInMemory ifTrue: [aBlock value: sqkPage]].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 11/24/1998 14:52'!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| sd |	sd _ ServerFile new on: 'file:./'.	sd fileName: 'page1.sp'.	^ SqueakPage new urlNoOverwrite: sd pathForFile! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:02'!includesMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ true]].	^ false! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:11'!pageCache	^ PageCache! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:04'!pageForMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ squeakPage]].	^ nil! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 12/16/1998 08:30'!purge	"Replace morphs with tombstones in all pages that are clean and not being shown.  Write any dirty ones first, if allowed to."	| list |	list _ OrderedCollection new.	GlobalPolicy == #neverWrite 		ifTrue: [PageCache doPagesInMemory: [:aPage | list add: aPage prePurge]]			"Writing only done by user's command"		ifFalse: [			PageCache doPagesInMemory: [:aPage | aPage write					 list add: aPage prePurge]].	list _ list select: [:each | each notNil].	"do bulk become:"	(list collect: [:each | each contentsMorph])		elementsExchangeIdentityWith:			(list collect: [:pg | MorphObjectOut new xxxSetUrl: pg url page: pg])! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 13:28'!purge: megs	"Replace morphs with tombstones in all pages that are clean and not being shown.  Do this until megs of new memory have been recovered.  Write any dirty ones first, if allowed to."	| goal |	goal _ Smalltalk garbageCollect + (megs * 1000000) asInteger.	PageCache doPagesInMemory: [:aPage | 		GlobalPolicy == #neverWrite ifFalse: [aPage write].		aPage purge.		Smalltalk garbageCollect > goal ifTrue: [^ true]].	"got enough"	^ false	"caller may want to tell the user to write out more pages"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 18:12'!removeURL: aURLString	"Remove the cache entry for the given URL. Do nothing if it has no cache entry."	PageCache removeKey: aURLString ifAbsent: [].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/22/1998 11:07'!write	"Write out all dirty pages"	GlobalPolicy == #neverWrite ifTrue: [^ self].	self doPagesInMemory: [:aPage | aPage write].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'tk 12/4/1998 13:02'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish url ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 13:00'!releaseCachedStateOfPages	"Note: This shouldn't be necessary if we are doing a good job of releasing cached state as we go. If running this doesn't do very much, we're doing well!!"	"SqueakPageCache releaseCachedStateOfPages"	| memBytes |	memBytes _ Smalltalk garbageCollect.	PageCache do: [:pg |		pg contentsMorph allMorphsDo: [:m | m releaseCachedState]].	^ (Smalltalk garbageCollect - memBytes) printString, ' bytes recovered'! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 10/7/1998 14:43'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		self unregister.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:01'!closed	"Answer true if this file is closed."	^ fileID isNil! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 10/7/1998 14:44'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	fileID _ self retryWithGC:[self primOpen: fileName writable: writeMode] until:[:id| id notNil].	fileID ifNil: [^ nil].  "allows sender to detect failure"	self register.	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 11/4/1998 19:17'!isReadOnly	^ rwmode not! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readWrite	"Make this file writable."	rwmode _ true.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'ar 11/24/1998 14:00'!localName	^ name ifNotNil: [(name findTokens: FileDirectory pathNameDelimiter asString) last]! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 14:11'!next	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 10/15/1998 09:30'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad _ self isBinary 		ifTrue: [aChar asCharacter asciiValue]	"ok for char or number"		ifFalse: [aChar asCharacter].	self nextPutAll: (buffer1 class new: ((self size - self position) min: 20000) 							withAll: pad).! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:56'!verbatim: aString	"A version of nextPutAll that can be called knowing it won't call nextPut: "	^ self nextPutAll: aString! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 150>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primClose: id	"Close this file."	<primitive: 151>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:04'!primGetPosition: id	"Get this files current position."	<primitive: 152>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:06'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 154>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 155>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSize: id	"Answer the size of this file."	<primitive: 157>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 157>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 158>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!register	^self class register: self! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!unregister	^self class unregister: self! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 3/21/98 18:16'!actAsExecutor	super actAsExecutor.	name := nil.! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 10/7/1998 15:44'!finalize	self primCloseNoError: fileID.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:13'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| dir localName choice newName |	(self isAFileNamed: fileName)		ifFalse: [^ self new open: fileName forWrite: true].	"file already exists:"	dir _ FileDirectory forFileName: fileName.	localName _ FileDirectory localNameFor: fileName.	choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fileName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: fileName.		^ self newFileNamed: newName].	self error: 'Please close this to abort file opening'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:16'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:19'!readOnlyFileNamed: fileName	"Open an existing file with the given name for reading."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:23'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/29/1998 18:02'!frozenPlayfieldBorderColor	^ Color red! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/30/1998 09:50'!runningPlayfieldBorderColor	^ Color green! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 9/14/1998 14:41'!statusColorSymbolFor: statusSymbol	#(	(normal					green)		(ticking					blue)		(paused					red)		(mouseDown				yellow)		(mouseStillDown			lightYellow)		(mouseUp				lightBlue)		(mouseEnter				lightBrown)		(mouseLeave			lightRed)		(mouseEnterDragging	lightGray)		(mouseLeaveDragging	darkGray)		(keyStroke				lightGreen)) do:			[:pair | statusSymbol == pair first ifTrue: [^ pair second]].		^ #blue! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:31'!formAtKey: aKey	"ScriptingSystem saveForm: (TileMorph downPicture) atKey: 'downArrow'"	^ FormDictionary at: aKey ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21'!inspectFormDictionary	"ScriptingSystem inspectFormDictionary"	FormDictionary inspectFormsWithLabel: 'Standard Graphics'! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21'!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	FormDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:29'!saveForm: aForm atKey: aKey	FormDictionary at: aKey put: aForm! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/24/1998 14:12'!squeakyMouseForm	^ self formAtKey: 'squeakyMouse'"	ScriptingSystem saveForm: (Form	extent: 30@29	depth: 16	fromArray: #( 1811114995 1878286257 2012637171 1811180532 1811180533 1811179508 1811180532 1811179508 1744006133 1878289396 1811180533 1878289396 1744007156 1674736630 1744006132 1811114995 1811181556 1744006131 1811246068 1811180532 1811179508 1811180532 1744071668 1811113972 1811180532 1811180532 1811179507 1878288338 1945529332 1744071668 1743941620 1811112945 1811179506 1811114995 1744006131 1744006130 1744005106 1811048434 1811113969 1743939570 1811179506 1743939571 1676833782 1676765171 1811047410 1744006131 1811048435 1811116020 1811180531 1743939571 1811048435 1743939570 1743939570 1743939570 1743940594 1744005106 1811181556 1811180532 1676766196 1743939570 1878420468 1676963830 1189896082 1811245044 1744137204 1744070644 1811179508 1811113971 1743939571 1811179508 1811246070 1811309524 1811302093 1811310580 1811246068 1674867703 1744049472 1120606594 1118465013 1744137205 1811179508 1811180532 1744071667 1744006132 1811112947 1811247095 1605584589 358761132 289435638 1676830707 1741975543 1462778473 1811312631 702891724 1811310548 1945528308 1811178450 1945528307 1878288372 1878353875 1878421494 1051471335 1809213397 1118524175 1811246068 1945659348 1185698607 1878486005 1672694510 1118531574 1607626741 1878420467 1811180533 1743942645 1744072693 1811301035 1185770487 1878486006 1324239597 1811180533 1811116019 1120623438 1878352818 1945462739 704868339 1878289395 1811049459 1878221808 1878223859 1743876083 1811162563 1945463796 1811181556 1464746666 1811116018 1809019893 1120551562 1945464821 1741844468 1466842760 1878289395 1811048434 1811050483 1811050483 1878223859 1049188174 1741910004 1811181556 1256998634 1811114994 1878289396 1466840647 1744007156 1744006131 1676877216 1743940596 1878222835 1743938545 1878351792 1676833781 358641652 1743940596 1811050484 845566798 1811113970 1811114995 1811163652 1811112913 1878420468 1878282028 1811179506 1607560178 1878289395 1676900342 1878351825 1466853330 1811113971 1811116019 635659217 1811179506 1811245045 1676942754 1744137206 1744201717 1676962806 1676962805 1811310581 1676896245 1744199635 1811376117 1744072695 1744005109 1811244019 499279861 1811310581 1811244020 1811293668 1399943159 1605528567 1744136181 982063522 986342388 1744070645 1744189066 430063308 1744071669 1744070644 1744067504 566519797 1744136181 1744137205 1743999854 912813044 1811311606 1742162607 4195488 283139922 1945531382 1253113857 144710948 1601400791 1811246069 1811167879 1464821747 1744136180 1674799094 1811178482 843473875 1811311606 1878533542 2106790 2080066222 1876193270 696845376 627472380 1185772536 1878355957 1743990309 1744007157 1676898294 1744006132 1811114996 1743941620 1811180533 1809204941 4194368 4217681 1878290421 1252982848 4194336 1670540278 1739811795 1878353906 1744006131 1811179506 1744007157 1744005106 1945462771 1811182582 1811311574 1393641133 1462856629 2012638196 1876382449 1112301394 1742041045 1945596917 1676833781 1811113970 1811179507 1811180532 1672705014 1674735606 1672697648 1945725943 1878551479 1809215479 1811312629 1809216504 1809215479 1809215478 1462853490 1878487029 1744007158 1744005075 1811239726 704979363 495004132 700789287 562372997 631646663 1739998892 4194400 1116497846 698688932 562375109 770124262 633609569 495070758 1257010166 562315916 1809279958 2012894002 1047280171 980237901 910966381 1668677696 4194400 6314867 1047281260 908804749 910968495 1393719290 1809279959 1185750370 1809214455 1878469062 423836236 1532188466 1601592148 1462986647 1672937568 4194368 6319062 1603622706 1601525554 1601522417 1047336194 770206679 1878487031 1878409899 977955830 1809145716 1118586509 980105834 980045584 1811372914 980104778 1605526483 1395605131 910769804 1118651052 1534358520 1809136234 1118596053 1532059506 1878485973 1326456163 1945660374 1742106615 1811311607 1945725942 1742107641 1744072693 1811311605 1744203767 1878551543 564478604 1878553591 1603428242 1811048433 1811049459 1051290611 1744006131 1811049459 1878156273 1743874034 1744007156 1743874033 1811048434 1811113970 1743939571 1743933228 1603301363 1743875059 1811049458 1945461745 1811181556 1811113971 1811049458 1811048434 1811116020 1878287346 1878223857 1743940594 1744006130 1744007157 1945395153 1945400309 1811048434 1743810547 1676765170 1878353906 1811113970 1743874032 1810983921 1743874033 1811113971 1676765169 1743874034 1743940593 1743939569 1811047409 1676765168 1743940595 1810981872 1945397235 1607560179 1743941620 1810982897 1810983921 1811048433 1744007155 1743875059 1811048434 1743875058 1743939568 1676832754 1811116019 1811114994 1811244019 1676962805 1677029367 1811244020 1744005106 1743940594 1811246068 1744070645 1676961781 1744004084 1676897269 1811180533 1878353908 1744004083 1744070645)	offset: 0@0) atKey: 'squeakyMouse'"! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 13:50'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object is facing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upward from the bottom of the container')(colorUnder		color'The color under the center of the object')(penDown		boolean'Whether the object''s pen is down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in the object is over another given color')(isOverColor		boolean'Whether any part of this object is directly over the specified color')(isUnderMouse	boolean'Whether any part of this object is beneath the current mouse-cursor position')(scaleFactor		number'The amount by which the object is scaled')(width			number'The distance between the left and right edges of the object')(height			number'The distance between the top and bottom edges of the object')(isOverColor		color'Whether any part of the object is over a given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate of the mouse pointer')(mouseY		number'The y coordinate of the mouse pointer')(left		number'My left edge, measured from the left edge of the World')(right		number'My right edge, measured from the left edge of the world')(top		number'My top edge, measured downward from the top edge of the world')(bottom		number'My bottom edge, measured downward from the top edge of the world')(tryMe			command'Click here to run this script once; hold button down to run repeatedly.')(try			command'Run this command once.')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')(chooseTrigger	command'when this script should be run	normal -- run when called	paused -- ready to run all the time	ticking -- run all the time	mouseDown -- run when mouse goes down on me	mouseStillDown -- while mouse still down	mouseUp -- when mouse comes back up	mouseEnter -- when mouse enters my bounds, button up	mouseLeave -- when mouse exits my bounds, button up	mouseEnterDragging -- when mouse enters my bounds, button down	mouseLeaveDragging -- when mouse exits my bounds, button down	opening -- when I am being opened	closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)(offerScriptorMenu	command'Press here to get a menu of options for this Scriptor')(objectNameInHalo  control'Object''s name -- To change: click here; backspace over old name, type in new name; hit ENTER')(userSlot		control'This is an instance variable defined by you.  Click here to change its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:53'!initializeScriptHelp" | helpDict |	helpDict _ IdentityDictionary new.	#(	(aTest 'testing one two three') 	(acceptScript:for: 'submit the contents of the given script editor as the code defining the given selector')	(actorState 'return the ActorState object for the receiver, creating it if necessary')	(addInstanceVariable 'start the interaction for adding a new instance variable to the receiver')	(addPlayerMenuItemsTo:hand: 'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')	(addSlotNamedLike:withValue: 'add a slot with a unique name derived from the first parameter, giving it the second parameter as its initial value')	(allScriptEditors 'answer a list off the extant ScriptEditors for the receiver')	(anonymousScriptEditorFor: 'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')	(assignDecrGetter:setter:amt: 'evaluate the decrement variant of assignment')	(assignGetter:setter:amt: 'evaluate the vanilla variant of assignment')	(assignIncrGetter:setter:amt: 'evalute the increment version of assignment')	(assignMultGetter:setter:amt: 'evaluate the multiplicative version of assignment')	(assureEventHandlerRepresentsStatus 'make certain that the event handler associated with my current costume is set up to conform to my current script-status')	(assureExternalName 'if I do not currently have an external name assigned, get one now')	(assureUniClass 'make certain that I am a member a uniclass (i.e. a unique Player subclass); if I am not, create one now and become me into an instance of it')	(availableCostumeNames 'answer a list of strings representing the names of all costumes currently available for me')	(availableCostumesForArrows 'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')	(beep: 'make the requested sound')	(bounce: 'if I have just run into a boundary, bounce off of it, making the stated sound')	(clearTurtleTrails 'erase all the pen trails within me')	(deleteCard 'delete the current card')	(firstPage 'make the first page of this book be the current one')	(forward: 'move forward by the specified amount')	(goto: 'make the given page be seen as my current page')	(goToNextCard 'make the next card within me be the currently-visible one')	(goToPreviousCard 'make the previous card within me be the currently-visible one')	(goToRightOf: 'move me until I lie directly to the right of the other object.')	(hide 'make me be invisible')	(initiatePainting 'let the user start painting a new object with me')	(lastPage 'make the last page of this book be the current one')	(liftAllPens 'lift the pens of all the objects within me')	(lowerAllPens 'lower the pens of all the objects within me')	(moveToward: 'move toward another object')	(newCard 'create a new card and make it my currently-visible one')	(nextPage 'go to the next page following the current one')	(pauseScript: 'make the specified script become paused')	(previousPage 'go to the page preceding the current one.')	(show 'make me be visible (if I was formerly hidden')	(startScript: 'make the specified script start ticking')	(stopScript: 'make the specified script stop running')	(turn: 'turn by the specified amount')	(wearCostumeOf: 'wear a costume resembling that of another player')	(wrap 'if I have just run into a boundary, reappear at the corresponding point on the opposite side')	 		) do: [:pair | helpDict at: pair first put: pair second].	ScriptingSystem scriptHelp: helpDict"	| aDoIt |	aDoIt _ StandardScriptingSystem firstCommentAt: #initializeScriptHelp.	Compiler evaluate: aDoIt"ScriptingSystem initializeScriptHelp""(     basicType beNotZero:   categories changeScript:toStatus: changeVariableType checkCostume choosePenColor: choosePenSize chooseSlotTypeFor: chooseUserSlot color color:sees: colorUnder commandPhraseFor:inViewer: compileAccessorsFor: compileInstVarAccessorsFor: convertdc0:dcc0: copyStateFrom: copyUniClass costume costume: costumeRespondingTo: costumeSlotNamesAndTypesForBank: costumes costumesDo: createNewCard defaultLabelForInspector defaultPenColor defaultPenSize  dummy externalName  forgetOtherCostumes  getAmount getAngle getBorderColor getBorderWidth getBottom getColor getColorUnder getCursor getHeading getHeadingUnrounded getHeight getInfo getIsUnderMouse getLeft getLeftRight getMouseX getMouseY getName getPenColor getPenDown getPenSize getRight getRotationStyle getScaleFactor getSpeed getTop getUpDown getValueAtCursor getValueFromCostume: getWidth getX getY     grabPlayerIn: hasCostumeOfClass: hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: headDown headLeft headRight headUp  infoFor: initialTypeForSlotNamed: initialValueForSlotOfType: initializeCostumesFrom: initiatePainting instantiatedUserScriptsDo: isFlagshipForClass justClonedFrom: knownSketchCostumeWithSameFormAs: lastEvent   liftPen  lowerPen makeBounceSound: maxPartsBankNumber maxScriptsBankNumber   newCostume  noteDeletionOf:fromWorld: okayToDestroyScriptNamed: okayToRemoveSlotNamed: owningPlayer  penColor: personalSlotNamesAndTypesForBank: phraseSpecFor: presenter  printOn: rawCostume: rememberCostume: removeSlotNamed: renameSlot: renameTo: renderedCostume: renderedCostumeRespondsTo: revealPlayerIn: revertToUnscriptedPlayerIfAppropriate runAllClosingScripts runAllOpeningScripts runAllTickingScripts scriptEditorFor: scriptEvaluatorFor:phrase: scriptInstantiationForSelector: scriptPerformer seesColor: sendMessageToCostume: sendMessageToCostume:with: setBorderColor: setBorderWidth: setBottom: setColor: setCostume: setCostumeSlot:toValue: setCursor: setHeading: setHeight: setLeft: setName: setPenColor: setPenDown: setPenSize: setRight: setRotationStyle: setScaleFactor: setTop: setValueAtCursor: setWidth: setX: setY:  slotInfo slotNames slotNamesAndTypesForViewerBank: slotPhraseFor:inViewer: standardCommandsForBank: standardSlotsForBank: standardWorldSlotsForBank: startRunning startRunningScripts  step stopProgramatically stopRunning  tearOffFancyWatcherFor: tearOffTileForSelf tearOffWatcherFor: thumbnailMenuEvt:forMorph: tileForArgType: tileForArgType:inViewer: tilePhraseSpecsForPlayerCategory: tilePhrasesForCategory:inViewer: tilePhrasesSpecsForCategory: tileReferringToSelf tileScriptCommands tileScriptCommandsForBank:  typeForSlot: typedCommandsForBank: unusedScriptName updateAllViewers valueOfType:from:  wearCostumeOfClass: wearCostumeOfName: wearSketchCostumeResembling: width  "! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 10/7/1998 09:32'!initializeSystemSlotDictionary	"ScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(seesColor		boolean)		(isUnderMouse	boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/6/1998 17:24'!scriptHelp: aDictionary	ScriptHelp _ aDictionary.	Transcript cr; show: 'script help loaded; ', aDictionary size printString, ' entries.'! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:28'!scriptHelpFor: aSelector	| help |	help _ self scriptHelpOrNilFor: aSelector.	help ifNotNil: [^ help].	^ HelpStrings at: aSelector ifAbsent: ['sorry, no description yet provided for ', aSelector]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:27'!scriptHelpOrNilFor: aSelector	^ ScriptHelp at: aSelector ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:13'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 12/31/1998 18:40'!fixUniclassAccessors	"ScriptingSystem fixUniclassAccessors"	Player allSubInstances do:		[:p | (((p isMemberOf: UnscriptedPlayer) or: [p isMemberOf: Player]) or: [p isKindOf: Component])			ifFalse:				[p class instVarNames do:					[:v | p compileInstVarAccessorsFor: v]]]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 11/11/1998 13:46'!newScriptingSpace	"Answer a complete scripting space"	| aTemplate  palette aPlayfield aWindow |	aWindow _ (SystemWindow labelled: 'scripting area') model: ScriptingDomain new.	aWindow extent: 640 @ 480.	aTemplate _ PasteUpMorph new setNameTo: 'etoy'.	aTemplate extent: 638 @ 470.	aWindow addMorph: aTemplate frame: (0@0 corner: 1@1).	aTemplate setStandardTexture.	aTemplate impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky.	aTemplate presenter addStopStepGoButtons; addTrashCan.	palette _ TabbedPalette new pageSize: 200@320.	palette beSticky.	aTemplate addMorph: palette.	palette addMenuTab.	palette addPartsTab.	palette addControlsTab.	palette addScrapsTab.	"palette addViewerTab."	aPlayfield _ PasteUpMorph new setNameTo: 'playfield'.	(Preferences valueOfFlag: #eToyScheme)  "Not widely advertised"		ifFalse:				[aPlayfield setToAdhereToEdge: #topRight.			palette setToAdhereToEdge: #topLeft]		ifTrue:			[aPlayfield setToAdhereToEdge: #topLeft.			palette setToAdhereToEdge: #topRight].	aTemplate addMorph: aPlayfield.	aPlayfield extent: 340@300; position: aTemplate topRight - (400@0).	aPlayfield beSticky.	aPlayfield automaticViewing: true.	aPlayfield wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aWindow! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'di 9/16/1998 00:38'!prepareForExternalReleaseNamed: aReleaseName	"ScriptingSystem prepareForExternalReleaseNamed: '2.2Beta'"	EToySystem stripMethodsForExternalRelease.	self class compile: 'guessDOLProxy	"deleted for external release"' classified: 'stripped'.	ScriptingSystem saveFormsToFileNamed: aReleaseName, '.Dis.Forms'.	ScriptingSystem stripGraphicsForExternalRelease.	ScriptingSystem cleanupsForRelease.	ScreenController initialize.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/14/1998 14:39'!standardEventStati	^ #(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging keyStroke)! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/16/1998 09:22'!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	|  replacement |	replacement _ FormDictionary at: 'Gets'.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | FormDictionary at: aKey put: replacement]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/10/1998 14:42'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(stopScript				'stop script')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(stopScript:				'stop script')		(startScript:				'start script')		(pauseScript:			'pause script')		(max:					'max')		(min:					'min')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(clearTurtleTrails		'clear pen trails')		(seesColor:				'is over color')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 11/16/1998 08:50'!customPartsBin	CustomPartsBin ifNil:		[self inform: 'There is no custom parts bin yet.To create one, start with a Standard Parts Bin, and modify it as you wish, and then choose''Save as Custom Parts Bin'' from theparts-window-controls menu, whichwill be found in the halo menu ofany parts-bin window'.	^ nil].	^ CustomPartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/21/1998 23:14'!newStandardPartsBin	"StandardPartsBin _ nil"	StandardPartsBin ifNil:		[StandardPartsBin _ Presenter new newStandardPartsBinTitled: 'objects' includeControls: false].	^ StandardPartsBin fullCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/27/1998 13:35'!resetStandardPartsBin	"ScriptingSystem resetStandardPartsBin"	StandardPartsBin _ nil! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 11/16/1998 08:47'!setCustomPartsBinFrom: aMorph	"Establish aMorph as the custom parts bin.  Normally triggered by use menu action, but can also be used to reset the custom parts bin to undefined"	CustomPartsBin _ aMorph	"ScriptingSystem setCustomPartsBinFrom: nil"! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 1/1/1999 16:03'!initStandardScriptInfo	"ScriptingSystem initStandardScriptInfo"	StandardScriptInfo _ Dictionary new.	#(	(command beep: sound)		(command bounce: sound)		(command clearTurtleTrails)		(command forward: number)		(command goToNextCard)		(command goToPreviousCard)		(command goToRightOf: player)		(command hide)		(command initiatePainting)		(command liftAllPens)		(command lowerAllPens)		(command makeNewDrawingIn: player)		(command moveToward: player)		(command pauseScript: string)		(command roundUpStrays)		(command show)		(command startScript: string)		(command stopScript: string)		(command turn: number)		(command unhideHiddenObjects)		(command wearCostumeOf: player)		(command wrap)		(command newCard)		(command deleteCard)		(command initiatePainting)		(command nextPage)		(command previousPage)		(command firstPage)		(command lastPage)		(command goto: player ))	do:		[:anArray | StandardScriptInfo at: anArray second put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 11/10/1998 17:39'!initStandardSlotInfo	"ScriptingSystem initStandardSlotInfo"	StandardSlotInfo _ Dictionary new.	#((color			color		readWrite	getColor				setColor:)	(borderWidth 	number		readWrite	getBorderWidth	setBorderWidth:)	(borderColor		color		readWrite	getBorderColor	setBorderColor:)		(leftRight	number		readOnly	getLeftRight				unused)		(upDown	number		readOnly	getUpDown				unused)		(angle		number		readOnly	getAngle				unused)		(amount	number		readOnly	getAmount				unused)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused)		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)		(rotationStyle	rotationStyle									readWrite	getRotationStyle		setRotationStyle:)		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused)		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:)		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:))	do:		[:anArray | StandardSlotInfo at: anArray first put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:51'!scriptInfoFor: aSlotName	^ StandardScriptInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:53'!slotInfoFor: aSlotName	^ StandardSlotInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/5/1998 16:54'!goButton	| aButton |	aButton _  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setBalloonText:'Resume running all paused scripts'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/11/1998 15:24'!goUp: evt with: aGoButton	aGoButton presenter startRunningScriptsFrom: aGoButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:59'!mouseUpBalk: evt! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 16:09'!scriptControlButtons	"World primaryHand attachMorph: ScriptingSystem scriptControlButtons"	| wrapper |	wrapper _ AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 1/4/1999 07:31'!stepButton	| aButton |	self flag: #deferred.  "ambiguity about recipients"	aButton _ ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);		 	actionSelector: #stepStillDown:with:; 			target: self;			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			actWhen: #whilePressed;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:33'!stepDown: evt with: aMorph	aMorph presenter stopRunningScripts! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepStillDown: dummy with: theButton	theButton presenter stepStillDown: dummy with: theButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepUp: evt with: aMorph	aMorph presenter stepUp: evt with: aMorph! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:50'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Pause all ticking scripts.'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/11/1998 15:16'!stopUp: dummy with: theButton	| aPresenter |	(aPresenter _ theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScriptsFrom: theButton! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:30'!brightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 1) = aColor ifTrue: [^ (pair at: 2)]].	^ aColor! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 11/10/1998 18:18'!brightColorForType: typeSymbol	^ (TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 2! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 15:58'!colorForType: typeSymbol	^ (TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 1! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:18'!colorFudge	^ 0.4! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:49'!initializeTypeColors	"ScriptingSystem initializeTypeColors"	TypeColorDictionary _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(object			(1.0 0.26 0.98)		(1.0 0.26 0.98))   		(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | TypeColorDictionary at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:01'!unbrightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 2) = aColor ifTrue: [^ (pair at: 1)]].	^ aColor! !!StandardScriptingSystem methodsFor: 'stripped' stamp: 'di 1/15/1999 11:29'!guessDOLProxy	"deleted for external release"! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 10/22/1998 10:32'!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	Smalltalk at: #ScriptingSystem put: (self new initializeSystemSlotDictionary; initializeHelpStrings; yourself).	ScriptingSystem initStandardSlotInfo! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 6/10/1998 15:10'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view topView isCollapsed ifFalse: [model modelWakeUp].! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:42'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]. ].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'framing' stamp: 'tk 8/11/1998 16:22'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUp]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect _ aDisplayBox.	theMin _ 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen _ 0.	subViews do:		[:sub | box _ sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub _ sub.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ theSub! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/23/1998 21:54'!addCategoryViewer		| aCategory |	aCategory _ self categoryNotCurrentlyViewing.	self addCategoryViewerFor: aCategory! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 21:19'!addCategoryViewerFor: aStartingCategory	| aViewer |	self addMorphBack: (aViewer _ CategoryViewer new initializeFor: scriptedPlayer categoryChoice: aStartingCategory).	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 1/13/1999 23:15'!addHeaderMorph	| header aFont aButton aTextMorph nail wrpr costs |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #dismiss;			setBalloonText: 'Delete'.	header addTransparentSpacerOfSize: 4@1.	header addMorphBack: (aButton _ SimpleButtonMorph new label: '+' font: aFont).	aButton target: self; beTransparent; borderWidth: 0;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother viewer'.	header addTransparentSpacerOfSize: 4@1.	(((costs _ scriptedPlayer costumes) size > 1) or: [costs size == 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume'].		nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		header beSticky.	self addMorph: header! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:38'!categoryMorphs	^ self submorphsSatisfying: [:m | m isKindOf: CategoryViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 23:11'!categoryNotCurrentlyViewing	| aList |	aList _ scriptedPlayer categories asOrderedCollection.	self categoryMorphs do:		[:m | aList remove: m currentCategory ifAbsent: []].	^ aList size > 0		ifTrue:			[aList first]		ifFalse:			['basic']! !!StandardViewer methodsFor: 'all' stamp: 'sw 11/5/1998 16:15'!dismiss	"User hit the dismiss button."	(owner isKindOf: TabbedPalette)		ifTrue:			[^ owner showNoPalette].	self delete! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:34'!downArrowHit	self nextCostume! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 09:24'!initializeFor: aPlayer	scriptedPlayer _ aPlayer.	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		borderWidth: 1.	self addHeaderMorph.	self addCategoryViewerFor: 'basic'.	self addCategoryViewerFor: 'tests'! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:37'!obtainBankInfoFrom: anotherViewer	anotherViewer categoryMorphs with: self categoryMorphs do:		[:old :new | new obtainBankInfoFrom: old]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:33'!upArrowHit	self previousCostume! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 11:40'!print: anObject	anObject printOn: self! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 17:13'!printHtml: anObject	anObject printHtmlOn: self! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'accessing' stamp: 'sw 10/5/1998 16:38'!textStyle	^ Utilities actualTextStyles detect:		[:aStyle | aStyle fontArray includes: self] ifNone: [nil]! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:46'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| eval |	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	emphasis > 0 ifTrue: [self error: 'Synthietic fonts do not get written out. Proceed for plain font.'].	eval _ 'StrikeFont familyName: #', self name ,' size: ', self height printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval).! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:49'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $)! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 9/20/1998 10:35'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'copying' stamp: 'tk 8/19/1998 16:15'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 7/2/1998 16:44'!familyName: aName size: aSize	| aStyle both ind |	(aStyle _ TextStyle named: aName asSymbol) ifNil: [		both _ aName splitInteger.		(both at: 2) > 0 			ifTrue: ["old style"				ind _ #('ComicB' 'Comic' 'ComicAll') indexOf: (both at: 1).				ind = 0 ifTrue: [^ self familyName: (both at: 1) size: aSize].				aStyle _ TextConstants at: (#(ComicBold ComicPlain ComicPlain) at: ind)]			ifFalse: [aStyle _ TextStyle default]].	"Substitute. Read-only so OK not to copy"	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'examples' stamp: 'tk 6/26/1998 15:19'!update	"A temporary method to change the names of StrikeFonts.  New convention is that each StrikeFont is in a TextStyle that has only fonts of the same name (family).  The name of that TextStyle in TextConstants is the same name as the family name of this font.  Sizes are no longer in the name of the font."	"StrikeFont update"| sty |TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		"Transcript show: assoc key; space."		sty _ assoc value.		sty fontArray do: [:font | font name: assoc key]		]]].TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		sty _ assoc value.		sty fontArray do: [:font | 			(StrikeFont familyName: font name size: font height) == font ifFalse: [				self error: 'not same']]]]].! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:58'!byteAt: index	^(self at: index) asciiValue! !!String methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:58'!byteAt: index put: value	self at: index put: value asCharacter.	^value! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^ self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:45'!findString: key startingAt: start caseSensitive: caseSensitive	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."	caseSensitive	ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]	ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:53'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'di 11/16/1998 10:00'!indexOf: aCharacter	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: 1! !!String methodsFor: 'accessing' stamp: 'di 11/16/1998 10:00'!indexOf: aCharacter  startingAt: start	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'ls 8/17/1998 23:28'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	ans _ String indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:20'!indexOfAnyOf: aCharacterSet	"returns the index of the first character in the given set.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  ifAbsent: aBlock	"returns the index of the first character in the given set.  Returns the evaluation of aBlock if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1  ifAbsent: aBlock! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  startingAt: start	"returns the index of the first character in the given set, starting from start.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: start  ifAbsent: [ 0 ]! !!String methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:27'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ String findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 17:02'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index _ self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'ls 9/10/1998 22:27'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start _ 1.	[ start <= self size ] whileTrue: [		end _ self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2. ].! !!String methodsFor: 'comparing' stamp: 'di 9/14/1998 16:29'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString species == String ifFalse: [^ false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!String methodsFor: 'comparing' stamp: 'di 9/20/1998 14:33'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra _ self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'ar 11/19/1998 21:48'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:37'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:28'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i _ keyStart.	j _ textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i _ i+1.  j _ j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch _ true.				matchStart _ i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch _ false.				matchStart _ i].	"Now determine the match string"	matchEnd _ self size.	(ii _ self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd _ ii-1].	(ii _ self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd _ matchEnd min: ii-1].	matchStr _ self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj _ text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j _ j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a collection, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/9/1998 12:17'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a point, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a string, convert us both to	numbers, and return the printString of the result."	^ (rcvr asNumber perform: selector with: self asNumber) printString! !!String methodsFor: 'converting' stamp: 'ls 9/5/1998 01:19'!asIRCLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase, where 'lowercase' is by IRC's definition"	^self collect: [ :c | c asIRCLowercase ]! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:33'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^self copy asString translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 6/29/1998 00:35'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: 'converting' stamp: 'ls 7/15/1998 18:40'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'converting' stamp: 'sw 1/10/1999 01:46'!integerAtBeginning	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not]).	^ firstNonDigit > 1		ifTrue:			[(self copyFrom: 1  to: (firstNonDigit - 1)) asNumber]		ifFalse:			[nil]"'234Whoopie' integerAtBeginning'wimpy' integerAtBeginning'  89Ten ' integerAtBeginning'78 92' integerAtBeginning"! !!String methodsFor: 'converting' stamp: 'tk 7/2/1998 16:32'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.  '43Sam' yields #(43 'Sam').  'Try90' yields #('Try' 90) "	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 			with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ls 1/3/1999 13:36'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result _ WriteStream on: (Array new: 10).	end _ 0.	"find one substring each time through this loop"	[ 		"find the beginning of the next substring"		beginning _ self indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: [ nil ].		beginning ~~ nil ] 	whileTrue: [		"find the end"		end _ self indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ self size + 1 ].		end _ end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 10:31'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	String translate: self  from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'ls 8/18/1998 07:44'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:30'!translateWith: table	"translate the characters in the string by the given table, in place"	^self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'sw 11/5/1998 19:47'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String methodsFor: 'converting' stamp: 'sw 1/8/1999 14:45'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not and: [m ~~ $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location	aPoint on aDisplayMedium."	(self asDisplayText foregroundColor: Color black backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'sw 7/3/1998 18:31'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!String methodsFor: 'system primitives' stamp: 'di 11/15/1998 16:27'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 246>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!String methodsFor: 'internet' stamp: 'ls 1/3/1999 15:19'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size+1 ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size + 1 ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                               specialValue _ String valueOfHtmlEntity: special.                         specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"								  scIndex > self size ifTrue: [ scIndex _ self size ].                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !!String methodsFor: 'internet' stamp: 'ls 7/22/1998 22:19'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| inStream ans c tok asciiVal |	inStream _ ReadStream on: self.	ans _ WriteStream on: String new.	[ c _ inStream next.  c = nil ] whileFalse: [ 		c = $+ ifTrue: [ ans nextPut: $ ] ifFalse: [			(c = $%) ifTrue: [				tok _ inStream next: 2.				asciiVal _ Integer readFrom: (ReadStream on: tok) base: 16.				ans nextPut: (Character value: asciiVal). ]			ifFalse: [				ans nextPut: c ] ] ].	^ans contents ! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 10/27/1998 00:52'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr _ Character cr.	lf _ Character linefeed.	crlf _ CharacterSet new.	crlf add: cr; add: lf.	inPos _ 1.	outPos _ 1.	outString _ String new: self size.	[ lineEndPos _ self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos _ outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos _ newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos _ lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos _ lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos _ outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!String methodsFor: 'internet' stamp: 'ls 7/1/1998 02:26'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote _ self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'testing' stamp: 'sw 11/5/1998 17:41'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: 'paragraph support' stamp: 'RAA 8/30/1998 15:20'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!* arg	^ arg adaptToString: self andSend: #*! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!+ arg	^ arg adaptToString: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!- arg	^ arg adaptToString: self andSend: #-! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!/ arg	^ arg adaptToString: self andSend: #/! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!// arg	^ arg adaptToString: self andSend: #//! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!\\ arg	^ arg adaptToString: self andSend: #\\! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'initialization' stamp: 'di 9/20/1998 14:09'!initialize  "String initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String new: 256.	Character allCharacters do: [ :c |		LowercasingTable at: (c asciiValue+1) put: c asLowercase ].		"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!String class methodsFor: 'primitives' stamp: 'ls 9/14/1998 07:50'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 244>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i _ start.	stringSize _ aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i _ i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!String class methodsFor: 'primitives' stamp: 'jm 10/12/1998 18:21'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 245>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ls 8/15/1998 12:15'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 243>	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned char *aString'.	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!String class methodsFor: 'internet' stamp: 'ls 8/15/1998 20:22'!valueOfHtmlEntity: specialEntity	specialEntity = 'quot' ifTrue: [ ^$" ].	specialEntity = 'lt' ifTrue: [ ^$< ].	specialEntity = 'amp' ifTrue: [ ^$& ].	specialEntity = 'gt' ifTrue: [ ^ $>].	specialEntity = 'nbsp' ifTrue: [ ^ Character nbsp ].	(specialEntity beginsWith: '#') ifTrue: [		^Character value: (specialEntity copyFrom: 2 to: specialEntity size) asNumber ].	^nil ! !!StringButtonMorph methodsFor: 'events' stamp: 'sw 10/23/1998 15:57'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue:			[self color: (oldColor mixed: 1/2 with: Color white).			actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!StringButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:47'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!StringButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:46'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		a Symbol""arguments _ arguments.		All weakly copied"actWhen _ actWhen veryDeepCopyWith: deepCopier.oldColor _ oldColor veryDeepCopyWith: deepCopier.! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:37'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	(self embeddedInMorphicWindowLabeled: labelString) openInWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 8/4/1998 18:21'!openAsMorphLabel: labelString  inWorld: aWorld	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld: aWorld! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents _ aStringOrText! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| shiftMenu |	^ shifted 	ifFalse: [aMenu 		labels: PluggableTextController yellowButtonMenu labelString 		lines: PluggableTextController yellowButtonMenu lineArray		selections: PluggableTextController yellowButtonMessages]	ifTrue: [shiftMenu _ PluggableTextController shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: PluggableTextController shiftedYellowButtonMessages]! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/14/1998 06:51'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[ParagraphEditor new clipboardTextPut: selector asString asText]! !!StringHolder methodsFor: 'message list menu' stamp: 'di 12/15/1998 21:25'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	| sel class |	(sel _ self selectedMessageName) ifNil: [^ self arrowKey: aChar from: view].	aChar == $m ifTrue: [^ Smalltalk browseAllImplementorsOf: sel].	aChar == $n ifTrue: [^ Smalltalk browseAllCallsOn: sel].	aChar == $b ifTrue: [^ (class _ self selectedClass) ifNotNil:							[Browser fullOnClass: class selector: sel]].	aChar == $v ifTrue: [^ self browseVersions].	^ self arrowKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/8/1998 13:25'!messageListSelectorTitle	| selector aString aStamp |	Preferences showTimeStampsInMenuTitles		ifFalse:			[^ nil].	(selector _ self selectedMessageName) ifNotNil:		[aString _ selector truncateWithElipsisTo: 28.		^ (aStamp _ self timeStamp) size > 0			ifTrue:				[aString, String cr, aStamp]			ifFalse:				[aString]].	^ nil! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:51'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:46'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 10/13/1998 13:31'!timeStamp	|  selector  aMethod |	^ (selector _ self selectedMessageName) ifNotNil:		[aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: [nil].		aMethod ifNotNil: [Utilities timeStampForMethod: aMethod]]! !!StringHolderController methodsFor: 'edit flag' stamp: 'di 10/9/1998 15:41'!hasUnacceptedEdits: aBoolean	^ view hasUnacceptedEdits: aBoolean! !!StringMorph methodsFor: 'initialization' stamp: 'sw 6/15/1998 15:34'!addOptionalHandlesTo: aHalo box: box	self flag: #deferred.	"Eventually...	self addFontHandlesTo: aHalo box: box"! !!StringMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:55'!userString	"Do I have a text string to be searched on?"	^ contents! !SwikiAction is the action to implement a Swiki, a collaborative website.This is a web server in Squeak.  Each page served has an "Edit this Page"link.  The syntax rules for editing pages (from any web browser) are in thefile FormattingRules.The pages may be viewed from any web browser, and the URL ishttp://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swikiarea.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an examplefocused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by WardCunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or theSqueak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do notsnapshot the image during normal server operation.  Restart the server byloading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of thefolder is the name of the Wiki.  Each page is a file.  (Inefficient on Macsbecause of large minimum page size, but that's an OS problem.)  Allversions of all pages are kept.  Each page contains chunks, just like achanges file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text:'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytesfrom the start of the chunk to just in front of the number.  This allowsback-chaining to old versions.  On startup, the chunk is executedexplicitly using evaluate:for:logged:.  It supplies the page name to aSwikiPage and installs it in the URLmap.  By doing this for all files inthe folder, the map (url->page) is built.  During operation, the chunk isnot executed.  Instead, take the file directly, look at 'back:' at the end,jump back to the start of the chunk, scan for 'text:' and read the text.The looks of the pages served are controlled by templates.  They live inthe 'swiki' folder in the 'Server' folder.  See page.html for how to changethe look of a served page.  Beware that templates are cached byHTMLformatter.  If you change a template, you will not see the effect untilyou reload the Swiki.A symbol *append here* may be added anywhere in the page.  Clicking on itwill bring up a page with a text editing form.  The what you type will beinserted just before the *append here* marker.  This allows append-onlypages, or multiple questions with places to add to the answer.!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter	^formatter! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter: anHTMLformatter	formatter _ anHTMLformatter! !!SwikiAction methodsFor: 'accessing' stamp: 'TPR 7/21/1998 18:06'!url	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'save and restore' stamp: 'ls 7/27/1998 23:26'!fixAllLineEndings	"for each page in the swiki, fixes line endings to be CR only.This is used to bring older Swikis up to date with the newer convention.If a page has no LF's, then it is left alone"	| origText newText pagesDone |	pagesDone _ 0.	'updating pages...' displayProgressAt: Sensor cursorPoint from: 0to: urlmap pages size during: [ :bar |		urlmap pages do: [ :page |			origText _ page text.			newText _ origText withSqueakLineEndings.			origText = newText ifFalse: [ page text: newText ].			pagesDone _ pagesDone + 1.			bar value: pagesDone. ] ]! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 10/9/1998 13:05'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct theurl map."	| map page folder dir rep templateFolder |	map _ self class mapClass new.	self map: map.	self formatter: (HTMLformatter new initialize).	self formatter specialCharacter: $*.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,				(ServerAction pathSeparator),fName action: self.			(page time isNil) ifTrue: [page time: Time now].			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/28/1998 20:59'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'page') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''page.html'' not found'].	request reply: htmlForUser.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/1998 15:32'!edit: pageRef from: request	request reply: (HTMLformatter evalEmbedded:							(self fileContents:source , 'edit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:31'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit""	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store textin a specific place	{swikiname}.searchresult  {with a field named 'searchFor'} conducts thesearch for that text and sends back the result"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			((self formatterFor: 'recent') format: (urlmapsearchFor:						(request fields at:'searchFor' ifAbsent:['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/7/1998 00:55'!pageURL: aPage	"make the URL suited to aPage in this Action"	^(self name),'.',aPage coreID! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 9/16/1998 15:58'!process: request	"URLs are of the form:	{swikiname} 		browse Front Page	{swikiname}.{coreID} browse the page number coreID	{swikiname}.{coreID}.edit  request to edit the page	{swikiname}.{coreID}.versions show the last three versions of the page	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in aspecific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  storetext in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper orlower case) return	the picture or static page stored in the {swikiname} folder."	| coreRef pageRef command formattedPage theLast pvtPageRef htmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success;		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].			command = 'insert' ifTrue:					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (request message at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor: 'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file ''insert.html'' not found'].					request reply: htmlForUser.					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue:					[request reply: ((self formatterFor: 'results')						format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue:					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			(request message at: 1) = (request message at: 2) ifTrue: [				request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.				request message: (request message copyFrom: 2 to: request message size).				^ self process: request].	"(success and contentHTML will be sent twice!!)"			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 4/18/98 18:09'!smtlk: request	"Return Smalltalk sourcecode.  URL =machine:80/myswiki.smtlk.Point|at;  included are:  Point|at:Point|Comment   Point|Hierarchy  Point|Definition   Point|class|x;y;  NOTE:use ; instead of : in selector names!!!!!!"	| classAndMethod set |	classAndMethod _ request message atPin: 3.	classAndMethod _classAndMethod copyReplaceAll: '|' with: ' '.	classAndMethod _classAndMethod copyReplaceAll: ';' with: ':'.	set _ LinkedMessageSetmessageList: (Array with: classAndMethod).	request reply: PWS crlf,((self formatterFor: 'smtlk') format: set).! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/5/98 17:20'!clearFormatterCache	"remove all formatters"	formatters _ nil.! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/7/98 22:04'!formatterFor: formatterName	"get the formatter for the given name.uses lazy initialization.  Could eventually check whether the on-disk filehas been updated."	| fileName fileModTime |		"first,create the dictionary of formatters if it isn't already"	formatters== nil ifTrue: [		formatters _ Dictionary new. ].	"get the filename for the template source"	fileName _formatterName, '.html'.	"get its modification time"	fileModTime_ ((FileDirectory on: ServerAction serverDirectory, source) entryAt:fileName) at: 3.	"create the formatter if necessary"	((formatters includesKey: formatterName) not or: [	((formatters at: formatterName) at: 2) < fileModTime ])	ifTrue: [		Transcript show: '(recompiling formatter ',formatterName, ')'; cr.		formatters at: formatterName put:(Array with:			(HTMLformatter forEvaluatingEmbedded: (selffileContents: (source, formatterName, '.html')))	with: fileModTime)	].	"return the formatter"	^(formatters at: formatterName) at: 1! !!SwikiAction class methodsFor: 'initialization' stamp: 'BJP 9/9/1998 21:41'!setUp: actionName	"Set up a named Swiki"	| action map page dir |	action _ self new.	map _ self mapClass new.	"URLmap or PURLmap"	action formatter: (HTMLformatter new initialize).	action formatter specialCharacter: $*.	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName.	dir _ FileDirectory on: (ServerAction serverDirectory).	(dir directoryNames includes: actionName) ifFalse: [		^ self inform: 'You need to create a folder in Server called ',actionName].		"A directory in the ServerDirectory for storing pages."	page _ map newpage: actionName,': Front Page' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage')contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules')contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.	^action! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 21:32'!by	| who |	who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].	^who.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/10/1998 15:26'!by: who	self address: who.! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:34'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."		(anObject isKindOf: String)			ifTrue: [date _ anObject asDate]			ifFalse: [date := anObject]! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/1/1998 09:58'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject.	^''! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/10/1998 14:14'!outputFormat	^self class outputFormat! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 19:41'!pageStatus	"The basic stati ;) are #new and #standard. If the pageStatus is nil,we make make the page #standard, as that is the old behavior. You could addother types to get e.g., different kinds of URLs, or to exclude pages froma search, or alter the formatter, or..."	pageStatus ifNil: [pageStatus _ #standard].	^pageStatus! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 13:55'!pageStatus: aSymbol	"While I'm trying to be careful about default behavior if the type isunknown, one should still be careful to check all the places that pageTypeis used."	pageStatus _ aSymbol.! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	^ temp! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID: idNum	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	temp _ idNum! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/13/1998 12:37'!text: aString	"Add onto the end of the file"	| this aFile start end realString |	realString _ self uniqueInsertionPoints: aString.	this _ String streamContents: [:ss |		ss nextPutAll: self chunk1.		realString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 10/5/1998 16:22'!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo count |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	bb _ 1. count _ steps.	[count > 0 and: [bb > 0]] whileTrue: [		bb _ self backupAChunk: theFile. count := count - 1.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Remove double !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 19:41'!time	"Answer the receiver's 'time'."	^time! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:29'!time: anObject	"Set the receiver's instance variable 'time' to be anObject."	(anObject isKindOf: String)		ifTrue: [time _ anObject asTime]		ifFalse: [time := anObject]! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:36'!backupAChunk: aFile	"We are positioned at the end of a chunk.  Read the size of thischunk from its end.  Back up one chunk.  Return the position of the spacebefore the back number."	| back pp aPiece isDigitFlag |	aFile skip: -2.	isDigitFlag _ false.	[isDigitFlag] whileFalse:	[aPiece := aFile next. aPiece isNil ifTrue: [^0].	aPiece isDigit ifFalse: [aFile skip: -2] ifTrue: [isDigitFlag _true].].	"[aFile next isDigit] whileFalse: [aFile skip: -2]." "This wasTed's elegant version.									Theuglier one above is to be able to test backing up too far."	aFile skip: -2.	[pp _ aFile position + 1. aFile next isDigit] whileTrue: [		aFile skip: -2].	back  _ (aFile upTo: $!!) asNumber.	aFile position: pp; skip: 0-back.	^ pp "now positioned at the end"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/7/1998 11:30'!chunk1	^self formatForOutput	"| who |	^ String streamContents: [:ss |		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  time print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/10/1998 14:16'!formatForOutput	^ String streamContents: [:ss |		ss nextPutAll: 'self '.		self outputFormat do: [:block |							ss nextPutAll:(block value: self)					"ifError: [:msg :rec |							 ss nextPutAll:'*** ', rec asString, ': ', msgasString ]"].		ss nextPutAll: 'text: ']."		   nextPutAll: name printString;		   nextPutAll: ' date: ''';		   nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.		     Time now print24: true on: ss.		who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: ';		   nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:15'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	self scanFrom: theFile.	"name, date"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 19:43'!name: pageName date: dateString time: timeString by: who text: theStringback: bytes	"Record the name of this page during startup.  When reading thepage in order to serve it, this is NOT executed.  The text is read from thefile explicitly."	name _ pageName.	date _ dateString asDate.	time _ timeString asTime.	address _ who! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/8/1998 18:08'!text: theString back: bytes	"Record the name of this page during startup.  When reading the page inorder to serve it, this is NOT executed.  The text is read from the fileexplicitly.""Which means that you'd better not cascade text & back or you're royallyscrewed ;) BJP"! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/13/1998 13:33'!unique: aTag in: aSet	"If aTag is not in aSet, put it in and return aTag.  If it's there,make up a new tag, insert it, and return it.  For keeping insertion pointsin text unique, so can tell where to put incoming text."	| base new |	((aSet includes: aTag) not and: [aTag size > 0]) ifTrue: [aSet add:aTag.  ^ aTag].	base _ 0.	[new _ (100 atRandom + base) printString.		aSet includes: new] whileTrue:			[base _ base + 50].	aSet add: new.	^ new! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/14/1998 20:52'!uniqueInsertionPoints: aString	"Find all occurances of '*append here'.  Make them lower case.  Ifthey don't have a number after them, assign one.  Don't use the same numbertwice in this page.  Place ID can actually be any string."| sourceStream targetStream ids char pos inside rest |sourceStream := ReadStream on: aString.targetStream := WriteStream on: String new.ids _ Set new.	"id numbers that have been used"[sourceStream atEnd	] whileFalse: [	targetStream nextPut: (char _ sourceStream next).	char == $* ifTrue: [		pos _ sourceStream position.		inside _ sourceStream upTo: $*.		(inside asLowercase beginsWith: 'append here')			ifFalse: [sourceStream position: pos.	"ignore"				((inside = '') and: [sourceStream atEndnot]) ifTrue: [					targetStream nextPut: (char _sourceStream next)]]	"Honor **"			ifTrue: ["See if it has a number"				targetStream nextPutAll: 'append here '.				rest _ inside copyFrom: (13 min: insidesize +1) to: inside size.				targetStream nextPutAll: (self unique: restin: ids); nextPut: $*]]].^ targetStream contents! !!SwikiPage class methodsFor: 'initialization' stamp: 'BJP 9/7/1998 12:23'!initialize	"SwikiPage initialize"	OutputFormat _ OrderedCollection new.	OutputFormat		add: [:thePage | 'name: ', thePage name printString, '; '];		add: [:thePage | 'date: ', thePage date mmddyyyyprintString, '; '];		add: [:thePage | 'time: ''', thePage time asString, '''; '];		add: [:thePage | 'by: ', thePage by printString, '; '];		add: [:thePage | 'pageStatus: #', thePage pageStatus, '; ']";		add: [:thePage | 'text: ']."! !!SwikiPage class methodsFor: 'accessing' stamp: 'BJP 9/7/1998 11:32'!outputFormat	^OutputFormat! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of the two selective flush methods needs to be used.	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 119>! !!Symbol class methodsFor: 'access' stamp: 'tk 8/11/1998 22:12'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString list binary |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	list _ lookupString correctAgainst: table.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | list addFirst: him]].	^ list! !!Symbol class methodsFor: 'access' stamp: 'di 11/15/1998 16:46'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive."	| size table candidate selectorList selectorTable ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^ selectorList].	aString size = 1 ifTrue:		[ascii _ aString first asciiValue.		ascii < 128 ifTrue:			[selectorList add: (SingleCharSymbols at: ascii + 1)]].	aString first isLetter ifFalse: [^ selectorList].	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate findString: aString startingAt: 1 caseSensitive: false) > 0) ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon' "! !!SyntaxError methodsFor: 'initialization' stamp: 'di 10/9/1998 16:17'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	contents _ aString.	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:36'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	doitFlag	ifTrue: [Compiler new evaluate: aString in: nil to: nil						notifying: aController ifFail: [^ false]]	ifFalse: [(class compile: aString classified: category						notifying: aController) ifNil: [^ false]].	aController hasUnacceptedEdits: false.	self proceed! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:51'!notify: error at: location in: source	"Open a syntax error view, inserting the given error message into the given source at the given location. This message is sent to the 'requestor' when the parser or compiler finds a syntax error."	| aClass aString |	aClass _ thisContext sender receiver encoder classEncoding.	aString _		source contents			copyReplaceFrom: location			to: location - 1			with: error.	self setClass: aClass		code: aString		debugger: (Debugger context: thisContext)		doitFlag: false.	self class open: self.! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:22'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph on: aSyntaxError list: #list			selected: #listIndex changeSelected: nil menu: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph on: aSyntaxError text: #contents			accept: #contents:notifying: readSelection: #contentsSelection			menu: #codePaneMenu:shifted:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 10/9/1998 16:18'!errorInClass: aClass withCode: codeString doitFlag: doit	"Open a view whose model is a syntax error. The error occurred when trying to add the given method code to the given class."	self open:		(self new setClass: aClass			code: codeString			debugger: (Debugger context: thisContext)			doitFlag: doit).! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:10'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	World ifNotNil:		[self buildMorphicViewOn: aSyntaxError.		Project current spawnNewProcess.		^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/5/1998 18:41'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	SystemChanges isEmpty ifTrue: [^ self inform: 'There are no changed messagesin the current change set.'].	ChangedMessageSet openFor: SystemChanges! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05'!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	^ self browseMessageList: (self allMethodsWithSourceString: aString									matchCase: caseSensitive)		name: 'Methods containing ' , aString printString , suffix autoSelect: aString! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-insensitive, unless the shift key is pressed, in which case the search is case-sensitive."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: aString caseSensitive: caseSensitive]]]		name:  'Methods with string ', aString printString, suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 12/15/1998 14:15'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses)."	aBlock value: Object.	Object allSubclassesDo: aBlock.	"Classes outside the Object hierarchy"	aBlock value: ObjectTracer.	ObjectTracer allSubclassesDo: aBlock.	aBlock value: ObjectOut.	ObjectOut allSubclassesDo: aBlock.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 9/29/1998 15:23'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList |	#(23 48 'fred' (new open:label:)) size.		"Example above should find #open:label:, though it is deeply embedded here."	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: special byte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte: byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 11/23/1998 12:02'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  The search is case-insensitive."	| list classCount |	list _ Set new.'Searching all source code...'displayProgressAt: Sensor cursorPointfrom: 0 to: Smalltalk classNames sizeduring:	[:bar | classCount _ 0.	Smalltalk allClassesDo:		[:class | bar value: (classCount _ classCount + 1).		(Array with: class with: class class) do:			[:cl | cl selectorsDo:				[:sel | 				((cl sourceCodeAt: sel) findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0					ifTrue:					[sel == #DoIt ifFalse: [list add: cl name , ' ' , sel]]]]]].	^ list asSortedCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 12/15/1998 21:47'!allUnSentMessagesIn: selectorSet	"Answer the subset of selectorSet which are not sent anywhere in the system.	Factored out from#allUnSentMessages "	|  all |	all _ selectorSet copy.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:lit |					(lit isMemberOf: Symbol)  "might be sent"						ifTrue: [all remove: lit ifAbsent: []].					(lit isMemberOf: Array)  "might be performed"						ifTrue: [lit do:								[:elt |								(elt isMemberOf: Array)									ifTrue: [elt do: [:e | all remove: e ifAbsent: []]]									ifFalse: [all remove: elt ifAbsent: []]]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			all remove: (self specialSelectorAt: index) ifAbsent: []]].	^ all! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 8/11/1998 13:23'!removeClassFromSystemUnlogged: aClass	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	SystemOrganization removeElement: aClass name.	self removeKey: aClass name.	self flushClassNameCache! !!SystemDictionary methodsFor: 'shrinking' stamp: 'wod 11/3/1998 15:41'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	"wod 11/3/1998: zap the organization before rather than after condensing changes."	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk allBehaviorsDo: [: b | b zapOrganization].	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 11/1/1998 08:31'!abandonTempNames	"Replaces every method by a copy with no source pointer or encoded temp names."	"Smalltalk abandonTempNames"	 | continue oldMethods newMethods n m |	continue _ (self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.').	continue ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts; garbageCollect.	oldMethods _ OrderedCollection new.	newMethods _ OrderedCollection new.	n _ 0.	'Removing temp names to save space...'		displayProgressAt: Sensor cursorPoint		from: 0 to: CompiledMethod instanceCount		during: [:bar |			Smalltalk allBehaviorsDo: [:cl |				cl selectors do: [:sel |					bar value: (n _ n + 1).					m _ cl compiledMethodAt: sel.					oldMethods addLast: m.					newMethods addLast: (m copyWithTrailerBytes: #(0))]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk closeSourceFiles.	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 13:00'!discardMorphic	"Discard Morphic."	| subs |	subs _ OrderedCollection new.	Morph allSubclassesWithLevelDo: [:c :i | subs addFirst: c]		startingLevel: 0.	subs do: [:c | c removeFromSystem].	SystemOrganization removeCategoriesMatching: 'User Objects'.	SystemOrganization removeCategoriesMatching: 'Experimental-'.	SystemOrganization removeCategoriesMatching: 'Morphic-*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 14:59'!discardNetworking	"Discard the support for TCP/IP networking."	Smalltalk discardPluggableWebServer.	SystemOrganization removeCategoriesMatching: 'HTML-*'.	SystemOrganization removeCategoriesMatching: 'NetTools-*'.	SystemOrganization removeCategoriesMatching: 'Network-*'.	SystemOrganization removeCategoriesMatching: 'System-Network'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 18:51'!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	Smalltalk at: #FormEditor ifPresent: [:c | c removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk at: #SampledSound ifPresent: [:c |		(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [c initialize]].	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k ifAbsent: []].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 11:55'!discardSoundSynthesis	"Discard the sound synthesis facilities, and the methods and classes that use it. This also discards MIDI."	Smalltalk discardMIDI.	Smalltalk removeClassNamed: #EnvelopeLineMorph.	Smalltalk removeClassNamed: #EnvelopeEditorMorph.	Smalltalk removeClassNamed: #PianoKeyboardMorph.	Smalltalk removeClassNamed: #WaveEditor.	Smalltalk removeClassNamed: #SoundSequencerMorph.	Smalltalk removeClassNamed: #SoundMorph.	Smalltalk removeClassNamed: #SoundLoopMorph.	Smalltalk removeClassNamed: #InterimSoundMorph.	Smalltalk removeClassNamed: #RecordingControlsMorph.	Smalltalk removeClassNamed: #PermanentRecordingControlsMorph.	Smalltalk removeClassNamed: #SoundDemoMorph.	Smalltalk at: #GraphMorph ifPresent: [:graphMorph |		#(loadCoffeeCupClink play playBach playOnce		  readDataFromFile registerWaveform stopPlaying)			do: [:sel | graphMorph removeSelector: sel]].	Smalltalk at: #TrashCanMorph ifPresent: [:trashMorph |		trashMorph class removeSelector: #samplesForDelete.		trashMorph class removeSelector: #samplesForMouseEnter.		trashMorph class removeSelector: #samplesForMouseLeave].	SystemOrganization removeCategoriesMatching: 'System-Sound'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 13:50'!discardVMConstruction	"Discard the virtual machine construction classes and the Smalltalk-to-C translator. These are only needed by those wishing to build or study the Squeak virtual machine, or by those wishing to construct new primitives via Smalltalk-to-C translation."	"remove the code for virtual machines"	Smalltalk removeKey: #InterpreterLog ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Squeak-Jitter'.	SystemOrganization removeCategoriesMatching: 'Squeak-Interpreter'.	"remove the Smalltalk-to-C translator"	Smalltalk at: #CCodeGenerator ifPresent: [:codeGen | codeGen removeCompilerMethods].	SystemOrganization removeCategoriesMatching: 'Squeak-Translation to C'.	Smalltalk removeClassNamed: #SystemTracer.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/24/1998 14:00'!lastRemoval  "Smalltalk lastRemoval"	#(abandonSources browseAllSelect: printSpaceAnalysis browseObsoleteReferences  lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 15:38'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around ?? in size."Smalltalk discardVMConstruction.  "663k"Smalltalk discardSoundSynthesis.  "330k"Smalltalk discardOddsAndEnds.  "228k"Smalltalk discardNetworking.  "261k"Smalltalk discardMorphic.  "2,231k""Above altogether saves 3,541k"	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete lots of classes.."	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'System-Object Storage'.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	RemoteString removeSelector: #makeNewTextAttVersion.	Utilities class removeSelector: #absorbUpdatesFromServer.	Smalltalk removeClassNamed: #PenPointRecorder.	Smalltalk removeClassNamed: #Path.	Smalltalk removeClassNamed: #Base64MimeConverter.	Smalltalk removeClassNamed: #EToySystem.	Smalltalk removeClassNamed: #RWBinaryOrTextStream.	Smalltalk removeClassNamed: #AttributedTextStream.	TextStyle allInstancesDo:		[:ts | ts newFontArray: (ts fontArray copyFrom: 1 to: 2)].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/24/1998 14:00'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(browseAllSelect: printSpaceAnalysis lastRemoval		dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 9/24/1998 16:33'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Smalltalk isMorphic			ifTrue: [Project current interruptName: 'Space is low']			ifFalse: [ScheduledControllers interruptName: 'Space is low']! !!SystemDictionary methodsFor: 'special objects' stamp: 'ar 3/21/98 15:30'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 42.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	newArray at: 42 put: Semaphore new. "finalization Semaphore"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 10/6/1998 14:36'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChanges _ aChangeSet.	Project current setChangeSet: aChangeSet! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 1/15/1999 01:26'!version	"Answer the version of this release."	^ 'Squeak 2.3 of January 14, 1999'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'tk 9/22/1998 23:15'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #MailDB ifPresent: [:mailDB |		mailDB allInstancesDo: [:db | db saveDB]].  "snapshot all mail databases to disk"	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	Smalltalk at: #HttpUrl ifPresent: [:urlClass | urlClass shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'tk 1/13/1999 15:38'!processStartUpList	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."	DisplayScreen startUp.	FileDirectory startUp.	CrLfFileStream startUp.	Cursor startUp.	Smalltalk installLowSpaceWatcher.	InputSensor startUp.	ProcessorScheduler startUp.	Delay startUp.	Smalltalk startUp.	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [ControlManager startUp].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sw 10/13/1998 16:06'!processUpdates	"Process update files from a well-known update server.  This method is called at system startup time,   Only if the preference #updateFromServerAtStartup is true is the actual update processing undertaken automatically"	| choice |	(Preferences valueOfFlag: #updateFromServerAtStartup) ifTrue:		[choice _ (PopUpMenu labels: 'Yes, Update\No, Not now' withCRs)			startUpWithCaption: 'Shall I look for new code\updates on the server?' withCRs.		choice = 1 ifTrue: [Utilities updateFromServer]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sw 8/22/1998 22:41'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'TPR 5/10/1998 21:33'!saveAs	| dir newName newImageName newChangesName |	dir _ FileDirectory default.	newName _ (FillInTheBlank		request: 'New File Name?'		initialAnswer: 'NewImageName') asFileName.	newName _ FileDirectory baseNameFor: newName.	newImageName _ newName, FileDirectory dot, FileDirectory imageSuffix.	newChangesName _ newName, FileDirectory dot, FileDirectory changeSuffix.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Decompiling all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Decompiler Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/28/1998 06:06'!testFormatter2    "Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged"	 | newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			newCodeString _ (cls compilerClass new)				format: oldCodeString				in: cls notifying: nil.			oldTokens _ oldCodeString findTokens: Character separators.			newTokens _ newCodeString findTokens: Character separators.			oldTokens = newTokens ifFalse:					[Transcript cr; show: '***' , cls name , ' ' , selector.					badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 12/30/1998 05:16'!compilerDisable	"Smalltalk compilerDisable"	<primitive: 'squeakCompilerDisable' module: 'squeakCompiler'>! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 12/30/1998 05:15'!compilerEnable	"Smalltalk compilerEnable"	<primitive: 'squeakCompilerEnable' module: 'squeakCompiler'>! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 9/23/1998 16:11'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[Project current interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:04'!hasMorphic	"Answer whether the Morphic classes are available in the system (they may have been stripped, such as by a call to Smalltalk removeMorphic"	^ ((Smalltalk at: #WorldMorph ifAbsent: [nil]) isKindOf: Class)! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:42'!imageImports	"Answer the global dictionary of image imports, creating it if necessary.  7/24/96 sw"	"Smalltalk viewImageImports"	(self includesKey: #ImageImports)		ifFalse:			[self at: #ImageImports put: Dictionary new].	^ self at: #ImageImports! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:26'!imageReaderClass	"Answer, if present, a class to handle the importing of various graphic image files	from disk. If none, return nil.   tao 10/26/97"	| aClass |	^ ((aClass _ self at: #ImageReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:23'!jpegReaderClass	"Answer, if present, a class to handle the importing of JPEG files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #JPEGReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:38'!spaceForInstancesOf: aClass	"Answer the number of bytes consumed by all instances of the given class, including thier object headers."	| instCount isCompact instVarBytes bytesPerElement contentBytes headerBytes total |	instCount _ aClass instanceCount.	instCount = 0 ifTrue: [^ 0].	isCompact _ aClass indexIfCompact > 0.	instVarBytes _ aClass instSize * 4.	aClass isVariable		ifTrue: [			bytesPerElement _ aClass isBytes ifTrue: [1] ifFalse: [4].			total _ 0.			aClass allInstancesDo: [:inst |				contentBytes _ instVarBytes + (inst size * bytesPerElement).				headerBytes _					contentBytes > 255						ifTrue: [12]						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].				total _ total + headerBytes + contentBytes].			^ total]		ifFalse: [			headerBytes _				instVarBytes > 255					ifTrue: [12]					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].			^ instCount * (headerBytes + instVarBytes)].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:45'!spaceTally	"Answer a collection of tuples representing the memory space (in bytes) consumed by the code and instances of each class in the system. The tuples have the form:	<class> <code size> <instance count> <space for instances>Code sizes do not currently report memory consumed by class variables. The arrays used to record these results consume a relatively insignificant amount of space."	"(Smalltalk spaceTally asSortedCollection: [:a :b | a last > b last]) asArray"	| results entry c |	"pre-allocate array of entries for results"	results _ OrderedCollection new: self size.	self do: [:cl |		(cl isKindOf: Class) ifTrue: [			entry _ Array new: 4.			entry at: 1 put: cl.			results add: entry]].	results _ results asArray.	Smalltalk garbageCollect.	1 to: results size do: [:i |		entry _ results at: i.		c _ entry at: 1.		entry at: 2 put: c spaceUsed.		entry at: 3 put: c instanceCount.		entry at: 4 put: (self spaceForInstancesOf: c).		Smalltalk garbageCollectMost].	^ results! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:03'!verifyMorphicAvailability	"If Morphic is available, return true; if not, put up an informer and return false"	self hasMorphic ifFalse:		[self beep.		self inform: 'Sorry, Morphic mustbe present to use this feature'.		^ false].	^ true! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:53'!viewImageImports	"Open up a special Form inspector on the dictionary of image imports."	self imageImports inspectFormsWithLabel: 'Image Imports'! !!SystemMonitor methodsFor: 'system parameters' stamp: 'jm 10/20/1998 11:36'!cacheVal	| icHit mcHit mcMiss total deltaMcMiss deltaMcHit deltaIcHit |	mcMiss _ vmParameters at: 15.	deltaMcMiss _ mcMiss - prevMcMiss.	prevMcMiss _ mcMiss.	mcHit _ vmParameters at: 16.	deltaMcHit _ mcHit - prevMcHit.	prevMcHit _ mcHit.	icHit _ vmParameters at: 17.	deltaIcHit _ icHit - prevIcHit.	prevIcHit _ icHit.	total _ deltaMcMiss + deltaMcHit + deltaIcHit.	total = 0 ifTrue: [total _ 1].	deltaMcMiss _ (deltaMcMiss * 100 / total asInteger).	deltaMcHit _ (deltaMcHit * 100 / total asInteger).	^Array		with: deltaMcMiss		with: deltaMcMiss + deltaMcHit! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:48'!actualObject	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:46'!initialize	super initialize.	self removeAllMorphs.	resultType _ #boolean! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:50'!isBoolean	^ true! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:51'!storeCodeOn: aStream indent: tabCount	submorphs first storeCodeOn: aStream indent: tabCount! !!SystemTracer methodsFor: 'initialization' stamp: 'di 12/15/1998 22:43'!initCompactClasses 	"NOTE: at present the VM counts on BlockContext and MethodContext keeping their present compact class indices."	| c |	c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: PseudoContext.	compactClasses _ c.	"Leave 16 to 31 for user defined compact classes."	"Attempt to correctly write contextCache image.."	"compactClasses _ Smalltalk compactClassesArray"! !!SystemTracer methodsFor: 'initialization' stamp: 'tk 12/15/1998 14:09'!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				].	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/8/1998 16:55'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: file fullName		type: 'STim'		creator: 'FAST'.	file close.! !!SystemTracer methodsFor: 'private' stamp: 'ar 3/21/98 00:31'!formatOf: obj	"Make the code that tells the format of this object.	It is like the class's instSpec, but with added low bits for byte size""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields        4=      both fixed and indexable weak fields        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	| class spec |	class _ obj class.	spec _ class instSpec.    "just use what's there"	spec < 8 ifTrue: [^ spec]			ifFalse: ["For byte objects, size = wordSize - spec.lowBits"					^ spec + (3 - (obj size+3 bitAnd: 3))]! !!SystemWindow methodsFor: 'initialization' stamp: 'sw 11/5/1998 10:26'!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	Preferences noviceMode ifTrue:		[closeBox setBalloonText: 'close window'.		collapseBox 	setBalloonText: 'collapse/expand window'].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabel to: self.	self extent: 300@200! !!SystemWindow methodsFor: 'geometry' stamp: 'di 1/3/1999 21:42'!extent: newExtent	| inner labelRect |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: self paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/15/1998 11:27'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [self position: ((self position max: 0@0) grid: 8@8).				collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds.				TopWindow ~~ self ifTrue: [self activate]]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:56'!labelRect	^ self innerBounds withHeight: self labelHeight.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:55'!panelRect	"Return the area below title bar, devoted to panes"	^ self innerBounds topLeft + (0@(self labelHeight))					corner: self innerBounds bottomRight! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/8/1998 13:41'!setBoundsOfPaneMorphs	| panelRect |	panelRect _ self panelRect.	paneMorphs with: paneRects do:		[:m :frame |  "m color: paneColor."		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/23/1998 09:39'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| panelRect |	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | 		(m bounds translateBy: panelRect topLeft negated)			scaleBy: (1.0 asPoint / panelRect extent)]! !!SystemWindow methodsFor: 'label' stamp: 'wod 11/26/1998 23:54'!relabel	| newLabel |	newLabel _ FillInTheBlank 		request: 'New label for this window'		initialAnswer: labelString.	newLabel isEmpty ifTrue: [^self].	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!SystemWindow methodsFor: 'label' stamp: 'di 11/10/1998 09:48'!setLabel: aString	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	self isCollapsed		ifTrue: [self extent: (label width + 50) @ (self labelHeight + 2)]		ifFalse: [label fitContents; setWidth: (label width min: bounds width - 50).				label align: label bounds topCenter with: bounds topCenter + (0@borderWidth).				collapsedFrame ifNotNil:					[collapsedFrame _ collapsedFrame withWidth: label width + 50]]! !!SystemWindow methodsFor: 'label' stamp: 'sw 12/2/1998 16:49'!widthOfFullLabelText	^ (QuickPrint newOn: Display box: Display boundingBox font: ((TextStyle default fontAt: 2) emphasized: 1)) stringWidth: labelString! !!SystemWindow methodsFor: 'open/close' stamp: 'jm 8/20/1998 18:32'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model windowIsClosing; release.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld.! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 8/12/1998 14:40'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !!SystemWindow methodsFor: 'open/close' stamp: 'ls 7/21/1998 00:30'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self position: (RealEstateAgent initialFrameFor: self) topLeft; extent: extent.	World addMorph: self.	self activate.	World startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 10/15/1998 11:13'!positionSubmorphs	"Feels like overkill, but effect needed"	super positionSubmorphs.	self submorphsDo:		[:aMorph | aMorph positionSubmorphs]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 6/24/1998 21:30'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		super bounds: fullFrame.		paneMorphs reverseDo: [:m | self addMorph: m].		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		paneMorphs do: [:m | m delete; releaseCachedState].		collapsedFrame			ifNil:	[self extent: (label width + 50) @ (self labelHeight + 2).					self position: (RealEstateAgent assignCollapsePointFor: self)]			ifNotNil: [super bounds: collapsedFrame]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 6/17/1998 11:55'!mouseLeaveEvent: event fromPane: pane	"For backward compatibility only.  Not used by any newly created window"	(pane isKindOf: ScrollPane) ifTrue: [pane mouseLeave: event].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/21/1998 16:12'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen box |	theLen _ 0.	paneMorphs do:		[:pane | box _ pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane _ pane.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ thePane! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 22:55'!reframePanesAdjoining: growingPane along: side to: aDisplayBox 	| delta newRect minDim theMin horiz |	growingPane ifNil: [^ self].  "As from click outside"	newRect _ aDisplayBox.	horiz _ #(left right) includes: side.	theMin _ horiz ifTrue: [40] ifFalse: [20].	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ (((paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side])		collect: [:pane | pane bounds adjustTo: newRect along: side]) copyWith: aDisplayBox)			inject: 999 into:				[:was :rect | was min: (horiz ifTrue: [rect width] ifFalse: [rect height])].	"If so, amend newRect as required"	minDim > theMin ifFalse:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (growingPane bounds perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	paneMorphs do:		[:pane | (pane bounds bordersOn: growingPane bounds along: side) ifTrue:			[pane bounds: (pane bounds adjustTo: newRect along: side)]].	"And adjust the growing pane itself"	growingPane bounds: newRect.	"Finally force a recomposition of the whole window"	self setPaneRectsFromBounds.	self extent: self extent! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 23:18'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds |	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			side = #top ifTrue: [newBounds _ growingPane bounds withTop: localPt y].			side = #bottom ifTrue: [newBounds _ growingPane bounds withBottom: localPt y].			side = #left ifTrue: [newBounds _ growingPane bounds withLeft: localPt x].			side = #right ifTrue: [newBounds _ growingPane bounds withRight: localPt x].			self reframePanesAdjoining: growingPane along: side to: newBounds]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'sw 11/30/1998 15:49'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) 		ifTrue:  [^ self].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [newBounds _ self bounds withTop: localPt y].			ptName = #bottom ifTrue: [newBounds _ self bounds withBottom: localPt y].			ptName = #left ifTrue: [newBounds _ self bounds withLeft: localPt x].			ptName = #right ifTrue: [newBounds _ self bounds withRight: localPt x].			ptName = #topLeft ifTrue: [newBounds _ localPt corner: bounds bottomRight].			ptName = #bottomRight ifTrue: [newBounds _ bounds topLeft corner: localPt].			ptName = #bottomLeft ifTrue: [newBounds _ (bounds withBottom: localPt y) withLeft: localPt x].			ptName = #topRight ifTrue: [newBounds _ (bounds withTop: localPt y) withRight: localPt x].			newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'di 11/25/1998 15:15'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	outerMorph _ self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !!SystemWindow methodsFor: 'top window' stamp: 'di 1/14/1999 08:50'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	self submorphsDo:		[:m | (m == closeBox or: [m == collapseBox])				ifTrue: ["Control boxes remain active, except in novice mode"						Preferences noviceMode ifTrue: [m lock]]				ifFalse: [m lock]].	self world ifNotNil:  "clean damage now, so dont merge this rect with new top window"		[self world == World ifTrue: [self world displayWorld]]! !!SystemWindow methodsFor: 'panes' stamp: 'di 1/3/1999 21:44'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		color: self paneColor;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'di 1/3/1999 21:42'!paneColor	Display depth > 2 ifTrue: [^ Color colorFrom: model defaultBackgroundColor].	^ Color white! !!SystemWindow methodsFor: 'panes' stamp: 'di 1/4/1999 21:19'!updatePaneColors	"Useful when changing from monochrome to color display"	self setStripeColorsFrom: self paneColor.	paneMorphs do: [:p | p color: self paneColor].! !!SystemWindow methodsFor: 'events' stamp: 'di 1/10/1999 10:10'!handlesMouseDown: evt	"If I am not the topWindow, then I will only respond to dragging by the title bar.	Any other click will only bring me to the top"	Preferences fastDragWindowForMorphic ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/5/1998 08:20'!mouseDown: evt	| cp offset newBounds |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[Preferences fastDragWindowForMorphic		ifTrue: [offset _ self position - Sensor cursorPoint.				newBounds _ self bounds newRectFrom:					[:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft]		ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseMove: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/23/1998 09:22'!paneTransition: event	"Mouse has entered or left a pane"	^ self spawnReframeHandle: event! !!SystemWindow methodsFor: 'stepping' stamp: 'ls 8/3/1998 21:49'!stepTime	(model respondsTo: #stepTime) ifTrue: [ ^model stepTime ].	^ 200 "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'di 1/8/1999 15:02'!wantsSteps	"Return true if the model wants its view to be stepped."		^ model wantsSteps! !!SystemWindow methodsFor: 'drawing' stamp: 'di 8/16/1998 01:14'!areasRemainingToFill: aRectangle	| areas |	(areas _ super areasRemainingToFill: aRectangle) isEmpty		ifTrue: [^ areas "good news -- complete occlusion"].	"Check for special case that this is scrollbar damage"	((bounds topLeft - (14@0) corner: bounds bottomRight) containsRect: aRectangle) ifTrue:		[paneMorphs do: [:p | ((p isKindOf: ScrollPane) and: [p scrollBarFills: aRectangle])							ifTrue: [^ Array new]]].	^ areas! !!SystemWindow methodsFor: 'menu' stamp: 'sw 10/5/1998 14:56'!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size == 1 ifFalse: [^ self beep].	aMorph _ paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!TAssignmentNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:14'!bindVariableUsesIn: aDictionary	"Do NOT bind the variable on the left-hand-side of an assignment statement."	expression _ expression bindVariablesIn: aDictionary.! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	expression _ expression bindVariableUsesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariableUsesIn: aDictionary ].! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:27'!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariableUsesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/11/1998 07:49'!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 60 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.! !!TCaseStmtNode methodsFor: 'all' stamp: 'di 12/14/1998 22:22'!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	"NOTE: I have made this work for the nested case (ie several shared entry points in the same case, but it does not really work for methods with arguments.  A mechanism coud be added that would add a preamble of the form,	innerSharedTemp = outerTemp;when they differed.  There should at least be a test here."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts == nil 							ifTrue: [newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection]							ifFalse: [newStmts removeLast "preserve any prior shared entry points - di"].						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt _ oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].! !!TMethod methodsFor: 'initialization' stamp: 'ar 9/18/1998 23:24'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	export _ self extractExportDirective.	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'accessing' stamp: 'jm 11/24/1998 09:03'!export	^ export! !!TMethod methodsFor: 'primitive compilation' stamp: 'ar 10/10/1998 23:36'!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	"ar 10/7/1998 -- 	Add the export directive for translated primitives.				--	Use the name of the primitive if it's called by name."	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	primArgCount _ args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn _ self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	"Check for pluggable primitive"	primitive = 117 		ifTrue:[	selector _ (aClass compiledMethodAt: selector) literals first at: 2.				export _ true]		ifFalse:[selector _ 'prim', aClass name, selector].	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].! !!TMethod methodsFor: 'transformations' stamp: 'ar 10/7/1998 18:55'!extractExportDirective	"Scan the top-level statements for an inlining directive of the form:		self export: <boolean>	 and remove the directive from the method body. Return the argument of the directive or false if there is no export directive."	| result newStatements |	result _ false.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #export:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'transformations' stamp: 'jm 12/14/1998 08:35'!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 ['self' = lastStmt expression name]]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TMethod methodsFor: 'inlining' stamp: 'jm 12/13/1998 10:06'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList _ OrderedCollection new: 100.	substitutionDict _ Dictionary new: 100.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName asSymbol put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList! !!TMethod methodsFor: 'inlining' stamp: 'jm 12/13/1998 10:06'!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict _ Dictionary new: 100.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName asSymbol put: exprNode.		locals remove: argName.	].	meth parseTree bindVariablesIn: substitutionDict.	^meth statements first expression! !!TMethod methodsFor: 'inlining' stamp: 'jm 12/13/1998 10:07'!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething _ false.	sendsToInline _ Dictionary new: 100.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething _ true.		parseTree _ parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	stmtLists _ self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements _ OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething _ true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"	].	^didSomething! !!TMethod methodsFor: 'inlining support' stamp: 'jm 12/13/1998 10:06'!renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels _ destMethod labels asSet.	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap _ Dictionary new: 100.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.! !!TMethod methodsFor: 'inlining support' stamp: 'jm 12/13/1998 10:07'!renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i _ 1.	varMap _ Dictionary new: 100.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i _ i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1! !!TMethod methodsFor: 'inlining support' stamp: 'jm 12/13/1998 10:07'!renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars _ aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars _ destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap _ Dictionary new: 100.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25'!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	export 		ifTrue:[aStream nextPutAll:'EXPORT('; nextPutAll: returnType; nextPutAll:') ']		ifFalse:[aStream nextPutAll: returnType; space].	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25'!emitProxyFunctionPrototype: aStream generator: aCodeGen	"Emit an indirect C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: '(*', (aCodeGen cFunctionNameFor: selector), ')('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TParseNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:13'!bindVariableUsesIn: aDictionary	"Bind uses of all variables in the given dictionary, but do not change variables that appear on the left-hand-side of an assignment statement."	^ self! !!TReturnNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	expression _ expression bindVariableUsesIn: aDictionary.! !!TSendNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	receiver _ receiver bindVariableUsesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariableUsesIn: aDictionary ].! !!TSendNode methodsFor: 'all' stamp: 'jm 12/14/1998 08:36'!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Special case for pluggable modules. Replace messages to interpreterProxy	by interpreterProxy->message(..) if the message is not builtin"	(aCodeGen isGeneratingPluginCode and:[		receiver isVariable and:[			'interpreterProxy' = receiver name and:[				self isBuiltinOperator not]]]) 		ifTrue:[aStream nextPutAll:'interpreterProxy->'].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [('self' = receiver name) or: ['interpreterProxy' = receiver name]]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TStmtListNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	statements _ statements collect: [ :s | s bindVariableUsesIn: aDictionary ].! !!TStmtListNode methodsFor: 'all' stamp: 'jm 11/25/1998 16:27'!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [:s |		level timesRepeat: [aStream tab].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or:		 [s isComment])			ifFalse: [aStream nextPut: $;].		aStream cr].! !!TStmtListNode methodsFor: 'all' stamp: 'jm 11/25/1998 16:26'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in a $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next].	^ ch = $}! !!TTCompositeGlyph methodsFor: 'initialize' stamp: 'ar 11/2/1998 01:20'!initialize	glyphs _ #().! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:21'!addGlyph: aGlyph transformation: aMatrix	glyphs _ glyphs copyWith: (aMatrix -> aGlyph)! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:43'!contours	^contours ifNil:[contours _ self computeContours]! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:20'!glyphs	^glyphs collect:[:assoc| assoc value].! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:28'!glyphsAndTransformationsDo: aBlock	glyphs do:[:assoc|		aBlock value: assoc value value: assoc key.	].! !!TTCompositeGlyph methodsFor: 'testing'!isComposite	^true! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:43'!computeContours	| out |	out _ WriteStream on: (Array new: glyphs size * 4).	self glyphsAndTransformationsDo:[:glyph :transform|		glyph contours do:[:ptArray|			out nextPut: (transform localPointsToGlobal: ptArray).		].	].	^out contents! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:27'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ nil.! !!TTCompositeGlyph class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 01:20'!new	^super new initialize! !This class represents a temporary contour structure during the construction of a TTGlyph from a TrueType file.Instance variables:	points	<Array of: TTPoint>	The points defining this contour!!TTContourConstruction methodsFor: 'accessing'!points	^points! !!TTContourConstruction methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:34'!points: anArray	points _ anArray asArray.! !!TTContourConstruction methodsFor: 'accessing'!segments	| segments |	segments _ OrderedCollection new.	self segmentsDo:[:seg| segments add: seg].	^segments! !!TTContourConstruction methodsFor: 'enumerating' stamp: 'ar 11/3/1998 14:42'!segmentsDo: aBlock	"Evaluate aBlock with the segments of the receiver. This may either be straight line	segments or quadratic bezier curves. The decision is made upon the type flags	in TTPoint as follows:	a) 	To subsequent #OnCurve points define a straight segment	b) 	A #OnCurve point followed by a #OffCurve point followed 		by a #TT_ONCURVE point defines a quadratic bezier segment	c)	Two subsequent #OffCurve points have an implicitely defined 		#OnCurve point at half the distance between them"	| last next mid index |	last _ points first.	"The first point is _always_ on the curve"	(last type == #OnCurve) ifFalse:[		Transcript cr; show:'Bad starting point OffCurve'.		last type: #OnCurve].	index _ 2.	[index <= points size] whileTrue:[		mid _ points at: index.		mid type == #OnCurve ifTrue:[			"Straight segment"			aBlock value: (LineSegment from: last asPoint to: mid asPoint).			last _ mid.		] ifFalse:["Quadratic bezier"			"Read ahead if the next point is on curve"			next _ (index < points size) ifTrue:[points at: (index+1)] ifFalse:[points first].			next type == #OnCurve ifTrue:[				"We'll continue after the end point"				index _ index + 1.			] ifFalse:[ "Calculate center"				next _ (next asPoint + mid asPoint) // 2].			aBlock value:(Bezier2Segment from: last asPoint via: mid asPoint to: next asPoint).			last _ next].		index _ index + 1].	(index = (points size + 1)) ifTrue:[		aBlock value:(LineSegment from: points last asPoint to: points first asPoint)]! !!TTContourConstruction methodsFor: 'converting' stamp: 'ar 11/14/1998 21:17'!asCompressedPoints	"Return the receiver compressed into a PointArray.	All lines will be converted into bezier segments with	the control point set to the start point"	| out minPt maxPt fullRange |	minPt _ -16r7FFF asPoint.	maxPt _ 16r8000 asPoint.	"Check if we need full 32bit range"	fullRange _ points contains:[:any| any asPoint < minPt or:[any asPoint > maxPt]].	fullRange ifTrue:[		out _ WriteStream on: (PointArray new: points size).	] ifFalse:[		out _ WriteStream on: (ShortPointArray new: points size).	].	self segmentsDo:[:segment|		out nextPut: segment start.		segment isBezier2Segment 			ifTrue:[out nextPut: segment via]			ifFalse:[out nextPut: segment start].		out nextPut: segment end.	].	^out contents! !!TTContourConstruction methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: points size;		"space;		print: self type;"		nextPut:$)! !!TTContourConstruction class methodsFor: 'instance creation'!on: points	^self new points: points! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: aCharOrInteger	^glyphTable at: aCharOrInteger asInteger+1! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: index put: value	^self shouldNotImplement! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!ascender	^ascender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!bounds	^bounds! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!descender	^descender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!lineGap	^lineGap! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:49'!unitsPerEm	^unitsPerEm! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!copyright	^copyright! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!familyName	^familyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!fullName	^fullName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!postscriptName	^postscriptName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!subfamilyName	^subfamilyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!trademark	^trademark! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!uniqueName	^uniqueName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:49'!versionName	^versionName! !!TTFontDescription methodsFor: 'converting' stamp: 'ar 11/14/1998 23:47'!asMorph	^TTSampleFontMorph font: self! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/14/1998 20:20'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	glyphs do:[:glyph| glyph flipAroundY]! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setAscender: asc descender: desc lineGap: lgap	ascender _ asc.	descender _ desc.	lineGap _ lgap! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:28'!setBounds: aRect unitsPerEm: aNumber	bounds _ aRect.	unitsPerEm _ aNumber.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setGlyphs: glyphArray mapping: mappingTable	glyphs _ glyphArray.	glyphTable _ mappingTable.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:48'!setKernPairs: array	kernPairs _ array! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:46'!setStrings: anArray	copyright _ anArray at: 1.	familyName _ anArray at: 2.	subfamilyName _ anArray at: 3.	uniqueName _ anArray at: 4.	fullName _ anArray at: 5.	versionName _ anArray at: 6.	postscriptName _ anArray at: 7.	trademark _ anArray at: 8.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'ar 11/2/1998 00:25'!glyphs: glyphArray mapping: glyphTable bounds: aRectangle	^self new setGlyphs: glyphArray mapping: glyphTable bounds: aRectangle! !!TTFontReader methodsFor: 'public' stamp: 'ar 11/2/1998 23:51'!readFrom: aStream	| fontData headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat |	"Read the raw font byte data"	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData _ aStream contents asByteArray.	fontDescription _ TTFontDescription new.	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	charMap _ self processCharMap: cmap.	fontDescription setGlyphs: glyphs mapping: charMap.	fontDescription setKernPairs: kernPairs.	^fontDescription! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:21'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap _ assoc value.	charTable _ Array new: 256.	charTable atAllPut: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue:["Mac encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: i put: glyph]].	assoc key = 3 ifTrue:["Win encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: (WinToMacTable at: i) put: glyph]].	^charTable! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 23:48'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmapFmt tableLength cmap assoc |	initialOffset _ entry offset.	entry skip: 2. "Skip table version"	nSubTables _ entry nextUShort.	1 to: nSubTables do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		offset _ entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy _ entry copy.			copy offset: initialOffset + offset.			cmapFmt _ copy nextUShort.			tableLength _ copy nextUShort.			"We can only read cmaps of type 0 (e.g., byte encoded tables)"			(cmapFmt = 0 "or:[cmapFmt = 4]") ifTrue:[				cmap _ Array new: tableLength.				copy nextBytes: tableLength into: cmap startingAt: initialOffset + offset].			pID = 1 ifTrue:[^pID -> cmap]. "Prefer Macintosh encoding over everything else"			assoc _ pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/15/1998 01:00'!processCompositeGlyph: glyph contours: nContours from: entry	"Read a composite glyph from the font data. The glyph passed into this method contains some state variables that must be copied into the resulting composite glyph."	| flags glyphIndex hasInstr cGlyph ofsX ofsY iLen a11 a12 a21 a22 m |	cGlyph _ TTCompositeGlyph new.	a11 _ a22 _ 16r4000.	"1.0 in F2Dot14"	a21 _ a12 _ 0.		"0.0 in F2Dot14"	"Copy state"	cGlyph bounds: glyph bounds; glyphIndex: glyph glyphIndex.	hasInstr _ false.	[ flags _ entry nextUShort.	glyphIndex _ entry nextUShort + 1.	(flags bitAnd: 1) = 1 ifTrue:[		ofsX _ entry nextShort.		ofsY _ entry nextShort.	] ifFalse:[		(ofsX _ entry nextByte) > 127 ifTrue:[ofsX _ ofsX - 256].		(ofsY _ entry nextByte) > 127 ifTrue:[ofsY _ ofsY - 256]].	((flags bitAnd: 2) = 2) ifFalse:[self halt].	(flags bitAnd: 8) = 8 ifTrue:[		a11 _ a22 _ entry nextShort].	(flags bitAnd: 64) = 64 ifTrue:[		a11 _ entry nextShort.		a22 _ entry nextShort].	(flags bitAnd: 128) = 128 ifTrue:[		"2x2 transformation"		a11 _ entry nextShort.		a21 _ entry nextShort.		a12 _ entry nextShort.		a22 _ entry nextShort].	m _ MatrixTransform2x3 new.	"Convert entries from F2Dot14 to float"	m a11: (a11 asFloat / 16r4000).	m a12: (a12 asFloat / 16r4000).	m a21: (a21 asFloat / 16r4000).	m a22: (a22 asFloat / 16r4000).	m a13: ofsX.	m a23: ofsY.	cGlyph addGlyph: (glyphs at: glyphIndex) transformation: m.	hasInstr _ hasInstr or:[ (flags bitAnd: 256) = 256].	"Continue as long as the MORE_COMPONENTS bit is set"	(flags bitAnd: 32) = 32] whileTrue.	hasInstr ifTrue:[		iLen _ entry nextUShort.		entry skip: iLen].	^cGlyph! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:42'!processFontHeaderTable: entry"Value				Data Type    DescriptionunitsPerEm			USHORT      Granularity of the font's em square.xMax				USHORT      Maximum X-coordinate for the entire font.xMin				USHORT      Minimum X-coordinate for the entire font.yMax				USHORT      Maximum Y-coordinate for the entire font.yMin				USHORT      Minimum Y-coordinate for the entire font.indexToLocFormat	SHORT       Used when processing the Index To Loc Table."	| origin corner units indexToLocFormat |	entry skip: 4. "Skip table version number"	entry skip: 4. "Skip font revision number"	entry skip: 4. "Skip check sum adjustment"	entry skip: 4. "Skip magic number"	entry skip: 2. "Skip flags"	units _ entry nextUShort.	entry skip: 8. "Skip creation date"	entry skip: 8. "Skip modification date"	"Get min/max values of all glyphs"	origin _ entry nextShort @ entry nextShort.	corner _ entry nextShort @ entry nextShort.	entry skip: 2. "Skip mac style"	entry skip: 2. "Skip lowest rec PPEM"	entry skip: 2. "Skip font direction hint"	indexToLocFormat _ entry nextShort.	fontDescription setBounds: (origin corner: corner) unitsPerEm: units.	^indexToLocFormat! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/3/1998 14:43'!processGlyphDataTable: entry offsets: offsetArray	"Read the actual glyph data from the font.	offsetArray contains the start offsets in the data for each glyph."	| initialOffset glyph nextOffset glyphLength glyphOffset nContours origin corner |	initialOffset _ entry offset.	glyphs _ Array new: nGlyphs.	1 to: nGlyphs do:[:i | 		glyphs at: i put: (TTGlyph new glyphIndex: i-1)].	'Reading glyph data' 		displayProgressAt: Sensor cursorPoint		from: 1 to: nGlyphs during:[:bar|	1 to: nGlyphs do:[:glyphIndex |		bar value: glyphIndex.		glyph _ glyphs at: glyphIndex.		glyphOffset _ offsetArray at: glyphIndex.		nextOffset _ offsetArray at: glyphIndex+1.		glyphLength _ nextOffset - glyphOffset.		glyphLength = 0 ifFalse:[			entry offset: initialOffset + glyphOffset.			nContours _ entry nextShort.			origin _ entry nextShort @ entry nextShort.			corner _ entry nextShort @ entry nextShort.			glyph bounds: (origin corner: corner).			nContours >= 0 ifTrue:[				self processSimpleGlyph: glyph contours: nContours from: entry			] ifFalse:[				glyph _ self processCompositeGlyph: glyph contours: nContours from: entry.				glyphs at: glyphIndex put: glyph]]]	].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalHeaderTable: entry"ascender           SHORT          Typographic ascent.descender          SHORT          Typographic descent.lineGap            SHORT          Typographic lineGap.numberOfHMetrics   USHORT         Number hMetric entries in the HTMX                                               Table; may be smaller than the total                                             number of glyphs."	| asc desc lGap numHMetrics |	entry skip: 4. "Skip table version"	asc _ entry nextShort.	desc _ entry nextShort.	lGap _ entry nextShort.	entry skip: 2. "Skip advanceWidthMax"	entry skip: 2. "Skip minLeftSideBearing"	entry skip: 2. "Skip minRightSideBearing"	entry skip: 2. "Skip xMaxExtent"	entry skip: 2. "Skip caretSlopeRise"	entry skip: 2. "Skip caretSlopeRun"	entry skip: 10. "Skip 5 reserved shorts"	entry skip: 2. "Skip metricDataFormat"	numHMetrics _ entry nextUShort.	fontDescription setAscender: asc descender: desc lineGap: lGap.	^numHMetrics! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalMetricsTable: entry length: numHMetrics	"Extract the advance width, left side bearing, and right	side bearing for each glyph from the Horizontal Metrics Table."	|  index lastAW glyph |	index _ 1.	[index <= numHMetrics] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: entry nextUShort.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].	index = (nGlyphs +1) ifTrue:[^true].	lastAW _ (glyphs at: index-1) advanceWidth.	[index <= nGlyphs] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: lastAW.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:43'!processIndexToLocationTable: entry format: indexToLocFormat"glyphOffset    ULONG[numGlyphs]   An array that contains each glyph's                                 offset into the Glyph Data Table."	| glyphOffset offset|	glyphOffset _ Array new: nGlyphs+1.	1 to: nGlyphs+1 do:[:i|		(indexToLocFormat = 0) ifTrue:[ "Format0: offset/2 is stored"			offset _ entry nextUShort * 2.		] ifFalse:["Format1: store actual offset"			offset _ entry nextULong].		glyphOffset at: i put: offset].	^glyphOffset! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 23:21'!processKerningTable: entry	"Extract the kerning information for pairs of glyphs."	| covLow covHigh nKernPairs kp |	entry skip: 2. "Skip table version"	entry skip: 2. "Skip number of sub tables -- we're using the first one only"	entry skip: 2. "Skip current subtable number"	entry skip: 2. "Skip length of subtable"	covHigh _ entry nextByte.	covLow _ entry nextByte.	"Make sure the format is right (kerning table and format type 0)"	((covLow bitAnd: 2) = 2 or:[ covHigh ~= 0]) ifTrue:[^false].	nKernPairs _ entry nextUShort.	entry skip: 2. "Skip search range"	entry skip: 2. "Skip entry selector"	entry skip: 2. "Skip range shift"	kernPairs _ Array new: nKernPairs.	1 to: nKernPairs do:[:i|		kp _ TTKernPair new.		kp left: entry nextUShort.		kp right: entry nextUShort.		kp value: entry nextShort.		kernPairs at: i put: kp].	^true! !!TTFontReader methodsFor: 'processing'!processMaximumProfileTable: entry"numGlyphs         USHORT      The number of glyphs in the font."	entry skip: 4. "Skip Table version number"	nGlyphs _ entry nextUShort.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:38'!processNamingTable: entry"copyright         CHARPTR     The font's copyright notice.familyName        CHARPTR     The font's family name.subfamilyName     CHARPTR     The font's subfamily name.uniqueName        CHARPTR     A unique identifier for this font.fullName          CHARPTR     The font's full name (a combination of                                          familyName and subfamilyName).versionName       CHARPTR     The font's version string."	| nRecords initialOffset storageOffset pID sID lID nID length offset multiBytes string strings |	strings _ Array new: 8.	strings atAllPut:''.	initialOffset _ entry offset.	entry skip: 2. "Skip format selector"	"Get the number of name records"	nRecords _ entry nextUShort.	"Offset from the beginning of this table"	storageOffset _ entry nextUShort + initialOffset.	1 to: nRecords do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		lID _ entry nextUShort.		nID _ entry nextUShort.		length _ entry nextUShort.		offset _ entry nextUShort.		"Read only Macintosh or Microsoft strings"		(pID = 1 or:[pID = 3 and:[sID = 1]]) ifTrue:[			"MS uses Unicode all others single byte"			multiBytes _ pID = 3.			string _ entry stringAt: storageOffset + offset length: length multiByte: multiBytes.			"Put the name at the right location.			Note: We prefer Macintosh strings about everything else."			nID < strings size ifTrue:[				(pID = 1 or:[(strings at: nID+1) = ''])					ifTrue:[strings at: nID+1 put: string].			].		].	].	fontDescription setStrings: strings.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 22:18'!processSimpleGlyph: glyph contours: nContours from: entry	| endPts  nPts iLength flags |	endPts _ Array new: nContours.	1 to: nContours do:[:i| endPts at: i put: entry nextUShort].	glyph initializeContours: nContours with: endPts.	nPts _ endPts last + 1.	iLength _ entry nextUShort. "instruction length"	entry skip: iLength.	flags _ self getGlyphFlagsFrom: entry size: nPts.	self readGlyphXCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	self readGlyphYCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	glyph buildContours.! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getGlyphFlagsFrom: entry size: nPts	"Read in the flags for this glyph.  The outer loop gathers the flags that	are actually contained in the table.  If the repeat bit is set in a flag	then the next byte is read from the table; this is the number of times	to repeat the last flag.  The inner loop does this, incrementing the	outer loops index each time."	| flags index repCount flagBits |	flags _ ByteArray new: nPts.	index _ 1.	[index <= nPts] whileTrue:[		flagBits _ entry nextByte.		flags at: index put: flagBits.		(flagBits bitAnd: 8) = 8 ifTrue:[			repCount _ entry nextByte.			repCount timesRepeat:[				index _ index + 1.				flags at: index put: flagBits]].		index _ index + 1].	^flags! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getTableDirEntry: tagString from: fontData	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables _ fontData shortAt: 5 bigEndian: true.	tag _ ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag _ tag longAt: 1 bigEndian: true.	pos _ 13.	1 to: nTables do:[:i|		currentTag _ fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos _ pos+16].	^nil! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:36'!readGlyphXCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the x coordinates for the given glyph from the font file."	| startPoint endPoint flagBits xValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"If bit zero in the flag is set then this point is an on-curve			point, if not, then it is an off-curve point."			(flagBits bitAnd: 1) = 1 				ifTrue:[ ttPoint type: #OnCurve]				ifFalse:[ttPoint type: #OffCurve].			"First we check to see if bit one is set.  This would indicate that			the corresponding coordinate data in the table is 1 byte long.			If the bit is not set, then the coordinate data is 2 bytes long."			(flagBits bitAnd: 2) = 2 ifTrue:[ "one byte"				xValue _ entry nextByte.				xValue _ (flagBits bitAnd: 16)=16 ifTrue:[xValue] ifFalse:[xValue negated].				ttPoint x: xValue.			] ifFalse:[ "two byte"				"If bit four is set, then this coordinate is the same as the				last one, so the relative offset (of zero) is stored.  If bit				is not set, then read in two bytes and store it as a signed value."				(flagBits bitAnd: 16) = 16 ifTrue:[ ttPoint x: 0 ]				ifFalse:[					xValue _ entry nextShort.					ttPoint x: xValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:37'!readGlyphYCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the y coordinates for the given glyph from the font file."	| startPoint endPoint flagBits yValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"Check if this value one or two byte encoded"			(flagBits bitAnd: 4) = 4 ifTrue:[ "one byte"				yValue _ entry nextByte.				yValue _ (flagBits bitAnd: 32)=32 ifTrue:[yValue] ifFalse:[yValue negated].				ttPoint y: yValue.			] ifFalse:[ "two byte"				(flagBits bitAnd: 32) = 32 ifTrue:[ ttPoint y: 0 ]				ifFalse:[					yValue _ entry nextShort.					ttPoint y: yValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/1/1998 21:01'!warn: aString	Transcript cr; show: aString; endEntry.! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 11/2/1998 00:16'!initialize	"TTFontReader initialize"	WinToMacTable _ 		#(	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 			16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 			32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 			48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 			64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 			80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 			96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 			112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 			173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183 			184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217 			202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248 			161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 			203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 			245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167 			136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149 			253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216) collect:[:i| i+1].! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:43'!parseFileNamed: aString	"TTFontReader parseFileNamed:'c:\windows\arial.ttf'"	"TTFontReader parseFileNamed:'c:\windows\times.ttf'"	| contents |	contents _ (FileStream readOnlyFileNamed: aString) binary contentsOfEntireFile.	^self readFrom: (ReadStream on: contents)! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 00:53'!readFrom: aStream	^self new readFrom: aStream! !!TTFontTableDirEntry methodsFor: 'initialize-release'!on: fd at: index	fontData _ fd.	tag _ fontData longAt: index bigEndian: true.	checkSum _ fontData longAt: index+4 bigEndian: true.	offset _ (fontData longAt: index+8 bigEndian: true) + 1.	length _ fontData longAt: index+12 bigEndian: true.! !!TTFontTableDirEntry methodsFor: 'accessing'!nextByte	| value |	value _ fontData byteAt: offset.	offset _ offset + 1.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextBytes: numBytes into: array startingAt: byteOffset	1 to: numBytes do:[:i|		array at: i put: (fontData byteAt: byteOffset + i - 1)].! !!TTFontTableDirEntry methodsFor: 'accessing'!nextLong	| value |	value _ fontData longAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextShort	| value |	value _ fontData shortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextULong	| value |	value _ fontData unsignedLongAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextUShort	| value |	value _ fontData unsignedShortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!offset	^offset! !!TTFontTableDirEntry methodsFor: 'accessing'!offset: newOffset	offset _ newOffset! !!TTFontTableDirEntry methodsFor: 'accessing'!skip: n	"Skip n bytes"	offset _ offset + n.! !!TTFontTableDirEntry methodsFor: 'accessing' stamp: 'ar 11/1/1998 23:37'!stringAt: stringOffset length: byteLength multiByte: aBoolean	| string index stringLength |	aBoolean ifFalse:[		stringLength _ byteLength.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + i - 1))].		^string	] ifTrue:[		stringLength _ byteLength // 2.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + 1)).			index _ index + 2].		^string]! !!TTFontTableDirEntry class methodsFor: 'instance creation'!on: fontData at: index	^self new on: fontData at: index! !This class represents a glyph of a TrueType font.Instance variables:	bounds			<Rectangle>	The receiver's bounds	contours		<Array of: PointArray> The compressed contours in the receiver	advanceWidth	<Integer>	advance width of the glyph	leftSideBearing	<Integer>	left side bearing	rightSideBearing <Integer>	right side bearing	glyphIndex 		<Integer>	the original index of the glyph (used for kerning)!!TTGlyph methodsFor: 'initialize-release' stamp: 'ar 11/1/1998 22:25'!initialize	bounds _ 0@0 corner: 0@0.	contours _ #().	advanceWidth _ 0.	leftSideBearing _ 0.	rightSideBearing _ 0.! !!TTGlyph methodsFor: 'accessing'!advanceWidth	^advanceWidth! !!TTGlyph methodsFor: 'accessing'!advanceWidth: aNumber	advanceWidth _ aNumber.! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds	^bounds! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds: aRectangle	bounds _ aRectangle! !!TTGlyph methodsFor: 'accessing'!contours	^contours! !!TTGlyph methodsFor: 'accessing'!contours: aCollection	contours _ aCollection asArray.! !!TTGlyph methodsFor: 'accessing'!glyphIndex	^glyphIndex! !!TTGlyph methodsFor: 'accessing'!glyphIndex: anInteger	glyphIndex _ anInteger! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:26'!glyphsAndTransformationsDo: aBlock	aBlock value: self value: MatrixTransform2x3 identity! !!TTGlyph methodsFor: 'accessing'!leftSideBearing	^leftSideBearing! !!TTGlyph methodsFor: 'accessing'!leftSideBearing: aNumber	leftSideBearing _ aNumber.! !!TTGlyph methodsFor: 'accessing'!rightSideBearing	^rightSideBearing! !!TTGlyph methodsFor: 'accessing'!rightSideBearing: aNumber	rightSideBearing _ aNumber.! !!TTGlyph methodsFor: 'testing'!isComposite	^false! !!TTGlyph methodsFor: 'printing' stamp: 'ar 11/1/1998 22:03'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: contours size;		nextPut:$).! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:18'!buildContours	"Build the contours in the receiver glyph.	The contour is constructed by converting the points	form each contour into an absolute value and then	compressing the contours into PointArrays."	| tx ty points |	tx _ ty _ 0.	contours _ contours collect:[:contour|		points _ contour points.		points do:[:pt|			pt x: (tx _ tx + pt x).			pt y: (ty _ ty + pt y)].		contour asCompressedPoints].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:42'!initializeContours: numContours with: endPoints	"Initialize the contours for creation of the glyph."	| startPt pts endPt |	contours _ Array new: numContours.	startPt _ -1.	1 to: numContours do:[:i|		endPt _ endPoints at: i.		pts _ Array new: endPt - startPt.		1 to: pts size do:[:j| pts at: j put: TTPoint new].		contours at: i put: (TTContourConstruction on: pts).		startPt _ endPt].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:27'!updateRightSideBearing	"Update the right side bearing value"	"@@: Is the following really correct?!!?!!"	rightSideBearing _ advanceWidth - leftSideBearing - bounds corner x + bounds origin x! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:41'!display	| canvas |	canvas _ FormCanvas on: Display.	self contours do:[:ptArray|		1 to: ptArray size by: 3 do:[:i|			canvas line: (ptArray at: i) // 10					to: (ptArray at: i+2) // 10					width: 1 color: Color black.		].	].! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:22'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ self contours collect:[:contour| contour collect:[:pt| pt x @ pt y negated]].! !!TTGlyph class methodsFor: 'instance creation'!new	^super new initialize! !!TTKernPair methodsFor: 'accessing'!left	^left! !!TTKernPair methodsFor: 'accessing'!left: aNumber	left _ aNumber! !!TTKernPair methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:08'!mask	^mask ifNil:[mask _ self class maskFor: left with: right]! !!TTKernPair methodsFor: 'accessing'!right	^right! !!TTKernPair methodsFor: 'accessing'!right: aNumber	right _ aNumber! !!TTKernPair methodsFor: 'accessing'!value	^value! !!TTKernPair methodsFor: 'accessing'!value: aNumber	value _ aNumber! !!TTKernPair class methodsFor: 'accessing'!maskFor: left with: right	^(left bitShift: 12) + right! !!TTPoint methodsFor: 'accessing'!type	^type! !!TTPoint methodsFor: 'accessing'!type: aSymbol	type _ aSymbol! !!TTPoint methodsFor: 'accessing'!x	^x! !!TTPoint methodsFor: 'accessing'!x: aNumber	x _ aNumber! !!TTPoint methodsFor: 'accessing'!y	^y! !!TTPoint methodsFor: 'accessing'!y: aNumber	y _ aNumber! !!TTPoint methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: x;		nextPut:$@;		print: y;		nextPut:$|;		print: type;		nextPut:$)! !!TTPoint methodsFor: 'converting'!asPoint	^x@y! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:26'!initialize	super initialize.	borderWidth _ 1.	borderColor _ Color black.	color _ Color black.	smoothing _ 4.	self extent: 300@300.! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/14/1998 23:50'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 03:16'!openInWorld	Smalltalk isMorphic ifFalse:[^self openInMVC].	World primaryHand attachMorph: self! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:32'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box center color: Color magenta on: #mouseDown send: #createSample to: self.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:39'!balloonHelpTextForHandle: aHandle	aHandle eventHandler firstMouseSelector == #createSample		ifTrue:[^'Create a sample string'].	^super balloonHelpTextForHandle: aHandle! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!doesBevels	^false! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:31'!font: aTTFontDescription	| morph |	font _ aTTFontDescription.	morph _ (TTSampleStringMorph font: font).	morph extent: morph extent * 2.	morph color: Color magenta.	self addMorphCentered: morph.	morph position: morph position x @ (self bounds bottom + 10).	self privateFullMoveBy: self fullBounds origin negated.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 22:42'!newTransformationMorph	^MatrixTransformMorph new! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing	^smoothing ifNil:[1]! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing: aNumber	smoothing _ aNumber! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:53'!transform	^transform ifNil:[self computeTransform].! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!extent: extentPoint	super extent: extentPoint.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!position: pos	super position: pos.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/14/1998 23:12'!areasRemainingToFill: aRectangle	^ Array with: aRectangle! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:48'!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do:[:i|		glyph _ font at: i.		origin _ font bounds extent * ((i \\ 16) @ (i // 16)).		r _ origin extent: font bounds extent.		offset _ r center - glyph bounds center.		cy _ glyph bounds center y.		m _ MatrixTransform2x3 withOffset: 0@cy.		m _ m composedWithLocal: (MatrixTransform2x3 withScale: 1@-1).		m _ m composedWithLocal: (MatrixTransform2x3 withOffset: 0@cy negated).		m _ m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|			balloonCanvas transformBy: m.			balloonCanvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 1					borderColor: Color black.		].	].! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:49'!drawOn: aCanvas	| origin extent offset |	(font isNil) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	origin _ self position asIntegerPoint.	extent _ self extent asIntegerPoint.	0 to: 16 do:[:i|		offset _ (extent x * i // 16) @ (extent y * i // 16).		aCanvas line: origin x @ (origin y + offset y) 				to: (origin x + extent x) @ (origin y + offset y)				width: borderWidth color: borderColor.		aCanvas line: (origin x + offset x) @ origin y 				to: (origin x + offset x) @ (origin y + extent y)				width: borderWidth color: borderColor.	].	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		balloonCanvas aaLevel: self smoothing.		self drawCharactersOn: balloonCanvas.	].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self smoothing = 1 		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self smoothing = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self smoothing = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 23:46'!createSample	self world primaryHand attachMorph: (TTSampleStringMorph font: font)! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingMore	smoothing _ 4.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOff	smoothing _ 1.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOn	smoothing _ 2.	self changed! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 01:06'!changed	self invalidRect: (self fullBounds insetBy: -1@-1)! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 22:48'!computeTransform	| fullExtent scale |	fullExtent _ font bounds extent * 16.	scale _ self extent asFloatPoint / fullExtent asFloatPoint.	transform _ MatrixTransform2x3 withScale: scale.	transform _ transform composedWithGlobal: (MatrixTransform2x3 withOffset: self position).	^transform! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:55'!privateMoveBy: delta	super privateMoveBy: delta.	transform _ nil.! !!TTSampleFontMorph class methodsFor: 'instance creation' stamp: 'ar 11/14/1998 23:06'!font: aTTFontDescription	^self new font: aTTFontDescription! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:27'!initialize	super initialize.	borderWidth _ 0.	borderColor _ Color black.	color _ {Color magenta. Color yellow. Color orange. Color lightGray} atRandom.	smoothing _ 4.! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 00:30'!initializeString	| xStart char glyph |	(font isNil or:[string isNil]) ifTrue:[^self].	xStart _ 0.	ttBounds _ 0@0 corner: 0@0.	1 to: string size do:[:i|		char _ string at: i.		glyph _ (font at: char).		ttBounds _ ttBounds merge: (glyph bounds translateBy: xStart@0).		xStart _ xStart + glyph advanceWidth.	].	self extent: ttBounds extent // 40.	borderWidth _ ttBounds height // 40.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:44'!addOptionalHandlesTo: aHalo box: box! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:10'!font: aTTFontDescription	font _ aTTFontDescription.	self string: aTTFontDescription fullName.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:53'!string: aString	string _ aString.	self initializeString.! !!TTSampleStringMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:51'!drawOn: aCanvas	| xStart glyph |	(font isNil or:[string isNil or:[string isEmpty]]) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	xStart _ 0.	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		balloonCanvas aaLevel: self smoothing.		string do:[:char|			glyph _ font at: char.			balloonCanvas preserveStateDuring:[:subCanvas|				subCanvas transformBy: (MatrixTransform2x3 withOffset: xStart@0).				subCanvas 					drawGeneralBezierShape: glyph contours					color: color 					borderWidth: borderWidth 					borderColor: borderColor].			xStart _ xStart + glyph advanceWidth.		].	].! !!TTSampleStringMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:04'!computeTransform	| cy |	cy _ bounds origin y + bounds corner y * 0.5.	transform _ MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy negated).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0@-1.0).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy).	^transform! !!TVariableNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:09'!bindVariableUsesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^ newNode copyTree! !!TVariableNode methodsFor: 'all'!setName: aString	name _ aString.! !A tab in a palette.  The contents is the name to be shown.  If it represents a book, that book is pointed to in my morphToInstall.!!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:28'!morphToInstall	^ morphToInstall! !!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:38'!morphToInstall: m	morphToInstall _ m.	self contents: m externalName.	self actionSelector: #tabSelected.	self target: self! !!TabMorph methodsFor: 'all' stamp: 'sw 7/3/1998 11:42'!representsBook	^ morphToInstall ~~ nil! !!TabMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:59'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be a TabbedPalette"	self player ifNotNil: [self player runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:39'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.morphToInstall _ deepCopier references at: morphToInstall ifAbsent: [morphToInstall].! !!TabMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:39'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.morphToInstall _ morphToInstall.		"Weakly copied"! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/2/1998 16:48'!defaultNameStemForInstances	^ 'tab'! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/3/1998 11:49'!forBook: aBook	^ self new morphToInstall: aBook! !A sorter for the tabs of a TabbedPalette!!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:05'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ TabMorph forBook: m].		(m isKindOf: TabTokenMorph) ifTrue:			[toAdd _ m tabRepresented contents: m contents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 15:24'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #cancelSort).	self addMorphFront: r.! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:06'!cancelSort	| oldOwner |	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 18:51'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder _ PasteUpMorph new.	pageHolder resizeToFit: true; autoLineLayout: true; fixLayout; layoutChanged.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:57'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs _ aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect:			[:aTab | TabTokenMorph new forTab: aTab]).	self position: aTabbedPalette position.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:30'!substituteForMorph: aMorph beingDroppedOn: aPage	(aMorph isKindOf: BookMorph) ifFalse: [^ nil].	^ TabTokenMorph new forTab: (TabMorph new morphToInstall: aMorph)! !An element of a TabSorter.!!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:02'!forTab: aTab	tabRepresented _ aTab.	self contents: aTab contents! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:51'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	super justDroppedInto: aMorph event: anEvent.	self world ifNotNil: [self world abandonAllHalos]! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:03'!tabRepresented	^ tabRepresented! !!TabTokenMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:42'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.tabRepresented _ deepCopier references at: tabRepresented ifAbsent: [tabRepresented].! !!TabTokenMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.tabRepresented _ tabRepresented.		"Weakly copied"! !A structure of tabs and associated books.  Pressing a tab brings into focus the associated book.  Some tabs can have simple actions rather than books as their focus -- in this case, the palette is cleared and the action taken. !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 17:52'!addTabForBook: aBook	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	^ aTab! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 10/29/1998 17:35'!addTabForBook: aBook withBalloonText: text	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	text ifNotNil: [aTab setBalloonText: text].	^ aTab! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:19'!addTabNamed: str color: aColor atIndex: anIndex	| aBook |	aBook _ BookMorph new setNameTo: str.	aBook color: aColor.	self addTabForBook: aBook! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:05'!defaultPageSize	^ 156 @ 232! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:10'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	color _ Color r: 0.0 g: 0.6 b: 0.6.  "background for menu bar, primarily"	borderWidth _ 1.	tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 14:57'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 |	pages _ pages species new.	tabsMorph ifNotNil:		[color1 _ tabsMorph  highlightColor.		color2 _ tabsMorph regularColor.		tabsMorph delete].	tabsMorph _ IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2].	currentPage ifNotNil:		[currentPage delete.		currentPage _ nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			(itsBook _ aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage _ itsBook]]].! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 9/14/97 01:12'!setInitialState	super setInitialState.	inset _ 0.	pageSize _ 156 @ 232! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:37'!addControlsTab	| controlWrapper controlPage |	controlPage _ AlignmentMorph newColumn beSticky color: Color white.	controlWrapper _ AlignmentMorph newRow beSticky vResizing: #spaceFill; color: Color white.	controlWrapper centering: #center.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlWrapper addMorphBack: self presenter controlPanel beSticky.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlPage addMorphBack: controlWrapper.	controlPage addMorphBack: (Morph new beTransparent extent: (1 @ 10)).	controlPage addMorphBack: RecordingControlsMorph newSticky.	controlPage setNameTo: 'Controls'.	self addTabForBook: controlPage  withBalloonText:'recording controls, andcontrols to turn sound,balloon help, etc., on and off'! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:39'!addPartsTab	| partsBook aPage |	partsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Supplies'.	partsBook removeEverything.	aPage _ self presenter newPageForStandardPartsBin.	aPage extent: pageSize.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph   StringMorph) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	partsBook insertPage: aPage pageSize: pageSize.	self addTabForBook: partsBook withBalloonText: 'parts bin'! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 11/7/1998 22:49'!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Scraps'.	scrapsBook removeEverything; showPageControls; insertPage.	scrapsBook currentPage addMorph: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook  withBalloonText: 'a storage place for anything; also, objects dragged into the trash can will be found here.'.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 18:13'!addToTrash: aMorph	"Paste the object onto a page of my Scraps tab. This is only called in situations where a presenter has a standard palette specified."	| aPage aBook |	self hasScrapsTab ifFalse:		[self addScrapsTab].	aBook _ self scrapsBook.	aMorph position: aBook pages first position + (0@40).	aBook pages do: [:pp | 		(pp submorphs size = 1 and: [pp hasProperty: #trash]) ifTrue:  "perhaps remove that property here"			["page is blank"			^ pp addMorph: aMorph]].	aPage _ aBook insertPageLabel: 'From Trash Can:'		morphs: (Array with: aMorph).	aPage setProperty: #trash toValue: true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:36'!hasScrapsTab	pages detect: [:p | (p hasProperty: #scraps)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:42'!scrapsBook	^ pages detect: [:p | p hasProperty: #scraps] ifNone: [nil]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 11/7/1998 22:53'!addViewerTab	| viewerBook |	"A now disused branch, though it may be invoked in some grandfathered palettes"	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 6/16/1998 16:02'!hasViewerTab	pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/30/1998 18:35'!oldViewMorph: aMorph	"View the morph using the old type of viewer."	| aPlayer currentViewer viewerBook |	self hasViewerTab ifFalse:		[self addViewerTab].	self visible: false.	aPlayer _ aMorph assuredPlayer.	viewerBook _ self viewerBook.  "Just to make this code easier to read"	(currentViewer _ viewerBook currentPage)		ifNil:			[currentViewer _ viewerBook setPlayer: aPlayer]		ifNotNil:			[currentViewer scriptedPlayer == aPlayer				ifFalse:					[currentViewer setPlayer: aPlayer]				ifTrue:					[currentViewer isInWorld ifFalse: [self halt]]].	"currentViewer makeAllTilesGreen. "  "yecch; overkill"	 "This stuff is generally still weird and objectionable, but since the PartsViewer path is being abandoned, to hell with it. "	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self selectViewerTab.	self snapToEdgeIfAppropriate.	self visible: true.	currentViewer visible: true"	self layoutChanged.	self ownerChanged.	self world displayWorld"! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:45'!selectViewerTab	| viewerTab |	(viewerTab _ self viewerTab) ifNil: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/25/1998 22:37'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer |	Preferences useNewViewers ifFalse: [^ self oldViewMorph: aMorph].	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	self visible: false.	aPlayer _ aMorph assuredPlayer.	aViewer _  StandardViewer new initializeFor: aPlayer.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage _ aViewer).	self snapToEdgeIfAppropriate..	self world startSteppingSubmorphsOf: aViewer.	self visible: true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'tk 8/3/1998 15:56'!viewerBook	^ pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [nil]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:44'!viewerTab	^ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [nil]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:12'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	self hasMenuTab		ifFalse:			[aCustomMenu add: 'add palette menu' action: #addMenuTab].	aCustomMenu add: 'become the Standard palette' action: #becomeStandardPalette! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/7/1998 22:50'!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		setBalloonText: 'menu';		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 9/11/1998 16:02'!addScriptableTab	^ self addScriptableTabWithTitle: 'aTab'! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 8/30/1998 09:11'!addScriptableTabWithTitle: aTitle	| aTab |	aTab _ tabsMorph addActionTabWithTitle: aTitle.	aTab actionSelector: #tabSelected; target: aTab.	^ aTab! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:11'!hasMenuTab	^ self hasSubmorphWithProperty: #tabsMenu! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/11/1998 14:42'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette		ifNotNil:			[aMenu add:  'clear' action: #showNoPalette.			aMenu addLine]		ifNil:			[submorphs size > 1				ifTrue: 					[aMenu add: 'clear!!' action: #showNoPalette.					aMenu addLine]].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 6/16/1998 16:17'!becomeStandardPalette	self presenter standardPalette: self! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/4/1998 14:12'!recolorTabs	"Prompt the user for new on and off colors for tabs"	| onColor offColor |	self inform: 'Choose the ''on'' color'.	onColor _ Color fromUser.	self inform: 'Okay, now please choosethe ''off'' color'.	offColor _ Color fromUser.	tabsMorph highlightColor: onColor regularColor: offColor.	currentPage ifNotNil:		[tabsMorph highlightTabFor: currentPage]! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 11/11/1998 14:02'!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	submorphs size > 1 ifTrue: "spurious submorphs, yecch"		[(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]].	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	"self snapToEdgeIfAppropriate"! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/3/1998 18:17'!sortTabs: evt	TabSorterMorph new sortTabsFor: self.  "it directly replaces me"	self delete! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 1/11/1999 20:08'!repelsMorph: aMorph event: ev	self visible ifFalse: [^ false].	^ openToDragNDrop not! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/19/1998 23:53'!selectTab: aTab	| currentPalette |	(currentPage notNil and: [(currentPage hasProperty: #placeHolder) not]) ifTrue:		[self currentPalette currentPlayerDo:			[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate.! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!selectTabNamed: aName	"For bkwrd compat with etoys"	| aTab |	aTab _ self tabMorphs detect: [:m | m contents = aName] ifNone: [nil].	aTab ifNil: [self error: 'tab not found'].	tabsMorph selectTab: aTab! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:40'!selectTabOfBook: aBook	self tabMorphs do:		[:aTab | aTab morphToInstall == aBook ifTrue: [^ self selectTab: aTab]]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!tabMorphs	^ tabsMorph tabMorphs! !!TabbedPalette methodsFor: 'user-interface' stamp: 'di 9/30/1998 10:39'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 6/23/1998 12:31'!currentPalette	"A stylistic convenience to reduce confusion caused by the fact that a palette is a book of books"	^ currentPage! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'tk 8/3/1998 22:30'!releaseCachedState	| vv |	(vv _ self viewerBook) ifNotNil: [		(self currentPage ~~ vv) ifTrue: [vv removeEverything]].	super releaseCachedState! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result _ super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'jm 11/16/97 17:59'!tabsMorph	^ tabsMorph! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 10/16/1998 11:30'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 200 @ 300.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 6/3/1998 21:27'!defaultNameStemForInstances	^ 'tabbedPalette'! !!TempVariableNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:06'!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color green)			do: [aStream nextPutAll: name]! !!TempoEvent methodsFor: 'all' stamp: 'jm 9/10/1998 08:37'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': tempo '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !!TestCClass1 methodsFor: 'all' stamp: 'jm 11/25/1998 18:09'!method9	"Test conditional code generation."	true ifTrue: [^ 1].	false ifTrue: [^ 'should not be generated'].	true ifFalse: [^ 'should not be generated'].	false ifFalse: [^ 2].	true ifTrue: [^ 3] ifFalse: [^ 'should not be generated'].	false ifTrue: [^ 'should not be generated'] ifFalse: [^ 4].	true ifFalse: [^ 'should not be generated'] ifTrue: [^ 5].	false ifFalse: [^ 6] ifTrue: [^ 'should not be generated'].! !!Text methodsFor: 'accessing' stamp: 'ls 7/29/1998 01:17'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs withStartStopAndValueDo: [ :start :stop :attribs | attribs do: [ :attrib |		(attrib isKindOf: TextAnchor) ifTrue: [  morphs add: attrib anchoredMorph ] ] ].	^morphs select: [ :m | m isKindOf: Morph ]! !!Text methodsFor: 'accessing' stamp: 'di 11/23/1998 11:53'!findString: aString startingAt: start caseSensitive: caseSensitive	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start caseSensitive: caseSensitive! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asUrl	^self asString asUrl! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!Text methodsFor: 'emphasis' stamp: 'ls 7/4/1998 16:13'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle fontAt: 1].	"null text tolerates access"	attributes _ runs at: characterIndex.	font _ aTextStyle fontAt: 1.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font	! !!TextAnchor methodsFor: 'all' stamp: 'di 7/1/1998 14:35'!= other 	^ (other class == self class) 		and: [other anchoredMorph == anchoredMorph]! !Tells a piece of text to be a certain way.Select text, press Command-6, choose a attribute.  If selected text is of the form 	Hi There<Smalltalk beep>the part in angle brackets is saved for action, and the Hi There appears in the paragraph.  If selection has no angle brackets, use the whole thing as both the text and the action.TextDoIt  --  eval as a Smalltalk expression (the part in angle brackets)TextLink -- Show a method, class comment, class hierarchy, or class defintion.	<Point extent:>, <Point Comment>, <Point Hierarchy>, or <Point Defintion> are what you type.TextURL -- Show the web page. <www.disney.com>These attributes of text need to be stored on the disk in a regular file-out.  It is done in this form: 	(ascii 2)<!!do Smalltalk beep(ascii 3)>Hi There(ascii 3)<!!>	(ascii 2)<!!li Point extent:(ascii 3)>Click here to see the extent: method(ascii 3)<!!>The brackets are for people to see in fileOuts.  The wierd ascii are for the scanner to pick up easily.  See RunArray class scanFrom: where decoding is done.!]style[(993 24 25)f1,f1LRunArray class scanFrom:;,f1!!TextContainer methodsFor: 'container protocol' stamp: 'di 9/30/1998 23:17'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	self shadowForm.  "Compute the shape".	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:24'!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText _ textMorph meOrMyDropShadow.	bounds _ theText owner bounds.	theText owner submorphsBehind: theText do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:21'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fillsOwner		ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: canvas]		ifFalse: [canvas fillRectangle: textMorph bounds color: Color black].	self avoidsOcclusions ifTrue:		[back _ canvas form deepCopy.		canvas form fillWhite.		theText owner submorphsInFrontOf: theText do:			[:m | (textMorph isLinkedTo: m)				ifTrue: []				ifFalse: [m fullDrawOn: canvas]].		back displayOn: canvas form at: 0@0 rule: Form reverse].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line; cr].	].	! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17'!destString: aString	realDst := self split: aString asString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!from: sourceString to: destString	self sourceString: sourceString.	self destString: destString.! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17'!sourceString: aString	realSrc := self split: aString asString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!split: aString	^self split: aString by: self splitCharacter! !!TextDiffBuilder methodsFor: 'testing'!hasMultipleMatches	^multipleMatches == true! !!TextDiffBuilder methodsFor: 'creating patches'!buildDisplayPatch	^Text streamContents:[:stream|		self printPatchSequence: self buildPatchSequence on: stream.	]! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:35'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht fr n-m matches"	matches := PluggableDictionary new.	matches hashBlock: self pointHashBlock.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:57'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index@index2 put: line]	].	srcLines doWithIndex:[:line :index|		(dstPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index2@index put: line]	].! !!TextDiffBuilder methodsFor: 'creating patches'!collectRunFrom: todo startingWith: startIndex into: run	| next start |	start := startIndex.	self remove: start from: todo.	run add: (matches at: start).	"Search downwards"	next := start.	[next := next + (1@1).	todo includes: next] whileTrue:[		run addLast: (matches at: next).		self remove: next from: todo].	"Search upwards"	next := start.	[next := next - (1@1).	todo includes: next] whileTrue:[		run addFirst: (matches at: next).		self remove: next from: todo.		start := next. "To use the first index"	].	^start! !!TextDiffBuilder methodsFor: 'creating patches'!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns _ OrderedCollection new.	sortedRuns _ SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY _ sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run _ sortedRuns at: i.		run key y > lastY			ifTrue: [lastY _ run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!TextDiffBuilder methodsFor: 'creating patches'!generatePatchSequence	| ps |	ps := OrderedCollection new: srcLines size.	srcLines size timesRepeat:[ps add: nil].	self incorporateMatchesInto: ps.	self incorporateRemovalsInto: ps.	self incorporateAddsInto: ps.	^ps! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value beforeIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateMatchesInto: aPatchSequence	"Incorporate matches"	| index |	runs associationsDo:[:assoc|		index := assoc key y.		assoc value do:[:line|			self assert:[(aPatchSequence at: index) isNil].			aPatchSequence at: index put: (#match -> line).			index := index + 1.		].	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateRemovalsInto: aPatchSequence	"Incorporate removals"	| index |	removed ifNil:[^self].	removed do:[:assoc|		index := assoc key.		self assert:[(aPatchSequence at: index) isNil].		aPatchSequence at: index put: #remove -> assoc value.	].! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonals	^self processDiagonalsFrom: matches keys asSet! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:34'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := PluggableDictionary new.	runList hashBlock: self pointHashBlock.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches'!processShiftedRuns	| key |	shifted isNil ifTrue:[^self].	shifted do:[:assoc|		key := assoc key.		assoc value doWithIndex:[:line :idx|			removed add: (key y + idx - 1) -> line.			added add: (key x + idx - 1) -> line].		runs removeKey: assoc key.	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy _ srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy _ dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private'!assert: aBlock	aBlock value ifFalse:[self error: 'Assertion failed']! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:35'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:31'!remove: pointKey from: aSet	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	aSet copy do:[:obj|		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26'!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index _ 1.	[index <= aString size] whileTrue:[		nextIndex _ aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index _ nextIndex+1].	^lines! !!TextDiffBuilder methodsFor: 'private'!splitCharacter	^Character cr! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/24/1998 13:41'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]] fixTemps! !!TextDiffBuilder class methodsFor: 'instance creation'!buildDisplayPatchFrom: srcString to: dstString	^(self from: srcString to: dstString) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation'!from: srcString to: dstString	^self new from: srcString to: dstString! !create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount	"number of tab spaces to indent by"	^amount! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:54'!tabs: numTabs	"create an indentation by the given number of tabs"	^self amount: numTabs! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text _ 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg _ text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !a textual input; it takes text input straight from the user via a PluggableText!!TextInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 04:01'!name: name0  defaultValue: defaultValue0  textMorph: textMorph0	name _ name0.	defaultValue _ defaultValue0.	textMorph _ textMorph0.! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:34'!name	^name! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 09:02'!reset	textMorph setText: defaultValue! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/6/1998 09:31'!value	textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].	^textMorph getText withInternetLineEndings! !!TextInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:23'!name: name0  defaultValue: defaultValue  textMorph: textMorph	^self new name: name0  defaultValue: defaultValue  textMorph: textMorph	! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 6/30/1998 22:03'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !!TextMorph methodsFor: 'accessing' stamp: 'di 10/5/1998 13:56'!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'accessing' stamp: 'ls 9/15/1998 19:36'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@-1000)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self world ifNotNil: [ 		self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:58'!userString	"Do I have a text string to be searched on?"	^ text string! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 12:37'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseEmphasis	self editor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseFont	self editor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:59'!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection"	"Also couple ParagraphEditor to Morphic keyboard events"	self editor sensor: (KeyboardBuffer new startingEvent: evt).	self selectionChanged.  "Note old selection"		interactionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'di 8/11/1998 13:04'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 14:02'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self editor "Forces install"]]		ifFalse: ["A hand has clicked elsewhere..."				w _ self world.				(w notNil and: 					[(w hands collect: [:h | h keyboardFocus]) includes: self])					ifFalse: ["Release control unless some hand is still holding on"							self releaseEditor]].! !!TextMorph methodsFor: 'editing' stamp: 'di 10/6/1998 10:32'!passKeyboardFocusTo: otherMorph	| w |	(w _ self world) ifNotNil: 		[w hands do:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 23:46'!bounds	container ifNil: [^ bounds].	^ container bounds ifNil: [bounds]! !!TextMorph methodsFor: 'geometry' stamp: 'di 1/13/1999 14:11'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^false].	self startingIndex > text size ifTrue:		["make null text frame visible"		^ super containsPoint: aPoint].	^ self paragraph containsPoint: aPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 8/14/1998 15:50'!defaultLineHeight	^ textStyle lineGrid! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/9/1998 15:50'!privateMoveBy: delta	self releaseEditor.	super privateMoveBy: delta.	paragraph ifNotNil: [paragraph moveBy: delta].! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 14:22'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	outer _ self meOrMyDropShadow owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'sw 6/15/1998 15:13'!addOptionalHandlesTo: aHalo box: box	self addFontHandlesTo: aHalo box: box! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 23:40'!followCurve	self setContainer: (TextOnCurveContainer new baseline: 0; textDirection: 1).	self changed! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 13:53'!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 17:04'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'di 10/8/1998 14:23'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: self meOrMyDropShadow owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 16:39'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 10/6/1998 11:22'!updateFromParagraph  	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 14:17'!meOrMyDropShadow	^ (owner isKindOf: DropShadowMorph)			ifTrue: [owner]			ifFalse: [self]! !!TextMorph methodsFor: 'containment' stamp: 'sw 6/25/1998 10:44'!ownerChanged	super ownerChanged.	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 23:20'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [newOwner isWorldOrHandMorph ifTrue: [self setContainer: nil]]! !!TextMorph methodsFor: 'containment' stamp: 'sw 12/16/1998 09:09'!recognizerArena	"Answer the rectangular area, in world coordinates, that the character recognizer should regard as its tablet"	| outer |	^ (outer _ self ownerThatIsA: PluggableTextMorph)		ifNotNil:			[outer boundsInWorld]		ifNil:			[self boundsInWorld]! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!TextMorph methodsFor: 'anchors' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphFront: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld globalPointToLocal: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TextMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:49'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.container _ deepCopier references at: container ifAbsent: [container]."Caller beware: it makes no sense to share pointers to existing predecessor and successor"predecessor _ deepCopier references at: predecessor ifAbsent: [nil].successor _ deepCopier references at: successor ifAbsent: [nil].! !!TextMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:47'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.textStyle _ textStyle veryDeepCopyWith: deepCopier.text _ text veryDeepCopyWith: deepCopier.wrapFlag _ wrapFlag veryDeepCopyWith: deepCopier.paragraph _ paragraph veryDeepCopyWith: deepCopier.editor _ editor veryDeepCopyWith: deepCopier."container _ container.		Weakly copied""predecessor _ predecessor.		All weakly copied"successor _ successor.		"All weakly copied"        ! !!TextMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 17:16'!authoringPrototype	| t |	t _ super authoringPrototype."Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 1/13/1999 07:53'!morph	^ morph! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 1/13/1999 07:53'!morph: aMorph	"Install a link back to the morph being edited (esp for text links)"	morph _ aMorph ! !!TextMorphEditor methodsFor: 'events' stamp: 'tk 1/12/1999 11:17'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		evt hand newKeyboardFocus: nil.		^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:11'!readKeyboard	super readKeyboard.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'sw 12/16/1998 08:55'!recognizeCharacters	"Recognize hand-written characters and put them into the receiving pane.  Invokes Alan's character recognizer."	self recognizeCharactersWhileMouseIn: morph recognizerArena! !!TextMorphEditor methodsFor: 'events' stamp: 'sw 12/16/1998 13:18'!recognizeCharactersWhileMouseIn: box	"Recognize hand-written characters and put them into the receiving TextMorph.  Invokes Alan's character recognizer.  box is in world coordinates."	| aRecognizer |	Cursor marker showWhile:		[aRecognizer _ CharRecog new textMorph: morph.		aRecognizer recognizeAndDispatch:			[:char | morph handleInteraction:				[char == BS					ifTrue:						[self simulatedBackspace]					ifFalse:						[self simulatedKeystroke: char]] fromEvent: nil.			morph updateFromParagraph.			morph world doOneCycle]		until:			[(box containsPoint: Sensor cursorPoint) not]]! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/9/1998 16:55'!cancel	"Cancel the changes made so far to this text"	morph cancelEdits! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'tk 1/13/1999 08:40'!changeEmphasis: characterStream 	"Intercept requests to create a link (Cmd-6).  Make them simpler for end-user editing.  SystemWidows use ParagraphEditor's complex commands."	| keyCode attribute index colors aPageName target book theSelection url newPage labels |	"Test if it's really the droids we're looking for..."	keyCode _ ('0123456789-=' indexOf: sensor keyboardPeek ifAbsent: [1]) - 1.	keyCode ~= 6 ifTrue: [^ super changeEmphasis: characterStream].		"underline, bold, etc."	(morph isKindOf: TextMorphForEditView) ifTrue: [		^ super changeEmphasis: characterStream].	"if in a browser, show all choices"	sensor keyboard.  "Yes, it is Cmd-6;  consume the command character"	theSelection _ self selection.	colors _ #(black magenta red yellow green blue cyan white).	labels _ colors, #(active).	(book _ morph ownerThatIsA: BookMorph) ifNotNil: [		labels _ labels, #('link to')].	index _ (PopUpMenu labelArray: labels							lines: (Array with: colors size)) startUp.	index = 0 ifTrue: [^ true].	index <= colors size ifTrue:		[attribute _ TextColor color: (Color perform: (colors at: index))].	index = (colors size + 1) ifTrue:		[attribute _ TextDoIt new.		theSelection _ attribute analyze: self selection asString].	index = (colors size + 2) ifTrue:	"Link to a new page, possibly create it"		["target page must be in memory"		aPageName _ self selection asString.		target _ book pageNamed: aPageName.	"later don't bring in all pages!!"		"later offer correction"		target ifNotNil: [url _ target url.			url ifNil: [self inform: 'You must send the target page to a server.'.  ^ true].			attribute _ TextSqkPageLink new. 			theSelection _ attribute analyze: self selection asString,'<',url,'>'].		target ifNil: ["add page at end"			(book valueOfProperty: #keepTogether) 				ifNotNil: [self inform: 'For now, can''t link in book whose pages must be kept together'.  ^ true].			newPage _ book insertPageSilentlyAtEnd.			newPage setNameTo: theSelection asString.			book saveOnUrlPage: newPage.	"write it on the server"			attribute _ TextSqkPageLink new. 			theSelection _ attribute analyze: 				self selection asString,'<', newPage url,'>'].		].	self replaceSelectionWith: (theSelection asText addAttribute: attribute).	^ true! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/5/1998 21:48'!find	super find.	morph installEditorToReplace: self! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'sw 10/18/1998 10:17'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	morph tempCommand.	^ true! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/14/1998 13:12'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 10/6/1998 00:02'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextMorphEditor methodsFor: 'binding' stamp: 'ls 7/24/1998 21:06'!bindingOf: aString	^model bindingOf: aString! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 11/10/1998 10:13'!flash	^ editView flash! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 10/5/1998 14:03'!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self editor model: editView model.  "For evaluateSelection, etc"	^ super handleInteraction: interActionBlock fromEvent: evt! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:43'!initialize	super initialize.	acceptOnCR _ false! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:49'!keyStroke: evt	| view |	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/30/1998 08:50'!mouseDown: event	event yellowButtonPressed ifTrue: [^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextMorphForEditView methodsFor: 'debugging' stamp: 'sw 11/2/1998 15:51'!tempCommand	"Smalltalk browseAllImplementorsOf: #tempCommand"	"Place your definition for tempCommand for this class here"! !!TextMorphForEditView methodsFor: 'object fileIn' stamp: 'tk 11/27/1998 20:33'!convertbosfcettwpecpse0: varDict bosfcettwpecpsea0: smartRefStrm	"These variables are automatically stored into the new instance ('editView' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('acceptOnCR' ) and deal with the information in ()"	acceptOnCR _ false.! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !I represent a link to either a SqueakPage in a BookMorph, or a regular url.  See TextMorphEditor changeEmphasis:.  !]style[(81 31 4)f1,f1LTextMorphEditor changeEmphasis:;,f1!!TextSqkPageLink methodsFor: 'as yet unclassified' stamp: 'tk 1/12/1999 12:56'!actOnClickFor: textMorph	"I represent a link to either a SqueakPage in a BookMorph, or a regular url"	| book |	((url endsWith: '.bo') or: [url endsWith: '.sp']) ifFalse: [		^ super actOnClickFor: textMorph].	book _ textMorph ownerThatIsA: BookMorph.	book ifNotNil: [book goToPageUrl: url].	"later handle case of page being in another book, not this one"	^ true! !!TextSqkPageLink methodsFor: 'as yet unclassified' stamp: 'tk 1/13/1999 08:14'!writeScanOn: strm	strm nextPut: $q; nextPutAll: url; nextPut: $;! !!TextStyle methodsFor: 'accessing' stamp: 'tk 6/26/1998 15:03'!fontNamesAndSizes  "TextStyle default fontNames"	^ fontArray collect: [:x | x name, ' ', x height printString]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 6/26/1998 15:58'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.	"Only works if file created by special code above"	newName _ this fontArray first name.	this fontArray do: [:aFont | aFont name = newName ifFalse: [		self error: 'All must be same family']].	style _ TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights _ style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 1/8/1999 07:45'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	#veryDeepCopyWith:.	"to satisfy checkVariables"	^ deepCopier references at: self ifAbsent: [		deepCopier references at: self put: self clone].	"remember"! !!TextURL methodsFor: 'as yet unclassified' stamp: 'di 9/19/1998 16:19'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m browser | 		"if it's a web browser, tell it to jump"		anObject isWebBrowser ifTrue: [			anObject jumpToUrl: url.			^true ].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m _ anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [ 					m  jumpToUrl: url.  					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m _ m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	(self confirm: 'open a browser to view this URL?') ifTrue: [		browser _ Scamper new.		browser jumpToUrl: url.		browser openAsMorph.		^ true ].		"couldn't display in a browser.  Offer to put up just the source"		response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Couldn''t find a web browser.  View page as source?'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'sw 11/11/1998 15:01'!printOn: aStream	| string |	aStream nextPutAll: '3PButton'.	arguments size > 0 ifTrue: [string _ arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	(string ~~ nil and: [string ~~ self])		ifTrue:			[aStream print: string; space]		ifFalse:			[aStream print: actionSelector; space].	aStream print: self identityHash;			nextPutAll: ')'.! !!ThreePhaseButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:02'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!ThreePhaseButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:01'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.offImage _ offImage veryDeepCopyWith: deepCopier.pressedImage _ pressedImage veryDeepCopyWith: deepCopier.state _ state veryDeepCopyWith: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		Symbol""arguments _ arguments.		Weakly copied"actWhen _ actWhen.		"Symbol"! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/24/1998 17:05'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	actualViewee isInWorld		ifTrue:			[(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].			(actualViewee isKindOf: SketchMorph)				ifTrue:					[diag _ actualViewee form extent r asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds].			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c _ c copyOffset: viewedMorphBox topLeft negated.			actualViewee fullDrawOn: c.		"recursion happens here"			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter]! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/15/1998 15:18'!tearOffTile	(objectToView isKindOf: Player) ifTrue: [^ objectToView tearOffTileForSelf].	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[objectToView costume]! !!ThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.objectToView _ deepCopier references at: objectToView ifAbsent: [objectToView].! !!ThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:56'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."objectToView _ objectToView.		Weakly copied"viewSelector _ viewSelector veryDeepCopyWith: deepCopier.lastSketchForm _ lastSketchForm veryDeepCopyWith: deepCopier.lastFormShown _ lastFormShown veryDeepCopyWith: deepCopier.! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/10/1998 08:33'!colorChangedForSubmorph: aSubmorph	"Invoked when the user selects a new color on a colorTile or a color-seer-tile; need to recompile the script."	self acceptNewLiteral! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!bePossessive	possessive _ true.	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 18:00'!bringUpToDate	| newLabel |	type == #objRef ifTrue:		[newLabel _ actualObject externalName.		self isPossessive ifTrue:			[newLabel _ newLabel, '''s'].		self line1: newLabel]	! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!isPossessive	possessive == nil ifTrue: [^ false].	^ possessive! !!TileMorph methodsFor: 'initialization' stamp: 'sw 7/2/1998 09:50'!setLiteral: anObject	| m |	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.  "BUT this doesn't do it, damnit"	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorph: m.	self literal: anObject.! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/6/1998 11:02'!associatedPlayer	^ actualObject! !!TileMorph methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:55'!playerBearingCode	"Answer the actual Player object who will be the 'self' when the receiver is being asked to generate code"	| anEditor |	(anEditor _ self topEditor) ifNotNil: [^ anEditor playerScripted].	^ (self nearestOwnerThat: [:m | m isAViewer]) scriptedPlayer! !!TileMorph methodsFor: 'accessing' stamp: 'sw 7/4/1998 18:01'!resultType	type == #literal ifTrue:		[(literal isKindOf: Number) ifTrue: [^ #number].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Point) ifTrue: [^ #point].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Boolean) ifTrue: [^ #boolean].		(literal isKindOf: Morph) ifTrue: [^ #costume]  "This last one dubious!!"].	type == #expression ifTrue:		[^ #number].	type == #objRef ifTrue: [^ #player].	^ #unknown! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/9/1998 14:18'!slotName	"Caution: the slotName is not in use!!"	^ slotName! !!TileMorph methodsFor: 'arrows' stamp: 'sw 10/21/1998 09:45'!showSuffixChoices	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: literal 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter harmonizeTileColorPolicyFor: (phrase topEditor ifNil: [phrase])! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:12'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:04'!storeCodeOn: aStream indent: tabCount	| op refType playerBearingCode |	"Must determine whom is scripted for what follows to work"	playerBearingCode _ self playerBearingCode.  "If it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["This is the critical point -- if the object is the method's own 'self' then we MUST, rather than just MAY, put out self rather than the referencer call, though the latter will temporarily work as long we have true uniclasses."				aStream nextPutAll: 'self']			ifFalse:				[aStream nextPutAll: 'self class '.				aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'private' stamp: 'sw 6/26/1998 16:26'!updateLiteralLabel	"now works for operator tiles also"	|  desiredW leader myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel contents:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + (leader + 0)) @ (bounds top + 3); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!TileMorph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 10:17'!convertbosfcepcbbtsloadustlno0: varDict bosfcebbtsloadustlnop0: smartRefStrm	"These variables are automatically stored into the new instance ('type' 'slotName' 'literal' 'operatorOrExpression' 'actualObject' 'downArrow' 'upArrow' 'suffixArrow' 'typeColor' 'lastArrowTick' 'nArrowTicks' 'operatorReadoutString' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('possessive' ) and deal with the information in ()"	"Morph's conversion method already deals with this, so no extra code here."! !!TileMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:15'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.actualObject _ deepCopier references at: actualObject ifAbsent: [actualObject].! !!TileMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:14'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.type _ type veryDeepCopyWith: deepCopier.slotName _ slotName veryDeepCopyWith: deepCopier.literal _ literal veryDeepCopyWith: deepCopier.operatorOrExpression _ operatorOrExpression veryDeepCopyWith: deepCopier."actualObject _ actualObject.		Weakly copied"downArrow _ downArrow veryDeepCopyWith: deepCopier.upArrow _ upArrow veryDeepCopyWith: deepCopier.suffixArrow _ suffixArrow veryDeepCopyWith: deepCopier.typeColor _ typeColor veryDeepCopyWith: deepCopier.lastArrowTick _ lastArrowTick veryDeepCopyWith: deepCopier.nArrowTicks _ nArrowTicks veryDeepCopyWith: deepCopier.operatorReadoutString _ operatorReadoutString veryDeepCopyWith: deepCopier.possessive _ possessive veryDeepCopyWith: deepCopier.            ! !!TilePadMorph methodsFor: 'all' stamp: 'sw 6/15/1998 09:21'!acceptDroppingMorph: aMorph event: evt	| editor wasPossessive |	wasPossessive _ submorphs size > 0 and: [submorphs first isPossessive].	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	wasPossessive ifTrue: [aMorph bePossessive].	(editor _ self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:07'!mouseEnter: evt	"Show drag/drop feedback."	| h m |	h _ evt hand.	h submorphCount ~= 1 ifTrue: [^ self].	m _ h firstSubmorph.	(self canAccept: m) ifTrue:		[self color: (ScriptingSystem brightColorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem brightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!mouseLeave: evt	"Clear drag/drop feedback."	color ~= (ScriptingSystem colorForType: type) ifTrue:		[self color: (ScriptingSystem colorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem unbrightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!rootForGrabOf: aMorph	"Allow submorph to be extracted."	| root |true ifTrue: [^ super rootForGrabOf: aMorph].	self inPartsBin ifTrue: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[root color: (ScriptingSystem colorForType: root resultType).			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!setType: aSymbol	type _ aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (TileMorph defaultW)@(TileMorph defaultH).! !!TilePadMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	submorphs do: [:m | m storeCodeOn: aStream indent: tabCount].! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 9/9/1998 17:35'!initialize	"TilePadMorph initialize"	ColorsForType _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(point			(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | ColorsForType at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!Time methodsFor: 'printing' stamp: 'sw 12/31/1998 17:53'!print24	"Return an 8-digit string representing the receiver.  Format is 'hh:mm:ss', with leading zeros if needed"	| aStream |	aStream _ ReadWriteStream on: ''.	hours < 10 ifTrue: [aStream nextPutAll: '0'].	hours printOn: aStream.	aStream nextPutAll: (minutes < 10 ifTrue: [':0'] ifFalse: [':']).	minutes printOn: aStream.	aStream nextPutAll: (seconds < 10 ifTrue: [':0'] ifFalse: [':']).	seconds printOn: aStream.	^ aStream contents"Time now print24" ! !!Time class methodsFor: 'general inquiries' stamp: 'JZH 11/8/1998 13:03'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Date fromSeconds: secondCount)		with: (Time fromSeconds: secondCount \\ 86400)! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	| secondCount d t |	secondCount _ self primSecondsClock.	d _ Date fromSeconds: secondCount.	t _ Time fromSeconds: secondCount \\ 86400.	^ Array with: d with: t! !an input from a toggle button!!ToggleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 07:33'!fixTargetPresenters	"ToggleButtonMorph fixTargetPresenters"	"Repair faulty instances from the first 'etoy-template' experiment, such that the instances refer to the local presenter rather than to a phantom and irrelevant world"	self allInstancesDo:		[:m | (m target isKindOf: Presenter) ifTrue:			[m target: m presenter]]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	World ifNotNil: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:25'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for simple translation."	^ canvasForMe copyOffset: transform offset negated truncated									clipRect: self innerBounds! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:44'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform globalBoundsToLocal:					(aCanvas clipRect intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'drawing' stamp: 'di 1/4/1999 10:58'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	self visible ifFalse: [^ false].	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform globalBoundsToLocal: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !!TransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform globalPointToLocal: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !!TransformMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: ((transform localBoundsToGlobal: damageRect) intersect: bounds)! !!TransformationMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 23:12'!flexing: aMorph byTransformation: tfm	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	(aMorph isKindOf: TransformationMorph)		ifTrue: [aMorph submorphsDo: [:m | self addMorph: m clone]]		ifFalse: [self addMorph: aMorph].	transform _ tfm.	self chooseSmoothing.	self layoutChanged.! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 7/31/1998 12:35'!forwardDirection	"Same as rotationDegrees"| m |^ (((m _ self renderedMorph) isKindOf: SketchMorph) and: [m rotationStyle ~~ #normal]) 			ifTrue: [m rotationDegrees]			ifFalse: [self angle radiansToDegrees negated]! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 8/20/1998 13:44'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on ', submorphs first printString! !!TransformationMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 23:43'!referencePosition	^ transform localPointToGlobal: self renderedMorph referencePosition! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 9/3/1998 00:18'!referencePosition: aPoint	self position: self position + (aPoint - self referencePosition)! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 14:37'!rotationDegrees: degrees	| m |	self adjustAfter:		[(m _ self renderedMorph) doesOwnRotation			ifTrue: ["is SketchMorph and rotationStyle is not #normal"				m rotationDegrees: degrees.				"self angle: 0.0 or not flexed"]			ifFalse: [self angle: degrees degreesToRadians negated]]	"usual case"! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 10/2/1998 15:11'!scaleToFit: anExtent	| scaleFactor |	scaleFactor _ anExtent r / submorphs first fullBounds extent r.	((scaleFactor - 1.0) abs < 0.05) ifTrue: [scaleFactor _ 1.0].	self scale: ((scaleFactor min: 8.0) max: 0.05).! !!TransformationMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45'!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (transform localBoundsToGlobal:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds])))				expandBy: 1].	super layoutChanged! !!TransformationMorph methodsFor: 'menu' stamp: 'di 9/9/1998 19:53'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed player: self player.	self player ifNotNil:		[self player rawCostume: unflexed.		self player: nil].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:49'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ self referencePosition.	changeBlock value.	self chooseSmoothing.	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:48'!chooseSmoothing	"Choose appropriate smoothing, after a change of scale or rotation."	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1]! !A transitionMorph inserts itself in the morphic object structure during a visual transition.  It has a stepNumber that runs from 1 to nSteps.  This class handles a large family of wipe-like transitions by itself.  Subclasses may implement other transitions such as dissolves and zooms.!!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 12:52'!completeReplacement	self delete.	completionBlock value! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 1/2/1999 20:55'!initiateReplacement	| n |	startForm _ effect = #dissolve		ifTrue: [(startMorph imageForm: 16 forRectangle: bounds) offset: 0@0]		ifFalse: [(startMorph imageFormForRectangle: bounds) offset: 0@0].	endForm _ (endMorph imageFormForRectangle: bounds) offset: 0@0.	nSteps == nil ifTrue:		[self nSteps: 30 stepTime: 10.		(#(zoom pageForward pageBack) includes: effect) ifTrue:			[n _ 20 * 100000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 10].		(#dissolve = effect) ifTrue:			[n _ 20 * 50000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 10]].	startBlock value.  "with forms in place there should b no further delay."	self arrangeToStartStepping.! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/14/1998 12:25'!nSteps: n stepTime: msPerStep	nSteps _ n.	stepTime _ msPerStep! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 13:32'!showTransitionFrom: startingMorph to: endingMorph in: containingMorph	whenStart: firstBlock whenDone: doneBlock	effect == #none ifTrue: [firstBlock value.  ^ doneBlock value].	self startMorph: startingMorph endMorph: endingMorph		startBlock: firstBlock completionBlock: doneBlock.	stepNumber _ 0.	self bounds: startingMorph bounds.	endingMorph privateOwner: self.  "Allows test of transition in progress"	containingMorph owner privateAddMorph: self atIndex: 		(containingMorph owner submorphs indexOf: containingMorph).	self initiateReplacement! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 10:46'!startMorph: start endMorph: end startBlock: firstBlock completionBlock: aBlock	startMorph _ start.	endMorph _ end.	startBlock _ firstBlock.	completionBlock _ aBlock! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 1/5/1999 08:37'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ aRectangle areasOutside: self bounds! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/22/1998 21:53'!drawDissolveOn: aCanvas	"startForm and endFrom are both fixed, but the dissolve ration changes."	startForm copyBits: endForm at: 0@0 translucent: stepNumber asFloat / (nSteps*2).	aCanvas image: startForm at: self position rule: Form over.! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/22/1998 20:55'!drawFrenchDoorOn: aCanvas	"startForm and endFrom are both fixed, but a border expands out from a vertical (or H) slit, revealing endForm.	It's like opening a pair of doors."	| box innerForm outerForm boxExtent h w |	h _ self height. w _ self width.	direction = #in ifTrue: [innerForm _ endForm.  outerForm _ startForm.							boxExtent _ self stepFrom: 0@h to: self extent].	direction = #out ifTrue: [innerForm _ startForm.  outerForm _ endForm.							boxExtent _ self stepFrom: self extent to: 0@h].	direction = #inH ifTrue: [innerForm _ endForm.  outerForm _ startForm.							boxExtent _ self stepFrom: w@0 to: self extent].	direction = #outH ifTrue: [innerForm _ startForm.  outerForm _ endForm.							boxExtent _ self stepFrom: self extent to: w@0].			aCanvas image: outerForm at: self position rule: Form over.	box _ Rectangle center: self center extent: boxExtent.	aCanvas image: innerForm at: box topLeft sourceRect: (box translateBy: self position negated) rule: Form over.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/22/1998 20:58'!drawOn: aCanvas	"During the transition process, the reveal and obscure areas will be invalidated,	so we should be drawing on a canvas that clips to only the changing region."	(stepNumber between: 1 and: nSteps) ifFalse: [^ self].	effect = #slideOver ifTrue: [^ self drawSlideOverOn: aCanvas].	effect = #slideBoth ifTrue: [^ self drawSlideBothOn: aCanvas].	effect = #slideAway ifTrue: [^ self drawSlideAwayOn: aCanvas].	effect = #slideBorder ifTrue: [^ self drawSlideBorderOn: aCanvas].	effect = #pageForward ifTrue: [^ self drawPageForwardOn: aCanvas].	effect = #pageBack ifTrue: [^ self drawPageBackOn: aCanvas].	effect = #frenchDoor ifTrue: [^ self drawFrenchDoorOn: aCanvas].	effect = #zoomFrame ifTrue: [^ self drawZoomFrameOn: aCanvas].	effect = #zoom ifTrue: [^ self drawZoomOn: aCanvas].	effect = #dissolve ifTrue: [^ self drawDissolveOn: aCanvas].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 15:43'!drawPageBackOn: aCanvas	"endForm grows in the given direction, overlaying endForm."	| offset growRect scale |	aCanvas image: startForm at: self position rule: Form over.	offset _ self stepFrom: self extent * direction negated to: 0@0.	growRect _ (bounds translateBy: offset) intersect: bounds.	scale _ growRect extent asFloatPoint / bounds extent.	aCanvas image: (endForm magnify: endForm boundingBox by: scale smoothing: 1)		at: growRect topLeft rule: Form over.	((growRect translateBy: direction) areasOutside: growRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 15:37'!drawPageForwardOn: aCanvas	"startForm shrinks in the given direction, revealing endForm."	| offset shrinkRect scale |	aCanvas image: endForm at: self position rule: Form over.	offset _ self stepFrom: 0@0 to: self extent * direction.	shrinkRect _ (bounds translateBy: offset) intersect: bounds.	scale _ shrinkRect extent asFloatPoint / bounds extent.	aCanvas image: (startForm magnify: startForm boundingBox by: scale smoothing: 1)		at: shrinkRect topLeft rule: Form over.	((shrinkRect translateBy: direction negated) areasOutside: shrinkRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:58'!drawSlideAwayOn: aCanvas	"startMorph slides away in the given direction, revealing up the endMorph."	| startLoc moveRect |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	moveRect _ startForm boundingBox translateBy: startLoc.	aCanvas image: endForm at: self position rule: Form over.	aCanvas image: startForm at: startLoc rule: Form over.	((moveRect translateBy: direction negated) areasOutside: moveRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:50'!drawSlideBorderOn: aCanvas	"startForm and endFrom are both fixed, but a border slides in the given direction, revealing endForm.  (It's like opening a can of sardines ;-)."	| endRect box sourceRect boxLoc |	box _ endForm boundingBox.	boxLoc _ self stepFrom: box topLeft - (box extent * direction) to: box topLeft.	sourceRect _ box translateBy: boxLoc.	endRect _ sourceRect translateBy: self position.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas image: startForm at: self position rule: Form over].	aCanvas image: endForm at: self position + boxLoc sourceRect: sourceRect rule: Form over.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 14:36'!drawSlideBothOn: aCanvas	"endMorph slides in the given direction, as startMorph slides out of its way."	| endLoc endRect startLoc |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	aCanvas image: startForm at: startLoc rule: Form over.	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	aCanvas image: endForm at: endLoc rule: Form over.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:48'!drawSlideOverOn: aCanvas	"endMorph slides in the given direction, covering up the startMorph."	| endLoc endRect |	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas image: startForm at: self position rule: Form over].	aCanvas image: endForm at: endLoc rule: Form over.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/22/1998 20:57'!drawZoomFrameOn: aCanvas	"startForm and endFrom are both fixed, but a square border expands out from the center (or back), revealing endForm.	It's like passing through a portal."	| box innerForm outerForm boxExtent |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].			aCanvas image: outerForm at: self position rule: Form over.	box _ Rectangle center: self center extent: boxExtent.	aCanvas image: innerForm at: box topLeft sourceRect: (box translateBy: self position negated) rule: Form over.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 17:50'!drawZoomOn: aCanvas	"Zoom in: endForm expands overlaying startForm.	Zoom out: startForm contracts revealing endForm."	| box innerForm outerForm boxExtent scale |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].	aCanvas image: outerForm at: self position rule: Form over.	box _ Rectangle center: self center extent: boxExtent.	scale _ box extent asFloatPoint / bounds extent.	aCanvas image: (innerForm magnify: innerForm boundingBox by: scale smoothing: 1)		at: box topLeft rule: Form over.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'change reporting' stamp: 'di 12/22/1998 20:59'!changed	"The default (super) method is, generally much slower than need be, since many transitions only change part of the screen on any given step of the animation.  The purpose of this method is to effect some of those savings."	| loc box boxPrev h w |	(stepNumber between: 1 and: nSteps) ifFalse: [^ super changed].	effect = #slideBoth ifTrue: [^ super changed].	effect = #slideOver ifTrue:		[loc _ self stepFrom: self position - (self extent * direction) to: self position.		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideAway ifTrue:		[loc _ self prevStepFrom: self position to: self position + (self extent * direction).		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideBorder ifTrue:		[box _ endForm boundingBox translateBy:				(self stepFrom: self topLeft - (self extent * direction) to: self topLeft).		boxPrev _ endForm boundingBox translateBy:				(self prevStepFrom: self topLeft - (self extent * direction) to: self topLeft).		^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].	effect = #pageForward ifTrue:		[loc _ self prevStepFrom: 0@0 to: self extent * direction.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #pageBack ifTrue:		[loc _ self stepFrom: self extent * direction negated to: 0@0.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #frenchDoor ifTrue:		[h _ self height. w _ self width.		direction = #in ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: 0@h to: self extent).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: 0@h to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #out ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: self extent to: 0@h).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: self extent to: 0@h).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box].		direction = #inH ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: w@0 to: self extent).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: w@0 to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #outH ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: self extent to: w@0).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: self extent to: w@0).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box]].	effect = #zoomFrame ifTrue:		[direction = #in ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: 0@0 to: self extent).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: 0@0 to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #out ifTrue:			[box _ Rectangle center: self center							extent: (self stepFrom: self extent to: 0@0).			boxPrev _ Rectangle center: self center							extent: (self prevStepFrom: self extent to: 0@0).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box]].	effect = #zoom ifTrue:		[box _ Rectangle center: self center extent:			(direction = #in				ifTrue: [self stepFrom: 0@0 to: self extent]				ifFalse: [self prevStepFrom: self extent to: 0@0]).		^ self invalidRect: ((box expandBy: 1) intersect: bounds)].	^ super changed! !!TransitionMorph methodsFor: 'change reporting' stamp: 'di 12/22/1998 20:10'!invalidate: box1 areasOutside: box2	((box1 intersect: bounds) areasOutside: (box2 intersect: bounds))		do: [:r | self invalidRect: r]! !!TransitionMorph methodsFor: 'stepping' stamp: 'di 12/14/1998 12:30'!step	(stepNumber _ stepNumber + 1) <= nSteps		ifTrue: [self changed]		ifFalse: [self completeReplacement]! !!TransitionMorph methodsFor: 'stepping' stamp: 'di 12/15/1998 13:52'!stepTime	^ stepTime! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/22/1998 21:01'!effect: effectSymbol direction: dirSymbol	| i |	effect _ effectSymbol.	"Default directions"	(#(zoom zoomFrame frenchDoor) includes: effectSymbol)		ifTrue: [(#(in out inH outH) includes: dirSymbol)					ifTrue: [direction _ dirSymbol]					ifFalse: [direction _ #in]]		ifFalse: [i _ #(right downRight down downLeft left upLeft up upRight)						indexOf: dirSymbol ifAbsent: [5].				direction _ (0@0) eightNeighbors at: i].! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/15/1998 11:42'!prevStepFrom: p1 to: p2	"Used for recalling dimensions from previous step."	^ (p2-p1) * (stepNumber-1) // nSteps + p1! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/14/1998 12:43'!stepFrom: p1 to: p2	"This gives p1 for stepCount = 0, moving to p2 for stepCount = nSteps"	^ (p2-p1) * stepNumber // nSteps + p1! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 12/20/1998 22:01'!effect: effectSymbol direction: dirSymbol	^ self new effect: effectSymbol direction: dirSymbol! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 12/20/1998 21:37'!effect: effectSymbol direction: dirSymbol inverse: inverse	| invEffect invDir i dirSet |	inverse ifFalse: [^ self effect: effectSymbol direction: dirSymbol].	invEffect _ effectSymbol.	effectSymbol = #pageForward ifTrue: [invEffect _ #pageBack].	effectSymbol = #pageBack ifTrue: [invEffect _ #pageForward].	effectSymbol = #slideOver ifTrue: [invEffect _ #slideAway].	effectSymbol = #slideAway ifTrue: [invEffect _ #slideOver].	invDir _ dirSymbol.	dirSet _ self directionsForEffect: effectSymbol.	(i _ dirSet indexOf: dirSymbol) > 0		ifTrue: [invDir _ dirSet atWrap: i + (dirSet size // 2)].	^ self effect: invEffect direction: invDir! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 11/16/1998 15:37'!includeInNewMorphMenu	"Transitions aren't meaningful without initializations"	^ false! !!TransitionMorph class methodsFor: 'available effects' stamp: 'di 12/22/1998 20:58'!allEffects	^ #(none		slideOver slideBoth slideAway slideBorder		pageForward pageBack 		frenchDoor		zoomFrame zoom		dissolve)! !!TransitionMorph class methodsFor: 'available effects' stamp: 'di 12/22/1998 20:59'!directionsForEffect: eff	 "All these arrays are ordered so inverse is atWrap: size//2."	(#(slideOver slideBoth slideAway slideBorder) includes: eff)		ifTrue: [^ #(right downRight down downLeft left upLeft up upRight)].	(#(pageForward pageBack) includes: eff)		ifTrue: [^ #(right down left up)].	(#(frenchDoor) includes: eff)		ifTrue: [^ #(in inH out outH)].	(#(zoomFrame zoom) includes: eff)		ifTrue: [^ #(in out)].	^ Array new! !!TranslucentColor methodsFor: 'printing' stamp: 'di 1/14/1999 14:31'!storeOn: aStream	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/14/1999 20:05'!bitPatternForDepth: depth	"Return an appropriate bit pattern or stipple.  This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."	alpha = 0 ifTrue: [^ Bitmap with: 0].	^ super bitPatternForDepth: depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:15'!pixelValueForDepth: d	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	alpha = 0 ifTrue: [^ 0].	^ super pixelValueForDepth: d! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:14'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:30'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	| pv32 a b g r |	pv32 _ super scaledPixelValue32.	a _ (self alpha * 255.0) rounded.	b _ (pv32 bitAnd: 255) * a // 256.	g _ ((pv32 bitShift: -8) bitAnd: 255) * a // 256.	r _ ((pv32 bitShift: -16) bitAnd: 255) * a // 256.	^b + (g bitShift: 8) + (r bitShift: 16) + (a bitShift: 24)! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ alpha < 255! !!TranslucentColor methodsFor: 'queries' stamp: 'di 1/3/1999 12:22'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ alpha > 0! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTransparent	^ alpha = 0! !!TranslucentColor methodsFor: 'object fileIn' stamp: 'tk 1/13/1999 11:22'!convertrcc0: varDict rcca0: smartRefStrm	"These variables are automatically stored into the new instance ().	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('alpha' ) and deal with the information in ()"	^ Color transparent! !!TrashCanMorph methodsFor: 'initialization' stamp: 'sw 11/5/1998 16:55'!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'To remove an object, drop it on this trash can.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:17'!handlesDragOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 10/30/1998 15:57'!handlesMouseDown: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:33'!handlesMouseOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseEnter: event	"Present feedback for potential deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self presenter soundsEnabled ifTrue: [self class playMouseEnterSound].			hand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[self presenter soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand endDisplaySuppression.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 11/11/1998 16:01'!acceptDroppingMorph: aMorph event: evt	| palette |	self presenter soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self standardPalette.	(palette notNil and: [palette isInWorld]) ifTrue: [palette addToTrash: aMorph].! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:44'!findActivePaintBox	"If painting, return the active PaintBoxMorph. If not painting, or if the paint box cannot be found, return nil."	| w m |	w _ self world.	w ifNil: [^ nil].	(w findA: SketchEditorMorph) ifNil: [^ nil].  "not painting"	(m _ w findA: PaintBoxMorph) ifNotNil: [^ m].	^ nil! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:45'!openTrash	"User wants to see what is in the trash."	| paintBox |	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"! !!TrashCanMorph methodsFor: 'other' stamp: 'sw 9/14/1998 12:02'!printOn: aStream	aStream nextPutAll: 'a TrashCanMorph'! !This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it has book set to true, it is a page in a book.  Clicking fetches the index of the book, opens it to the first page, and puts it in the hand.A thumbnail on a known book:	(URLMorph grabURL: 'ftp://doltest1.disney.com/squeak/test/p1.sp')		book: true.A thumbnail ona single PasteUpMorph:Make a PasteUpMorph with any morphs in it.Decide where it should live, make a url string, and copy it.	'file://HardDisk/books/book1/myPage.sp'	'ftp://doltest1.disney.com/squeak/test/p1.sp'Choose 'Save as Web Morph'Paste in the url.Drop the resulting thumbnail into some morph.See SqueakPage's comment for the stages of in/out.url page 		A SqueakPageisBookmark 		Booleanbook 	A Boolean -- whether I represent a whole book or a page.!!URLMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 07:16'!initialize	super initialize.	color _ Color lightGray.	isBookmark _ false.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book	^ book! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book: aWebBookMorph	"Set the book morph to be invoked when this url is used as a bookmark. If nil, then this bookmark operates on whatever book it is currently in."	book _ aWebBookMorph.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:16'!isBookmark	^ isBookmark! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:17'!isBookmark: aBoolean	"Make this morph behave as a clickable bookmark if the argument is true."	isBookmark _ aBoolean.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:07'!page	"Answer the cached page that this morph represents."	^ page! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:05'!url	"Answer the URL for the page that this morph represents."	^ url! !!URLMorph methodsFor: 'drawing' stamp: 'tk 1/5/1999 10:57'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." 	| thumbnail oldExt |	thumbnail _ self thumbnailOrNil.	thumbnail		ifNil: [aCanvas frameRectangle: bounds width: 1 color: Color blue.			aCanvas fillRectangle: (bounds insetBy: 1) color: color]		ifNotNil: [oldExt _ bounds extent.			bounds _ bounds origin extent: thumbnail extent + (2@2).			aCanvas frameRectangle: bounds width: 1 color: Color blue.			aCanvas image: thumbnail at: bounds origin + 1.			oldExt = thumbnail extent ifFalse: [self layoutChanged]].! !!URLMorph methodsFor: 'event handling' stamp: 'tk 1/13/1999 08:04'!handlesMouseDown: event	^ isBookmark & event shiftPressed! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:55'!handlesMouseUp: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:58'!mouseDown: evt	"do nothing"! !!URLMorph methodsFor: 'event handling' stamp: 'tk 1/14/1999 12:54'!mouseUp: evt	| pg ow newPage mm ll bookUrl bk |	"If url of a book, bring in book with first page and grab it."	book==true ifTrue: [		ll _ url findLast: [:char | char == $.].		ll = 0 ifTrue: [^ self].		bookUrl _ url copyFrom: 1 to: ll-1.	"remove .sp"		bookUrl _ (bookUrl stemAndNumericSuffix) at: 1.		"remove trailing number"		[bookUrl last == $x] whileTrue: [bookUrl _ bookUrl allButLast].		bookUrl _ bookUrl, '.bo'.		(BookMorph alreadyInFromUrl: bookUrl) ifTrue: [^ self].			"If this book is already in, we would steal the pages out of it!!"		(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self].		bk goToPageUrl: url.	"turn to the page"		^ World primaryHand attachMorph: bk].	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'tk 11/23/1998 17:37'!enclosingBook	"rethink this since class WebBookMorph is gone"! !!URLMorph methodsFor: 'private' stamp: 'tk 10/1/1998 13:05'!enclosingPage	"Answer the inner-most SqueakPage contents that contains this morph, or nil if there isn't one."	| m pg |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: PasteUpMorph) ifTrue: [			(pg _ SqueakPageCache pageForMorph: m) ifNotNil: [^ pg]].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 08:20'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	page ifNotNil: [self pageHasChanged: page].! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 12:07'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [page _ SqueakPageCache atURL: url].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 1/5/1999 10:40'!grabURL: aURLString	"Create a URLMorph for this url.  Drop it and click it to get the SqueakPage."	| um |	World primaryHand attachMorph: 		((um _ self new) isBookmark: true; setURL: aURLString page: nil).	^ um! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:35'!newBookmarkForURL: aURLString	^ (self newForURL: aURLString) isBookmark: true! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 12:08'!newForURL: aURLString	| pg |	pg _ SqueakPageCache atURL: aURLString.	^ self new setURL: aURLString page: pg! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:41'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(self isStringRooted: uString)		ifTrue: ["an external URL"			(self isStringAnImage: uString)				ifTrue: ["Looks like an image URL"						^self imageURL: string]				ifFalse: [^self externalURL: string]]		ifFalse: [ "Serious!! Gotta provide-a-link!! But check forimage or local action first"				(self isStringAnImage: uString)					ifTrue: [^self localImageURL: string].				(self isStringALocalAction: uString)					ifTrue:[^self localActionURL: string].			newpage _ pages at: string asLowercase ifAbsent: [nil].			newpage isNil				ifTrue: [ "Create a new page"					newpage _ self newpage: stringfrom: peer.].			(aList indexOf: newpage) ~= 0				ifFalse: [aList add: newpage]. "Add only ifnot there"			^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:47'!linkFor: string from: peer storingTo: aList page: aPage	| uString placeID |	uString _ string asUppercase.	(uString beginsWith: 'APPEND HERE') ifTrue: [		placeID _ uString copyFrom: (13 min: uString size) to:uString size.		^'<a href="', aPage url, '.insert.', placeID ,'">','AppendHere','</a>'].			"later an image here"	^self linkFor: string from: peer storingTo: aList.! !!URLmap methodsFor: 'searching' stamp: 'BJP 9/7/1998 01:06'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new]."We definitely want the reject: first, so we sort a smaller collection.Having the variable name be 'sortedPages' is a bit of a misnomer, though.""I think we shouldn't do all this for each call to recent changes. Afterall, most of the time, it's *hasn't* changed, and when it *has*, it'spretty much only added something to the end. At the very least we shouldcache the sorted, filtered collection.""And really, why is this in URLmap? Recent Changes is a kind of page. I'drather see it as a swikipage, perhaps standardly defined (that is, when youset up a swiki, you get a front page, a formatting page, and a RecentChanges page). That is, SwikiPages could store text (as they do now) orcgi-ish functions (like recent). That way, we could design custom templatesfor them, etc.At the very least, there needs to be better labeling. Why not call thecategory with these page functions, 'dynamic pages', or somethign similar?""A different condsideration: It would be nice to have arbitrary filters:e.g., 'past ten days', 'all pages *not* yet edited', etc., and be able tocombine them. Would work as a 'search for various attributes' feature whichone might or might not expose to the user."	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(pageaddress).].	response nextPutAll: '</ul>'.	^response contents		! !!URLmap methodsFor: 'accessing' stamp: 'JZH 10/13/1998 22:56'!atID: id	"Return page of a given key."	| idString |	idString _ id isInteger ifTrue: [id printString] ifFalse: [id].	^ pages detect: [:page | page coreID = idString] ifNone: [selfatID: '1']! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:16'!externalURL: aString	"make a non-local  URL"	^'<a href="',aString,'">',aString,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:15'!imageURL: aString	"make a non-local image URL"	^'<img src="', aString,'" alt="', aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:10'!localActionURL: aString	|string|	"fake up a more ordinary URL by dropping the shriek chars"	string _ aString copyWithout: $!!.	^'<a href="',string,'">',string,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/1/1998 12:32'!localImageURL: aString	"make a local image URL"	^'<img src="',action name, '/', aString,'" alt="', action name,'/',aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 10/14/1998 14:38'!pageURL: aPage	(aPage pageStatus = #new)		ifTrue:			[(action isKindOf: CachedSwikiAction)			ifFalse: [^'<u>',(aPage name),'</u><a href="', 				(action pageURL: aPage),'.edit">?</a>']			ifTrue: [^'<u>',(aPage name),'</u><a href="',				(action pwsURL),(action name),'.',(aPage coreID),'.edit">?</a>']				"Underlines new but not yet edited pages"]		ifFalse:			[^'<a href="', (action pageURL: aPage),'">',(aPage name),'</a>']"Logically, there should be editPageUrl in SwikiAction as well. After all,we might want to define other URL schemes." ! !!URLmap methodsFor: 'creating' stamp: 'BJP 9/7/1998 00:52'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	"This filtering should be generalized a tad, methinks. Perhapsincorparated into the	linkhandler."	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'mjg 10/9/1998 13:06'!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p |		p coreID asNumber > max ifTrue: [p coreID asNumber]				ifFalse: [max]]) + 1) printString.	newpage _ action class pageClass new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage time: (Time now).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory),		directory, (ServerAction pathSeparator), newfile).	newpage pageStatus: #new.	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'mjg 8/28/1998 19:48'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page time: (Time now).	page text: text.	page address: peer.	^ page! !!URLmap methodsFor: 'creating' stamp: 'tk 7/14/1998 19:32'!storeID: id text: insertedText insertAt: idString	"Insert in a place in the text.  Just before '*append here 34*' ifidString is '34'."	| page bigText ind toInsert |	page _ self atID: id.	page date: (Date today).	bigText _ page text.	ind _ bigText findString: '*append here ',idString,'*' startingAt:1.	"always lower case"	ind = 0 ifTrue: [^ page].		"could not find that place"	"Make sure new text surrounded by line feeds"	toInsert _ (insertedText last == Character linefeed)		ifTrue: [insertedText]		ifFalse: [insertedText, (String with: Character linefeed)].	((insertedText first == Character linefeed) or: [		(bigText at: (ind-1 max: 1)) == Character linefeed])			ifFalse: [toInsert _ (String with: Characterlinefeed), toInsert].	page text: (bigText copyReplaceFrom: ind to: ind-1 with: toInsert).	"page address: peer.  Don't sign with person who only added"	^ page! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:51'!isStringALocalAction: anUpperCasedString	"check the string to see if it starts and end with  a shriek - codefor a Swiki action such as Comment or whatever"	^(anUpperCasedString size >=2) and:	[anUpperCasedString first = $!! and:	[anUpperCasedString last= $!!]]! !!URLmap methodsFor: 'private' stamp: 'mjg 9/21/1998 10:47'!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes it likely to be an image URL"	^(anUpperCasedString endsWith: '.GIF') or:		[(anUpperCasedString endsWith: '.JPEG') or:		[anUpperCasedString endsWith: '.JPG']]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:37'!isStringRooted: anUpperCasedString	"check the string to see if it starts with something that makes itlkely to be a rooted URL"	^(anUpperCasedString indexOfSubCollection: 'HTTP' startingAt: 1) =1 or:	[(anUpperCasedString indexOfSubCollection: 'FTP' startingAt: 1) = 1 or:	[(anUpperCasedString indexOfSubCollection: 'MAILTO' startingAt: 1)= 1]]! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 8/31/1998 16:53'!addToGlossary: myName as: myURL	|aStream |	"Add to a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	aStream setToEnd.	aStream nextPutAll: myName,'|',myURL; cr.	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:44'!readGlossary: aStream	|aLine pieces name url newpage|	"Expect a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	self pages: (Dictionary new).	aStream open.	[aStream atEnd] whileFalse:		[aLine := aStream upTo: (Character cr).		pieces _ aLine findTokens: '|'.		name _ pieces at: 1.		url _ pieces at: 2.		newpage _ SwikiPage new.		newpage coreID: url.		newpage map: self.		newpage name: name.		pages at: name asLowercase put: newpage].	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:47'!writeGlossary	"Write out the pages dictionary as a CR-delimited file of pagenameand URL"	|aStream |	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	pages keys asSortedCollection do: [:each |		aStream nextPutAll: (pages at: each) name,'|',(pages at:each) coreID; cr.].	aStream close.	! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!UndefinedObject methodsFor: 'printing' stamp: 'sw 10/29/1998 16:34'!newTileMorphRepresentative	^ UndescribedTile new! !!UndescribedTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:45'!initialize	super initialize.	self extent: (20 @ 22)! !Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 1/14/1999 12:00'!default	"UnloadedSound default play"	| snd p |	snd _ super new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !My instances are Player objects that have not been scripted, and which hence do not require a unique scripts dictionary, etc.  As soon as the needed, I am transformed automatically into a unique subclass of Player.!!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:21'!assureUniClass	| anInstance |	anInstance _ Player instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!belongsToUniClass	^ false! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:13'!copyUniClass	self error: 'oops, copyUniClass sent to an UnscriptedPlayer'! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!acceptsLoggingOfCompilation	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:33'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self new! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:34'!officialClass	^ self! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:49'!wantsChangeSetLogging	^ true! !!UnscriptedPlayer class methodsFor: 'reference' stamp: 'sw 9/30/1998 09:14'!ephemeralPlayerRef	"UnscriptedPlayer ephemeralPlayerRef"	^ ephemeralPlayerRef! !!UnscriptedPlayer class methodsFor: 'reference' stamp: 'sw 9/30/1998 09:05'!referenceSelectorFor: anObject	"The use of this is for immediate evaluation of lines of script in a Viewer.  The class inst var 'ephemeralPlayerRef' is constantly reused for this purpose."	ephemeralPlayerRef _ anObject.	^ 'ephemeralPlayerRef'! !A customized updating-string-morph used for displaying and editing boolean values; mouse-down on one of these is inerpreted as a request to toggle.!!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/1/1998 16:59'!handlesMouseDown: evt	^ true! !!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/1/1998 16:49'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target scriptPerformer perform: putSelector with: getSelector with: newValue.			target isMorph ifTrue: [target changed]].			self growable ifTrue:				[self readFromTarget; fitContents.				owner updateLiteralLabel]]! !!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/5/1998 12:12'!mouseDown: evt	self contentsClipped: (target perform: getSelector) not asString.	self informTarget! !!UpdatingRectangleMorph methodsFor: 'display' stamp: 'sw 10/24/1998 21:23'!drawOn: aCanvas 	"Copied down from BorderedMorph, with the substitution that the color inst var of the receiver here might well be something like #raised or some other symbol, which the frameAndFillRectangle... methods barf on."	| insetColor colorToFill |	colorToFill _ (color isKindOf: Color) ifTrue: [color] ifFalse: [Color gray].	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue:		[^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: colorToFill lighter			bottomRightColor: colorToFill darker].	borderColor == #inset ifTrue:		[insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: colorToFill		borderWidth: borderWidth		borderColor: borderColor.! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied"lastValue _ lastValue veryDeepCopyWith: deepCopier."getSelector _ getSelector.		a Symbol""putSelector _ putSelector.		a Symbol"contents _ contents veryDeepCopyWith: deepCopier.! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'sw 6/26/1998 07:41'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.	growable _ true! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:53'!acceptValueFromTarget: v	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:56'!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target scriptPerformer perform: getSelector.	^ self acceptValueFromTarget: v! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 08:26'!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ self growable		ifTrue:			['stop']		ifFalse:			['start'].	menu add: prefix, ' being growable' action: #toggleGrowability.	menu add: 'decimal places...' action: #setPrecision.	menu add: 'font size...' action: #setFontSize.	menu add: 'font style...' action: #setFontStyle! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 17:34'!setFontSize	| sizes reply family aPair |	family _ font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family _ TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes _ 	family fontNamesAndSizes collect: [:aString |		aPair _ aString findTokens: ' '.		aPair second asNumber].	reply _ (SelectionMenu labelList: (sizes collect: [:s | s printString]) selections: sizes) startUp.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 17:42'!setFontStyle	| aList reply style |	aList _ (TextConstants select: [:anItem | anItem isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		self font: (style fontArray at: 2)]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/5/1998 15:31'!setPrecision	| aList aMenu reply |	aList _ #('0' '1' '2' '3' '4' '5').	aMenu _ SelectionMenu labels: aList selections: aList.	reply _ aMenu startUpWithCaption: 'How many decimal places?'.	reply ifNotNil:		[self floatPrecision:			(#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001) at: (aList indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable _ self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 15:37'!veryDeepFixupWith: deepCopier	"If target field is weakly copied, fix it here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 15:36'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.format _ format veryDeepCopyWith: deepCopier."target _ target.		Weakly copied"lastValue _ lastValue veryDeepCopyWith: deepCopier.getSelector _ getSelector veryDeepCopyWith: deepCopier.putSelector _ putSelector veryDeepCopyWith: deepCopier.floatPrecision _ floatPrecision veryDeepCopyWith: deepCopier.growable _ growable veryDeepCopyWith: deepCopier.! !!UpdatingStringMorphWithArgument methodsFor: 'as yet unclassified' stamp: 'sw 10/25/1998 00:57'!readFromTarget	| v |	argumentTarget ifNil: [^ super readFromTarget].	v _ target perform: getSelector with: (argumentTarget perform: argumentGetSelector).	^ self acceptValueFromTarget: v! !!UpdatingStringMorphWithArgument methodsFor: 'all' stamp: 'sw 10/25/1998 00:20'!argumentTarget: t argumentGetSelector: s	argumentTarget _ t.	argumentGetSelector _ s! !!UpdatingStringMorphWithArgument methodsFor: 'copying' stamp: 'tk 1/7/1999 15:40'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.argumentTarget _ deepCopier references at: argumentTarget 			ifAbsent: [argumentTarget].! !!UpdatingStringMorphWithArgument methodsFor: 'copying' stamp: 'tk 1/7/1999 15:39'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."argumentTarget _ argumentTarget.		Weakly copied"argumentGetSelector _ argumentGetSelector veryDeepCopyWith: deepCopier.! !A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!Url methodsFor: 'parsing' stamp: 'ls 8/5/1998 00:57'!newFromRelativeText: aString	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"	"if the scheme is the same, or not specified, then use the same class"	| newSchemeName remainder fragmentStart newFragment newUrl bare |	bare _ aString withBlanksTrimmed.	newSchemeName _ Url schemeNameForString: bare.	(newSchemeName isNil not and: [ newSchemeName ~= self schemeName ]) ifTrue: [		"different scheme -- start from scratch"		^Url absoluteFromText: aString ].	remainder _ bare.	"remove the fragment, if any"	fragmentStart _ remainder indexOf: $#.	fragmentStart > 0 ifTrue: [		newFragment _ remainder copyFrom: fragmentStart+1 to: remainder size. 		remainder _ remainder copyFrom: 1 to: fragmentStart-1].	"remove the scheme name"	newSchemeName ifNotNil: [		remainder _ remainder copyFrom: (newSchemeName size + 2) to: remainder size ].	"create and initialize the new url"	newUrl _ self class new privateInitializeFromText: remainder  relativeTo: self.	"set the fragment"	newUrl privateFragment: newFragment.	^newUrl! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:50'!privateInitializeFromText: aString	^self subclassResponsibility! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:55'!privateInitializeFromText: aString relativeTo: aUrl	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"	"by default, just do regular initialization"	^self privateInitializeFromText: aString! !!Url methodsFor: 'classification' stamp: 'ls 6/16/1998 16:22'!scheme	"return a string with the scheme of this URL.  For instance, HTTP"	^self subclassResponsibility! !!Url methodsFor: 'classification' stamp: 'ls 7/3/1998 21:11'!schemeName	"return a lowercase string with the scheme of this URL.  For instance, 'http'"	^self subclassResponsibility! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!printOn: aStream	aStream nextPutAll: self toText! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!toText	"give a String representation of the Url, suitable for printing, etc."	^self subclassResponsibility! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:41'!activate	"spawn an external handler for this URL"	! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:40'!hasContents	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"	^false! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContents	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved"	^nil! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContentsForBrowser: aBrowser	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved.  Since aBrowser is specified, this could do browser specific things"	^self retrieveContents! !!Url methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asText	^self asString asText! !!Url methodsFor: 'converting' stamp: 'ls 6/29/1998 00:36'!asUrl	^self! !!Url methodsFor: 'converting' stamp: 'ls 7/3/1998 21:11'!asUrlRelativeTo: aUrl	^self! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:41'!fragment	^fragment! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:02'!privateFragment: aString	fragment _ aString! !!Url class methodsFor: 'parsing' stamp: 'ls 8/4/1998 20:42'!absoluteFromText: aString	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"	"Url absoluteFromText: 'file:/etc/passwd'"	| remainder scheme fragment ind newUrl |	"trim surrounding whitespace"	remainder _ aString withBlanksTrimmed.		"extract the fragment, if any"	ind _ remainder indexOf: $#.	ind > 0 ifTrue: [		fragment _ remainder copyFrom: ind+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: ind-1 ].	"choose class based on the scheme name, and let that class do the bulk of the parsing"	scheme _ self schemeNameForString: remainder.	scheme = nil ifTrue: [		newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'http') ifTrue: [ newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'msw') ifTrue: [ newUrl _ MswUrl new privateInitializeFromText: remainder ]. 	(scheme = 'ftp') ifTrue:[ newUrl _ FtpUrl new privateInitializeFromText: remainder ].	(scheme = 'file') ifTrue: [newUrl _ FileUrl new privateInitializeFromText: remainder ].		(scheme = 'browser') ifTrue: [ newUrl _ BrowserUrl new privateInitializeFromText: remainder ].	(scheme = 'mailto') ifTrue: [ newUrl _ MailtoUrl new privateInitializeFromText: remainder ].	newUrl ifNil: [  newUrl _ GenericUrl new privateInitializeFromText: remainder ].	"set the fragment"	newUrl privateFragment: fragment.	"all done"	^newUrl! !!Url class methodsFor: 'parsing' stamp: 'ls 7/26/1998 20:37'!schemeNameForString: aString	"get the scheme name from a string, or return nil if it's not specified.  used in internal parsing routines--an outsider may as well use asUrl.  lowercases the return value."	"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| idx schemeName |	idx _ aString indexOf: $:.	idx = 0 ifTrue: [ ^nil ].	schemeName _ aString copyFrom: 1 to: idx-1.	schemeName do: [ :c |		"make sure it is all alphabetic"		c isLetter ifFalse: [ ^nil ]. ].	^schemeName asLowercase! !!Url class methodsFor: 'testing' stamp: 'ls 8/4/1998 02:42'!quickieTest	"run some quick tests on the Url hierarchy"	"	Url quickieTest	"	| tests url block correct actual numCorrect numWrong baseUrl |	"each item in tests in a two-element array.  it has a block, followed by the string the block should evaluate to"	tests _ OrderedCollection new.	"parsing absolute urls of various kinds"	tests add: (Array with: 		[url _ 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.		url schemeName, '|', url authority, '|', url path first, '|', url path size printString, '|', url query, '|',url fragment.]		with: 'http|chaos.resnet.gatech.edu:8000|docs|3|A%20query%20|part').	tests add: (Array with:		[url _ 'ftP://some.server/some/directory/' asUrl.		url schemeName, '|', url class name, '|', url authority, '|', url path first , '|', url path size printString]		with: 'ftp|FtpUrl|some.server|some|3').	tests add: (Array with:		[url _ 'telNet:chaos.resnet.gatech.edu#goo' asUrl.		url schemeName, '|', url locator, '|', url fragment] 		with: 'telnet|chaos.resnet.gatech.edu|goo').	tests add: (Array with:		[url _ Url absoluteFromText: 'file:/etc/passwd#foo'.		url schemeName, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|etc|2|foo').	tests add: (Array with: 		[url _ Url absoluteFromText: 'browser:bookmarks#mainPart'.		url schemeName, '|', url locator, '|', url fragment, '|', url class name ]		with: 'browser|bookmarks|mainPart|BrowserUrl').	tests add: (Array with:		[url _ 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.		url schemeName, '|', url class name, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|FileUrl|foo|5|fragger').	"relative urls of each kind, relative to the original"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp://a.b'.		url toText]		with: 'ftp://a.b/').	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp:xyz'.		url toText.]		with: 'ftp://somewhere/some/dir/xyz').	tests add: (Array with: [		baseUrl _ 'http://some.where/some/dir?query1#fragment1' asUrl.		url _ baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.		url toText]		with: 'http://some.where/another/dir/?query2#fragment2').	tests add: (Array with: [		baseUrl _ 'file:/some/dir#fragment1' asUrl.		url _ baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.		url toText]		with: 'file:/another/dir/#fragment2').	"relative urls of a different scheme"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'http:xyz'.		url toText.]		with: 'http://xyz/').	"run the tests"	numCorrect _ 0.	numWrong _ 0.	tests do: [ :test |		block _ test at: 1.		correct _ test at: 2.		actual _ block value.		Transcript show: actual.		correct = actual 			ifTrue: [ numCorrect _ numCorrect + 1 ]			ifFalse: [				numWrong _ numWrong + 1.				Transcript show: '<-- should be: ', correct ].		Transcript cr. ].	Transcript show: numCorrect printString, ' correct, ', numWrong printString, ' wrong.', String cr.	numWrong > 0 		ifTrue: [ Transcript show: 'happy hacking!!' ]		ifFalse: [ Transcript show: 'yay!!!!!!' ].	Transcript cr.! !!UserScript methodsFor: 'initialization' stamp: 'tk 6/13/1998 14:25'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [		currentScriptEditor == #textuallyCoded ifFalse: [			currentScriptEditor donorActor: player1 ownActor: player2]].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!UserScript methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:06'!initializeForPlayer: aPlayer afterShallowCopyFrom: aDonorUserScript	player _ aPlayer.	formerScriptEditors _ nil.	aDonorUserScript isTextuallyCoded		ifFalse:			[currentScriptEditor _ currentScriptEditor fullCopy.				"We have a rule that ScriptEditors can't have Players in them"			currentScriptEditor playerScripted: aPlayer.			currentScriptEditor donorActor: aDonorUserScript player ownActor: aPlayer]		! !!UserScript methodsFor: 'script editor' stamp: 'sw 8/21/1998 16:35'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!Utilities methodsFor: 'read me' stamp: 'sw 10/13/1998 13:14'!seeClassSide	"All the code for Utilitites is on the class side"! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 15:57'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger > 412]].	Utilities readServerUpdatesSaveLocally: true updateImage: true.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #().	Utilities readServerUpdatesSaveLocally: true updateImage: false       The expression above ftps all updates not in the current image over to the local       hard disk, but does NOT absorb them into the current image"	| fileNames fileNamesInOrder fileNamesUnnumbered names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	fileNames _ FileDirectory default fileNames select:		[:n | n first isDigit			and: [(n initialInteger between: n1 and: n2)			and: [(skipList includes: n initialInteger) not]]].	fileNamesInOrder _ fileNames asSortedCollection.	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | FileDirectory default rename: n toBe: nu].	(ServerDirectory groupNamed: choice) putUpdateMulti: fileNamesUnnumbered! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 15:02'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted.  If the preference #suppressUpdateServerPrompt is true, then suppress that prompt, in effect using the same server choice that was used the previous time (a convenience for those of us who always answer the same thing to the prompt.)"	| index him |	((UpdateUrlLists size > 1) and: [(Preferences valueOfFlag: #suppressUpdateServerPrompt) == false])		ifTrue:			[index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 				startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.			index > 0 ifTrue:				[him _ UpdateUrlLists at: index.				UpdateUrlLists removeAt: index.				UpdateUrlLists addFirst: him].			^ index > 0].	^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/11/1999 13:35'!newUpdatesOn: serverList throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ ChangeSorter allChangeSetNames.	existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].			"Replace slashes with underbars"	serverList do: [:server |		doc _ HTTPSocket httpGet: server,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				(existing includes: ff sansPeriodSuffix)					ifFalse:						[itsNumber _ ff integerAtBeginning. 						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 9/24/1998 06:26'!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt _ true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/13/1999 23:21'!readNextUpdateFromServer	"Utilities readNextUpdateFromServer"	self updateFromServerThroughUpdateNumber: (ChangeSorter highestNumberedChangeSet + 1)! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 02:02'!readServerUpdatesSaveLocally: saveLocally updateImage: updateImage	^ self readServerUpdatesThrough: nil saveLocally: saveLocally updateImage: updateImage! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 02:21'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']) throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse:					[doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse:							["(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							updateImage ifTrue:									[ChangeSorter newChangesFromStream: doc									named: (this findTokens: '/') last].							saveLocally ifTrue:								[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"							loaded _ loaded + 1]]]]].	str _ loaded printString ,' new update files processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',						'\Starting with "' withCRs, failed, '".'].	self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 16:13'!saveUpdate: doc onFile: fileName	"Save the update on a local file.  With or without the update number on the front, depending on the preference #updateRemoveSequenceNum"	| file fName pos |	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue:		[pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(FileDirectory default fileExists: fName) ifFalse:		[file _ FileStream newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 9/14/1998 13:27'!serverUrls	"Return the current list of server URLs.  For code updates.  Format of UpdateUrlLists is #( ('squeak updates' ('url1' 'url2'))    ('some other updates' ('url3' 'url4')))"	^ UpdateUrlLists first last! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 16:03'!updateFromServer	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesSaveLocally: Preferences updateSavesFile updateImage: true! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 01:59'!updateFromServerThroughUpdateNumber: aNumber	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesThrough: aNumber saveLocally: Preferences updateSavesFile updateImage: true! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'support windows' stamp: 'di 5/28/1998 12:11'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selection<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 01:53'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(StringHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 02:02'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(StringHolder new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!Utilities class methodsFor: 'support windows' stamp: 'sw 9/22/1998 16:44'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 5000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.(FileStream oldFileNamed: 'DryRot.cs') edit.(FileStream oldFileNamed: 'change.cs') fileInChangeList browseFile: 'Elvis.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspectSystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 11/25/1998 22:31'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in _ (FileStream oldFileNamed: fileName) binary.	out _  (FileStream newFileNamed: fileName, '.lf') binary.	justPutCR _ false.	[in atEnd] whileFalse: [		c _ in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR _ true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR _ false]].	in close.	out close.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'di 11/10/1998 10:24'!emergencyCollapse	World ifNotNil: [^ self].	ScheduledControllers screenController emergencyCollapse! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/22/1998 17:12'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream oldFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream oldFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 10/13/1998 13:38'!timeStampForMethod: method	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file, or nil if none is found"	| position preamble tokens stamp file tokenCount |	method fileIndex == 0 ifTrue: [^ nil].	position _ method filePosition.	file _ (SourceFiles at: method fileIndex) readOnlyCopy.	file position: (0 max: position - 150).  "Skip back to before the preamble"		[file position < (position - 1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		stamp _ nil.		tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp _ tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokenCount]].	file close.	^ stamp! !!Utilities class methodsFor: 'common requests' stamp: 'sw 10/15/1998 15:14'!closeAllDebuggers	"Utilities closeAllDebuggers"	Smalltalk isMorphic	ifTrue:		[(SystemWindow allSubInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w delete]]	ifFalse:		[(StandardSystemController allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w closeAndUnscheduleNoTerminate]]! !!Utilities class methodsFor: 'common requests' stamp: 'di 9/22/1998 16:06'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw	 5/10/96 sw: converted over to new format of StringHolder"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapseUtilities closeAllDebuggersSensor keyboardCursor normal show----------------------------------ScriptingSystem inspectFormDictionaryPreferences enable: #showTimeStampsInMenuTitlesPreferences enable: #cmdDotEnabledForm fromUser bitEditDisplay border: (0@0 extent: 640@480) width: 2----------------------------------Undeclared inspectUndeclared removeUnreferencedKeys; inspectTranscript clearChangeSorter removeEmptyUnnamedChangeSets'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/1998 17:41'!actualTextStyles   "Utilities actualTextStyles"	| aCollection |	aCollection _ OrderedCollection new.	(TextConstants select: [:anItem | anItem isKindOf: TextStyle]) do:		[:aStyle | aCollection add: aStyle].	^ aCollection! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/5/1998 17:58'!chooseFileWithSuffixFromList: aSuffixList withCaption: aCaption	"Pop up a list of all files in the default directory which have a suffix in the list.  Return #none if there are none; return nil if the user backs out of the menu without making a choice."	"Utilities chooseFileWithSuffixFromList: #('.gif' '.jpg')"	| aList aName |	aList _ OrderedCollection new.	aSuffixList do:		[:aSuffix | aList addAll: (FileDirectory default fileNamesMatching: '*', aSuffix)].	^ aList size > 0		ifTrue:			[aName _ (SelectionMenu selections: aList) startUpWithCaption: aCaption.			aName]		ifFalse:			[#none]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 9/23/1998 02:03'!fontSizeSummary	"Utilities fontSizeSummary"	| aStream aList |	aStream _ ReadWriteStream on: ''.	aList _ Utilities knownTextStyles.	aList do: [:aStyleName |		aStream nextPutAll:			aStyleName, '  ',			(Utilities fontSizesFor: aStyleName) asArray storeString.		aStream cr].	(StringHolder new contents: aStream contents)		openLabel: 'Font styles and sizes'! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/1998 14:09'!graphicsFileSuffixes	"Answer a list of filename suffixes which signal file content which we are able to internalize"	^#('.gif' '.bmp' '.jpg' '.jpeg' '.jpe', '.form')! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:49'!windowFromMenu: aMenu target: aTarget title: aTitle	"Supply a default list of colors"	^ self windowFromMenu: aMenu target: aTarget title: aTitle		colorPattern: #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange)! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:48'!windowFromMenu: aMenu target: aTarget title: aTitle colorPattern: aColorPattern	| labelList targetList selectionList i |	selectionList _ aMenu selections.	labelList _ (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList _  (1 to: selectionList size) collect: [:ind | aTarget].	(i _ labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList _ selectionList copyReplaceFrom: i to: i with: Array new.		labelList _ labelList copyReplaceFrom: i to: i with: Array new.		targetList _ targetList copyReplaceFrom: i to: i with: Array new].	self windowMenuWithLabels:  labelList colorPattern: aColorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 11/2/1998 14:27'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ WorldMorph new.	colorList _  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents: newContents	contents _ newContents.	self changed: #contents! !!VariableNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:13'!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color blue)		do: [aStream nextPutAll: name].! !!VariableNode methodsFor: 'C translation' stamp: 'jm 11/25/1998 18:44'!asTranslatorNode	name = 'true' ifTrue: [^ TConstantNode new setValue: true].	name = 'false' ifTrue: [^ TConstantNode new setValue: false].	^ TVariableNode new setName: name! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35'!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!colorSeesPhrase	| outerPhrase |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	outerPhrase addMorphBack: ColorSeerTile new.	(outerPhrase submorphs at: 2) goBehind.		"Make it third"	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:25'!controlButtonColor	^ Color blue muchLighter! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph	| pal |	aMorph player == scriptedPlayer ifTrue:		[(pal _ self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!Viewer methodsFor: 'all' stamp: 'sw 12/4/1998 15:46'!objectViewed	^ scriptedPlayer costume! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 20:32'!obtainBankInfoFrom: anotherViewer	"Grandfathered in from old archictecture.   Probably dubious"! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:56'!scriptedPlayer	^ scriptedPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/20/1998 13:20'!scriptedPlayer: aPlayer	scriptedPlayer _ aPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:09'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/23/1998 09:10'!setPlayer: aPlayer	"bridging to old interface"	self initializeFor: aPlayer! !!Viewer methodsFor: 'copying' stamp: 'tk 1/7/1999 17:01'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.scriptedPlayer _ deepCopier references at: scriptedPlayer ifAbsent: [scriptedPlayer].! !!Viewer methodsFor: 'copying' stamp: 'tk 1/8/1999 07:42'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.scriptedPlayer _ scriptedPlayer.		"Weakly copied"	"Store into it to satisfy checkVariables"! !Serves as the container for displaying one or more viewers in a tabbed palette.!!ViewerBook methodsFor: 'all' stamp: 'sw 6/19/1998 18:25'!partsViewer	^ submorphs size == 0 ifTrue: [nil] ifFalse: [submorphs first]! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/21/1998 23:21'!repelsMorph:  aMorph event: evt	^ true! !!ViewerBook methodsFor: 'all' stamp: 'sw 10/19/1998 23:21'!setPlayer: aPlayer	| aPartsViewer |	"caution: returns an object not yet visible"	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "deploy viewer cache soon"	aPlayer costume pasteUpMorph "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky visible: false).		aPartsViewer setPlayer: aPlayer.	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1.	currentPage _ aPartsViewer.	^ aPartsViewer! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/11/1998 11:50'!addHelpPane	helpPane ifNotNil: [^ self].	helpPane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	helpPane extent: ((self width - 4) @ (Preferences viewerEditingPaneHeight)).	helpPane scrollBarOnLeft: false; retractable: false.	self addMorphBack: helpPane! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 13:57'!codePaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'menueventuallywillbeuseful'		lines: #(1)		selections: #(beep flash beep flash beep)! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:26'!contents	| aType  newText sel info |	(info _ self userSlotInformation) ifNotNil:		[^ info documentation].	(aType _ self entryType) == #slot ifTrue: "system-defined slot"		[^ ScriptingSystem helpStringFor: self slotName].	aType == #script ifTrue:		[sel _ self phraseTileMorph submorphs second operatorOrExpression.		newText _ (Preferences showScriptSource or: [self playerBearingCode class tileScriptNames includes: sel])			ifTrue:				[self playerBearingCode sourceCodeFor: sel]			ifFalse:				[ScriptingSystem scriptHelpFor: sel]].	^ newText ifNil: ['?????']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:14'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	| info |	(info _ self userSlotInformation)		ifNotNil:			[info documentation: c.			^ true].	self beep.	^ false! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 09:31'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 21:04'!detailButtonPressed	helpPane		ifNotNil:			[helpPane delete.			helpPane _ nil]		ifNil:			[self addHelpPane]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!entryType	^ self viewerRow entryType! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/11/1998 11:53'!initialize	super initialize.	color _ Color r: 1.0 g: 0.985 b: 0.985.	inset _ 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:34'!phraseTileMorph	"Answer the phraseTileMorph within the receiver"	^ self entryType == #script		ifTrue:			[self viewerRow submorphs fourth]		ifFalse:			[self error: 'slot rows do not contain a phrase tile morph']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:10'!playerBearingCode	^ self viewerRow playerBearingCode! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 20:56'!rootForGrabOf: aMorph	^ aMorph == self		ifTrue: [nil]		ifFalse:	[super rootForGrabOf: aMorph]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow submorphs sixth operatorOrExpression! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	(self entryType == #slot)		ifFalse:			[^ nil].	aSlotName _ self slotName.	^ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!viewerRow	"Answer the ViewerRow object, that contains the controls and the phraseTile"	^ submorphs first! !!ViewerRow methodsFor: 'all' stamp: 'sw 1/13/1999 23:11'!addDetailButton	| aButton |	aButton _ SimpleButtonMorph new		target: self;		actionSelector: #detail;		beTransparent;		borderWidth: 0;		setBalloonText: 'detail';		label: ''.	self addMorphFront: aButton! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 09:16'!detail	owner detailButtonPressed! !!ViewerRow methodsFor: 'all' stamp: 'sw 10/27/1998 21:27'!entryType	"systemSlot userSlot systemScript userScript, eventually?!!"	| keyElement |	keyElement _ submorphs second submorphs first contents.	keyElement = '!!' ifTrue: [^ #script].	keyElement = '' ifTrue: [^ #slot].	^ #unknown! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/7/1998 22:31'!initialize	super initialize.	inset _ 1! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 10:17'!playerBearingCode	^ submorphs fourth associatedPlayer! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/9/1998 15:57'!rootForGrabOf: aMorph	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ nil].	^ aMorph fullCopy isPartsDonor: false! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 17:29'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol _ points last y * decayScale.			mSecsForChange _ 0.			nextRecomputeTime _ mSecs + 1000000.			^ self].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime _ loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 4.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 9/10/1998 07:04'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 08:00'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale _ aNumber asFloat.! !This tool was created to aid in the preparation of LoopedSampledSound objects. It includes support for finding good loop points with a little help from the user.  Namely, the user must identify a good ending point for the loop (typically just before the decay phase begins) and identify one cycle of the waveform. After that, the  "choose loop point" menu command can be invoked to search backwards to find and rank all possible loop starting points. Some experimentation is usually required to find a loop that "breaths" in a natural way.This tool can also be used as a general viewer of numerical sequences of any kind, such as time-varying functions, FFT data, etc.!!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 09:16'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';					actionSelector: #delete).	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';				actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After';			actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Play Loop';			actionSelector: #playLoop).	r addMorphBack: (b fullCopy label: 'Test';				actionSelector: #playTestNote).	r addMorphBack: (b fullCopy label: 'Save';				actionSelector: #saveInstrument).	r addMorphBack: (b fullCopy label: 'Set Loop End';		actionSelector: #setLoopEnd).	r addMorphBack: (b fullCopy label: 'One Cycle';			actionSelector: #setOneCycle).	r addMorphBack: (b fullCopy label: 'Set Loop Start';		actionSelector: #setLoopStart).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m _ Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 8/17/1998 20:31'!addLoopPointControls	| r m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Loop end: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop length: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop cycles: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Frequency: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 08:27'!initialize	super initialize.	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"	self extent: 5@5;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ GraphMorph new extent: 450@100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:43'!chooseLoopStart	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...'			during: [possibleLoopStarts _ self findPossibleLoopStartsFrom: graph cursor]].	bestLoops _ possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu _ CustomMenu new.	bestLoops do: [:entry |		secs _ ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: secs printString, ' secs' action: entry].	choice _ menu startUp.	choice ifNil: [^ self].	loopCycles _ choice at: 3.	start _ self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:04'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('play straight through'		play)		('play before cursor'		playBeforeCursor)		('play after cursor'			playAfterCursor)		('play test note'				playTestNote)		('play loop'					playLoop)		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		('choose loop start'			chooseLoopStart)		('jump to loop start'			jumpToLoopStart)		('jump to loop end'			jumpToLoopEnd)		('make unlooped'			setUnlooped)		('make unpitched'			setUnpitched)		('show envelope'			showEnvelope)		('show FFT'					showFFTAtCursor)).	aMenu invokeOn: self defaultSelection: nil.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:42'!jumpToLoopEnd	graph cursor: loopEnd; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 10:09'!jumpToLoopStart	graph cursor: (loopEnd - loopLength) truncated; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 09:23'!play	graph data size < 2 ifTrue: [^ self].	(SampledSound samples: graph data samplingRate: samplingRate) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:40'!playAfterCursor	self playFrom: graph cursor to: graph data size.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:39'!playBeforeCursor	self playFrom: 1 to: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz _ graph data size.	i1 _ ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 _ (loopEnd min: sz) max: i1.	len _ (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd _ LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data _ graph data.	end _ (loopEnd min: data size) max: 1.	snd _ LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur _ (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur _ (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 14:24'!saveInstrument	| name data end snd basePitch |	name _ FillInTheBlank request: 'Instrument name?'.	name isEmpty ifTrue: [^ self].	data _ graph data.	((loopEnd = 0) or: [loopLength = 0])		ifTrue: [  "save as unlooped"			loopLength * loopCycles = 0				ifTrue: [basePitch _ 100.0]				ifFalse: [basePitch _ (samplingRate * loopCycles) / loopLength].			snd _ LoopedSampledSound new				unloopedSamples: data pitch: basePitch samplingRate: samplingRate]		ifFalse: [			end _ (loopEnd min: data size) max: 1.			basePitch _ (samplingRate * loopCycles) / loopLength.			snd _ LoopedSampledSound new				samples: data loopEnd: end loopLength: loopLength				pitch: basePitch samplingRate: samplingRate].	snd addReleaseEnvelope.	AbstractSound soundNamed: name put: snd.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 11:06'!setLoopEnd	graph cursor: (self zeroCrossingAfter: graph cursor) - 1.	self loopEnd: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 08:21'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start _ graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.'].	len _ (loopEnd - start) + 1.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len _ loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles _ 1.		self loopLength: len].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength _ 0.	loopCycles _ 1.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength _ 0.	loopCycles _ 0.	perceivedFrequency _ 100.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuanta."	| data mSecsPerQuanta samplesPerQuanta result endOfQuanta maxThisQuanta s |	data _ graph data.	mSecsPerQuanta _ 10.	samplesPerQuanta _ (mSecsPerQuanta / 1000.0) * self samplingRate.	result _ WriteStream on: (Array new: data size // samplesPerQuanta).	endOfQuanta _ samplesPerQuanta.	maxThisQuanta _ 0.	1 to: data monoSampleCount do: [:i |		i asFloat > endOfQuanta ifTrue: [			result nextPut: maxThisQuanta.			maxThisQuanta _ 0.			endOfQuanta _ endOfQuanta + samplesPerQuanta].		s _ data at: i.		s < 0 ifTrue: [s _ 0 - s].		s > maxThisQuanta ifTrue: [maxThisQuanta _ s]].	WaveEditor openOn: result contents.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:21'!showFFTAtCursor	| data start availableSamples nu n fft r |	data _ graph data.	start _ graph cursor max: 1.	availableSamples _ (data size - start) + 1.	nu _ 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.'].	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r _ (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	WaveEditor openOn: r.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:48'!trimAfterCursor	graph data: (graph data copyFrom: 1 to: graph cursor).! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:52'!trimBeforeCursor	graph data: (graph data copyFrom: graph cursor to: graph data size).	graph cursor: 1.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/5/1998 12:43'!data: newData	graph data: newData.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/3/2004 18:16'!graph	^ graph! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 09:48'!loopCycles	^ loopCycles! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles _ aNumber.	self loopLength: loopLength.  "updates frequency"! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 6/30/1998 17:20'!loopEnd	^ loopEnd! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd _ (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts _ nil.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 08:38'!loopLength	^ loopLength! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength _ aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency _ samplingRate asFloat * loopCycles / loopLength].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 10:08'!loopStart	^ (loopEnd - loopLength) truncated + 1! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start _ self fractionalLoopStartAt: index.	len _ (loopEnd asFloat - start) + 1.0.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:31'!perceivedFrequency	^ perceivedFrequency! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency _ aNumber.	(loopCycles > 0) ifTrue: [		loopLength _ samplingRate asFloat * loopCycles / perceivedFrequency].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate	^ samplingRate! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate _ samplesPerSecond.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data _ graph data.	error _ 0.	i1 _ index1.	index2 to: (index2 + length - 1) do: [:i2 |		e _ (data at: i1) - (data at: i2).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e.		i1 _ i1 + 1].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error _ 0.	1 to: sampleArray1 size do: [:i |		e _ (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:25'!findPossibleLoopStartsFrom: index	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r _ OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart _ loopEnd + 1.  "Assumed to be a zero-crossing."	i _ self zeroCrossingAfter: postLoopCycleStart + (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength _ i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i _ self zeroCrossingAfter: postLoopCycleStart - (1.1 * postLoopCycleLength) asInteger.	cycleLength _ postLoopCycleStart - i.	cycleCount _ 1.	[cycleLength > 0] whileTrue: [		err _ self autoCorrolationBetween: i and: postLoopCycleStart length: postLoopCycleLength.		r add: (Array				with: i				with: err				with: cycleCount				with: (((loopEnd - i) asFloat / self samplingRate) roundTo: 0.01)).		oldI _ i.		i _ self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.		cycleLength _ oldI - i.  "will be zero when start of data is encountered"		cycleCount _ cycleCount + 1].	r _ r asSortedCollection: [:e1 :e2 | (e1 at: 2) < (e2 at: 2)].	^ r asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle _ (samplingRate / perceivedFrequency) rounded.	w1 _ self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr _ SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 _ self interpolatedWindowAt: i width: oneCycle.		err _ self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex _ i.			minErr _ err]].	^ bestIndex! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale _ 10000.	data _ graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex _ index truncated.	scaledFrac _ ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac _ scale - scaledFrac.	prevSample _ data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample _ data at: i.		v _ ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample _ nextSample.		v].! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/19/1998 15:03'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/30/1998 16:11'!scrollTime: relativeValue	graph startIndex: relativeValue * (graph data size - (graph width // 2)).! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data _ graph data.	end _ data size.	index <= 1 ifTrue: [^ 1].	i _ index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i _ i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i _ i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i _ i + 1].  "find next non-negative sample"	^ i! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 21:04'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	(self new data: dataCollection) openInWorld.! !WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'class initialization' stamp: 'ar 10/7/1998 16:45'!initialize	"WeakArray initialize"	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	"Check if Finalization is supported by this VM"	IsFinalizationSupported _ nil.	self isFinalizationSupported ifFalse:[^self].	FinalizationProcess notNil ifTrue:[FinalizationProcess terminate].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents isNil ifTrue:[		FinalizationDependents := WeakArray new: 10.	].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] newProcess.	FinalizationProcess priority: Processor userInterruptPriority.	FinalizationProcess resume.! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!addWeakDependent: anObject	| finished index weakDependent |	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject _ WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported _false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported _ (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!removeWeakDependent: anObject	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/8/1998 11:19'!finalizationProcess	[true] whileTrue:[		FinalizationSemaphore wait.		FinalizationLock critical:[			FinalizationDependents do:[:weakDependent|				weakDependent isNil 					ifFalse:[weakDependent finalizeValues].			].		] ifError:[:msg :rcvr| rcvr error: msg].	].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/7/1998 15:24'!pvtCreateTemporaryObjectIn: tempObject	"We have to create the temporary object in a separate stack frame"	tempObject at: 1 put: Object new! !I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:47'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:44'!key: aKey value: anObject	key := WeakArray with: key.	value := anObject.! !I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 3/21/98 16:15'!finalizeValues	"default action is to re-hash the receiver and to remove nil-keys"	self rehash.	self removeKey: nil ifAbsent:[].! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 3/22/98 00:21'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf := self species new: self size.	self associationsDo:[:each| newSelf noCheckAdd: each].	array := newSelf array.	tally := newSelf size.! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ar 3/22/98 00:19'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/21/98 16:33'!size	^self protected:[		valueDictionary size	].! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'private' stamp: 'ar 10/8/1998 11:18'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !I am an association holding only weakly on my value.!!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:53'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:55'!value	^value isNil		ifTrue:[nil]		ifFalse:[value at: 1]! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !I am a dictionary holding only weakly on my values. Clients may expect to get a nil value for any object they request.!!WeakValueDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:02'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !IntegerArrays store 32bit unsigned Integer values.!!WordArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asWordArray	^self! !!WordArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 10/16/1998 18:49'!configureForConstruction	| aPanel aCan |	self addMorph: (self presenter standardPartsWindow position: 10@10).	presenter standardPlayer.	aPanel _ presenter controlPanel.	self addMorph: aPanel.	self positionControlPanel: aPanel.	aCan _ self presenter addTrashCan.	aCan position: (Display boundingBox bottomRight - aCan extent).  "This oddity necessary to avoid the trashcan's showing up at top-left until an ownerChanged is sent to it; the problem is that addTrashCan: is called too early otherwise."! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 07:29'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	balloonHelpEnabled _ true.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 9/21/1998 17:55'!openWithTitle: aString cautionOnClose: aBoolean	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString cautionOnClose: aBoolean! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/3/1998 14:12'!positionControlPanel: aPanel	| referencePos |	referencePos _ bounds width > 200		ifTrue:		[bounds bottomRight]		ifFalse:		[Display boundingBox bottomRight].	aPanel position:  (referencePos - ((70 + aPanel width) @ (aPanel height + 4)))! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!exit	self sleep.	Project current exit.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!goBack	self sleep.	Project returnToPreviousProject.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 9/10/1998 16:38'!sleep	canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this project to save space?']) ifTrue: [self clearTurtleTrails].	self canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 8/16/1998 00:12'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'sw 1/11/1999 17:39'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: viewBox extent).	damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'drawing' stamp: 'di 12/31/1998 10:31'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!WorldMorph methodsFor: 'events' stamp: 'jm 6/10/1998 07:57'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.	evt hand invokeMetaMenu: evt.! !!WorldMorph methodsFor: 'stepping' stamp: 'sw 8/21/1998 16:32'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: self]]! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/14/1998 12:56'!activeHand: aHandMorph	activeHand _ aHandMorph! !!WorldMorph methodsFor: 'change reporting' stamp: 'di 9/29/1998 21:08'!invalidRect: damageRect	"Record the given rectangle in the damage list."	damageRecorder == nil ifTrue: [^ self].	damageRecorder recordInvalidRect: damageRect.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 12/23/1998 10:54'!doOneCycle	self interCyclePause: MinCycleLapse.	self doOneCycleNow.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 1/2/1999 20:53'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 1/2/1999 20:53'!interCyclePause: milliSecs	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	currentTime _ Time millisecondClockValue.	lastCycleTime ifNotNil: [ 		wait _ lastCycleTime + milliSecs - currentTime.		wait > 0 ifTrue: [ 			wait < milliSecs  "big waits happen after a snapshot"				ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ].	lastCycleTime _ currentTime! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 8/22/1998 22:45'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	refPoint _ (aPalette _ self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/2/1998 11:51'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point.	NOTE: due to some bounds wobble in flexing, we take the middle of 3x3 rect."	^ (self patchAt: (aPoint-1 extent: 3) without: aMorph andNothingAbove: true)		colorAt: 1@1! !!WorldMorph methodsFor: 'sensing' stamp: 'di 11/10/1998 11:41'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	submorphs reverseDo:		[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ c form]]				ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)							ifTrue: [^ c form]]].  	hands reverseDo: [:h |		h submorphsReverseDo:		[:m | m == stopMorph			ifTrue: [stopThere ifTrue: [^ c form]]			ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)						ifTrue: [^ c form]]]].  	^ c form! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'sw 7/19/1998 12:46'!addMorphsAndModel: aMorphOrList	"Dump in submorphs, model, and stepList from aMorphOrList.  Used to bring a world, paste-up, or other morph in from an object file."	aMorphOrList isMorph		ifTrue:			[aMorphOrList isWorldMorph				ifFalse:					["one morph, put on hand"					"aMorphOrList installModelIn: self.  	a chance to install model pointers"					aMorphOrList privateOwner: nil.					self hands first attachMorph: aMorphOrList.					self startSteppingSubmorphsOf: aMorphOrList]				ifTrue: 					[model == nil						ifTrue:							[self setModel: (aMorphOrList modelOrNil)]						ifFalse:							[aMorphOrList modelOrNil ifNotNil:								[aMorphOrList modelOrNil privateOwner: nil.								self addMorph: (aMorphOrList modelOrNil)]].					aMorphOrList privateSubmorphs reverseDo: [:m |						m privateOwner: nil.						self addMorph: m.						m changed].					(aMorphOrList instVarNamed: 'stepList') do:						[:entry | entry first startSteppingIn: self]]]		ifFalse:  "list, add them all"			[aMorphOrList reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				self startSteppingSubmorphsOf: m.	"It may not want this!!"				m changed]]! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 1/7/1999 14:29'!veryDeepCopyWith: deepCopier	"If a WorldMorph really needs to be veryDeepCopied, only copy submorphs, model, and stepList.  Lots of special stuff.  See storeDataOn:"	^ self error: 'Worlds should not be copied'	"maybe ^ self later?  For now, catch all offenders."! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 6/25/1998 08:35'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts."	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:)				(mouseX			number		readOnly	getMouseX			unused)				(mouseY		number		readOnly	getMouseY			unused))]		ifFalse:			[Array new]! !!WorldMorph methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 17:11'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcebbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' 'balloonHelpEnabled' ) and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 7/15/1998 19:39'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' ) and deal with the information in ()"! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:56'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' 'lastCycleTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('balloonHelpEnabled' ) and deal with the information in ()"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 20:33'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'lastCycleTime' 'balloonHelpEnabled' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!balloonHelpEnabled	^ balloonHelpEnabled ~~ false! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!toggleShowBalloons	balloonHelpEnabled _ self balloonHelpEnabled not! !!WorldMorph class methodsFor: 'all' stamp: 'ls 7/13/1998 00:44'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!WorldMorph class methodsFor: 'all' stamp: 'ls 9/20/1998 11:36'!initialize	"WorldMorph initialize"	self MinCycleLapse: 20.		"allows 50 frames per second..."! !!WorldMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 18:51'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aPanel aWindow |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aPanel _ aWorld presenter controlPanel.	aWorld addMorph: aPanel.	aWorld positionControlPanel: aPanel.	aWorld addMorph: (aWindow _ aWorld presenter standardPartsWindow position: 10@10).	aWindow activate.	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !Serves as a model for a WorldView -- a morphic world viewed within an mvc project.!!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:50'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	^ (0@0 extent: DisplayScreen actualScreenSize) copy! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent	initialExtent ifNotNil: [^ initialExtent].	^ super initialExtent! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent: anExtent	initialExtent _ anExtent! !!WriteStream methodsFor: 'accessing' stamp: 'ls 8/20/1998 10:19'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse: [		^super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue: [		collection _ collection,			(collection species new: (newEnd - writeLimit + (collection size max: 20)) ).		writeLimit _ collection size ].	collection replaceFrom: position+1 to: newEnd  with: aCollection.	position _ newEnd.! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit _ position _ 0.! !This class can be used to read from ZLib compressed streams. For more information see the RFC1950 "ZLIB Compressed Data Format Specification version 3.3" available for instance from	http://www.leo.org/pub/comp/doc/standards/rfc/index.html!!ZLibStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 21:04'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !!ZoomMorph class methodsFor: 'as yet unclassified' stamp: 'di 10/6/1998 13:15'!includeInNewMorphMenu	"Zooms aren't meaningful without initializations"	^ false! !	Smalltalk condenseChanges!----QUIT----(15 January 1999 11:31:38 am ) priorSource: 3592334!'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 3:44:01 pm'!"Change Set:		TTFcontainsPoint-arDate:			15 January 1999Author:			Andreas RaabFixes the behavior of TTSampleStringMorph>>containsPoint:"!!TTSampleStringMorph methodsFor: 'geometry' stamp: 'ar 1/15/1999 15:40'!containsPoint: aPoint	| picker |	(self bounds containsPoint: aPoint) ifFalse:[^false].	picker _ BalloonCanvas on: (Form extent: 1@1 depth: 32).	picker transformBy: (MatrixTransform2x3 withOffset: aPoint negated).	self drawOn: picker.	^(picker form bits at: 1) ~= 0! !'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 9:08:55 am'!"Change Set:		InterpChgsDate:			15 January 1999Author:			Ian PiumartaDebugging and Jitter interface methods."!!Interpreter methodsFor: 'debug support' stamp: '' prior: 35259609!okayInterpreterObjects	| oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: activeContext.	self okayFields: method.	self okayFields: receiver.	self okayFields: theHomeContext.	self okayFields: messageSelector.	self okayFields: newMethod.	self okayFields: lkupClass.	0 to: MethodCacheEntries - 1 by: MethodCacheEntrySize do: [ :i |		oopOrZero _ methodCache at: i + MethodCacheSelector.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i + MethodCacheSelector).			self okayFields: (methodCache at: i + MethodCacheClass).			self okayFields: (methodCache at: i + MethodCacheMethod).		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.! !!Interpreter methodsFor: 'compiler support'!bytecodeExecuteNewMethod	primitiveIndex > 0 ifTrue: [		self primitiveResponse.		successFlag ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self bytecodeActivateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 4:39:40 pm'!"Change Set:		MTMcontainsPoint-arDate:			15 January 1999Author:			Andreas RaabFixes the picking behavior of MatrixTransformMorph."!!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 1/15/1999 16:34' prior: 35760953!containsPoint: aPoint	self visible ifFalse:[^false].	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullContainsPoint: (self transform globalPointToLocal: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 5:53:14 pm'!"Change Set:		SystemStartupListDate:			15 January 1999Author:			Andreas RaabAdds two globals:	SystemStartupList - an OrderedCollection of classes that want to receive a #startUp message on system startup.	SystemShutdownList - an OrderedCollection of classes that want to receiver #shutDown on system shutdown.The lists are processed in order so one can assure the startUp of a dependent class by adding it before or after this class."Smalltalk at:#SystemShutdownList put: OrderedCollection new.Smalltalk at:#SystemStartupList put: OrderedCollection new.!!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 1/15/1999 17:19' prior: 36803232!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #MailDB ifPresent: [:mailDB |		mailDB allInstancesDo: [:db | db saveDB]].  "snapshot all mail databases to disk"	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	Smalltalk at: #HttpUrl ifPresent: [:urlClass | urlClass shutDown].	self shutDownSound.	SystemShutdownList do:[:class| class shutDown].	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 1/15/1999 17:18' prior: 36803959!processStartUpList	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."	DisplayScreen startUp.	FileDirectory startUp.	CrLfFileStream startUp.	Cursor startUp.	Smalltalk installLowSpaceWatcher.	InputSensor startUp.	ProcessorScheduler startUp.	Delay startUp.	Smalltalk startUp.	"Process the global startup list"	SystemStartupList do:[:class| class startUp].	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [ControlManager startUp].! !'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 5:53:18 pm'!"Change Set:		ShortArrayFixesDate:			15 January 1999Author:			Andreas RaabFixes byte order problems with the short integer classes in Balloon"!ArrayedCollection variableWordSubclass: #ShortIntegerArray	instanceVariableNames: ''	classVariableNames: 'LastSaveOrder '	poolDictionaries: ''	category: 'Balloon-Collections'!ArrayedCollection variableWordSubclass: #ShortRunArray	instanceVariableNames: ''	classVariableNames: 'LastSaveOrder '	poolDictionaries: ''	category: 'Balloon-Collections'!!ShortIntegerArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:35'!pvtAt: index	"Private -- for swapping only"	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:35'!pvtAt: index put: value	"Private -- for swapping only"	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:37'!swapShortObjects	"Private -- swap all the short quantities in the receiver"	| tmp |	1 to: self basicSize do:[:i|		tmp _ (self pvtAt: i * 2).		self pvtAt: i * 2 put: (self pvtAt: i * 2 - 1).		self pvtAt: i * 2 - 1 put: tmp.	]! !!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:31'!initialize	"ShortIntegerArray initialize"	(SystemStartupList includes: self) ifFalse:[		SystemStartupList add: self.	].	LastSaveOrder _ self new: 2.	LastSaveOrder at: 1 put: 42.	LastSaveOrder at: 2 put: 13.! !!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:51'!obsolete	"I am obsolete  - remove me from the startup list"	SystemStartupList remove: self ifAbsent:[].	^super obsolete! !!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:33'!startUp	"Check if the word order has changed from the last save"	((LastSaveOrder at: 1) = 42 and:[(LastSaveOrder at: 2) = 13]) 		ifTrue:[^self]. "Okay"	((LastSaveOrder at: 2) = 42 and:[(LastSaveOrder at: 1) = 13]) 		ifTrue:[^self swapShortObjects]. "Reverse guys"	^self error:'This must never happen'! !!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:40'!swapShortObjects	self allSubInstancesDo:[:inst| inst swapShortObjects]! !!ShortIntegerArray class methodsFor: 'instance creation' stamp: 'ar 1/15/1999 17:28'!new: n	^super new: n + 1 // 2! !!ShortPointArray class methodsFor: 'instance creation' stamp: 'ar 1/15/1999 17:40'!new: n	^super new: n * 2! !!ShortRunArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:47'!pvtAt: index	"Private -- for swapping only"	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:47'!pvtAt: index put: value	"Private -- for swapping only"	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 1/15/1999 17:48'!swapRuns	"Private -- swap length/value pairs in the receiver"	| tmp |	1 to: self basicSize do:[:i|		tmp _ (self pvtAt: i * 2).		self pvtAt: i * 2 put: (self pvtAt: i * 2 - 1).		self pvtAt: i * 2 - 1 put: tmp.	]! !!ShortRunArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:45'!initialize	"ShortRunArray initialize"	(SystemStartupList includes: self) ifFalse:[		SystemStartupList add: self.	].	LastSaveOrder _ #(42 42 42) as: self.! !!ShortRunArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:51'!obsolete	"I am obsolete  - remove me from the startup list"	SystemStartupList remove: self ifAbsent:[].	^super obsolete! !!ShortRunArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:46'!startUp	"Check if the word order has changed from the last save"	((LastSaveOrder valueAtRun: 1) = 42 and:[(LastSaveOrder lengthAtRun: 1) = 3]) 		ifTrue:[^self]. "Okay"	((LastSaveOrder lengthAtRun: 1) = 42 and:[(LastSaveOrder valueAtRun: 1) = 3]) 		ifTrue:[^self swapRuns]. "Reverse guys"	^self error:'This must never happen'! !!ShortRunArray class methodsFor: 'class initialization' stamp: 'ar 1/15/1999 17:47'!swapRuns	self allSubInstancesDo:[:inst| inst swapRuns]! !ShortIntegerArray initialize!ShortRunArray initialize!'From Squeak 2.3 beta of Nov 25, 1998 on 15 January 1999 at 11:46:27 am'!!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/15/1999 11:44'!alpha: alphaValue	alphaValue = 1.0 ifTrue:		[^ Color basicNew			setPrivateRed: self privateRed			green: self privateGreen			blue: self privateBlue].	^ super alpha: alphaValue! !----QUIT----(15 January 1999 12:04:35 pm ) priorSource: 3592363!