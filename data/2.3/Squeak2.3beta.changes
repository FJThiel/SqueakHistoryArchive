'From Squeak 2.2 of Sept 23, 1998 on 23 September 1998 at 5:10:01 pm'!I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 20:06'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	f _ (FileStream readOnlyFileNamed: fileName) binary.	self readFrom: f.	f close.! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/17/1998 20:36'!edit	| ed |	ed _ WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/2/1998 19:26'!play	"Play the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	snd play.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 7/12/1998 18:24'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."	| compressionType |	channelCount _ in nextNumber: 2.	frameCount _ in nextNumber: 4.	bitsPerSample _ in nextNumber: 2.	samplingRate _ self readExtendedFloat.	chunkSize > 18 ifTrue: [		fileType = 'AIFF'			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].		compressionType _ (in next: 4) asString.		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 11:43'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp _ in nextNumber: 2.	mantissa _ in nextNumber: 8.  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign _ 1.0]		ifFalse: [sign _ -1.0].	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 19:58'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in _ aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz _ in nextNumber: 4.	end _ in position + sz.	fileType _ (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType _ (in next: 4) asString.		chunkSize _ in nextNumber: 4.		p _ in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/5/1998 17:31'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey _ in next.	detune _ in next.	lowNote _ in next.	highNote _ in next.	lowVelocity _ in next.	highVelocity _ in next.	gain _ in nextNumber: 2.	sustainMode _ in nextNumber: 2.	sustainStartID _ in nextNumber: 2.	sustainEndID _ in nextNumber: 2.	releaseMode _ in nextNumber: 2.	releaseStartID _ in nextNumber: 2.	releaseEndID _ in nextNumber: 2.	isLooped _ sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped _ false]].	pitch _ self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 21:22'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount _ in nextNumber: 2.	markers _ Array new: markerCount.	1 to: markerCount do: [:i |		id _ in nextNumber: 2.		position _ in nextNumber: 4.		labelBytes _ in next.		label _ (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:58'!readMergedStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."	| buf w1 w2 |	buf _ channelData at: 1.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w1 _ s next.				w1 > 127 ifTrue: [w1 _ w1 - 256].				w2 _ s next.				w2 > 127 ifTrue: [w2 _ w2 - 256].				buf at: i put: ((w1 + w2) bitShift: 7)]]		ifFalse: [			1 to: frameCount do: [:i |				w1 _ (s next bitShift: 8) + s next.				w1 > 32767 ifTrue: [w1 _ w1 - 65536].				w2 _ (s next bitShift: 8) + s next.				w2 > 32767 ifTrue: [w2 _ w2 - 65536].				buf at: i put: ((w1 + w2) bitShift: -1)]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:53'!readMonoChannelDataFrom: s	"Read monophonic channel data from the given stream. Each frame contains a single sample."	| buf w |	buf _ channelData at: 1.  "the only buffer"	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				buf at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				buf at: i put: w]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:55'!readMultiChannelDataFrom: s	"Read multi-channel data from the given stream. Each frame contains channelCount samples."	| w |	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ s next.					w > 127 ifTrue: [w _ w - 256].					(channelData at: ch) at: i put: (w bitShift: 8)]]]		ifFalse: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ (s next bitShift: 8) + s next.					w > 32767 ifTrue: [w _ w - 65536].					(channelData at: ch) at: i put: w]]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/3/1998 14:55'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples s |	skipDataChunk ifTrue: [in skip: chunkSize. ^ self].	offset _ in nextNumber: 4.	blockSize _ in nextNumber: 4.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples _ chunkSize - 8.	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))		ifFalse: [self error: 'actual sample count does not match COMM chunk'].	(mergeIfStereo and: [channelCount = 2])		ifTrue: [			channelData _ Array with: (SoundBuffer newMonoSampleCount: frameCount)]		ifFalse: [			channelData _				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))		ifTrue: [s _ ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"		ifFalse: [s _ in].  "not enough space to buffer; read directly from file"	"mono and stereo are special-cased for better performance"	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].	channelCount = 2 ifTrue: [		mergeIfStereo			ifTrue: [channelCount _ 1. ^ self readMergedStereoChannelDataFrom: s]			ifFalse: [^ self readStereoChannelDataFrom: s]].	self readMultiChannelDataFrom: s.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:56'!readStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream. Each frame contains two samples."	| left right w |	left _ channelData at: 1.	right _ channelData at: 2.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				left at: i put: (w bitShift: 8).				w _ s next.				w > 127 ifTrue: [w _ w - 256].				right at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				left at: i put: w.				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				right at: i put: w]].! !!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	"Subclasses should override to return the ending time if the event has some duration."	^ time! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isControlChange	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isPitchBend	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isProgramChange	^ false! !!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port. This default implementation does nothing."! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes _ #().! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just after the last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize _ self samplingRate // 10.	buf _ SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/19/1998 08:30'!viewSamples	| stereoBuf |	stereoBuf _ self computeSamplesForSeconds: self duration.	WaveEditor openOn: stereoBuf extractLeftChannel.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange _ false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange _ true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs _ 10]		ifFalse: [			env _ envelopes first.			decayInMs _ env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor _ 2 raisedTo: 15.	FloatScaleFactor _ ScaleFactor asFloat.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave _ PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:00'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch _ el at: 1.				pitch isNumber ifFalse: [pitch _ self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p _ pitchNameOrNumber asFloat]		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].	octave _ -1.	[p >= TopOfBottomOctave] whileTrue: [		octave _ octave + 1.		p _ p / 2.0].	i _ self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i _ i - 1]].	midiKey _ ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey _ 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 7/6/1998 15:47'!pitchTable	"AbstractSound pitchTable"	| out note i |	out _ WriteStream on: (String new: 1000).	i _ 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note _ noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i _ i + 1]].	^ out contents! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	pitch _ aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch _ pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale _ SequentialSound new.	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd _ endPitch asFloat]		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p _ startPitch asFloat]		ifFalse: [p _ AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p _ p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/3/1998 17:00'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale _ self majorPitchesFrom: aPitch.	score _ MixedSound new.	leadingRest _ pan _ 0.	#(1 3 5 8) do: [:noteIndex |		note _ aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest _ leadingRest + 0.2.		pan _ pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:27'!initSounds	"AbstractSound initSounds"	Sounds _ Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:11'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:50'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName refStream |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	refStream _ SmartRefStream fileNamed: fileName, '.sounds'.	refStream nextPut: aDictionary.	refStream close.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:52'!updateScorePlayers	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allInstances do: [:p | p pause].	SoundPlayer shutDown.	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'jm 8/19/1998 14:22'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	"AbstractSound cCodeForSoundPrimitives"	^ CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(ReverbSound applyReverbTo:startingAt:count:)	).! !!AcceptableCleanTextMorph methodsFor: 'all' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 23:09'!byteReverseForm: aForm	"Byte-reverse the words of the given Form's bitmap. Supports porting a Squeak image to the Acorn."	| bits mask pixelDepth dstWord srcWord srcPix nPix |	(aForm isKindOf: Cursor)		ifFalse:[aForm unhibernate].	bits _ aForm bits.	pixelDepth _ aForm depth.	nPix _ 32 // pixelDepth.	1 to: bits size do: [:i |		srcWord _ bits at: i.		mask _ (1 << pixelDepth) - 1.		dstWord _ 0.		1 to: nPix do: [:p|			srcPix _ srcWord bitAnd: mask.			srcWord _ srcWord >> pixelDepth.			dstWord _ ((dstWord << pixelDepth) bitOr: srcPix)].		bits at: i put: dstWord].	(aForm isKindOf: Cursor)		ifFalse:[aForm hibernate]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:48'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	On Acorn, the test is whether systemAttribute 1001 = 'RiscOS' (on newer VMs) or if the primPathNameDelimiter is $. (on older ones), which is what we would like to use for a dirsep if only it would work out. See pathNameDelimiter for more woeful details - then just get on and enjoy Squeak"	| attr |	attr _ Smalltalk getSystemAttribute: 1001.	attr isNil ifFalse:[^attr = 'RiscOS'].	^self primPathNameDelimiter = $.! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/10/1998 21:45'!pathNameDelimiter"Acorn RiscOS uses a dot as the directory separator and has no real concept of filename extensions. We tried to make code handle this, but there are just too many uses of dot as a filename extension - so fake it out by pretending to use a slash. The file prims do conversions instead.Sad, but pragmatic"	^ $/! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/1/199812:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage liveText|	liveText _ HTMLformatter evalEmbedded: (pageRef text)		with: request unlessContains: (self dangerSet).	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: liveText			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: ((self formatterFor: 'page') format: formattedPage).! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/10/199815:33'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!! -- but don't complain!! Could be for ActivePage!!""	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr."! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 21:27'!morph 	^ morph! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:09'!morph: m	morph _ m! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/4/1998 15:47'!occurAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick	(target == nil or: [selector == nil]) ifTrue:		[^ morph encounteredAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick].	target perform: selector withArguments: arguments! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/6/1998 08:07'!relatedPlayer	(morph isMemberOf: MovieFrameSyncMorph)		ifFalse: [^ nil].	^ morph player.	! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:08'!target: t selector: s arguments: a	target _ t.	selector _ s.	arguments _ a.! !!AssignmentTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: ' assign', (assignmentSuffix copyWithout: $:), 'Getter: #'.	aStream nextPutAll: (Utilities getterSelectorFor: assignmentRoot).	aStream nextPutAll: ' setter: #'.	aStream nextPutAll: (Utilities setterSelectorFor: assignmentRoot).	aStream nextPutAll: ' amt: '.! !An asynchronous file allows simple file read and write operations to be performed in parallel with other processing. This is useful in multimedia applications that need to stream large amounts of sound or image data from or to a file while doing other work.!!AsyncFile methodsFor: 'all'!close	fileHandle ifNil: [^ self].  "already closed"	self primClose: fileHandle.	Smalltalk unregisterExternalObject: semaphore.	semaphore _ nil.	fileHandle _ nil.! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!fileHandle	^ fileHandle! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 07:54'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name _ fullFileName.	writeable _ aBoolean.	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	fileHandle _ self primOpen: name forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil.		^ nil].! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 08:28'!readByteCount: byteCount fromFilePosition: fPosition onCompletionDo: aBlock	"Start a read operation to read byteCount's from the given position in this file. and fork a process to await its completion. When the operation completes, evaluate the given block. Note that, since the completion block may run asynchronous, the client may need to use a SharedQueue or a semaphore for synchronization."	| buffer n |	buffer _ String new: byteCount.	self primReadStart: fileHandle fPosition: fPosition count: byteCount.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primReadResult: fileHandle intoBuffer: buffer at: 1 count: byteCount.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].		aBlock value: buffer.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 10:07'!test: byteCount fileName: fileName	"AsyncFile new test: 10000 fileName: 'testData'"	| buf1 buf2 bytesWritten bytesRead |	buf1 _ String new: byteCount withAll: $x.	buf2 _ String new: byteCount.	self open: fileName forWrite: true.	self primWriteStart: fileHandle		fPosition: 0		fromBuffer: buf1		at: 1		count: byteCount.	semaphore wait.	bytesWritten _ self primWriteResult: fileHandle.	self close.		self open: fileName forWrite: false.	self primReadStart: fileHandle fPosition: 0 count: byteCount.	semaphore wait.	bytesRead _		self primReadResult: fileHandle			intoBuffer: buf2			at: 1			count: byteCount.	self close.	buf1 = buf2 ifFalse: [self error: 'buffers do not match'].	^ 'wrote ', bytesWritten printString, ' bytes; ',	   'read ', bytesRead printString, ' bytes'! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!waitForCompletion	semaphore wait! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 17:28'!writeBuffer: buffer atFilePosition: fPosition onCompletionDo: aBlock	"Start an operation to write the contents of the buffer at given position in this file, and fork a process to await its completion. When the write completes, evaluate the given block. Note that, since the completion block runs asynchronously, the client may need to use a SharedQueue or a semaphore for synchronization."	| n |	self primWriteStart: fileHandle		fPosition: fPosition		fromBuffer: buffer		at: 1		count: buffer size.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primWriteResult: fileHandle.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].		n = buffer size ifFalse: [^ self error: 'did not write the entire buffer'].		aBlock value.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:42'!primClose: fHandle	"Close this file. Do nothing if primitive fails."	<primitive: 540>! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:54'!primOpen: fileName forWrite: openForWrite semaIndex: semaIndex	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise."	<primitive: 541>	^ nil! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:28'!primReadResult: fHandle intoBuffer: buffer at: startIndex count: count	"Copy the result of the last read operation into the given buffer starting at the given index. The buffer may be any sort of bytes or words object, excluding CompiledMethods. Answer the number of bytes read. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 542>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:36'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 543>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:27'!primWriteResult: fHandle	"Answer the number of bytes written. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 544>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 08:35'!primWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: startIndex count: count	"Start a write operation of count bytes starting at the given index in the given buffer. The buffer may be any sort of bytes or words object, excluding CompiledMethods. The contents of the buffer are copied into an internal buffer immediately, so the buffer can be reused after the write operation has been started. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 545>	writeable ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!AsyncFile class methodsFor: 'class initialization' stamp: 'jm 6/25/1998 17:33'!initialize	"AsyncFile initialize"	"Possible abnormal I/O completion results."	Busy _ -1.	Error _ -2.! !!AtomMorph methodsFor: 'all' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p _ self position.	vx _ velocity x.		vy _ velocity y.	px _ p x + vx.		py _ p y + vy.	bounced _ false.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.		bounced _ true].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.		bounced _ true].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.		bounced _ true].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.		bounced _ true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !a stream on Text's which keeps track of the last attribute put; new characters are added with those attributes.instance vars:	characters - a WriteStream of the characters in the stream	attributeRuns - a RunArray with the attributes for the stream	currentAttributes - the attributes to be used for new text	attributesChanged - whether the attributes have changed since the last addition!!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'ls 6/27/1998 15:04'!contents	| ans |	ans _ Text new: characters size.	ans setString: characters contents  setRuns: attributeRuns.   "this is declared private, but it's exactly what I need, and it's declared as exactly what I want it to do...."	^ans! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 14:59'!nextPut: aChar	attributesChanged 		ifTrue: [ 			attributeRuns addLast: currentAttributes.			attributesChanged _ false ]		ifFalse: [			attributeRuns  repeatLastIfEmpty: [ OrderedCollection new ] ].	characters nextPut: aChar! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 15:02'!nextPutAll: aString	"add an entire string with the same attributes"	attributesChanged 		ifTrue: [ attributeRuns addLast: currentAttributes times: aString size.			attributesChanged _ false. ]		ifFalse: [ attributeRuns repeatLast: aString size  ifEmpty: [ OrderedCollection new ] ].	characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 6/27/1998 15:09'!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 7/28/1998 02:08'!currentAttributes: newAttributes	"set the current attributes"	attributesChanged _ currentAttributes ~= newAttributes.	currentAttributes _ newAttributes.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 9/10/1998 03:36'!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:08'!initialize	characters _ WriteStream on: String new.	currentAttributes _ OrderedCollection new.	attributesChanged _ true.	attributeRuns _ RunArray new.	! !!AttributedTextStream class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:07'!new	^super basicNew initialize! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/21/1998 08:23'!authorizer	"*** Do not use this method to add or delete users!!  The change will not be recorded on the disk!!  Instead call mapName:password:to: in this class.***"	^authorizer! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 7/6/1998 07:31'!checkAuthorization: request	^ authorizer ifNotNil: [authorizer user: request userID].! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/199815:32'!process: request	self checkAuthorization: request.	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/13/1998 20:45'!processSpecial: request	"Let SwikiAction process this with no authorization check."	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 6/22/1998 14:15'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| fName |	super restore: nameOfSwiki.	fName _ ServerAction serverDirectory, name, (ServerAction pathSeparator), 				'authorizer'.	(FileDirectory new fileExists: fName) ifTrue: [		authorizer _ (FileStream oldFileNamed: fName) fileInObjectAndCode].! !Allows anyone to read the pages of this Swiki, but only authorized users can edit or change pages.  Can have multiple users, each with a different password.  Each can modify the whole Swiki area.To restart an existing Authorized Swiki:	AuthorizedWriteSwiki new restore: 'SWSecure'.The front page URL is:  http://serverMachine:80/SWSecure.1To make a completely new one:	| a s |	a := Authorizer new.	a realm: 'SwikiArea'.	a mapName: 'viki' password: 'hard2guess' to: 'viki'.	AuthorizedWriteSwiki setUp: 'SWSecure'.	s := AuthorizedWriteSwiki new restore: 'SWSecure'.	s authorizer: a.!!AuthorizedWriteSwiki methodsFor: 'as yet unclassified' stamp: 'tk 9/13/1998 20:59'!process: request	"Only demand authorization of name and password when requesting the edit page, requesting the append page, receiving an edit, or receiving an append."	| command coreRef |	request fields ifNotNil: ["Are there input fields?"		coreRef _ request message size < 2			ifTrue: ['1']			ifFalse: [request message at: 2].		coreRef = 'searchresult' ifFalse: ["Must be text for an edit!!"			self checkAuthorization: request]].	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[self checkAuthorization: request].			command = 'insert' ifTrue:					[self checkAuthorization: request]].	^(super processSpecial: request).		"all the way up to SwikiAction"! !A minimalist button-like object intended for use with the tile-scripting system.!!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 17:02'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label...' action: #setLabel.! !!BasicButton methodsFor: 'all' stamp: 'sw 6/29/1998 20:57'!initialize	super initialize.	self borderWidth: 1.	self borderColor: Color yellow darker.	self color: Color yellow.	self label: 'Button'! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:49'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:53'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ aFont		ifNil:			[StringMorph contents: aString]		ifNotNil:			[StringMorph contents: aString font: aFont].	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!BasicButton class methodsFor: 'all' stamp: 'sw 6/16/1998 16:58'!defaultNameStemForInstances	^ 'button'! !!Behavior methodsFor: 'copying' stamp: 'sw 6/16/1998 15:15'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ methodDict copy! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 9/10/1998 14:37'!changeRecordsAt: selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	| aList |	aList _ ChangeList new			scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])			class: self meta: self isMeta			category: (self whichCategoryIncludesSelector: selector)			selector: selector.	^ aList ifNotNil: [aList changeList]! !I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMapThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'copying' stamp: 'di 6/29/1998 20:27'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	self primitiveFailed  "Later do nicer error recovery"! !!BitBlt methodsFor: 'private' stamp: 'di 9/11/1998 13:07'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededForDepth: destForm depth]! !This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'di 6/30/1998 11:13'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 33]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/29/1998 12:19'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/30/1998 11:43'!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/29/1998 12:27'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 18:05'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:45'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	"Check for degenerate shift values 4/28/97 ar"	sourcePixSize = 32 		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:44'!warpLoop	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:08'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:09'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:55'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 00:29'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5]		ifFalse: [bitsPerColor _ 8].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:56'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 16:41'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5.  rgbMask _ 16r1F]		ifFalse: [bitsPerColor _ 8.  rgbMask _ 16rFF].	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff _ 0]							ifFalse: [diff _ 1]]				ifFalse: [diff _ (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff _ (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount _ bitCount + diff].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 11:27'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	pixMask _ (1<<destPixSize) - 1.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'translation support' stamp: 'di 6/30/1998 11:12'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/29/1998 23:24'!initialize	"BitBltSimulation initialize"  	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/30/1998 11:11'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:41'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 237>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size _ bm size.	i _ self encodeInt: size in: ba at: 1.	k _ 1.	[k <= size] whileTrue:		[word _ bm at: k.		lowByte _ word bitAnd: 16rFF.		eqBytes _ ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j _ k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j _ j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i _ self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i _ i+1]				ifFalse: [i _ self encodeInt: j-k+1*4+2 in: ba at: i.						i _ self encodeBytesOf: word in: ba at: i].			k _ j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i _ self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i _ i+1.				k _ k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j _ j+1].				j = size ifTrue: [j _ j + 1].				"We have one or more unmatching words, ending at j-1"				i _ self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i _ self encodeBytesOf: (bm at: m) in: ba at: i].				k _ j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | f unhibernate.	b _ f bits.	n _ n + 1.	rawBytes _ rawBytes + (b size*4).	myBytes _ myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Bitmap methodsFor: 'filing' stamp: 'di 6/1/1998 20:35'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream.	A leading byte ~= 16r80 identifies this as raw bits (uncompressed)."	aStream nextInt32Put: self size.	aStream nextPutAll: self! !!BlockContext methodsFor: 'evaluating' stamp: 'tk 6/24/1998 15:32'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver. If an error occurs the given is evaluated with the error message and the receiver as parameters. The error handler block may return a value to be used if the receiver block gets an error. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | ^ 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'division by 0' = err				ifTrue: [^ Float infinity]				ifFalse: [self error: err]]"	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ errorHandlerBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'scheduling' stamp: 'di 9/12/1998 11:53'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive]		priority: Processor activePriority! !Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.!!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:43'!initialize	super initialize.	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23'!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages _ pages species new.	pages addAll: pageList! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45'!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	self removeAllMorphs! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 17:03'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	openToDragNDrop _ true! !!BookMorph methodsFor: 'sorting' stamp: 'sw 6/25/1998 17:15'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects existingCursor toAdd newCursor |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	existingCursor _ aHolder cursor.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [toAdd _ m page].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[goodPages add: toAdd.				i == existingCursor ifTrue: [newCursor _ goodPages size]]].	self newPages: goodPages.	goodPages size == 0 ifTrue: [self insertPage].	newCursor ifNil: [newCursor _ 1].	self goToPage: newCursor.	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'sorting' stamp: 'di 8/8/1998 15:02'!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: Sensor cursorPoint		from: 0 to: pages size		during:			[:bar | i _ 0.			thumbnails _ pages collect:				[:p | bar value: (i_ i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter]					ifFalse: [p thumbnailForPageSorter]]].	^ thumbnails! !!BookMorph methodsFor: 'sorting' stamp: 'jm 6/17/1998 21:35'!sortPages: evt	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: (pages indexOf: currentPage ifAbsent: [0]).	evt == nil		ifTrue: [self world addMorphFront: sorter]		ifFalse: [evt hand attachMorph: sorter].! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 16:40'!beThoroughlyRepelling	submorphs do: [:m | m beRepelling].	self beRepelling! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 17:12'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/31/1998 00:04'!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: evt cursorPoint) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 6/24/1998 18:50'!deletePage	| message |	message _ 'Are you certain that youwant to delete this page andeverything that is on it? '.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 6/11/1998 17:42'!deletePageBasic	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 6/14/1998 14:26'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil: [			newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'zooming page turns' stamp: 'jm 7/10/1998 14:06'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	| image |	ascending ifNotNil: [		image _ currentPage imageForm.  "compute image before starting sound"		self playPageFlipSound.		(PageFlipSoundOn and: [oldOrigin ~~ nil]) ifTrue: [			Display wipeImage: image				at: oldOrigin				delta: (ascending ifTrue: [0@-4] ifFalse: [0@4])]].! !!BookMorph methodsFor: 'navigation' stamp: 'sw 7/15/1998 21:07'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld]! !!BookMorph methodsFor: 'navigation' stamp: 'di 8/6/1998 23:49'!pageNumber.	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/5/1998 00:23'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	subMenu add: 'make this be "My Parts Bin"' action: #saveAsMyPartsBin.	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'Book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 16:06'!indexOfCurrentPage	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:24'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'di 8/11/1998 12:47'!saveAsMyPartsBin	| aBin |	aBin _ self veryDeepCopy.	aBin pages do:		[:aPage | 			aPage isPartsBin: true.			aPage openToDragNDrop: false.			aPage submorphs do:				[:m | m markAsPartsDonor.				m suspendEventHandler]].	ScriptingSystem setPartsBinFrom: aBin! !!BookMorph methodsFor: 'menu' stamp: 'tk 8/13/1998 12:09'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentPage ifNotNil:		[newPagePrototype _ currentPage veryDeepCopy].! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:50'!thumbnailForThisPage	self primaryHand attachMorph:		(currentPage thumbnailForPageSorter pageNumber: self pageNumber inBook: self)! !!BookMorph methodsFor: 'other' stamp: 'tk 8/13/1998 12:49'!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: aColor; borderWidth: 0.	aColumn _ AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; inset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; inset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' < ' ; actionSelector: #previousPage).		"fullCopy is OK, since we just made it and it can't own any Players"	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'other' stamp: 'sw 8/11/1998 16:50'!succeededInRevealing: aPlayer	currentPage ifNotNil: [currentPage player == aPlayer ifTrue: [^ true]].	pages do:		[:aPage |			(aPage succeededInRevealing: aPlayer) ifTrue:				[self goToPageMorph: aPage.				^ true]].	^ false! !!BookMorph class methodsFor: 'all' stamp: 'sw 7/4/1998 15:58'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:27'!acceptSort	book acceptSortedContentsFrom: pageHolder.	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:39'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:28'!book: aBookMorph morphsToSort: morphList	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:42'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Close'; actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/1/1998 18:36'!forBook: aBookMorph	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs:		(book pages collect: [:p | p thumbnailForPageSorter]).	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 12:36'!initialize	super initialize.	self extent: 440@400;		orientation: #vertical;		centering: #topLeft;		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 3;		color: Color lightGray;		borderWidth: 2.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent - borderWidth.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 6/25/1998 10:10'!computeThumbnail	| f scale |	f _ page imageForm.	page fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Flip to this page with no extra sound"	BookMorph turnOffSoundWhile: [bookMorph goToPage: pageNumber]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/8/1998 14:02'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!page: aMorph	page _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!pageNumber: n inBook: b	pageNumber _ n.	bookMorph _ b! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/8/1998 14:06'!smaller	self form: (self form copy: (0@0 extent: self form extent//2)).! !A common superclass for BookMorph and WebBookMorph!!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 15:48'!fullControlSpecs	^ #(( '<--'		firstPage		'First page')		( '<-' 		previousPage	'Previous page')		('-'			deletePage		'Delete this page')		('<<>>'		invokeBookMenu 'Invoke menu')		('+'			insertPage		'Add a new page after this one')		('->'			nextPage		'Next page')		( '-->'		lastPage			'Final page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:12'!hidePageControls	"Delete all submorphs answering to the property #pageControl"	self deleteSubmorphsWithProperty: #pageControl! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:16'!makePageControlsFrom: controlSpecs	| c aButton col row b |	c _ (color saturation > 0.1) ifTrue: [color lighter] ifFalse: [color darker].	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: c.	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; inset: 0.	col hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; inset: 0.	row hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:pair |		b _ aButton fullCopy			label: pair first;			actionSelector: pair second;			setBalloonText: pair third.		row addMorphBack: b.		(pair last asLowercase includesSubString: 'menu')			ifTrue: [b actWhen: #buttonDown]].  "pop up menu on mouseDown"	col addMorphBack: row.	^ col! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 17:48'!shortControlSpecs	^ #(( '<-'	previousPage	'Previous page')		('->'		nextPage		'Next page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:13'!showPageControls	| spacer pageControls |	self hidePageControls.	spacer _ Morph new color: color; extent: 0@10.	spacer  setProperty: #pageControl toValue: true.	self addMorph: spacer.	pageControls _ Preferences noviceMode		ifTrue: [self makePageControlsFrom: self shortControlSpecs]		ifFalse: [self makePageControlsFrom: self fullControlSpecs].	pageControls borderWidth: 1; inset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	self addMorph: pageControls.! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"This factoring allows subclasses to have different menu yet still use the super call for the rest of the metamenu."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39'!clearNewPagePrototype	newPagePrototype _ nil! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:40'!firstPage	self goToPage: 1! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:18'!insertPage	self insertPageColored: self color! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 16:08'!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self indexOfCurrentPage.	self presentResultMorph: sorter! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:56'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	(self hasSubmorphWithProperty: #pageControl)		ifTrue: [aCustomMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [aCustomMenu add: 'show page controls' action: #showPageControls]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 8/11/1998 16:51'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage player) ifNotNil:		[aBlock value: aPlayer]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:36'!pageSize	^ pageSize! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51'!pageSize: aPoint	pageSize _ aPoint! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:38'!playPageFlipSound	(self presenter soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: 'camera'].! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:09'!presentResultMorph: aMorph	"Add the given morph to the world."	self primaryHand attachMorph: aMorph"	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph."! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 15:59'!initialize	"BooklikeMorph initialize"	PageFlipSoundOn _ true! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!BooleanScriptEditor methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	((submorphs size > 0) and:	 [submorphs first submorphs size > 0]) ifTrue: [			aStream nextPutAll: '(('.			super storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ') ~~ false)'.			^ self].	aStream nextPutAll: ' true '.! !!BooleanScriptEditor methodsFor: 'all' stamp: 'sw 8/3/1998 17:15'!wantsDroppedMorph: aMorph	((aMorph isKindOf: PhraseTileMorph) and:		[submorphs size == 1]) ifTrue: [^ false].	^ aMorph isTileLike and: [aMorph resultType ~~ #command]! !A tile whose result type is boolean.!!BooleanTile methodsFor: 'all' stamp: 'sw 8/5/1998 17:52'!resultType	^ #boolean! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:55'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(borderColor isColor and: [borderColor alpha < 1.0]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:25'!areasRemainingToFill: aRectangle	color isTransparent ifTrue: [^ Array with: aRectangle].	borderWidth = 0		ifTrue: [^ aRectangle areasOutside: self bounds]		ifFalse: [(borderColor isColor and: [borderColor isTransparent])					ifTrue: [^ aRectangle areasOutside: self innerBounds]					ifFalse: [^ aRectangle areasOutside: self bounds]]! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 6/25/1998 08:34'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	^ aNumber == 2		ifTrue: 			[#(			(color			color		readWrite	getColor				setColor:)			(borderWidth 		number		readWrite	getBorderWidth	setBorderWidth:)			(borderColor			color		readWrite	getBorderColor	setBorderColor:))]		ifFalse:			[super slotNamesAndTypesForBank: aNumber]! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' action: #startInfection.	aCustomMenu add: 'set atom count' action: #setAtomCount.	aCustomMenu add: 'show infection history' action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString _ FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 8/10/1998 18:32'!step	"Bounce those atoms!!"	| r bounces |	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph _ GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection _ false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 8/10/1998 18:32'!updateTemperature: currentTemperature	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures == nil ifTrue: [		recentTemperatures _ OrderedCollection new.		20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature _ recentTemperatures sum asFloat / recentTemperatures size.! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:50'!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window codePane aListMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0.25@0 extent: 0.25@0.3).	window addMorph: self buildMorphicSwitches		frame: (0.25@0.3 extent: 0.25@0.1).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.4 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:08'!openEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| systemCategoryListView classListView 	messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphEditing: aString].	Sensor leftShiftDown ifTrue: [^ self openAsMorphEditing: aString "testing"].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategoryList		selected: #systemCategoryListIndex		changeSelected: #systemCategoryListIndex:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	topView addSubView: classListView toRightOf: systemCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	messageListView menuTitleSelector: #messageListSelectorTitle.	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@110).	topView addSubView: browserCodeView below: systemCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:17'!openMessageCatEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message category."	| messageCategoryListView messageListView browserCodeView topView |	World ifNotNil: [^ self openAsMorphMsgCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageCategoryListView _ PluggableListView on: self		list: #messageCatListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageCategoryListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 200 @ 70).	topView addSubView: messageListView below: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphClassEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	classListView _ PluggableListView on: self		list: #classListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 100 @ 12).	topView addSubView: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageCategoryListView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	switchView 		window: switchView window 		viewport: (classListView viewport topRight 					corner: messageListView viewport topRight).	topView addSubView: switchView toRightOf: classListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphSysCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategorySingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 67 @ 62).	topView addSubView: classListView below: systemCategoryListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	switchView _ self buildInstanceClassSwitchView.	switchView 		window: switchView window 		viewport: (classListView viewport bottomLeft 					corner: messageCategoryListView viewport bottomLeft).	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 67 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(110-12)).	topView addSubView: browserCodeView below: switchView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:13'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories 		ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) 		ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText stamp: Utilities changeStamp. ^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage) 		ifTrue: [^ self defineMessage: aText notifying: aController].	editSelection == #none		ifTrue: [PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.				^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'class functions' stamp: 'di 6/2/1998 13:58'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName |	oldClass _ self selectedClassOrMetaClass.	newClassName _ (defString findTokens: Character separators) third copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [Smalltalk includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	oldClass ifNil: [oldClass _ Object].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!Browser methodsFor: 'message list' stamp: 'di 9/21/1998 23:12'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message functions' stamp: 'di 5/27/1998 15:45'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.  "In case organization not cached"	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !URLs that instruct a browser to do something.!!BrowserUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !!ButtonMorph methodsFor: 'copying' stamp: 'tk 8/13/1998 12:53'!prepareToBeSaved	"SmartRefStream will not write any morph that is owned by someone outside the root being written.  (See DataStream.typeIDFor:)  Open Scripts are like that.  Make a private copy of the scriptEditor."	super prepareToBeSaved.	lastAcceptedScript ifNotNil: [		lastAcceptedScript owner ifNotNil: ["open on the screen"			lastAcceptedScript _ lastAcceptedScript fullCopy setMorph: self.			self flag: #noteToTed.  "What if some tile has a Player?  				Need an invariant that says no script part can have a Player.  Enforce it."			"lastAcceptedScript privateOwner: nil" "fullCopy does it"]].	"lastScriptEditor will not be written out"! !This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: 'interp.c' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.!!CCodeGenerator methodsFor: 'C code generator' stamp: 'ls 8/15/1998 08:36'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 7/5/1998 18:17'!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| rcvr arg divisor |	rcvr _ msgNode receiver.	arg _ msgNode args first.	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor _ arg value) isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		aStream nextPutAll: '((int) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.		aStream nextPutAll: ')'.	] ifFalse: [		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitCExpression: arg on: aStream].! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 8/19/1998 09:56'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!CCodeGenerator class methodsFor: 'class initialization' stamp: 'jm 8/19/1998 10:03'!initialize	"CCodeGenerator initialize"	UseRightShiftForDivide _ true.		"If UseRightShiftForDivide is true, the translator will generate a right-shift when it encounters a division by a constant that is a small power of two. For example, 'x / 8' will generate '((int) x >> 3)'. The coercion to int is done to make it clear that the C compiler should generate a signed shift."		"Note: The Kernighan and Ritchie 2nd Edition C manual, p. 49, leaves the semantics of right-shifting a negative number open to the discretion of the compiler implementor. However, it strongly suggests that most compilers should generate an arithmetic right shift (i.e., shifting in the sign bit), which is the same as dividing by a power of two. If your compiler does not generate or simulate an arithmetic shift, then make this class variable false and re-translate."! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:14'!generate: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage peer cacheFile file|	(request isKindOf: PWS)	ifFalse: [(request isKindOf: String) ifTrue: [peer _ request]ifFalse: [peer _ ' ']]	ifTrue: [peer _ request peerName].	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: peer					storingTo: OrderedCollection new]).	cacheFile _ (self cacheDirectory),(self name),(ServerActionpathSeparator),(pageRef coreID),'.html'.	(StandardFileStream isAFileNamed: cacheFile)	ifTrue: [FileDirectory deleteFilePath: cacheFile].	file _ FileStream fileNamed: cacheFile.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:15'!generateRecent	| file |	file _ FileStream fileNamed: (self cacheDirectory),(selfname),(ServerAction pathSeparator),'recent.html'.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source, 'recent.html')					with: urlmap recent).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:34'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.			^ self]].		"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/9/1998 21:34'!pageURL: aPage	"make the url suited to aPage"	^(self url),(self name),'/',aPage coreID,'.html'! !!CachedSwikiAction methodsFor: 'access' stamp: 'TPR 7/21/1998 18:05'!url	^cacheURL! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!extent	^ Display extent! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'testing' stamp: 'jm 5/30/1998 21:10'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:59'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self		image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:48'!line: pt1 to: pt2 brushForm: brush	"Noop here; overridden by non-trivial canvases."! !I represent the organization of the mail database into set of message lists called "categories". Each category contains a collection of message ID's. The same message may be cross-filed quite cheaply by storing it's ID in multiple categories.The categories information is kept in a binary file on the disk. It is read into memory in its entirety when the mail database is opened. To make changes persist, the categories information must be saved out to disk. This should be done after fetching new mail and when the mail database is closed. It could also be done periodically by some sort of background process. Note that the categories file, unlike the index file, cannot be re-created from the messages file.!!CategoriesFile methodsFor: 'categories access'!addCategory: categoryName	"Add a new category, if it doesn't already exist."	(self categories includes: categoryName) ifFalse:		[categories at: categoryName put: Set new].! !!CategoriesFile methodsFor: 'categories access'!categories	"Answer a collection of my categories, including the pseudo-categories '.unclassified.' and '.all.'. '.unclassified.' contains the orphaned messages that would otherwise not appear in any category. '.all.' contains all the messages in the database. Since these pseudo-categories are computed on the fly, there may be a noticable delay when one of them is selected."	^(categories keys)		add: '.all.';		add: '.unclassified.';		yourself! !!CategoriesFile methodsFor: 'categories access'!file: messageID inCategory: categoryName	"Add the given message ID to the given category. The target category must be a real category, not a pseudo-category."	(categoryName = '.unclassified.' | categoryName = '.all.') ifTrue: [^self].	(categories includesKey: categoryName) ifFalse:		[categories at: categoryName put: Set new].	(categories at: categoryName) add: messageID.! !!CategoriesFile methodsFor: 'categories access'!isUnclassified: messageID	"Answer true if the given message ID does not appear in any of my real (not pseudo) categories."	categories do:		[: category | (category includes: messageID) ifTrue: [^false]].	^true! !!CategoriesFile methodsFor: 'categories access'!messagesIn: category	"Answer a collection of message ID's for the messages in the given category. The pseudo-categories are dynamically computed and so they cannot be accessed in this manner."	^categories at: category ifAbsent: [#()]! !!CategoriesFile methodsFor: 'categories access'!remove: messageID fromCategory: categoryName	"Remove the given message ID from the given category."	| msgList |	msgList _ categories at: categoryName ifAbsent: [^self].	msgList remove: messageID ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeCategory: categoryName	"Remove the given category, if it exists."	categories removeKey: categoryName ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeMessagesInCategory: categoryName butNotIn: indexFile	"Used to clean the dead wood out of a category."	| oldMsgs newMsgs |	oldMsgs _ categories at: categoryName ifAbsent: [^self].	newMsgs _ oldMsgs copy.	oldMsgs do:		[: msgID |		 (indexFile includesKey: msgID) ifFalse:			[newMsgs remove: msgID]].	categories at: categoryName put: newMsgs.! !!CategoriesFile methodsFor: 'categories access'!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = 'new' | oldName = '.unclassified.' | oldName = '.all.' |	 (self categories includes: newName)) ifTrue:		[^self].	"can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!CategoriesFile methodsFor: 'categories access'!unclassifiedFrom: messageIDs	"Answer the subset of the given set of message ID's that do not appear in any category."	^messageIDs select:		[: msgID | self isUnclassified: msgID]! !!CategoriesFile methodsFor: 'read-write' stamp: 'jm 8/18/1998 16:24'!readFrom: aFileStream	"Read the categories from the given FileStream."	| name categorySize messageIDs |	categories _ Dictionary new: 64.	aFileStream binary; position: 0.	[aFileStream atEnd] whileFalse:		[name _ aFileStream ascii; nextString.		 categorySize _ aFileStream binary; nextWord.		 messageIDs _ Set new: categorySize * 4.		 categorySize timesRepeat:			[messageIDs add: aFileStream nextInt32].		 categories at: name put: messageIDs].! !!CategoriesFile methodsFor: 'read-write'!writeOn: aFileStream	"Write the categories to the given FileStream. The categories data is stored in binary (as opposed to a human-readable form) to save space."	aFileStream binary; position: 0.	categories associationsDo:		[: category |		 "(category key) is the category name"		 "(category value) is the set of message ID's in that category"		 aFileStream nextStringPut: (category key).		 aFileStream nextWordPut: (category value) size.		 (category value) do:			[: messageID |			 aFileStream nextInt32Put: messageID]].! !A model for a morphic world view which will ask for confirmation before being closed, unless the corresponding preference is set to false. !!CautiousModel methodsFor: 'all' stamp: 'sw 9/15/1998 16:45'!okToChange	Preferences cautionBeforeClosing ifFalse: [^ true].	Sensor leftShiftDown ifTrue: [^ true].	self beep.	^ self confirm: 'Warning!!If you answer "yes" here, thiswindow will disappear andits contents will be lost!!Do you really want to do that?'"CautiousModel new okToChange"! !I am the core of a mail reading and organizing program. The name "Celeste" is a reference to an earlier mail reader named "Babar", which was written at Xerox PARC by Steve Putz and John Maloney.This object provides a user interface and some higher-level functionality for the application. The foundation of of the mail reader is really the mail database, implemented by the class MailDB.!!Celeste methodsFor: 'open-close' stamp: 'jm 9/21/1998 17:18'!close	"Close the mail database."	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil].! !!Celeste methodsFor: 'open-close' stamp: 'ls 9/13/1998 21:15'!openOnDatabase: aMailDB	"Initialize myself for the mail database with the given root filename."	mailDB _ aMailDB.	mailDB addDependent: self.	currentCategory _ 'new'.	lastCategory _ ''.	subjectFilter _ ''.	fromFilter _ ''.	dateFilter _ nil.	self setCategory: currentCategory.! !!Celeste methodsFor: 'open-close' stamp: 'jm 8/20/1998 18:37'!windowIsClosing	"Close the mail database when my window is closed."	self close.! !!Celeste methodsFor: 'categories pane'!addCategory	"Create a new category with the user-specified name. This does nothing if the category already exists."	| newCatName |	newCatName _ FillInTheBlank request: 'Name for new category?'.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB addCategory: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 09:24'!categoriesKeystroke: aCharacter	aCharacter asciiValue = 30 ifTrue: [self previousCategory].	aCharacter asciiValue = 31 ifTrue: [self nextCategory].! !!Celeste methodsFor: 'categories pane'!category	"Answer the currently selected category or nil."	^currentCategory! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:25'!categoryList	"Answer a list of categories for the categories pane."	^ mailDB allCategories! !!Celeste methodsFor: 'categories pane' stamp: 'jm 9/21/1998 17:28'!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\fetch mail\send queued mail\add category' withCRs.	lineSeparations _ #(1 2).	selectors _ #(save fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\export category' withCRs.			lineSeparations _ lineSeparations, #(4).			selectors _ selectors, #(renameCategory removeCategory exportCategory ). ]		ifFalse: [			lineSeparations _ lineSeparations, #(1) ].	labels _ labels, '\empty trash\compact\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(2 1 5).	selectors _ selectors, #(emptyTrash compact toggleSuppressHeaders setUserName setCCList setPopServer setPopUSername setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [ labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer) ]		ifFalse: [ labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching) ].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [ :i |		lines at: i put: ((lines at: i) + (lines at: i-1)) ].	^aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane'!compact	"Compact the messages file."	| stats |	Transcript cr; show: 'Compacting message file...'.	Cursor execute showWhile: [stats _ mailDB compact].	Transcript show: 'Done.'; cr.	Transcript show:		'Recovered ',		(stats at: 1) printString, ' message',		(((stats at: 1) > 1) ifTrue: ['s, '] ifFalse: [', ']),		(stats at: 2) printString, ' bytes.'; cr.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!deleteMessagesAfterFetching	"start deleting messages off the server after POP-ing"	DeleteInboxAfterFetching _ true! !!Celeste methodsFor: 'categories pane'!emptyTrash	"Delete all messages in the '.trash.' category.	WARNING: The messages will be completely removed from the database."	| msgList |	msgList _ self filteredMessagesIn: '.trash.'.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB deleteAll: msgList.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategory	"Store the filtered message list of the current category to another mail database. The user is prompted for the name of the other database."	| destDBName destDB |	currentCategory ifNil: [ ^self ].	destDBName _ FillInTheBlank		request: 'Destination mail database?'		initialAnswer: ''.	(destDBName isEmpty) ifTrue: [^self].	destDB _ MailDB openOn: destDBName.	(destDB isNil) ifTrue: [^self].	destDB mergeMessages: (self filteredMessagesIn: currentCategory) from: mailDB.	destDB saveDB.	destDB changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategoryUnix	"Store the filtered message list of the current category into a Eudora/Unix database"	| destFileName destFile messageIds count |	currentCategory ifNil: [ ^self ].	destFileName _ FillInTheBlank		request: 'Destination mail file?'		initialAnswer: ''.	(destFileName isEmpty) ifTrue: [^self].	destFile _ FileStream fileNamed: destFileName.	destFile ifNil: [ ^self error: 'could not open file' ].	destFile setToEnd.	messageIds _ self filteredMessagesIn: currentCategory.	('exporting ', messageIds size printString, ' messages')		displayProgressAt: Sensor mousePoint		from: 0		to: messageIds size		during: [ :bar |			count _ 0.			messageIds do: [ :messageId |				destFile nextPutAll: Celeste eudoraSeparator.				(mailDB getMessage: messageId) text linesDo: [ :line |					(line beginsWith: 'From ') ifTrue: [ destFile nextPut: $> ].					destFile nextPutAll: line.					destFile cr ].				count _ count + 1.				bar value: count. ].		].	destFile close.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/15/1998 18:58'!fetchMail	"Add the messages from the mail inbox file into this mail database."	| count server userName password |	self checkTrash.	server _ self class popServer.	userName _ self class popUserName.	password _ self class popPassword.	[count _ mailDB POPMailFrom: server		userName: userName		password: password		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching		informingUser: true.	 self inform: count printString, ' messages fetched'.	 currentCategory _ 'new'. 	] ifError: [ :err :rcvr | 			Transcript show: err.			(self confirm: 'Error: ', err, String cr,'debug it?') ifTrue: [ self halt ]. ].	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:43'!fetchNews	"Add the messages from the news inbox file into this mail database."	| inboxPath count |	self halt: 'This is probably out of date.  Feel lucky?'.	inboxPath _ Celeste inOutFolder.	inboxPath size > 0		ifTrue: [ inboxPath _ inboxPath, ':newsInbox' ]		ifFalse: [ inboxPath _ 'newsInbox' ].	Transcript show: 'Fetching news from ', inboxPath.	count _ mailDB fetchNewsFrom: inboxPath		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching. 	Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	count > 0 ifTrue: [		self changed: #categoryList.		self updateTOC].! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/15/1998 05:23'!findDuplicates	"find duplicate messages, and move them all to a given category"	|duplicatesCategory |	duplicatesCategory _ FillInTheBlank request: 'category to move duplicates to?' initialAnswer: '.duplicates.'.	duplicatesCategory isEmpty ifTrue:[ ^self ].	Utilities informUser: 'searching for duplicates...' during: [		mailDB fileDuplicatesIn: duplicatesCategory ].	self setCategory: duplicatesCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:17'!importIntoCategory	"Add the messages from a Unix or Eudora format file into this category"	| inboxPath count |	currentCategory ifNil: [ ^self ].	"get the file to import from"	inboxPath _ ''.	[	inboxPath _ FillInTheBlank request: 'file to import from?\(should be Eudora or Unix format)' withCRs.		inboxPath isEmpty ifTrue: [ ^self ].		FileStream isAFileNamed: inboxPath 	] whileFalse: [		self inform: 'file does not exist' ].	Utilities informUser: 'Fetching mail from ', inboxPath during: [		count _ mailDB importMailFrom: inboxPath  intoCategory: currentCategory. ].	self inform: count printString, ' messages imported'.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!keepMessagesOnServer	"start keeping messages on the server after POP-ing"	DeleteInboxAfterFetching _ false! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 13:05'!nextCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i < catList size		ifTrue: [self setCategory: (catList at: i + 1)]		ifFalse: [self setCategory: (catList at: 1)].	self changed: #category.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 13:06'!previousCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i > 1		ifTrue: [self setCategory: (catList at: i - 1)]		ifFalse: [self setCategory: (catList at: catList size)].	self changed: #category.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:57'!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	currentCategory ifNil: [ ^self ].	msgList _ mailDB messagesIn: currentCategory.	(mailDB messagesIn: '.trash.') do: [: id |		msgList remove: id ifAbsent: []].	msgList isEmpty ifFalse: [		(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].	mailDB removeCategory: currentCategory.	self setCategory: nil.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:45'!renameCategory	"Rename the category with the user-specified name."	| newCatName |	currentCategory ifNil: [ ^self ].	newCatName _ FillInTheBlank		request: 'New name?'		initialAnswer: currentCategory.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB renameCategory: currentCategory to: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 18:34'!save	"Snapshot the database to disk."	mailDB saveDB.! !!Celeste methodsFor: 'categories pane'!setCCList	"Change the default cc: list for use in composing messages."	self class setCCList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 9/21/1998 11:03'!setCategory: newCategory	"Change the currently selected category. We must also compute the table of contents and message list for the new category."	| s |	currentCategory _ newCategory.	(newCategory isNil)		ifTrue: [			currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse: [			currentMessages _ self filteredMessagesIn: newCategory.			currentTOC _ OrderedCollection new: currentMessages size.			1 to: currentMessages size do: [:i |				s _ WriteStream on: (String new: 200).				s nextPutAll: i printString; space.				[s position < 4] whileTrue: [s space].				s nextPutAll: (mailDB getTOCstring: (currentMessages at: i)).				currentTOC add: s contents].			currentTOC _ currentTOC asArray.			(currentMessages includes: currentMsgID) ifFalse: [currentMsgID _ nil]].	self changed: #category.	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	self class setInOutFolder.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:37'!setPopServer	^self class setPopServer! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:39'!setPopUserName	^self class setPopUserName! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 02:31'!setSmtpServer	^self class setSmtpServer! !!Celeste methodsFor: 'categories pane'!setUserName	"Change the user's email name for use in composing messages."	self class setUserName.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:35'!toggleSuppressHeaders	SuppressWorthlessHeaderFields _ SuppressWorthlessHeaderFields not.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/14/1998 16:50'!underConstruction	self halt: 'Sorry, that is still under construction!!'.! !!Celeste methodsFor: 'table of contents pane'!deleteAll	"Move all visible messages in the current category to '.trash.'."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: '.trash.'.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 16:32'!deleteMessage	"Move the current message to the '.trash.' category and select the next message. Deleted messages can later purged by invoking the 'deleteAll' command in the '.trash.' category."	currentMsgID isNil ifTrue: [^ self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: '.trash.'.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAgain	"File the current message in the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAll	"File all visible messages in the current category in some other category as well."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileMessage	"File the current message in another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!getCategoryNameIfNone: aBlock	"Prompt the user for a category name, remembering it for the next time."	| catList categoryName |	catList _ self categoryList.	catList remove: '.all.' ifAbsent: [].	catList remove: '.trash.' ifAbsent: [].	catList remove: '.unclassified.' ifAbsent: [].	catList add: '<new category>'.	((lastCategoryList ~= catList) or: [lastCategoryMenu = nil])		ifTrue: [lastCategoryMenu _ CustomMenu selections: catList].	categoryName _ lastCategoryMenu startUp.	categoryName = nil ifTrue: [^aBlock value].	categoryName = '<new category>' ifTrue: [		categoryName _ FillInTheBlank			request: 'New category name?'			initialAnswer: ''.		(categoryName isEmpty) ifTrue: [^aBlock value].		lastCategoryMenu _ nil.		mailDB addCategory: categoryName.		self changed: #categoryList.	].	lastCategoryList _ catList.	^lastCategory _ categoryName! !!Celeste methodsFor: 'table of contents pane'!moveAgain	"Move the current message to the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveAll	"Move all visible messages in the current category to another category."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveMessage	"Move the current message to another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:10'!nextMessage	"Select the next message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index < currentMessages size		ifTrue: [self setTOCEntry: (currentTOC at: index + 1)]		ifFalse: [self setTOCEntry: (currentTOC at: 1)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!otherCategories	"Prompt the user with a menu of all other categories in which the currently selected message appears. If the user chooses a category from this menu, go to that category."	| otherCategories choice |	otherCategories _		(mailDB categoriesThatInclude: currentMsgID) asOrderedCollection.	otherCategories remove: currentCategory ifAbsent: [].	(otherCategories isEmpty) ifTrue: [^self].	choice _ (CustomMenu selections: otherCategories) startUp.	choice = nil ifFalse: [self setCategory: choice].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:13'!previousMessage	"Select the previous message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index > 1		ifTrue: [self setTOCEntry: (currentTOC  at: index - 1)]		ifFalse: [self setTOCEntry: (currentTOC  at: currentMessages size)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane'!removeAll	"Remove all messages from the current category."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!removeMessage	"Remove the current message from the current category."	mailDB remove: currentMsgID fromCategory: currentCategory.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!search	| destCat matchString msgText |	destCat _ FillInTheBlank		request: 'In what category should the search results be filed?'		initialAnswer: '.search results.'.	(destCat isEmpty) ifTrue: [^self].	matchString _ FillInTheBlank		request: 'String sought in message text?'		initialAnswer: ''.	(self filteredMessagesIn: currentCategory) do:		[: msgID |		 msgText _ mailDB getText: msgID.		 ((msgText findString: matchString startingAt: 1) > 0) ifTrue:			[mailDB file: msgID inCategory: destCat]].	self changed: #categoryList.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 10:35'!setTOCEntry: newTOCentry	"Change the currently selected message. This is done by finding the message ID corresponding to the selected table of contents entry."	| i |	(newTOCentry isNil | currentTOC isNil)		ifTrue: [currentMsgID _ nil]		ifFalse:			[i _ currentTOC indexOf: newTOCentry ifAbsent: [nil].			 (i isNil)				ifTrue: [currentMsgID _ nil]				ifFalse: [currentMsgID _ currentMessages at: i]].	self changed: #messageText.  "update the message pane"! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:56'!tocEntry	"Answer the table of contents entry for the currently selected message or nil."	(currentMsgID isNil)		ifTrue: [^nil]		ifFalse: [^currentTOC at: (currentMessages indexOf: currentMsgID)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocEntryList	"Answer a collection of table-of-contents entries for the currently selected category or an empty collection if no category is selected."	currentCategory		ifNil: [^ #()]		ifNotNil: [^ currentTOC].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocKeystroke: aCharacter	aCharacter = Character backspace ifTrue: [self deleteMessage].	aCharacter asciiValue = 30 ifTrue: [self previousMessage].	aCharacter asciiValue = 31 ifTrue: [self nextMessage].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 10:49'!tocMenu: aMenu	"Answer the menu for the table of contents pane."	currentCategory ifNil: [^ nil].	currentMsgID		ifNil: [			^ aMenu				labels: 'compose\file all\move all\remove all\delete all\search' withCRs				lines: #(1 5)				selections: #(compose fileAll moveAll removeAll deleteAll search)]		ifNotNil: [			^ aMenu				labels: 'delete\compose\reply\forward\file again\move again\file\move\remove\file all\move all\remove all\delete all\other categories\search' withCRs				lines: #(1 4 6 9 13 14)				selections: #(deleteMessage compose reply forward fileAgain moveAgain fileMessage moveMessage removeMessage fileAll moveAll removeAll deleteAll otherCategories search)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 9/10/1998 02:19'!updateTOC	"Update the table of contents after a moving, removing, or deleting a message. Select a message near the removed message in the table of contents if possible."	| currentMsgIndex |	((currentCategory isNil) |	 (currentMsgID isNil) |	 (currentMessages size < 2))		ifTrue: [currentMsgIndex _ 1]		ifFalse: [currentMsgIndex _ currentMessages indexOf: currentMsgID].	currentMsgID _ nil.	self setCategory: currentCategory.  "update currentMessages, currentTOC"	currentMessages isEmpty ifFalse: [		(currentMsgIndex <= currentMessages size)			ifTrue: [currentMsgID _ currentMessages at: currentMsgIndex]			ifFalse: [currentMsgID _ currentMessages last].	].	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'filtering'!customFilterOff	"Cancel custom filtering."	customFilterBlock _ nil.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/11/1998 19:37'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asSortedCollection asOrderedCollection.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (CustomMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName = nil ifTrue: [^self].	filterName = '<delete a filter...>' ifTrue: [^ self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.! !!Celeste methodsFor: 'filtering'!defineFilter	| filterName expr |	filterName _ FillInTheBlank request: 'Filter name?'.	filterName isEmpty ifTrue: [^''].	(CustomFilters includesKey: filterName)		ifTrue: [expr _ CustomFilters at: filterName]		ifFalse: [expr _ ''].	^self editFilterNamed: filterName filterExpr: expr! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!deleteFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to delete?'.	filterName = nil ifTrue: [^''].	CustomFilters removeKey: filterName ifAbsent: [].! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!editFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to edit?'.	filterName = nil ifTrue: [^''].	^self editFilterNamed: filterName filterExpr: (CustomFilters at: filterName)! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/15/1998 06:49'!editFilterNamed: filterName filterExpr: oldExpr	| newDefinition |	newDefinition _ FillInTheBlank		request:'Enter a filter definition where "m" is the message being testing. The expression can send"fromHas:", "toHas:", "ccHas:", "subjectHas:", "participantHas:", or "textHas:" to m to test forinclusion of a string--or one of an array of strings--in a field. It can also test m''s timeand/or date and can combine several tests with logical operators. Examples:      m fromHas: ''johnm''                       -- messages from johnm     m participantHas: ''johnm''                -- messages from, to, or cc-ing johnm     m textHas: #(squeak smalltalk java)      -- messages with any of these words     m subjectHas: #(0 1 2 3 4 5 6 7 8 9)       -- numbers in lists treated as strings NOTE: "textHas:" is very slow, since it must read the message from disk.'		initialAnswer: oldExpr.	newDefinition isEmpty ifTrue: [^''].	CustomFilters at: filterName put: newDefinition.	^newDefinition! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/14/1998 10:38'!filteredMessagesIn: categoryName	| msgList |	msgList _ mailDB messagesIn: categoryName.	(customFilterBlock notNil) ifTrue:		[msgList _ msgList select:			[: id | customFilterBlock value: (mailDB getTOCentry: id) ]].	(fromFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) from includesSubstring: fromFilter caseSensitive: false]].	(subjectFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) subject includesSubstring: subjectFilter caseSensitive: false]].	^msgList! !!Celeste methodsFor: 'filtering'!fromFilterOff	"Cancel from filtering."	fromFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!fromFilterOn	"Show only those messages from the same person as the currently selected message. The user is given a chance to edit the pattern string used to match 'From:' fields."	fromFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) from].	fromFilter _ FillInTheBlank		request: '''From:'' filter pattern?'		initialAnswer: fromFilter.	fromFilter _ self removeTrailingSeparators: fromFilter.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^ aString copyFrom: 1 to: i]		ifFalse: [^ ''].! !!Celeste methodsFor: 'filtering'!subjectFilterOff	"Cancel subject filter."	subjectFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/12/1998 19:37'!subjectFilterOn	"Show only those messages whose subject matches the currently selected message. The user is given a chance to edit the pattern string used to match 'Subject:' fields."	subjectFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) subject].	subjectFilter _ subjectFilter withBlanksTrimmed.	(subjectFilter asLowercase beginsWith: 're:') ifTrue: [		subjectFilter _ subjectFilter copyFrom: 4 to: subjectFilter size.		subjectFilter _ subjectFilter withBlanksTrimmed ].	subjectFilter _ FillInTheBlank		request: '''Subject:'' filter pattern?'		initialAnswer: subjectFilter.	subjectFilter _ self removeTrailingSeparators: subjectFilter.	self updateTOC.! !!Celeste methodsFor: 'message text pane'!changeMessage: newText	"Accept an edited version of a message and store it away. Answer true if successful."	(currentCategory isNil | currentMsgID isNil)		ifTrue: [^false]		ifFalse: [			mailDB newText: newText asString for: currentMsgID.			self updateTOC.			^ true].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:56'!compose	"Make a MailSendTool for composing a new message."	self openSender: self composeText.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItContext	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItReceiver	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:59'!format	messageTextView		editString: self formatedMessageText;		hasUnacceptedEdits: true.! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:25'!formatedMessageText	"Answer a string that is my formatted mail message."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getMessage: currentMsgID) formattedText].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:57'!forward	"Make a MailSendTool for forwarding the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self forwardTextFor: currentMsgID)].! !!Celeste methodsFor: 'message text pane'!message	"Answer the text of the currently selected message or nil if there isn't one."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getText: currentMsgID) asText]! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 08:14'!messageMenu	"Answer the menu for the message text pane."	(currentMsgID notNil)		ifTrue: [^CustomMenu			labels: 'again\undo\copy\cut\paste\format\accept\cancelcompose\reply\forward' withCRs			lines: #(2 5 6 8)			selections: #(again undo copySelection cut paste format accept cancelcompose reply forward)]		ifFalse: [^SelectionMenu			labels: 'again\undo\copy\cut\paste\compose' withCRs			lines: #(2 5)			selections: #(again undo copySelection cut paste compose)].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:28'!messageMenu: aMenu shifted: shifted	"Use the standard text menu."	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/8/1998 05:12'!messageText	(currentMsgID isNil) ifTrue: [^''].	(SuppressWorthlessHeaderFields and: [FormatWhenFetching not])		ifTrue: [^ self formatedMessageText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 12:05'!messageText: aStringOrText	currentCategory isNil | currentMsgID isNil ifTrue: [^ self].	mailDB newText: aStringOrText asString for: currentMsgID.	self updateTOC.  "in case the message header was changed"	messageTextView hasUnacceptedEdits: false.	self changed: #messageText.	^ true! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/14/1998 15:13'!messageTextView: aView	messageTextView _ aView.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 03:08'!reply	"Make a MailSendTool for replying to the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self replyTextFor: currentMsgID)].! !!Celeste methodsFor: 'other' stamp: 'ls 9/15/1998 00:56'!checkTrash	"check the .trash. folder, and inform the user if it's getting excessively large"	| numTrash numTotal |	numTrash _ (mailDB messagesIn: '.trash.') size.	numTotal _ (mailDB messagesIn: '.all.') size.	(numTrash > 20 and: [ numTrash > (numTotal / 2)]) ifTrue: [		self inform: 'You have more deleted email than non-deleted.You might consider running "empty trash" and "compact"' ].! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 15:26'!clearUserEditFlag	messageTextView hasUnacceptedEdits: false.! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 08:14'!okToChange	"This message is sent when changing the selection in either the message cateory or message list panes. Eventually, this should ask the user if it is okay to throw away and unaccepted edits of the current message. For now, it always gives permission."	currentCategory isNil | currentMsgID isNil ifTrue: [		"no message selected; discard edits in message pane silently"		messageTextView hasUnacceptedEdits: false.		^ true].	messageTextView hasUnacceptedEdits ifFalse: [^ true].	(CustomMenu confirm: 'Discard changes to currently selected message?')		ifTrue: [messageTextView hasUnacceptedEdits: false. ^ true]		ifFalse: [^ false].! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 11:08'!perform: selector orSendTo: otherTarget	"Celeste handles all menu commands."	selector = #format ifTrue: [^ self perform: selector].	((#(yellowButtonActivity shiftedYellowButtonActivity) includes: selector) or:		[(PluggableTextController yellowButtonMessages includes: selector) or:		[PluggableTextController shiftedYellowButtonMessages includes: selector]])			ifTrue: [otherTarget perform: selector]			ifFalse: [self perform: selector].! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:55'!composeText	"Answer the template for a new message."	^String streamContents: [ :str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName.		str cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList.			str cr ].		str cr. ]! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/18/1998 05:10'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) body, '-------------------------------'! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:56'!hasUsername: aString	"Answer true if the given string contains the user's name."	^((aString asLowercase)		findString: (Celeste userName) asLowercase		startingAt: 1) ~= 0! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/16/1998 00:18'!openSender: initialText	"open a message sender with the given initial text"	Smalltalk isMorphic ifTrue: [ ^self openSenderInMorphic: initialText ].	^self openSenderInMVC: initialText! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/16/1998 00:34'!openSenderInMVC: initialText	| topWindow textHolder textView sendButton  |	topWindow _ StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250.	textHolder _ StringHolder new .	textHolder contents: initialText.	textView _ PluggableTextView		on: textHolder		text: #contents		accept: #acceptContents:.	sendButton _ PluggableButtonView 		on: [			textView hasUnacceptedEdits ifTrue: [ textView controller accept ].			self queueMessageWithText: textHolder contents.			topWindow controller close. ] fixTemps		getState: nil		action: #value.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	topWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	topWindow addSubView: textView below: sendButton.	topWindow controller open.		! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/14/1998 10:57'!openSenderInMorphic: initialText	"open an interface for sending a mail message with the given initial text"	| textHolder win textMorph buttonsList sendButton |	textHolder _ StringHolder new.	textHolder contents: initialText.	win _ SystemWindow labelled: 'Mister Postman'.		textMorph _ PluggableTextMorph on: textHolder text: #contents  accept: #acceptContents:.	win addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: [			textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].			self queueMessageWithText: textHolder contents.			win delete. ]		getState: nil		action: #value.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		win addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	win openInMVC.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 03:10'!queueMessageWithText: aStringOrText	"queue a message for sending.  Currently, this simply sticks it in .tosend."	"add a x-mailer line"	| messageText id |	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"actually queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText) inCategory: '.tosend.'.	mailDB file: id inCategory: 'sent'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 06:12'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s anyCCs |	msg _ mailDB getMessage: msgID.	s _ WriteStream on: (String new: 500).	"add From:"	s nextPutAll: 'From: ', Celeste userName; cr.	"add To:"	s nextPutAll: 'To: ', msg from; cr.	"add CC:s from the message and from the user's CC list"	s nextPutAll: 'CC: '.	anyCCs _ false.	(msg to isEmpty) ifFalse: [		anyCCs ifTrue:[ s nextPutAll: ', '] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg to ].	(msg cc isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg cc ].	(Celeste ccList isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].			s nextPutAll: Celeste ccList ].	s cr.	"add Subject:"	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	s cr.	"add contents of previous message"	s cr.	s nextPutAll: msg from; nextPutAll: ' wrote:'; cr.	msg body linesDo: [ :line |		s nextPutAll: '> '.		s nextPutAll: line.		s cr ].	s cr.	^s contents! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/18/1998 06:34'!sendQueuedMail	"send queued mail out"	| msgIds msgNum message recipients bareFrom |	"compute the main part of the From: address"	bareFrom _ (MailAddressParser addressesIn: self class userName) first.	"gather up message IDs of messages to send"	msgIds _ mailDB messagesIn: '.tosend.'.	msgIds isEmpty ifTrue: [		^self inform: 'all messages have been sent' ].	msgNum _ 1.	('sending ', msgIds size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgIds size		during: 	[ :bar | msgIds do: [ :id |		message _ mailDB getMessage: id.				"gather up the recipients"		recipients _ Set new.		recipients addAll: (MailAddressParser addressesIn: message to).		recipients addAll: (MailAddressParser addressesIn: message cc).		"send it out"		[(SMTPSocket 			deliverMailFrom: bareFrom			to: recipients 			text: message text 			usingServer: Celeste smtpServer) ifFalse: [ self error: 'error delivering mail' ].		] ifError: [ :a :b |			self error: 'error delivering message' ].			"inform the user we are starting a new message"		bar value: msgNum.		msgNum _ msgNum + 1.		].	"remove all these messages from the queue"	msgIds do: [ :id |		mailDB remove: id  fromCategory: '.tosend.' ].	].	mailDB saveDB.	"update any Celeste display windows to account for the changing .tosend. category"	self updateTOC.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/10/1998 23:36'!initialize	"Celeste initialize"	"user preferences"	InOutFolder _ nil.	UserName _ nil.	CCList _ nil.	SuppressWorthlessHeaderFields _ true.	EmailDBName _ 'EMAIL'.		"file to store user's EMAIL in"	QueueDBName _ 'QUEUE'.		"file to store outgoing email in"	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	DeleteInboxAfterFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:14'!versionString	"return a short string describing this version of Celeste"	^'Celeste 2.0'! !!Celeste class methodsFor: 'instance creation'!buildButtonsFor: model	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on:		(Switch new			onAction: [model subjectFilterOn];			offAction: [model subjectFilterOff]).	b	label: ('Subj. F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model fromFilterOn];			offAction: [model fromFilterOff]).	b	label: ('From F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model customFilterOn];			offAction: [model customFilterOff]).	b	label: ('Custom F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model reply]);		action: #turnOn;		label: ('Reply' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model forward]);		action: #turnOn;		label: ('Forward' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model deleteMessage]);		action: #turnOn;		label: ('Delete' asParagraph centered);		borderWidth: 1.	buttons add: b.	^ buttons! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 9/21/1998 11:06'!buildViewsFor: model	"Answer a collection of window panes for the Celeste user interface."	| listViewClass textViewClass listFont views v |	Smalltalk isMorphic		ifTrue: [			listViewClass _ PluggableListMorphByItem.			textViewClass _ PluggableTextMorph]		ifFalse: [			listViewClass _ PluggableListViewByItem.			textViewClass _ PluggableTextView].	listFont _ StrikeFont allInstances		detect: [:f | (f name beginsWith: 'CourierFixed') and: [f height = 11]]		ifNone: [TextStyle default fontAt: 1].	views _ OrderedCollection new.	v _ listViewClass		on: model		list: #categoryList		selected: #category		changeSelected: #setCategory:		menu: #categoryMenu:		keystroke: #categoriesKeystroke:.	views add: v.	v _ listViewClass		on: model		list: #tocEntryList		selected: #tocEntry		changeSelected: #setTOCEntry:		menu: #tocMenu:		keystroke: #tocKeystroke:.	v font: listFont.	views add: v.	v _ textViewClass new		on: model		text: #messageText		accept: #messageText:		readSelection: nil		menu: #messageMenu:shifted:.	v borderWidth: 1.	model messageTextView: v.	views add: v.	^ views! !!Celeste class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 03:05'!openOn: rootFilename	"Open a MailReader on the mail database with the given root filename."	|database |	database _  MailDB openOn: rootFilename.	database ifNotNil: [ ^ self openOnDatabase: database ].! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 9/21/1998 10:46'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: [			topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0@0.0 extent: 0.16@0.05).			topWindow addMorph: (buttons at: 2) frame: (0.16@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 3) frame: (0.33@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 4) frame: (0.50@0.0 extent: 0.16@0.05).			topWindow addMorph: (buttons at: 5) frame: (0.66@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 6) frame: (0.83@0.0 extent: 0.17@0.05).			topWindow addMorph: (views at: 1) frame: (0.0@0.05 extent: 0.2@0.25).			topWindow addMorph: (views at: 2) frame: (0.2@0.05 extent: 0.8@0.25).			topWindow addMorph: (views at: 3) frame: (0.0@0.30 extent: 1.0@0.70).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: [			topWindow _ StandardSystemView new				model: model;				label: 'Celeste';				minimumSize: 400@250.			(views at: 1) window: (0@0 extent: 20@25).			(views at: 2) window: (0@0 extent: 80@25).			(views at: 3) window: (0@0 extent: 100@70).			(buttons at: 1) window: (0@0 extent: 17@5).			(buttons at: 2) window: (0@0 extent: 17@5).			(buttons at: 3) window: (0@0 extent: 16@5).			(buttons at: 4) window: (0@0 extent: 17@5).			(buttons at: 5) window: (0@0 extent: 17@5).			(buttons at: 6) window: (0@0 extent: 16@5).			topWindow				addSubView: (buttons at: 1);				addSubView: (buttons at: 2) toRightOf: (buttons at: 1);				addSubView: (buttons at: 3) toRightOf: (buttons at: 2);				addSubView: (buttons at: 4) toRightOf: (buttons at: 3);				addSubView: (buttons at: 5) toRightOf: (buttons at: 4);				addSubView: (buttons at: 6) toRightOf: (buttons at: 5);				addSubView: (views at: 1) below: (buttons at: 1);				addSubView: (views at: 2) toRightOf: (views at: 1);				addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!ccList	"Answer the default cc list to be used in composing messages."	CCList isNil ifTrue: [CCList _ ''].	^CCList! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:52'!inOutFolder	"Answer the folder for the inbox/outbox files."	self halt: 'someone asked for InOutFolder'.	InOutFolder isNil ifTrue: [self setInOutFolder].	^InOutFolder! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popPassword	"answer the password to use when retrieving mail via POP"	"theoretically, this could remember the password for a little while.  But let's keep it simple for now"	^FillInTheBlank request: 'POP password'! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popServer	"Answer the server for downloading email via POP"	(PopServer isNil or: [PopServer isEmpty])		ifTrue: [self setPopServer].	PopServer isEmpty ifTrue: [		self error: 'POP server not specified' ].	^PopServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popUserName	"Answer the user's username on the POP server"	(PopUserName isNil or: [PopUserName isEmpty])		ifTrue: [self setPopUserName].	PopUserName isEmpty ifTrue: [ 		self error: 'no POP user name specified' ].	^PopUserName! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!setCCList	"Change the list of names used in the default cc list. Items in the list should be valid mail addresses and should be separated by commas."	| newList |	(CCList isNil) ifTrue: [CCList _ ''].	newList _ FillInTheBlank		request: 'addresses to automatically add to CC: fields?'		initialAnswer: CCList.	CCList _ newList.! !!Celeste class methodsFor: 'user preferences'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	(InOutFolder isNil) ifTrue: [InOutFolder _ ''].	InOutFolder _ FillInTheBlank		request: 'Where are the inbox and outbox files kept?'		initialAnswer: InOutFolder.	((InOutFolder size > 0) and:	 [(InOutFolder last = $:) or: [InOutFolder last = $/]]) ifTrue: [		"remove folder or directory delimitor"		InOutFolder _ InOutFolder copyFrom: 1 to: InOutFolder size - 1.	].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopServer	"Change the user's email name for use in composing messages."	(PopServer isNil) ifTrue: [PopServer _ ''].	PopServer _ FillInTheBlank		request: 'What is your POP server''s hostname?'		initialAnswer: PopServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopUserName	"set the POP server used for downloading email"	(PopUserName isNil) ifTrue: [PopUserName _ ''].	PopUserName _ FillInTheBlank		request: 'What is your username on your POP server?'		initialAnswer: PopUserName.	"be kind, if they include the host name here"	(PopUserName includes: $@) ifTrue: [		PopUserName _ PopUserName copyFrom: 1 to: (PopUserName indexOf: $@)-1 ].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setSmtpServer	"Set the SMTP server used to send outgoing messages via"	(SmtpServer isNil) ifTrue: [		PopServer isNil			ifTrue: [ SmtpServer _ '' ]			ifFalse: [ SmtpServer _ PopServer ] ].	SmtpServer _ FillInTheBlank		request: 'What is your mail server for outgoing mail?'		initialAnswer: SmtpServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:49'!setUserName	"Change the user's email name for use in composing messages."	(UserName isNil) ifTrue: [UserName _ ''].	UserName _ FillInTheBlank		request: 'What is your email address?\(This is the address other people will reply to you)' withCRs		initialAnswer: UserName.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!smtpServer	"Answer the server for sending email"	(SmtpServer isNil or: [SmtpServer isEmpty])		ifTrue: [self setSmtpServer].	SmtpServer isEmpty ifTrue: [		self error: 'no SMTP server specified' ].	^SmtpServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!userName	"Answer the user name to be used in composing messages."	(UserName isNil or: [UserName isEmpty])		ifTrue: [self setUserName].	UserName isEmpty ifTrue: [ self error: 'no user name specified' ].	^UserName! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/20/1998 11:48'!addMVCMailSenderButtons: topView textView: mailTextView	"Add some handy buttons to the mail sender window."	| sendButton sendAndKeepButton doneButton |	sendButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents]);			action: #turnOn;			label: ('Send' asParagraph centered);			window: (0@0 extent: 34@10);			borderWidth: 1.	sendAndKeepButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents.					 Celeste addMessageToInbox: mailTextView model contents]);			action: #turnOn;			label: ('Send&Keep' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	doneButton _		PluggableButtonView new			model: (Button new onAction: [topView controller close]);			action: #turnOn;			label: ('Done' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	topView		addSubView: sendButton above: topView firstSubView;		addSubView: sendAndKeepButton toRightOf: sendButton;		addSubView: doneButton toRightOf: sendAndKeepButton.! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	| mailBox |	mailBox _ FileStream fileNamed: Celeste inOutFolder, ':inbox'.	mailBox setToEnd.	"append this message to inbox"	mailBox nextPutAll: 'From local Sun 1990' ; cr.	mailBox nextPutAll: 'Date: ', Date today printString, ' ', Time now printString; cr.	mailBox nextPutAll: msgString; cr.	mailBox close.! !!Celeste class methodsFor: 'sending'!eudoraSeparator	"Return a Eudora-style message separator string."	| s today dateString |	s _ WriteStream on: (String new: 50).	today _ Date today.	dateString _ today printFormat: #(2 1 3 32 2 1).	dateString _ dateString copyFrom: 1 to: dateString size - 4.	s nextPutAll: 'From ???@??? '.	s nextPutAll: (today weekday copyFrom: 1 to: 3); space.	s nextPutAll: dateString.	Time now print24: true on: s.	s space.	s print: today year; cr.	^s contents! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!postToEudoraOutbox: msgString	"Append the given message to a Eudora outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	mailBox nextPutAll: self eudoraSeparator.	mailBox nextPutAll: (MailMessage from: msgString) eudoraOutboxText.	mailBox cr.	mailBox close.! !!Celeste class methodsFor: 'sending'!postToUnixOutbox: msgString	"Append the given message to a Unix shell-script outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	"append this message to outbox"	mailBox nextPutAll: 'cat - >outgoingMsg <<\endmsg'; cr.	mailBox nextPutAll: msgString; cr.	mailBox nextPutAll: 'endmsg'; cr.	mailBox nextPutAll: '/usr/lib/sendmail -v -t <outgoingMsg'; cr.	mailBox close.! !!ChangeList methodsFor: 'scanning' stamp: 'sw 9/10/1998 15:17'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ prevPos // 16r1000000.						prevPos _ prevPos \\ 16r1000000]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/12/1998 16:33'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:17'!browseVersionsOf: method class: class meta: meta		category: category selector: selector 	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[self open: changeList name: 'Recent versions of ' , selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:18'!browseVersionsOf: method class: class meta: meta		category: category selector: selector lostMethodPointer: sourcePointer	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[changeList setLostMethodPointer: sourcePointer.			self open: changeList name: 'Recent versions of ' , selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:39'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  6/28/96 sw"		| method aChangeList |	method _ aClass compiledMethodAt: aSelector.	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !!ChangeList class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:40'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window listView |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: (listView _ PluggableListMorph on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3)."	multiSelect ifTrue: [listView controller: PluggableListControllerOfMany new]."	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!ChangeRecord methodsFor: 'access' stamp: 'sw 8/24/1998 08:16'!fileIn	| methodClass |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil].		(type == #doIt) ifTrue:			[Compiler evaluate: self string].		(type == #classComment) ifTrue:			[(Smalltalk at: class asSymbol) comment: self text stamp: stamp]]! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 16:05'!expungeEmptyClassChangeEntries	| toRemove |	toRemove _ OrderedCollection new.	classChanges associationsDo:		[:assoc | assoc value isEmpty ifTrue:			[toRemove add: assoc key]]. 	toRemove do:		[:aKey | classChanges removeKey: aKey ifAbsent: []]! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 14:36'!forgetAllChangesFoundIn: aChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner.	sw 8/14/1998 17:30:  This method somehow became very badly, and damagingly, broken since I originally wrote it.  Below is an attempt to bring it back to health, or at least to remove the most damaging of its bugs."	| cls itsMethodChanges myClassChange |	aChangeSet == self ifTrue: [^ self].	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo:					[:assoc | self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]]]].	classRemoves removeAllFoundIn: aChangeSet classRemoves.	"names of them"	self expungeEmptyClassChangeEntries! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/14/1998 17:22'!removeAllMemoryOfChangesTo: class	"Remove all memory of changes associated with this class"	classChanges removeKey: class name ifAbsent: [].	methodChanges removeKey: class name ifAbsent: [].	classRemoves remove: class name ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/22/1998 21:12'!removeAllMemoryOfChangesToClassNamed: className	"Remove all memory of changes associated with this class"	classChanges removeKey: className ifAbsent: [].	methodChanges removeKey: className ifAbsent: [].	classRemoves remove: className ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'ls 8/12/1998 23:47'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	classChanges removeKey:  cname ifAbsent: [].	methodChanges removeKey:  cname ifAbsent: [].	classRemoves remove:  cname ifAbsent: [].! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 8/14/1998 17:16'!forgetChange: actionToSubtract forSelector: selector class: class 	"If the receiver records a change that can be subsumed by the change given by the parameters, which characterize a change in another change set which is being 'subtracted' from the receiver, remove it from the receiver."	| myChangeDictionaryForClass methodCurrentlyExists |	myChangeDictionaryForClass _ methodChanges at: class name ifAbsent: [^ self].	methodCurrentlyExists _ class includesSelector: selector.	((#(add change) includes: actionToSubtract) and: [methodCurrentlyExists])		ifTrue:			[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	((#(remove addedThenRemoved) includes: actionToSubtract) and: [methodCurrentlyExists not])			ifTrue:				[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	myChangeDictionaryForClass isEmpty ifTrue: [methodChanges removeKey: class name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 8/10/1998 07:13'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips changes method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		changes _ methodChanges at: aClass name ifAbsent: [nil].		changes ifNotNil:			[changes associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/15/1998 16:52'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	"wod 5/12/1998: use #asFileName rather than #truncateTo:"	| file slips |	Cursor write showWhile:		[file _ FileStream newFileNamed:			(self name, FileDirectory dot, Utilities dateTimeSuffix, FileDirectory dot, 'cs') asFileName.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/10/1998 12:37'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/16/1998 09:36'!summaryString	"Answer the string summarizing this changeSet"	| ps s2 date author line |	^ String streamContents:		[:s |		s nextPutAll: self name.		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:		'.  date _ s2 upTo: Character cr.			s2 match: 'Author:			'.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]]."To summarize all changeSets in this image...(FileStream newFileNamed: 'ChangeSummaries.txt') nextPutAll:(String streamContents:	[:s | ChangeSorter gatherChangeSets do:		[:cs | s nextPutAll: cs summaryString; cr]])"! !!ChangeSet methodsFor: 'private' stamp: 'sw 9/2/1998 14:24'!fileOutClassModifications: class on: stream 	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes."	| aClass |	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #comment) ifTrue:		[(aClass _ class theNonMetaClass) organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: aClass].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'accessing' stamp: 'di 5/25/1998 14:24'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:43'!oldOpenAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| buttonView col aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	buttonView _ PluggableButtonMorph		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	col _ Color perform: self defaultBackgroundColor.	buttonView		label: myChangeSet name; 		onColor: col offColor: col;		triggerOnMouseDown: true; borderColor: window color.	window addMorph: buttonView		frame: (((0@0 extent: 1.0@0.06) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0.5@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.36 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/8/1998 17:35'!oldOpenView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView buttonView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	buttonView _ PluggableButtonView		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	buttonView		label: myChangeSet name;		triggerOnMouseDown: true; borderWidth: 1; 		window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	topView addSubView: buttonView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: classView below: buttonView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: messageView toRightOf: classView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'creation' stamp: 'jm 7/5/1998 12:35'!openAsMorph	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	window openInWorld.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 16:48'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| chgSetList aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (chgSetList _ PluggableListMorphByItem on: self			list: #changeSetList			selected: #currentCngSet			changeSelected: #showChangeSetNamed:			menu: #changeSetMenu:)		frame: (((0@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	chgSetList autoDeselect: false.	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0.5@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph  menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0@0.25 extent: 1@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.5 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:18'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:.	cngSetListView window: ((0 @ 0 extent: 180 @ 100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (180 @ 0 extent: 180 @ 100).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: (0 @ 100 extent: 360 @ 100).	topView addSubView: messageView below: cngSetListView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: messageView.! !!ChangeSorter methodsFor: 'access' stamp: 'di 6/15/1998 20:33'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 08:15'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self changed: #contents.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 07:38'!showChangeSetNamed: aName	aName ifNil: [^ self showChangeSet: nil].	self showChangeSet: 		(AllChangeSets detect: [:each | each name = aName]) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/12/1998 16:29'!changeSetList	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	^ AllChangeSets reversed collect: [:each | each name]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/17/1998 17:57'!chooseCngSet	"Put up a list of them"	| index |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	index _ (PopUpMenu labels: 		(AllChangeSets reversed collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (AllChangeSets at: (AllChangeSets size - index + 1))].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 9/4/1998 09:00'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self update.		self showChangeSet: aSet.		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 11:58'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self inform: 'No change made'].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:19'!updateIfNecessary	"recompute all of my panes"	| newList |	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:07'!classMenu: aMenu	"Could be for a single or double changeSorter"	^ parent ifNotNil:		[aMenu labels: 'copy class chgs to other sidemove class chgs to other sidedelete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(3 4 )		selections: #(copyClassToOther moveClassToOther forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]	ifNil:		[ aMenu labels: 'delete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(1 2 )		selections: #(forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:17'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	| info cls otherSorter otherChangeSet |	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet == myChangeSet ifTrue: [^ self beep].	(myChangeSet classRemoves includes: currentClassName)		ifTrue:			[otherChangeSet noteRemovalOf: currentClassName]		ifFalse:			[info _ myChangeSet classChangeAt: (cls _ self selectedClassOrMetaClass) name.			info do: [:each | otherChangeSet atClass: cls add: each].			info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].			info associationsDo: [:ass |				otherChangeSet atSelector: ass key class: cls put: ass value]].	otherSorter showChangeSet: otherChangeSet.	self forgetClass! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:57'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil:		[^ aMenu labels: 'copy method to other sidemove method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 4 7 11)		selections: #(copyMethodToOther moveMethodToOtherforget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]	ifNil: [^ aMenu labels: 'delete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 5 9 )		selections: #( forget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:56'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other info cls sel |	self okToChange ifFalse: [^ self beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].		other atSelector: sel			class: cls 			put: (info at: sel).			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:44'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionrevert and forgetmore...' 	lines: #(5 7 9)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!ChangeSorter methodsFor: 'code pane' stamp: 'di 9/21/1998 23:57'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ ''].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr]].			^ contents _ strm contents].! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 9/4/1998 14:38'!newChangeSet	"Prompt the user for a name, and establish a new change set of that name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank request: 'Please name the new change set:'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue:		[self inform: 'nothing done'.		^ nil].	(self changeSetNamed: newName) ifNotNil:			[self inform: 'Sorry that name is already used'.			^ nil].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	Smalltalk newChanges: newSet.	Transcript cr; show: newName, ' is now the current change set'.	^ newSet! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 8/3/1998 16:26'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed, and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| aCount |	aCount _ 0.	AllChangeSets copy do:		[:aChangeSet | ((aChangeSet name beginsWith: 'Unnamed') and:			[(aChangeSet okayToRemoveInforming: false) and: [aChangeSet isEmpty]])				ifTrue:					[aCount _ aCount + 1.					AllChangeSets remove: aChangeSet.					aChangeSet wither]].	self inform: aCount printString, ' change set(s) removed.'! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  "	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented.	self openMessageList: messageSet name: ('Methods in Change Set ', aChangeSet name) autoSelect: nil changeSet: aChangeSet! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	| messageSet |	messageSet _ self messageList: messageList.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: autoSelectString.	World		ifNotNil:			[self openAsMorph: messageSet name: labelString]		ifNil:			[ScheduledControllers scheduleActive:  (self open: messageSet name: labelString)]! !!Character methodsFor: 'testing' stamp: 'ls 7/26/1998 20:27'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^self isAlphaNumeric or: [ '.~-_' includes: self ]! !!Character methodsFor: 'converting' stamp: 'ls 9/5/1998 01:18'!asIRCLowercase	"convert to lowercase, using IRC's rules"	self == $[ ifTrue: [ ^ ${ ].	self == $] ifTrue: [ ^ $} ].	self == $\ ifTrue: [ ^ $| ].	^self asLowercase! !!Character class methodsFor: 'instance creation' stamp: 'ls 8/15/1998 06:56'!allCharacters	^ (0 to: 255)		collect: [:v | Character value: v]	! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/8/1998 22:15'!lf	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/14/1998 22:08'!nbsp	"non-breakable space.  It looks like a space, but it's not considered a separator"	#xxx. "the correct code for ISO 8859-1 is 160.  However, Squeak's character 160 doesn't look right.  If you value absolute correctness over looks, then change this back"	"Character value: 160"	^Character value: 0! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:55'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel isNil ifTrue: [ 0 ] ifFalse: [ indentationLevel ]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:54'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 14:55'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	destX _ destX + (width _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + width) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis fo rnext run"	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 19:45'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta displaying: display 	"This method will perform text scanning with non-zero kerning.	It calls the faster primitive method, if the kern delta is zero.	Some day we may want to put kerning into the primitive."	| ascii nextDestX maxAscii fillBlt |	line first = startIndex ifTrue: [		"handle indentation"		self indentationLevel timesRepeat: [ self tab ] ].		kernDelta = 0 ifTrue:		[^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString				rightX: rightX stopConditions: stops displaying: display].	display ifTrue: [fillBlt _ self fillBlt].	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue:				[self copyBits				fillBlt == nil ifFalse:					[fillBlt destX: nextDestX destY: destY							width: kernDelta height: height;							copyBits]].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private' stamp: 'ls 7/16/1998 01:39'!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	alignment _ textStyle alignment.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !A set of characters.  Lookups for inclusion are very fast.!!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:33'!add: aCharacter	map at: aCharacter asciiValue+1  put: 1.! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:41'!do: aBlock	"evaluate aBlock with each character in the set"	Character allCharacters do: [ :c |		(self includes: c) ifTrue: [ aBlock value: c ] ]! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:31'!includes: aCharacter	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:34'!remove: aCharacter	map at: aCharacter asciiValue + 1  put: 0! !!CharacterSet methodsFor: 'conversion' stamp: 'ls 8/17/1998 20:39'!complement	"return a character set containing precisely the characters the receiver does not"	| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!= anObject	^self class == anObject class and: [		self byteArrayMap = anObject byteArrayMap ]! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!hash	^self byteArrayMap hash! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:35'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^map! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map _ ByteArray new: 256 withAll: 0.! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set _ self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:36'!empty 	"return an empty set of characters"	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:31'!new	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!nonSeparators	"return a set containing everything but the whitespace characters"	^self separators complement! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set _ self empty.	set addAll: Character separators.	^set! !!Class methodsFor: 'initialize-release' stamp: 'sw 8/11/1998 13:23'!removeFromSystemUnlogged	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"	Smalltalk removeClassFromSystemUnlogged: self.	self obsolete! !!Class methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 09:53'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver and redefine its subclasses if necessary."	super		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	self ~~ oldClass		ifTrue: 			[environ at: name put: self.			oldClass obsolete]! !!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 10:01'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:28'!comment	"Answer the receiver's comment. (If old format, not a Text, unpack the old way.) "	| aString |	aString _ self theNonMetaClass organization classComment.	(aString asString beginsWith: self name, ' comment:\''' withCRs) 		ifFalse: [^ aString]		ifTrue: ["old format"			aString size = 0 ifTrue: [^ ''].			"get string only of classComment, undoubling quotes"			^ String readFromString: aString]! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/8/1998 14:43'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	Smalltalk changes commentClass: self theNonMetaClass! !!ClassDescription methodsFor: 'copying' stamp: 'sw 6/16/1998 15:01'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 08:40'!renameInstVar: oldName to: newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 15:30'!renameSilentlyInstVar: oldName to: newName	| i oldCode newCode parser header body sels |	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 8/11/1998 12:52'!removeSelectorUnlogged: aSymbol 	"Remove the message whose selector is aSymbol from the method dictionary of the receiver, if it is there. Answer nil otherwise.  Do not log the action either to the current change set or to the changes log"	(methodDict includesKey: aSymbol) ifFalse: [^ nil].	super removeSelector: aSymbol.	self organization removeElement: aSymbol! !!ClassDescription methodsFor: 'compiling' stamp: 'di 8/21/1998 11:01'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode newText |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [text askIfAddStyle: priorMethod req: requestor]			ifFalse: [text].		 method putSource: newText				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/11/1998 14:40'!compileUnlogged: text classified: category notifying: requestor 	| selector  |	self compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^ nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel].	self organization classify: selector under: category.	^ selector! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/8/1998 14:44'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:30'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ organization classComment: aString].	oldCommentRemoteStr _ organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).	Smalltalk changes commentClass: self.	! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/2/1998 14:22'!commentStamp: changeStamp	self organization commentStamp: changeStamp.    ^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 22:02'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(65 333 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 15:26'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	Smalltalk changes reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !I represent method categorization information for classes.  The handling of class comments has gone through a tortuous evolution.   Grandfathered class comments (before late aug 98) have no time stamps, and historically, fileouts of class comments always substituted the timestamp reflecting the author and date/time at the moment of fileout; and historically any timestamps in a filed out class comment were dropped on the floor, with the author & time prevailing at the moment of filein being substituted.   Such grandfathered comments now go out on fileouts with '<historical>' timestamp; class comments created after the 8/98 changes will have their correct timestamps preserved, though there is not yet a decent ui for reading those stamps other than filing out and looking at the file; nor is there yet any ui for browsing and recovering past versions of such comments.  Everything in good time!!!!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp	^ commentStamp! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp: aStamp	commentStamp _ aStamp! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:33'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	globalComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp _ '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!Color methodsFor: 'transformations' stamp: 'jm 6/25/1998 10:12'!darker	"Answer a darker shade of this color."	^ self mixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'jm 6/17/1998 11:23'!lighter	"Answer a lighter shade of this color."	^ self mixed: 0.8333 with: Color white! !!Color methodsFor: 'other' stamp: 'sw 6/10/1998 17:50'!newTileMorphRepresentative	^ ColorTileMorph new colorSwatchColor: self! !!Color methodsFor: 'conversions' stamp: 'jm 6/2/1998 14:56'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val rgbBlack32 |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		rgbBlack32 _ 16rFF000001.  "closest black for 32-bit depth, with opaque alpha"		"eight bits per component; top 8 bits set to all ones (opaque)"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack32] ifFalse: [16rFF000000 + val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'copying' stamp: 'tk 8/19/1998 16:12'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:48'!indexOfColor: aColor	"Return the index of aColor in my color array"	self ensureColorArrayExists.	^ colors indexOf: aColor ifAbsent: [0]! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:49'!replaceColorAtIndex: index with: newColor	"Replace a color map entry with newColor."	self ensureColorArrayExists.	colors at: index put: newColor.	cachedColormap == nil ifFalse:		[cachedColormap at: index put: (newColor pixelValueForDepth: cachedDepth)]! !!ColorSeerTile methodsFor: 'as yet unclassified' stamp: 'jm 5/28/1998 19:19'!storeCodeOn: aStream indent: tabCount	"We have a hidden arg. Output two keywords with interspersed arguments."	| parts |	parts _ operatorOrExpression keywords.	"color:sees:"	^ aStream nextPutAll: (parts at: 1); space;		nextPutAll: colorSwatch color printString; space;		nextPutAll: (parts at: 2).! !!ColorTileMorph methodsFor: 'events' stamp: 'sw 9/10/1998 08:22'!mouseUp: evt	evt hand changeColorTarget: colorSwatch selector: #userSelectedColor:! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 6/10/1998 17:49'!colorSwatchColor: aColor	colorSwatch color: aColor! !!ColorTileMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:02'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: colorSwatch color printString.! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:58'!process: request	"URLs are of the form Comment.commentKey or	Comment.commentKey.note of Comment.commentKey.gif.	If commentKey is accessed but not created, create an empty one.	If note is accessed, display it."	| commentKey noteIndex newNote |	(request message size > 1) ifTrue: [commentKey _ request message at: 2]	ifFalse: [^request reply: (self showAllComments: CommentsTable)].	(CommentsTable includesKey: commentKey)		ifFalse:			[CommentsTable at: commentKey put: Discussion new.			(CommentsTable at: commentKey)				title: commentKey.			(CommentsTable at: commentKey)				description: 'Discussion on ' , commentKey].	request fields isNil		ifFalse:			["Are there input fields?"			newNote _ self createComment: request.			newNote parent: commentKey.			(CommentsTable at: commentKey)				addNote: newNote.			newNote url: ('Comment.',commentKey,'.',				(CommentsTable at: commentKey) notes sizeprintString)].	request message size > 2		ifTrue:			["There's a note reference or a request for astatus image"			noteIndex _ request message at: 3.			noteIndex asUppercase = 'GIF'			ifTrue: [			request reply: (PWS success),(PWS content:'image/gif').			request reply: (HTMLformatter textToGIF:				(CommentsTable at: commentKey) status)]			ifFalse: [request reply: (self showNote:((CommentsTable at: commentKey)						at: noteIndex asNumber))]]		ifFalse: [request reply: (self showComment: (CommentsTableat: commentKey))]! !!Comment class methodsFor: 'URL processing' stamp: 'TPR 7/20/1998 18:07'!showAllComments: aDictionaryOfCommentSpaces	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowAllComments.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName)contentsOfEntireFile with: aDictionaryOfCommentSpaces! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 8/20/1998 09:31'!hasReportableSlip	"Answer whether the receiver contains anything that might be brought to the attention of the author when filing out.   Customize the lists to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'suppressCheckForSlips' has not been hard-coded to true."	| assoc | 	#(halt halt: urgent hottest) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:14'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 8/19/1998 16:20'!veryDeepCopyWith: deepCopier	"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way."! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2output	^functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2outputSet: newValue	functionComponent2output _ newValue.	self changed: #functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItem	^listComponent2selectedItem! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItemSet: newValue	listComponent2selectedItem _ newValue.	self changed: #listComponent2selectedItem! !!Component1 methodsFor: 'functions' stamp: 'di 9/15/1998 17:10'!functionComponent2a: a 	^ Smalltalk at: a! !!CompositionScanner methodsFor: 'initialize-release' stamp: 'jm 5/29/1998 14:48'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	super		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:50'!handlesMouseOverDragging: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows _ scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r _ rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:31'!storeCodeOn: aStream indent: tabCount	aStream nextPut: $(.	testPart storeCodeOn: aStream indent: 0.	aStream nextPut: $); cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifTrue: ['; cr.	self storeCodeBlockFor: yesPart on: aStream indent: tabCount + 2.	aStream nextPut: $]; cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifFalse: ['; cr.	self storeCodeBlockFor: noPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !!ContextPart methodsFor: 'printing' stamp: 'di 9/10/1998 09:19'!printOn: aStream 	| selector class |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:mclass].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'private' stamp: 'afr 9/11/1998 19:50'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value t1 t2 t3 |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!control	^ control! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!control: midiControl	control _ midiControl.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!control: midiControl value: midiControlValue channel: midiChannel	control _ midiControl.	value _ midiControlValue.	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02'!value	^ value! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!value: midiControlValue	value _ midiControlValue.! !!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isControlChange	^ true! !!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rB0		channel: channel		byte: control		byte: value.! !!ControlChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': ctrl['.	control printOn: aStream.	aStream nextPutAll: ']='.	value printOn: aStream.	aStream nextPut: $).! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'di 6/20/1998 12:59'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/13/1998 00:48'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!initialize	"Controller initialize"	self MinActivityLapse: 10.! !!CrLfFileStream methodsFor: 'open/close' stamp: 'ar 1/20/98 16:15'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be 	read-only. "	| result |	result _ super open: aFileName forWrite: writeMode.	result ifNotNil: [self detectLineEndConvention].	^ result! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!ascii	super ascii.	self detectLineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!binary	super binary.	lineEndConvention _ nil! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 7/10/1998 23:35'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead pos |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	lineEndConvention _ LineEndDefault.	"Default if nothing else found"	numRead _ 0.	pos _ super position.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char _ super next.			char = Lf				ifTrue: 					[super position: pos.					^ lineEndConvention _ #lf].			char = Cr				ifTrue: 					[super peek = Lf						ifTrue: [lineEndConvention _ #crlf]						ifFalse: [lineEndConvention _ #cr].					super position: pos.					^ lineEndConvention].			numRead _ numRead + 1].	super position: pos.	^ lineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:17'!next	| char |	char _ super next.	lineEndConvention ifNil: [^ char].	(LineEndStrings at: lineEndConvention) first = char		ifTrue: [lineEndConvention = #crlf				ifTrue: [self peek = Character lf						ifTrue: 							[super next.							^ Cr]						ifFalse: [^ char]]				ifFalse: [^ Cr]]		ifFalse: [^ char]! !!CrLfFileStream methodsFor: 'access' stamp: 'di 9/22/1998 16:34'!next: n 	| string |	string _ super next: n.	string size = 0 ifTrue: [^ string].	lineEndConvention ifNil: [^ string].	lineEndConvention == #crlf ifTrue:		["Special case for last character"		(string last = Cr and: [self peek = Lf]) ifTrue: [self next]].	string _ self convertStringToCr: string.	string size = n ifTrue: [^ string].	"string shrunk due to embedded crlfs; make up the difference"	^ string , (self next: n - string size)! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPut: char 	(lineEndConvention notNil and: [char = Cr])		ifTrue: [super nextPutAll: (LineEndStrings at: lineEndConvention)]		ifFalse: [super nextPut: char].	^ char! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPutAll: aString 	super nextPutAll: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!verbatim: aString 	super verbatim: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringToCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCR	"CrLfFileStream defaultToCR"	LineEndDefault := #cr.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCRLF	"CrLfFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToLF	"CrLfFileStream defaultToLF"	LineEndDefault := #lf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:13'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $: ifTrue:[^self defaultToCR].	FileDirectory pathNameDelimiter = $/ ifTrue:[^self defaultToLF].	FileDirectory pathNameDelimiter = $\ ifTrue:[^self defaultToCRLF].	"in case we don't know"	^self defaultToCR! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:14'!initialize	"CrLfFileStream initialize"	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.	self guessDefaultLineEndConvention.! !!Cursor methodsFor: 'displaying' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title _ aTitle! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList _ (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray _ #()]		ifNotNil: [linesArray _ anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font _ aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'di 8/20/1998 09:24'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!CustomMenu methodsFor: 'private' stamp: 'jm 8/20/1998 08:30'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [: label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: (TextStyle default fontAt: 1)		lines: dividers.! !!DataMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:46'!becomeField	| aStack slotNameChosen  |	aStack _ self pasteUpMorph assuredPlayer.	slotNameChosen _ aStack addSlotNamedLike: self externalName withValue: self valueFromContents.	self getSelector: (Utilities getterSelectorFor: slotNameChosen).	self putSelector: (Utilities setterSelectorFor: slotNameChosen).	self target: aStack.	status _ #field.	aStack updateAllViewers! !This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn't repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored.  On the high level, objectToStoreOnDataStream allows you to substitute another object on the way out.  The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload and (class) readDataFrom:size:. See these methods, and the class DiskProxy, for more information about externalizing and internalizing.NOTE: A DataStream should be treated as a write-stream for writing.  It is a read-stream for reading.  It is not a ReadWriteStream.!!DataStream methodsFor: 'all' stamp: 'tk 9/9/1998 14:10'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].	"After reading the externalObject, internalize it.	 #readReference is a special case. Either:	   (1) We actually have to read the object, recursively calling		   next, which internalizes the object.	   (2) We just read a reference to an object already read and		   thus already interalized.	 Either way, we must not re-internalize the object here."	selector == #readReference ifFalse:		[anObject _ self internalize: anObject].	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:18'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectToStoreOnDataStream) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectToStoreOnDataStream.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'all' stamp: 'jm 8/19/1998 17:00'!readByteArray	"PRIVATE -- Read the contents of a ByteArray."	| count |	count _ byteStream nextNumber: 4.	^ byteStream next: count  "assume stream is in binary mode"! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:32'!readShortRef	"Read an object reference from two bytes only.  Original object must be in first 65536 bytes of the file.  Relative to start of data.  vacantRef not a possibility."	^ self objectAt: (byteStream nextNumber: 2)! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:03'!readString	| str |	byteStream ascii.	str _ byteStream nextString.	byteStream binary.	^ str! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:27'!readStringOld   ^ byteStream nextStringOld! !!DataStream methodsFor: 'all' stamp: 'tk 8/18/1998 08:59'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	aStream binary.	basePos _ aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream _ aStream.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:13'!typeIDFor: anObject	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  	Classes can control their instance variables by defining objectToStoreOnDataStream.	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."		^ TypeMap at: anObject class ifAbsent: [9 "instance of any normal class"]	"See DataStream initialize.  nil=1. true=2. false=3. a SmallInteger=4. (a String was 5). a Symbol=6.  a ByteArray=7. an Array=8. other = 9.  a Bitmap=11. a Metaclass=12. a Float=14.  a Rectangle=15. any instance that can have a short header=16.  a String=17 (new format)."! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:16'!vacantRef	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference	 position' to identify a reference that's not yet filled in. This must be a	 value that won't be used as an ordinary reference. Cf. outputReference: and	 readReference. -- 	 NOTE: We could use a different type ID for vacant-refs rather than writing		object-references with a magic value. (The type ID and value are		overwritten by ordinary object-references when weak refs are fullfilled.)"	^ SmallInteger maxVal! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!writeBitmap: aBitmap	"PRIVATE -- Write the contents of a Bitmap."	aBitmap writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words."! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!writeByteArray: aByteArray	"PRIVATE -- Write the contents of a ByteArray."	byteStream nextNumber: 4 put: aByteArray size.	"May have to convert types here..."	byteStream nextPutAll: aByteArray.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 20:57'!writeString: aString	"PRIVATE -- Write the contents of a String."	byteStream nextStringPut: aString.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:23'!writeStringOld: aString	"PRIVATE -- Write the contents of a String."	| length |	aString size < 16384 		ifTrue: [			(length _ aString size) < 192				ifTrue: [byteStream nextPut: length]				ifFalse: 					[byteStream nextPut: (length // 256 + 192).					byteStream nextPut: (length \\ 256)].			aString do: [:char | byteStream nextPut: char asciiValue]]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!DataStream class methodsFor: 'all' stamp: 'tk 6/8/1998 21:10'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 40. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"Does anything use this?"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	"t at:  put: 18.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!Date class methodsFor: 'instance creation' stamp: 'ls 7/25/1998 01:15'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 	1901."	^self fromDays: seconds // 86400! !!Date class methodsFor: 'instance creation' stamp: 'di 5/26/1998 11:53'!newDay: day month: month year: year 	"Note: day, month and year are all integers, except month may be a string"	"Answer an instance of me which is the day'th day of the month named 	 month in the year'th year. The year may be specified as the actual 	 number of years since the beginning of the Roman calendar or the 	 number of years since 1900.  **Note** two digit dates are always from 1900.		1/1/01 will NOT mean 2001."	"Tolerate a month index instead of a month name."	| monthIndex daysInMonth firstDayOfMonth |	year < 100 ifTrue: [^ self			newDay: day			month: month			year: 1900 + year].	monthIndex _ month isInteger	 ifTrue: [month] ifFalse: [self indexOfMonth: month].	monthIndex = 2		ifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [daysInMonth _ DaysInMonth at: monthIndex].	monthIndex > 2		ifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].	(day < 1 or: [day > daysInMonth])		ifTrue: [self error: 'illegal day in month']		ifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:22'!buildMVCDebuggerViewLabel: aString minSize: aPoint	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	self expandStack.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	stackListView _ PluggableListView on: self			list: #contextStackList			selected: #contextStackIndex			changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted:			keystroke: #contextStackKey:from:.		stackListView menuTitleSelector: #messageListSelectorTitle.		stackListView window: (0 @ 0 extent: 150 @ 50).		topView addSubView: stackListView.	stackCodeView _ PluggableTextView on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ PluggableListView on: self receiverInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ PluggableTextView on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ PluggableListView on: self contextVariablesInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ PluggableTextView on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: ctxtValView toRightOf: ctxtVarView.	topView label: aString.	topView minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'wod 5/26/1998 16:44'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (SystemWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:44'!openFullMorphicLabel: labelString	| window aListMorph |	self expandStack.	window _ (SystemWindow labelled: labelString) model: self.	aListMorph _ PluggableListMorph on: self list: #contextStackList			selected: #contextStackIndex changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted: keystroke: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@0.7).	window addMorph: (PluggableListMorph on: self receiverInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0.7 corner: 0.2@1).	window addMorph: (PluggableTextMorph on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.2@0.7 corner: 0.5@1).	window addMorph: (PluggableListMorph on: self contextVariablesInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0.5@0.7 corner: 0.7@1).	window addMorph: (PluggableTextMorph on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.7@0.7 corner: 1@1).	^ window openInWorld! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 13:04'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msgString]		ifFalse: [msg _ msgString].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcess].	Display fullScreen.	Cursor normal show.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:31'!release	self windowIsClosing.	super release.! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:30'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'notifier menu' stamp: 'wod 5/26/1998 16:19'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."	World ifNotNil:		[self breakDependents.		self openFullMorphicLabel: topView label.		^ topView delete].	topView controller controlTerminate.	topView deEmphasizeView; erase.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack (message list)' stamp: 'di 9/22/1998 00:26'!selectedMessage	"Answer the source code of the currently selected context."	contents _ self selectedContext sourceCode.	Preferences browseWithPrettyPrint ifTrue: [contents _ self selectedClass compilerClass new					format: contents					in: self selectedClass					notifying: nil].	^ contents _ contents asText makeSelectorBoldIn: self selectedClass! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 8/18/1998 16:35'!contextStackMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)senders of...implementors of...method inheritanceversionsinst var refs...inst var defs...class var refs...class variablesclass refsbrowse fullmore...'	lines: #(6 10 12 15)	selections: #(fullStack restart proceed step send wherebrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFullshiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'context stack menu' stamp: 'ar 5/26/1998 16:26'!step	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #contentsSelection]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #contentsSelection.					self updateInspectors]]! !!Debugger methodsFor: 'code pane' stamp: 'di 9/22/1998 00:21'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i methodNode pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.		sourceMap _ methodNode sourceMap.		tempNames _ methodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	pc_ self selectedContext pc -		((externalInterrupt and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'private' stamp: 'di 9/22/1998 00:21'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self changed: #contents.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self changed: #contents.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'di 6/20/1998 14:48'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'instance creation' stamp: 'di 6/17/1998 14:39'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'di 9/22/1998 00:35'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| f |	<primitive: 19> "Simulation guard"	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	Preferences logDebuggerStackToFile ifTrue:		[FileDirectory default deleteFileNamed: 'SqueakDebug.log' ifAbsent: [].		f _ FileStream fileNamed: 'SqueakDebug.log'.		f nextPutAll: aString; cr.		aContext stack do: [:ctxt | f print: ctxt; cr].		f close].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'di 6/30/1998 12:13'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   All uniClass instances do have a new class created for them.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepcopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/31/1998 15:47'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, you MUST go the the method being checked (veryDeepCopyWith:) and update its code.  And then update the test here.""All classes that implements veryDeepCopyWith: for the purpose of not doing a veryDeepCopy on some inst var, must have a check here."	| str str2 |	str _ '|veryDeepCopyWith: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self halt: 'Morph', str].	"added ones are OK"	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/22/1998 11:25'!initialize	references _ IdentityDictionary new: 4096.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	(self identityHash // 16 bitAnd: 7) = 1 ifTrue: [self checkVariables].		"Just check once in a while"! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/31/1998 15:52'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321).""Uniclasses use class vars to hold onto siblings who are referred to in code"| pp |pp _ Object class instSize + 1.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+0"	"(pp+1) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+2 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 22:13'!references	^ references! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/19/1998 15:48'!uniClasses	^uniClasses! !!Dictionary methodsFor: 'user interface' stamp: 'di 9/23/1998 12:20'!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  "	| viewClass |	viewClass _ PluggableTextView.	Smalltalk at: #FormInspectView		ifPresent: [:formInspectView | viewClass _ formInspectView].	^ DictionaryInspector openOn: self withEvalPane: true		withLabel: aLabel		valueViewClass: viewClass! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:25'!contentsIsString	"Hacked so contents empty when deselected"	^ (selectionIndex = 0)! !an entry in a directory; a reference to either a file or a directory.!!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!creationTime	"time the entry was created.  (what's its type?)"	^creationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!fileSize	"size of the entry, if it's a file"	^fileSize! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!isDirectory	"whether this entry represents a directory"	^dirFlag! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!modificationTime	"time the entry was last modified"	^modificationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!name	"name of the entry"	^name! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:29'!at: index	"compatibility interface"	"self halt: 'old-style access to DirectoryEntry'"	index = 1 ifTrue: [ ^self name ].	index = 2 ifTrue: [ ^self creationTime ].	index = 3 ifTrue: [ ^self modificationTime ].	index = 4 ifTrue:[ ^self isDirectory ].	index = 5 ifTrue:[ ^self fileSize ].	self error: 'invalid index specified'.! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:16'!size	^5! !!DirectoryEntry methodsFor: 'private-initialization' stamp: 'ls 7/15/1998 21:42'!privateName: name0  creationTime: creationTime0  modificationTime: modificationTime0  isDirectory: isDirectory0  fileSize: fileSize0	name _ name0.	creationTime _ creationTime0.	modificationTime _ modificationTime0.	dirFlag _ isDirectory0.	fileSize _ fileSize0.! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:42'!fromArray: array	^self name: (array at: 1) creationTime: (array at: 2) modificationTime: (array at: 3) isDirectory: (array at: 4) fileSize: (array at: 5) ! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:41'!name: name0  creationTime: creationTime  modificationTime: modificationTime   isDirectory: isDirectory  fileSize: fileSize	^self new privateName: name0  creationTime: creationTime  modificationTime: modificationTime  isDirectory: isDirectory  fileSize: fileSize! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!author	^self description! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!children	^#()! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:45'!timestamp	^String new:0! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:53'!url	"fake the url as the title"	^'Comment.', self title! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:31'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 16:03'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				height _ anchoredMorph height.				runX _ destX.				anchoredMorph displayOn: destForm at: destX - width@destY].	^ true! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !!DosFileDirectory methodsFor: 'all' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DosFileDirectory methodsFor: 'all' stamp: 'di 9/11/1998 16:15'!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue: [''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !a placeholder for an image that is downloading!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 8/20/1998 09:12'!altText: aString	"set the text to be displayed while downloading"	altText _ aString.	self setContents! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/9/1998 06:59'!defaultExtent: aPoint	"set the size to use when the image hasn't yet downloaded"	defaultExtent _ aPoint! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:40'!downloadState	"download the image"	| doc |	doc _ url retrieveContents.	downloadQueue nextPut: doc.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:21'!initialize	super initialize.	altText _ '[image]'.	self color: Color transparent.	downloadQueue _ SharedQueue new.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 21:43'!setContents	"set up our morphic contents"	| stringMorph imageMorph outlineMorph extent |	self removeAllMorphs.	image		ifNil: [ 			altText = '' ifTrue: [ self extent: 0@0. "don't display anything..." ^self ].			stringMorph _ StringMorph new.			stringMorph contents: altText.			stringMorph position: self position+(2@2).			self addMorph: stringMorph.			outlineMorph _ RectangleMorph new.			outlineMorph borderWidth: 1.			outlineMorph color: Color transparent.			outlineMorph position: self position.			"figure out how big to make the box"			extent _ defaultExtent ifNil: [ 0 @ 0 ].			stringMorph width + 4 > extent x ifTrue: [				extent _ (stringMorph width + 4) @ extent y ].			stringMorph height + 4 > extent y ifTrue: [				extent _ extent x @ (stringMorph height + 4) ].			outlineMorph extent: extent.			self addMorph: outlineMorph.			self extent: outlineMorph extent ]		ifNotNil: [			imageMorph _ ImageMorph new.			imageMorph image: image.			imageMorph position: self position.			self addMorph: imageMorph.			imageMorph extent ~= self extent ifTrue: [				self extent: imageMorph extent ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:42'!step	| doc |	downloadQueue size > 0 ifTrue: [		doc _ downloadQueue next.		doc mainType = 'image' 		ifTrue: [			image _ ImageReadWriter  formFromStream: doc contentStream binary.			self setContents ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:19'!stepTime	"this check doesn't need to be frequent"	^500! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 17:48'!url: aUrl	"set the url to download"	url _ aUrl asUrl.! !!DualChangeSorter methodsFor: 'all' stamp: 'jm 7/5/1998 12:37'!openAsMorph		| window |	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	window openInWorld.! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!nextPut: aByte	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!nextPutAll: aByteArray	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 7/12/1998 12:51'!position: anOffset	"Pretend to position wherever the caller says!!"! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'jm 6/28/1998 13:57'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: self stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'jm 8/22/1998 10:08'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	self inline: false.	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	(nextWakeupTick ~= 0) ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	((nextWakeupTick ~= 0) and: [self ioLowResMSecs ~= startTime]) ifTrue: [		"primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: [  "process the interrupt now"					self checkForInterrupts]				ifFalse: [  "process the interrupt in primtive failure code"					interruptCheckCounter _ 0]]].	^ successFlag! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'jm 9/22/1998 16:48'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 10:11'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:34'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:37'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients that trigger interrupts should set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0)		ifTrue: [self checkForInterrupts].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 9/23/1998 00:14'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:58'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 9/22/1998 16:58'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!EToySystem class methodsFor: 'development support' stamp: 'di 9/14/1998 10:02'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream _ ReferenceStream fileNamed: 'JanForms'.	newFormDict _ aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Smalltalk imageImports add: assoc]! !!EToySystem class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 16:22'!prepareRelease	"To prepare a release of the EToy system, first make a copy of your image. Start that image and:		1. close all windows and projects		2. clean any garbage out of the following:			Smalltalk at: #ImageImports.			(Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Behavior) not])				asSortedCollection asArray.			SampledSound soundLibrary.		3. run this method		4. save the image"	"EToySystem prepareRelease"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: []. 	Preferences setPreference: #quitWhenExitingImagineeringStudio toValue: true.	Preferences setPreference: #showDevelopersEToys toValue: false.	Preferences setPreference: #startImagineeringStudio toValue: true.	Preferences setPreference: #updateFromServer toValue: false.	Preferences setPreference: #warnIfNoChangesFile toValue: false.	Preferences setPreference: #warnIfNoSourcesFile toValue: false.	Smalltalk minorShrink.	SystemOrganization removeSystemCategory: 'Morphic-Windows'.	SystemOrganization removeSystemCategory: 'Graphics-Files'. "No license for GIF reader"	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Socket deadServer: ''.	"Don't reveal any specific server name"	Symbol rehash.	Preferences desktopColor: (Color r: 0.2 g: 0.2 b: 0.2).	ScheduledControllers updateGray; restore.! !!EToySystem class methodsFor: 'external release' stamp: 'sw 9/15/1998 16:58'!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		serverUrls)		(EToySystem			class		eToyDoItStrings)		(EToySystem			class		loadPurpleWalt)			(EToySystem			class		readCollagePic)			(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!EllipseMorph methodsFor: 'all' stamp: 'di 6/24/1998 14:27'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs _ (seconds * 1000.0) asInteger - 19.	attack _ self attackTime.	decay _ self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime _ endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime _ attack]				ifFalse: [endTime _ endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 11:31'!editSound: aSound	| p |	sound _ aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p _ OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 10:40'!initOnSound: aSound title: title	sound _ aSound.	soundName _ title.	self initialize.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 11:02'!initialize	super initialize.	prevMouseDown _ false.	showAllEnvelopes _ true.	self editSound: (sound ifNil: [FMSound brass1 copy]).	soundName ifNil: [soundName _ 'test'].	sampleDuration _ 250.  sound duration: sampleDuration.	sound duration: sampleDuration / 1000.0.	denominator _ 7.	self extent: 10@10.  "ie the minimum"! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:59'!addControls	| chooser |	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'editing ' , envelope name;		target: self;		actionSelector: #chooseFrom:envelopeItem:;		getItemsSelector: #curveChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topLeft with: graphArea bounds bottomLeft + (0@5).	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'duration: ' , self durationName;		target: self;		actionSelector: #chooseFrom:durationItem:;		getItemsSelector: #durationChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topRight with: graphArea bounds bottomRight + (-50@5).! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:49'!addKeyboard	keyboard _ PianoKeyboardMorph new soundPrototype: sound.	keyboard align: keyboard bounds bottomCenter with: bounds bottomCenter - (0@4).	self addMorph: keyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:56'!buildGraphAreaIn: frame	| r y |	graphArea _ RectangleMorph		newBounds: ((frame left + 40) @ (frame top + 40)		corner: (frame right+1) @ (frame bottom - 60))		color: Color lightGreen lighter lighter.	graphArea borderWidth: 1.	self addMorph: graphArea.	(envelope updateSelector = #pitch: and: [envelope scale <= 2.0]) ifTrue:		["Show half-steps"		r _ graphArea innerBounds.		0.0 to: 1.0 by: 1.0/12.0/envelope scale do:			[:val |			y _ self yFromValue: val.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].	(envelope updateSelector = #ratio: and: [denominator ~= 9999]) ifTrue:		["Show denominator gridding"		r _ graphArea innerBounds.		(0.0 to: 1.0 by: 1.0/denominator/envelope scale) do:			[:v |			y _ self yFromValue: v.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 13:16'!buildView	| frame |	self color: Color lightGreen.	self removeAllMorphs.	frame _ self innerBounds.	self buildGraphAreaIn: frame.	self buildScalesIn: frame.	self addHandlesIn: frame.	self addCurves.	line addHandles.	self addControls.	self addKeyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:57'!durationChoices	^ #(	'125ms'	'250ms'	'500ms'	'1000ms'	'2000ms'	'other'	'held'	)! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:29'!durationName	self durationChoices do:		[:c | c asNumber = sampleDuration ifTrue: [^ c]].	sampleDuration = 9999 ifTrue: [^ 'held'].	^ sampleDuration printString! !!EnvelopeEditorMorph methodsFor: 'scaling' stamp: 'di 9/4/1998 16:03'!extent: newExtent	super extent: (newExtent max: (self maxTime//10*3+50 max: 355) @ 284).	self buildView! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:45'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	envelope updateSelector = #ratio: ifTrue:		[menu add: 'choose denominator...' action: #chooseDenominator:].	menu add: 'adjust scale...' action: #adjustScale:.	SoundPlayer isReverbOn		ifTrue: [menu add: 'turn reverb off' target: SoundPlayer selector: #stopReverb]		ifFalse: [menu add: 'turn reverb on' target: SoundPlayer selector: #startReverb].	menu addLine.	menu add: 'get sound from lib' action: #chooseSound:.	menu add: 'put sound in lib' action: #saveSound:.	menu add: 'read sound from disk...' action: #readFromDisk:.	menu add: 'save sound on disk...' action: #saveToDisk:.	menu add: 'save library on disk...' action: #saveLibToDisk:.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:49'!chooseFrom: chooserMorph durationItem: item	| str |	item asNumber ~= 0 ifTrue: [sampleDuration _ item asNumber].	item = 'other' ifTrue:		[str _ FillInTheBlank request: 'duration in milliseconds'						initialAnswer: sampleDuration printString.		sampleDuration _ str asNumber].	item = 'held' ifTrue: [sampleDuration _ 9999].	sound duration: sampleDuration / 1000.0.	chooserMorph contentsClipped: 'duration: ' , self durationName! !!EnvelopeEditorMorph methodsFor: 'stepping' stamp: 'di 9/5/1998 10:56'!step	| mouseDown hand |	hand _ self world hands first.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown _ hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown _ mouseDown! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'di 9/15/1998 16:35'!handlesMouseOverDragging: evt	mouseEnterDraggingRecipient ifNotNil: [^ true].	mouseLeaveDraggingRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseEnterDragging: event fromMorph: sourceMorph	^ self send: mouseEnterDraggingSelector to: mouseEnterDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseLeaveDragging: event fromMorph: sourceMorph	^ self send: mouseLeaveDraggingSelector to: mouseLeaveDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].	mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterDraggingRecipient ifNotNil:		[list add: (mouseEnterDraggingRecipient class classThatUnderstands:					mouseEnterDraggingSelector) name , ' ', mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient ifNotNil:		[list add: (mouseLeaveDraggingRecipient class classThatUnderstands:					mouseLeaveDraggingSelector) name , ' ', mouseLeaveDraggingSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseDownSelector	^ mouseDownSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseUpSelector	^ mouseUpSelector! !!EventHandler methodsFor: 'access' stamp: 'sw 9/21/1998 12:07'!printOn: aStream	| aVal |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]]! !!EventHandler methodsFor: 'object fileIn' stamp: 'di 9/15/1998 16:35'!convertmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkv0: smartRefStrm	"These variables are automatically stored into the new instance ('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' ) and deal with the information in ()"! !!EventRecorder methodsFor: 'as yet unclassified' stamp: 'jm 5/29/1998 14:21'!testControl: anEvent	"See if it is a control event for me.  Control 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"	anEvent isKeystroke ifFalse: [^ self].	anEvent controlKeyPressed ifFalse: [^ self].	anEvent commandKeyPressed ifTrue: [^ self].	"not this"	anEvent macOptionKeyPressed ifTrue: [^ self].	"not this"	anEvent shiftPressed ifTrue: [^ self].	"not this"	anEvent keyCharacter = $1 ifTrue: ["start recording"		tape ifNil: [tape _ OrderedCollection new].		state _ #record].	anEvent keyCharacter = $2 ifTrue: ["stop recording (or playing back)"		state _ nil].	anEvent keyCharacter = $3 ifTrue: ["start playing back"		state _ #play.		tape ifNotNil: [			tape do: [:evt | 				anEvent hand world runStepMethods.				anEvent hand handleEvent: evt.				anEvent hand world displayWorld]].		state _ nil].! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'jm 8/16/1998 17:36'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize _ 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44'!initialize	super initialize.	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples _ SoundBuffer fromArray: anArray]		ifFalse: [samples _ anArray].	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ samples.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:28'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound new modulation: 0 multiplier: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:06'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound new modulation: 0 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:05'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute2	"FMSound flute2 play"	"(FMSound majorScaleOn: FMSound flute2) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe2	"FMSound oboe2 play"	"(FMSound majorScaleOn: FMSound oboe2) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:01'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 125@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:03'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:05'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/13/1998 09:54'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."        | resp what all |        readAhead size > 0                ifTrue: [resp _ readAhead removeFirst]  "response already came in"                ifFalse: [                        all _ self getResponseUpTo: CrLf.                        resp _ all at: 1.       "150 Opening binary mode data conn"                        readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].        Transcript show: resp; cr.        resp size > 0                 ifTrue: [                        resp first isDigit ifFalse: [ ^self lookFor: beginning ].  "we're in the middle of a line, not the end." #XXX. "this should be fixed..."                        (resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"                        (resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"                        "((resp at: 1) isDigit) & ((resp at: 1) digitValue < 4) ifTrue: [^ self lookFor: beginning]."                                "the way I used to detect comments"                        ]                ifFalse: [resp _ '[timeout]'].        what _ (PopUpMenu labels: 'OK\ debug ' withCRs)                 startUpWithCaption: 'Server reported this error:\' withCRs, resp.        what = 2 ifTrue: [self halt].        self destroy.        ^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 4/26/1998 09:33'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Return true if OK, the error string if not."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	resp size > 0 		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FileDirectory methodsFor: 'enumeration' stamp: 'wod 6/16/1998 15:07'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"wod 6/16/1998: add Cursor wait, and use 'self pathNameDelimiter asString' rather than hardwired ':' "	"FileDirectory default statsForDirectoryTree: '\smalltalk'"	| dirs files bytes todo p entries |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			entries _ self directoryContentsFor: p.			entries do: [:entry |				(entry at: 4)					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, (entry at: 1)).						dirs _ dirs + 1]					ifFalse: [						files _ files + 1.						bytes _ bytes + (entry at: 5)]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:44'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [^ OrderedCollection new].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:43'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:54'!entryAt: fileName  	"find the entry with local name fileName"	^self entryAt: fileName ifAbsent: [ self error: 'file not indirectory: ', fileName ].! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:53'!entryAt: fileName  ifAbsent: aBlock	"find the entry with local namefileName"	^self entries 		detect: [ :entry | (entry at: 1) =fileName ] 		ifNone: [ aBlock value ]! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:32'!changeSuffix"if 'changes' is not suitable, override this message to return something that is ok"	^'changes'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:31'!imageSuffix"if 'image' is not suitable, override this message to return something that is ok"	^'image'! !!FileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:49'!pathNameDelimiter"return the active directory class's directory seperator character"	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList methodsFor: 'initialization' stamp: 'di 5/25/1998 10:26'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:05'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '"Please fill in the following info, then select all text and choose DoIt."| aa | aa _ ServerDirectory new.aa server: ''st.cs.uiuc.edu''.    "host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.    "<- this is optional.  Only used when *writing* update files."ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/15/1998 22:18'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles sortBlock |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x size = y size 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:08'!removeServer	| choice names |	names _ ServerDirectory serverNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 16:49'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim _ directory pathNameDelimiter.				path _ String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:07'!volumeMenu: aMenu	^ aMenu		labels:'add server...remove server...'		lines: # ()		selections: #(askServerInfo removeServer)! !!FileList methodsFor: 'file list' stamp: 'di 5/26/1998 20:22'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - self folderString size.					listIndex _ 0.					brevityState _ #FileList.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'file list menu' stamp: 'ls 7/15/1998 20:59'!addNewDirectory	"Add a new directory and update the list"	| newName index ending |	self okToChange ifFalse: [^ self].	newName _ (FillInTheBlank request: 'New Directory Name?' 					initialAnswer: 'DirectoryName') asFileName.	Cursor wait showWhile: [		(directory createDirectory: newName)].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/16/1998 12:22'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: 'Really delete ' , fileName , '?') ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/24/1998 16:21'!fileAllIn	"File in all of the currently selected file, if any."	"wod 5/24/1998: open the file read only."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:06'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:02'!importImage	"Import the given image file and store the resulting Form in the global dictionary	ImageImports, at a key consisting of the short filename up to the first period.  "	| key image |	key _ fileName sansPeriodSuffix.	image _ Form fromFileNamed: self fullName.	Smalltalk imageImports at: key put: image.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 15:30'!itemsForAnyFile	^ #(('copy name to clipboard' 'rename' 'delete')		()		(copyName renameFile deleteFile)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 07:44'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges putUpdate)].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:33'!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'add new file' 'add new directory')		(3)		(sortByName sortBySize sortByDate		addNewFile addNewDirectory)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:34'!noFileSelectedMenu: aMenu	| items |	items _ self itemsForNoFile.	^ aMenu		labels: items first		lines: items second		selections: items third! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:05'!offerAllFileOptions	| items action |	items _ self itemsForFileEnding: '*'.	action _ (SelectionMenu labels: items first lines: items second selections: items third)			startUp.	action ifNotNil: [self perform: action]! !!FileList methodsFor: 'file list menu' stamp: 'di 8/17/1998 17:31'!openAsMovie	"Open a MoviePlayerMorph on the given file (must be in .movie format)." 	Smalltalk at: #Morph ifAbsent: [^ self beep].	(MoviePlayerMorph new openFileNamed: self fullName) openInWorld! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:03'!openImageInWindow	"Handle four file formats: GIF, JPG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image |	image _ Form fromFileNamed: self fullName.	World		ifNil: [FormView open: image named: fileName]		ifNotNil: [World addMorph: (SketchMorph new form: image)].! !!FileList methodsFor: 'file list menu' stamp: 'sw 9/21/1998 10:59'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	World		ifNotNil:			[World addMorphsAndModel: morphOrList]		ifNil:			[(morphOrList isKindOf: Morph)				ifFalse:					[^ self inform: 'can only load a single morph into an mvc project via this mechanism'].				morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/29/1998 17:09'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory oldFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FileList methodsFor: 'file list menu' stamp: 'di 5/24/1998 14:09'!putUpdate	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdate: 				(directory oldFileNamed: self fullName).! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/3/1998 17:24'!renderFile	"Render the currently selected file"	| map action file renderedFile formatPage |	listIndex = 0 ifTrue: [^ self].	map _ URLmap new.	action _ RenderedSwikiAction new.	action name: '.'.  "For image references, refer to this directory"	map action: action.	map directory: directory.	(directory fileExists: 'glossary')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'glossary') close].].	map readGlossary: (directory oldFileNamed: 'glossary').	formatPage _ SwikiPage new.	formatPage map: map.	formatPage coreID: (fileName allButFirst).	formatPage formatted: (HTMLformatter		evalEmbedded: (directory oldFileNamed: fileName)contentsOfEntireFile		with: formatPage		unlessContains: (Set new)).	formatPage name isNil		ifTrue: [self notify: 'You forgot to name the page!!<?request name: ''myname''?>'.				formatPage name: 'defaultName'.].	map pages at: (formatPage name asLowercase) put: formatPage.	formatPage formatted: (LessHTMLformatter swikify: (formatPageformatted)			linkhandler: [:link | map					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	"Make a template if one does not exist"	(directory fileExists: 'template.html')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'template.html') nextPutAll: (selftemplateFile); close].].	renderedFile _ (directory pathName),(ServerActionpathSeparator),(formatPage coreID).	(directory fileExists: renderedFile)		ifTrue: [directory deleteFileNamed: renderedFile].	file _ FileStream fileNamed: renderedFile.	file nextPutAll: (HTMLformatter evalEmbedded:		(directory oldFileNamed: 'template.html') contentsOfEntireFile			with: formatPage).	file close.	FileDirectory default setMacFileNamed: renderedFile		type: 'TEXT'		creator: 'MOSS'.	map writeGlossary. "Directory is already in the map, so write tothe glossary there"	self updateFileList.! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/1/1998 14:10'!templateFile	^'<head><title><?request name?></title></head><body><?request formatted?></body>'! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:26'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:25'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED'; cr.					s nextPutAll: '  -- Folder Summary --'; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findFirst: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:46'!put: aText	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[PopUpMenu notify: 'No fileName is selected'.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	PopUpMenu notify: type , ' contents cannotmeaningfully be saved at present.'.	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:22'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:20'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	((size _ f size)) > 5000 & brevity		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	^ contents _ ((size > 5000) & brevity		ifTrue: ['File ''', fileName, ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', hexData , '------------------------------------------... end of the first 5000 characters.']		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'ls 9/11/1998 04:15'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents]! !!FileList methodsFor: 'private' stamp: 'wod 5/27/1998 17:47'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	"wod 5/27/1998: nil out the fileName."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [self listForPattern: pattern]			ifFalse: [				pattern isEmpty					ifTrue: [self listForPattern: '*']					ifFalse: [self listForPattern: '*', pattern, '*']].		listIndex _ 0.		volListIndex _ volList size.		fileName _ nil.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:23'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView |	World ifNotNil: [^ self openAsMorph].	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/28/1998 10:37'!openAsMorph     "FileList openAsMorph openInMVC"	"Open a morphic view of a FileList on the default directory."	| dir aFileList window |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:22'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	window openInWorld! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:00'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!FileStream methodsFor: 'fileIn/Out' stamp: 'jm 8/19/1998 16:59'!fileInObjectAndCode	"Optimization: If the file is small, read the entire file into memory before processing."	| s |	self text.	((self size < 1000000) and: [Smalltalk garbageCollectMost > 3000000])		ifTrue: [			s _ RWBinaryOrTextStream with: (self contentsOfEntireFile).			s position: 0.			^ s fileInObjectAndCode]		ifFalse: [^ super fileInObjectAndCode].! !!FileStream class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 05:19'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: fName! !!FileStream class methodsFor: 'concrete classes' stamp: 'ls 7/11/1998 02:58'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream  "may change this to CrLfFileStream"! !A reference to a local file.  The url itself uses the UNIX notation of %20 for space.  path has the tokens translated to ascii, except if we have a UNIX file system. path is OC of path parts.  If last is empty string, then referring to a directory.!!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 13:05'!privateInitializeFromText: text	| bare schemeName pathString |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	path _ pathString findTokens: '/'.	path _ path collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ path addLast: '' ].	isAbsolute _ pathString beginsWith: '/'.! !!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 16:40'!privateInitializeFromText: aString relativeTo: aUrl	| bare |	bare _ aString.	(bare beginsWith: (self schemeName, ':')) ifTrue: [		bare _ bare copyFrom: (self schemeName size + 2) to: bare size ].	(bare beginsWith: '/') ifTrue: [ ^self privateInitializeFromText: aString ].	isAbsolute _ aUrl isAbsolute.	path _ aUrl path copy.	path removeLast.	"empty string that says its a directory"	(bare findTokens: '/') do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			path addLast: token unescapePercents ].		token = '..' ifTrue: [ 			path isEmpty ifFalse: [ 				path last = '..' ifFalse: [ path removeLast ] ] ].		"token = '.' do nothing" ].	(bare endsWith: '/') ifTrue: [ path add: '' ].! !!FileUrl methodsFor: 'printing' stamp: 'tk 9/6/1998 13:08'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment encodeForHTTP ].	^s contents! !!FileUrl methodsFor: 'access' stamp: 'ls 8/2/1998 05:39'!isAbsolute	^isAbsolute! !!FileUrl methodsFor: 'access' stamp: 'ls 7/23/1998 07:29'!path	"return an ordered collection of the path elements"	^path! !!FileUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:57'!path: anArray	path _ anArray! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 00:35'!pathForFile	"Path using local file system's delimiter.  $\ or $:"	| first |	^String streamContents: [ :s |		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: p ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 13:03'!pathString	"Path as it appears in a URL with $/ as delimiter"	| first |	^String streamContents: [ :s |		isAbsolute ifTrue:[ s nextPut: $/ ].		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first _ false.			s nextPutAll: p encodeForHTTP ] ]! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/6/1998 00:36'!default	"Use the default local Squeak file directory"	| local |	local _ FileUrl new path: (FileDirectory default pathParts), #('')		isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!FileUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/5/1998 20:42'!retrieveContents	| file pathString s dir |		pathString _ self pathForFile.	path last size > 0 ifTrue: [		file _ FileStream oldFileOrNoneNamed: pathString.		file ifNotNil: [ 			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: file contentsOfEntireFile ] ].	"assume it's a directory..."	s _ WriteStream on: String new.	dir _ FileDirectory on: pathString.	(pathString endsWith: '/') ifFalse: [ pathString _ pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	dir entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file:', pathString)! !!FileUrl methodsFor: 'private-initialization' stamp: 'ls 7/26/1998 20:43'!path: aCollection isAbsolute: aBoolean	path _ aCollection.	isAbsolute _ aBoolean! !!FileUrl methodsFor: 'classification' stamp: 'ls 7/26/1998 21:11'!schemeName	^'file'! !!FileUrl class methodsFor: 'parsing' stamp: 'tk 9/6/1998 22:48'!absoluteFromText: text	"(how does this method fit with FileUrl|privateInitializeFromText:?)"	| schemeName pathString bare thePath |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	thePath _ (pathString findTokens: '/') collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ thePath add: '' ].	^self new path: thePath isAbsolute: (pathString beginsWith: '/')! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:01'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: queryString"	^ self request: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView savedArea |	World ifNotNil:		[^ FillInTheBlankMorph			request: queryString			initialAnswer: defaultAnswer			centerAt: aPoint].	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		(Smalltalk at: #FillInTheBlankView)			on: model			message: queryString			centerAt: aPoint.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'di 9/12/1998 09:26'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane retractableOrNot.	textPane acceptOnCR: true.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Float methodsFor: 'copying' stamp: 'tk 8/19/1998 16:08'!veryDeepCopyWith: deepCopier	"Return self.  Do not record me."	^ self clone! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."	^ self! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:48'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:49'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!anyShapeFill	"Fill the interior of the outtermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape: to paint a solid color.  See also convexShapeFill:"	| shape |	shape _ (self findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'di 6/11/1998 21:38'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'scaling, rotation' stamp: 'di 8/17/1998 22:17'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: self boundingBox by: scale			smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:04'!peripheralColor  "Form fromUser peripheralColor"	"Return the dominant color as sampled at four corners"	^ (self boundingBox innerCorners collect:		[:p | self colorAt: p]) asBag sortedCounts first value! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!primCountBits	"Count the non-zero pixels of this form."	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this form into the valueTable, which is	a bitmap similar to a color map.  Since the underlying BitBlt function	that performs the tally does not do bit-boundary clipping, the	tallies for any word-boundary fringes must be subtracted."	self tallyPixelValuesPrimitive: destRect into: valueTable.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:37'!tallyPixelValuesPrimitive: destRect into: valueTable	"Tally the selected pixels of this form into valueTable, a Bitmap similar to a color map, and return valueTable. Since the BitBlt function that performs the tally does not do bit-boundary clipping, the tallies for any word-boundary fringes must be subtracted by the sender."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		colorMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 01:00'!trimToPixelValue: pv orNot: not	"Return the smallest part of me that includes all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	^ self copy: (self innerPixelRectFor: pv orNot: not)"Try this to select all but the background...Form fromUser in: [:f |(f trimToPixelValue: (f peripheralColor pixelValueForDepth: f depth) orNot: true) display]Or this to select whatever is black...Form fromUser in: [:f |(f trimToPixelValue: (Color black pixelValueForDepth: f depth) orNot: false) display]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits _ ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:30'!writeUncompressedOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!Form methodsFor: 'as yet unclassified' stamp: 'di 7/8/1998 12:18'!baldMountainWorkspace"   -- Reset player, do this, then play -- 	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 2 do:		[:i | file position: i-1*153613+1.		ff readFrom: file.		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		Sensor yellowButtonPressed ifTrue: [^ file close]].	file close] -- Async version -- |  file ff byteCount nFrames bytesRead di |	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	byteCount _ ff bits size * 4.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: 1+13 count: byteCount.	1 to: nFrames by: (di_1) do:		[:i |		file waitForCompletion.		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		Sensor anyButtonPressed ifTrue: [^ file close].		(i+di) <= nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: (i-1+di)*(byteCount+13)+1+13 count: byteCount].		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		].	file close.	waitTime	| ps zps f32 f16 |	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		f32 _ Form fromFile: (FileStream oldFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps bmps:Bald' , zps , '.BMP').		f32 displayAt: 0@0.		f16 _ Form extent: f32 extent depth: 16.		f32 displayOn: f16 at: 0@0.		f16 displayAt: 330@0.		Transcript cr; show: i printString.		f16 writeUncompressedOnFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form'.		Sensor anyButtonPressed ifTrue: [^ nil]]	| ps zps  file |	file _ FileStream newFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fpsAll338.forms'.	file binary.	file nextPut: 2.	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form') display; writeUncompressedOn: file.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close	-- convert .forms file to .movie format --	|  out ps zps ff |	out _ FileStream newFileNamed: 'Bald2minAt10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 338) , (6 to: 32)		do: [:i | out nextInt32Put: i].			1 to: 1203 by: 1 do:		[:i | i printString displayAt: 400@0.		ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'BackStreet HD:Bald Mt Disk:Bald2 10fps Proc:Bald10.' , zps) 			displayOn: ff.		ff display; writeOnMovie: out].	out close.	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 1 do:		[:i | ff  readFrom: file.		ff display.		Sensor anyButtonPressed ifTrue: [^ file close]].	file close]	|  file ff byteCount nFrames filePosition bytesRead waitTime t |Array with: (Time millisecondsToRun: [	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	waitTime _ 0.	byteCount _ ff bits size * 4.	filePosition _ 1.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount.	1 to: nFrames by: 1 do:		[:i |		t _ Time millisecondClockValue.		file waitForCompletion.		waitTime _ waitTime + (Time millisecondClockValue - t).		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		filePosition _ filePosition+13 + bytesRead.		Sensor anyButtonPressed ifTrue: [^ file close].		i < nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount].		ff display].	file close])	with: waitTime (18400 9798 ) | ff | ff _ Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald00338.form'. Time millisecondsToRun: [1 to: 100 do: [:i | ff display]] 100000//1359 73Try out on-the-fly pixel doubling [dummied for timing]... | file f1 f2 f2a pixMap bb1 bb2 |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	f1 _ Form extent: 320@240 depth: 16.	f2 _ Form extent: 640@480 depth: 16.	f2a _ Form extent: 320@480 depth: 32.	f2a bits: f2 bits.	pixMap _ Bitmap new: 32768.	1 to: 32768 do: [:i | pixMap at: i put: (i bitOr: (i bitShift: 16))].	bb1 _ BitBlt destForm: f2a sourceForm: f1 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 320@1 clipRect: f2a boundingBox.	bb1 colorMap: pixMap.	bb2 _ BitBlt destForm: f2 sourceForm: f2 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 640@1 clipRect: f2 boundingBox.	1 to: 338 by: 1 do:		[:i | f1  readFrom: file.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		0 to: 239 do:			[:j |			bb1 sourceY: j; destY: j*2; copyBits.			bb2 sourceY: j*2; destY: j*2+1; copyBits].		f2 display.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close] 104512 53247 39812 338000.0/ 53247 6.34777546152835 6 6"! !!Form class methodsFor: 'instance creation' stamp: 'di 9/15/1998 09:47'!fromFileNamed: fileName	"Read a Form or ColorForm from given file in any of four formats."	| file fileCode |	file _ (FileStream readOnlyFileNamed: fileName) binary.	fileCode _ file next.	fileCode = 1 ifTrue:		["Old Squeakform format"		^ self new readFromOldFormat: file].	fileCode = 2 ifTrue:		["New Squeak form format"		^ self new readFrom: file].	fileCode = $B asciiValue ifTrue:		[file skip: - 1.		^ self fromBMPFile: file].	file close.	"Try for JPG, GIF, or PCX..."	^ Smalltalk imageReaderClass formFromFileNamed: fileName! !!FormCanvas methodsFor: 'drawing' stamp: 'di 6/26/1998 15:09'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: 0@0.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:41'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [			fillC == nil ifTrue: [^ self].  "both border and fill are transparent"			borderC _ nil.			rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor].	port combinationRule:		(self drawRule: Form over color: c borderColor: borderColor).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:33'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 15:41'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rule |	rule _ self drawRule: Form over color: fillColor borderColor: borderColor.	port combinationRule: rule.	borderColor isTransparent ifFalse: [		"draw border of rectangle"		(r area > 10000 or: [fillColor isTransparent or: [rule = Form blend]]) ifTrue: [			port frameRect: (r translateBy: origin)				borderWidth: borderWidth				borderColor: (self drawColor: borderColor).		] ifFalse: [			"for small rectangles, it's faster to fill the entire outer rectangle than to compute and fill the border rects"			port fillRect: r color: (self drawColor: borderColor) offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse: [		port 	fillRect: (r insetBy: borderWidth)				color: (self drawColor: fillColor)				offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/3/1998 14:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		port fillColor: (self drawColor: bottomRightColor);			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint color: Color black);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over color: c);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c)		background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:27'!drawRule: defaultRule color: color	"Answer the BitBlt combination rule for the given default rule and color. If this canvas is in shadow-drawing mode, answer 'paint'. If the color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color isColor and: [color alpha < 1.0])		ifTrue: [^ Form blend]		ifFalse: [^ defaultRule].! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:32'!drawRule: defaultRule color: color1 borderColor: color2	"Answer the BitBlt combination rule for the given default rule and colors. If this canvas is in shadow-drawing mode, answer 'paint'. If either color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color1 isColor and: [color1 alpha < 1.0]) ifTrue: [^ Form blend].	(color2 isColor and: [color2 alpha < 1.0]) ifTrue: [^ Form blend].	^ defaultRule! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:40'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:41'!stipple: newStipple	shadowStipple _ newStipple.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:46'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:11'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: Color white.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:14'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: Color white.	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: Color red.	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.	canvas point: 100@100 color: Color black.	canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.	canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.	canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.	canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.	canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.	canvas showAt: 0@0.! !!FormEditor class methodsFor: 'private' stamp: 'di 9/12/1998 12:28'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder _ 2.	formView _ FormHolderView new model: aForm.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView _ View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView _ StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !an input instance for a form.  A form takes its input from a collection of FormInputs; each FormInput has a name and can retrieve a textual value.  WHen a form is submitted, these name-value associations are gathered together and passed to an HTTP server.!!FormInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^false! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:11'!active	"whether this input is currently providing an input"	^true! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!name	"name associated with this input"	^self subclassResponsibility! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!reset	"reset to a default value"	! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!value	"value associated with this input"	^self subclassResponsibility! !Holds the inputs for an instance of an HTML Form.  It has a link to the browser it will be displayed in, and it has a link to each of the input PluggableTextMorph's that it input will read from.inputs - maps HtmlInput's into the text morphs which will input their value.!!FormInputSet methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 03:57'!form: f  browser: b	inputs _ OrderedCollection new.	form _ f.	browser _ b.! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/5/1998 03:57'!addInput: anInput	inputs add: anInput! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/11/1998 03:30'!inputs	"return a list of the list of inputs"	^inputs! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/5/1998 03:58'!reset	"reset all inputs to their default value"	inputs do: [ :input | input reset ]! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/11/1998 20:11'!submit	"collect inputs and instruct the browser to do a submission"	| inputValues |	inputValues _ Dictionary new.	inputs do: [ :input |		input active ifTrue: [			(inputValues includesKey: input name) ifFalse: [				inputValues at: input name  put: (OrderedCollection new: 1) ].			(inputValues at: input name)  add: input value ] ].	browser submitFormWithInputs: inputValues  url: form url method: form method.	^true! !!FormInputSet class methodsFor: 'instance creation' stamp: 'ls 7/16/1998 22:01'!forForm: form  andBrowser: browser	"create a FormData for the given form and browser"	^super new form: form  browser: browser! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale _ self insetDisplayBox extent / model selection extent.	scale _ (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:57'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:56'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormView class methodsFor: 'examples' stamp: 'di 9/12/1998 10:17'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !a reference to a file which may be downloaded by anonymous ftp!!FtpUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 01:24'!retrieveContents	| server contents pathString listing |	"currently assumes directories end in /, and things that don't end in / are files.  Also, doesn't handle errors real well...."	server _ ServerDirectory new.	server server: self authority.	server directory: '/'.	server user: 'anonymous'.	server password: 'SqueakUser'.	pathString _ self pathString.	pathString _ pathString copyFrom: 2 to: pathString size. "remove the leading /"	self path last size = 0 ifFalse: [		"a file"		contents _ (server getFileNamed: pathString).		(contents respondsTo: #contents) ifTrue: [ 			"the file exists--return it"			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents contents ]		ifFalse: [			"some error"			^nil ]. ].	"a directory?"	server directory: self pathString.	listing _ String streamContents: [ :stream |		stream nextPutAll: '<title>', self pathString, '</title>'; cr.		stream nextPutAll: '<h1>Listing for ', self pathString, '</h1>'; cr.		stream nextPutAll: '<ul>'; cr.		server entries do: [ :entry |			stream nextPutAll: '<li>';				nextPutAll: '<a href="', entry name encodeForHTTP.			entry isDirectory ifTrue: [ stream nextPut: $/ ].			stream nextPutAll: '">';				nextPutAll: entry name;				nextPutAll: '</a>';				cr ] ].	^MIMEDocument contentType: 'text/html' content: listing! !!FtpUrl methodsFor: 'access' stamp: 'ls 7/24/1998 00:18'!pathString	self path isEmpty ifTrue: [ ^'/' copy ].	^String streamContents: [ :s |		self path do: [ :p |		 	s nextPut: $/.			s nextPutAll: p ] ]! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !a URL type that can't be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.!!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ self error: 'opaque URL with no scheme--shouldn''t happen!!'. ].	locator _ aString copyFrom: (schemeName size+2) to: aString size.! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString relativeTo: aUrl	schemeName _ aUrl schemeName.	locator _ aString.! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!locator	^locator! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!schemeName	^schemeName! !!GenericUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName0  locator: locator0	schemeName _ schemeName0.	locator _ locator0.! !!GenericUrl methodsFor: 'printing' stamp: 'ls 8/4/1998 02:41'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self locator.	self fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: self fragment ].	^s contents! !!GenericUrl class methodsFor: 'parsing' stamp: 'ls 7/26/1998 21:24'!absoluteFromText: aString	| schemeName locator |	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].	locator _ aString copyFrom: (schemeName size + 2) to: aString size.	^self schemeName: schemeName locator: locator! !!GenericUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName  locator: locator	^self new schemeName: schemeName  locator: locator! !!GradientFillMorph methodsFor: 'drawing' stamp: 'jm 6/1/1998 19:24'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorArrayForDepth: aCanvas depth.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 6/2/1998 15:57'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 alpha < 1.0]) ifTrue: [^ true].	^ false! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:55'!fillColor: aColorOrPattern	aColorOrPattern == lastColor ifTrue: [^ self].	super fillColor: aColorOrPattern.	lastColor _ aColorOrPattern.! !!GrafPort methodsFor: 'all' stamp: 'sw 8/5/1998 12:10'!fillRect: rect color: fillColor offset: aPoint	fillColor class == InfiniteForm ifTrue: 		[self fillColor: nil.		fillColor displayOnPort: ((self clippedBy: (rect translateBy: aPoint)) colorMap: nil) at: aPoint.		^ self].	sourceForm _ nil.	self fillColor: fillColor.	destX _ rect left + aPoint x.	destY _ rect top + aPoint y.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:36'!frameRectBottom: rect height: h	sourceForm _ nil.	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:35'!frameRectRight: rect width: w	sourceForm _ nil.	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!GraphMorph methodsFor: 'initialization' stamp: 'jm 7/8/1998 20:31'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'private' stamp: 'jm 7/8/1998 20:32'!drawPointerOn: aCanvas	| ptr x r c |	ptr _ (cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!HTMLformatter methodsFor: 'formatting' stamp: 'ls 4/18/98 16:46'!format: requestObject	"format text with requestObject as the argument forthe code blocks"	^String streamContents: [ :stream |	formattingBlock value: requestObject value: stream ]! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'ls 4/18/98 13:23'!formattingBlock: aBlock	formattingBlock _ aBlock! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'mjg 8/28/199820:56'!initialize	specialCharacter = $*.! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/28/1998 21:03'!rangesOfAngleBrackets: sourceStrm	"Return an OrderedCollection of intervals of position within anglebrackets < and >.  Caller wants to avoid putting <br> in there."	| list char intervals start |	list _ OrderedCollection new: 10.	[sourceStrm atEnd] whileFalse: [		(char _ sourceStrm next) == $< ifTrue: [list add:sourceStrm position].	"a start"		char == $> ifTrue: [list add: sourceStrm positionnegated]].	"an end"	sourceStrm reset.	intervals _ OrderedCollection new: 10.	start _ nil.	list do: [:each |		(each > 0) & (start == nil) ifTrue: [start _ each].		(each < 0) & (start ~~ nil) ifTrue: [			intervals add: (start to: each negated). start _ nil]].	^ intervals"	HTMLformatter rangesOfAngleBrackets: (ReadStream on: '1234 <good><456 <good> 567> <ok>')	"! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/31/1998 12:48'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:00'!specialCharacter	^specialCharacter! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:01'!specialCharacter: someCharacter	specialCharacter _ someCharacter! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:23'!evalEmbedded: stringOrStream with: request	| formatter |	formatter _self forEvaluatingEmbedded: stringOrStream.	^formatter format: request! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 6/3/98 10:29'!fixForIE: text	| ch targetStream sourceStream |	targetStream := WriteStream on: String new.	sourceStream := ReadStream on: text.	[sourceStream atEnd] whileFalse:	[ch := sourceStream next.	ch = $> ifTrue: [targetStream nextPutAll: '&gt;']	ifFalse: [ch = $< ifTrue: [targetStream nextPutAll: '&lt;']		ifFalse: [targetStream nextPut: ch]].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 7/15/1998 12:02'!forEvaluatingEmbedded: stringOrStream	"stringOrStream is text with <?expr?> expressions intermingled.This creates a HTLMLformatter instance which will substitute the <?expr?>expressions with the value of the argument (named request), and whichleaves all other text in stringOrStream alone"	| blockStream sourceStream doingEval ch |	blockStream _ WriteStream on: String new. 	blockStream nextPutAll: '[ :request :output | output nextPutAll: '''.	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	doingEval _ false.	[sourceStream atEnd] whileFalse:  [		ch := sourceStream next.		(doingEval not and: [ ch = $<  and: [ sourceStream peek =$? ]]) ifTrue: [			"beginning of an <?...?> expression"			blockStream nextPutAll: '''.  output nextPutAll: ['.			sourceStream next.  "Skip the ?"			doingEval _ true]		ifFalse: [		(doingEval and: [ ch = $? and: [ sourceStream peek = $> ]])ifTrue: [			"end of a <?...?> expression"			blockStream nextPutAll: '] value asString.  outputnextPutAll: '''.			sourceStream next.  "Skip the >"			doingEval _ false.]		ifFalse: [			"normal char"			blockStream nextPut: ch.			(doingEval not and: [ ch = $' ]) ifTrue: [				 "double $' marks"  blockStream nextPut: $'] ] ] ].	"end the block"	doingEval		ifTrue: [ blockStream nextPutAll: '] value asString' ]		ifFalse: [ blockStream nextPutAll: '''' ].	blockStream nextPutAll: ']'.	^HTMLformatter new formattingBlock: (Compiler evaluate: blockStreamcontents)! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:38'!oldEvalEmbedded: stringOrStream with: request	| sourceStream targetStreamevalStream currentStream evalValue peekValue ch |	(stringOrStreamisKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	targetStream := WriteStream on: String new.	currentStream :=targetStream. 	[sourceStream atEnd] whileFalse: 		[ch :=sourceStream next.		ch = $< ifTrue:			[peekValue := sourceStream peek. (peekValue = $?) ifTrue:		[evalStream := WriteStream on: String new.		currentStream := evalStream.	sourceStream next. "Eat the ?"				ch :=sourceStream next.]].		((currentStream = evalStream) and: [ch =$?]) ifTrue:			[ peekValue := sourceStream peek.(peekValue = $>) ifTrue:				[sourceStream next."Eat the >"				currentStream := targetStream.			evalValue := (Compiler new evaluate: (evalStreamcontents) 					in: thisContext to: selfnotifying: nil ifFail: [^nil]).				(evalValueisKindOf: String)				ifFalse: [evalValue :=evalValue printString].				currentStreamnextPutAll: evalValue.]]			ifFalse: [currentStreamnextPut: ch].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 9/3/1998 16:58'!swikify: aStringOrStream linkhandler: aBlock	| formatter |	formatter _ self new.	formatter specialCharacter: $*.	^formatter swikify: aStringOrStream linkhandler: aBlock! !!HTMLformatter class methodsFor: 'formatting' stamp: 'pm 6/6/1998 21:39'!textAreaStart: fieldName rows: rows cols: cols       ^ '<TEXTAREA NAME="', fieldName, '" ROWS=',rows,' COLS=',cols,'>' ! !HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'all' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type _ self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type _ type withBlanksTrimmed.	i _ type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 11:39'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 12:24'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response _ RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf _ String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifTrue: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 14:35'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response size). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail _ aRequest! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:30'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxy _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/4/97 16:11'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder _ doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 5/6/1998 16:40'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 9/15/1998 23:57'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGet: url  args: nil accept: mimeType! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/16/1998 10:31'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:25'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url args: nil accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 17:48'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	^ self httpGetDocument: url args: args accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 19:01'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, self argString: args ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc _ self httpGet: url.	doc binary; reset.	(ggg _ Smalltalk jpegReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^ self httpPostDocument: url args: argsDict accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:00'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc _ (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc _ 'The server does not seem to be responding']."	doc class == String ifTrue: [text _ doc] ifFalse: [text _ doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 9/15/1998 08:22'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens image |	nameTokens _ url findTokens: '/'.	image _ self httpGif: url.	World ifNil: [FormView open: image named: nameTokens last]		ifNotNil: [World addMorph: (SketchMorph new form: image)]! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpShowJpeg: url	"Display the picture retrieved from the given URL, which is assumed to be a JPEG file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpJpeg: url) named: nameTokens last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:18'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:17'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxy _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 9/22/1998 17:46'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!HTTPSocket class methodsFor: 'magic numbers' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 5/22/1998 16:28'!innerTarget	^ innerTarget! !!HaloMorph methodsFor: 'stepping' stamp: 'jm 6/2/1998 13:51'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target fullBoundsInWorld].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:55'!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/19/1998 11:58'!addHandles	| box s |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: s+1)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color transparent		on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[self addHandleAt: (box rightCenter + (0 @ ((s+2) negated)) min: box rightCenter + box bottomRight // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 12:34'!addHandlesForWorldHalos	| box s |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	s _ self handleSize.	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: target.	self addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: target.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: target)			on: #mouseUp send: #deleteBalloon to: target].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/19/1998 11:46'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world doOneCycle.	menu _ evt hand buildDebugHandleMenuFor: innerTarget.	menu addTitle: innerTarget externalName.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/21/1998 12:25'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	evt hand setArgument: target.	self setTarget: evt hand duplicateMorph.	self removeAllHandlesBut: dupHandle! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 11:35'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - target referencePosition) degrees.	degrees _ degrees - angleOffset degrees.	(degrees abs < 1.0) ifTrue: [degrees _ 0.0].	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	target rotationDegrees: (degrees						detentBy: 10.0						atMultiplesOf: 90.0 snap: false).	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:54'!handleSize	^ 16! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 12:30'!maybeDoDup: evt with: dupHandle	^ target okayToDuplicate ifTrue:		[self doDup: evt with: dupHandle]! !!HandMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 12:23'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:06'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	cacheCanvas ifNil: [		"could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 9/10/1998 16:20'!trailMorph	"You can't draw trails when picked up by the hand."	^ nil! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:05'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	depth = 32 ifTrue: [		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	myBnds _ super fullBounds.  "my full bounds without my shadow"	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:48'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:18'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				mouseDownMorph _ m.				eventTransform _ m transformFrom: self.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 15:58'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed				ifTrue: [self handleDragOver: evt]				ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:46'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:47'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 12:56'!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p].  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 5/29/1998 18:08'!newMouseFocus: aMorphOrNil	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/5/1998 14:05'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].	lastEvent _ evt.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		lastEvent _ evt.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 6/17/1998 08:57'!updateMouseDownTransform	"To help with, eg, autoscrolling"	mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 8/4/1998 17:27'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| targetM toDrop |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		targetM _ self dropTargetFor: m event: evt.		targetM ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		toDrop _ targetM morphToDropFrom: m. 		toDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		targetM acceptDroppingMorph: toDrop event: evt.		toDrop justDroppedInto: targetM event: evt.		toDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 7/6/1998 16:37'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:36'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: World action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'scripting...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open window...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:54'!changesDo	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Change management') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: ScreenController new action: #fileOutChanges.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu add: 'recent change log' action: #openChangesLog.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:09'!debugDo	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Debugging...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'inspect model' action: #inspectWorldModel.	menu add: 'start MessageTally' action: #startMessageTally.	menu add: 'call #tempCommand' action: #callTempCommand.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 02:08'!helpDo	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #updateFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:32'!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 02:15'!openWindow	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:48'!remoteDo	"Build the Telemorphic menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Telemorphic') defaultTarget: self.	menu addStayUpItem.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:02'!scriptingDo	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'scripting...') defaultTarget: self.	menu addStayUpItem.	menu add: 'detachable scripting space' target: self action: #detachableScriptingSpace.	menu add: 'default parts bin' target: self presenter action: #createStandardPartsBin.	menu add: 'custom parts bin' target: self presenter action: #launchMyPartsBin.	menu add: 'control panel' target: self presenter action: #createControlPanel.	menu add: 'add stop, step, and go buttons' target: self presenter action: #addStopStepGoButtons.	menu addLine.	menu add: 'flush viewer cache' action: #flushViewerCache.	menu add: 'unlock contents' action: #unlockWorldContents.	menu add: 'unhide hidden objects' action: #showHiders.	menu add: 'round up stray objects' action: #roundUpStrayObjects.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:35'!windowsDo	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Window management') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu add: 'expand all windows' action: #expandAll.	menu add: 'close unchanged windows' action: #closeUnchangedWindows.	menu addLine.	menu add: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])		target: ScreenController new action: #changeWindowPolicy.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/5/1998 16:53'!browseChangedMessages	Smalltalk browseChangedMessages! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!browsePlayerClass	Browser newOnClass: argument player class label: 'Compiled scripts for ', argument player externalName! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/19/1998 11:54'!buildDebugHandleMenuFor: argMorph	"Build the menu for the given morph's halo's debug handle."	argument _ argMorph.	^ argMorph debuggingMenuFor: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	Preferences noviceMode ifFalse:		[argMorph addDebuggingItemsTo: menu hand: self].	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:05'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'inspect in Morphic' action: #inspectMorphInMorphic.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!changeVariableType	argument ifNotNil:		[argument assuredPlayer changeVariableType]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!chooseNewCostumeForArgument	argument notNil ifTrue:		[argument assuredPlayer newCostume]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/15/1998 07:58'!chooseNewFormForSketchMorph	"Only available when argument is a SketchMorph"	| reply |	reply _ (SelectionMenu selections: Smalltalk imageImports keys asSortedCollection) startUpWithCaption: 'Which element of ImageImports?'.	reply == nil ifTrue: [^ self].	argument form: (Smalltalk imageImports at: reply)! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:33'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self world satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 11:52'!copyToPasteBuffer	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	argument isMorph		ifTrue: [Cursor wait showWhile: 					[argument okayToDuplicate ifTrue:						[PasteBuffer _ argument topRendererOrSelf veryDeepCopy]]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 13:26'!detachableScriptingSpace	| aPasteUp |	aPasteUp _ PasteUpMorph new color: Color white; borderWidth: 1; borderColor: Color green lighter; extent: 500@400.	self attachMorph: aPasteUp.	aPasteUp impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky	! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/21/1998 11:54'!duplicateMorph	| newMorph aName usedNames |	newMorph _ argument veryDeepCopy.	(aName _ argument knownName) ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo:			(Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	self grabMorphFromMenu: newMorph.	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:29'!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	self invokeMenu: menu event: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:30'!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	self invokeMenu: menu event: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!inspectArgumentsPlayerInMorphic	self attachMorph: ((Inspector openAsMorphOn: argument player) extent: 300@200)! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!inspectPlayer	argument player inspect! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/22/1998 22:07'!jumpToProject	(Project buildJumpToMenu: (MenuMorph new defaultTarget: Project))		popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 21:52'!makeAliasForArgument	| aThumbnailMorph |	(argument notNil and: [self playfield notNil]) ifTrue:		[aThumbnailMorph _ argument newThumbnailOfHeight: 40.		aThumbnailMorph  setNameTo: '^ ', argument externalName.		self attachMorph: aThumbnailMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 6/1/1998 19:15'!makeNewDrawing	"Make a new drawing in the standard playfield."	| aPlayfield bnds |	(aPlayfield _ self world playfield) ifNil: [aPlayfield _ self world].	bnds _ aPlayfield paintingBoundsAround: aPlayfield boundsInWorld center.	self makeNewDrawingInBounds: bnds pasteUpMorph: aPlayfield.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 12:30'!maybeDuplicateMorph	argument okayToDuplicate ifTrue:		[self duplicateMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/14/1998 14:34'!objectToPaste	"It may need to be sent #startRunning by the client"	^ Cursor wait showWhile: [PasteBuffer veryDeepCopy]	"PasteBuffer usableDuplicateIn: self world"! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 6/12/1998 15:29'!openChangeSorter: oneOrTwo	oneOrTwo = 1		ifTrue: [ChangeSorter new open]		ifFalse: [DualChangeSorter new open]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 11:29'!openConstructionProject	| aSystemWindow |	self world addMorph: (aSystemWindow _ ProjectViewMorph newMorphicConstruction).	aSystemWindow model "the Project itself" enter: false! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/8/1998 04:57'!openEmail	"open an email interface"	Celeste openOn: 'EMAIL'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openFileList	FileList openAsMorph openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/5/1998 01:22'!openIRC	"open an interface to Internet Relay Chat"	IRCConnection new openView; openDirectMessagesObserver! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/14/1998 23:21'!openWebBrowser	Scamper openAsMorph ! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openWorkspace	Workspace new openAsMorphLabel: 'Workspace' inWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:53'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee player ifNotNil: [aPastee player startRunning]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:49'!placeArgumentIn 	"Let the user choose a new layer in the core sample for the argument to reside in, but don't allow strange loops"	|  targetMorph |	targetMorph _ self selectEmbedTargetMorph: ('Place ', argument externalName, ' in...').	targetMorph ifNotNil:		[targetMorph addMorphFront: argument fromWorldPosition: argument position]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:44'!potentialEmbeddingTargets	"Answer a list of targets into which the hand's arguement could be embedded"	| possibleTargets |	possibleTargets _ self world morphsAt: menuTargetOffset.	argument ifNotNil:		[possibleTargets removeAllFoundIn: argument allMorphs].	^ possibleTargets! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/17/1998 16:27'!saveOnFile	"Save the guy we clicked on, not the hand"	argument saveOnFile! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:07'!selectEmbedTargetMorph: caption	"Put up a menu of morphs found in a core sample taken of the world at the receiver's menuTargetOffset, with the given caption"	|  menu |	menu _ CustomMenu new.	self potentialEmbeddingTargets  do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/3/1998 08:40'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first with: evt].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpAt: self position event: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 8/13/1998 12:56'!writeInitMethodForModel	| model |	model _ self world model.	model class chooseNewName.	model veryDeepCopy compileInitMethods.! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph position.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom: self position - targetOffset].! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03'!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	mouseDownMorph _ nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 9/20/1998 22:28'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette |	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 7/6/1998 13:30'!rejectDropMorph: aMorph event: evt	"aMorph has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	(formerOwner notNil and: [formerOwner isPartsBin not]) ifTrue:		[^ aMorph slideBackToFormerSituation: evt].	formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ aMorph vanishAfterSlidingTo: formerPosition event: evt].			aMorph slideToTrash: evt! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 6/25/1998 09:28'!roundUpStrayObjects	self world roundUpStrays! !a "hidden" input.  It never actually appear on a formatted page, and the user can't change the input value.!!HiddenInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 06:37'!name: name0  value: value0	name _ name0.		value _ value0.! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!name	^name! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!value	^value! !!HiddenInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:38'!name: name0  value: value	^self new name: name0  value: value! !A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.!!HierarchicalUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:44'!hasContents	"most of these do...."	^true! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:24'!privateInitializeFromText: aString	| remainder ind nextTok s specifiedSchemeName |	remainder _ aString.	schemeName ifNil: [ 		specifiedSchemeName _ Url schemeNameForString: remainder.		specifiedSchemeName ifNotNil: [ 			schemeName _ specifiedSchemeName.			remainder _ remainder copyFrom: (schemeName size+2) to: remainder size ].		schemeName ifNil: [ "assume HTTP"  schemeName _ 'http' ] ].	"remove leading // if it's there"	(remainder beginsWith: '//') ifTrue: [		remainder _ remainder copyFrom: 3 to: remainder size ].	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ].	"get the authority"	ind _ remainder indexOf: $/.	ind > 0 ifTrue: [		ind = 1 ifTrue: [ authority _ '' ] ifFalse: [			authority _ remainder copyFrom: 1 to: ind-1.			remainder _ remainder copyFrom: ind+1 to: remainder size. ] ]	ifFalse: [		authority _ remainder.		remainder _ ''. ].	"get the path"	path _ OrderedCollection new.	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 9/10/1998 03:20'!privateInitializeFromText: aString relativeTo: aUrl	| remainder ind nextTok s |	remainder _ aString.	"set the scheme"	schemeName _ aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//') ifTrue: [		^self privateInitializeFromText: aString ].	"otherwise, use the same authority"	authority _ aUrl authority.	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ]. 	"get the path"	remainder isEmpty ifTrue: [ 		path _ aUrl path ]	ifFalse: [		(remainder beginsWith: '/')			ifTrue: [ path _ OrderedCollection new ]			ifFalse: [ path _ aUrl path shallowCopy.				path size > 0 ifTrue: [ path removeLast ] ]. 				s _ ReadStream on: remainder.		[ 			s peek = $/ ifTrue: [ s next ].			nextTok _ WriteStream on: String new.			[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].			nextTok _ nextTok contents unescapePercents.			nextTok = '..' 				ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]				ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].			s atEnd 		] whileFalse.		path isEmpty ifTrue: [ path add: '' ]	. ].! !!HierarchicalUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName0  authority: authority0  path: path0  query: query0	"initialize a new instance"	schemeName _ schemeName0.	authority _ authority0.	path _ path0.	query _ query0.! !!HierarchicalUrl methodsFor: 'printing' stamp: 'ls 7/21/1998 07:23'!toText	| ans |	ans _ WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	ans nextPutAll: self authority.	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!authority	^authority! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/6/1998 12:45'!isAbsolute		path size > 0 ifFalse: [^ false].	(path at: 1) size > 0 ifFalse: [^ false].	^ ((path at: 1) at: 1) ~~ $.! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!path	"return an ordered collection of the decoded path elements, as strings"	^path! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:56'!path: anArray	path _ anArray! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:59'!query	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"	^query ! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!schemeName	^schemeName! !!HierarchicalUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName  authority: authority  path: path  query: query	^self new schemeName: schemeName  authority: authority  path: path  query: query! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!tagName	^'a'! !!HtmlAnchor methodsFor: 'formatting' stamp: 'ls 9/10/1998 03:22'!addToFormatter: formatter	| href name |	name _ self getAttribute: 'name'.	name ifNotNil: [		formatter noteAnchorStart: name ].	href _ self getAttribute: 'href'.	href isNil		ifTrue: [ super addToFormatter: formatter ]		ifFalse: [ 				formatter startLink: href.			super addToFormatter: formatter.			formatter endLink: href. ].! !!HtmlAttributes methodsFor: 'printing' stamp: 'ls 7/23/1998 19:05'!printHtmlOn: aStream	self associationsDo: 		[:element | 		aStream 			space;			nextPutAll: element key asUppercase.		element value ifNotNil: [  				aStream nextPut: $=.				aStream print: element value withoutQuoting]. ]! !an entity which supposedly increases the font size of its constituents!a moderately high level entitiy.  This includes P, FORM, and UL, among others!!HtmlBlockEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:27'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:26'!tagName	^'blockquote'! !!HtmlBlockQuote methodsFor: 'formatting' stamp: 'ls 7/17/1998 20:26'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.	formatter ensureNewlines: 1.! !!HtmlBody methodsFor: 'lint' stamp: 'ls 7/29/1998 00:24'!shouldContain: anEntity	"I don't *think* there are any elements that can be in both the header and the body..."	^anEntity isHeadElement not! !!HtmlBody methodsFor: 'testing' stamp: 'ls 7/4/1998 19:24'!mayContain: anEntity	"Body's can contain anything, so that even if we screw up the parsing, all the text will end up actually being included"	^true! !!HtmlBody methodsFor: 'testing' stamp: 'ls 6/25/1998 02:04'!tagName	^'body'! !an entity which displays its contents in boldface!!HtmlBoldEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 12:53'!addToFormatter: formatter	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!mayContain: anEntity	^false! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!tagName	^'br'! !!HtmlBreak methodsFor: 'formatting' stamp: 'ls 7/17/1998 19:21'!addToFormatter: formatter	formatter addChar: Character cr.! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!mayContain: anEntity	^false! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'button'! !A comment, eg <!!-- this is a comment -->Normally this is ignored, but it's included so that every byte in theinput gets put into one tag or another.!!HtmlComment methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self shouldNotImplement! !!HtmlComment methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isComment	^true! !!HtmlComment methodsFor: 'access' stamp: 'ls 1/25/98 04:56'!text	"return the text of the comment, the part inside the <!!-- and -->"	^self notYetImplemented! !a comment from the page!!HtmlCommentEntity methodsFor: 'private-iniitialization' stamp: 'ls 7/28/1998 20:28'!initializeWithText: aString	super initialize.	commentText _ aString.! !!HtmlCommentEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:30'!printOn: aStream  indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '<!!-- '.	aStream nextPutAll: self commentText.	aStream nextPutAll: ' -->'.	aStream cr.! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^true! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:27'!mayContain: anEntity	^false! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:30'!tagName		"return a bogus tag name"	^'x-comment'! !!HtmlCommentEntity methodsFor: 'formatting' stamp: 'ls 7/4/1998 12:27'!addToFormatter: formatter	"do nothing"! !!HtmlCommentEntity methodsFor: 'access' stamp: 'ls 7/4/1998 12:27'!commentText	^commentText! !!HtmlDefinitionDefinition methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:12'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:20'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ] ! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:18'!tagName	^'dd'! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!mayContain: anEntity	^anEntity isDefinitionListElement! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dl'! !!HtmlDefinitionList methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlDefinitionListElement methodsFor: 'testing' stamp: 'ls 6/25/1998 02:19'!isDefinitionListElement	^true! !!HtmlDefinitionTerm methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:19'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dt'! !an entire HTML document.  It should have exactly two sub-entities when completed: a HEAD and a BODY!!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:57'!mayContain: anElement	^true 	"not strictly true, but it makes the parser simpler"! !!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:06'!tagName	^'html'! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:38'!addToBody: anObject	"add an object to the Body entity of the receiver"	self body add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:37'!addToHead: anObject	"add an object to the head entity of the receiver"	self head add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!body	^self contents at: 2! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!head	^self contents at: 1! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:25'!formattedText	"return a version of this document as a formatted Text"	| formatter |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	^formatter text ! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/29/1998 03:01'!formattedTextForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted Text (which includes links and such)"	| formatter text |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	text _ formatter text.	^text! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/14/1998 00:35'!formattedTextMorph	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter text textMorph |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	text _ formatter text .	textMorph _ TextMorph new initialize.	textMorph contentsWrapped: text.	^textMorph! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/16/1998 22:12'!formattedTextMorphForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter textMorph |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	textMorph _ formatter textMorph .	^textMorph! !!HtmlDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 04:26'!emptyDocument	"return an empty document"	^super new add: HtmlHead new; add: HtmlBody new! !<html>When HtmlParser runs, it generates a tree whose nodes are in HtmlEntity's subclasses.  There is a separate class for most of the available elements in HTML, though some are grouped together under generic classes like HtmlBoldEntity.Methods of particular interest when modifying or adding subclasses are:<ul><li>initialize:<li>mayContain:<li>addToFormatter:</ul>!!HtmlEntity methodsFor: 'downloading' stamp: 'ls 7/29/1998 00:52'!downloadState: baseUrl	"download any state needed for full rendering.  eg, images need this"	! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrame	^false! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^false! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspect	"Open an HtmlEntityInspector on the receiver.	Use basicInspect to get a normal type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspectWithLabel: aLabel	"Open a HtmlEntityInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true withLabel: aLabel! !!HtmlEntity methodsFor: 'converting' stamp: 'djp 7/21/1998 11:58'!asHtml	| aStream |	aStream := WriteStream on: ''.	self printHtmlOn: aStream.	^aStream contents.! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:21'!add: anObject	"add an object to the receiver"	(anObject isKindOf: String)		ifTrue: [contents add: (HtmlTextEntity new text: anObject)]		ifFalse: [contents add: anObject]! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 13:51'!at: key put: anObject	self attributes ifNil: [self attributes: (HtmlAttributes new)].	(self attributes) at: key put: anObject! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:28'!attributes	^attribs ifNil: [attribs := HtmlAttributes new]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 15:01'!addToFormatter: aFormatter	"by default, just format our childer"	contents do: [ :e | e addToFormatter: aFormatter ]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 7/15/1998 18:31'!parsingFinished	"some entities need to make a final pass *after* parsing has finished and all the contents of each entity have been established; here is a place to do that"	contents do: [ :e | e parsingFinished ].! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:03'!addEntity: anEntity	"add an entity to the receiver"	contents add: anEntity! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:02'!contents	"return an ordered collection of this entity's contents"	^contents! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:37'!textualContents	"return a string with the concatenated contents of all textual sub-entities"	^String streamContents: [ :s |		contents do: [ :e | s nextPutAll: e textualContents ] ]! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'ls 7/31/1998 02:57'!initialize	contents _ OrderedCollection new.	attribs _ HtmlAttributes new.! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'djp 7/20/1998 20:52'!initialize: aTag	self initialize.	attribs _ HtmlAttributes newFrom: aTag attribs.! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isDefinitionListElement	"whether receiver can appear in a DefinitionList"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/16/1998 23:18'!isFormEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:54'!isHeadElement	"whether this can appear in a header"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:18'!isListElement	"is this an HtmlListElement, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:12'!isListItem	"is this an HtmlListItem, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	"whether this is an <option> entity"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isTextualEntity	"is receiver either text, or some low-level text-like entity such as <b> or <em>"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:09'!lint	^String streamContents: [ :s | self lint: s ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:37'!lint: aStream	"do a lint check, reporting to aStream"	self lintAttributes: aStream.	contents do: [ :c |		(c isComment not   and:  [ (self shouldContain: c) not ]) ifTrue: [ 			aStream nextPutAll: '<', self tagName, '> should not contain <', c tagName, '>'.			aStream cr. ] ].	contents do: [ :c  | c lint: aStream ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:07'!lintAttributes: aStream	"check that our attributes are okay.  Print any anomalies to aStream"	! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:03'!mayContain: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:01'!mayContainEntity: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:35'!shouldContain: anEntity	"whether, according to the HTML DTD, this element should actually contain anEntity.  Used for checking the quality of a pages HTML"	^self mayContain: anEntity! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:02'!tagName	"tag name for ourself"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/26/1998 19:59'!attributes: newAttributes	"set all of the attributes at once.  newAttributes should not be modified after passing it in"	^attribs _ newAttributes! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 02:55'!doesNotUnderstand: aMessage	"treat the message as an attribute name"	| selector |	selector _ aMessage selector.	selector asLowercase = selector ifFalse: [		"attribute accesses must be in all lowercase.  This should cut down on some false doesNotUnderstand: traps"		^super doesNotUnderstand: aMessage ].	selector numArgs == 0 ifTrue: [		"return the named attribute"		^self getAttribute: selector asString default: nil ].	selector numArgs == 1 ifTrue: [		"set the named attribute"		self setAttribute: (selector asString copyFrom: 1 to: (selector size-1)) to: aMessage argument.		^self ].	^super doesNotUnderstand: aMessage! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:20'!getAttribute: name	^self getAttribute: name  default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:52'!getAttribute: name  default: anObject	^self getAttribute: name  ifAbsent: [anObject]! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:51'!getAttribute: name  ifAbsent: aBlock	^attribs at: name ifAbsent: aBlock! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/17/1998 19:04'!name	^self getAttribute: 'name' default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 03:00'!setAttribute: name  to: value	"set the given attribute to the given value"	attribs at: name asLowercase  put: value! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/20/1998 21:12'!printHtmlOn: aStream	^self printHtmlOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/21/1998 17:43'!printHtmlOn: aStream indent: indent	aStream 		next: indent put: $ ;		nextPut: $<;		nextPutAll: self tagName asUppercase;		printHtml: self attributes;		nextPut: $>;		cr.	contents do: [ :entity | entity printHtmlOn: aStream indent: indent+3 ].	aStream		next: indent put: $ ;		nextPutAll: '</';		nextPutAll: self tagName asUppercase;		nextPut: $>;		cr.! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 6/25/1998 03:13'!printOn: aStream	^self printOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 8/11/1998 03:16'!printOn: aStream  indent: indent	aStream		next: indent put: $ ;		nextPut: $<;		print: self tagName.	self attributes associationsDo: [ :assoc |		aStream			space;			nextPutAll: assoc key;			nextPutAll: '=';			nextPutAll: assoc value ].	aStream		nextPut: $>;		cr.	contents do: [ :entity | entity printOn: aStream indent: indent+1 ].! !!HtmlEntity methodsFor: 'enumeration' stamp: 'ls 7/16/1998 23:17'!allSubentitiesDo: aBlock	"perform the block recursively on all sub-entities"	contents do: [ :e | 		aBlock value: e .		e allSubentitiesDo: aBlock.	].	! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 7/29/1998 01:27'!forTag: aTag	"create a new entity based on the given tag"	^self new initialize: aTag! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 13:17'!new	^super new initialize! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'djp 7/21/1998 17:21'!fieldList	^ super fieldList, (Array with: 'asHtml')! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'ls 7/24/1998 01:40'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 300 @ 300! !!HtmlEntityInspector methodsFor: 'selecting' stamp: 'ls 7/23/1998 07:37'!selection	selectionIndex = self fieldList size 		ifTrue: [^object asHtml]		ifFalse: [^super selection]! !An entity that (supposedly) displays its contents in a fixed-width font.  I don't know how to do this, though.  -ls!an entity whose effect is to change the font its constituents are displayed in in some way.  Multiple tags might generate almost any of the subclasses, so the tag name is stored explicitly.!!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 7/5/1998 01:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 12:51'!tagName	"must be stored in an i-var, because these classes work for different tags"	^tagName! !!HtmlFontChangeEntity methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:34'!initialize: aTag	super initialize: aTag.	tagName _ aTag name! !the <font> tag.  it's here for future expansion....!!HtmlForm methodsFor: 'testing' stamp: 'ls 7/4/1998 19:51'!isBlockElement	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/15/1998 00:24'!mayContain: anEntity	"allow anything.  People probably always put </form> anyway at the end of their forms.  And furthermore, it has no effect on the display, even if this is gotten wrong"	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/3/1998 23:30'!tagName	^'form'! !!HtmlForm methodsFor: 'formatting' stamp: 'ls 7/17/1998 00:26'!addToFormatter: formatter	formatter startForm: self.	super addToFormatter: formatter.	formatter currentFormData reset.	formatter endForm.! !!HtmlForm methodsFor: 'parsing' stamp: 'ls 7/16/1998 23:16'!parsingFinished	"figure out who our constituents are"	self allSubentitiesDo: [ :e |		e isFormEntity ifTrue: [ e form: self ] ].	super parsingFinished.	formEntities _ OrderedCollection new.	self allSubentitiesDo: [ :e |		(e isFormEntity and: [ e form == self ])			ifTrue: [ formEntities add: e ] ].! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!method	"method to submit with"	^self getAttribute: 'method' default: 'get'! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!url	"url to submit to"	^self getAttribute: 'action' default: nil.  ! !!HtmlForm methodsFor: 'access' stamp: 'ls 7/16/1998 23:29'!formEntities	^formEntities! !Abstract superclass for elements that only appear in forms!!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form	"return which form we are in"	^form! !!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form: aForm	"set which form we are part of"	form _ aForm! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/15/1998 00:22'!isFormEntity	^true! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/29/1998 00:15'!lint: aStream	form ifNil: [ aStream nextPutAll: '<', self tagName, '> not within a form'.		aStream cr. ].	super lint: aStream.! !a filter which formats HTML into a Text with attributes!!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:07'!currentFormData	"return the current form data, or nil if we aren't inside a form"	formDatas size > 0 		ifTrue: [ ^formDatas last ]		ifFalse: [ ^nil ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:06'!endForm	formDatas size > 0 ifTrue: [ 		formDatas removeLast. ]	ifFalse: [ self halt: 'HtmlFormatter: ended more forms that started!!?' ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 8/5/1998 07:14'!startForm: form	"a form is beginning"	formDatas addLast: (FormInputSet forForm: form  andBrowser: browser).! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/10/1998 03:20'!anchorLocations	"return a dictionary mapping lowercase-ed anchor names into the integer positions they are located at in the text"	^anchorLocations! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!baseUrl	"return the base URL for the document we are formatting, if known"	^baseUrl! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:09'!baseUrl: url	"set the base url.  All relative URLs will be determined relative to it"	baseUrl _ url.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:07'!browser	"return the browser we are formatting for, or nil if none"	^browser! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!browser: b	"set what browser we are formatting for"	browser _ b.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/5/1998 18:08'!incompleteMorphs	"list of morphs needing to download some more state"	^incompleteMorphs! !!HtmlFormatter methodsFor: 'private-initialization' stamp: 'ls 9/10/1998 03:17'!initialize	outputStream _ AttributedTextStream new.	preformattedLevel _ 0.	indentLevel _ boldLevel _ italicsLevel _ underlineLevel _ strikeLevel _ centerLevel _ 0.	listLengths _ OrderedCollection new.	listTypes _ OrderedCollection new.	formDatas _ OrderedCollection new.	precedingSpaces _ 0.	precedingNewlines _ 1000.   "more than will ever be asked for"	morphsToEmbed _ OrderedCollection new.	incompleteMorphs _ OrderedCollection new.	anchorLocations _ Dictionary new.	outputStream nextPut: Character cr.! !!HtmlFormatter methodsFor: 'private-formatting' stamp: 'ls 8/5/1998 01:41'!setAttributes	"set attributes on the output stream"	| attribs |	attribs _ OrderedCollection new.	indentLevel > 0 ifTrue: [ attribs add: (TextIndent tabs: indentLevel) ].	boldLevel > 0 ifTrue: [ attribs add: TextEmphasis bold ].	italicsLevel >  0 ifTrue: [ attribs add: TextEmphasis italic ].	underlineLevel > 0 ifTrue: [ attribs add: TextEmphasis underlined ].	strikeLevel > 0 ifTrue: [ attribs add: TextEmphasis struckOut ].	urlLink isNil ifFalse: [ attribs add: (TextURL new url: urlLink) ].	outputStream currentAttributes: attribs! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:14'!addChar: c	"add a single character, updating all the tallies"	"add the character to the output"	outputStream nextPut: c.	"update counters for preceeding spaces and preceding newlines"	(c = Character space or: [ c = Character tab ]) 	ifTrue: [ precedingSpaces _ precedingSpaces+1.  precedingNewlines _ 0 ]	ifFalse: [		(c = Character cr) ifTrue: [			precedingSpaces _ 0.			precedingNewlines _ precedingNewlines + 1 ]		ifFalse: [			precedingSpaces _ precedingNewlines _ 0 ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/5/1998 18:09'!addIncompleteMorph: aMorph	"add a morph, and note that it needs to download some more state before reaching its ultimate state"	self addMorph: aMorph.	incompleteMorphs add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 02:51'!addLink: text  url: url	"add a link with the given url and text"	| savedAttributes linkAttribute  |	"set up the link attribute"	linkAttribute _ TextURL new.	linkAttribute url: url.	"add the link to the stream"	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes, linkAttribute).	outputStream nextPutAll: text.	outputStream currentAttributes: savedAttributes.	"reset counters"	precedingSpaces _ precedingNewlines _ 0.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/29/1998 07:39'!addMorph: aMorph	"add a morph to the output"	| savedAttributes |	self addChar: Character space.	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes copyWith: (TextAnchor new anchoredMorph: aMorph)).	self addChar: $*.	outputStream currentAttributes: savedAttributes.	self addChar: Character space.	morphsToEmbed add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/25/1998 06:10'!addString: aString	"adds the text in the given string.  It collapses spaces unless we are in a preformatted region"	| space compacted lastC i |	aString isEmpty ifTrue: [ ^self ].	space _ Character space.	preformattedLevel > 0 ifTrue: [		"add all the characters as literals"		outputStream nextPutAll: aString.		"update the counters"		lastC _ aString last.		(lastC = space or: [ lastC = Character cr ]) ifTrue: [			"how many of these are there?"			i _ aString size - 1.			[ i >= 1 and: [ (aString at: i) = lastC ] ] whileTrue: [ i _ i - 1 ].			i = 0 ifTrue: [				"the whole string is the same character!!"				lastC = space ifTrue: [					precedingSpaces _ precedingSpaces + aString size.					precedingNewlines _ 0.					^self ]				ifFalse: [					precedingSpaces _ 0.					precedingNewlines _ precedingNewlines + aString size.					^self ]. ].			lastC = space ifTrue: [				precedingSpaces _ aString size - i.				precedingNewlines _ 0 ]			ifFalse: [				precedingSpaces _ 0.				precedingNewlines _ aString size - i ] ] ]	ifFalse: [		compacted _ aString withSeparatorsCompacted.		compacted = ' ' ifTrue: [			"no letters in the string--just white space!!"			(precedingNewlines = 0 and: [precedingSpaces = 0]) ifTrue: [				precedingSpaces _ 1.				outputStream nextPut: space. ].			^self ].		(compacted first = Character space and: [			(precedingSpaces > 0) or: [ precedingNewlines > 0] ])		ifTrue: [ compacted _ compacted copyFrom: 2 to: compacted size ].		outputStream nextPutAll: compacted.		"update counters"		precedingNewlines _ 0.		compacted last = space 			ifTrue: [ precedingSpaces _ 1 ]			ifFalse: [ precedingSpaces _ 0 ]. ]! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseBold	boldLevel _ boldLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseIndent	indentLevel _ indentLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseItalics	italicsLevel _ italicsLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!decreasePreformatted	preformattedLevel _ preformattedLevel - 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!decreaseStrike	strikeLevel _ strikeLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:39'!decreaseUnderline	underlineLevel _ underlineLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!endLink: url	urlLink _ nil.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/20/1998 11:34'!endListItem	"end a list item"	self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:17'!endOrderedList	"end an ordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 	self ensureNewlines: 1.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:18'!endUnorderedList	"end an unordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 		self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/25/1998 17:21'!ensureNewlines: number	"make sure there are at least number preceding newlines"	number > precedingNewlines ifTrue: [		(number - precedingNewlines) timesRepeat: [ self addChar: Character cr ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/16/1998 11:34'!ensureSpaces: number	"make sure there are at least number preceding spaces, unless we're at the beginning of a new line"	precedingNewlines > 0 ifTrue: [ ^ self ].	number > precedingSpaces ifTrue: [		(number - precedingSpaces) timesRepeat: [ self addChar: Character space ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:15'!hr	"add an (attempt at a) horizontal rule"	self ensureNewlines: 1.	25 timesRepeat: [ self addChar: $- ].	self ensureNewlines: 1.	precedingSpaces _ 0.	precedingNewlines _ 1000.    "pretend it's the top of a new page"! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseBold	boldLevel _ boldLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseIndent	indentLevel _ indentLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:13'!increaseItalics	italicsLevel _ italicsLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!increasePreformatted	preformattedLevel _ preformattedLevel + 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!increaseStrike	strikeLevel _ strikeLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:40'!increaseUnderline	underlineLevel _ underlineLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/10/1998 03:26'!noteAnchorStart: anchorName	"note that an anchor starts at this point in the output"	anchorLocations at: anchorName asLowercase put: outputStream size! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!startLink: url	urlLink _ url.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/13/1998 23:19'!startListItem	"begin a new list item"	listTypes size = 0 ifTrue: [ ^self ].	self ensureNewlines: 1.	listTypes last = #unordered		ifTrue: [ self addString: 'o ' ]		ifFalse: [ self addString: (listLengths last + 1) printString.			self addString: '. ' ].	listLengths at: (listLengths size) put: (listLengths last + 1).! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startOrderedList	"begin an ordered list"	listLengths add: 0.	listTypes add: #ordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startUnorderedList	"begin an unordered list"	listLengths add: 0.	listTypes add: #unordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 6/30/1998 01:13'!text	| text |	text _ outputStream contents.	^text! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 7/16/1998 21:55'!textMorph	| text textMorph |	text _ outputStream contents.	textMorph _ TextMorph new contents: text.	morphsToEmbed do:[ :m | textMorph addMorph: m ].	^textMorph! !!HtmlFormatter class methodsFor: 'instance creation' stamp: 'ls 6/25/1998 17:25'!new	^super new initialize! !!HtmlFormatter class methodsFor: 'example' stamp: 'ls 7/14/1998 00:42'!example1	"(HtmlFormatter example1 asParagraph compositionRectangle: (0@0 extent: 300@500) ) displayAt: 0@0"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser"]></a></body></html>'.	^(HtmlParser on: input) formattedText! !!HtmlFormatter class methodsFor: 'initialization' stamp: 'ls 8/20/1998 06:05'!initialize	"HtmlFormatter initialize"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!HtmlFrame methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:25'!isFrame	^true! !!HtmlFrame methodsFor: 'formatting' stamp: 'ls 7/26/1998 21:53'!addToFormatter: formatter	| src |	src _ self getAttribute: 'src' default: nil.	formatter ensureNewlines: 1.	src ifNotNil: [ formatter startLink: src ].	formatter addString: 'frame '.	formatter addString: (self name ifNil: ['(unnamed)']).	src ifNotNil:  [ formatter endLink: src ].	formatter ensureNewlines: 1.! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!mayContain: anEntity	^false! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!tagName	^'frame'! !!HtmlFrameSet methodsFor: 'lint' stamp: 'ls 7/29/1998 00:25'!shouldContain: anEntity	^anEntity isFrame or: [ anEntity isFrameSet ]! !!HtmlFrameSet methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/29/1998 00:26'!mayContain: anEntity	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/26/1998 21:45'!tagName	^'frameset'! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:03'!title	"return the title, or nil if there isn't one"	| te |	te _ self titleEntity.	te ifNil: [ ^nil ].	^te textualContents! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:02'!titleEntity	"return the title entity, or nil if there isn't one"	contents do: [ :e | e tagName = 'title' ifTrue: [ ^e ] ].	^nil! !!HtmlHead methodsFor: 'testing' stamp: 'ls 7/28/1998 20:25'!mayContain: anEntity	^anEntity isHeadElement or: [ anEntity isComment ]! !!HtmlHead methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'head'! !abstract superclass for entities that may appear in the HEAD section!!HtmlHeadEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 15:37'!isHeadElement	^true! !!HtmlHeadEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:38'!addToFormatter: formatter	"head elements are normally just meta-information, and thus don't add anything to the formatter"! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^true! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 6/27/1998 15:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/23/1998 05:42'!tagName	^'h', level printString! !!HtmlHeader methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:14'!addToFormatter: formatter	formatter ensureNewlines: 3.	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.	formatter ensureNewlines: 2.! !!HtmlHeader methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 05:42'!initialize: aTag	super initialize: aTag.	level _ aTag name last digitValue.! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/27/1998 15:52'!mayContain: anEntity	^false! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'hr'! !!HtmlHorizontalRule methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:57'!addToFormatter: formatter	formatter hr! !!HtmlImage methodsFor: 'downloading' stamp: 'ls 8/8/1998 03:47'!downloadState: baseUrl 	|  sourceUrl imageSource |	image ifNil: [ 		sourceUrl _ self src.		sourceUrl ifNotNil: [ 			imageSource _ HTTPSocket httpGetDocument: (sourceUrl asUrlRelativeTo: baseUrl asUrl) toText.			imageSource contentType = 'image/gif'  ifTrue: [				[image _ (GIFReadWriter on: (RWBinaryOrTextStream with: imageSource content) reset binary) nextImage ]				ifError: [ :a :b |  "could not decode--ignore it"  image _ nil ] ].			 ] ].! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 8/4/1998 21:58'!alt	^(self getAttribute: 'alt') ifNil: ['[image]']! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 9/9/1998 07:01'!imageExtent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 7/29/1998 00:56'!src	^self getAttribute: 'src' default: nil! !!HtmlImage methodsFor: 'formatting' stamp: 'ls 9/9/1998 07:05'!addToFormatter: formatter	| morph url |	self src isNil ifTrue: [ ^self ].	url _ self src.	formatter baseUrl ifNotNil: [ 		url _ url asUrlRelativeTo: formatter baseUrl ].	morph _ DownloadingImageMorph new.	morph defaultExtent: self imageExtent.	morph altText: self alt.	morph url: url.	formatter addIncompleteMorph: morph.! !!HtmlImage methodsFor: 'initializing' stamp: 'ls 7/27/1998 02:17'!initialize: aTag		super initialize: aTag.! !!HtmlImage methodsFor: 'testing' stamp: 'ls 7/1/1998 02:30'!mayContain: anEntity	^false! !!HtmlImage methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'img'! !result of an <input> tag!!HtmlInput methodsFor: 'attributes' stamp: 'ls 9/18/1998 08:22'!defaultValue	^(self getAttribute: 'value' default: '') replaceHtmlCharRefs! !!HtmlInput methodsFor: 'attributes' stamp: 'ls 7/23/1998 19:09'!type	^(self getAttribute: 'type' default: 'text') asLowercase! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:15'!isTextualEntity	^true! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!mayContain: anEntity	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/21/1998 06:51'!suppliesInput	"whether we actually have input to supply"	self type = 'text' ifTrue: [ ^true ].	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!tagName	^'input'! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 8/11/1998 20:47'!addRadioButtonToFormatter: formatter	| name formData checked buttonSet button buttonInput |	"dig up relevant attributes"	name _ self getAttribute: 'name'.	name ifNil: [ ^self ].	value _ self getAttribute: 'value'.	value ifNil: [ ^value ].		formData _ formatter currentFormData.	formData ifNil:  [ ^self ].	checked _ self getAttribute: 'checked'.	"find or create the set of buttons with our same name"	buttonSet _ formData inputs detect: [ :i | i isRadioButtonSetInput and: [ i name = name ] ] ifNone: [ nil ].	buttonSet ifNil: [ 		"create a new button set"		buttonSet _ RadioButtonSetInput name: name.		formData addInput: buttonSet. ].	"set up the form input"	buttonInput _ RadioButtonInput  inputSet: buttonSet value: value.	buttonSet addInput: buttonInput.	checked ifNotNil: [		buttonSet  defaultButton: buttonInput ].	"create the actual button"	button _ PluggableButtonMorph on: buttonInput getState: #pressed  action: #toggle.	button label: 'X'.	formatter addMorph: button.! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 9/11/1998 23:42'!addToFormatter: formatter	"is it a submit button?"	| inputMorph formData size |	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image' ifTrue: [		"fake it"		value _ self getAttribute: 'value' default: 'Submit'.		formData _ formatter currentFormData.		formatter addMorph: ((PluggableButtonMorph on: formData getState: nil action: #submit) label: value).		formData addInput: (HiddenInput name: (value,'.x') value: '0').		formData addInput: (HiddenInput name: (value,'.y') value: '0').			^self ].	self type = 'text' ifTrue: [		inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.		size _ self getAttribute: 'size' default: '12'.		size _ size asNumber.		inputMorph extent: (size*10@20).		formatter addMorph: inputMorph.		formatter currentFormData addInput: (TextInput name: self name  defaultValue: self defaultValue  textMorph: inputMorph).		^self ].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !an entity which displays its contents in italics!!HtmlItalicsEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 13:16'!addToFormatter: formatter	formatter increaseItalics.	super addToFormatter: formatter.		formatter decreaseItalics.! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/17/1998 19:20'!mayContain: anElement	"lists may only contain LI elements"	"^anElement isListItem"	"except that people write some sucky HTML out there!!!!  well, let's assume they always put the end tag.  Much safer assumption than that they only put list-items in their lists"	^true! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/28/1998 20:40'!shouldContain: anEntity	^anEntity isListItem! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:10'!isListItem	^true! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ]! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:09'!tagName	^'li'! !!HtmlListItem methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:49'!addToFormatter: formatter	formatter startListItem.	super addToFormatter: formatter.	formatter endListItem.! !some result of a meta tag; unimplemented so far!!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!mayContain: anEntity	^false! !!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!tagName	^'meta'! !!HtmlMeta methodsFor: 'formatting' stamp: 'ls 8/12/1998 05:44'!addToFormatter: formatter	| httpEquiv |	httpEquiv _ self getAttribute: 'http-equiv'.	httpEquiv ifNil: [ ^self ].	httpEquiv asLowercase = 'refresh' ifTrue: [		formatter addString: '{refresh: ', (self getAttribute:  'content' default: ''), '}' ].! !!HtmlMeta methodsFor: 'initialization' stamp: 'ls 7/5/1998 02:23'!initialize: aTag	super initialize: aTag.	theTag _ aTag.! !!HtmlMeta methodsFor: 'printing' stamp: 'ls 7/5/1998 02:24'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: 'meta: '.	theTag printOn: aStream.	aStream cr.! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:19'!label	"label to be displayed for this morph"	^self getAttribute: 'label' ifAbsent: [self textualContents]! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 08:42'!value	"value to pass if this option is selected"	^self getAttribute: 'value' default: '(unspecified)'! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	^true! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'option'! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!mayContain: anEntity	^anEntity isOption! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'optgroup'! !!HtmlOrderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startOrderedList.	super addToFormatter: formatter.	formatter endOrderedList.! !!HtmlOrderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ol'! !!HtmlParagraph methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:16'!addToFormatter: formatter	formatter ensureNewlines: 2.	super addToFormatter: formatter.! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!tagName	^'p'! !parses a stream of HtmlToken's into an HtmlDocument.  All token become an entity of some sort in the resulting document; some things are left only as comments, though.!!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/28/1998 02:02'!parse: aStream	^self parseTokens: (HtmlTokenizer on: aStream)! !!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/29/1998 03:13'!parseTokens: tokenStream	|  entityStack document head token matchesAnything entity body |	entityStack _ OrderedCollection new.	"set up initial stack"	document _ HtmlDocument new.	entityStack add: document.		head _ HtmlHead new.	document addEntity: head.	entityStack add: head.	"go through the tokens, one by one"	[ token _ tokenStream next.  token = nil ] whileFalse: [		(token isTag and: [ token isNegated ]) ifTrue: [			"a negated token"			(token name ~= 'html' and: [ token name ~= 'body' ]) ifTrue: [				"see if it matches anything in the stack"				matchesAnything _ (entityStack detect: [ :e | e tagName = token name ] ifNone: [ nil ]) isNil not.				matchesAnything ifTrue: [					"pop the stack until we find the right one"					[ entityStack last tagName ~= token name ] whileTrue: [ entityStack removeLast ].					entityStack removeLast.				]. ] ]		ifFalse: [			"not a negated token.  it makes its own entity"			token isComment ifTrue: [				entity _ HtmlCommentEntity new initializeWithText: token source.			].			token isText ifTrue: [				entity _ HtmlTextEntity new text: token text.				(((entityStack last shouldContain: entity) not) and: 					[ token source isAllSeparators ]) ifTrue: [					"blank text may never cause the stack to back up"					entity _ HtmlCommentEntity new initializeWithText: token source ].			].			token isTag ifTrue: [				entity _ token entityFor.				entity = nil ifTrue: [ entity _ HtmlCommentEntity new initializeWithText: token source ] ].			entity = nil ifTrue: [ self error: 'could not deal with this token' ].			entity isComment ifTrue: [				"just stick it anywhere"				entityStack last addEntity: entity ]			ifFalse: [				"only put it in something that is valid"				[ entityStack last mayContain: entity ] 					whileFalse: [ entityStack removeLast ].				"if we have left the head, create a body"									entityStack size < 2 ifTrue: [ 					body _ HtmlBody new.					document addEntity: body.					entityStack add: body  ].				"add the entity"				entityStack last addEntity: entity.				entityStack addLast: entity.			].		]].	body == nil ifTrue: [		"add an empty body"		body _ HtmlBody new.		document addEntity: body ].	document parsingFinished.	^document! !!HtmlParser class methodsFor: 'example' stamp: 'ls 6/27/1998 15:32'!example1	"HtmlParser example1"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser]"></a></body></html>'.	^HtmlParser parse: input! !!HtmlPreformattedRegion methodsFor: 'lint' stamp: 'ls 7/29/1998 00:27'!shouldContain: anEntity	^anEntity isTextualEntity! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!mayContain: anEntity	^true! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!tagName	^'pre'! !!HtmlPreformattedRegion methodsFor: 'formatting' stamp: 'ls 7/13/1998 23:15'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increasePreformatted.	super addToFormatter: formatter.	formatter decreasePreformatted.	formatter ensureNewlines: 1.! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!isTextualEntity	^true! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^true  "end tag required"! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'select'! !!HtmlSelect methodsFor: 'formatting' stamp: 'ls 8/11/1998 03:12'!addToFormatter: formatter	| options defaultOption listMorph names |	names _ OrderedCollection new.	options _ OrderedCollection new.	defaultOption _ nil.	(self getAttribute: 'multiple') ifNotNil: [		self flag: #incomplete.		formatter addString: '[M option list]'.		^self ].	contents do: [ :c |  c isOption ifTrue: [		names add: c value.		options add: c label.		(c getAttribute: 'selected') ifNotNil: [ defaultOption _ c label ] ] ].	contents isEmpty ifTrue: [ ^self ].	defaultOption ifNil: [ defaultOption _ contents first ].	listMorph _ PluggableListMorph on: (ValueHolder new contents: (contents indexOf: defaultOption)) list: nil  selected: #contents  changeSelected: #contents:.	listMorph list: options.	formatter addMorph: listMorph.	formatter currentFormData addInput: (SelectionInput  name: self name  defaultValue: defaultOption  list: listMorph  values: names asArray)! !supposedly decreases the font size its constituents are displayed in!the contents should be displayed struck-through!!HtmlStrikeEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 02:05'!addToFormatter: formatter	formatter increaseStrike.	super addToFormatter: formatter.	formatter decreaseStrike.! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!tagName	^'style'! !an entity to be displayed as a subscript!an entity whose contents are to be displayed as a superscript!!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!mayContain: anEntity	^anEntity isTableRow! !!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 19:07'!tagName	^'table'! !!HtmlTable methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableDataItem methodsFor: 'formatting' stamp: 'ls 9/5/1998 03:37'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureSpaces: 1.! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^true! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:56'!mayContain: anEntity	^anEntity isTextualEntity or: [ anEntity isBlockEntity or: [ anEntity isHeader ] ]! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 19:01'!tagName	^'td'! !a TH tag.  Currently treated the same as a TD!!HtmlTableHeader methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:51'!tagName	^'th'! !!HtmlTableRow methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^true! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!mayContain: anEntity	^anEntity isTableDataItem! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 19:00'!tagName	^'tr'! !An HTML tag, eg <a href="foo.html">!!HtmlTag methodsFor: 'parser support' stamp: 'ls 6/27/1998 13:18'!entityFor	"return an empty entity corresponding to this tag"	| eClass |	eClass _ self class entityClasses at: name ifAbsent: [ ^nil ].	^eClass forTag: self ! !!HtmlTag methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isTag	^true! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:50'!attribs	"return a dictionary mapping attribute names (in lowercase) to their values"	^attribs! !!HtmlTag methodsFor: 'access' stamp: 'ls 6/24/1998 18:53'!isNegated	^isNegated! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:49'!name	"return the basic kind of tag, in lowercase"	^name! !!HtmlTag methodsFor: 'private-initialization' stamp: 'ls 7/14/1998 22:49'!name: name0  negated: isNegated0 attribs: attribs0	"initialize from the given attributes"	name _ name0.	isNegated _ isNegated0.	attribs _ attribs0 ifNil: (Dictionary new).! !!HtmlTag class methodsFor: 'parser support' stamp: 'ls 9/12/1998 00:52'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		a		HtmlAnchor		br		HtmlBreak		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		th		HtmlTableHeader		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!HtmlTag class methodsFor: 'parser support' stamp: 'ls 7/14/1998 22:56'!initialize	EntityClasses _ nil.! !!HtmlTag class methodsFor: 'instance creation' stamp: 'ls 6/24/1998 18:54'!source: source0  name: name0  negated: negated0 attribs: attribs0	^(super forSource: source0) name: name0 negated: negated0 attribs: attribs0! !A sequence of text without any tags in it.  &sp; style characters have been replaced by their actual values. !!HtmlText methodsFor: 'formatter' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"	aFormatter addText: source! !!HtmlText methodsFor: 'access' stamp: 'ls 1/25/98 04:57'!text	^text! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 8/25/1998 05:47'!initialize: source0	super initialize: source0.	self text: source0 replaceHtmlCharRefs.! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 7/21/1998 01:02'!text: text0	text _ text0.! !!HtmlText methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isText	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:28'!isBlockEntity	"not sure...."	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/29/1998 00:28'!mayContain: anEntity	^true   "really we shouldn't be interpretting tags in here at all, though...."! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/17/1998 19:05'!suppliesInput	^self name ~= nil! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:40'!tagName	^'textarea'! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:17'!columns	| a |	a _ self getAttribute: 'cols' default: '70'.	^(Integer readFrom: (ReadStream on: a)) max: 5.! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:12'!defaultValue	^self textualContents  "it would be nice to through the tags in there, too....  Easiest way would probably be to modiy the tokenizer"! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:16'!rows	| a |	a _ self getAttribute: 'rows' default: '20'.	^(Integer readFrom: (ReadStream on: a)) max: 1.! !!HtmlTextArea methodsFor: 'formatting' stamp: 'ls 8/5/1998 08:50'!addToFormatter: formatter	| inputMorph |	formatter ensureNewlines: 1.	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	inputMorph extent: (self columns * 5) @ (self rows * 8).	formatter addMorph: inputMorph.	formatter currentFormData addInput: (TextInput name: self name  defaultValue:  self textualContents  textMorph: inputMorph).	formatter ensureNewlines: 1.! !!HtmlTextEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:38'!textualContents	^text! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:26'!mayContain: anEntity	^false! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!tagName	"bogus"	^'x-text'  ! !!HtmlTextEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:24'!addToFormatter: aFormatter	aFormatter addString: text! !!HtmlTextEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:28'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '['.	aStream nextPutAll: text.	aStream nextPutAll: ']'.	aStream cr.! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 6/25/1998 02:58'!text	^text! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 7/14/1998 23:58'!text: text0	text _ text0! !includes raw text, font-changing entities like <b> and <em>, and special entities like <a> and <img>.  All of these are relatively low level regarding formatting; they are superceded by higher level things like <li> and <p>.  When formatted, they flow around like characters.!!HtmlTextualEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!isTextualEntity	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!isHeadElement	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:36'!tagName	^'title'! !!HtmlToken methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self subclassResponsibility! !!HtmlToken methodsFor: 'formatting' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"! !!HtmlToken methodsFor: 'printing' stamp: 'ls 1/25/98 05:45'!printOn: aStream	aStream nextPutAll: '{';		nextPutAll: self class name;		nextPut: $:;		nextPutAll: self source;		nextPut: $}.! !!HtmlToken methodsFor: 'private-initialization' stamp: 'ls 1/25/98 05:34'!initialize: s	"default initialization doesn't do much.  subclasses are free to override"	source _ s! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:47'!isComment	"whether this token is an HTML comment"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:38'!isTag	"is this an HTML tag"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:39'!isText	"return whether it is a string of text"	^false! !!HtmlToken methodsFor: 'access' stamp: 'ls 1/25/98 04:48'!source	"the raw source text that composes this token"	^source! !!HtmlToken class methodsFor: 'instance creation' stamp: 'ls 1/25/98 06:01'!forSource: source  	^super new initialize: source! !This class takes a text stream and produces a sequence of HTML tokens.It requires its source stream to support #peek.!!HtmlTokenizer methodsFor: 'private-initialization' stamp: 'ls 9/18/1998 08:06'!initialize: s	text _ s withSqueakLineEndings.	pos _ 1.	textAreaLevel _ 0.! !!HtmlTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/18/1998 08:08'!next 	"return the next HtmlToken, or nil if there are no more"	|token|	"branch, depending on what the first character is"	self atEnd ifTrue: [ ^nil ].	self peekChar = $< 		ifTrue: [ token _ self nextTagOrComment ]		ifFalse: [ token _ self nextText ].	"return the token, modulo modifications inside of textarea's"	textAreaLevel > 0 ifTrue: [		(token isTag and: [ token name = 'textarea' ]) ifTrue: [			"textarea tag--change textAreaLevel accordingly"			token isNegated				ifTrue: [ textAreaLevel _ textAreaLevel - 1 ]				ifFalse: [ textAreaLevel _ textAreaLevel -2 ].			textAreaLevel > 0				ifTrue: [ 					"still inside a <textarea>, so convert this tag to text"					^HtmlText forSource: token source ]				ifFalse: [ "end of the textarea; return the tag"  ^token ] ].			"end of the textarea"		"inside the text area--return the token as text"		^HtmlText forSource: token source ].	(token isTag and: [ token isNegated not and: [ token name = 'textarea' ]]) ifTrue: [		"beginning of a textarea"		inTextArea _ true.		^token ].			^token! !!HtmlTokenizer methodsFor: 'stream protocol' stamp: 'ls 8/20/1998 05:15'!atEnd	"are there any more tokens?  This is equivalent to whether there is any more input"	^(pos > text size)! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!nextChar	| c |	self atEnd ifTrue: [ ^nil ].	c _ text at: pos.	pos _ pos + 1.	^c! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!peekChar	self atEnd ifTrue: [ ^nil ].	^text at: pos! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:33'!nextAttributeValue	"return the next sequence of alphanumeric characters; used to read in the value part of a tag's attribute, ie <tagname  attribname=attribvalue>"	"because of the plethora of sloppy web pages, this is EXTREMELY tolerant"	| c start end |	"make sure there are at least two characters left"	pos >= text size ifTrue: [ ^self nextChar asString ].	"okay, peek at the first character"	start _ pos.	c _ text at: start.	"check whether it's either kind of quote mark"	(c = $" or: [ c = $' ]) ifTrue: [		"yes--so find the matching quote mark"		end _ text indexOf: c startingAt: start+1 ifAbsent: [ text size + 1 ].		pos _ end+1.		^text copyFrom: start to: end ].	"no--go until a space or a $> is seen"	end _ text indexOfAnyOf: CSAttributeEnders startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	pos _ end + 1.	^text copyFrom: start to: end.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextComment	"we've seen < and the next is a !!.  read until the whole comment is done"	"this isn't perfectly correct--for instance <!!--> is considered a proper comment--but it should do for now.  It also picks up <!!DOCTYPE...> tags"	| source c hyphens |		self nextChar.   "swallow the $!!"	source _ WriteStream on: String new.	source nextPutAll: '<!!'.		self peekChar = $- ifFalse: [ 		"this case is wierd.  go until we find a > at all and pray it's the correct end-of-'comment'"		[	self atEnd or: [ self peekChar = $> ] 		] whileFalse: [			c _ self nextChar.			source nextPut: c 		].		self atEnd ifFalse: [ source nextPut: self nextChar ].		^HtmlComment forSource: source contents ].		hyphens _ 0.	[ 	c _ self nextChar.		c = nil or: [			source nextPut: c.			(hyphens >=2 and: [ c = $> ])]	] whileFalse: [		c = $- ifTrue: [ hyphens _ hyphens + 1 ] ifFalse: [ hyphens _ 0 ]	].			^HtmlComment forSource: source contents.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:24'!nextName	"return the next sequence of alphanumeric characters"	"because of the plethora of sloppy web pages, this also accepts most non-space characters"	| start end |	start _ pos.	end _ text indexOfAnyOf: CSNameEnders startingAt: start ifAbsent: [ text size + 1].	end _ end - 1.	pos _ end+1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:23'!nextSpaces	"read in as many consecutive space characters as possible"	| start end |	"short cut for a common case"	self peekChar isSeparator not ifTrue: [ ^'' ].	"find the start and end of the sequence of spaces"	start _ pos.	end _ text indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	"update pos and return the sequence"	pos _ end + 1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:43'!nextTag	"we've seen a < and peek-ed something other than a !!.  Parse and return a tag"	| source negated name attribs attribName attribValue sourceStart sourceEnd c |		sourceStart _ pos-1.	attribs _ Dictionary new.	"determine if its negated"	self peekChar = $/ 		ifTrue: [ negated _ true.  self nextChar. ]		ifFalse: [ negated _ false ].	"read in the name"	self skipSpaces.	name _ self nextName.	name _ name asLowercase.	"read in any attributes"	[ 	self skipSpaces.		c _ self peekChar.		c = nil or: [c isLetter not ]	] whileFalse: [		attribName _ self nextName.		attribName _ attribName asLowercase.		self skipSpaces.		self peekChar = $= 			ifTrue: [ 				self nextChar.				self skipSpaces.				attribValue _ self nextAttributeValue withoutQuoting  ]			ifFalse: [ attribValue _ '' ].		attribs at: attribName  put: attribValue ].	self peekChar = $> ifTrue: [ self nextChar ].	sourceEnd _ pos-1.	source _ text copyFrom: sourceStart to: sourceEnd.	^HtmlTag source: source name: name asLowercase negated: negated attribs: attribs! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextTagOrComment	"next character is a $<.  So read either a tag or a token"	self nextChar.  "skip the $<"	^self peekChar = $!! 		ifTrue: [ self nextComment ]		ifFalse: [ self nextTag ]! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:34'!nextText	"returns the next textual segment"	|start end|	start _ pos.	end _ (text indexOf: $< startingAt: start ifAbsent: [ text size + 1 ]) - 1.	pos _ end+1.	^HtmlText forSource: (text copyFrom: start to: end)! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:26'!skipSpaces	"skip as many consecutive space characters as possible"	pos _ text indexOfAnyOf: CSNonSeparators startingAt: pos ifAbsent: [ text size + 1 ].! !!HtmlTokenizer class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 05:13'!on: aStream	^super basicNew initialize: aStream contents! !!HtmlTokenizer class methodsFor: 'initialization' stamp: 'ls 8/19/1998 09:09'!initialize	"HtmlTokenizer initialize"	CSAttributeEnders _ CharacterSet empty.	CSAttributeEnders addAll: Character separators.	CSAttributeEnders add: $>.		CSNameEnders _ CharacterSet empty.	CSNameEnders addAll: '=>'.	CSNameEnders addAll: Character separators.	CSNonSeparators _ CharacterSet separators complement.! !!HtmlUnderlineEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 01:41'!addToFormatter: formatter	formatter increaseUnderline.	super addToFormatter: formatter.		formatter decreaseUnderline.! !!HtmlUnorderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startUnorderedList.	super addToFormatter: formatter.	formatter endUnorderedList.! !!HtmlUnorderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ul'! !A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URLrealm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.Passwords = a Dictionary of (realm -> encoded user&password)!!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 23:08'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: Sensor cursorPoint - (50@0).	password _ FillInTheBlank request: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:25'!postFormArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self postFormArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self postFormArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:49'!privateInitializeFromText: aString relativeTo: aUrl	super privateInitializeFromText: aString relativeTo: aUrl.	realm _ aUrl realm.! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:47'!realm	^ realm! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContents	^ self retrieveContentsArgs: nil! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContentsArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpGetDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self retrieveContentsArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self retrieveContentsArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl class methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 23:13'!shutDown	"Forget all cached passwords, so they won't stay in the image"	Passwords _ nil.! !holds various info on a channel that the user is a member of.!!IRCChannelInfo methodsFor: 'messages' stamp: 'ls 9/5/1998 00:40'!sendMessage: aString	"send a message on the channel"	connection privmsgFrom: nil  to: name  text: aString! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:17'!addMember: memberName	"note that memberName is on the channel.  memberName should be given in the user's preferred capitalization"	members add: memberName.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!addMembers: list	members addAll: list.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 10:07'!changeTopic: aText	"attempt to change the topic"	connection sendMessage: (IRCProtocolMessage		command: 'TOPIC'		arguments: (Array with: self name with: aText asString)).	^true! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:44'!connection	"return the IRC connection I am watching"	^connection! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!memberNames	"names of the clients subscribing to this channel"	^members! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!name	"name of the channel, in its preferred capitalization"	^name! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:39'!removeMember: memberName	"note that memberName has left (PART-ed or QUIT-ed) the channel"	members remove: memberName ifAbsent: [ ^self ].	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:41'!subscribe: anObject	"add anObject as a subscriber.  anObject must respond to ircMessageRecieved"	subscribers isEmpty ifTrue: [ connection join: name ].	subscribers add: anObject! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!subscribers	"collection of objects watching for messages on the channel"	^subscribers! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:52'!topic	^topic ifNil: ['']! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:53'!topic: aString	topic _ aString.	self changed: #topic! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:39'!unsubscribe: anObject	"unsubscribe anObject"	subscribers remove: anObject.	subscribers isEmpty ifTrue: [ connection leave: name ].! !!IRCChannelInfo methodsFor: 'private-initialization' stamp: 'ls 9/6/1998 20:23'!initializeName: aString  connection: aConnection	name _ aString.	members _ Set new.	subscribers _ IdentitySet new.	connection _ aConnection! !!IRCChannelInfo methodsFor: 'interface' stamp: 'ls 9/17/1998 09:21'!openUserList	"open a listing with all the users on this channel"	^IRCChannelUsersBrowser openOnChannel: self! !!IRCChannelInfo class methodsFor: 'instance creation' stamp: 'ls 9/6/1998 20:22'!forChannelNamed: aString  onConnection: connection	"create an instance for the channel with the given name"	^super new initializeName: aString connection: connection! !a browser of the list of channels a given connection offers.  Allows users to easily join and create channels.!!IRCChannelListBrowser methodsFor: 'private-initialization' stamp: 'ls 9/17/1998 11:23'!initialize: anIRCConnection	connection _ anIRCConnection.	channelList _ #().	channelIndex _ 0.	sortCriterion _ #name.	anIRCConnection addDependent: self.	self refreshChannelList.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 10:45'!refreshChannelList	"update the list of channels"	| sortBlock |	channelList _ connection channelList.	"sort the channels"	sortCriterion = #name ifTrue: [		sortBlock _ [ :a :b | a name asIRCLowercase < b name asIRCLowercase ] ]	ifFalse: [		sortBlock _ [ :a :b |		a numUsers = b numUsers			ifTrue: [ a name asIRCLowercase < b name asIRCLowercase ]			ifFalse: [ a numUsers > b numUsers ] ] ].	channelList _ channelList asSortedCollection: sortBlock.	channelList _ channelList asArray.		channelIndex _ 0.	self changed: #channelDescriptions.	self changed: #channelIndex.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 07:00'!update: aSymbol	aSymbol == #channelList ifTrue: [		self refreshChannelList ].! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!createChannel	|  channelName |	channelName _ FillInTheBlank request: 'channel name'.	channelName isEmpty ifTrue: [ ^self ].	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 22:07'!openMorphicView	| win descListView updateButton actionColumn openChannelButton createChannelButton |	win _ SystemWindow new.	win setLabel: 'Channel Listing'.	win model: self.	descListView _ PluggableListMorph on: self  list: #channelDescriptions selected: #channelIndex changeSelected: #channelIndex:.	win addMorph: descListView  frame: (0@0 extent: 0.8@0.9).	updateButton _ PluggableButtonMorph on: connection getState: nil action: #requestChannelList.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	actionColumn _ AlignmentMorph newColumn.	openChannelButton _ PluggableButtonMorph on: self getState: nil action: #openSelectedChannel.	openChannelButton label: 'join channel'.	actionColumn addMorphBack: openChannelButton.	createChannelButton _ PluggableButtonMorph on: self getState: nil action: #createChannel.	createChannelButton label: 'create channel'.	actionColumn addMorphBack: createChannelButton.	win addMorph: actionColumn  frame: (0.8@0 extent: 0.2@0.9).	win openInWorld! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!openSelectedChannel	| channelInfo channelName |	channelInfo _ channelList at: channelIndex ifAbsent: [ ^self ].	channelName _ channelInfo name.	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 21:28'!openView	^self openMorphicView! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/17/1998 06:59'!channelDescriptions	^channelList collect: [ :channel |		channel name, '(', channel numUsers printString, ')    ', channel topic].! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:34'!channelIndex	^channelIndex! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:53'!channelIndex: anInteger	channelIndex _ anInteger.	self changed: #channelIndex! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:35'!forConnection: connection	^super new initialize: connection! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:36'!openForConnection: connection	(self forConnection: connection) openView! !converts IRC messages forwarded to it, into a textual format that may be displayed.  Messages may additionally sent *from* it, to a specified target.!!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 17:51'!chatAreaSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 19:59'!chatText	^chatText! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatTextSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:58'!connection: anIRCConnection channelName: aString	connection _ anIRCConnection.	channel _ connection channelInfo: aString.	channel subscribe: self.	chatText _ Text new.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 00:23'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	chatText _ chatText, newLine.	chatText size > 1000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 500) to: chatText size ].	self changed: #chatText.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 10:22'!openMorphicView	"open a view for interacting with this collector"	| win textArea inputArea topicArea usersButton |	win _ SystemWindow new.	win setLabel: channel name.	win model: self.	topicArea _ PluggableTextMorph on: channel  text: #topic  accept: #changeTopic:.	topicArea acceptOnCR: true.	win addMorph: topicArea frame: (0@0 extent: 0.9@0.1).	usersButton _ PluggableButtonMorph on: channel  getState: nil  action: #openUserList.	usersButton label: 'users'.	win addMorph: usersButton frame: (0.9@0 extent: 0.1@0.1).	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	win addMorph: textArea frame: (0@0.1 extent: 1@0.8).	inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.	inputArea acceptOnCR: true.	win addMorph: inputArea frame: (0@0.9 extent: 1@0.1) .	win openInWorld.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 20:59'!openView	"open a view for interacting with this collector"	^self openMorphicView! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!release	super release.	channel unsubscribe: self! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!sendMessage: aText	channel sendMessage: aText asString.	^true! !!IRCChannelObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 08:56'!openForChannelNamed: channelName  onConnection: connection 	^(super new connection: connection  channelName: channelName) openView! !very basic info on an IRC channel; specifically, that returned by a LIST command!!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:39'!name	"the name of the channel"	^name! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!numUsers	"number of users currently on the channel"	^numUsers! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!topic	"the current topic of discussion"	^topic! !!IRCChannelSummary methodsFor: 'printing' stamp: 'ls 9/2/1998 23:35'!printOn: aStream	aStream nextPutAll: 'IRCChannel '.	aStream nextPutAll: self name.	aStream nextPutAll: ' ('.	aStream nextPutAll: numUsers printString.	aStream nextPutAll: ')'.! !!IRCChannelSummary methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 22:38'!initializeName: aString  numUsers: anInteger  topic: anotherString	name _ aString.	numUsers _ anInteger.	topic _ anotherString.! !!IRCChannelSummary class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 22:39'!name: cname  numUsers: numUsers  topic: topic	^super new initializeName: cname  numUsers: numUsers  topic: topic! !Used for browsing the list of users on a particular channel.!!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!onChannel: aChannel	channel _ aChannel.	userList _ #().	userIndex _ 0.	channel addDependent: self.	self refreshUserList.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:47'!openAsMorph	| win listView talkToButton |	win _ SystemWindow labelled: 'users in ', channel name.	win model: self.	listView _ PluggableListMorph on: self list: #userList selected: #userIndex  changeSelected: #userIndex:.	win addMorph: listView  frame: (0@0 extent: 1@0.9).	talkToButton _ PluggableButtonMorph on: self getState: nil action: #talkTo.	talkToButton label: 'talk to selected user'.	win addMorph: talkToButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:18'!openView	^self openAsMorph! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:22'!refreshUserList	"update the user list from the channel"	|oldName |	(userIndex > 0) ifTrue: [		oldName _ userList at: userIndex ].	userList _ channel memberNames asSortedCollection asArray.	userIndex _ 0.	oldName ifNotNil: [		"try to select the same user again"		userIndex _ userList indexOf: oldName ].	self changed: #userList.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:42'!selectedUser	"return the name of the selected user, or nil if none"	^userList at: userIndex ifAbsent: [nil ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:43'!talkTo	"open a window for talking to the selected user"	| user |	user _ self selectedUser.	user ifNil: [ ^self ].	^IRCDirectMessagesObserver openForConnection: channel connection   talkingTo: user! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!update: aSymbol	aSymbol == #memberNames ifTrue: [ self refreshUserList ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userIndex	"return the index in userList of the user currently selected"	^userIndex! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:25'!userIndex: anInteger	"change which user is selected"	userIndex _ anInteger.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userList	"return the current list of user names"	^userList! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!onChannel: channel	^self new onChannel: channel! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!openOnChannel: channel	^(self onChannel: channel) openView! !A connection to an IRC server.  This handles spooling messages in and out, and converts between network commands and more convenient data structures.Start up an instance along with an interface with:		IRCConnection new openView!!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!portAsString: aString	port _ [ aString asString asNumber ] ifError: [ :a :b | ^false ].	DefaultPort _ port.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/6/1998 20:23'!channelInfo: channelName	"return cached info on a channel"	| lChannelName |	lChannelName _ channelName asIRCLowercase.	^subscribedChannels at: lChannelName ifAbsent: [ 		"no info available--create and return a skeleton"		subscribedChannels at: lChannelName put:			(IRCChannelInfo forChannelNamed: channelName  onConnection: self) ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:35'!channelList	"returns the list of channels, or nil if it hasn't been retrieved yet"	^channelList! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:53'!channelListReport	"list the channels in a textual format"	| list |	list _ self channelList.	list ifNil: [ ^'(info not available)' ].	^String streamContents: [ :stream |		stream nextPutAll: 'Channel List'; cr.		stream nextPutAll: '--------------'; cr.		list do: [ :channel |			stream nextPutAll: channel name.			stream nextPutAll: '('.			stream nextPutAll: channel numUsers printString.			stream nextPutAll: ')		['.			stream nextPutAll: channel topic.			stream nextPutAll: ']'.			stream cr ] ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:18'!motd	"return the most recently seen Message of the Day, or nil if none has been seen yet"	^motd! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 06:51'!initialize	self reset.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	directMessageSubscribers _ IdentitySet new.	protocolMessageSubscribers _ IdentitySet new.	consoleText _ Text new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 08:44'!reset	"prepare for a new connection"	recieveBuffer _ String new.	protocolMessagesToSend _ OrderedCollection new.	sendBuffer _ nil.	socket _ nil.	channelList _ nil.	channelListBeingBuilt _ nil.	motd _ nil.	motdBeingBuilt _ nil.	messagesProcessed _ 0.	subscribedChannels _ Dictionary new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/4/1998 23:22'!step	self processIO! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:38'!processChannelList: aMessage	"an item has arrived in the list of channels"	| chanName chanNumUsers chanTopic |	aMessage arguments size < 4 ifTrue: [ ^self ].	chanName _ aMessage arguments at: 2.	chanNumUsers _ (aMessage arguments at: 3) asNumber.	chanTopic _ (aMessage arguments at: 4).	chanName = '*' ifTrue: [ ^self ].	channelListBeingBuilt ifNil: [ channelListBeingBuilt _ OrderedCollection new ].	channelListBeingBuilt add: (IRCChannelSummary name: chanName numUsers: chanNumUsers topic: chanTopic). ! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:39'!processChannelListEnd: aMessage	"a complete channel listing has arrived"	"end of a channel listing"	channelList _ channelListBeingBuilt asArray.	channelListBeingBuilt _ nil.	self changed: #channelList. 	self changed: #channelListReport.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:37'!processChannelListStart: aMessage	"start of a channel listing"	channelListBeingBuilt _ OrderedCollection new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 09:33'!processJoin: aMessage	"a user is joining a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) addMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 08:48'!processMessage: aMessage	| handler |	protocolMessageSubscribers do: [ :subscriber |		subscriber ircProtocolMessage: aMessage ].	handler _ MessageHandlers at: aMessage command ifAbsent: [ nil ].	handler ifNil: [	^self ].	^self perform: handler  with: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotd: aMessage	"a new line has arrived for the MOTD"	motdBeingBuilt nextPutAll: aMessage arguments second.	motdBeingBuilt cr.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotdEnd: aMessage	"the whole MOTD has arrived"	motd _ motdBeingBuilt contents.	motdBeingBuilt _ nil.	self changed: #motd.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:35'!processMotdStart: aMessage	"MOTD is being transmitted"	motdBeingBuilt _ WriteStream on: String new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:19'!processNamReply: aMessage	"list of names for a channel, probably a channel being joined"	| names lChannelName channelInfo |	names _ aMessage arguments last findTokens: ' '.	names _ names collect: [ :origName |		('+@' includes: origName first) 			ifTrue: [ origName copyFrom: 2 to: origName size ]			ifFalse: [ origName ] ].	lChannelName _ (aMessage arguments at: 3) asIRCLowercase.	channelInfo _ subscribedChannels at: lChannelName ifAbsent: [nil].	channelInfo ifNotNil: [ channelInfo addMembers: names ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:07'!processNoTopic: aMessage	"remove a channel's topic"	(self channelInfo: (aMessage arguments at: 2)) topic: ''! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 09:33'!processPach: aMessage	"a user is leaving a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) removeMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPart: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPing: aMessage	"ping request"	self sendMessage: (IRCProtocolMessage command: 'pong' arguments: aMessage arguments).! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPrivmsg: aMessage	"handle a PRIVMSG or NOTICE message"	| sender recipient text privMessage info |	"put together the message"	sender _ aMessage prefix.	recipient _ aMessage arguments at: 1.	text _ aMessage arguments at: 2.	privMessage _ IRCMessage sender: sender  recipient: recipient  text: text.	"broadcast the message to all subscribers"	info _ subscribedChannels at: recipient asIRCLowercase ifAbsent: [ nil ].	info ifNotNil: [ info subscribers do: [ :sub |		sub ircMessageRecieved: privMessage ] ].	recipient asIRCLowercase = nick asIRCLowercase ifTrue: [		directMessageSubscribers do: [ :sub |			sub ircMessageRecieved: privMessage ] ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:14'!processTopic: aMessage	"change a channel topic"	| args |	args _ aMessage arguments.	args size < 2 ifTrue: [ "malformed message" ^self ].	(self channelInfo: (args at: (args size-1))) topic: (args at: args size).! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:18'!consoleMenu: menu	^menu		labels: 'connect\disconnect\message of the day\channel list\talk to individual\inspect me' withCRs		lines: #(2 4 5)		selections: #(openConnectionDialogue disconnect openMotd openChannelList talkTo inspect)! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:17'!talkTo	"talk to some user using 1-to-1 chat messages"	| user |	user _ FillInTheBlank request: 'user to talk to'.	user _ user withBlanksTrimmed.	user isEmpty ifTrue: [ ^self ].	IRCDirectMessagesObserver openForConnection: self  talkingTo: user! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:42'!addToConsole: aText	"add aString to the text being displayed on console."	consoleText _ consoleText, aText.	consoleText size > 2000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 1000) to: consoleText size ].	self changed: #consoleText.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:41'!consoleText	^consoleText! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:43'!consoleTextSelection	| size |	size _ self consoleText size.	^size+1 to: size! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:55'!openAsMorph	| win consolePane inputPane |	"build views"	win _ SystemWindow labelled: 'IRC'.	win model: self.	consolePane _ PluggableTextMorph on: self text: #consoleText accept: nil readSelection: #consoleTextSelection menu: #consoleMenu:.	win addMorph: consolePane frame: (0@0 extent: 1@0.9).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendRawCommand:.	inputPane acceptOnCR: true.	win addMorph: inputPane  frame: (0@0.9 extent: 1@0.1).	"subscribe to protocol messages and direct messages, so we can display them on console"	self subscribeToDirectMessages: self.	self subscribeToProtocolMessages: self.	win openInWorld! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:32'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:58'!openConnectionDialogue	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph textEntryList |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	textEntryList _ OrderedCollection new.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		textEntry acceptOnCR: true.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		textEntryList add: textEntry.		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: [			textEntryList do: [ :m | m hasUnacceptedEdits ifTrue:[ m accept ] ].			self connect 		] getState: nil action: #value.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 01:12'!openDirectMessagesObserver	IRCDirectMessagesObserver openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openMotd	"open a view on the MOTD"	| win textView updateButton |	win _ SystemWindow labelled: 'MOTD'.	textView _ PluggableTextMorph on: self text: #motd accept: nil.	win addMorph: textView  frame: (0@0 extent: 1@0.9).	updateButton _ PluggableButtonMorph on: self getState: nil action: #requestMotd.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openView	^self openAsMorph! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:45'!perform: aSelector  orSendTo: editor	(self respondsTo: aSelector) ifTrue: [		^self perform: aSelector ].	^editor perform: aSelector! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:36'!release	super release.	self disconnect.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:46'!sendRawCommand: aString	"send a command directly"	| message |	message _ [ IRCProtocolMessage fromString: aString asString ] ifError: [ :a :b |		^false ].	self sendMessage: message.	^true! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/6/1998 20:21'!subscribe: anObject toChannel: channelName	"send all messages for channelName to anObject.  anObject must implemented #ircMessageReceieved:"	|  info |	info _ self channelInfo: channelName.	info subscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 18:06'!subscribeToDirectMessages: anObject	"send all messages directly to the user's nick to anObject.  anObject must implemented #ircMessageReceieved:"	directMessageSubscribers add: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/15/1998 06:30'!subscribeToProtocolMessages: anObject	"anObject should respond to #ircProtocolMessage:.  It will be sent all incoming messages"	protocolMessageSubscribers add: anObject! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:38'!unsubscribe: anObject fromChannel: channelName	"see subscribe:toChannel:"	|  lChannelName info |	lChannelName _ channelName asIRCLowercase.	info _ subscribedChannels at: lChannelName ifAbsent: [ ^self ].	info unsubscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:10'!unsubscribeFromDirectMessages: anObject 	"see #subscribeFromDirectMessages:"	directMessageSubscribers remove: anObject ifAbsent: []! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!join: channelName	"join a channel"	self sendMessage: (IRCProtocolMessage		command: 'join'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!leave: channelName	"leave a channel"	self sendMessage: (IRCProtocolMessage		command: 'part'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/12/1998 04:54'!privmsgFrom: from  to: to  text: text	"send a private message.  'to' can be a channel name...."	| msg |	msg _ (IRCProtocolMessage		prefix: from		command: 'privmsg'		arguments: (Array with: to  with: text)).	self processMessage: msg.	"because these aren't sent back by default"	self sendMessage: msg.! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!quit	"tell the server we are leaving"	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:36'!requestChannelList	"request a list of all channels"	self sendMessage: (IRCProtocolMessage command: 'list')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:18'!requestMotd	self sendMessage: (IRCProtocolMessage command: 'motd')! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 23:30'!connect	"connect to a server"	| addr |	Socket initializeNetwork.	socket ifNotNil: [ socket destroy ].	self reset.	Utilities informUser: 'looking up server address...' during: [		addr _ NetNameResolver addressForName: server ].	addr ifNil: [ ^PopUpMenu notify: 'could not find address for ', server ].	socket _ Socket new.	socket connectTo: addr  port: port.	self sendMessage: (IRCProtocolMessage fromString: 'NICK ', nick).	self sendMessage: (IRCProtocolMessage fromString: 'USER ', userName, ' * * :', fullName).! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 21:27'!disconnect		"disconnect from the server"	socket ifNotNil: [ socket isValid ifTrue: [ 		Transcript show: 'disconnecting from IRC', String cr.		socket close ] ].		socket _ nil.! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 17:45'!isConnected	"whether we are currently connected"	^socket ~~ nil  and: [ socket isConnected ]! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/3/1998 00:19'!processIO	"do as much network IO as is immediately possible"		| amount idx messageText message |	"do nothing if the socket isn't ready for work"	(socket isNil or: [socket isValid not or: [ socket isConnected not ]]) ifTrue: [ 		"Transcript show: 'socket not ready; no IO done'; cr."		^self ].	"first do sending"	[ socket sendDone and: [ sendBuffer isNil not or: [ protocolMessagesToSend size > 0 ] ] ]	whileTrue: [		sendBuffer ifNil: [			protocolMessagesToSend isEmpty ifFalse: [				sendBuffer _ protocolMessagesToSend removeFirst asString ] ].		sendBuffer ifNotNil: [			amount _ socket sendSomeData: sendBuffer.			sendBuffer _ sendBuffer copyFrom: amount+1 to: sendBuffer size.			sendBuffer isEmpty ifTrue: [ sendBuffer _ nil ] ].	].	"now do receiving"	[ socket dataAvailable ] whileTrue: [ 		recieveBuffer _ recieveBuffer, socket getData ].	"parse as many messages as possible"	[ idx _ recieveBuffer indexOf: Character lf.  	  idx > 0 ] whileTrue: [		messageText _ recieveBuffer copyFrom: 1 to: idx.		message _ IRCProtocolMessage fromString: messageText.				self processMessage: message.		recieveBuffer _ recieveBuffer copyFrom: idx+1 to: recieveBuffer size ].! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 21:53'!sendMessage: aMessage	"queue a message for sending"	protocolMessagesToSend addLast: aMessage.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:49'!ircMessageRecieved: aMessage	| sender newLine |	Smalltalk beep.	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToConsole: newLine.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:47'!ircProtocolMessage: msg	"a new message.  log it on the console, unless it's a channel listing"	(msg command ~= IRCConnection RPLList printString	and: [ msg command ~= IRCConnection RPLMotd ]) ifTrue: [		self addToConsole: msg asString ].! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLAway	"someone has marked themselves as away"	^301! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLBanList	""	^367! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLChannelModeIs	""	^324! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLEndOfBanList	""	^368! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfLinks	""	^365! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:10'!RPLEndOfMotd	"the MOTD has been completely transmitted"	^376! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfNames	""	^366! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLEndOfWho	"end of responses to a WHO"	^315! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLEndOfWhoIs	""	^318! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLEndOfWhoWas	""	^369! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLInviting	"inform that you are inviting someone to a channel"	^341! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLLinks	""	^364! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLList	"one item in a list command"	^322! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListEnd	"marks end of listing from a LIST command"	^323! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListStart	"start of response to a LIST command"	^321! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:45'!RPLMotd	"a line from the MOTD"	^372! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/3/1998 18:17'!RPLMotd2	"secondd version of a line from the MOTD"	^377! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLMotdStart	"a MOTD listing is beginning"	^375! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLNamReply	""	^353! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLNoTopic	"no topic is set for the given channel"	^331! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLNowaway	"something to do with AWAY"	^306! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLSummoning	"inform that you are summoning a user"	^342! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLTopic	"topic for the given channel"	^332! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLUnaway	"someone has marked themselves as unaway"	^305! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLVersion	"version info for the server"	^351! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoIsIdle	""	^317! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsOperator	""	^313! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsServer	""	^312! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsUser	""	^311! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLWhoReply	"response to a WHO"	^352! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLWhoWasUser	""	^314! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoisChannels	""	^319! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 10:10'!initialize	"IRCConnection initialize"	self initializeMessageHandlers.	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 10:11'!initializeMessageHandlers	"initilize the table mapping IRC commands to processing methods"	"IRCConnection initializeMessageHandlers"	MessageHandlers _ Dictionary new.	#(		372		processMotd:		377		processMotd:		375		processMotdStart:		376		processMotdEnd:		ping	processPing:		join		processJoin:		part	processPart:		privmsg		processPrivmsg:		notice		processPrivmsg:		321		processChannelListStart:		322		processChannelList:		323		processChannelListEnd:		331		processNoTopic:		332		processTopic:		topic	processTopic:		353		processNamReply:	) pairsDo: [ :command  :method |		MessageHandlers at: command asString put: method ].! !!IRCConnection class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:31'!new	^super new initialize! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!addToChatText: aString	chatText _ chatText, aString.	chatText size > 1000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 500) to: chatText size ].	self changed: #chatText.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatAreaSelection 	^self chatTextSelection! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:52'!chatText	^chatText! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!chatTextSelection	^chatText size+1 to: chatText size! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:01'!initialize: aConnection	connection _ aConnection.	chatText _ Text new.	connection subscribeToDirectMessages: self.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	talkingTo ifNotNil: [		"only display messages to or from talkingTo"		sender asIRCLowercase = talkingTo asIRCLowercase ifFalse: [^self ] ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToChatText: newLine.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:15'!openMorphicView	"open a view for messages sent here"	| win textArea inputArea |	win _ SystemWindow new.	win setLabel: (talkingTo ifNotNil: [ talkingTo ] ifNil: [ 'private messages' ]).	win model: self.	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	talkingTo		ifNil: [ win addMorph: textArea frame: (0@0 extent: 1@1) ]		ifNotNil: [			win addMorph: textArea  frame: (0@0 extent: 1@0.9).			inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.			inputArea acceptOnCR: true.			win addMorph: inputArea  frame: (0@0.9 extent: 1@0.1) ].	win openInWorld.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:53'!openView	^self openMorphicView! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/8/1998 04:55'!release	connection unsubscribeFromDirectMessages: self.	super release.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:09'!sendMessage: aString	"send a message to the user we are talking to"	| newLine |	talkingTo ifNil: [ Smalltalk beep.  ^self ].	connection privmsgFrom: nil  to: talkingTo  text: aString.	newLine _ (Text string: 'me' attribute: TextEmphasis bold),		': ', aString, String cr.	self addToChatText: newLine.	^true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:38'!talkingTo: aName	"set who this window is for talking to"	talkingTo _ aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!forConnection: aConnection	^super new initialize: aConnection! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!forConnection: aConnection  talkingTo: aName	^(super new initialize: aConnection) talkingTo: aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!openForConnection: aConnection	^(self forConnection: aConnection) openView! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!openForConnection: aConnection  talkingTo: aName	^(self forConnection: aConnection talkingTo: aName) openView! !A message on IRC.  It has a sender (usually a username), a recipient (usually a user or channel name), and some text.!!IRCMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:14'!initializeSender: sender0  recipient: recipient0  text: text0	sender _ sender0.	recipient _ recipient0.	text _ text0.! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!recipient	"name the message is destined to"	^recipient! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!sender	"name of the message's sender"	^sender! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!text	"message text"	^text! !!IRCMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 17:15'!sender: sender  recipient: recipient  text: text	"create a new message with the given sender, recipient, and text"	^super new initializeSender: sender  recipient: recipient text: text! !A pattern for matching IRC messages.  Currently one can only match on the sender or the reciever.!!IRCMessagePattern methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:41'!sender: sender0  recipient: recipient0	sender _ sender0.	recipient _ recipient0.! !!IRCMessagePattern methodsFor: 'filtering' stamp: 'ls 9/2/1998 17:42'!matches: aMessage	"decide whether the message matches this pattern"	sender ifNotNil: [ sender = aMessage sender ifFalse: [ ^false ] ].	recipient ifNotNil: [ recipient = aMessage recipient ifFalse: [ ^false ] ].	^true! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!recipient: recipient	"create a pattern matching messages to the given recipient"	^self sender: nil  recipient: recipient! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:10'!sender: sender	"create a pattern for messages from the given sender"	^self sender: sender  recipient: nil! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!sender: sender  recipient: recipient	"create a pattern matching messages from the given sender and to the given recipient"	^super new sender: sender  recipient: recipient! !holds some subset of the messages coming in from an IRC connection.  subclasses define specific criteria for filtering the messages.!!IRCMessageSet methodsFor: 'as yet unclassified' stamp: 'ls 8/21/1998 10:39'!acceptMessage: ircMessage	"whether the given message should be accepted by this set"	^self subclassResponsibility! !A Morph for interfacing with IRC.!!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!addToConsole: aText	consoleText _ consoleText, aText.	consoleText size > 1000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 500) to: consoleText size ].	self changed: #consoleText.! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!consoleSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:17'!consoleTextSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!step	connection processIO.! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:17'!stepTime	^0! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!wantsSteps	^true! !!IRCMorph methodsFor: 'initialization' stamp: 'ls 9/4/1998 23:13'!initialize 	|  connectButton column channelListButton motdButton consoleView inputPane |	super initialize.	connection _ IRCConnection new.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	self setLabel: 'IRC'.	self extent: 200@100.	column _ AlignmentMorph newColumn.	connectButton _ PluggableButtonMorph		on: self		getState: nil		action: #openConnection.	connectButton label: 'connect to server'.	column addMorphBack: connectButton.	motdButton _ PluggableButtonMorph		on: self		getState: nil		action: #openMotd.	motdButton label: 'view MOTD'.	column addMorphBack: motdButton.	channelListButton _ PluggableButtonMorph		on: self		getState: nil		action: #openChannelList.	channelListButton label: 'channel list'.	column addMorphBack: channelListButton.	self addMorph: column frame: (0@0 extent: 0.4@0.8).	consoleText _ Text new.	consoleView _ PluggableTextMorph on: self  text: #consoleText accept: nil readSelection: #consoleTextSelection menu: nil.	self addMorph: consoleView frame: (0.4@0 extent: 0.6@0.8).	consoleView color: (Color r: 0.937 g: 0.937 b: 0.937).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendCommand:.	self addMorph: inputPane frame: (0@0.8 corner: 1@1).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:29'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu  hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'connect to server' action: #makeConnection.	aCustomMenu addLine.	aCustomMenu add: 'view MOTD' action: #openMotd.	aCustomMenu add: 'view channel list' action: #openChannelList.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:12'!connect	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection subscribeToDirectMessages: self.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 18:10'!delete	super delete.	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 22:11'!ircMessageRecieved: aMessage	| sender |	sender _ aMessage sender ifNil: [ nick ].	self addToConsole: (		sender asText,		': ',		aMessage text,		String cr).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:57'!makeConnection	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection requestChannelList.    "this is usually necessary, so go ahead and ask for it"! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 23:11'!openChannel: name	"open a window for interacting with the given channel"	IRCChannelObserver openForChannel: name  onConnection: connection ! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:35'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: connection! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 17:57'!openConnection	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: self getState: nil action: #connect.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:44'!openMotd	connection openMotd! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/8/1998 04:55'!release	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.	super release.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 00:23'!sendCommand: aString	| message |	[ message _ IRCProtocolMessage fromString: aString asString ] ifError: [ ^false ].	connection sendMessage: message.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/4/1998 18:49'!consoleText	^consoleText! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!portAsString: aString	port _ [ aString asString asNumber ] ifError: [ :a :b | ^false ].	DefaultPort _ port.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCMorph class methodsFor: 'misc' stamp: 'ls 9/4/1998 18:53'!hasPrototype	"it's not needed here...."	^false! !!IRCMorph class methodsFor: 'initialization' stamp: 'ls 9/3/1998 20:42'!initialize 	"set all the defaults to something reasonable"	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !A low-level IRC message; this is an internal format for what actually goes over the wire.!!IRCProtocolMessage methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:57'!quit	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!arguments	"return the arguments to the command"	^arguments! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:48'!command	"return the main command, in lowercase"	^command! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!prefix	"return the prefix of the message, or nil if none"	^prefix! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 21:49'!prefix: aString  command: anotherString  arguments: aCollection	prefix _ aString.	command _ anotherString asLowercase.	arguments _ aCollection.! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'ls 9/2/1998 21:49'!asString	"encode in the format used for transferral over the network"	^String streamContents: [ :stream |		prefix ifNotNil: [			stream nextPut: $:.			stream nextPutAll: prefix.			stream space ].		stream nextPutAll: command asUppercase.		stream space.		arguments isEmpty ifFalse: [			"print out all but the last argument"			(arguments copyFrom: 1 to: (arguments size - 1)) do: [ :arg |				stream nextPutAll: arg.				stream space ].						"print the last as a trailer, just to be safe"			stream nextPut: $:.			stream nextPutAll: arguments last. ].		stream nextPut: Character cr.		stream nextPut: Character lf. ]! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString	^self command: anotherString  arguments: Array new! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString  arguments: aCollection	^self prefix: nil  command: anotherString  arguments: aCollection! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:47'!fromString: aString	"parse an IRC message from its network format"	| remainder trailerStart trailer tokens command  arguments prefix idx |	remainder _ aString.	"strip the CRLF"	idx _ remainder indexOf: Character cr.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	idx _ remainder indexOf: Character lf.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	"check if there is a trailer"	trailerStart _ remainder indexOf: $: startingAt: 2 ifAbsent: [0].	trailerStart > 0 ifTrue: [		trailer _ remainder copyFrom: trailerStart+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: trailerStart-1 ].	"divide the rest of the string up between spaces"	tokens _ remainder findTokens: ' '.	"the command is the first token..."	command _ tokens removeFirst.	command first = $: ifTrue: [		"...unless it starts with a $:, in which case there is a prefix and the command is the second token"		prefix _ command copyFrom: 2 to: command size.  "copy without the leading :"		command _ tokens removeFirst ].	"the arguments are the remaining tokens, plus the trailer if any"	arguments _ tokens.	trailer ifNotNil: [ arguments _ arguments copyWith: trailer ].	^self prefix: prefix  command: command  arguments: arguments.! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:34'!prefix: aString  command: anotherString  arguments: aCollection	^super new prefix: aString  command: anotherString  arguments: aCollection! !a filter for messages  sent to a particular user!!ImageMorph methodsFor: 'menu commands' stamp: 'di 9/15/1998 09:58'!readFromFile	| fileName |	fileName _ FillInTheBlank		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image ona stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for imagestoragesClass Variables:	ImageNotStoredSignal		<Signal>	image not storederror signal	MagicNumberErrorSignal		<Signal>	magic number errorsignalSubclasses must implement the following messages:	accessing		nextImage		nextPutImage:	testing		canUnderstand         (added tao 10/26/97)!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access'!close	"close if you can"	(stream respondsTo: #close) ifTrue: [			stream closed ifFalse: [stream close]]! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextLongPut: a32BitW	"Write out a 32-bit integer as 32 bits."	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a32BitW bitAnd: 16rFF).	^a32BitW! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private'!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).	newBits _ ByteArray new: dstRowByteSize * height.	srcRowBase _ 1.	rowEndOffset _ dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase _ srcRowBase + srcRowByteSize].	^newBits! !!ImageReadWriter methodsFor: 'private'!hasMagicNumber: aByteArray	| position |	position _ stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!ImageReadWriter methodsFor: 'private' stamp: 'di 9/15/1998 11:42'!on: aStream	(stream _ aStream) reset.	(stream respondsTo: #binary) ifTrue: [stream binary].	"Note that 'reset' makes a file be text.  Must do this after."! !!ImageReadWriter methodsFor: 'private'!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask _ (1 bitShift: depth) - 1.	pixelInByte _ 8 / depth.	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).	stopWidth _ width * depth + 7 // 8.	trailingSize _ width - (stopWidth - 1 * pixelInByte).	upBits _ ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex _ i - 1 * bitsWidth.		upBitIndex _ i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val _ bits at: (bitIndex _ bitIndex + 1).			upBitIndex _ upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val _ val bitShift: depth negated]].		val _ (bits at: (bitIndex _ bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex _ upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val _ val bitShift: depth negated]].	^ upBits! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream _ FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:10'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | aBinaryStream reset. (subclass new on: aBinaryStream) understandsImageFormat]		ifNone: [			(aBinaryStream respondsTo: #close) ifTrue: [ aBinaryStream close ].			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !I represent an index for the messages in a mail database. I acts like a dictionary that maps unique message ID's to IndexFileEntry objects.The index file is read into memory in its entirety and kept there for the duration of a mail reading session. It should be stored back to disk at the end of the session, or after a major change, such as fetching new mail. If necessary, it can be completely recreated by scanning the messages file.!!IndexFile methodsFor: 'file operations'!openOn: aFileName messageFile: messageFile	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream messageFile: messageFile.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!IndexFile methodsFor: 'dictionary access'!at: msgID	"Answer the IndexFileEntry for the message with the given ID."	^msgDictionary at: msgID ifAbsent: [self reportInconsistency]! !!IndexFile methodsFor: 'dictionary access'!at: msgID ifAbsent: aBlock	"Answer the IndexFileEntry for the message with the given ID. Evaluate the given block if there is no entry for the given ID."	^msgDictionary at: msgID ifAbsent: aBlock! !!IndexFile methodsFor: 'dictionary access'!at: msgID put: anIndexFileEntry	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat:		[: assoc | assoc key = msgID].	"don't duplicate the entry!!"	msgDictionary at: msgID put: anIndexFileEntry.	timeSortedEntries add: (Association key: msgID value: anIndexFileEntry).! !!IndexFile methodsFor: 'dictionary access'!includesKey: msgID	"Answer true if my message dictionary contains an entry for the message with the given ID."	^msgDictionary includesKey: msgID! !!IndexFile methodsFor: 'dictionary access'!keys	"Answer a collection of message IDs for the messages in this IndexFile, sorted in ascending timestamp order. Because sorting is expensive, the sorted key list is cached."	| keys |	keys _ OrderedCollection new: timeSortedEntries size * 2.	timeSortedEntries do: [: assoc | keys addLast: assoc key].	^keys! !!IndexFile methodsFor: 'dictionary access'!remove: msgID	"Remove the entry with the given ID from my Dictionary."	timeSortedEntries removeAllSuchThat: [: assoc | assoc key = msgID].	msgDictionary removeKey: msgID ifAbsent: [].! !!IndexFile methodsFor: 'read-write'!readFrom: aStream messageFile: messageFile	"Initialize myself from the given text stream. It is assumed that the .index file was written in order of ascending message timestamps, although this method is only less efficient, not incorrect, if this is not the case."	| sorted lastTime msgID entry |	msgDictionary _ Dictionary new: 1000.	timeSortedEntries _ (SortedCollection new: 1000) sortBlock:		[: m1 : m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd] whileFalse:		[msgID _ MailDB readIntegerLineFrom: aStream.		 entry _ IndexFileEntry readFrom: aStream messageFile: messageFile msgID: msgID.		 msgDictionary at: msgID put: entry.		 timeSortedEntries addLast: (Association key: msgID value: entry).		 ((sorted & lastTime notNil) and: [lastTime > entry time]) ifTrue:			[sorted _ false].		 lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]. 	"re-sort if necessary"! !!IndexFile methodsFor: 'read-write'!writeOn: aStream	"Write my index entries to the given text stream in human-readable form."	"Note: For efficiency, this is done in order of increasing message timestamps, to save the cost of sorting when we read it back in. It is assumed that timeSortedEntries should contains exactly the same message ID's as msgDictionary."	timeSortedEntries do:		[: assoc |		 (assoc key) printOn: aStream.		"message ID"		 aStream cr.		 (assoc value) writeOn: aStream].	"index entry"! !!IndexFile class methodsFor: 'instance creation'!openOn: fileName messageFile: messageFile	"Answer a new instance of me for the given message file, backed by the file with the given name."	^(super new) openOn: fileName messageFile: messageFile! !An IndexFileEntry contains enough information to present a table-of-contents entry for the message and to support simple filtering based on a subset of the mail header information. The IndexFile maps unique message ID's to IndexFileEntries.!!IndexFileEntry methodsFor: 'access'!cc	^cc! !!IndexFileEntry methodsFor: 'access'!cc: aString	cc _ aString.! !!IndexFileEntry methodsFor: 'access'!date	"Answer a date string for this index entry."	^Date fromDays: (time + (Date newDay: 1 year: 1980) asSeconds) // 86400! !!IndexFileEntry methodsFor: 'access'!from	^from! !!IndexFileEntry methodsFor: 'access'!from: aString	from _ aString.! !!IndexFileEntry methodsFor: 'access'!location	^location! !!IndexFileEntry methodsFor: 'access'!location: anInteger	location _ anInteger.! !!IndexFileEntry methodsFor: 'access'!messageFile	^messageFile! !!IndexFileEntry methodsFor: 'access'!messageFile: aMessageFile	messageFile _ aMessageFile.! !!IndexFileEntry methodsFor: 'access'!msgID	^msgID! !!IndexFileEntry methodsFor: 'access'!msgID: anID	msgID _ anID.! !!IndexFileEntry methodsFor: 'access'!subject	^subject! !!IndexFileEntry methodsFor: 'access'!subject: aString	subject _ aString.! !!IndexFileEntry methodsFor: 'access'!textLength	^textLength! !!IndexFileEntry methodsFor: 'access'!textLength: anInteger	textLength _ anInteger.! !!IndexFileEntry methodsFor: 'access'!time	^time! !!IndexFileEntry methodsFor: 'access'!time: anInteger	time _ anInteger.! !!IndexFileEntry methodsFor: 'access'!to	^to! !!IndexFileEntry methodsFor: 'access'!to: aString	to _ aString.! !!IndexFileEntry methodsFor: 'printing' stamp: 'jm 9/21/1998 10:55'!computeTOCString	"Answer a string for the table of contents."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	| fromFieldSize s |	fromFieldSize _ 18.	s _ WriteStream on: (String new: 200).	s nextPutAll: self dateString.	[s position < 9] whileTrue: [s space].	s nextPutAll: (self fromStringLimit: fromFieldSize).	[s position <= (9 + fromFieldSize + 2)] whileTrue: [s space].	s nextPutAll: subject.	^ s contents! !!IndexFileEntry methodsFor: 'printing'!dateString	"Answer a date string for this index entry."	^self date printFormat: #(2 1 3 47 1 2)! !!IndexFileEntry methodsFor: 'printing'!flushTOCCache	"Flush my cached table-of-contents entry string."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	tocLineCache _ nil.! !!IndexFileEntry methodsFor: 'printing' stamp: 'ls 9/10/1998 21:15'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from.	s skipSeparators.	('"<' includes: s peek) ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		(('@<>)$"' includes: ch) or: [editedFrom position >= limit])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!IndexFileEntry methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self dateString; cr.	aStream nextPutAll: from; cr.	aStream nextPutAll: to; cr.	aStream nextPutAll: cc; cr.	aStream nextPutAll: subject; cr.	aStream nextPut: $(; nextPutAll: location printString; space.	aStream nextPutAll: textLength printString; nextPut: $).	aStream cr.! !!IndexFileEntry methodsFor: 'printing'!tocString	"Answer a string for the table of contents."	(tocLineCache isNil) ifTrue:		[tocLineCache _ self computeTOCString].	^tocLineCache! !!IndexFileEntry methodsFor: 'read-write'!readFrom: aStream	"Initialize myself from the given text stream."	location _ MailDB readIntegerLineFrom: aStream.	textLength _ MailDB readIntegerLineFrom: aStream.	time _ MailDB readIntegerLineFrom: aStream.	from _ MailDB readStringLineFrom: aStream.	to _ MailDB readStringLineFrom: aStream.	cc _ MailDB readStringLineFrom: aStream.	subject _ MailDB readStringLineFrom: aStream.! !!IndexFileEntry methodsFor: 'read-write'!writeOn: aStream	"Write a human-readable representation of myself on the given text stream."	aStream		print: location; cr;		print: textLength; cr;		print: time; cr;		nextPutAll: from; cr;		nextPutAll: to; cr;		nextPutAll: cc; cr;		nextPutAll: subject; cr.! !!IndexFileEntry methodsFor: 'filtering support'!ccHas: stringOrList	^ self field: cc has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 8/14/1998 13:39'!field: field has: stringOrList	"Return true if either the given field contains the argument string or, if the argument is a collection, return true if the given field contains any of the strings in that collection."	| s |	(stringOrList isKindOf: String) ifTrue: [		^ field includesSubstring: stringOrList caseSensitive: false	] ifFalse: [		1 to: stringOrList size do: [ :i |			s _ stringOrList at: i.			s isNumber ifTrue: [s _ s printString].			(field includesSubstring: s caseSensitive: false) ifTrue: [^ true].		].		^ false	].! !!IndexFileEntry methodsFor: 'filtering support'!fromHas: stringOrList	^ self field: from has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!getMessage	"Answer the MailMessage for this index file entry."	^MailMessage from:		(messageFile			getMessage: msgID			at: location			textLength: textLength).! !!IndexFileEntry methodsFor: 'filtering support'!participantHas: stringOrList	^ (self field: from has: stringOrList) or:	   [(self field: self to has: stringOrList) or:	   [self field: self cc has: stringOrList]]! !!IndexFileEntry methodsFor: 'filtering support'!subjectHas: stringOrList	^ self field: subject has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!textHas: stringOrList	^ self field: self getMessage has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!toHas: stringOrList	^ self field: to has: stringOrList! !!IndexFileEntry class methodsFor: 'instance creation'!message: aMailMessage location: location messageFile: aMessageFile msgID: msgID	"Answer a new instance of me for the given message and message file location."	^self new		messageFile: aMessageFile;		msgID: msgID;		location: location;		textLength: aMailMessage text size;		time: aMailMessage time;		from: aMailMessage from;		to: aMailMessage to;		cc: aMailMessage cc;		subject: aMailMessage subject! !!IndexFileEntry class methodsFor: 'instance creation'!readFrom: aStream messageFile: aMessageFile msgID: msgID	"Answer a new instance of me initialized from the given text stream."	^(self new readFrom: aStream)		messageFile: aMessageFile;		msgID: msgID! !Used in conjunction wi[th a TabbedPalette -- each TabbedPalette has one.  Each submorph of an IndexTabs is a TabMorph.  When you click on one of the tabs, a corresponding action is taken -- sometimes, the existing palette gets replaced by the new one, other times, the tab results in some selector being invoked; in any case, tab highlighting takes place accordingly.!!IndexTabs methodsFor: 'initialization' stamp: 'sw 7/3/1998 16:10'!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addActionTabWithTitle: aString	|  aTab |	aTab _ TabMorph new.	aTab contents: aString.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 11:44'!addTab: aTab	self addMorphBack: aTab.	self laySubpartsOutInOneRow! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addTabForBook: aBook	|  aTab |	aTab _ TabMorph new morphToInstall: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 12:42'!tabMorphs	"Presently all the submorphs are tabMorphs, but this still supports an earlier design where spacers are interleaved."	^ submorphs select: [:m | m isKindOf: TabMorph]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!basicHeight	^ basicHeight! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) "max: owner pageSize x") @ self basicHeight)! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/21/1998 22:05'!openToDragNDrop	^ false! !!IndexTabs methodsFor: 'selection' stamp: 'sw 7/3/1998 18:43'!selectTab: aTab	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTab: aTab.! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:56'!highlightColor	^ highlightColor ifNil: [Color yellow]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!highlightColor: aColor	highlightColor _ aColor! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:43'!highlightColor: color1 regularColor: color2	"Apply these colors to all of the receiver's tabs"	highlightColor _ color1.	regularColor _ color2.	self tabMorphs do:		[:m | m highlightColor: color1.  m regularColor: color2]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 15:27'!highlightTab: aTab	self tabMorphs do: [:m |		m == aTab		ifTrue: [m color: m highlightColor]		ifFalse: [m color: m regularColor]]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/4/1998 14:58'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m color: m highlightColor.  theOne _ m]				ifFalse: [m color: m regularColor]].	^ theOne! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:47'!regularColor	^ regularColor ifNil: [Color r: 0.4 g: 0.2 b: 0.6]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!regularColor: aColor	regularColor _ aColor! !!IndexTabs class methodsFor: 'all' stamp: 'sw 7/2/1998 15:16'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'tabs'! !!InputSensor methodsFor: 'modifier keys' stamp: 'jm 5/29/1998 14:17'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	^ self primMouseButtons anyMask: 32! !!InputSensor methodsFor: 'user interrupts' stamp: 'di 9/23/1998 16:12'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		Smalltalk shutDownSound.		Smalltalk handleUserInterrupt]! !!Inspector methodsFor: 'accessing' stamp: 'di 9/22/1998 21:28'!step	"Continuously update the value of the selected item"	| newText |	contents ifNotNil: [ contents size > 1000 ifTrue: [ 		"too much text--forget the automatic updating"		^self  ] ].	newText _ self contentsIsString		ifTrue: [self selection]		ifFalse: [self selection printString].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:24'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (selectionIndex = 2) | (selectionIndex = 0)! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:29'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionIndex = anInteger		ifTrue: 			["same index, turn off selection"			selectionIndex _ 0.			contents _ '']		ifFalse:			["different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selection printString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject	^ self openAsMorphOn: anObject withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:30'!openAsMorphOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject withLabel: label) openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject withLabel: aLabel	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: ((inspector isMemberOf: DictionaryInspector)						ifTrue: [#dictionaryMenu:]						ifFalse: [#fieldListMenu:])				keystroke: #inspectorKey:from:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.7 corner: 1@1).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 9/23/1998 12:38'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	World ifNotNil:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass].	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!Integer methodsFor: 'arithmetic' stamp: 'LC 6/18/1998 09:33'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger		ifTrue: [quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"								neg: self negative ~~ aNumber negative.				(quoRem at: 2) = 0					ifTrue: [^(quoRem at: 1) normalize]					ifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]		ifFalse: [^ (aNumber adaptInteger: self) / aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic' stamp: 'LC 9/8/1998 18:44'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger		ifTrue: 			[ng _ self negative == aNumber negative == false.			quo _ (self digitDiv:				(aNumber class == SmallInteger					ifTrue: [aNumber abs]					ifFalse: [aNumber])				neg: ng) at: 1.			^ quo normalize]		ifFalse: [^ (aNumber adaptInteger: self) quo: aNumber adaptToInteger]! !!Integer methodsFor: 'truncation and round off' stamp: 'sw 6/26/1998 15:48'!atRandom	"Return a random integer from 1 to self.  Heavy users should use Interval atRandom or atRandom: directly."	self < 1 ifTrue: [^ self].	^ (1 to: self) atRandom! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'converting' stamp: 'di 7/1/1998 21:37'!asFloat	"Answer a Float that represents the value of the receiver. Optimized to process only the significant digits of a LargeInteger."	| sum factor numBytes |	sum _ 0.0.	factor _ self sign asFloat.	numBytes _ self size.	numBytes > 8		ifFalse: [			1 to: self size do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0]]		ifTrue: [			(numBytes - 7) to: numBytes do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0].			sum _ sum timesTwoPower: 8 * (numBytes - 8)].	^ sum! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'private' stamp: 'LC 6/18/1998 10:07'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	arg = 0 ifTrue: [^ self error: 'division by 0'].	"*****We've added this line*****"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0 ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l				put: lo - (lo // 256 * 256) "sign-tolerant form of (lo bitAnd: 255)".			a _ (lo // 256) - (hi bitShift: -4).			l _ l + 1].		a < 0 ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !!Interpreter methodsFor: 'contexts' stamp: 'jm 6/24/1998 17:59'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 8/22/1998 09:41'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	(nextWakeupTick ~= 0) ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	((nextWakeupTick ~= 0) and: [self ioLowResMSecs ~= startTime]) ifTrue: [		"primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: [  "process the interrupt now"					self checkForInterrupts]				ifFalse: [  "process the interrupt in primtive failure code"					interruptCheckCounter _ 0]]].	^ successFlag! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ls 8/18/1998 06:24'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:32'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:34'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:37'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients that trigger interrupts should set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0)		ifTrue: [self checkForInterrupts].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 9/22/1998 23:09'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/25/1998 06:45'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 09:37'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 17:59'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 11:14'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 14:08'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 9/22/1998 16:52'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primBitmapcompresstoByteArray	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:16'!primBitmapdecompressfromByteArrayat	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primStringcomparewithcollated	^ self primitiveFail! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 16:41'!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 17:00'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:CW Test Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 6/28/1998 11:56'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives													onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/30/1998 13:58'!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ # (83 73 84 33 0 2 0 0 34 226 114 76 97 117 2 162 0 0 0 22 1 221 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 99 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 189 166 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 140 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 177 190 158 132 0 0 37 198 0 0 29 242 0 0 7 229 0 0 8 33 202 166 25 188 0 0 0 0 0 0 74 218 13 192 248 235 186 60 187 86 182 50 249 202 82 126 132 219 225 217 121 124 162 181 178 35 44 114 140 80 66 9 187 40 158 158 156 30 167 157 39 161 114 250 92 159 19 110 134 239 165 173 199 52 252 197 241 79 249 209 6 121 107 17 38 127 194 201 113 9 229 71 24 121 110 132 229 25 57 22 225 71 158 69 249 25 225 79 158 63 225 132 19 254 132 19 202 7 132 19 70 248 153 157 132 19 26 97 228 248 17 78 152 132 191 132 37 225 3 35 199 8 91 129 187 26 176 232 243 35 199 143 54 136 242 149 175 17 78 56 161 71 88 228 248 73 88 100 198 9 127 138 39 28 24 127 2 1 232 117 118 1 48 0 144 199 3 204 192 63 123 39 167 221 46 115 126 81 240 169 92 139 40 72 156 230 23 52 78 149 91 68 89 18 57 49 168 90 107 111 109 21 133 230 121 133 149 142 144 34 47 175 100 49 187 203 229 174 113 214 47 44 99 96 81 254 0 250 37 222 254 46 118 220 124 163 4 48 237 48 192 165 175 138 156 39 40 120 155 57 185 85 11 6 144 32 161 172 234 156 53 127 64 229 240 167 249 69 206 39 54 9 173 65 13 207 106 179 38 135 184 144 18 144 52 81 113 44 172 163 151 251 47 113 94 65 146 100 141 243 32 27 249 54 209 199 201 77 77 81 18 122 30 143 232 21 90 85 145 11 104 132 30 10 194 66 26 86 129 153 22 130 17 76 228 143 214 65 58 176 152 200 132 72 39 158 140 0 106 135 69 22 22 3 1 21 23 17 69 108 46 193 203 85 215 114 243 10 155 57 231 108 103 65 129 227 233 129 44 216 241 0 204 209 67 244 124 3 211 201 100 178 171 250 243 56 32 35 138 140 233 156 61 152 201 14 12 227 98 183 178 33 211 187 80 14 48 65 4 152 120 132 50 75 99 32 18 137 165 137 68 24 18 4 186 88 63 146 216 180 9 160 56 66 190 168 178 153 233 46 89 18 188 242 176 2 102 184 2 44 204 75 108 56 126 30 12 66 239 188 249 144 70 170 132 22 73 37 87 21 144 154 69 229 123 38 209 12 110 183 243 68 134 220 18 183 187 106 188 100 111 193 127 73 40 20 52 6 224 225 114 85 149 166 242 88 171 2 30 110 97 75 72 86 52 34 237 143 57 92 238 42 172 86 67 0 30 245 206 107 141 1 116 173 169 173 25 34 248 39 143 186 178 134 58 214 225 77 182 48 87 189 222 53 79 169 170 243 48 59 188 5 5 134 0 60 76 14 239 207 130 252 206 35 100 24 160 107 104 152 200 25 30 98 219 207 130 252 26 122 189 250 255 169 87 91 156 71 82 141 137 200 195 45 168 94 33 120 90 88 93 215 144 160 26 5 240 240 14 43 155 210 149 24 27 194 35 157 240 248 169 19 141 241 96 29 223 251 155 254 48 213 136 43 83 245 218 224 172 30 241 13 54 146 164 60 233 28 124 178 183 245 191 214 65 251 189 162 42 201 102 63 202 67 245 7 61 169 60 86 119 217 47 170 34 15 173 213 32 128 7 9 179 3 171 228 111 93 221 164 22 83 30 216 0 196 225 162 180 63 230 56 235 112 79 241 48 12 112 184 213 165 139 200 76 46 169 135 203 93 159 210 195 168 193 41 159 84 227 172 83 78 242 56 227 148 71 120 140 58 229 17 93 71 157 114 138 135 241 130 83 30 210 227 47 167 124 74 216 63 157 114 138 199 168 83 30 162 113 206 41 39 121 24 3 56 101 227 15 135 123 178 96 207 58 220 211 157 209 48 192 225 214 7 164 171 231 114 109 133 243 78 56 92 203 31 78 7 137 156 200 241 135 211 73 242 56 227 80 70 244 24 117 40 41 30 99 29 120 136 199 185 14 156 228 97 114 36 187 94 6 242 192 194 31 177 194 227 29 38 193 35 24 24 110 123 223 78 18 78 87 26 225 33 123 150 15 243 168 246 44 79 241 200 116 157 92 87 136 23 135 203 89 97 8 32 250 111 51 130 12 84 131 86 244 47 60 176 83 5 135 189 226 100 194 35 40 168 42 231 148 91 66 129 224 119 234 198 58 3 86 180 216 100 8 160 235 120 103 72 120 233 164 39 31 227 145 234 192 169 58 75 116 78 109 184 204 70 195 156 75 215 134 24 48 49 22 220 240 41 130 70 196 151 28 219 2 141 51 15 232 24 192 139 0 141 124 248 131 99 248 63 200 135 249 112 239 251 151 46 193 141 159 73 176 27 51 175 195 51 44 38 20 170 248 246 135 222 132 198 171 42 96 201 87 183 64 120 223 46 8 119 180 241 225 7 45 244 78 120 61 182 67 194 68 231 199 217 248 118 146 143 111 223 188 15 110 218 123 247 0 23 68 194 119 61 122 92 112 253 252 145 46 25 229 119 60 248 246 39 46 230 219 31 199 219 81 126 144 115 51 236 198 127 63 159 142 143 160 177 120 63 158 159 161 92 122 40 231 195 176 137 42 157 131 89 145 49 110 20 177 23 22 233 163 212 218 214 16 233 206 4 173 192 109 66 81 81 139 236 214 30 152 188 253 138 56 113 102 150 174 8 102 101 124 143 205 1 251 13 251 241 191 219 31 249 154 71 252 74 188 23 1 251 148 89 136 29 193 191 13 114 218 235 48 255 139 249 96 54 35 206 29 207 15 136 187 117 124 150 198 20 188 209 165 122 149 0 76 197 129 36 230 167 91 85 190 110 172 3 212 135 230 207 192 252 59 118 129 61 55 177 19 149 127 255 147 252 198 167 52 68 176 8 8 159 238 110 176 95 178 131 185 38 205 134 216 30 228 215 73 235 124 242 246 213 122 126 212 131 228 183 79 143 217 202 92 152 78 182 225 72 13 92 48 88 3 104 122 20 65 9 136 106 17 24 90 212 0 179 224 250 47 12 3 106 32 3 216 169 131 53 16 107 2 0 93 121 208 87 249 10 244 213 180 241 29 119 188 94 77 166 234 38 200 196 15 224 67 198 183 130 112 140 144 219 112 224 145 46 56 248 230 3 192 204 94 207 248 86 162 30 43 58 123 163 65 239 247 169 107 144 201 91 252 70 212 148 230 239 202 195 28 135 74 97 70 41 100 189 211 0 231 21 178 180 135 229 100 233 134 225 192 182 231 83 253 28 121 206 137 65 58 190 42 23 114 122 55 227 191 19 49 15 189 159 211 119 20 172 207 245 68 48 16 231 175 197 90 224 183 101 230 195 17 6 235 117 109 4 152 189 116 18 206 90 112 175 52 171 54 208 18 10 138 92 169 40 142 79 54 13 59 130 1 198 8 166 8 48 236 96 198 133 89 186 212 73 55 60 17 164 97 133 9 223 22 11 198 43 184 91 11 19 245 61 107 110 177 139 140 6 201 190 245 200 248 160 63 202 75 106 235 244 157 149 203 109 54 218 207 255 141 98 140 56 248 195 142 44 76 216 53 152 114 46 234 120 110 47 216 130 155 192 137 122 216 67 55 140 7 27 138 17 80 44 93 170 106 130 66 172 158 129 67 216 169 83 196 98 30 172 103 236 126 70 0 237 170 216 0 66 95 198 78 94 21 48 164 137 103 201 132 41 181 153 79 220 134 238 94 24 50 179 192 63 217 213 111 48 4 240 49 169 178 61 238 115 126 112 57 186 55 177 128 57 209 181 6 222 207 96 39 126 178 113 26 25 129 95 196 72 192 134 22 211 249 236 133 33 5 135 177 83 225 178 218 186 154 60 204 216 191 113 151 215 75 135 155 232 249 112 139 229 83 152 134 247 173 4 171 121 13 112 110 195 208 225 246 117 247 66 33 98 244 189 130 10 55 224 56 159 33 19 63 8 189 13 213 200 122 6 193 90 214 194 82 196 234 8 86 56 27 240 113 0 214 71 176 54 55 172 65 108 53 193 46 216 10 29 136 117 19 108 230 11 112 15 98 71 9 198 47 128 251 0 206 159 79 48 233 101 216 130 146 53 16 204 255 57 60 140 82 210 65 114 254 6 216 137 24 114 1 152 146 14 56 75 185 136 204 106 224 166 101 208 131 239 121 208 124 75 43 224 61 196 54 80 222 235 224 99 196 54 19 236 74 39 124 6 112 201 109 4 155 244 25 124 131 24 205 145 187 19 223 221 0 142 14 25 203 50 152 108 128 233 248 54 8 6 78 87 176 162 230 18 200 116 136 98 88 11 152 219 141 111 142 136 94 141 195 186 82 3 178 148 141 27 70 241 65 184 149 110 58 196 225 44 178 235 226 148 125 226 117 162 100 73 236 189 208 107 81 26 147 162 91 87 177 148 49 188 94 80 164 128 180 76 181 198 232 150 181 105 138 160 166 151 249 2 154 172 152 203 101 73 75 175 19 148 101 162 150 93 226 245 138 56 140 119 11 154 31 239 211 52 89 212 172 71 137 39 86 74 233 181 40 33 171 190 220 17 87 78 135 99 180 211 157 229 46 76 150 69 30 92 136 241 72 60 190 48 129 64 184 57 68 175 71 249 252 15 0 12 0 235 49 185 14 204 107 214 217 121 201 105 215 132 222 54 182 50 249 211 46 202 7 166 178 181 79 217 105 231 118 141 167 71 56 57 238 225 217 122 50 15 79 40 158 106 225 159 230 19 222 17 38 217 79 54 97 251 201 109 178 201 126 242 155 12 54 217 100 31 57 30 225 100 31 149 71 37 191 143 12 232 38 155 220 150 112 178 201 38 147 77 56 225 40 32 19 126 132 31 57 78 56 225 228 54 217 228 182 100 63 217 20 184 183 117 211 107 227 143 93 79 205 111 128 39 252 141 222 102 100 176 9 26 182 148 108 0 130 7 62 60 80 14 186 152 166 169 132 16 23 124 27 9 217 243 77 248 254 12 122 17 248 22 193 247 71 100 27 105 35 110 210 82 28 213 198 245 152 108 16 215 243 207 146 71 72 247 240 252 95 59 73 49 32 208 87 130 53 125 110 142 231 13 75 177 230 62 229 172 46 233 10 160 30 99 120 219 17 67 224 242 199 240 124 129 254 104 232 95 128 23 10 120 116 198 22 66 218 103 73 217 195 149 196 245 202 15 9 185 48 239 122 168 234 109 114 144 68 160 126 236 18 20 157 129 225 225 163 252 177 250 192 119 220 62 82 228 138 213 158 180 166 35 238 195 238 35 23 230 201 59 192 61 41 175 36 213 160 2 66 60 76 35 11 175 68 73 152 178 158 244 199 108 120 251 245 97 93 154 42 171 121 24 166 240 64 125 26 234 114 172 189 80 159 129 218 135 253 50 168 37 168 75 210 191 121 180 14 234 163 233 137 83 47 67 221 159 158 120 168 8 234 96 122 242 193 31 64 253 93 242 61 152 170 204 230 197 107 140 245 40 170 28 209 149 81 99 149 156 214 45 3 120 17 124 252 137 60 5 211 84 219 124 212 25 99 224 5 1 99 42 17 91 227 229 4 214 53 51 123 167 159 128 41 26 176 222 157 250 219 139 111 66 45 120 218 133 255 213 98 93 143 245 50 127 135 241 127 193 99 245 140 242 151 63 127 194 231 31 200 31 129 141 42 155 207 74 198 103 151 162 203 49 83 211 167 242 18 19 174 37 248 220 186 129 199 199 201 44 176 224 179 121 172 96 60 30 215 166 12 83 137 141 20 156 226 58 139 199 42 168 127 191 192 163 224 207 241 143 77 190 178 62 226 99 124 245 203 230 132 166 175 208 69 190 136 245 126 228 165 14 235 138 148 235 209 159 64 93 153 242 236 122 122 129 63 255 6 127 205 136 35 248 107 250 229 220 123 109 80 55 254 234 245 95 140 231 249 116 249 93 109 192 70 147 205 103 61 227 51 42 235 138 164 6 18 241 112 168 43 20 209 116 243 10 179 61 88 247 162 238 132 14 239 196 58 132 255 9 190 239 178 252 83 240 191 236 63 29 89 31 218 129 245 78 172 143 225 156 142 63 221 157 245 169 67 150 126 150 245 210 239 162 233 115 159 173 151 114 174 23 109 60 17 95 203 92 95 192 250 118 156 119 15 214 109 88 219 250 17 122 185 227 127 186 57 104 233 167 29 107 225 47 182 158 14 204 124 57 176 19 234 219 214 117 245 185 158 178 254 3 57 17 244 244 160 146 136 107 19 171 130 186 213 210 147 237 51 66 31 247 97 127 47 214 199 215 125 215 214 145 208 205 17 172 239 157 249 199 219 95 91 208 77 231 127 243 209 61 168 171 27 240 191 13 189 20 114 117 88 49 98 31 231 234 174 45 7 114 117 150 143 42 99 108 64 141 51 63 92 227 36 176 85 2 31 144 207 62 33 3 94 247 150 3 124 252 147 17 81 111 243 113 93 60 161 127 188 156 129 39 182 76 34 39 216 251 7 59 7 220 130 253 125 150 223 181 96 125 51 214 203 249 222 206 1 215 99 125 19 214 55 98 45 124 75 228 78 225 251 118 238 236 33 189 219 222 130 218 157 97 148 41 161 20 220 125 32 234 87 149 179 235 252 11 220 43 115 240 156 26 150 204 97 88 204 29 234 56 209 220 35 181 180 43 7 58 226 173 126 248 193 158 35 156 155 131 241 177 35 169 107 231 96 1 164 31 234 24 105 137 142 74 170 218 186 68 14 108 221 46 205 33 250 56 135 55 26 26 120 224 164 31 232 248 144 132 133 39 252 32 59 199 14 182 113 68 62 155 131 249 129 232 30 52 131 220 9 83 148 252 216 225 32 229 105 188 232 154 14 71 250 122 104 135 184 25 234 183 28 69 166 60 173 79 10 212 214 39 201 54 134 250 13 71 55 144 146 230 56 42 237 144 34 134 250 136 195 110 202 235 125 9 103 133 14 236 120 64 173 222 247 157 157 208 227 207 61 245 117 215 244 96 247 201 65 218 1 231 4 84 95 189 227 180 179 95 117 3 175 20 149 118 96 47 198 102 117 246 104 179 95 249 123 26 81 161 3 59 102 80 173 247 253 34 99 204 63 92 16 61 205 8 28 149 165 133 210 78 80 111 241 183 183 143 130 135 21 112 89 18 97 168 172 83 198 81 139 167 206 75 170 145 135 101 185 68 160 74 196 131 168 134 25 87 180 85 212 211 25 212 211 164 156 163 150 0 42 168 58 7 107 161 122 51 168 186 146 24 90 65 61 147 65 61 67 124 168 6 83 25 149 215 212 176 56 107 69 39 232 181 228 167 229 160 214 94 89 138 203 250 146 36 88 202 231 168 180 83 201 81 233 29 0 162 130 5 125 232 121 176 19 152 14 135 131 189 172 83 197 24 122 190 180 75 54 70 142 142 231 180 199 146 61 155 149 117 170 57 106 241 224 84 82 46 232 149 229 39 142 74 59 53 28 181 38 168 37 226 138 169 104 9 73 5 178 116 205 154 128 165 47 49 235 19 164 150 163 122 194 202 164 28 15 107 241 172 144 44 212 58 142 90 210 125 94 78 152 121 138 44 212 29 56 235 151 198 193 141 227 186 52 113 117 214 157 28 181 34 131 58 40 79 154 87 144 45 212 122 84 222 64 244 1 83 201 187 158 133 186 11 121 13 203 163 212 195 55 120 221 141 122 165 247 0 43 254 74 243 54 119 20 218 105 16 26 210 117 45 235 65 31 204 218 200 51 74 9 72 123 48 24 201 161 210 44 205 115 3 75 213 123 80 121 129 100 82 149 7 37 117 228 170 242 154 248 172 149 129 120 92 151 13 227 100 159 68 109 229 50 52 205 239 124 86 150 228 175 199 89 239 151 13 126 99 115 117 214 102 225 121 186 148 92 241 188 127 163 238 69 149 31 147 13 83 82 63 112 133 143 80 247 33 106 143 166 230 236 255 10 234 13 200 235 32 156 24 21 60 197 66 189 81 160 130 105 93 67 189 9 189 33 26 211 149 100 142 86 27 245 102 116 202 80 194 84 11 234 179 80 111 17 106 80 38 233 106 100 67 13 45 168 215 80 76 75 92 211 107 43 207 202 206 77 207 108 241 169 62 204 202 208 129 13 56 67 117 54 230 105 255 247 127 141 89 25 58 176 231 21 179 174 238 133 211 115 175 13 33 42 116 224 218 130 161 58 215 25 233 253 167 222 69 84 232 144 253 153 156 119 94 201 57 222 101 53 248 209 27 34 186 6 160 198 134 83 30 64 229 113 33 228 149 71 183 241 28 149 118 218 56 106 121 80 27 77 106 137 92 106 179 102 189 13 81 217 172 161 68 114 124 201 139 172 252 122 59 71 245 178 180 145 143 136 214 172 119 112 212 237 221 145 72 176 144 230 45 212 118 100 8 64 169 49 159 213 38 63 229 245 32 71 245 245 107 166 114 78 137 45 229 154 203 168 135 80 229 220 76 54 85 126 39 71 45 131 92 110 234 90 46 138 90 168 29 168 242 176 156 200 239 13 46 163 222 37 124 8 142 112 180 161 77 134 238 70 134 104 70 233 134 221 193 103 12 221 35 18 27 108 95 244 85 134 22 189 225 94 134 250 76 153 216 2 46 207 74 111 37 56 42 237 28 70 94 163 108 63 180 201 235 125 34 151 131 242 174 105 232 8 162 70 180 137 117 94 23 81 59 133 43 199 32 192 254 7 53 192 211 134 115 251 48 251 194 27 63 199 60 4 29 114 148 239 14 203 140 49 240 148 115 202 242 190 140 222 21 96 70 129 14 9 114 212 90 99 44 162 74 230 57 77 31 141 38 229 24 181 191 75 248 244 10 1 81 161 3 215 31 153 20 181 114 45 146 174 169 11 32 42 116 224 38 66 164 168 213 27 138 116 69 181 216 110 66 7 54 219 12 213 185 36 75 207 189 154 18 137 237 213 20 57 38 178 50 3 92 201 202 139 62 212 139 89 25 242 208 232 90 86 94 68 13 113 212 234 224 253 97 62 238 82 224 179 80 143 35 67 125 218 4 44 150 54 211 252 9 174 6 231 222 52 253 219 221 143 161 26 160 3 215 185 12 213 185 230 77 255 238 226 20 162 66 135 132 217 150 125 218 185 141 72 121 26 218 197 70 191 161 157 244 115 71 241 48 134 134 187 228 172 239 209 59 95 225 67 112 241 203 158 11 174 179 137 59 18 149 135 230 231 51 64 240 143 139 208 127 232 92 110 239 59 73 232 55 209 155 229 72 159 97 82 0 248 7 106 175 31 174 86 205 72 143 106 208 127 254 15 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 77 114 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 215 154 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 177 190 158 123 0 0 42 109 0 0 31 62 0 0 9 113 0 0 8 117 16 125 111 57 0 0 0 0 0 0 27 241 13 192 213 101 47 91 187 188 110 221 29 229 18 150 183 198 233 53 72 187 149 29 97 73 24 97 155 146 205 162 120 122 246 155 230 166 118 54 232 76 126 126 20 79 13 207 60 59 243 247 250 17 78 219 94 172 181 174 129 145 219 100 179 219 18 70 246 179 178 167 91 194 201 38 180 35 172 211 45 97 219 235 216 126 178 25 217 39 217 71 201 182 35 199 200 38 140 48 194 175 99 114 194 54 57 30 219 30 97 69 185 132 17 254 81 242 180 91 129 175 26 212 121 117 190 155 125 180 149 173 237 35 91 26 97 155 220 214 205 54 153 109 178 201 102 120 178 129 241 30 16 128 94 103 135 7 96 0 48 103 9 192 108 60 53 159 116 5 223 89 254 32 131 224 123 30 88 32 6 7 240 28 172 219 186 208 28 124 75 185 149 167 86 127 182 93 150 90 109 54 139 217 227 117 183 88 4 204 110 181 218 170 44 181 43 138 24 148 102 15 163 239 4 240 249 72 236 94 215 148 9 48 243 110 128 121 109 89 121 230 224 209 157 79 150 22 173 215 173 220 186 115 79 238 76 68 166 149 184 130 93 11 205 144 134 167 1 207 164 242 125 39 117 21 111 67 90 189 97 229 86 122 235 209 237 170 170 169 88 148 80 214 63 125 32 232 41 95 87 222 190 8 32 129 115 75 224 159 54 74 150 196 29 14 109 2 6 148 175 2 40 249 3 203 152 141 47 4 158 92 139 119 254 30 52 198 23 241 222 18 194 241 125 162 71 178 183 74 77 242 7 90 42 49 41 244 222 236 219 208 118 254 125 74 245 6 159 95 110 179 56 37 159 79 246 93 160 144 125 78 169 243 161 3 1 19 105 16 217 134 183 143 114 142 133 128 44 244 42 0 44 194 81 74 138 164 89 37 187 169 162 218 132 45 194 100 89 104 201 201 49 127 119 56 139 168 148 153 114 9 221 87 178 109 44 89 120 224 76 30 61 48 164 131 39 151 153 208 40 108 230 213 41 68 106 116 60 152 86 21 160 90 212 65 2 27 106 184 36 38 50 26 70 50 25 177 8 93 194 98 225 215 26 108 162 0 137 216 23 83 6 56 179 4 52 14 193 112 154 96 16 11 150 74 22 96 134 114 165 216 177 3 32 47 72 95 168 95 36 235 172 110 151 100 119 143 41 160 133 185 160 103 63 17 2 145 251 217 234 38 89 214 64 2 245 158 80 235 41 115 184 90 101 239 251 76 198 51 76 203 183 217 202 110 21 89 61 158 249 30 143 83 29 128 135 213 90 86 16 207 147 90 230 104 48 173 104 243 184 189 126 146 246 66 14 171 173 172 88 37 128 71 173 165 80 29 64 215 170 234 170 81 130 31 243 168 41 90 93 163 49 55 52 219 251 250 250 128 253 108 59 127 120 236 9 63 93 197 199 90 94 71 187 84 104 40 144 156 78 183 219 101 42 145 157 30 122 56 117 153 0 199 182 246 64 215 156 101 176 51 247 0 61 33 30 130 217 30 107 133 214 90 197 211 92 170 14 133 135 214 108 207 201 81 5 224 161 49 219 175 8 242 119 30 92 118 85 0 93 61 99 68 174 243 144 59 174 8 242 215 80 234 181 249 63 245 154 22 225 17 83 35 5 121 216 36 159 93 114 94 22 86 209 213 35 141 26 252 127 242 176 143 41 27 215 149 12 18 241 208 17 143 15 59 209 53 30 130 249 125 159 116 38 52 85 242 231 62 170 87 223 149 62 173 67 25 242 125 109 188 79 243 247 231 250 244 106 75 197 184 143 73 163 36 197 49 39 211 232 182 183 255 183 5 113 255 225 245 121 99 166 97 130 135 175 217 217 16 207 147 106 43 186 170 42 242 240 183 171 4 240 160 208 154 177 74 254 173 171 141 106 81 113 220 75 151 125 70 189 196 113 163 180 23 114 220 112 220 151 120 168 6 56 238 138 130 82 211 184 30 86 91 109 92 15 181 15 231 126 81 213 27 206 61 198 227 186 115 31 231 49 225 220 199 117 157 112 238 113 30 234 11 206 125 84 143 127 57 247 75 194 126 236 220 227 60 38 156 251 40 141 155 206 61 198 67 61 192 185 107 205 62 185 233 195 62 13 208 117 231 41 156 198 207 133 130 108 236 207 251 135 251 116 49 239 211 234 31 142 251 98 225 223 112 220 151 59 172 106 128 227 174 117 184 238 90 108 234 88 182 244 207 142 91 255 15 199 132 68 174 116 134 107 142 41 198 227 186 211 25 215 99 194 233 196 121 92 235 228 163 60 110 118 242 24 15 141 57 214 245 146 144 7 22 254 184 53 191 213 97 162 60 156 142 177 182 119 122 178 113 185 210 136 135 187 161 101 140 71 69 67 75 156 71 178 245 226 58 71 164 56 172 150 18 85 0 209 255 54 107 72 66 53 120 69 95 229 129 157 202 57 230 57 211 137 7 45 141 153 44 238 54 143 195 121 86 221 112 103 192 138 150 215 171 2 232 122 171 51 68 61 121 204 219 95 227 17 239 192 241 58 139 118 78 255 88 153 77 132 206 196 151 213 4 208 50 218 69 203 133 58 196 215 158 250 6 212 205 123 67 193 0 246 3 212 137 129 223 158 194 179 95 12 136 129 190 87 102 173 197 141 168 201 112 16 51 111 194 59 208 202 20 43 19 59 191 254 75 168 91 80 2 107 223 171 135 192 107 7 32 240 72 135 24 120 82 207 223 4 30 198 118 72 76 20 126 166 52 177 147 242 137 157 79 189 6 107 94 221 50 204 5 145 192 99 221 67 130 43 119 244 228 24 152 31 249 13 133 216 217 51 67 236 220 131 175 67 252 96 202 58 56 136 231 25 62 143 188 14 117 121 71 240 254 2 231 210 203 57 159 128 29 92 233 41 152 21 25 51 220 62 20 114 115 55 139 155 95 90 29 34 199 64 51 163 144 185 106 30 197 19 153 38 158 54 97 11 120 2 229 237 83 32 188 253 10 225 38 173 136 249 77 70 113 243 46 101 110 155 188 184 135 53 125 77 209 142 242 85 126 191 67 220 220 93 12 250 162 189 48 248 157 67 172 242 231 189 152 107 35 36 182 126 1 30 127 119 144 85 190 184 13 71 18 60 48 199 17 150 240 165 39 224 228 189 221 226 163 39 202 185 250 240 116 61 205 36 128 189 90 200 42 191 7 66 83 198 29 48 248 171 233 10 187 251 127 196 53 27 139 193 147 212 138 120 241 71 52 230 186 252 120 31 192 198 93 236 48 8 217 185 202 120 187 186 221 67 14 37 183 68 150 26 101 175 47 55 191 188 122 5 206 44 21 16 167 36 63 56 69 39 91 254 242 17 214 216 227 199 115 46 91 78 229 53 245 16 103 212 248 172 173 0 146 12 96 200 50 70 216 27 243 15 199 123 18 251 212 134 55 56 208 24 226 65 56 42 78 124 216 221 83 255 50 13 63 10 62 24 128 94 204 181 157 234 133 53 62 183 133 52 193 252 61 252 189 225 142 45 144 254 149 238 108 72 210 114 61 158 102 233 252 84 34 3 50 177 32 132 105 35 53 128 104 88 121 99 106 47 164 63 51 55 42 216 252 112 117 11 172 229 143 139 192 184 242 8 158 7 155 131 127 18 17 191 19 223 5 193 248 137 249 136 13 224 153 6 83 58 107 48 255 254 108 208 106 17 55 13 229 7 196 109 10 62 223 207 114 94 238 242 217 189 14 248 127 28 68 97 126 190 125 216 210 143 253 16 245 225 249 147 48 255 91 7 192 152 17 221 29 204 58 177 73 220 190 151 166 88 216 12 137 79 255 115 96 156 185 155 21 26 108 136 29 66 126 219 120 197 167 63 243 160 146 31 245 160 252 198 204 112 103 67 253 105 23 151 106 224 182 145 26 64 243 235 149 188 14 25 139 95 245 161 6 196 237 151 107 128 181 254 238 135 106 2 53 48 121 164 6 104 23 84 68 78 196 89 29 165 15 160 152 250 208 34 186 218 75 132 86 182 85 96 194 136 179 130 72 73 12 69 42 36 98 137 240 35 244 242 37 114 152 227 155 243 87 35 15 67 217 165 98 129 213 231 254 188 112 35 136 79 4 60 191 161 143 60 71 82 46 70 29 111 214 190 30 93 0 70 200 93 31 82 122 233 112 67 81 3 138 251 238 243 249 37 47 95 218 80 111 8 35 104 132 208 79 29 162 127 4 192 224 221 79 13 68 95 102 84 137 113 127 31 196 62 154 45 165 40 127 142 49 173 178 146 193 161 63 200 224 255 99 134 146 20 231 87 215 40 238 101 14 78 221 18 105 99 168 11 61 17 247 228 106 7 101 59 228 115 206 187 28 229 31 35 250 179 191 149 137 254 51 71 72 121 243 240 204 47 227 147 233 236 5 16 60 171 248 156 126 154 199 139 67 249 219 97 118 117 77 85 22 102 252 226 105 74 201 249 124 200 205 187 222 61 63 5 154 119 164 18 86 249 0 228 226 245 255 8 43 125 28 104 43 246 97 194 218 111 131 123 241 186 155 176 148 26 104 194 43 13 15 33 115 22 32 87 86 74 88 245 124 216 136 216 87 9 91 234 133 173 136 125 155 176 252 231 169 142 216 94 194 214 164 195 179 136 29 37 44 241 56 214 37 8 253 132 125 190 15 126 129 74 242 237 208 197 107 224 55 136 225 63 117 0 214 217 224 77 196 248 230 68 150 27 142 35 198 183 197 54 62 15 239 34 214 75 88 173 22 6 113 4 194 103 59 121 243 88 50 254 238 131 116 131 230 37 12 53 54 221 67 88 253 239 25 78 93 77 124 127 33 199 201 230 32 198 117 93 255 45 118 23 170 200 243 77 57 198 112 235 54 115 19 97 183 239 97 149 136 209 220 5 30 90 206 112 194 156 197 91 69 85 55 107 68 140 231 120 232 155 12 127 26 146 205 181 47 90 194 238 7 152 165 172 163 244 210 220 105 54 253 217 7 52 199 57 198 117 157 108 195 126 35 219 253 38 172 79 159 195 237 202 176 74 77 14 187 201 34 121 70 150 44 208 134 135 31 42 59 37 233 209 7 33 14 169 124 209 38 146 113 18 173 90 89 220 141 242 167 101 151 62 186 118 197 159 133 50 166 209 254 115 161 195 135 68 229 182 6 98 73 46 255 244 3 131 178 251 142 91 134 46 217 105 192 181 188 8 189 201 161 197 195 179 120 173 228 117 57 92 77 190 212 176 178 69 29 126 175 228 211 21 53 58 252 110 175 182 216 237 242 235 106 36 111 147 236 55 228 219 237 50 74 108 147 252 205 248 158 167 153 68 138 132 69 139 110 103 243 103 97 153 149 189 164 48 239 16 28 166 173 179 20 91 49 217 36 62 174 8 241 136 254 87 37 145 32 92 122 227 207 67 124 254 7 0 12 0 235 117 249 249 94 179 188 38 114 202 39 70 249 123 114 202 39 102 3 183 84 182 246 41 211 235 240 155 173 199 125 201 38 252 60 60 245 164 143 223 212 180 240 31 243 247 128 108 74 182 145 231 29 217 132 19 70 246 145 219 39 249 125 100 27 121 182 201 38 91 42 139 186 201 237 35 155 28 219 132 147 227 145 77 54 225 228 55 217 132 147 125 100 191 100 19 222 17 78 126 31 217 94 146 253 146 77 54 121 74 182 71 184 192 189 173 156 30 63 252 177 139 108 182 118 246 50 60 97 101 244 146 12 54 65 195 62 74 54 158 224 129 47 160 28 116 81 77 139 19 66 92 240 223 69 72 243 207 225 255 23 232 73 240 47 134 255 11 80 181 19 55 188 53 70 91 24 198 179 59 95 129 154 144 115 115 199 88 125 233 163 120 173 155 32 224 17 82 228 142 238 152 37 174 55 35 174 32 57 232 10 183 252 128 52 2 145 225 221 79 147 166 121 52 15 252 41 222 182 226 23 88 31 240 178 111 31 35 143 187 31 221 51 242 238 116 165 0 119 208 253 240 103 46 144 215 73 17 33 149 111 144 122 242 20 188 171 96 26 153 255 202 212 132 169 232 201 182 104 142 166 236 215 135 245 141 233 242 186 199 96 138 155 161 62 9 245 30 172 111 129 250 20 212 173 216 191 9 106 25 234 27 50 223 63 219 0 245 3 153 137 129 223 64 45 101 38 62 86 12 245 67 153 201 227 95 134 250 73 114 6 166 42 183 121 241 24 227 221 106 92 145 116 117 204 88 37 39 184 105 0 47 130 143 159 145 23 97 154 90 155 143 6 99 60 36 71 125 198 84 34 90 224 37 132 245 214 153 235 167 127 4 83 212 96 93 157 254 199 75 127 128 90 240 84 133 239 202 177 246 98 189 200 223 253 248 94 240 88 54 163 254 253 111 31 240 249 19 112 63 66 106 108 62 171 25 159 157 170 174 68 77 77 159 202 75 236 58 139 207 205 27 120 60 71 102 129 5 175 205 99 21 227 241 136 54 101 152 106 116 116 217 41 186 44 30 187 161 126 126 158 71 193 159 227 31 235 124 229 124 196 203 248 234 83 204 9 77 95 161 139 92 143 245 237 200 75 5 214 183 166 93 103 191 1 245 109 233 138 237 175 206 243 183 119 141 191 109 136 35 248 171 127 230 252 95 219 161 174 125 246 119 223 73 229 249 116 181 185 218 129 141 102 155 207 38 198 103 88 209 85 57 238 75 196 66 129 206 128 164 233 230 37 102 15 99 29 64 221 9 29 222 139 245 17 124 39 248 190 207 242 79 193 255 162 255 236 207 249 80 37 214 30 172 123 112 78 199 159 14 228 124 234 30 75 63 139 122 233 115 209 244 121 131 173 151 74 174 23 45 149 136 21 50 23 205 145 44 39 226 188 117 88 183 97 109 235 71 232 229 206 255 234 230 110 75 63 119 97 45 252 197 214 211 190 153 99 190 70 168 239 184 162 171 255 233 41 231 63 144 19 65 79 199 213 68 76 155 88 21 212 195 150 158 108 159 17 250 232 192 126 35 214 189 87 124 215 214 145 208 141 15 235 206 153 183 94 253 236 188 110 14 253 39 31 249 81 87 219 241 221 154 94 150 115 117 72 53 162 87 115 245 71 54 29 200 213 57 62 106 140 241 254 120 140 249 97 129 147 7 55 75 224 3 242 217 7 100 192 119 112 211 1 62 222 102 68 52 217 124 108 137 37 244 171 203 25 248 96 227 195 62 145 19 236 253 131 157 3 118 99 191 201 242 187 102 172 119 97 189 152 239 237 28 208 128 245 78 172 119 96 45 124 75 228 78 225 251 118 238 236 38 61 69 127 132 218 157 101 148 41 193 235 235 11 7 90 252 109 146 228 111 11 170 131 121 254 133 110 114 115 120 194 129 254 71 78 92 29 131 108 177 230 128 237 217 194 28 149 1 186 47 27 146 163 74 97 140 236 252 185 57 170 146 186 54 4 139 36 157 50 18 95 30 165 164 48 71 105 72 54 71 174 80 193 62 129 155 155 195 27 58 238 63 154 74 152 234 152 82 16 8 221 167 210 239 43 228 41 54 135 232 139 124 17 30 79 41 242 104 203 177 80 203 254 3 189 203 124 244 103 199 255 147 219 251 100 171 219 243 218 79 221 222 35 103 70 97 37 9 143 36 119 241 119 223 96 50 242 246 61 77 200 133 183 97 178 185 236 174 18 220 231 157 65 96 199 41 36 247 241 71 171 249 72 29 192 74 217 39 29 239 72 123 122 63 225 154 14 73 193 110 218 33 110 134 250 121 71 225 51 253 103 59 92 211 198 72 124 144 118 72 17 67 157 118 116 248 204 215 6 40 170 153 26 164 29 82 204 80 191 232 168 46 93 19 172 69 134 160 67 182 48 212 175 59 94 150 174 216 245 85 68 133 14 41 97 168 159 115 28 103 230 173 215 246 114 84 218 129 60 1 14 230 109 114 242 199 236 167 221 63 118 77 71 186 78 68 104 135 148 117 128 127 150 254 170 52 50 149 84 140 182 247 118 210 11 179 210 12 192 80 89 103 43 71 173 243 107 137 152 106 170 90 66 142 67 168 215 53 107 2 150 32 56 42 237 148 115 212 138 144 58 169 196 66 90 76 185 60 175 133 90 193 81 203 186 78 43 9 51 79 145 133 90 137 179 126 52 5 91 198 152 46 79 124 56 171 135 163 86 101 81 35 202 164 121 9 217 66 245 114 212 173 253 225 71 76 53 190 68 145 133 90 133 188 134 148 49 186 207 93 227 181 26 245 74 119 218 203 122 101 153 145 161 178 78 141 208 144 174 107 250 53 13 213 114 71 41 3 105 71 252 210 18 42 205 131 220 81 88 50 172 67 229 249 146 201 184 18 145 227 163 31 42 175 158 207 90 237 139 197 116 197 48 78 4 101 106 43 23 161 105 6 229 179 178 52 218 128 179 30 85 12 45 165 71 23 21 97 205 186 77 120 158 46 39 87 60 239 61 212 70 84 249 97 197 48 229 248 251 174 240 79 212 38 68 237 214 226 49 37 47 61 11 117 59 242 26 129 51 153 101 79 177 80 119 8 84 48 173 13 212 157 232 13 225 168 174 38 151 104 181 81 119 161 83 66 246 138 47 171 207 66 221 45 212 160 78 210 248 181 166 134 102 212 107 32 170 37 54 244 122 29 117 20 207 156 115 55 49 251 169 55 51 152 135 160 3 91 92 134 234 108 125 51 109 95 250 30 71 165 29 216 253 51 84 231 86 32 179 111 224 207 136 10 29 216 53 51 212 98 99 60 79 42 69 133 253 19 162 66 135 220 216 1 168 165 95 40 25 91 22 16 77 0 116 203 197 19 0 237 220 196 81 75 167 78 203 249 132 194 80 229 44 170 76 110 70 84 195 140 169 218 42 234 201 44 234 73 178 135 163 150 1 42 196 214 37 88 11 245 150 44 170 174 38 134 87 80 79 101 81 79 145 86 84 3 75 228 171 106 88 152 245 214 14 216 166 148 125 179 18 212 218 163 200 75 198 204 54 200 28 149 118 110 227 168 158 119 80 33 153 191 143 74 247 205 211 161 144 191 135 117 110 71 207 235 84 78 171 75 9 229 162 123 237 69 47 151 116 13 64 141 181 100 179 15 157 146 27 87 222 41 233 5 0 71 165 157 54 142 90 233 215 198 146 90 98 41 101 91 179 222 129 168 108 214 64 34 153 186 156 29 216 54 92 160 62 79 218 57 170 135 165 195 124 164 183 102 189 147 163 150 116 209 85 72 94 229 22 234 93 200 16 128 210 32 53 168 77 254 139 215 187 57 170 183 79 51 213 33 53 122 57 135 94 68 189 7 85 206 15 27 214 85 126 47 71 45 135 61 138 169 107 75 198 108 161 238 71 149 135 148 68 106 35 15 221 39 124 8 14 127 180 225 117 134 14 32 67 52 83 118 193 174 231 223 12 221 143 179 134 153 151 175 207 250 0 207 67 229 198 56 232 97 72 93 204 0 116 15 143 121 8 58 112 103 192 80 157 187 132 217 95 255 254 91 152 243 160 67 30 226 168 245 198 184 20 151 205 33 77 31 11 39 149 40 21 252 187 83 211 93 63 206 10 29 184 33 16 57 111 245 230 32 83 85 43 18 27 116 224 50 131 161 58 151 28 153 186 6 31 162 66 7 238 95 178 168 43 247 50 153 243 191 29 70 84 232 144 14 177 31 2 71 217 240 6 31 162 74 218 132 162 95 67 61 36 210 70 20 22 41 215 80 253 136 26 129 196 86 152 117 33 55 116 50 212 95 148 139 157 232 162 15 209 219 29 142 74 59 93 92 67 206 205 225 185 95 190 248 56 215 16 237 144 238 108 98 51 70 15 229 29 214 98 232 48 159 213 185 175 203 156 127 57 45 244 250 114 154 244 136 237 11 3 92 217 190 44 204 26 224 168 85 144 216 198 10 219 151 5 212 35 28 181 214 127 52 196 199 189 28 73 45 212 94 100 40 168 77 192 170 114 125 63 20 204 186 215 234 245 237 108 233 64 16 93 25 58 112 139 203 80 157 219 221 204 15 119 124 27 53 4 29 184 116 102 168 206 101 116 230 185 39 166 16 21 58 112 207 192 25 186 114 255 144 121 238 12 36 0 159 36 5 105 7 46 212 225 250 194 51 87 193 24 26 233 84 114 190 71 111 166 69 70 129 235 105 246 185 224 210 157 184 165 176 50 124 33 123 1 65 175 223 225 196 26 222 208 185 220 158 215 159 128 126 51 189 255 150 130 134 73 1 224 205 75 176 25 245 194 5 240 43 82 119 220 160 111 254 15).! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:24'!macAsyncFilePrimsFile	^ '/*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>#include "sq.h"/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/23/1998 00:06'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Macintosh virtual machine.	Many primitives are "stubbed-out", meaning that if they are invoked from the	image they will return a "primitive failed" error. Among the stubbed out primitives	are those that support sound input and output, serial and MIDI ports, networking,	joystick, and file directory operations. The basic file read/write operations are	NOT stubbed out, although they could be as long as the image loading mechanism	still works. In this case, you''ll need to modify the method "openSourceFiles"	in the image to skip opening the changes and sources files at startup time.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been implemented, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioSetCursorWithMask() -- install a masked cursor		ioBeep()			-- make a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- some other behavior appropriate to this platform							-- (if this is a noop you won''t be able to quit from Squeak)		ioRelinquishProcessorForMicroseconds()							-- called when Squeak is idle to return time to the OS  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that that directory is the default working directory	for file operations. The "shortImageName" is used to display the image file	name (but not its full path) in the title bar of the Macintosh window.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- return the number of seconds since Jan 1, 1901	   						-- may return 0, but then the current date and time	   						-- will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqFilePrims.c	-- file primitives (can be stubbed out)		sqMacMinimal.c	-- this file		sqMiscPrims.c	-- automatically generated primitives (optional)	plus the appropriate support libraries. To build a PowerPC	virtual machine using CodeWarrior 8, these are:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		MathLib		MWCRuntime.Lib*/#include <MacHeaders.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#define STUBBED_OUT { success(false); }/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	success(false);  /* stubbed out */}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* Process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top) - 20;		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 20, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	return 0;}int clipboardSize(void) {	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	return 0;}/*** Directory ***/int dir_Delimitor(void) {	return '':'';}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												{/* noop */}/*** Joystick Stubs ***/int joystickRead(int stickIndex)											STUBBED_OUT/*** MIDI Stubs ***/int sqMIDIClosePort(int portNum)											STUBBED_OUTint sqMIDIGetClock(void)													STUBBED_OUTint sqMIDIGetPortCount(void)												STUBBED_OUTint sqMIDIGetPortDirectionality(int portNum)								STUBBED_OUTint sqMIDIGetPortName(int portNum, int namePtr, int length)					STUBBED_OUTint sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate)	STUBBED_OUTint sqMIDIParameter(int whichParameter, int modify, int newValue)			STUBBED_OUTint sqMIDIPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time)	STUBBED_OUT/*** Networking Stubs ***/int sqNetworkInit(int resolverSemaIndex)									STUBBED_OUTvoid sqNetworkShutdown(void)												STUBBED_OUTvoid sqResolverAbort(void)													STUBBED_OUTvoid sqResolverAddrLookupResult(char *nameForAddress, int nameSize)			STUBBED_OUTint sqResolverAddrLookupResultSize(void)									STUBBED_OUTint sqResolverError(void)													STUBBED_OUTint sqResolverLocalAddress(void)											STUBBED_OUTint sqResolverNameLookupResult(void)										STUBBED_OUTvoid sqResolverStartAddrLookup(int address)									STUBBED_OUTvoid sqResolverStartNameLookup(char *hostName, int nameSize)				STUBBED_OUTint sqResolverStatus(void)													STUBBED_OUTvoid sqSocketAbortConnection(SocketPtr s)									STUBBED_OUTvoid sqSocketCloseConnection(SocketPtr s)									STUBBED_OUTint sqSocketConnectionStatus(SocketPtr s)									STUBBED_OUTvoid sqSocketConnectToPort(SocketPtr s, int addr, int port)					STUBBED_OUTvoid sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex)							STUBBED_OUTvoid sqSocketDestroy(SocketPtr s)											STUBBED_OUTint sqSocketError(SocketPtr s)												STUBBED_OUTvoid sqSocketListenOnPort(SocketPtr s, int port)							STUBBED_OUTint sqSocketLocalAddress(SocketPtr s)										STUBBED_OUTint sqSocketLocalPort(SocketPtr s)											STUBBED_OUTint sqSocketReceiveDataAvailable(SocketPtr s)								STUBBED_OUTint sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize)			STUBBED_OUTint sqSocketRemoteAddress(SocketPtr s)										STUBBED_OUTint sqSocketRemotePort(SocketPtr s)											STUBBED_OUTint sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize)				STUBBED_OUTint sqSocketSendDone(SocketPtr s)											STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** Serial Port Functions Stubs ***/int serialPortClose(int portNum)											STUBBED_OUTint serialPortOpen(  int portNum, int baudRate, int stopBitsType,  int parityType, int dataBits, int inFlowCtrl, int outFlowCtrl,  int xOnChar, int xOffChar)												STUBBED_OUTint serialPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint serialPortWriteFrom(int portNum, int count, int bufferPtr)				STUBBED_OUT/*** Sound Output Stubs ***/int snd_AvailableSpace(void)												STUBBED_OUTint snd_PlaySamplesFromAtLength(  int frameCount, int arrayIndex, int startIndex)							STUBBED_OUTint snd_InsertSamplesFromLeadTime(  int frameCount, int srcBufPtr, int samplesOfLeadTime)						STUBBED_OUTint snd_PlaySilence(void)													STUBBED_OUTint snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_Stop(void)															STUBBED_OUT/*** Sound Input Stubs ***/int snd_SetRecordLevel(int level)											STUBBED_OUTint snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_StopRecording(void)													STUBBED_OUTdouble snd_GetRecordingSampleRate(void)										STUBBED_OUTint snd_RecordSamplesIntoAtLength(  int buf, int startSliceIndex, int bufferSizeInBytes)						STUBBED_OUT/*** Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void)			STUBBED_OUTint primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)	STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUTint primReverbSoundapplyReverbTostartingAtcount(void)						STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUT/*** Old Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtpan(void)						STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primWaveTableSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUT/*** Experimental Asynchronous File I/O ***/int asyncFileClose(AsyncFile *f)											STUBBED_OUTint asyncFileOpen(  AsyncFile *f, int fileNamePtr, int fileNameSize,  int writeFlag, int semaIndex)												STUBBED_OUTint asyncFileRecordSize()													STUBBED_OUTint asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize)		STUBBED_OUTint asyncFileReadStart(AsyncFile *f, int fPosition, int count)				STUBBED_OUTint asyncFileWriteResult(AsyncFile *f)										STUBBED_OUTint asyncFileWriteStart(  AsyncFile *f, int fPosition, int bufferPtr, int bufferSize)				STUBBED_OUT/*** Main ***/void main(void) {	sqImageFile f;	int reservedMemory, availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	SetUpMenus();	SetUpWindow();	SetUpPixmap();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following to open the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:12'!macSerialAndMIDIPortFile	^ '#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <Serial.h>#include <Strings.h>#include "sq.h"/*** Constants ***/#define INPUT_BUF_SIZE 1000/*** Imported Variables ***/extern int successFlag;/*** Local Variables ***/short inRefNum[4] = {0, 0, 0, 0};short outRefNum[4] = {0, 0, 0, 0};char inputBuffer[4][INPUT_BUF_SIZE];/*** Private Functions ***/int portCount(void);int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);int portCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			strcpy(portName, p2cstr(*(serialPtr->name)));			strcpy(inName, p2cstr(*(serialPtr->inputDriverName)));			strcpy(outName, p2cstr(*(serialPtr->outputDriverName)));			c2pstr((void *) *(serialPtr->name));			c2pstr((void *) *(serialPtr->inputDriverName));			c2pstr((void *) *(serialPtr->outputDriverName)); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	osErr = OpenDriver(c2pstr(outName), &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	osErr = OpenDriver(c2pstr(inName), &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	return serialPortClose(portNum);}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return portCount();}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */	success((portNum == 0) || (portNum == 1));	return 3;}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int count;	if ((portNum > 4) || (portNum >= portCount())) {		return success(false);	}	portNames(portNum, userName, inName, outName);	count = strlen(userName);	success(count > 0);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	return serialPortWriteFrom(portNum, count, bufferPtr);}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:31'!macSoundFile	^ '#include <Sound.h>#include <SoundInput.h>#include "sq.h"/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 4)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, NULL, NULL, true, 0};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:28'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 750000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:38'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built from four header and twelve source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- Mac primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	interp.c				-- automatically generated code for the virtual machineThe platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, May 8, 1998'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:34'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define LITTLE_ENDIAN_BITBLT# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  undef  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   if defined(ITSY)#     define LITTLE_ENDIAN_BITBLT#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:26'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:35'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*//* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"#ifdef macintosh/* macintosh memory allocation */#include <Memory.h>#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) NewPtr(desiredHeapSize)/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWritetypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num) #endif /* ACORN */#ifdef LITTLE_ENDIAN_BITBLT#define ifLittleEndianDoelseDo(a, b) a#else#define ifLittleEndianDoelseDo(a, b) b#endif'! !I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder. !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!acTableIndex	^acTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!acTableIndex: anInteger	acTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!dcTableIndex	^dcTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!dcTableIndex: anInteger	dcTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!heightInBlocks	^heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!heightInBlocks: anInteger	heightInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id	^id! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id: anObject	id _ anObject! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:29'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth _ mw.	mcuHeight _ mh.	dctSize _ ds.	hSampleFactor _ mcuWidth // widthInBlocks.	vSampleFactor _ mcuHeight // heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!priorDCValue: aNumber	priorDCValue _ aNumber! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:43'!qTableIndex	^qTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!qTableIndex: anInteger	qTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:18'!totalMcuBlocks	^ heightInBlocks * widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!updateDCValue: aNumber	priorDCValue _ priorDCValue + aNumber.	^priorDCValue! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!widthInBlocks	^widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!widthInBlocks: anInteger	widthInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!initializeSampleStreamBlocks: aCollection	mcuBlocks _ aCollection.	self resetSampleStream! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 14:23'!nextSample	| dx dy blockIndex sampleIndex sample |	dx _ currentX // hSampleFactor.	dy _ currentY // vSampleFactor.	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.	currentX _ currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX _ 0.			currentY _ currentY + 1].	^ sample! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!resetSampleStream	currentX _ 0.	currentY _ 0! !I represent the table of values used to decode Huffman entropy-encoded bitstreams.  From the JFIF file header entropy values, I build a derived table of codes and values for faster decoding.!!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!bits: anObject	bits _ anObject! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:31'!lookaheadBits	^lookaheadBits! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:38'!lookaheadSymbol	^lookaheadSymbol! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:59'!maxcode	^maxcode! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!values: anObject	values _ anObject! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!makeDerivedTables	| huffSize huffCode code si index lookbits |	mincode _ Array new: 16.	maxcode _ Array new: 17.	valptr _ Array new: 17.	huffSize _ OrderedCollection new.	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].	huffSize add: 0.	code _ 0.	huffCode _ Array new: huffSize size.	si _ huffSize at: 1.	index _ 1.	[(huffSize at: index) ~= 0] whileTrue:		[[(huffSize at: index) = si] whileTrue:			[huffCode at: index put: code.			index _ index + 1.			code _ code + 1].		code _ code << 1.		si _ si + 1].	index _ 1.	1 to: 16 do:		[:l |		(bits at: l) ~= 0			ifTrue:				[valptr at: l put: index.				mincode at: l put: (huffCode at: index).				index _ index + (bits at: l).				maxcode at: l put: (huffCode at: index-1)]			ifFalse:				[maxcode at: l put: -1]].	maxcode at: 17 put: 16rFFFFF.	lookaheadBits _ (Array new: 1 << Lookahead) atAllPut: 0.	lookaheadSymbol _ Array new: 1 << Lookahead.	index _ 1.	1 to: Lookahead do:		[:l |		1 to: (bits at: l) do:			[:i |			lookbits _ (huffCode at: index) << (Lookahead - l) + 1.			(1 << (Lookahead - l) to: 1 by: -1) do:				[:ctr |				lookaheadBits at: lookbits put: l.				lookaheadSymbol at: lookbits put: (values at: index).				lookbits _ lookbits + 1].			index _ index + 1]]! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/21/97 22:44'!valueForCode: code length: length	^ values at: ((valptr at: length) + code - (mincode at: length))! !!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!initialize	Lookahead _ 8.	BitBufferSize _ 16! !!JPEGHuffmanTable class methodsFor: 'constants' stamp: 'tao 10/21/97 22:15'!lookahead	^ Lookahead! !I am a subclass of ImageReadWriter that understands JFIF file streams, and can decode JPEG images.This code is based upon the Independent Joint Photographic Experts Group (IJPEG) software, originally written in C by Tom Lane, Philip Gladstone, Luis Ortiz, Jim Boucher, Lee Crocker, Julian Minguillon, George Phillips, Davide Rossi, Ge' Weijers, and other members of the Independent JPEG Group.!!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:53'!nextImage	^ self nextImageDitheredToDepth: Display depth! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:54'!nextImageDitheredToDepth: depth	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 10/26/97 21:41'!setStream: aStream	"Feed it in from an existing source"	stream _ aStream! !!JPEGReadWriter methodsFor: 'preferences' stamp: 'tao 10/26/97 22:09'!useFloatingPoint	^ false! !!JPEGReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:27'!understandsImageFormat	"test to see if the image stream format is understood by this decoder"	[self parseFirstMarker] ifError: [:err :rcvr | ^ false].	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!initialSOSSetup	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:		[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	hACTable , hDCTable do: [:t | t ifNotNil: [t makeDerivedTables]].	bitBuffer _ 0.	bitsInBuffer _ 0.	lookahead _ JPEGHuffmanTable lookahead.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:31'!okToIgnoreMarker: aMarker	^ ((16rE0 to: 16rEF) includes: aMarker) "unhandled APPn markers"		or: [aMarker = 16rDC or: [aMarker = 16rFE]] "DNL or COM markers"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!parseAPPn	| length buffer thumbnailLength markerStart |	markerStart _ self position.	length _ self nextWord.	buffer _ self next: 4.	(buffer asString = 'JFIF') ifFalse: [self error: 'APP header is incorrect'].	self next.	majorVersion _ self next.	minorVersion _ self next.	densityUnit _ self next.	xDensity _ self nextWord.	yDensity _ self nextWord.	thumbnailLength _ self next * self next * 3.	length _ length - (self position - markerStart).	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].	self next: length! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!parseDecoderRestartInterval	| length |	length _ self nextWord.	length = 4 ifFalse: [self error: 'DRI length incorrect'].	restartInterval _ self nextWord.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 22:31'!parseFirstMarker	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].	self next = 16rD8 ifFalse: [self error: 'SOI marker expected'].	self parseStartOfInput.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:49'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[index _ self next.		isACTable _ (index bitAnd: 16r10) ~= 0.		index _ (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits _ self next: 16.		count _ bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal _ self next: count.		(hTable _ JPEGHuffmanTable new)			bits: bits;			values: huffVal.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:32'!parseNOP	"don't need to do anything, here"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:40'!parseNextMarker	| byte discardedBytes |	discardedBytes _ 0.	[(byte _ self next) = 16rFF] whileFalse: [ self debug. discardedBytes _ discardedBytes + 1].		[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes _ discardedBytes + 2].	discardedBytes > 0 ifTrue: [self notify: 'warning: extraneous data discarded'].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte hex , ' cannot be handled']])! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:31'!parseQuantizationTable	| length markerStart n prec value table |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[value _ self next.		n _ (value bitAnd: 16r0F) + 1.		prec _ (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table _ Array new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value _ (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!parseStartOfFile	| length markerStart value n |	markerStart _ self position.	length _ self nextWord.	dataPrecision _ self next.	dataPrecision = 8		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].	height _ self nextWord.	width _ self nextWord.	n _ self next.	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].	(length - (self position - markerStart)) ~= (n * 3)		ifTrue: [self error: 'component length is incorrect'].	components _ Array new: n.	1 to: components size do:		[:i |		components			at: i			put:				(JPEGColorComponent new					id: self next;					"heightInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					widthInBlocks: (value bitAnd: 16r0F);"					widthInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					heightInBlocks: (value bitAnd: 16r0F);					qTableIndex: self next + 1)]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!parseStartOfInput	restartInterval _ 0.	densityUnit _ 0.	xDensity _ 1.	yDensity _ 1! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!parseStartOfScan	| length n id value dcNum acNum comp |	length _ self nextWord.	n _ self next.	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].	currentComponents _ Array new: n.	1 to: n do: [:i |		id _ self next.		value _ self next.		dcNum _ (value >> 4) bitAnd: 16r0F.		acNum _ value bitAnd: 16r0F.		comp _ components detect: [:c | c id = id].		comp			dcTableIndex: dcNum+1;			acTableIndex: acNum+1.		currentComponents at: i put: comp].	ss _ self next.	se _ self next.	value _ self next.	ah _ (value >> 4) bitAnd: 16r0F.	al _ value bitAnd: 16r0F.	self initialSOSSetup.	self perScanSetup.	sosSeen _ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 9/17/1998 01:02'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | Array new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!skipMarker	| length markerStart |	markerStart _ self position.	length _ self nextWord.	self next: length - (self position - markerStart)! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 17:10'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte _ self decodeByteWithTable: huffmanDC.	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte _ aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i _ 2.	[i <= DCTSize2] whileTrue:		[byte _ self decodeByteWithTable: huffmanAC.		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i _ i + zeroCount.				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].		i _ i + 1]		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:24'!decodeByteWithTable: aHuffmanTable	| look nb length code |	look _ self peekBits: lookahead.	(look >= 0 and: [(nb _ aHuffmanTable lookaheadBits at: look+1) ~= 0])		ifTrue:			[self getBits: nb.			^ aHuffmanTable lookaheadSymbol at: look+1].	length _ 1.	code _ self getBits: length.	[code > (aHuffmanTable maxcode at: length)] whileTrue:		[code _ code << 1 + (self getBits: 1).		length _ length + 1].	length > 16 ifTrue: [self error: 'bad encoding value in bit stream'].	^ aHuffmanTable valueForCode: code length: length.				! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/23/97 13:50'!decodeMCU	| comp |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	mcuMembership withIndexDo:		[:ci :i |		comp _ currentComponents at: ci.		self			decodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)].	restartsToGo _ restartsToGo - 1.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:56'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:			[byte _ self next.			(byte = 16rFF and: [(stream peekFor: 16r00) not])					ifTrue:						[stream position: stream position - 1.						^0].			bitBuffer _ bitBuffer << 8 bitOr: byte.			bitsInBuffer _ bitsInBuffer + 8].	^ bitsInBuffer! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:54'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer				ifTrue:					[self error: 'not enough bits available to decode']].	value _ bitBuffer >> (bitsInBuffer - requestedBits).	bitBuffer _ bitBuffer bitAnd: (1 << (bitsInBuffer - requestedBits) -1).	bitsInBuffer _ bitsInBuffer - requestedBits.	^ value		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 12:46'!peekBits: requestedBits	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer ifTrue: [^ -1]].	^ bitBuffer >> (bitsInBuffer - requestedBits)		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 19:40'!processRestart	bitBuffer _ 0.	bitsInBuffer _ 0.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 09:43'!scaleAndSignExtend: aNumber inFieldWidth: w	^ aNumber < (1 << (w - 1))		ifTrue: [aNumber + (1 << w) negated + 1]		ifFalse: [aNumber]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:16'!dctFloatRangeLimit: value	^ (value / 8.0) + FloatSampleOffset.! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 _ (anArray at: i) * (qt at: i).		t1 _ (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 _ (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 _ (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 _ t0 + t2.		t11 _ t0 - t2.		t13 _ t1 + t3.		t12 _ (t1 - t3) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		t4 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 _ (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 _ (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 _ (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 _ t6 + t5.		z10 _ t6 - t5.		z11 _ t4 + t7.		z12 _ t4 - t7.		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |		t10 _ (ws at: (i+1)) + (ws at: (i+5)).		t11 _ (ws at: (i+1)) - (ws at: (i+5)).		t13 _ (ws at: (i+3)) + (ws at: (i+7)).		t12 _ ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		z13 _ (ws at: (i+6)) + (ws at: (i+4)).		z10 _ (ws at: (i+6)) - (ws at: (i+4)).		z11 _ (ws at: (i+2)) + (ws at: (i+8)).		z12 _ (ws at: (i+2)) - (ws at: (i+8)).		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'di 9/15/1998 14:29'!idctBlockInt: anArray component: aColorComponent	|  qt ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	shift _ 1 bitShift: ConstBits - Pass1Bits.	1 to: DCTSize do:		[:i |		anACTerm _ (1 to: DCTSize-1)			detect: [:row | (anArray at: (row * DCTSize + i)) ~= 0]			ifNone: [nil].		anACTerm isNil			ifTrue:				[dcval _ (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.				(0 to: DCTSize-1) do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 _ (z2 + z3) * FIXn0n541196100.				t2 _ z1 + (z3 * FIXn1n847759065 negated).				t3 _ z1 + (z2 * FIXn0n765366865).				z2 _ (anArray at: i) * (qt at: i).				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 _ (z2 + z3) bitShift: ConstBits.				t1 _ (z2 - z3) bitShift: ConstBits.				t10 _ t0 + t3.				t13 _ t0 - t3.				t11 _ t1 + t2.				t12 _ t1 - t2.				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 _ t0 + t3.				z2 _ t1 + t2.				z3 _ t0 + t2.				z4 _ t1 + t3.				z5 _ (z3 + z4) * FIXn1n175875602.				t0 _ t0 * FIXn0n298631336.				t1 _ t1 * FIXn2n053119869.				t2 _ t2 * FIXn3n072711026.				t3 _ t3 * FIXn1n501321110.				z1 _ z1 * FIXn0n899976223 negated.				z2 _ z2 * FIXn2n562915447 negated.				z3 _ z3 * FIXn1n961570560 negated.				z4 _ z4 * FIXn0n390180644 negated.				z3 _ z3 + z5.				z4 _ z4 + z5.				t0 _ t0 + z1 + z3.				t1 _ t1 +z2 +z4.				t2 _ t2 + z2 + z3.				t3 _ t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].	"Pass 2: process rows from work array, store back into anArray"	shift _ 1 bitShift: ConstBits + Pass1Bits + 3.	(0 to: DCTSize2-DCTSize by: DCTSize) do:		[:i |		z2 _ ws at: i + 3.		z3 _ ws at: i + 7.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * FIXn1n847759065 negated).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 8).		t1 _ ws at: (i + 6).		t2 _ ws at: (i + 4).		t3 _ ws at: (i + 2).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * FIXn0n899976223 negated.		z2 _ z2 * FIXn2n562915447 negated.		z3 _ z3 * FIXn1n961570560 negated.		z4 _ z4 * FIXn0n390180644 negated.		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 21:25'!idctMCU	| comp |	self useFloatingPoint		ifTrue:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockFloat: (mcuSampleBuffer at: i) component: comp]]		ifFalse:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockInt: (mcuSampleBuffer at: i) component: comp]]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!scaleQuantizationTable: table	| index |	index _ 1.	1 to: DCTSize do:		[:row |		1 to: DCTSize do:			[:col |			table at: index				put: ((table at: index) * (QTableScaleFactor at: row) *					(QTableScaleFactor at: col)) rounded.			index _ index + 1]].	^ table! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 18:53'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - FloatSampleOffset.		cr _ crSampleStream nextSample - FloatSampleOffset.		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:55'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample) + greenResidual.		y > MaxSample ifTrue: [y _ MaxSample].		greenResidual _ y bitAnd: ditherMask.		y _ y bitAnd: MaxSample - ditherMask.		y < 1 ifTrue: [y _ 1].		bits at: i put: (y<<16) + (y<<8) + y].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:58'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - SampleOffset.		cr _ crSampleStream nextSample - SampleOffset.		red _ y + ((FIXn1n40200 * cr) // 65536) + redResidual.		red > MaxSample			ifTrue: [red _ MaxSample]			ifFalse: [red < 0 ifTrue: [red _ 0]].		redResidual _ red bitAnd: ditherMask.		red _ red bitAnd: MaxSample - ditherMask.		red < 1 ifTrue: [red _ 1].		green _ y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + greenResidual.		green > MaxSample			ifTrue: [green _ MaxSample]			ifFalse: [green < 0 ifTrue: [green _ 0]].		greenResidual _ green bitAnd: ditherMask.		green _ green bitAnd: MaxSample - ditherMask.		green < 1 ifTrue: [green _ 1].		blue _ y + ((FIXn1n77200 * cb) // 65536) + blueResidual.		blue > MaxSample			ifTrue: [blue _ MaxSample]			ifFalse: [blue < 0 ifTrue: [blue _ 0]].		blueResidual _ blue bitAnd: ditherMask.		blue _ blue bitAnd: MaxSample - ditherMask.		blue < 1 ifTrue: [blue _ 1].		bits at: i put: (red bitShift: 16) + (green bitShift: 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 21:27'!colorConvertMCU	^ currentComponents size = 3		ifTrue:			[self useFloatingPoint				ifTrue: [self colorConvertFloatYCbCrMCU]				ifFalse: [self colorConvertIntYCbCrMCU]]		ifFalse: [self colorConvertGrayscaleMCU]! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:43'!sampleFloatRangeLimit: aNumber	^ (aNumber rounded max: 0) min: MaxSample! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'di 9/15/1998 14:30'!sampleRangeLimit: aNumber	aNumber < 0 ifTrue: [^ 0].	aNumber > MaxSample ifTrue: [^ MaxSample].	^ aNumber! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hACTable	hACTable ifNil: [hACTable _ Array new: HuffmanTableSize].	^ hACTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hDCTable	hDCTable ifNil: [hDCTable _ Array new: HuffmanTableSize].	^ hDCTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!qTable	qTable ifNil: [qTable _ Array new: QuantizationTableSize].	^ qTable! !!JPEGReadWriter methodsFor: 'error handling' stamp: 'tao 10/19/97 12:25'!notSupported: aString	self error: aString , ' is not currently supported'! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'tao 9/18/1998 09:06'!initialize	"general constants"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	FloatSampleOffset _ SampleOffset asFloat.	DCTSize2 _ DCTSize squared.	QuantizationTableSize _ 4.	HuffmanTableSize _ 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits _ 13.	Pass1Bits _ 2.	DCTK1 _ 2 sqrt.	DCTK2 _ 1.847759065.	DCTK3 _ 1.082392200.	DCTK4 _ -2.613125930.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder _ #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor _ (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dithering masks"	(DitherMasks _ Dictionary new)		add: 0 -> 0;		add: 1 -> 127;		add: 2 -> 63;		add: 4 -> 63;		add: 8 -> 31;		add: 16 -> 7;		add: 32 -> 0.	"dictionary of marker parsers"	(JFIFMarkerParser _ Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:05'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. stop stepping if realJoystickIndex is nil; that means we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt m mCenter r scaledPt |	realJoystickIndex ifNil: [^ self stopStepping].	threshold _ 30.	joyMax _ 350.	joyPt _ Sensor joystickXY: realJoystickIndex.	joyPt x abs < threshold ifTrue: [joyPt _ 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt _ joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue _ joyPt.	m _ handleMorph.	mCenter _ m center.	r _ m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt _ r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:00'!stepTime	^ 0! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set X range' action: #setXRange.	aCustomMenu add: 'set Y range' action: #setYRange.	autoCenter		ifTrue: [aCustomMenu add: 'turn auto-center off' action: #toggleAutoCenter]		ifFalse: [aCustomMenu add: 'turn auto-center on' action: #toggleAutoCenter].	realJoystickIndex		ifNil: [aCustomMenu add: 'track real joystick' action: #trackRealJoystick]		ifNotNil: [aCustomMenu add: 'stop tracking joystick' action: #stopTrackingJoystick].! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex _ nil.	self stopStepping.! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:59'!trackRealJoystick	| s |	s _ FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex _ Number readFromString: s.	self startStepping.! !I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!I am a 7-segment LED that can display a decimal digit!!LedDigitMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:01'!initialize	super initialize.	color _ Color green.	highlighted _ false.	digit _ 0.! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit	^ digit! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit _ anInteger \\ 10	"make sure it stays between 0 and 9"! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 17:00'!highlighted	^ highlighted! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 17:03'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor _ highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor _ color darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ ((hThickness - thickness) // 2) max: 0.	hOffset _ ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 13:58'!drawOnFills: aRectangle	^ true! !!LedDigitMorph class methodsFor: 'initialization' stamp: 'tao 5/18/1998 12:29'!initialize	HSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments _ {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}}.	VSegments _ {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}}.! !I am a collection of LED digits that can display a decimal value.  The display can be set to flash by sending flash: true.!!LedMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:38'!initialize	super initialize.	flashing _ false.	flash _ false.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:51'!color: aColor	color _ aColor.	self submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!digits	^ digits! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits _ aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash	^ flash! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!value	^ value! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value _ aNumber.	val _ value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val _ val // 10].	self changed.! !!LedMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 14:00'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color darker darker.! !!LedMorph methodsFor: 'change reporting' stamp: 'tao 5/18/1998 13:53'!layoutChanged	super layoutChanged.	submorphs withIndexDo:		[:m :i |		m			position: self position + (((i-1) * self width / digits) rounded @ 0);			extent: (self width / digits) rounded @ self height]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:42'!step	(flash or: [flashing])		ifTrue:			[flashing _ flashing not.			self submorphsDo: [:m | m highlighted: flashing]]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:44'!stepTime	^ 500! !The LessHTMLformatter provides a few more plaintext notations to swikify,to avoid typing HTML a bit more.  Used in rendering -- see FileListrenderFile!]style[(133 19)f1,f1LFileList renderFile;!!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/3/1998 17:31'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll:'<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll:'<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll:'<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll:'<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll:'<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll:'<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll:aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 9/21/1998 23:03'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse: [			source _ class sourceMethodAt: selector.			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 18:59'!font	| style |	textStyle		ifNil: [style _ TextStyle default]		ifNotNil: [style _ textStyle].	^ style fontNamed: style fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle _ nil]		ifNotNil: [			textStyle _ TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'list access' stamp: 'jm 9/20/1998 17:10'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy style: textStyle.	selection _ 0.	self positionList.! !I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/17/1998 17:45'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 130@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 2) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease _ (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease _ 0].	releaseCount _ sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/2/1998 19:54'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples _ FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample: aNumber	firstSample _ (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain: aNumber	gain _ aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples: aSampleBuffer	leftSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!pitch: p	scaledIndexIncr _		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount _ 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples: aSampleBuffer	rightSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/19/1998 10:43'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive: 184>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo _ leftSamples ~~ rightSamples.	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.	i _ (2 * startIndex) - 1.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex _ sampleIndex]				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m _ scaledIndex bitAnd: LoopIndexFractionMask.		rightVal _ leftVal _			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal _				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		rightVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0].			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].	count _ count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38'!reset	super reset.	count _ initialCount.	scaledIndex _ firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:30'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen _ scaledLoopLength asFloat / LoopIndexScaleFactor.	ed _ WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 07:49'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples _ (leftSamples size - startIndex) + 1.	fftWinSize _ 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize _ fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize _ fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i _ self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:26'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft _ self fftAt: startIndex.	powerArray _ self normalizedResultsFromFFT: fft.	threshold _ powerArray max / 50.0.	indices _ (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i].				s _ rightSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:47'!comeFullyUpOnReload	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ leftSamples]		ifFalse: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ SoundBuffer fromByteArray: self rightSamples].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:48'!objectToStoreOnDataStream    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	| objToStore |	objToStore _ self clone.	objToStore leftSamples: leftSamples asByteArray.	self isStereo		ifTrue: [objToStore rightSamples: rightSamples asByteArray]		ifFalse: [objToStore rightSamples: objToStore leftSamples].	^ objToStore! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 08:11'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo _ self isStereo.	leftSamples _ leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples _ rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples _ leftSamples].	originalSamplingRate _ originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength _ (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength _ self loopLength / 2.0].	firstSample _ (firstSample + 1) // 2.	lastSample _ (lastSample + 1) // 2.	loopEnd _ (loopEnd + 1) // 2.	scaledLoopLength _ (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 07:48'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu _ ((windowSize - 1) log: 2) truncated + 1.	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/16/1998 17:48'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r _ (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg _ r sum / r size.	^ r collect: [:v | v / avg].! !!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor _ 512.	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !I am a parser for mail files in the format output by the Unix 'mh' program.!!MHMailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream textStart textSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue:			["if possible, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile).			 fileStream _ nil]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue:		["skip the three-line message delimiter"		 3 timesRepeat: [MailDB skipRestOfLine: stream].		 textStart _ stream position.		 self scanToNextMessageIn: stream.		 textSize _ stream position - textStart.		 stream position: textStart.		 msgText _ stream next: textSize.		 aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MHMailInboxFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message delimiter (if there is one) or at the end of the stream."	| msgStart |	[true] whileTrue:		[(aStream skipTo: $:) ifFalse: [^false].	"end of stream"		 msgStart _ aStream position - 1.		 ((MailDB readStringLineFrom: aStream) = ':::::::::::::') ifTrue:			["looking good..."			 MailDB skipRestOfLine: aStream.	"skip message number"			 ((MailDB readStringLineFrom: aStream) = '::::::::::::::') ifTrue:				["found a message!!"				 aStream position: msgStart. ^true]].		 "false alarm, keep scanning"		 aStream position: msgStart + 1].! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 18:29'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	chunkSize = 6		ifFalse: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:10'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			"Note: Tracks without note events are currently not saved to			 eliminate clutter in the score player. In control applications,			 this can be easily changed by modifying the following test."			(self trackContainsNotes: track) ifTrue: [				tracks add: track asArray.				info _ WriteStream on: (String new: 100).				strings do: [:s | info nextPutAll: s; cr].				trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:00'!guessMissingInstrumentNames	"Attempt to guess missing instrument names from the first program change in that track."	| progChange instrIndex instrName |	1 to: tracks size do: [:i |		(trackInfo at: i) isEmpty ifTrue: [			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: [nil].			progChange ifNotNil: [				instrIndex _ progChange program + 1.				instrName _ self class standardMIDIInstrumentNames at: instrIndex.				trackInfo at: i put: instrName]]].! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!readChunkType	"Read a chunk ID string from the next 4 bytes."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 19:19'!scanForMIDIHeader	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."	| asciiM p lastSearchPosition byte restOfHeader |	asciiM _ $M asciiValue.	stream skip: -3.	p _ stream position.	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [		[(byte _ stream next) ~= asciiM and: [byte ~~ nil]] whileTrue.  "find the next 'M' or file end"		restOfHeader _ (stream next: 3) asString.		restOfHeader = 'Thd'			ifTrue: [^ self]			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].		p _ stream position].	self error: 'MIDI header chunk not found'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!splitIntoTracks	"Split a type zero MIDI file into separate tracks by channel number."	| newTempoMap newTracks |	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].	newTempoMap _ OrderedCollection new.	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].	tracks first do: [:e |		e isTempoEvent			ifTrue: [newTempoMap addLast: e]			ifFalse: [(newTracks at: e channel + 1) addLast: e]].	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].	newTracks _ newTracks select: [:t | self trackContainsNotes: t].	tracks _ newTracks collect: [:t | t asArray].	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!playStream: binaryStream	ScorePlayerMorph		openOn: (self scoreFromStream: binaryStream)		title: 'a MIDI stream'! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 5/29/1998 17:12'!playURLNamed: urlString	| titleString |	titleString _ urlString		copyFrom: (urlString findLast: [:c | c=$/]) + 1		to: urlString size.	ScorePlayerMorph		openOn: (self scoreFromURL: urlString)		title: titleString.! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!scoreFromStream: binaryStream	|  score |	score _ (self new readMIDIFrom: binaryStream) asScore.	^ score! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 9/12/1998 19:57'!standardMIDIInstrumentNames	"Answer an array of Standard MIDI instrument names."	^ #(		'Grand Piano'		'Bright Piano'		'Electric Grand Piano'		'Honky-tonk Piano'		'Electric Piano 1'		'Electric Piano 2'		'Harpsichord'		'Clavichord'		'Celesta'		'Glockenspiel'		'Music Box'		'Vibraphone'		'Marimba'		'Xylophone'		'Tubular Bells'		'Duclimer'		'Drawbar Organ'		'Percussive Organ'		'Rock Organ'		'Church Organ'		'Reed Organ'		'Accordion'		'Harmonica'		'Tango Accordion'		'Nylon Guitar'		'Steel Guitar'		'Electric Guitar 1'		'Electric Guitar 2'		'Electric Guitar 3'		'Overdrive Guitar'		'Distorted Guitar'		'Guitar Harmonics'		'Acoustic Bass'		'Electric Bass 1'		'Electric Bass 2'		'Fretless Bass'		'Slap Bass 1'		'Slap Bass 2'		'Synth Bass 1'		'Synth Bass 2'		'Violin'		'Viola'		'Cello'		'Contrabass'		'Tremolo Strings'		'Pizzicato Strings'		'Orchestral Harp'		'Timpani'		'String Ensemble 1'		'String Ensemble 2'		'Synth Strings 1'		'Synth Strings 2'		'Choir Ahhs'		'Choir Oohs'		'Synth Voice'		'Orchestra Hit'		'Trumpet'		'Trombone'		'Tuba'		'Muted Trumpet'		'French Horn'		'Brass Section'		'Synth Brass 1'		'Synth Brass 2'		'Soprano Sax'		'Alto Sax'		'Tenor Sax'		'Baritone Sax'		'Oboe'		'English Horn'		'Bassoon'		'Clarinet'		'Piccolo'		'Flute'		'Recorder'		'Pan Flute'		'Blown Bottle'		'Shakuhachi'		'Whistle'		'Ocarina'		'Lead 1 (square)'		'Lead 2 (sawtooth)'		'Lead 3 (calliope)'		'Lead 4 (chiff)'		'Lead 5 (charang)'		'Lead 6 (voice)'		'Lead 7 (fifths)'		'Lead 8 (bass+lead)'		'Pad 1 (new age)'		'Pad 2 (warm)'		'Pad 3 (polysynth)'		'Pad 4 (choir)'		'Pad 5 (bowed)'		'Pad 6 (metallic)'		'Pad 7 (halo)'		'Pad 8 (sweep)'		'FX 1 (rain)'		'FX 2 (soundtrack)'		'FX 3 (crystals)'		'FX 4 (atmosphere)'		'FX 5 (brightness)'		'FX 6 (goblins)'		'FX 7 (echoes)'		'FX 8 (sci-fi)'		'Sitar'		'Banjo'		'Shamisen'		'Koto'		'Kalimba'		'Bagpipe'		'Fiddle'		'Shanai'		'Tinkle Bell'		'Agogo'		'Steel Drum'		'Woodblock'		'Taiko Drum'		'Melodic Tom'		'Synth Drum'		'Reverse Cymbal'		'Guitar Fret Noise'		'Breath Noise'		'Seashore'		'Bird Tweet'		'Telephone Ring'		'Helicopter'		'Applause'		'Gunshot')! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 14:55'!addAmbientEvent: evt	| i |	ambientTrack == nil ifTrue: [^ ambientTrack _ Array with: evt].	i _ ambientTrack findFirst: [:e | e time >= evt time].	i = 0 ifTrue: [^ ambientTrack _ ambientTrack , (Array with: evt)].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i-1 with: (Array with: evt)! !!MIDIScore methodsFor: 'all' stamp: 'di 8/1/1998 15:31'!ambientEventAfter: eventIndex ticks: scoreTicks	| evt |	(ambientTrack == nil or: [eventIndex > ambientTrack size]) ifTrue: [^ nil].	evt _ ambientTrack at: eventIndex.	evt time <= scoreTicks ifTrue: [^ evt].	^ nil! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 20:34'!ambientTrack	^ ambientTrack! !!MIDIScore methodsFor: 'all' stamp: 'jm 9/10/1998 17:22'!eventForTrack: trackIndex after: eventIndex ticks: scoreTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time > scoreTick ifTrue: [^ nil].	^ evt! !!MIDIScore methodsFor: 'all' stamp: 'jm 8/6/1998 21:16'!jitterStartAndEndTimesBy: mSecs	| r range halfRange oldEnd newEnd newStart |	r _ Random new.	range _ 2.0 * mSecs.	halfRange _ mSecs.	tracks do: [:t |		t do: [:e |			e isNoteEvent ifTrue: [				oldEnd _ e time + e duration.				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).				newStart _ e time + ((r next * range) asInteger - halfRange).				e time: newStart.				e duration: (newEnd - newStart)]]].				! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 08:04'!otherPlayersDo: playerBlock	"Not elegant -- scan for any players registered in the ambientTrack,	and evaluate the block for them."	| players p |	ambientTrack == nil ifTrue: [^ self].	players _ Set new.	ambientTrack do:		[:evt | p _ evt relatedPlayer.		p ifNotNil: [players add: p]].	players do: playerBlock! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!pauseFrom: scorePlayer	self otherPlayersDo: [:p | p pauseFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 21:52'!removeAmbientEventWithMorph: aMorph	| i |	ambientTrack == nil ifTrue: [^ self].	i _ ambientTrack findFirst: [:e | e morph == aMorph].	i = 0 ifTrue: [^ self].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i with: Array new! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resetFrom: scorePlayer	self otherPlayersDo: [:p | p resetFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resumeFrom: scorePlayer	self otherPlayersDo: [:p | p resumeFrom: scorePlayer]! !a MIME object, along with its type and the URL it was found at (if any)!!MIMEDocument methodsFor: 'printing' stamp: 'ls 7/23/1998 20:12'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', ';		nextPutAll: self content size printString;		nextPutAll: ' bytes)'.! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url _ aUrl! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!content	"return the raw data in this object"	^content! !!MIMEDocument methodsFor: 'access' stamp: 'ls 9/18/1998 05:41'!contentStream	"return a RWBinaryOrTextStream on the contents"	^(RWBinaryOrTextStream with: self content) reset! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!contentType	^self mainType, '/', self subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!mainType	#XXX.  "is there a better name?"	^mainType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!subType	^subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!type	^mainType, '/', subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 8/12/1998 00:25'!url	"returns the URL this object was downloaded from.  It may legitimately be nil"	^url! !!MIMEDocument class methodsFor: 'content-types' stamp: 'ls 8/8/1998 03:15'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension _ url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension _ (extension findTokens: '.') last asLowercase.	extension = 'html' ifTrue: [ ^'text/html' ].	extension = 'htm' ifTrue:[ ^'text/html' ].	extension = 'txt' ifTrue: [ ^'text/plain' ].	extension = 'gif' ifTrue: [ ^'image/gif' ].	extension = 'jpg' ifTrue: [ ^'image/jpeg' ].	extension = 'jpeg' ifTrue: [ ^'image/jpeg' ].	extension = 'mid' ifTrue: [ ^'audio/midi' ].	^self defaultContentType! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!content: aString	^self contentType: self defaultContentType  content: aString! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 08:00'!contentType: aString  content: content	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/12/1998 00:26'!contentType: aString  content: content  url: aUrl	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl asUrl.	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!defaultContentType	^'application/octet-stream'! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/22/1998 14:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !Parse mail addresses.  The basic syntax is:	addressList := MailAddressParser addressesIn: aStringThis currently only returns the bare addresses, but it could also return a list of the address "source codes".  For example, if you give it "Joe <joe@foo>, <jane>", it will currently return a list ('joe@foo' 'jane').  It would be nice to also get a list ('Joe <joe@foo>'  '<jane>').!!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:31'!addToAddress	"add the last token to the address.  removes the token from the collection"	curAddrTokens addFirst: (tokens removeLast)! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!finishAddress	"we've finished one address.  Bundle it up and add it to the list of addresses"	| address |	address _ String streamContents: [ :str |		curAddrTokens do: [ :tok | str nextPutAll: tok text ] ].	addresses addFirst: address.	curAddrTokens _ nil.! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!startNewAddress	"set up data structures to begin a new address"	(curAddrTokens ~~ nil) ifTrue: [		self error: 'starting new address before finishing the last one!!' ].	curAddrTokens _ OrderedCollection new.	! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!grabAddressWithRoute	"grad an address of the form 'Descriptive Text <real.address@c.d.e>"		self startNewAddress.	tokens removeLast.	"remove the >"	"grab until we see a $<"	[ 		tokens isEmpty ifTrue: [			self error: '<> are not matched' ].		tokens last type = $<	] whileFalse: [ self addToAddress ].	tokens removeLast.  "remove the <"	self removePhrase.	self finishAddress! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:25'!grabAddresses	"grab all the addresses in the string"	| token |	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token _ tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:32'!grabBasicAddress	"grad an address of the form a.b@c.d.e"		self startNewAddress.	"grab either the domain if specified, or the domain if not"	self addToAddress.		[ tokens last type = $. ] whileTrue: [		"add name-dot pairs of tokens"		self addToAddress.		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'bad token in address: ', tokens last text ].		self addToAddress ].	(tokens isEmpty or: [ tokens last type ~= $@]) ifTrue: [		"no domain specified"		self finishAddress ]	ifFalse: [		"that was the domain.  check that no QuotedString's slipped in"		curAddrTokens do: [ :tok |			tok type = #QuotedString ifTrue: [				self error: 'quote marks are not allowed within a domain name (',					tok text, ')'. ] ].		"add the @ sign"		self addToAddress.		"add the local part"		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'invalid local part for address: ', tokens last text ].		self addToAddress.		"add word-dot pairs if there are any"		[ tokens isEmpty not and: [ tokens last type = $. ] ] whileTrue: [			self addToAddress.			(tokens isEmpty not 			  and: [ #(Atom QuotedString) includes: tokens last type ]) 			  ifTrue: [ self addToAddress ] ].		self finishAddress ].! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:07'!grabGroupAddress	"grab an address of the form 'phrase : address, address, ..., address;'"	"I'm not 100% sure what this format means, so I'm just returningthe list of addresses between the : and ;   -ls  (if this sounds right to someone, feel free to remove this comment :)"	"remove the $; "	tokens removeLast.	"grab one address each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		tokens isEmpty ifTrue: [			"no matching :"			^self error: 'stray ; in address list'. ].		tokens last type = $:	] whileFalse: [		"delegate to either grabAddressWithRoute, or grabBasicAddress.  nested groups are not allowed"		tokens last type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: tokens last type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ]	].	tokens removeLast.   "remove the :"	self removePhrase.! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!removePhrase	"skip most characters to the left of this"	[		tokens isEmpty not and: [			#(Atom QuotedString $. $@) includes: (tokens last type) ]	] whileTrue: [ tokens removeLast ].! !!MailAddressParser methodsFor: 'private-initialization' stamp: 'ls 9/13/1998 01:25'!initialize: tokenList	tokens _ tokenList asOrderedCollection copy.	addresses _ OrderedCollection new.! !!MailAddressParser class methodsFor: 'examples' stamp: 'ls 9/13/1998 02:08'!example	"test out several correct formats"	"MailAddressParser example"	^self addressesIn: 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'! !!MailAddressParser class methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:34'!addressesIn: aString	"return a collection of the bare addresses listed in aString"	| tokens |	tokens _ MailAddressTokenizer tokensIn: aString.	^(self new initialize: tokens) grabAddresses! !a single token from an RFC822 mail address.  Used internally in MailAddressParser!!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!text	^text! !!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!type	^type! !!MailAddressToken methodsFor: 'private' stamp: 'ls 9/12/1998 20:24'!type: type0  text: text0	type _ type0.	text _ text0.! !!MailAddressToken methodsFor: 'printing' stamp: 'ls 9/12/1998 20:40'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self type asString.	aStream nextPut: $|.	aStream nextPutAll: self text.	aStream nextPut: $].! !!MailAddressToken class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:31'!type: type  text: text	^self new type: type text: text! !Divides an address into tokens, as specified in RFC 822.  Used by MailAddressParser.!!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!atEndOfChars	^pos > text size! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextAtom	| start end |	start _ pos.	pos _ text indexOfAnyOf: CSNonAtom startingAt: start ifAbsent: [ text size + 1].	end _ pos - 1.	^MailAddressToken		type: #Atom		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:52'!nextChar	self atEndOfChars ifTrue: [ ^nil ].	pos _ pos + 1.	^text at: (pos-1)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:39'!nextDomainLiteral	| start end |	start _ pos.	end _ text indexOf: $] startingAt: start ifAbsent: [ 0 ].	end = 0 ifTrue: [		"not specified"		self error: 'saw [ without a matching ]' ].	pos _ end+1.	^MailAddressToken		type: #DomainLiteral		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!nextQuotedString	| res c |	res _ WriteStream on: String new.	res nextPut: self nextChar.   "record the starting quote"	[ self atEndOfChars ] whileFalse: [		c _ self nextChar.		c = $\ ifTrue: [			res nextPut: c.			res nextPut: self nextChar ]		ifFalse: [			c = $" ifTrue: [				res nextPut: c.				^MailAddressToken type: #QuotedString  text: res contents ]			ifFalse: [				res nextPut: c ] ] ].	"hmm, never saw the final quote mark"	^MailAddressToken type: #QuotedString  text: (res contents, '"')! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextSpecial	| c |	c _ self nextChar.	^MailAddressToken type: c  text: c asString.! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!nextToken	| c |	self skipSeparatorsAndComments.	c _ self peekChar.	c ifNil: [ ^nil ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:15'!peekChar	^text at: pos ifAbsent: [ nil ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 02:02'!skipComment	| nestLevel paren |	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]. ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:14'!skipSeparators	pos _ text indexOfAnyOf: CSNonSeparators  startingAt: pos  ifAbsent: [ text size + 1 ].! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!skipSeparatorsAndComments	[	self skipSeparators.		self peekChar = $(	] whileTrue: [ self skipComment ]! !!MailAddressTokenizer methodsFor: 'initialization' stamp: 'ls 9/12/1998 20:13'!initialize: aString	text _ aString.	pos _ 1.! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!atEnd	^self peek == nil! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:51'!next	| ans |	cachedToken ifNil: [ ^self nextToken ].	ans _ cachedToken.	cachedToken _ nil.	^ans! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!peek	cachedToken ifNil: [ cachedToken _ self nextToken. ].		^cachedToken	! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:54'!forString: aString	^super basicNew initialize: aString! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/13/1998 01:34'!tokensIn: aString	"return a collection of the tokens in aString"	^(self forString: aString) upToEnd! !!MailAddressTokenizer class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:02'!initialize	"MailAddressTokenizer initialize"	CSNonSeparators _ CharacterSet separators complement.	CSSpecials _ CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonAtom _ CharacterSet separators.	CSNonAtom addAll: CSSpecials.	0 to: 31 do: [ :c |		CSNonAtom add: (Character value: c) ].	CSNonAtom add: (Character value: 127).	CSParens _ CharacterSet empty.	CSParens addAll: '()'.! !I am the in-memory representation of a Celeste mail database. A mail database named "current" consists of three files:	current.messages	-- an append-only file containing the full content of all messages	current.index		-- an index of all messages in the messages file that maps unique						   message ID's to index entries containing some header information						   and the offset of the full message in the .messages file	current.categories	-- maps category names to collections of message ID'sEach open mail database has a MailDB object that manages these three files. Operations such as fetching a message given its unique ID and finding out which messages are in which category are supported by the MailDB object. It also supports incorporating new messages (reading mail), message editing and deletions, and message file compaction and recovery.!!MailDB methodsFor: 'initialize-release'!close	"Save and close the messageFile."	self saveDB.	(messageFile notNil) ifTrue: [messageFile close].	rootFilename _ nil.	messageFile _ indexFile _ categoriesFile _ nil.! !!MailDB methodsFor: 'initialize-release'!openOn: rootNameString	"Open a mail database with the given root file name."	| status |	rootFilename _ rootNameString.	status _ self dbStatus.	messageFile _ indexFile _ categoriesFile _ nil.	(status = #exists) ifTrue: [^self openDB].	(status = #partialDatabase) ifTrue: [^self recoverDB].	(status = #doesNotExist) ifTrue: [^self createDB].! !!MailDB methodsFor: 'initialize-release'!release	"Close this database."	self close.	super release.! !!MailDB methodsFor: 'open-create-save'!createDB	"Create a new mail database."	(self confirm:'Shall I create a new mail databasenamed: ', rootFilename, '?')		ifFalse:	"abort create operation"			[rootFilename _ nil.			 self release.			^nil].	self openDB.							"creates new DB files"	self saveDB.							"save the new mail database to disk"! !!MailDB methodsFor: 'open-create-save' stamp: 'jm 8/14/1998 13:43'!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	messageFile _ FileDirectory default includesKey: rootFilename, '.messages'.	indexFile _ FileDirectory default includesKey: rootFilename, '.index'.	categoriesFile _ FileDirectory default includesKey: rootFilename, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'open-create-save'!openDB	"Open an existing mail database."	Transcript show: 'Opening mail database ''', rootFilename, '''...'.	messageFile _ MessageFile openOn: rootFilename, '.messages'.	indexFile _ IndexFile openOn: rootFilename, '.index' messageFile: messageFile.	categoriesFile _ CategoriesFile openOn: rootFilename, '.categories'.	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'open-create-save'!recoverDB	"Open a mail database with the given root file name."	(self confirm:'The mail database named:    ', rootFilename, 'appears to be damaged. Shall I fix it?')		ifFalse: [^self release].	self openDB.	self compact.! !!MailDB methodsFor: 'open-create-save'!rootFilename	"Answer my root filename."	^rootFilename! !!MailDB methodsFor: 'open-create-save'!saveDB	"Write all database files to disk."	(rootFilename notNil)		ifTrue: [Transcript show: 'Saving mail database ''', rootFilename, '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	(messageFile notNil) ifTrue: [messageFile save].	(indexFile notNil) ifTrue: [indexFile save].	(categoriesFile notNil) ifTrue: [categoriesFile save].	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/14/1998 06:38'!POPMailFrom: server  userName: userName password: passworddoFormatting: doFormatting deleteInbox: deleteInbox informingUser: informUser	"Download mail via POP and append to this mail database. Answer the number of messages fetched."	| nextID msg location connection numMessages msgText displayMessage  |	"is there any mail?"		"connect to the POP server"	connection _ POPSocket createIfFail: [ ^0 ].	self do: [		connection serverName: server.			connection userName: userName.		connection password: password.		connection addProgressObserver: Transcript.		connection connectToPOP. ] 	andInform: (informUser ifTrue: ['connecting to ', server] ifFalse: [nil]).	connection isConnected ifFalse: [ ^ 0 ].	"download each message"	numMessages _ connection numMessages.	displayMessage _ 'downloading ', numMessages printString, ' messages'.	self showProgress: informUser from: 0 to: numMessages message: displayMessage during: [ :bar |		nextID _ self nextUnusedID.		1 to: numMessages do: [ :messageNum |			bar value: messageNum.			msgText _ connection retrieveMessage: messageNum.			"save the message"			msg _ MailMessage from: msgText.			doFormatting ifTrue: [msg format].			location _ messageFile basicAppend: msg text id: nextID.			indexFile				at: nextID				put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).			categoriesFile file: nextID inCategory: 'new'.			nextID _ nextID + 1.				"delete the message from the server, if desired"			deleteInbox ifTrue: [ connection deleteMessage: messageNum ].		].		messageFile endAppend.		LastID _ nextID.		connection disconnectFromPOP.		"snapshot the database and remove the inbox file"		self saveDB.	].	^numMessages! !!MailDB methodsFor: 'fetch-merge-compact'!appendMessages: msgBuffer messageFile: msgFile indexFile: idxFile	"Append the given collection of messages to the message file. msgBuffer is a collection of (message ID, message text) pairs."	| id msgText location entry |	msgBuffer do:		[: idAndText |		 id _ idAndText at: 1.		 msgText _ idAndText at: 2.		 location _ msgFile basicAppend: msgText id: id.		 entry _ indexFile			at: id			ifAbsent:				[IndexFileEntry					message: (MailMessage from: msgText)					location: location					messageFile: msgFile					msgID: id].		 entry _ (entry copy) location: location; textLength: msgText size.		 idxFile at: id put: entry].! !!MailDB methodsFor: 'fetch-merge-compact'!cleanUpCategories	"Prune the dead wood out of all categories."	categoriesFile categories do:		[: category |		 categoriesFile removeMessagesInCategory: category butNotIn: indexFile].! !!MailDB methodsFor: 'fetch-merge-compact'!compact	"Compact the message file and rebuild the index file. Answer an array containing with the number of messages and the number of bytes recovered."	| newMessageFile newIndexFile stats |	newMessageFile _ MessageFile openOn: rootFilename, '.messages.tmp'.	newIndexFile _ IndexFile openOn: rootFilename, '.index.tmp' messageFile: newMessageFile.	stats _ self copyUndeletedTo: newMessageFile indexFile: newIndexFile.	newMessageFile save.	newIndexFile save.	messageFile rename: rootFilename, '.messages.bak'.	indexFile rename: rootFilename, '.index.bak'.	newMessageFile rename: rootFilename, '.messages'.	newIndexFile rename: rootFilename, '.index'.	indexFile delete.	messageFile delete.	indexFile _ newIndexFile.	messageFile _ newMessageFile.	self cleanUpCategories.	categoriesFile save.	^stats! !!MailDB methodsFor: 'fetch-merge-compact'!copyUndeletedTo: newMsgFile indexFile: newIndexFile	"Copy all the undeleted messages in my current message file into the new message file, recording their locations in the new index file. Answer an array containing with the number of messages and the number of bytes recovered."	"Note: To minimize disk seeks, messages are buffered and written in large batches. You may wish to tune the amount of buffering if you have a particular shortage or abundance of physical memory. bufferLimit is the approximate number of bytes of messages that will be accumulated before writing the buffered messages to disk."	| bufferLimit msgBuffer bufferSize deletedCount deletedBytes |	Smalltalk garbageCollect.	bufferLimit _ Smalltalk bytesLeft // 2.	"use half of the available memory"	msgBuffer _ OrderedCollection new: 1000.	bufferSize _ 0.	deletedCount _ deletedBytes _ 0.	newMsgFile beginAppend.	messageFile messagesDo:		[: deleted : msgID : msgText |		 (deleted)			ifTrue:				[deletedCount _ deletedCount + 1.				 deletedBytes _ deletedBytes + msgText size]			ifFalse:				[msgBuffer addLast: (Array with: msgID with: msgText).				 bufferSize _ bufferSize + msgText size.				 (bufferSize >= bufferLimit) ifTrue:					[self						appendMessages: msgBuffer						messageFile: newMsgFile						indexFile: newIndexFile.					 msgBuffer _ OrderedCollection new: 1000.					 bufferSize _ 0]]].	"flush remaining buffered messages"	self		appendMessages: msgBuffer		messageFile: newMsgFile		indexFile: newIndexFile.	newMsgFile endAppend.	"return statistics"	^Array with: deletedCount with: deletedBytes! !!MailDB methodsFor: 'fetch-merge-compact'!fetchMailFrom: inboxFileName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given mail inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any mail?"	(StandardFileStream isAFileNamed: inboxFileName) ifFalse: [^0].	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo:		[: msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^count! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'jm 8/14/1998 16:47'!fetchNewsFrom: inboxPathName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given news inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any news?"	((FileDirectory on: inboxPathName) includesKey: 'news') ifFalse: [^ 0].	inbox _ RNInboxFile openOn: inboxPathName, ':news'.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox newsMessagesDo:		[: newsgroup : msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: newsgroup.		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^ count! !!MailDB methodsFor: 'fetch-merge-compact'!fileDuplicatesIn: categoryName	"MailDB someInstance fileDuplicatesIn: '.duplicates.'"	self fileAll: self findDuplicates inCategory: categoryName.! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/15/1998 22:30'!findDuplicates	"MailDB someInstance findDuplicates"	| msgsAtTime m duplicates list text1 msg1 msg2 id1 id2 |	msgsAtTime _ Dictionary new.	(self messagesIn: '.all.') do: [ :msgID |		m _ indexFile at: msgID.		(msgsAtTime includesKey: m time) ifFalse: [			msgsAtTime at: m time put: OrderedCollection new.		].		(msgsAtTime at: m time) add: (Array with: msgID with: m).	].	duplicates _ Set new.	msgsAtTime associationsDo: [ :assoc |		list _ assoc value asOrderedCollection.		list do: [ :arr1 |  			id1 _ arr1 at: 1.			msg1 _ arr1 at: 2.			text1 _ self getText: id1.			list do: [ :arr2 |				id2 _ arr2 at: 1.				msg2 _ arr2 at: 2.				(id1 < id2 and: 				 [ (duplicates includes: id2) not and:				 [ msg2 _ self getMessage: id2.  msg1 to = msg2 to and:				 [ msg1 subject = msg2 subject and: 				 [ msg1 from = msg2 from and:				 [ text1 = (self getText: id2) ] ] ] ] ]) ifTrue: [ duplicates add: id2 ]. ] ] ].	^duplicates asArray! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/17/1998 05:06'!importMailFrom: inboxFileName intoCategory: category	"Append the messages from the given mail inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any mail?"	(StandardFileStream isAFileNamed: inboxFileName) ifFalse: [^0].	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo:		[: msgText |		 msg _ MailMessage from: msgText.		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: category.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	^count! !!MailDB methodsFor: 'fetch-merge-compact'!mergeMessages: msgIDList from: sourceDB	"Merge the given collection of messages from the source database into the receiver. When a message being added has the same message ID as an existing message, check to see if the two message texts are identical. If so, do not store the duplicate message. If the texts are different, make a new ID for the message being added. This operation will also copy the category information from the sourceDB, creating new catetories if necessary."	| msgText newMsgID saveIt msg location entry |	messageFile beginAppend.	msgIDList do:		[: oldMsgID |		 msgText _ sourceDB getText: oldMsgID.		 "resolve ID conflicts"		 (indexFile includesKey: oldMsgID)			ifFalse:	"no ID conflict"				[newMsgID _ oldMsgID.				 saveIt _ true]			ifTrue:	"resolve an ID conflict"				[(msgText = (self getText: oldMsgID))					ifTrue:	"identical text; don't save again"						[newMsgID _ oldMsgID.						 saveIt _ false]					ifFalse:	"different text; save with new ID"						[newMsgID _ self nextUnusedID.						 saveIt _ true]].		 "save the message in the destination DB"		 saveIt ifTrue:			[msg _ MailMessage from: msgText.			 location _ messageFile basicAppend: msg text id: newMsgID.			 entry _ IndexFileEntry						message: msg						location: location 						messageFile: messageFile						msgID: newMsgID.			 indexFile at: newMsgID put: entry].		 "update the categories for the message in the destination DB"		 (sourceDB categoriesThatInclude: oldMsgID) do:			[: categoryName |			 self file: newMsgID inCategory: categoryName]].	messageFile endAppend.! !!MailDB methodsFor: 'fetch-merge-compact'!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).	"never go backwards!!"	^id! !!MailDB methodsFor: 'categories'!addCategory: categoryName	"Create a category with the given name if one doesn't already exist."	categoriesFile addCategory: categoryName.! !!MailDB methodsFor: 'categories' stamp: 'ls 9/12/1998 02:17'!addNewMessage: message inCategory: category	"add the given message to the database, putting it in the given category.	Returns the message id"	|id location |	id _ self nextUnusedID.	location _ messageFile append: message text  id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	categoriesFile file: id inCategory: category.	^id! !!MailDB methodsFor: 'categories'!allCategories	"Answer a list of categories sorted in alphabetical order, including the special categories."	^categoriesFile categories asSortedCollection asOrderedCollection! !!MailDB methodsFor: 'categories'!categoriesThatInclude: msgID	"Answer a collection of names for real categories that include the message with the given ID. Pseudo-categories (such as '.unclassified.') are not considered real categories."	^categoriesFile categories select:		[: catName |		 (categoriesFile messagesIn: catName) includes: msgID]! !!MailDB methodsFor: 'categories'!file: msgID inCategory: categoryName	"File the message with the given ID in the given category."	categoriesFile file: msgID inCategory: categoryName.! !!MailDB methodsFor: 'categories'!fileAll: msgIDList inCategory: categoryName	"File all the messages with ID's in the given list in the given category."	msgIDList do:		[: msgID |		 categoriesFile file: msgID inCategory: categoryName].! !!MailDB methodsFor: 'categories'!messagesIn: categoryName	"Answer a collection of message ID's for the messages in the given category, sorted in ascending time order.  If the category does not exist, answer an empty collection. The pseudo-categories '.all.' and '.unclassified.' are computed dynamically, which may take a little time."	| msgList category |	(categoryName = '.unclassified.') ifTrue:		[Cursor execute showWhile:			[msgList _ categoriesFile unclassifiedFrom: indexFile keys].		 ^msgList].	(categoryName = '.all.') ifTrue:		[^indexFile keys].	"otherwise, it is a real category"	category _ categoriesFile messagesIn: categoryName.	^indexFile keys select:		"indexFile keys is sorted"		[: msgID | category includes: msgID]! !!MailDB methodsFor: 'categories'!remove: msgID fromCategory: categoryName	"Remove the message with the given ID from the given category."	categoriesFile remove: msgID fromCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeAll: msgIDList fromCategory: categoryName	"Remove all the messages with ID's in the given list from the given category."	msgIDList do:		[: msgID |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!removeCategory: categoryName	"Remove the category with the given name. This does nothing if the category does not exist or if it is a pseudo-category."	categoriesFile removeCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeFromAllCategories: msgID	"Remove the message with the given ID from all categories. The message will appear in 'unclassified'."	categoriesFile categories do:		[: categoryName |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('new', '.all.', or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages'!delete: msgID	"Delete the messages with the given ID from the message file. In contrast to simply removing a message from a category, this is permanent!!"	messageFile		deleteMessageAt: (indexFile at: msgID) location		id: msgID.	indexFile remove: msgID.	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!deleteAll: msgIDList	"Delete all the messages with ID's in the given list from the message file. This is permanent!!"	msgIDList do:		[: msgID |		 messageFile			deleteMessageAt: (indexFile at: msgID) location			id: msgID.		 indexFile remove: msgID].	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!getMessage: msgID	"Answer the MailMessage with the given ID."	^MailMessage from: (self getText: msgID)! !!MailDB methodsFor: 'messages'!getTOCentry: msgID	"Answer the table-of-contents entry for the message with the given ID."	^indexFile at: msgID! !!MailDB methodsFor: 'messages'!getTOCstring: msgID	"Answer the table-of-contents string for the message with the given ID."	^(indexFile at: msgID) tocString! !!MailDB methodsFor: 'messages'!getText: msgID	"Answer the text for the message with the given ID."	| entry |	entry _ indexFile at: msgID.	^messageFile		getMessage: msgID		at: entry location		textLength: entry textLength! !!MailDB methodsFor: 'messages'!newText: newText for: msgID	"Replace the text for the message with the given ID."	| oldLocation newLocation newEntry |	oldLocation _ (indexFile at: msgID) location.	newLocation _ messageFile update: newText at: oldLocation id: msgID.	newEntry _ IndexFileEntry		message: (MailMessage from: newText)		location: newLocation		messageFile: messageFile		msgID: msgID.	indexFile at: msgID put: newEntry.! !!MailDB methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a MailDB on ''', rootFilename, ''''.! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 00:26'!do: aBlock  andInform: aString	"evaluate aBlock.  If aString is non-nil, display it to the user while doing the evaluation"	^aString		ifNil: [ aBlock value ]		ifNotNil: [ Utilities informUser: aString during: aBlock ]! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 01:12'!showProgress: showProgress  from: start  to:  end message: message during: aBlock	"evaluate aBlock.  If showProgress is true, then displaya progress meter while evaluating"	showProgress ifFalse: [ ^aBlock value: [ :ignored | ] ].	^message displayProgressAt: Sensor mousePoint from: start to: end during: aBlock! !!MailDB class methodsFor: 'instance creation'!openOn: rootFilename	"Open or create a mail database with the given root filename. If an instance of me exists with the given root filename, return a reference to that instance rather than creating a new one. This allows multiple MailReaders to be open on the same database without synchronization problems."	| alreadyOpenDB |	alreadyOpenDB _ self allInstances		detect:			[: db |			 (db rootFilename notNil) and:			 [db rootFilename = rootFilename]]		ifNone: [nil].	(alreadyOpenDB notNil)		ifTrue: [^alreadyOpenDB]		ifFalse: [^(self new) openOn: rootFilename].! !!MailDB class methodsFor: 'utilities'!readIntegerLineFrom: aStream	"Read a positive integer from the given stream. Answer zero if there are no digits. Consume the stream through the next carriage return."	| digit value |	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		 ((digit >= 0) & (digit <= 9))			ifTrue: 				[value _ (value * 10) + digit]			ifFalse:				[(digit == Character cr digitValue) ifFalse:					[self skipRestOfLine: aStream].				 ^value]].	^value! !!MailDB class methodsFor: 'utilities' stamp: 'ls 9/8/1998 05:19'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	| |	^aStream upTo: Character cr! !!MailDB class methodsFor: 'utilities'!skipRestOfLine: aStream	"Consume characters from the given stream through the next carriage return."	| crValue |	crValue _ Character cr asciiValue.	[aStream atEnd or:	 [aStream next asciiValue == crValue]] whileFalse:		["consume until end of stream or a carriage return"].! !I am an abstract class that collects some of the operations common to all mail database files.!!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:40'!delete	"Delete this file."	FileDirectory splitName: filename to: [:dirPath :name |		(FileDirectory forFileName: filename) 			deleteFileNamed: name ifAbsent: []].! !!MailDBFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:35'!rename: newFileName	"Rename this file."	FileDirectory splitName: filename to: [:dirPath :oldFileName |		(FileDirectory forFileName: filename) 			rename: oldFileName toBe: newFileName].	filename _ newFileName.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:00'!save	"Atomically save a representation of this object to its file. The old file is renamed to '<oldname>.bak' before the new file is written. If the write operation fails, the old file may be restored by renaming it. If it succeeds, the .bak file is deleted."	| f dir shortName |	"create the file if it doesn't already exist"	(StandardFileStream isAFileNamed: filename) ifFalse: [		f _ StandardFileStream new open: filename forWrite: true.		f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir rename: shortName toBe: shortName, '.bak'.	f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.	dir deleteFileNamed: (shortName, '.bak') ifAbsent: [].! !!MailDBFile methodsFor: 'read-write'!readFrom: aStream	"Subclasses must override this method to provide a means of reading themselves into memory."	self subclassResponsibility! !!MailDBFile methodsFor: 'read-write'!writeOn: aStream	"Subclasses must override this method to provide a means of writing themseves out on their files."	self subclassResponsibility! !!MailDBFile methodsFor: 'error reporting'!reportInconsistency	"Report that the index file is not consistent with the messages file."	self error:'The .index file is not consistent with the .messages file. Thismay be fixed by compacting the mail database, whichwill rebuild the index file from scratch.'! !!MailDBFile class methodsFor: 'instance creation'!openOn: fileName	"Answer a new instance of me, backed by the file with the given name."	^(super new) openOn: fileName! !I am a parser for mail inboxes in a form found in the Unix '/var/spool' inboxes. This is also the format used by Eudora 3.0 on the Macintosh (and perhaps by other versions of Eudora as well).!!MailInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for mail inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!MailInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for mail inboxes."	self error: 'Mail inboxes are read only!!'! !!MailInboxFile methodsFor: 'scanning'!delimitersDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText delim |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue: [		aBlock value: (MailDB readStringLineFrom: stream)].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!findPossibleMessageStart: aStream	"Find the next line starting with the string 'From' followed by a space. Leave the input stream positioned at the character following the space."	(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].	[true] whileTrue: [		aStream skipTo: Character cr.		[aStream peek = Character cr] whileTrue: [aStream next].		(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].		aStream atEnd ifTrue: [^false].	].! !!MailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	self scanToNextMessageIn: stream.	MailDB skipRestOfLine: stream.  "skip message delimiter"	msgStart _ stream position.	[self scanToNextMessageIn: stream] whileTrue: [		msgSize _ stream position - msgStart.		stream position: msgStart.		msgText _ stream next: msgSize.		MailDB skipRestOfLine: stream.  "skip message delimiter"		msgStart _ stream position.		aBlock value: msgText].	"process final message"	msgSize _ stream position - msgStart.	msgSize > 0 ifTrue: [		stream position: msgStart.		msgText _ stream next: msgSize.		aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!nextStringIs: aString in: aStream	"If the next characters of the given stream form the given string, then advance the stream position by the size of the string and return true. Otherwise, leave the stream untouched and return false."	| oldPosition |	oldPosition _ aStream position.	1 to: aString size do: [ :i |		aStream next = (aString at: i) ifFalse: [			aStream position: oldPosition.			^false		].	].	aStream position: oldPosition.	^true! !!MailInboxFile methodsFor: 'scanning' stamp: 'ls 8/21/1998 10:21'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message or at the end of the stream."	| msgStart line dayOfWeek year |	[aStream atEnd] whileFalse: [		(self findPossibleMessageStart: aStream) ifFalse: [^false].		msgStart _ aStream position.		aStream next: 5.  "skip 'From '"		"skip address"		[aStream peek isSeparator] whileFalse: [aStream next].		[aStream peek = Character space] whileTrue: [aStream next].		line _ MailDB readStringLineFrom: aStream.		line size >= 7 ifTrue: [			dayOfWeek _ (line copyFrom: 1 to: 3) asLowercase.			year _ (line copyFrom: line size - 3 to: line size) asNumber.			((#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: dayOfWeek) and:			[(year > 1900) and: [year < 2100]]) ifTrue: [				aStream position: msgStart.				^true  "found a message!!"			].		].	].	^false! !I represent a mail or news message. I parse the message header and keep certain header fields in instance variables for rapid access.!!MailMessage methodsFor: 'initialize-release'!from: aString	"Parse the given string to initialize myself. The given string will become my text."	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |		 (fName = 'date') ifTrue: [time _ self timeFrom: fValue].		 (fName = 'from') ifTrue: [from _ fValue].		 (fName = 'to') ifTrue: [to isEmpty ifTrue: [to _ fValue] ifFalse: [to _ to, ', ', fValue]].		 (fName = 'cc') ifTrue: [cc isEmpty ifTrue: [cc _ fValue] ifFalse: [cc _ cc, ', ', fValue]].		 (fName = 'subject') ifTrue: [subject _ fValue]].! !!MailMessage methodsFor: 'initialize-release'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^aString copyFrom: 1 to: i]		ifFalse: [^''].! !!MailMessage methodsFor: 'access' stamp: 'ls 9/13/1998 06:15'!body	"return just the body of the message"	| s |	s _ ReadStream on: self text.	"scan until a blank line is seen"	[ s atEnd not and: [ (s peek = Character cr) not ] ] whileTrue: [		s upTo: Character cr ].	s next. 	"skip the blank line"	"the body is the rest of the text"	^s upToEnd! !!MailMessage methodsFor: 'access'!cc	^cc! !!MailMessage methodsFor: 'access'!date	"Answer a date string for this message."	^(Time aTime: (time + (Date newDay: 1 year: 1980) asSeconds)) first		printFormat: #(2 1 3 47 1 2)! !!MailMessage methodsFor: 'access'!from	^from! !!MailMessage methodsFor: 'access'!subject	^subject! !!MailMessage methodsFor: 'access'!text	^text! !!MailMessage methodsFor: 'access'!time	^time! !!MailMessage methodsFor: 'access'!to	^to! !!MailMessage methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:27'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value."	| savedLine line s |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators; skip: -1.			line _ line, s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!MailMessage methodsFor: 'parsing'!readDateFrom: aStream	"Parse a date from the given stream and answer nil if the date can't be parsed. The date may be in any of the following forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>		(4/5/82)	In addition, the date may be preceded by the day of the week and an optional comma, such as:		Tue, November 14, 1989"	| day month year |	self skipWeekdayName: aStream.	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"month name or weekday name"			[month _ WriteStream on: (String new: 10).			 [aStream peek isLetter] whileTrue: [month nextPut: aStream next].			 month _ month contents.			 day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				 (aStream peek isDigit) ifFalse: [^nil].				 day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			 day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	(aStream peek isDigit) ifFalse: [^nil].	year _ Integer readFrom: aStream.	^Date newDay: day month: month year: year! !!MailMessage methodsFor: 'parsing'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field has an empty value part."	| s fieldName fieldValue |	s _ ReadStream on: aString.	fieldName _ (s upTo: $:) asLowercase.	s skipSeparators.	(s atEnd) ifFalse: [		"field is not empty"		fieldValue _ s upToEnd.		aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'parsing'!skipWeekdayName: aStream	"If the given stream starts with a weekday name or its abbreviation, advance the stream to the first alphaNumeric character following the weekday name."	| position name abbrev |	aStream skipSeparators.	(aStream peek isDigit) ifTrue: [^self].	(aStream peek isLetter) ifTrue:		[position _ aStream position.		 name _ WriteStream on: (String new: 10).		 [aStream peek isLetter] whileTrue: [name nextPut: aStream next].		 abbrev _ (name contents copyFrom: 1 to: (3 min: name position)).		 abbrev _ abbrev asLowercase.		 (#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: abbrev asLowercase)			ifTrue:				["found a weekday; skip to the next alphanumeric character"				 [aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]			ifFalse:				["didn't find a weekday so restore stream position"				 aStream position: position]].! !!MailMessage methodsFor: 'parsing'!timeFrom: aString	"Parse the date and time and answer the result as the number of seconds since the start of 1980. The time is interpreted in the sender's time-zone; it should really be converted to GMT, depending on the timezone of the sender..."	| s t |	s _ ReadStream on: aString.	t _ (self readDateFrom: s) asSeconds.  "date part"	[s atEnd or: [s peek isAlphaNumeric]] whileFalse: [s next].	(s atEnd) ifFalse:		["read time part (interpreted as local, regardless of sender's timezone)"		 t _ t + (Time readFrom: s) asSeconds].	^t - (Date newDay: 1 year: 1980) asSeconds		"time started with 1980..."! !!MailMessage methodsFor: 'printing/formatting'!eudoraOutboxText	"Return this message formatted for inclusion in a Eudora outbox."	| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	MailMessage new fieldsFrom: old do: [ :fName :fValue | "skip header fields" ].	new nextPutAll: 'To: ';		nextPutAll: to; cr.	new nextPutAll: 'From: ';	nextPutAll: from; cr.	new nextPutAll: 'Subject: ';	nextPutAll: subject; cr.	new nextPutAll: 'Cc: ';		nextPutAll: cc; cr.	new nextPutAll: 'Bcc: '; cr.	new nextPutAll: 'X-attachments: '; cr.	new cr.	new nextPutAll: old upToEnd.	^new contents! !!MailMessage methodsFor: 'printing/formatting'!format	"Replace the text of this message with a formatted version."	"NOTE: This operation discards extra header fields."	text _ self formattedText.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 9/8/1998 05:17'!formattedText	"Answer a version of my text with a cleaned up header."	| old new header body |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do:		[: fName : fValue |		 (#('received'			'return-path'			'newsgroups'			'message-id'			'path'			'reply-to'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from') includes: fName) ifFalse:				[new nextPutAll: fName capitalized.				 new nextPutAll: ': '.				 new nextPutAll: fValue; cr]].	new cr.	header _ new contents.	body _ old upToEnd.	^header, body! !!MailMessage methodsFor: 'printing/formatting'!replace: oldString with: newString in: aString	"Replace all occurances of oldString in the given string with newString."	| target where |	target _ aString.	where _ 1.	[(where _ target findString: oldString startingAt: where) = 0] whileFalse:		[target _ target					copyReplaceFrom: where					to: where + oldString size - 1					with: newString].	^target! !!MailMessage class methodsFor: 'instance creation'!from: aString	"Initialize a new instance from the given string."	^(self new) from: aString! !a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.!!MailtoUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 21:05'!activate	(Smalltalk includesKey: #EmailWindow) ifTrue: [		(Smalltalk at: #EmailWindow) beginNewMessageTo: self locator	].	self notify: 'no mail reader present'! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 6/15/1998 12:18'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self boundsInWorld containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:])			ifFalse: [owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				evt hand world displayWorld.				owner invokeItem: self]]].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 8/8/1998 09:22'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAdjacentTo: (Array with: self bounds topRight + (10@0)									with: self bounds topLeft)			forHand: aHand			from: self].! !!MenuMorph methodsFor: 'construction' stamp: 'di 9/22/1998 20:29'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'keep this menu up'		target: self		selector: #toggleStayUp:		argumentList: EmptyArray.	self addLine! !!MenuMorph methodsFor: 'construction' stamp: 'di 8/20/1998 09:30'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!MenuMorph methodsFor: 'control' stamp: 'di 8/8/1998 09:48'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	popUpOwner _ sourceItem.	originalEvent _ MorphicEvent new setHand: hand.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'di 6/22/1998 15:15'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !I represent the messages file of a mail database. This file is treated as (mostly) append-only. All new messages or edited messages are appended to the end of this file.Messages are stored as ASCII text with seperator strings and some additional information between each message. If necessary, this file can be inspected or edited with a text editor; after editing, the index file should be recreated using the "compact" command. (This is necessary because the offsets kept in the index file will probably be different after the edits.)When a message is deleted, its delimiter is changed to mark it as deleted, but it is left in the mail file until the next time "compact" command is executed. Generally, the reduction in disk fragmentation resulting from keeping the messages in a single file more than offsets the temporary space lost by having a few deleted messages hanging around between compactions. Compaction is done into a new copy of the file, followed by a renaming operation. Thus, if compaction fails, the original messages file will not be lost.!!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:26'!close	"Close the file."	file ifNil: [^ self].	file		ensureOpen;		setToEnd;		close.	file _ nil.! !!MessageFile methodsFor: 'file operations'!delete	"I must close my file handle before the file can be deleted."	self close.	super delete.! !!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:30'!ensureFileIsOpen	"Make sure that my file is open. The file is automatically closed on snapshots."	file		ifNil: [file _ FileStream fileNamed: filename]		ifNotNil: [file ensureOpen].! !!MessageFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself for the message file with the given name."	filename _ aFileName.	file _ nil.	self ensureFileIsOpen.! !!MessageFile methodsFor: 'file operations'!rename: newFileName	"I must close my file handle before the file can be renamed."	self close.	super rename: newFileName.! !!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:27'!save	"Make sure the message file is flushed to disk. This is NOT atomic because MessageFiles can get large and there might not be enough disk space to save them atomically. Besides, it would be very slow."	file ifNil: [^ self].	file		ensureOpen;		setToEnd;		close;		reopen.! !!MessageFile methodsFor: 'message operations'!append: messageText id: messageID	"Append the given message text with the given unique identifier. Answer the new location of the message."	| location |	self beginAppend.	location _ self basicAppend: messageText id: messageID.	self endAppend.	^location! !!MessageFile methodsFor: 'message operations'!assertValidMessageAt: filePosition id: msgID	"Verify that the given filePosition is, indeed, the start of a message (possibly deleted) with the given ID and raise an error if this assertion is false."	| delimiter fileMsgID |	"assume file is open"	file position: filePosition.	delimiter _ file next: 10.	((delimiter = '&&&&&start') or: [delimiter = '&&&&&XXXXX']) ifFalse:		[^self reportInconsistency].	file next. "skip cr"	fileMsgID _ MailDB readIntegerLineFrom: file.	(msgID = fileMsgID) ifFalse:		[^self reportInconsistency].! !!MessageFile methodsFor: 'message operations'!basicAppend: messageText id: messageID	"Append the given message text with the given message ID. Answer the new location of the message."	"WARNING: This operation assumes:		1. the sender positioned the stream to the end of the file (using beginAppend), and		2. the sender will do an endAppend operation after all messages are appended to flush all file buffers to disk."	| location |	file setToEnd.	location _ file position.	file nextPutAll: '&&&&&start'.	"message delimiter"	file cr.	messageID printOn: file.		"message ID"	file cr.	file nextPutAll: messageText.	^location! !!MessageFile methodsFor: 'message operations'!beginAppend	"Set the file to the end prior to performing a sequence of basicAppend operations."	self ensureFileIsOpen.	file setToEnd.! !!MessageFile methodsFor: 'message operations'!deleteMessageAt: filePosition id: msgID	"Mark as deleted the message with the given ID located at the given file position."	self ensureFileIsOpen.	self assertValidMessageAt: filePosition id: msgID.	file position: filePosition.	file nextPutAll: '&&&&&XXXXX'.		"delimiter for deleted messages"	file flush.! !!MessageFile methodsFor: 'message operations'!endAppend	"Complete an append transaction by flushing the file to disk."	self save.! !!MessageFile methodsFor: 'message operations'!getMessage: msgID at: start textLength: textSize	"Retrieve the message with the given ID, location, and text size."	self ensureFileIsOpen.	self assertValidMessageAt: start id: msgID.	^file next: textSize! !!MessageFile methodsFor: 'message operations'!update: messageText at: oldMessagePosition id: msgID	"Atomically update the message having the old location and ID with the given new text (e.g. when the user has edited a message). Answer the new location of the message."	| newLocation |	newLocation _ self append: messageText id: msgID.	self deleteMessageAt: oldMessagePosition id: msgID.	^newLocation! !!MessageFile methodsFor: 'scanning'!messagesDo: aBlock	"Scan the message file and invoke the given block for each message in it. The block arguments are:	deleted			true if this message is marked deleted	msgID			the message ID	msgBody			the message textThis operation is very expensive."	| more deleted msgID textStart textSize msgBody |	self ensureFileIsOpen.	file position: 0.	more _ self scanToNextMessageIn: file.	[more] whileTrue:		[deleted _								"deleted"			(MailDB readStringLineFrom: file) = '&&&&&XXXXX'.		 msgID _ MailDB readIntegerLineFrom: file.	"msgID"		 textStart _ file position.		 more _ self scanToNextMessageIn: file.		 textSize _ file position - textStart.		 file position: textStart.		 msgBody _ file next: textSize.				"msgBody"		 aBlock valueWithArguments:			(Array				with: deleted				with: msgID				with: msgBody)].! !!MessageFile methodsFor: 'scanning'!scanToNextAndSigns: aStream	"Scan the given stream for a pair of and-sign (&) characters and answer true if they are found before the end of the stream is reached. The stream is left positioned after the second and-sign or at the end of the stream."	| ch |	[true] whileTrue:		[ch _ aStream next.		 ((ch == $&) and:		   [aStream next == $&]) ifTrue: [^true].	"found"		 (ch == nil) ifTrue: [^false]].	"end of file"! !!MessageFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message. Answer true if we find a message delimiter, false if we hit the end of the file first. The stream is left positioned at the start of the next message (at the message delimiter) or at the end of the stream."	| delimiter |	[self scanToNextAndSigns: aStream] whileTrue:		[delimiter _ aStream next: 8.		 ((delimiter = '&&&start') or: [delimiter = '&&&XXXXX'])			ifTrue: [aStream skip: -10. ^true]			ifFalse: [(delimiter includes: $&) ifTrue: [aStream skip: -8]]].	^false	"end of file"! !!MessageSet methodsFor: 'message list' stamp: 'di 9/21/1998 23:04'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'message list' stamp: 'wod 6/16/1998 15:08'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'contents' stamp: 'di 6/26/1998 09:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 12:23'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView |	World ifNotNil: [^ self openAsMorph: aMessageSet name: aString].	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/19/1998 13:51'!openAsMorph: aMessageSet name: labelString 	"Create a SystemWindow aMessageSet, with the label labelString, in a Morphic project"	^ self openAsMorph: aMessageSet name: labelString inWorld: World! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 17:05'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph |	self flag: #newBrowsers.	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 extent: 1@0.2).	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.2 corner: 1@1).	window openInWorld: aWorld! !My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.[Subtle detail] A class is know by name to an environment.  Typically this is the SystemDictionary named Smalltalk.  If we ever make lightweight classes that are not in Smalltalk, they must be in some environment.  Specifically, the code that sets 'wasPresent' in name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed: must continue to work.!!Metaclass methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 10:03'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'initialize-release' stamp: 'tk 8/22/1998 07:45'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. oldClass is a metaclass, so we know there is just one instance.  Permute variables as necessary."	| oldInstVarNames map variable new instSize oldInstances |	oldClass soleInstance == nil ifTrue: [^self].	"no instances to convert"	oldInstVarNames _ oldClass allInstVarNames.	map _ self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].	variable _ self isVariable.	instSize _ self instSize.	"Now perform a bulk mutation of old instances into new ones"	oldInstances _ Array with: oldClass soleInstance.	oldInstances elementsExchangeIdentityWith:		(oldInstances collect: 		[:old | 		variable			ifTrue: [new _ self basicNew: old basicSize]			ifFalse: [new _ self basicNew].		1 to: instSize do: 			[:offset |  (map at: offset) > 0 ifTrue:				[new instVarAt: offset						put: (old instVarAt: (map at: offset))]].		variable 			ifTrue: [1 to: old basicSize do: 						[:offset |						new basicAt: offset put: (old basicAt: offset)]].		new])! !!Metaclass methodsFor: 'accessing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!Metaclass methodsFor: 'copying' stamp: 'tk 8/19/1998 16:16'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'tk 8/22/1998 10:46'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !!MethodNode methodsFor: 'printing' stamp: 'di 8/24/1998 12:13'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 256 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur max: snd duration].	^ dur! !A morph (from the Greek "shape" or "form") is an interactive graphical object.All morphs owned by a morph are held in submorphs.  All coordinates are global screen coordinates.  (Except those that are flexed, contained inside a FlexMorph.)All show unless they are 'hidden'.  Hidden morphs: are still in submorphs have a position of about 1000000@100000 have a property #relPos that is its relative position inside its owner. has a property #hidden set to true. when fullBounds of a morph is computed, don't include morphs that have the property hidden = true. "Stop" must not move hidden morphs back onto the playfield (PasteUpMorph)!!Morph methodsFor: 'initialization' stamp: 'di 8/10/1998 13:08'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.! !!Morph methodsFor: 'initialization' stamp: 'jm 7/5/1998 12:40'!openInMVC	MorphWorldView		openWorldWith: self		labelled: self defaultLabelForInspector.! !!Morph methodsFor: 'initialization' stamp: 'di 8/17/1998 20:59'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	World addMorph: self.	World startSteppingSubmorphsOf: self.! !!Morph methodsFor: 'initialization' stamp: 'sw 8/4/1998 18:20'!openInWorld: aWorld	"Add this morph to the requested World."	aWorld addMorph: self! !!Morph methodsFor: 'initialization' stamp: 'sw 9/11/1998 11:13'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	(aPresenter _ self presenter) ifNil: [^ nil].	^ (pal _ aPresenter ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner _ aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'accessing' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state _ self actorStateOrNil.	state ifNil:		[state _ ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:05'!actorState: anActorState	extension == nil ifTrue: [self assureExtension].	extension actorState: anActorState! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:06'!actorStateOrNil	extension == nil ifTrue: [^ nil].	^ extension actorState! !!Morph methodsFor: 'accessing' stamp: 'sw 8/19/1998 11:55'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(maybeDoDup:with:			'Duplicate')		(doGrab:with:				'Pick up')		(startDrag:with:				'Move')		(doMenu:with:				'Menu')		(doDebug:with:				'Debug')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!balloonTextSelector: aSelector	extension == nil ifTrue: [self assureExtension].	extension balloonTextSelector: aSelector! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!beSticky	extension == nil ifTrue: [self assureExtension].	extension sticky: true! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler	extension == nil ifTrue: [^ nil].	^ extension eventHandler! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "	extension == nil ifTrue: [self assureExtension].	extension eventHandler: anEventHandler! !!Morph methodsFor: 'accessing' stamp: 'tk 7/31/1998 13:47'!forwardDirection	"Default implementation."	^ 0.0! !!Morph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:54'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	^ color isColor and: [color alpha < 1.0]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:47'!highlightColor		| val |	^ (val _ self valueOfProperty: #highlightColor)		ifNotNil:			[val]		ifNil:			[owner highlightColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!highlightColor: aColor	self setProperty: #highlightColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:09'!isLocked	extension == nil ifTrue: [^ false].	^ extension locked! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!isSticky	extension == nil ifTrue: [^ false].	^ extension sticky! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!lock: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension locked: aBoolean! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player	extension == nil ifTrue: [^ nil].	^ extension player! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player: anObject	extension == nil ifTrue: [self assureExtension].	extension player: anObject! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:48'!regularColor		| val |	^ (val _ self valueOfProperty: #regularColor)		ifNotNil:			[val]		ifNil:			[owner regularColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!regularColor: aColor	self setProperty: #regularColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:12'!toggleStickiness	extension == nil ifTrue: [^ self beSticky].	extension sticky: extension sticky not! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 12:33'!unlock	self lock: false! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:09'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	extension == nil ifTrue: [^ false].	^ extension hasProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/16/1998 11:13'!removeProperty: propName	extension == nil ifTrue: [^ self].	extension removeProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:12'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].	extension == nil ifTrue: [self assureExtension].	extension setProperty: propName toValue: aValue! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName	extension == nil ifTrue: [^ nil].	^ extension valueOfProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName ifAbsent: aBlock	extension == nil ifTrue: [^ aBlock value].	^ extension valueOfProperty: propName ifAbsent: aBlock! !!Morph methodsFor: 'copying' stamp: 'di 8/11/1998 22:13'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].	extension == nil ifFalse: [extension updateReferencesUsing: aDictionary]! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:55'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutPlayer here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'copying' stamp: 'tk 5/22/1998 12:17'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream"	self allMorphsDo: [:m | m prepareToBeSaved].		"Actors fix open scriptEditors"	^ super veryDeepCopy ! !!Morph methodsFor: 'copying' stamp: 'tk 8/31/1998 15:19'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Do not copy the owner field.  That must be filled in by the owner, if he is within the tree being copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	new _ self clone.	class isSystemDefined ifFalse: ["May occur in the future"		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	"Morph subclasses do not have variable numbers of fields (like Array does)"	new privateBounds: bounds clone.	"Points are shared with original"		"indexes used here are checked by checkVariables"	(subAss _ deepCopier references associationAt: owner ifAbsent: [nil])		ifNil: [new privateOwner: nil]	"weak reference to owner"		ifNotNil: [new privateOwner: subAss value].	new privateSubmorphs: (submorphs veryDeepCopyWith: deepCopier).	new privateFullBounds: fullBounds.	"fullBounds is shared with original!!"	new privateColor: (color veryDeepCopyWith: deepCopier).		"color, if simple, will return self. may be complex"	new instVarAt: 6 put: (extension veryDeepCopyWith: deepCopier).		"extension is treated like any generic inst var"	index _ class instSize.	[index > 6] whileTrue: 		[sub _ self instVarAt: index.		new instVarAt: index put: (sub veryDeepCopyWith: deepCopier).		index _ index - 1].	new submorphsDo: [:morph | morph privateOwner: new].  "strengthen weak pointers"	^ new! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:56'!veryDeepCopyWithoutPlayer	| hold copy holdState |	hold _ self player.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	self player: nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self player: hold.	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:45'!ownerThatIsAHandOrA: aClass	"Return the first enclosing morph that is either a HandMorph or a kind of aClass, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[((current isKindOf: aClass) or: [current isHandMorph]) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:46'!owningHandOrPasteUpMorph	"Answer the closest containing morph that is a Hand or a PasteUp morph"	^ self ownerThatIsAHandOrA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 18:02'!pasteUpMorph	"Answer the closest containing morph that is a PasteUp morph"	^ self ownerThatIsA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 8/30/1998 09:47'!topPasteUp	"If the receiver is in a world, return that; otherwise return the outermost pasteup morph"	^ self outermostMorphThat: [:m | m isKindOf: PasteUpMorph]! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 12:15'!world	^ owner ifNil: [nil] ifNotNil: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 17:11'!hasSubmorphWithProperty: aSymbol	submorphs detect: [:m | m hasProperty: aSymbol] ifNone: [^ false].	^ true! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:38'!morphsIn: aRectangle	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  The order is deepest embedding first."	^ self morphsIn: aRectangle addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:28'!morphsIn: aRectangle addTo: mList	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  Must do this recursively because of transforms.  "	submorphs size > 0 ifTrue:		[submorphs do: [:m | m morphsIn: aRectangle addTo: mList]].	(self bounds intersects: aRectangle) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 18:47'!submorphWithProperty: aSymbol	^ submorphs detect: [:aMorph | aMorph hasProperty: aSymbol] ifNone: [nil]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/29/1998 15:39'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 6/17/1998 16:04'!addMorphNearBack: aMorph	| bg |	(submorphs size > 0 and: [submorphs last mustBeBackmost]) ifTrue:		[bg _ submorphs last.		bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 8/13/1998 10:09'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[(extension == nil or: [self player == nil])		ifTrue: [owner privateRemoveMorph: self.				owner _ nil]		ifFalse: ["Player must be notified"				aWorld _ self world.				owner privateRemoveMorph: self.				owner _ nil.				self player noteDeletionOf: self fromWorld: aWorld]		].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 7/3/1998 11:02'!deleteSubmorphsWithProperty: aSymbol	submorphs copy do:		[:m | (m hasProperty: aSymbol) ifTrue: [m delete]]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 8/20/1998 17:32'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	newMorph arrangeToStartStepping! !!Morph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:10'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:33'!doesOwnRotation	"Some morphs don't want to TransformMorph to rotate their images, but we do"	^ false! !!Morph methodsFor: 'drawing' stamp: 'di 6/17/1998 12:44'!flash	| w |	w _ self world.	w ifNotNil:		[Display flash: (((self transformFrom: w) invertRect: bounds)								translateBy: w viewBox origin)].! !!Morph methodsFor: 'drawing' stamp: 'di 8/16/1998 11:19'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		submorphs size > 0 ifTrue: [			submorphs do: [:m | (m left < 50000 or: [(self hasProperty: #hidden) not])					ifTrue: [fullBounds _ fullBounds quickMerge: m fullBounds]]]].	^ fullBounds! !!Morph methodsFor: 'drawing' stamp: 'jm 5/30/1998 21:06'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	submorphs isEmpty		ifTrue: [self drawOn: aCanvas]		ifFalse: [			(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].			submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'drawing' stamp: 'tk 7/9/1998 13:44'!hide	"Move this morph way, way offstage!!  Remember its coordinates in relative form, in case window moves while hidden."	owner ifNil: [^ self].	self position < (5000@5000) ifTrue: [		self setProperty: #relPosition toValue: (self position - owner position).		self position: self position + (1000000@100000).		self setProperty: #hidden toValue: true].! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:43'!imageForm: depth forRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent depth: depth.	self fullDrawOn: (canvas copyOffset: rect topLeft negated).	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:42'!imageFormDepth: depth	^ self imageForm: depth forRectangle: self fullBounds! !!Morph methodsFor: 'drawing' stamp: 'di 9/9/1998 22:25'!imageFormForRectangle: rect	^ self imageForm: Display depth forRectangle: rect! !!Morph methodsFor: 'drawing' stamp: 'di 9/10/1998 12:29'!shadowForm	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fullDrawOn: canvas.	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'drawing' stamp: 'tk 7/9/1998 13:57'!show	"Make sure this morph is on-stage."	| saved |	self world ifNil: [^ self].	"would like to set bounds, but we must be in a world"	(self valueOfProperty: #hidden) ifNil: [^ self].	(saved _ self valueOfProperty: #relPosition) ifNotNil: [		self position: saved + owner position.		self setProperty: #hidden toValue: nil.	"showing"		self wrap.	"be sure I'm on-stage"		"self bottomRight = owner bottomRight ifTrue: [			self error: 'Why did object lose position?']"		].! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!bottomLeft: aPoint	self bottom: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:08'!bottomRight: aPoint	self bottom: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'di 7/5/1998 20:57'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!topLeft: aPoint	self top: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:29'!topRight: aPoint	self top: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'rotate scale and flex' stamp: 'sw 8/11/1998 16:45'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/9/1998 23:10'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map patchBelowMe |	"make a mask with black where sensitiveColor is, white elsewhere"	myImage _ self imageForm.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ (Color cachedColormapFrom: myImage depth to: 1) copy.	map primFill: 0.	map at: (sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form		at: 0@0		colorMap: map.	"get an image of the world below me"	patchBelowMe _ self world patchAt: self fullBounds belowMorph: self.	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: (sensitiveColor indexInMap: map) put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/9/1998 22:49'!colorUnder	"Return the color of under the receiver's center."	self isInWorld		ifTrue: [^ self world colorAt: (self pointInWorld: self referencePosition) belowMorph: self]		ifFalse: [^ Color black].! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/9/1998 14:06'!goHome	| box close |	owner ifNotNil: [		close _ bounds origin x < 50000. "quick test for not hidden"		close ifFalse: ["real but slow test"			close _ (self valueOfProperty: #hidden) ~~ true].		close ifTrue: [			box _ owner.			self left < box left ifTrue: [self position: box left@self position y].			self right > box right ifTrue: [self position: (box right - self width)@self position y].			self top < box top ifTrue: [self position: self position x@box top].			self bottom > box bottom ifTrue: [				self position: self position x@(box bottom - self height)]]].! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/10/1998 12:41'!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm |	shadowForm _ self shadowForm.	patchBelowMe _ self world patchAt: self fullBounds belowMorph: self.	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/8/1998 23:47'!wrap	| myBox box newX newY wrapped |	owner ifNil: [^ self].	myBox _ self fullBounds.	myBox corner < (50000@50000) ifFalse: [		self inform: 'Who is trying to wrap a hidden object?'. ^ self].	box _ owner bounds.	newX _ self position x.	newY _ self position y.	wrapped _ false.	((myBox right < box left) or: [myBox left > box right]) ifTrue: [		newX _ box left + ((self position x - box left) \\ box width).		wrapped _ true].	((myBox bottom < box top) or: [myBox top > box bottom]) ifTrue: [		newY _ box top + ((self position y - box top) \\ box height).		wrapped _ true].	self position: newX@newY.	(wrapped and: [owner isPlayfieldLike])		ifTrue: [owner changed].  "redraw all turtle trails if wrapped"! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 14:35'!newThumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new height: aHeight; morphRepresented: self! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 15:40'!thumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new extent: aHeight @ aHeight; morphRepresented: self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 08:21'!aboutToBeGrabbedBy: aHand	| extentToHandToHand |	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!closeDragAndDrop	self setProperty: #openToDragAndDrop toValue: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/11/1998 13:01'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!openDragAndDrop	self setProperty: #openToDragAndDrop toValue: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 17:02'!rootForGrabOf: aMorph	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 12:34'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	owner privateRemoveMorph: self.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 16:29'!substituteForMorph: aMorph beingDroppedOn: aPage	"Allows a morph that is one level above aPage in the containment hierarchy to have a say on which morph should be dropped"	^ nil ! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 8/4/1998 18:41'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld origin startPoint endPoint aPresenter |	aForm _ self imageForm offset: 0@0.	aPresenter _ self presenter.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition + origin.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	aPresenter soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'event handling' stamp: 'sw 7/3/1998 16:45'!cursorPoint	"A convenience"	^ self primaryHand lastEvent cursorPoint! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOverDragging: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:00'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:33'!mouseEnterDragging: evt	"Handle a mouseEnterDragging event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs.  The default response is to let my eventHandler, if any, handle it, or else to do nothing."	self eventHandler ifNotNil:		[^ self eventHandler mouseEnterDragging: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:38'!mouseLeaveDragging: evt	"Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it; else to do nothing."	self eventHandler ifNotNil:		[self eventHandler mouseLeaveDragging: evt fromMorph: self]! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!on: eventName send: selector to: recipient	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!removeLink: actionCode	self eventHandler ifNotNil:		[self eventHandler on: actionCode send: nil to: nil]! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!suspendEventHandler	self eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: self eventHandler.		self eventHandler: nil]! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenColor: evt	self assuredPlayer choosePenColor: evt! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenSize	self assuredPlayer choosePenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenColor	^ self player ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenDown	self player ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenSize	self player ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!liftPen	self assuredPlayer liftPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!lowerPen	self assuredPlayer lowerPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!penColor: aColor	self assuredPlayer penColor: aColor! !!Morph methodsFor: 'pen' stamp: 'di 9/3/1998 10:38'!penUpWhile: changeBlock 	"Suppress any possible pen trail during the execution of changeBlock"	self getPenDown		ifTrue: ["If this is a costume for a player with its pen down, suppress any line."				self liftPen.				changeBlock value.				self lowerPen]		ifFalse: ["But usually, just do it."				changeBlock value]! !!Morph methodsFor: 'pen' stamp: 'di 9/10/1998 16:18'!trailMorph	"You can't draw trails on me, but try my owner."	owner == nil ifTrue: [^ nil].	^ owner trailMorph! !!Morph methodsFor: 'naming' stamp: 'sw 8/11/1998 16:46'!choosePartNameSilently	^ self world model namePartSilently: self assuredPlayer! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:10'!knownName	extension == nil ifTrue: [^ nil].	^ extension externalName! !!Morph methodsFor: 'naming' stamp: 'sw 8/30/1998 09:48'!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:11'!setNamePropertyTo: aName	extension == nil ifTrue: [self assureExtension].	extension externalName: aName! !!Morph methodsFor: 'naming' stamp: 'tk 8/10/1998 16:00'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			self eventHandler ifNotNil: [				self eventHandler mouseDownSelector ifNotNil: [					hh _ self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				self eventHandler mouseUpSelector ifNotNil: [					hh _ self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/21/1998 16:31'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld startStepping: self.	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 7/19/1998 11:51'!startSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld"	self step.  "one to get started!!"	aWorld ifNotNil: [aWorld startStepping: self].	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message"	self player ifNotNil: [self player step]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ self player ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:56'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menus' stamp: 'di 9/14/1998 10:04'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:32'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left topLeft topRight bottomRight bottomLeft none) do:		[:anEdge |			menu add: anEdge asString selector: #setToAdhereToEdge: argument: anEdge.			((anEdge == #left) | (anEdge == #bottomLeft))				ifTrue:					[menu addLine]].	menu popUpAt: self position forHand: self primaryHand! !!Morph methodsFor: 'menus' stamp: 'sw 7/15/1998 21:16'!adhereToEdge: edgeSymbol	(owner == nil or: [owner isHandMorph]) ifTrue: [^ self].	self perform: (edgeSymbol, ':') asSymbol withArguments: (Array with: (owner bounds perform: edgeSymbol))! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:25'!setToAdhereToEdge: anEdge	anEdge ifNil: [^ self].	anEdge == #none ifTrue: [^ self removeProperty: #edgeToAdhereTo].	self setProperty: #edgeToAdhereTo toValue: anEdge.	self layoutChanged! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds _ bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld _ self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/5/1998 12:08'!addFontHandlesTo: aHalo box: box	"Add handles for controlling font, style, and emphasis choices to the halo"	| s |	s _ aHalo handleSize.	aHalo addHandleAt: (box bottomLeft + ((s+2)@0))		color: Color lightGreen on: #mouseDown send: #chooseFont to: self.	aHalo addHandleAt: (box bottomLeft + ((s+2*2)@0))		color: Color lightRed on: #mouseDown send: #chooseStyle to: self.	aHalo addHandleAt: (box bottomRight - ((s+2)@0))		color: Color lightBrown darker on: #mouseDown send: #chooseEmphasis to: self.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/6/1998 11:32'!addHalo	| halo |	halo _ HaloMorph new bounds: self fullBoundsInWorld.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 12:43'!editBalloonHelpText	| str  |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 22:11'!setBalloonText: stringOrText	extension == nil ifTrue: [self assureExtension].	extension balloonText: stringOrText! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!colorChangedForSubmorph: aSubmorph	"The color associated with aSubmorph was changed through the UI; react if needed"! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'sw 7/8/1998 13:21'!ownerChanged	"The receiver's owner, some kind of a pasteup, has changed its layout."	self snapToEdgeIfAppropriate! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!userSelectedColor: aColor	"The user, via the UI, chose aColor to be the color for the receiver; set it, and tell my owner in case he wishes to react"	self color: aColor.	owner ifNotNil: [owner colorChangedForSubmorph: self]! !!Morph methodsFor: 'player' stamp: 'sw 9/15/1998 13:33'!newPlayerInstance	^ UnscriptedPlayer newUserInstance! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!okayToDuplicate	self player ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!showPlayerMenu	self player ifNotNil:		[self player showPlayerMenu]! !!Morph methodsFor: 'player commands' stamp: 'sw 8/4/1998 18:41'!makeFenceSound	self presenter soundsEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!Morph methodsFor: 'player viewer' stamp: 'sw 6/25/1998 08:32'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts.  This remains somewhat awkward -- color is normally there, but for objects that only wear an image/sketch costume, offering color would be perplexing, so it's left to the costumes to decide.""		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:))]		ifFalse:			[Array new]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:53'!jettisonScripts	self player ifNotNil: [self player class jettisonScripts]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	self player ifNotNil:		[self player justClonedFrom: aDonor player]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:59'!restoreTypeColor	self player ifNotNil: [self player allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:46'!scriptEditorFor: aScriptName	^ self assuredPlayer scriptEditorFor: aScriptName! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!scriptPerformer	^ self player ifNil: [self]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!tearOffTile	| aValue |	self player ifNotNil: [^ self player tearOffTileForSelf].		(aValue _ self valueAsConstant) ifNotNil:		[^ self world primaryHand attachMorph: aValue newTileMorphRepresentative]. 	^ self assuredPlayer tearOffTileForSelf! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:	[NumericReadoutTile new typeColor: aColor]		ifFalse:	[StringReadoutTile new typeColor: aColor]. 	viewer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat]		ifFalse:			[viewer useDefaultFormat].	aTile addMorphBack: viewer.	putSelector == #unused ifFalse: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!useUniformTileColor	self player ifNotNil:		[self player allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 6/10/1998 17:33'!valueAsConstant	"If the receiver can be perceived by the end-user as bearing a data value of any type other than player-reference, return the literal representing its value at this very moment -- for the purpose of a value-tile being constructed."	^ nil! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:56'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	self player updateAllViewers.	self world addMorph: (anEditor _ self player scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/30/1998 09:53'!clearPaletteArea	| pal |	(pal _ self standardPalette) ~~ nil ifTrue:		[pal showNoPalette]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid _ Compiler evaluate: (FillInTheBlank request: 'Enter grid size' initialAnswer: '16').	Utilities informUser: 'Choose a background color' during: [backColor _ Color fromUser].	Utilities informUser: 'Choose a line color' during: [lineColor _ Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/30/1998 09:41'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do: [:i |		gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.		gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm.	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/26/1998 16:05'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/1/1998 18:01'!referencePlayfield	| former |	owner isPlayfieldLike ifTrue: [^ owner].	((owner isKindOf: HandMorph) and: [(former _ owner formerOwner) ~~ nil])		ifTrue:			[^ former isPlayfieldLike 				ifTrue:					[former]				ifFalse:					[former referencePlayfield]].	self isInWorld ifFalse: [^ nil].	^ self world submorphNamed: 'playfield'! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:18'!setStandardTexture	| parms |	parms _ self textureParameters.	self makeGraphPaperGrid: parms first		background: parms second		line: parms third! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:55'!succeededInRevealing: aPlayer	aPlayer == self player ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!textureParameters	"Answer a triplet giving the preferred grid size, background color, and line color.  The choices here are as suggested by Alan, 9/13/97"	^ Array with: 16 with: Color lightYellow with: Color lightGreen lighter lighter! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 12:48'!inPartsBin	| o |	self isPartsDonor ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:09'!isPartsDonor	extension == nil ifTrue: [^ false].	^ extension isPartsDonor! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:10'!isPartsDonor: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension isPartsDonor: aBoolean! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 13:02'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self isPartsDonor: true! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 18:00'!printStructureOn: aStream indent: tabCount	tabCount timesRepeat: [aStream tab].	self printOn: aStream.	aStream cr.	self submorphsDo: [:m | m printStructureOn: aStream indent: tabCount + 1].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s _ WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!Morph methodsFor: 'property extension' stamp: 'di 8/14/1998 12:55'!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize]! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 22:08'!copyPropertiesFrom: donorMorph dict: dict	(extension _ donorMorph extension copy) == nil ifTrue: [^ self].	extension copyPropertiesFrom: donorMorph dict: dict! !!Morph methodsFor: 'property extension' stamp: 'di 8/10/1998 14:25'!extension	^ extension! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 12:01'!otherProperties	extension == nil ifTrue: [^ nil].	^ extension otherProperties! !!Morph methodsFor: 'debug and other' stamp: 'sw 6/25/1998 15:50'!inspectOwnerChain	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	c asArray inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color _ aColor.! !!Morph methodsFor: 'private' stamp: 'tk 8/30/1998 09:58'!privateFullBounds: boundsRect	"Private!! Computed automatically."	fullBounds _ boundsRect.! !!Morph methodsFor: 'private' stamp: 'di 9/10/1998 16:21'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| trailMorph start |	(extension == nil or: [extension player == nil]) ifFalse:		["Most cases eliminated fast by above test"		self getPenDown ifTrue:			["If this is a costume for a player with its pen down, draw a line."			(trailMorph _ self trailMorph) ifNotNil:				[start _ self referencePosition.				trailMorph drawPenTrailFor: self from: start to: start + delta]]].	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"				fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [bounds _ bounds translateBy: delta.				fullBounds _ nil]! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 5/26/1998 15:33'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream |	aFileName _ ('my ', self class name) asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name? (".morph" will be added to end)' 			initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: aFileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 7/11/1998 18:53'!storeDataOn: aDataStream	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."	| cntInstVars cntIndexedVars ti localInstVars |	"block my owner unless he is written out by someone else"	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	localInstVars _ Morph instVarNames.	ti _ 2.  	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:			[self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPutWeak: owner.	"owner only written if in our tree"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Morph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:34'!convertbosfcepc0: varDict bosfce0: smartRefStrm	"These variables are automatically stored into the new instance ('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information in ('eventHandler' 'properties' 'costumee' )""This method moves all property variables as well as eventHandler, and costumee into a morphicExtension."	| propVal |	"Move refs to eventhandler and costumee into extension"	(varDict at: 'eventHandler') == nil ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') == nil ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') == nil ifFalse:		[(varDict at: 'properties') keys do:			[:key |  "Move property extensions into extension"			propVal _ (varDict at: 'properties') at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [key ifNotNil: [					self assureExtension.					extension convertProperty: key toValue: propVal]]]].			].! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/19/1998 11:52'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/19/1998 11:51'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	aMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[aMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	aMenu add: 'temp command' action: #tempCommand.	^ aMenu! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/19/1998 18:14'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/29/1998 21:28'!newBounds: bounds color: color	^ (self new privateBounds: bounds) privateColor: color! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 16:51'!morphsUnknownToTheirOwners	"Return a list of all morphs (other than HandMorphs) whose owners do not contain them in their submorph lists"	"Morph morphsUnknownToTheirOwners"	| problemMorphs itsOwner |	problemMorphs _ OrderedCollection new.	self allSubInstances do:		[:m | (m isHandMorph not and: [((itsOwner _ m owner) ~~ nil and: [(itsOwner submorphs includes: m) not])])			ifTrue:				[problemMorphs add: m]].	^ problemMorphs! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 17:31'!repairMorphsUnknownToTheirOwners	"Morph repairMorphsUnknownToTheirOwners"	| aList |	(aList _ self morphsUnknownToTheirOwners) do:		[:m | m privateOwner: nil].	^ aList size printString, ' morph(s) repaired'! !MorphExtension provides access to extra instance state that is not required in most simple morphs.  This allows simple morphs to remain relatively lightweight while still admitting more complex structures as necessary.  The otherProperties field takes this policy to the extreme of allowing any number of additional named attributes, albeit at a certain cost in speed and space.!!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!actorState	^ actorState! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!actorState: newValue	actorState _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonText	^ balloonText! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonText: newValue	balloonText _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonTextSelector	^ balloonTextSelector! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonTextSelector: newValue	balloonTextSelector _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!eventHandler	^ eventHandler! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!eventHandler: newValue	eventHandler _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName	^ externalName! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName: newValue	externalName _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!isPartsDonor	^ isPartsDonor! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:52'!isPartsDonor: newValue	isPartsDonor _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!locked	^ locked! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!locked: newValue	locked _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!player	^ player! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!player: newValue	player _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!sticky	^ sticky! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!sticky: newValue	sticky _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!visible	^ visible! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!visible: newValue	visible _ newValue! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	otherProperties == nil ifTrue: [^ false].	prop _ otherProperties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 12:02'!otherProperties	^ otherProperties! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!removeProperty: propName	otherProperties == nil ifTrue: [^ self].	otherProperties removeKey: propName ifAbsent: [].	otherProperties size == 0 ifTrue: [otherProperties _ nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!setProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName	otherProperties == nil ifTrue: [^ nil].	^ otherProperties at: propName ifAbsent: [nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName ifAbsent: aBlock	otherProperties == nil ifTrue: [^ aBlock value].	^ otherProperties at: propName ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:14'!copyPropertiesFrom: donorMorph dict: dict	| val |	otherProperties _ donorMorph otherProperties copy.	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | val _ assn value.			val isMorph ifTrue: [				val owner ifNil: [assn value: (val copyRecordingIn: dict)]]]].					"note side effecting.  Any un-owned morph belongs to us."! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:16'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot."	| old |	eventHandler == nil ifFalse:		[self eventHandler: self eventHandler copy.		1 to: self eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | assn value: (aDictionary at: assn value ifAbsent: [assn value])]].			"note side effecting"! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 14:19'!comeFullyUpOnReload	"inst vars have default booplean values."	locked ifNil: [locked _ false].	visible ifNil: [visible _ true].	sticky ifNil: [sticky _ false].	isPartsDonor ifNil: [isPartsDonor _ false].	^ self! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:31'!convertProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	propName == #locked ifTrue: [^ locked _ aValue].	propName == #visible ifTrue: [^ visible _ aValue].	propName == #sticky ifTrue: [^ sticky _ aValue].	propName == #balloonText ifTrue: [^ balloonText _ aValue].	propName == #balloonTextSelector ifTrue: [^ balloonTextSelector _ aValue].	propName == #actorState ifTrue: [^ actorState _ aValue].	propName == #player ifTrue: [^ player _ aValue].	propName == #name ifTrue: [^ externalName _ aValue].  "*renamed*"	propName == #partsDonor ifTrue: [^ isPartsDonor _ aValue].  "*renamed*"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'initialization' stamp: 'di 8/16/1998 12:02'!initialize	"Init all booleans to default values"	locked _ false.	visible _ true.	sticky _ false.	isPartsDonor _ false.! !!MorphExtension methodsFor: 'other' stamp: 'sw 8/20/1998 12:35'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == true ifTrue: [aStream nextPutAll: ' [visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !A morph whose appearance is a thumbnail of some other morph.!!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'reveal original morph' action: #revealOriginal.	aCustomMenu add: 'grab original morph' action: #grabOriginal.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 17:37'!computeThumbnail	| f scale |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale smoothing: 2).	self extent: originalForm extent! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:08'!grabOriginal	self primaryHand attachMorph: morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'all' stamp: 'jm 11/17/97 17:30'!morphRepresented	^ morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:04'!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail])		ifTrue:			[^ self beep].	morphRepresented owner == nil ifTrue:		[^ owner replaceSubmorph: self by: morphRepresented].	self beep.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!smaller	self form: (self form copy: (0@0 extent: self form extent // 2))! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 15:39'!thumbnailOfHeight: aHeight	self height: aHeight.	self computeThumbnail.	^ self! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/21/1998 17:54'!openOn: aWorldMorph label: aString cautionOnClose: aBoolean	"Open a view with the given label on the given WorldMorph."	| aModel |	aModel _ aBoolean		ifTrue:		[CautiousModel new]		ifFalse:		[WorldViewModel new].	^ self openOn: aWorldMorph label: aString model: (aModel initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 11:40'!openWorldWith: aMorph labelled: labelString	| w |	w _ WorldMorph new addMorph: aMorph.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:16'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:20'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicModel methodsFor: 'initialization' stamp: 'jm 8/20/1998 09:08'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!MorphicModel class methodsFor: 'instance creation' stamp: 'tk 8/13/1998 12:58'!new	"Return a copy of the prototype, if there is one.	Otherwise create a new instance normally."	self hasPrototype ifTrue: [^ prototype veryDeepCopy].	^ super new! !!MorphicModel class methodsFor: 'prototype access' stamp: 'tk 8/13/1998 12:58'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph veryDeepCopy.	(prototype isKindOf: MorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 22:44'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber.	moviePlayerMorph msSinceStart: scorePlayer msecsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 14:13'!frameNumber	^ frameNumber! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 17:04'!image: aForm player: aMoviePlayer frameNumber: n	self image: aForm.	moviePlayerMorph _ aMoviePlayer.	frameNumber _ n! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 21:57'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		(evt morph isMemberOf: MovieFrameSyncMorph) ifTrue: [^ evt]].	^ nil! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 08:06'!player	^ moviePlayerMorph! !!MovieMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:03'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:21'!fullControlSpecs	^ #(				('<<>>'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			('->'			nextPage		'Forward one frame')			('>>'			playForward	'Play forward')			( '-->'		lastPage			'Go to final page'))! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 14:05'!insertPage	^ self makeMyPage! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:56'!makeMyPage	currentPage ifNotNil: [currentPage releaseCachedState; delete].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	pages _ OrderedCollection with: currentPage.	self addMorphBack: currentPage.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 22:01'!openFileNamed: fName	| f w h d n m |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ m/1000.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 23:37'!position: newPos	super position: newPos.	(currentPage ~~ nil and: [currentPage left odd])		ifTrue: ["crude word alignment for depth = 16"				super position: newPos + (1@0)]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 17:12'!setInitialState	super setInitialState.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!frameNumber: n	frameNumber _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msPerFrame: n	msPerFrame _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msSinceStart: n	msSinceStart _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/8/1998 11:53'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self primaryHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:32'!firstPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 19:02'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step  "will stop after first step"! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!lastPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: frameCount! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!nextPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber + 1 min: frameCount).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playForward	(playDirection ~= 0 or: [frameNumber >= frameCount]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ 1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playReverse	(playDirection ~= 0 or: [frameNumber <= 1]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ -1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!previousPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber - 1 max: 1).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/5/1998 23:40'!stopPlay	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 22:59'!pauseFrom: player	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 08:46'!resetFrom: player	self pauseFrom: player.	frameNumber _ 1! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/17/1998 19:02'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self startRunning! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:47'!startRunning	| ff byteCount |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.	scorePlayer == nil ifTrue: [msSinceStart _ Time millisecondClockValue].! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:49'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If it is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  In either case, ssome calls on step will skip their  action until the right time."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	|  ff byteCount ms |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				ms < msSinceStart ifTrue: [msSinceStart _ ms "clock rollover"].				ms < (msSinceStart + msPerFrame) ifTrue: [^ self]]		ifFalse: [msSinceStart > scorePlayer msecsSinceStart ifTrue: [^ self]].	ff _ currentPage image. 	byteCount _ ff bits size * 4.	frameNumber _ frameNumber + playDirection.	msSinceStart _ msSinceStart + msPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.	currentPage changed.	(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].		"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:57'!stepTime	^ 0  "step as fast as possible"! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 19:01'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil:		[movieFile close.		movieFile _ nil].	playDirection _ 0.! !(out of date class....)!!MswUrl methodsFor: 'misc' stamp: 'ls 7/1/1998 02:23'!httpUrlOfServer	"return the HTTP address to make queries to"		#XXX.  "should come up with a better name for this when I'm less tired"	^HttpUrl schemeName: 'http'  authority: authority  path: path  query: nil.! !!MswUrl methodsFor: 'access' stamp: 'ls 7/12/1998 23:34'!query	"return the query.  There is never a MuSwiki URL without a query; the query defaults to 'top' if none is explicitly specified"	| q |	q _ super query.	q isNil ifTrue: [ q _ 'top' ].	^q! !!NetNameResolver class methodsFor: 'lookups' stamp: 'ls 9/5/1998 01:14'!addressForName: aString	^self addressForName: aString timeout: 60! !!NewParagraph methodsFor: 'composition' stamp: 'di 6/22/1998 12:37'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						hitCR ifTrue:							["If text ends with CR, add a null line at the end"							((lineY + lineHeightGuess) <= container bottom) ifTrue:								[row _ container rectanglesAt: lineY height: lineHeightGuess.								row size > 0 ifTrue:									[line _ (TextLine start: charIndex stop: charIndex-1										internalSpaces: 0 paddingWidth: 0)									rectangle: row first;									lineHeight: lineHeightGuess baseline: textStyle baseline.									lines addLast: line]]].						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/22/1998 12:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/14/1998 11:43'!defaultStartBlock	selectionStart ifNotNil: [^ selectionStart].	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/14/1998 11:45'!defaultStopBlock: aCharacterBlock	selectionStop ifNotNil: [^ selectionStop].	^ aCharacterBlock! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/20/1998 10:45'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [:i | rects addLast: (lines at: i) rectangle].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	^ time + duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!pitch	"Convert my MIDI key number to a pitch and return it."	^ AbstractSound pitchForMIDIKey: midiKey! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!endNoteOnMidiPort: aMidiPort	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: 0.! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!startNoteOnMidiPort: aMidiPort	"Output a noteOn event to the given MIDI port."	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: velocity.! !!Number methodsFor: 'mathematical functions' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Object methodsFor: 'accessing' stamp: 'jm 6/1/1998 12:41'!do: aBlock	"Obsolete!! Replaced by Object>in:. Apply the given block to the receiver, as if the receiver were contained in a collection with itself as the only element."	"Note: Calling this method 'do:' turned out to mask errors. For example, an initialized instance variable will respond to 'do:', passing nil as an argument. This method will be entirely removed in the future."	self notify:'Only collections should respond to "do:". The "do:" method in Object will soon be removed; clients depending on it should use "in:" instead. If you get this message in system code, please report it to johnm@wdi.disney.com. Proceed from this notifier to get the old behavior.'.	^ self in: aBlock! !!Object methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:51'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'testing' stamp: 'ls 7/14/1998 21:45'!isWebBrowser	"whether this object is a web browser.  See class: Scamper"	^false! !!Object methodsFor: 'comparing' stamp: 'sw 8/20/1998 12:34'!identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:01'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver.  These will be remapped in mapUniClasses, if needed."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 22:16'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new |	copier _ DeepCopier new initialize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	^ new! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self instVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new instVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new instVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'updating' stamp: 'jm 8/20/1998 18:26'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!modelWakeUp	"A window with me as model is being entered.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'private' stamp: 'di 5/28/1998 12:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System error handling failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		20 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	Smalltalk isMorphic ifTrue:		[^ World install "To init hand events and redisplay world"].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting' stamp: 'jm 6/1/1998 12:58'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ (OrderedCollection new: 1) add: self; yourself! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!Object methodsFor: 'objects from disk' stamp: 'tk 8/19/1998 15:03'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:22'!initialInstance	"Answer the first instance of the receiver, generate an error if there is one already"	"self instanceCount > 0 ifTrue: [self error: 'instance(s) already exist.']."		"Debugging test that is very slow"	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:27'!instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString	"Create a unique class for the receiver, and answer an instance of it"	^ (self newUniqueClassInstVars: instVarString 		classInstVars: classInstVarString) initialInstance! !!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 8/15/1998 15:26'!initialize	"remove all old class vars that are not instance-specific classes being renamed"	self clear.	"Most importantly, return self, so a fileIn will let ObjectScanner seize control.  So UniClasses can be remapped.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(10 247 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!PCXReadWriter methodsFor: 'accessing' stamp: 'tao 10/6/97 10:11'!nextImage	"Read in the next PCX image from the stream."	| bytes form |	self readHeader.	bytes _ self readBody.	colorPalette _ self readPalette.	self close.	form _ ColorForm extent: width@height depth: bitsPerPixel.	(Form new hackBits: bytes) displayOn: (Form new hackBits: form bits).	form colors: colorPalette.	^ form! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:38'!nextWord	^self next + (self next bitShift: 8)! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 10:07'!readBody	| array scanLine rowBytes position byte count pad |	pad _ #(0 3 2 1) at: (width \\ 4 + 1).	array _ ByteArray new: ((width + pad) * height * bitsPerPixel) // 8.	scanLine _ ByteArray new: rowByteSize.	position _ 1.	1 to: height do:		[:line |		rowBytes _ 0.		[rowBytes < rowByteSize] whileTrue:			[byte _ self next.			byte < 16rC0				ifTrue:					[rowBytes _ rowBytes + 1.					scanLine at: rowBytes put: byte]				ifFalse:					[count _ byte - 16rC0.					byte _ self next.					1 to: count do: [:i | scanLine at: rowBytes + i put: byte].					rowBytes _ rowBytes + count]].		array			replaceFrom: position			to: position + width - 1			with: scanLine			startingAt: 1.		position _ position + width + pad].	^ array! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 09:42'!readHeader	| xMin xMax yMin yMax |	self next.	"skip over manufacturer field"	version _ self next.	encoding _ self next.	bitsPerPixel _ self next.	xMin _ self nextWord.	yMin _ self nextWord.	xMax _ self nextWord.	yMax _ self nextWord.	width _ xMax - xMin + 1.	height _ yMax - yMin + 1.	self next: 4. "skip over device resolution"	self next: 49. "skip over EGA color palette"	colorPlanes _ self next.	rowByteSize _ self nextWord.	isGrayScale _ (self next: 2) = 2.	self next: 58. "skip over filler".! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:29'!readPalette	| r g b array |	self next = 12 ifFalse: [self error: 'no Color Palette!!'].	array _ Array new: (1 bitShift: bitsPerPixel).	1 to: array size do:		[:i |		r _ self next.  g _ self next.  b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)].	^ array.! !Post Office Protocol.  This is used to download email over the network, usually from an intermittent connection.  To see how to use it, see POPSocket classe>>example.!!POPSocket methodsFor: 'private-initialization' stamp: 'ls 9/7/1998 05:27'!initialize	super initialize.	progressObservers _ IdentitySet new.! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:14'!addProgressObserver: anObserver	"progress will be sent to anObserver.  anObserver should respond to show:, endEntry, cr....  Transcript things"	progressObservers add: anObserver! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!password: aString	"set the password to use"	password _ aString ! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:22'!serverName: aString	"set the server name to connect to"	serverName _ aString! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!userName: aString	"set the username to use"	userName _ aString! !!POPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 19:57'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString.		aString last = Character cr ifFalse: [ observer show: String cr ]].! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 06:40'!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find the address for ', serverName	].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:55'!deleteAllMessages	"delete all messages"	1 to: self numMessages do: [ :num |		self deleteMessage: num ]! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:07'!deleteMessage: num	"delete the numbered message"	self sendCommand: 'DELE ', num printString.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 20:00'!disconnectFromPOP	"send a QUIT message and disconnect"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:54'!messagesDo: aBlock	"perform aBlock on each message text"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		aBlock value: thisMessage.	].	! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 02:02'!numMessages	"query the number of messages that are in the POP mailbox"	| response answerString |	numMessages ifNotNil: [ ^numMessages ].	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [ 		"ERROR"		^0 ].	[			answerString _ (response findTokens: Character separators) second.		numMessages _ answerString asNumber asInteger.		^numMessages	] ifError: [ :a :b |	].	"parse error"	^0! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:04'!retrieveMessage: number	"retrieve the numbered message"	| response |	self sendCommand: 'RETR ', number printString.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [		self error: 'error: ', response ].	^self getMultilineResponse.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 19:44'!example	"POPSocket example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/19/1998 22:43'!getMessagesNotifying: aProgressReporter andForEachDo: aBlock	|  s |		self initializeNetwork.	s _ self createIfFail: [self error: 'For some reason I could not create a POP socket'].	^s getMessagesNotifying: aProgressReporter andForEachDo: aBlock.! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 9/10/1998 15:35'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(request fields includesKey: 'text') ifTrue: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			username: (request fields at: 'username' ifAbsent:[''])			password: (request fields at: 'password' ifAbsent: [''])			privs: (request fields at: 'privs' ifAbsent: [''])			text: (request fields at: 'text' ifAbsent: ['blanktext'])			from: request peerName.		page user: request userID.  "Address is machine, user onlyif logged in"		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!PSwikiAction methodsFor: 'all' stamp: 'tk 9/16/1998 16:21'!process: request	"URLs are of the form:	{swikiname} to browse Front Page	{swikiname}.{coreID} to browse the page	{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.{coreID}.versions displays the last three versions of the page	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case) 		return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, Versions, or Edit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded:							(self fileContents: source , 'results.html')						with: (urlmap searchFor: pageRef name)).			^ self].		command = 'all' ifTrue:			[formattedPage _ urlmap allPagesFrom: pageRef for: request.			request reply: (HTMLformatter evalEmbedded:							(self fileContents: source, 'page.html')						with: formattedPage).			^ self].		(request message at: 1) = (request message at: 2) ifTrue: [			request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.			request message: (request message copyFrom: 2 to: request message size).			^ self process: request].	"(success and contentHTML will be sent twice!!)"		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !!PSwikiPage methodsFor: 'all' stamp: 'BJP 9/10/1998 14:33'!outputFormat	| formatCollection textBlock |"Ah, yes, my first experience with class vars. I need to think about thisscheme a bit, but it's only	 a placeholder anyway. BJP"	formatCollection _ OrderedCollection newFrom: super outputFormat.	textBlock _ formatCollection last.	^ formatCollection		add: [:thePage | 'authName: ', thePage usernameprintString, '; ']before: textBlock;		add: [:thePage | 'authPW: ', thePage password printString,'; ']before: textBlock;		add: [:thePage | 'privs: ', thePage privs printString, '; ']before: textBlock.! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:40'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		(page privs includesSubString: 'read') ifTrue:			[(action auth user: request userID) = page coreID			ifFalse: [self error: (PWS unauthorizedFor: (pagename))]].		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:36'!newpage: label from: peer	| newpage newfile |		newpage _ PSwikiPage new.		self at: label put: newpage.		newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage username: ''.		newpage password: ''.		newpage privs: ''.		newpage pageStatus: #new.		newpage file: ((ServerAction serverDirectory),			directory, (ServerAction pathSeparator), newfile).		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	^newpage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:39'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new].	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL:page),'...',(page address).		(page privs includesSubString: 'read') ifTrue:			[response nextPutAll: '  <b>Read protected</b>'.].		(page privs includesSubString: 'write') ifTrue:			[response nextPutAll: '  <b>Write protected</b>'.].].	response nextPutAll: '</ul>'.	^response contents! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:41'!storeID: id  username: theUsername password: thePassword privs: thePrivstext: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page address: peer.	(theUsername size > 1) ifTrue: [		page username: theUsername.		page password: thePassword.		page privs: thePrivs.		"Set up the authorization"		action auth mapName: theUsername password: thePassword			to: id.].	page text: text.	^ page! !!PWS methodsFor: 'Accessing' stamp: 'tk 9/16/1998 15:50'!message: anArray   message _ anArray! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:47'!initializeFrom: aSocket	"Initialize me from aSocket."	| request idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	"sets header"	header _ header substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at:idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ self clientName: connection remoteAddress.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	request last notNil		ifTrue: [ fields := self decodeFields: request last ]		ifFalse: [ (url includes: $?) ifTrue: [			idx _ url indexOf: $?.			idx = url size				ifTrue: [ "empty request" fields _Dictionary new ]				ifFalse: [					fields _ self decodeFields:						(url copyFrom: idx+1 to:url size) ].			url _ url copyFrom: 1 to: idx-1 ] ].	message := url findTokens: '/.\?:='.! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:44'!readRequest	"Read the request and return an array of header and query."	| idx request query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf)startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString:'CONTENT-LENGTH:' startingAt: 1) = 0			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to:		  (request indexOf: Character cr startingAt: lengthifAbsent: []))			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request,connection getData ].		query := (request copyFrom: idx + 3 to: request size)withBlanksTrimmed ].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'tk 7/15/1998 12:06'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request -- ', self classcrlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS methodsFor: 'Processing' stamp: 'ls 7/28/1998 01:09'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut:			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $%					ifTrue: [ (Number readFrom: (rsnext: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents ! !!PWS class methodsFor: 'HTTPcodes' stamp: 'tk 6/24/1998 16:24'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body></html>'! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:36'!checkVersion	"This is Squeak 2.2.  Make sure that the Server:swiki folder is the version for 2.2."	| fName |	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'page.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'The path to the Server folder is wrong.Please modify the following method ...'. 	Browser openMessageBrowserForClass: ServerAction class 		selector: #serverDirectory editString: nil.	^ false].	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'render.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'Initialization failed.  ''swiki'' folder is out of date.Get one from:http://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.tar orhttp://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.sea'. ^ false].	^ true! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:03'!howToStart	"To set up your new Swiki, you need a copy of the 'Server' folderfound at:http://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/Put the 'Server' folder into the folder that your image is in.Modify this method to be a path to your Server folder, select it, andchoose fileItIn:!!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!!serverDirectory	^ 'Hard Disk:Squeak1.31:Server:'!! !!Then do:	PWS initializeAll.To enable a new Swiki called OurOwnArea.Make a folder named OurOwnArea in the Server folder.  Then do:	SwikiAction setUp: 'OurOwnArea'.	(its main URL is http://thisMachine:80/OurOwnArea.1)<<<<There has been a major change between Squeak 2.1 and 2.2.  If you are reloading an existing Swiki for the first time in Squeak 2.2, Do this instead of the normal reload.	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	(PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineEndings ].	PWS serveOnPort: 80 loggingTo: 'log.txt'.(This to converts LineFeeds to CarriageReturns in all of your swiki data files.  Only do this the first time!!)>>>>>Suppose you already have a Swiki called 'myswiki'.To start up:	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	PWS serveOnPort: 80 loggingTo: 'log.txt'.To stop the server:	PWS stopServer.-----------------------To purge a particular file of all except the latest version:	((PWS actions at: 'myswiki' asLowercase) urlmap atID: '3') condenseChanges.To roll the entire wiki back to a previous time:	""This does not erase data, it just copies the older page to the end""	(PWS actions at: 'myswiki' asLowercase) rollBack: '1/28/98' asDate			at: '1:30 am' asTime.The look of a served page is controlled by a template.  Templates live inthe 'swiki' folder in the 'Server' folder.  Beware that templates arecached by HTMLformatter.  If you change a template, you will not see theeffect until you reload the Swiki.To set up a Swiki with a password (same for all users), seeAuthorizedSwikiAction comment.To enable a privledged user to execute code remotely (on a workspace page):	(PWS actions at: 'authorized') mapName: 'JSmith' password:'hard2guess' to: 'JSmith'.	(URL is http://thisMachine:80/authorized.workspace.html)To backup the user data to the disk, do nothing.  All info is alreadyinside the page files on the disk.To enable a new Swiki that evaluates Squeak code submitted by the user.Make a folder named SqkEval in the Server folder.  Then do:	ActiveSwikiAction setUp: 'SqkEval'.	(this is dangerous, because there are still ways a user could crashyour server)To convert a Swiki with LineFeed line endings to CarriageReturn lineendings, execute these lines:          (PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineENdings ]To convert from an old pre-Squeak1.3 Swiki to the new page format:	(In the old image, do a backup:)		| mine | mine _ PWS actions at: 'myswiki'.		mine saveTo: mine path,'backup28JanA'.	(Quit.  Start the new image which has this version of the Swiki code)	(Do not start the server!!!!!!)		PWS initializeAll.		SwikiAction restore: 'myswiki' from:			(ServerAction serverDirectory), 'myswiki:backup28JanA'.		(PWS actions at: 'myswiki' asLowercase) convert.	(do these steps for each Swiki you have)	(now, start the server)	PWS serveOnPort: 80 loggingTo: 'log.txt'."!]style[(10 712 46 2904)f1b,f1,f3,f1! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:20'!initializeAll	| anAuthorizer |	(self checkVersion) ifFalse: [^ false].	anAuthorizer _ Authorizer new.	anAuthorizer realm: 'AuthorizedSpace'."	anAuthorizer mapName: 'JSmith' password: 'hard2guess' to: 'JSmith'.  "		"No default account!!  See howToStart to enable remote code execution."	self link: 'authorized' to: (AuthorizedServerAction new authorizer: anAuthorizer).	self link: 'chat' to: ChatPage new.	self link: 'default' to: ServerAction new.	self link: 'embedded' to: EmbeddedServerAction new.	self link: 'smtlk' to: CodeServer new.	self link: 'chunk' to: CodeServer new.	Comment setUpExample.	self link: 'comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).! !!PWS class methodsFor: 'Serving' stamp: 'tk 7/15/1998 11:27'!serveShowingErrorsOnPort: portNumber	"Start up the HTTP server loop for debugging!!  Operate in thisprocess, synchronously.  Force errors to stop the server and show on thescreen.."	| socket logEntry inst |	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: 'dummy.log'.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil			ifTrue: ["serve:"				inst _ self new.				inst initializeFrom: socket.				inst getReply.				socket closeAndDestroy: 30.				logEntry _ inst log contents]		"nologging for now"			ifFalse: [(Delay forMilliseconds: 100) wait]].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 6/11/1998 11:25'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting.				self setAction: #paint:]].! !!PaintBoxMorph class methodsFor: 'all' stamp: 'tk 8/13/1998 13:00'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ FormCanvas on: button onImage.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 7/16/1998 00:02'!initialize	super initialize.	self image: (ScriptingSystem formAtKey: 'Painting')! !!PaintInvokingMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:03'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor ifFalse: [^ self].	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !!PaintInvokingMorph class methodsFor: 'all' stamp: 'sw 7/15/1998 21:24'!authoringPrototype	^ self new image: (ScriptingSystem formAtKey: 'Painting'); markAsPartsDonor; yourself! !!Paragraph methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:48'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'composition' stamp: 'jm 5/29/1998 14:48'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'di 9/14/1998 11:42'!defaultStartBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'character location' stamp: 'di 9/14/1998 11:45'!defaultStopBlock: aCharacterBlock	^ aCharacterBlock! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 9/14/1998 11:45'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultStartBlock.	stopBlock _ paragraph defaultStopBlock: startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/21/1998 23:03'!prettyPrint	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model messageListIndex = 0 ifTrue: [^view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 8/24/1998 09:56'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  Inconvenient to have it here in this separate method; when/if we consolidate via a class variable, as for unshifted, the problem will go away.  1/17/96 sw	 3/7/96 sw: added methodSourceContainingIt	 3/13/96 sw: merged ParagraphEditor and StringHolderController versions into ParagraphEditor, and deleted the StringHolderController versions	 5/27/96 sw: added offerFontMenu	 8/20/96 sw: makeover"	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu unshiftedYellowButtonActivity)"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 6/26/1998 15:04'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesAndSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 8/24/1998 09:57'!prettyPrint: characterStream 	"Triggered by Cmd-shift-P; reformat this code by prettyPrinting the parse tree"	sensor keyboard.		"flush character"	self prettyPrint.	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 8/24/1998 09:58'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$p	prettyPrint:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!Parser methodsFor: 'scanning' stamp: 'sn 9/19/97 19:32'!advance    | this |    prevMark _ hereMark.    prevToken _ "Now means prev size"        self previousTokenSize.    this _ here.    here _ token.    hereType _ tokenType.    hereMark _ mark.    self scanToken.    ^this! !!Parser methodsFor: 'error correction' stamp: 'tk 8/11/1998 21:52'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Parser methodsFor: 'private' stamp: 'sn 9/19/97 19:31'!previousTokenSize    "Answer the size of the previous token. Bugfix for Strings."    hereType == #number ifTrue: [^mark - prevMark].    hereType == #string ifTrue: [^here size + 2].    "One for eachsingle quote"    ^here size! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'tk 8/13/1998 16:52'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy isPartsDonor: false]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PartsBinMorph class methodsFor: 'all' stamp: 'sw 8/19/1998 15:18'!includeInNewMorphMenu	"Not to be instantiated from the menu. The PartsBinMorph is misleadingly named, and is extremely special-purpose"	^ false! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 9/10/1998 14:45'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 7/6/1998 22:42'!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self beRepelling.	self layoutChanged! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 9/10/1998 14:46'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	self presenter coloredTilesEnabled ifFalse:		[m makeAllTilesGreen].	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:55'!caretColor	^ CaretColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:56'!controlButtonColor	^ ControlButtonColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/15/1998 13:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:08'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:09'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeScripts	| r aButton aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'add script' font: (aFont _ StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'add inst var' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	r addMorphBack: aButton.	^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/10/1998 14:32'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(TilePadMorph colorForType: #color)).	^ outerPhrase! !!PartsViewer methodsFor: 'private' stamp: 'sw 7/3/1998 17:31'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ TilePadMorph colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 17:55'!includeInNewMorphMenu	^ false! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 18:00'!initialize	"PartsViewer initialize"	CaretColor _ Color green muchLighter.	ControlButtonColor _  Color green muchLighter! !!PasteUpMorph methodsFor: 'initialization' stamp: 'di 9/3/1998 09:19'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	gradientDirection _ #vertical.	color _ Color r: 0.8 g: 1.0 b: 0.6.	fillColor2 _ color.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	openToDragNDrop _ true.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'display' stamp: 'di 9/3/1998 09:16'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	turtleTrailsForm ifNotNil: [aCanvas image: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 7/2/1998 15:09'!padding	^ padding! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:56'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/18/1998 09:10'!automaticPhraseExpansion	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/17/1998 12:58'!automaticViewing	^ (self standardPalette ~~ nil) and: [self hasProperty: #automaticViewing]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/15/1998 13:40'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph thumbnailOfHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:41'!repelsMorph: aMorph event: ev	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [		aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/6/1998 17:37'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy]].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/2/1998 14:51'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:42'!wantsDroppedMorph: aMorph event: evt^ ((self openToDragNDrop and: [self isPartsBin not]) and: [	self bounds containsPoint: evt cursorPoint]) and: [		((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [			aMorph isKindOf: SystemWindow]) not]! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 8/3/1998 13:43'!laySubpartsOutInOneRow	| aPosition |	aPosition _ 0 @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition _ aMorph topRight]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/1998 13:22'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self addStackMenuItems: menu hand: aHandMorph.	self addPenMenuItems: menu hand: aHandMorph.	self addPlayfieldMenuItems: menu hand: aHandMorph.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #paintBackground to: self."	aHalo addHandleAt: box leftCenter color: Color veryVeryLightGray on: #mouseDown send: #makeNewDrawingWithin to: self."! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:11'!addPenMenuItems: menu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 8/5/1998 18:25'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #impartPrivatePresenter].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:10'!addStackMenuItems: menu hand: aHandMorph	| subMenu |	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 9/9/1998 13:21'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ super debuggingMenuFor: aHandMorph.	aMenu add:  'abandon costume history' target: self action: #abandonCostumeHistory.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/5/1998 18:13'!wantsHaloFor: aSubMorph	^ (isPartsBin ~~ true and: [openToDragNDrop ~~ false]) and:		[self wantsMouseOverHalos]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:16'!setThumbnailHeight	|  reply |	reply _ FillInTheBlank		request: 'New height for thumbnails? '		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply _ reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!'].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:26'!toggleAlwaysShowThumbnail	(self hasProperty: #alwaysShowThumbnail)		ifTrue:			[self removeProperty: #alwaysShowThumbnail]		ifFalse:			[self setProperty: #alwaysShowThumbnail toValue: true].	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand _ self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current _ self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'di 8/11/1998 13:04'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ self isPartsBin not.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/8/1998 10:58'!toggleMouseOverHalos	wantsMouseOverHalos _ self wantsMouseOverHalos not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:24'!updateSubmorphThumbnails	| thumbsUp aHeight itsThumbnail |	thumbsUp _ self alwaysShowThumbnail.	aHeight _ self heightForThumbnails.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph thumbnailOfHeight: aHeight.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos	^ wantsMouseOverHalos == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos _ aBoolean! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 19:16'!makeNewDrawingWithin	| bnds |	bnds _ self paintingBoundsAround: self boundsInWorld center.	self primaryHand makeNewDrawingInBounds: bnds pasteUpMorph: self.! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 18:52'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ ScriptingSystem reasonablePaintingExtent.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 09:27'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds. On return, turtleTrailsForm exists and is the correct size."	| newForm |	turtleTrailsForm ifNil: [		"create new turtleTrailsForm if needed"		turtleTrailsForm _ Form extent: self extent depth: 8.		turtlePen _ Pen newOnForm: turtleTrailsForm.		^ self].	turtleTrailsForm extent = self extent ifFalse: [		"resize turtleTrailsForm if my size has changed"		newForm _ Form extent: self extent depth: 8.		newForm copy: self bounds from: turtleTrailsForm					to: 0@0 rule: Form paint.		turtleTrailsForm _ newForm.		turtlePen _ Pen newOnForm: turtleTrailsForm].! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 10:44'!drawPenTrailFor: aMorph from: oldPoint to: newPoint	"Draw a pen trail for aMorph, using its pen state (the pen is assumed to be down)."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin mPenSize offset |	self createOrResizeTrailsForm.	origin _ self topLeft.	mPenSize _ aMorph getPenSize.	turtlePen sourceForm width ~= mPenSize		ifTrue: [turtlePen squareNib: mPenSize].	offset _ (mPenSize // 2)@(mPenSize // 2).	turtlePen color: aMorph getPenColor.	turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint.	self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!liftAllPens	submorphs do: [:m | m assuredPlayer liftPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!lowerAllPens	submorphs do: [:m | m assuredPlayer lowerPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/10/1998 16:17'!trailMorph	"Yes, you can draw trails on me."	^ self! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 8/30/1998 09:44'!allTileScriptingElements	^ self allMorphs select:		[:s | s isTileScriptingElement]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 9/15/1998 13:37'!emptyAnonymousScriptorFrom: aPlaceHoldingMorph	| aScriptor aPlayer |	aPlayer _ aPlaceHoldingMorph valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer anonymousScriptEditorFor: nil.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 6/18/1998 09:17'!expandPhrasesToScripts	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:47'!becomeStack	currentDataInstance _ self assuredPlayer.	dataInstances _ OrderedCollection with: currentDataInstance.	isStackLike _ true.	self borderWidth: (self borderWidth + 1).	submorphs do:		[:aMorph | aMorph holdsDataForEachInstance			ifTrue:				[aMorph becomeField]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:50'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	self player: anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 9/9/1998 10:45'!abandonCostumeHistory	self allMorphsDo:		[:m | m player ifNotNil: [m player forgetOtherCostumes]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:46'!allScriptEditors	^ self allMorphs select:		[:s | s isKindOf: ScriptEditorMorph]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:19'!alwaysShowThumbnail	^ self hasProperty: #alwaysShowThumbnail! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:39'!heightForThumbnails	^ self valueOfProperty: #heightForThumbnails ifAbsent: [40]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:08'!impartPrivatePresenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles.		presenter addStopStepGoButtons.		presenter addTrashCan.		presenter standardPlayer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'jm 9/11/1998 09:40'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	owner ifNotNil: [owner invalidRect: (damageRect intersect: bounds)].! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseX	^ (self cursorPoint x) - self left! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseY	^ self bottom - (self cursorPoint y)! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/17/1998 12:06'!navigateTo	self inform: 'Not quite yet!!Later, you can directly retargetthis area so that it displays thecontents of any url'.! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 9/3/1998 09:19'!prepareToBeSaved	super prepareToBeSaved.	turtlePen _ nil! !!PasteUpMorph methodsFor: 'misc' stamp: 'tk 8/3/1998 17:52'!releaseCachedState	presenter ifNotNil: [presenter flushViewerCache].	super releaseCachedState! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 22:02'!removeScriptingControls	self deleteSubmorphsWithProperty: #scriptingControl! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/1998 22:53'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	self autoLineLayout		ifTrue:			[self fixLayout]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/25/1998 09:26'!roundUpStrays	self submorphsDo:		[:m |			m goHome.			m isPlayfieldLike ifTrue: [m roundUpStrays]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 18:13'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:")].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 8/8/1998 14:09'!smallThumbnailForPageSorter	^ BookPageThumbnailMorph new smaller page: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:34'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self presenter flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self presenter allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:35'!stepAll	self presenter allExtantPlayers do:		[:aPlayer | 			aPlayer startRunning; step; stopRunning.			aPlayer costume goHome]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:33'!stopRunningAll	"Stop running all scripted morphs.  Triggered by user hitting STOP button"	self presenter allExtantPlayers  do:		[:aPlayer |			aPlayer stopRunning.			aPlayer costume goHome].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:38'!thumbnailForPageSorter	^ BookPageThumbnailMorph new page: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:47'!updateStatusForAllScriptEditors	self allScriptEditors do: [:anEditor | anEditor updateStatus]! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcep0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepcbbfgcc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from BookPageMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 6/18/1998 10:31'!convertbosfcepcbbfgccpmcpbttloiairfidcuw0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"These variables are automatically stored into the new instance ('presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'openToDragNDrop' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle')."	"Incoming morphs have extra inst var: 'wantsMouseOverHalos'"! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 6/30/1998 17:00'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter; borderWidth: 1; 		borderColor: Color green darker; extent: 100 @ 80.	proto setProperty: #expandedExtent toValue: 300 @ 240.	proto beSticky.	^ proto! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points == nil ifTrue:		[points _ OrderedCollection new: 1000.		points addLast: p1].	points addLast: p2! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!actualObject	"Answer the player that's the object of my attention"	^ self associatedPlayer! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!associatedPlayer	"Answer the player that's the object of my attention"	^ self firstSubmorph firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!catchDivideByZero: aStream indent: tabCount	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	(submorphs at: 2) type = #operator ifFalse: [^ false].		"not me"	(submorphs at: 2) operatorOrExpression == #/ ifFalse: [^ false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs at: 3) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| aStream |	aStream _ ReadWriteStream on: ''.	self storeCodeOn: aStream indent: 1.	^ aStream contents! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:24'!handlesDragOver: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:57'!handlesMouseOverDragging: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 6/29/1998 09:22'!inPartsBin	| o |	o _ self owner.	[o == nil] whileFalse:		[(o isKindOf: PartsBinMorph) ifTrue: [^ true].  "special case for ancient Parts Viewer stuff"		o _ o owner].	^ super inPartsBin! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:15'!isPossessive	^ false! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	"Add in some smarts for division by zero."	aStream nextPut: $(.	(submorphs at: 1) storeCodeOn: aStream indent: tabCount.	aStream space.	(submorphs at: 2) storeCodeOn: aStream indent: tabCount.	submorphs size > 2 ifTrue: [		(self catchDivideByZero: aStream indent: tabCount) ifFalse: [			aStream space.			(submorphs at: 3) storeCodeOn: aStream indent: tabCount]].	aStream nextPut: $).! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:57'!try	| aPlayer |	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false].	(Delay forMilliseconds: 200) wait! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 17:05'!initialize	super initialize.	self color: Color black.	whiteKeyColor _ Color veryLightGray.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/20/1998 14:00'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 24.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/9/1998 10:45'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [soundPlaying stopGracefully].! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 12:57'!soundPrototype: aSound	soundPrototype _ aSound! !PianoRollNoteMorphs, as their name implies, are used to display musical notes on a piano roll.  The design is centered around speed of display, compact representation through sharing, and the ability to display in any color without having to make new note forms.The note shapes are stored as ColorForms, which are then displayed in paint mode (0 is transparent) using the individual note color in the color map.Each note carries an offset which can be used to display complex note shapes so that the center of the note ellipse appears in the proper location.!!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 8/28/1998 15:51'!drawOn: aCanvas	image replaceColorAtIndex: NoteColorIndex with: color.	super drawOn: aCanvas! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 8/31/1998 11:31'!newBounds: boundRect color: fillColor image: noteForm	"This message incorporates all necessary initialization for enhanced performance"	bounds _ boundRect.	owner _ nil.	submorphs _ EmptyArray.	color _ fillColor.	image _ noteForm! !!PianoRollNoteMorph class methodsFor: 'class initialization' stamp: 'di 8/29/1998 06:07'!initialize  "PianoRollNoteMorph initialize"	| j1 dot j2 noteColor |	NoteForms _ Array new: 200.	NoteColorIndex _ 250.	noteColor _ Color indexedColors at: NoteColorIndex.	j1 _ 1.	6 to: 28 do: 		[:i | dot _ ((EllipseMorph newBounds: (0@0 extent: i@i) color: noteColor)					imageFormDepth: 8) as8BitColorForm.		j2 _ i*i//4.		j1 to: j2 do: [:j | NoteForms at: j put: dot].		j1 _ j2+1].	j1 to: NoteForms size do: [:j | NoteForms at: j put: dot].! !!PianoRollNoteMorph class methodsFor: 'instance creation' stamp: 'di 8/31/1998 11:32'!newBounds: boundsRect color: trackColor	"boundsRect is the rectangle for old-style piano roll notes."	| noteForm locPoint |	noteForm _ NoteForms atPin: boundsRect width.	locPoint _ boundsRect topLeft + (0@(1 - (noteForm height//2))).	^ self basicNew		newBounds: (locPoint extent: noteForm extent)		color: trackColor		image: noteForm! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:08'!acceptDroppingMorph: aMorph event: evt	"In addition to placing this morph in the pianoRoll, add a corresponding	event to the score so that it will always appear when played, in addition	to possibly triggering other actions"	| ambientEvent |	ambientEvent _ AmbientEvent new morph: aMorph;							time: (self timeForX: aMorph left).	super acceptDroppingMorph: aMorph event: evt.	score addAmbientEvent: ambientEvent.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 15:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #openToDragAndDrop) == true	ifTrue: [aCustomMenu add: 'close drag anddrop' action: #closeDragAndDrop]	ifFalse: [aCustomMenu add: 'open drag and drop' action: #openDragAndDrop]! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 9/7/1998 22:13'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"		track _ score ambientTrack.		i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated.							visibleMorphs add:								("PianoRollNoteMorph"  Morph  "<-- Change comment quotes here**"									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!contractTime	timeScale _ timeScale / 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:20'!drawOn: aCanvas	| innerBox center |	super drawOn: aCanvas.	self drawStaffOn: aCanvas.	innerBox _ self innerBounds.	center _ innerBox center x.	aCanvas		fillRectangle: (center@innerBox top corner: (center + 1)@innerBox bottom)		color: Color red.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:01'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	blackKeyColor _ Color gray: 0.7.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!expandTime	timeScale _ timeScale * 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:33'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	fullBounds ifNil: [fullBounds _ bounds].	^ bounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:03'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	self drawOn: aCanvas.	submorphs isEmpty ifFalse: [		clippingCanvas _ aCanvas copyClipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 8/27/1998 16:39'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 18:59'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 07:52'!isBlackKey: midiKey	"Answer true if the given MIDI key corresponds to a black key on the piano keyboard."	| note |	note _ midiKey \\ 12.	note = 1 ifTrue: [^ true].	note = 3 ifTrue: [^ true].	note = 6 ifTrue: [^ true].	note = 8 ifTrue: [^ true].	note = 10 ifTrue: [^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:20'!layoutChanged	"Override this to avoid propagating 'layoutChanged' when just adding/removing note objects."	fullBounds = bounds ifTrue: [^ self].	super layoutChanged.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:03'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	lowestNote _ 24.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:48'!privateRemoveMorph: aMorph	score removeAmbientEventWithMorph: aMorph.	^ super privateRemoveMorph: aMorph! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/22/1998 09:33'!step	| t fudge |	score ifNil: [^ self].	approximateScreenUpdateTime ifNil: [approximateScreenUpdateTime _ 1000].	lastStepMSec ifNotNil: [		"compute the approximate redisplay time"		"Details: lastStepMSecs is set only when we've updated the piano roll, so		 this display time estimate is done on the cycle following an actual piano roll		 update. The goal is to adjust for different processor speeds automatically."		t _ Time millisecondClockValue - lastStepMSec.		(t > 0 and: [t < (4 * approximateScreenUpdateTime)]) ifTrue: [			"ignore clock wrap (i.e., t < 0) and very large values of t for stability"			approximateScreenUpdateTime _ (approximateScreenUpdateTime + t) // 2].		lastStepMSec _ nil].  "don't do this calculation again until the next real piano roll update"	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		lastStepMSec _ Time millisecondClockValue.		fudge _ 5.  "alignment tweak, in pixels"		self goToTime:			t - (((self width // 2) - borderWidth + fudge) asFloat / timeScale) truncated +			(scorePlayer ticksForMSecs: approximateScreenUpdateTime).		self addNotes.		lastUpdateTick _ t].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:07'!stepTime	^ 0! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:35'!timeForX: aNumber	^ ((aNumber - bounds left - borderWidth) asFloat / timeScale + leftEdgeTime) asInteger! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:29'!xForTime: aNumber	^ ((aNumber - leftEdgeTime) asFloat * timeScale) asInteger + bounds left + borderWidth! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:35'!yForMidiKey: midiKey	^ (bounds bottom - borderWidth - 4) - (3 * (midiKey - lowestNote))! !!PinMorph methodsFor: 'events' stamp: 'jm 5/29/1998 14:33'!handlesMouseDown: evt	^ (evt yellowButtonPressed | evt blueButtonPressed) not! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!bend	^ bend! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend	bend _ midiPitchBend.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend channel: midiChannel	bend _ midiPitchBend.	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isPitchBend	^ true! !!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rE0		channel: channel		byte: (bend bitAnd: 16r7F)		byte: (bend bitShift: -7).! !!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': bend '.	bend printOn: aStream.	aStream nextPut: $).! !!Player methodsFor: 'card/stack commands' stamp: 'sw 8/17/1998 17:23'!deleteCard	"Still underway"	true ifTrue: [^ self beep].	self costume deleteCard! !!Player methodsFor: 'clone' stamp: 'tk 8/31/1998 15:46'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this in mapUniClasses"	newCls slotInfo: self class privateSlotInfo deepCopy.	newCls copyAddedStateFrom: self class.  "All class inst vars for inter Player refs"	^ newCls! !!Player methodsFor: 'clone' stamp: 'sw 9/15/1998 13:12'!initializeCostumesFrom: aPlayer	"Used to copy costume info over from an UnscriptedPlayer to a Player UniClass"	costume _ aPlayer costume.	costumes _ aPlayer costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:42'!availableCostumesForArrows	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 9/21/1998 11:50'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds _ costume bounds.		costume owningHandOrPasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'sw 8/18/1998 11:47'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph _ self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes size > 0 ifTrue:  "This catches the nil and empty cases both"		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 9/15/1998 13:12'!costumes	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/21/1998 17:19'!costumesDo: aBlock	"Evaluate aBlock against every real (not flex) costume known to the receiver)"	aBlock value: costume renderedMorph.	costumes ifNotNil:		[(costumes copyWithout: costume) do:			[:aCostume | aBlock value: aCostume]]! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:46'!forgetOtherCostumes	costumes _ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 16:37'!knownSketchCostumeWithSameFormAs: aSketchMorph	| itsForm rend |	itsForm _ aSketchMorph form.	(((rend _ costume renderedMorph) isKindOf: SketchMorph) and: [rend form == itsForm])		ifTrue:	[^ rend].	^ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume _ aMorph! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember _ aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes _ OrderedCollection new].	existing _ (costumeToRemember isKindOf: SketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes _ costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 9/21/1998 11:46'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owningHandOrPasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			aMorph setNameTo: costume knownName.			costume _ aMorph]! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume _ self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:51'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	| itsCostume |	itsCostume _ anotherPlayer costume renderedMorph.	(itsCostume isKindOf: SketchMorph)		ifTrue:			[self wearSketchCostumeResembling: itsCostume]		ifFalse:			[anotherPlayer costume player: nil.			self renderedCostume: itsCostume veryDeepCopy.			anotherPlayer costume player: anotherPlayer].	costume layoutChanged! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:39'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume _ aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 9/11/1998 16:02'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm cur degs chgd |	itsForm _ aSketchMorph form.	((cur _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cur form == itsForm ifTrue: [^ self]].	costumes size > 0 ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	chgd _ false.	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume originalForm: itsForm;		rotationCenter: aSketchMorph rotationCenter;		framesToDwell: aSketchMorph framesToDwell.		chgd _ true].	((cur isKindOf: SketchMorph) and: [cur rotationStyle ~~ #normal])			ifTrue:				[newCostume rotationStyle: cur rotationStyle.				newCostume rotationDegrees: cur rotationDegrees.				degs _ cur valueOfProperty: #setupAngle ifAbsent: [nil].				degs ifNotNil: [newCostume setupAngle: degs].				chgd _ true].	chgd ifTrue: [newCostume layoutChanged].	self renderedCostume: newCostume! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:12'!assureExternalName	| aCostume |	(aCostume _ self costume) knownName ifNil:		[aCostume setNameTo: aCostume externalName]! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:20'!renameTo: aName	self costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:22'!choosePenColor: evt	evt hand changeColorTarget:  self costume  selector: #penColor:! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!clearTurtleTrails	self costume clearTurtleTrails! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:12'!colorUnder	^ self costume colorUnder! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!liftAllPens	self costume liftAllPens! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!lowerAllPens	self costume lowerAllPens! !!Player methodsFor: 'slots-kernel' stamp: 'sw 9/10/1998 14:48'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/1998 16:46'!standardWorldSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver, special-cased for the situation where the receiver's costume is the World""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	aBank = 1 ifTrue: [^ #(		(x 			number		readOnly	getX					unused)		(y			number		readOnly	getY				unused))].	aBank = 4 ifTrue: [^ #(		(colorSees	boolean		readOnly	dummy				unused)		(width 		number		readOnly	getWidth			unused)		(height 		number		readOnly	getHeight			unused)		(left 		number		readOnly	getLeft				unused)		(right 		number		readOnly	getRight			unused)		(top 		number		readOnly	getTop				unused)		(bottom 		number		readOnly	getBottom			unused)		)].	^ #()! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAmount	self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAngle	^ self getValueFromCostume: #angle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderColor	^ self getValueFromCostume: #borderColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderWidth	^ self getValueFromCostume: #borderWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColor	^ self costume renderedMorph color! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColorUnder	^ self costume colorUnder! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getCursor	^ self getValueFromCostume: #cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:51'!getHeadingUnrounded	^ self costume forwardDirection asSmallAngleDegrees! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getLeftRight	^ self getValueFromCostume: #leftRight! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!getMouseX	^ self costume mouseX! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getMouseY	^ self costume mouseY! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!getRotationStyle	^ self getValueFromCostume: #rotationStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getScaleFactor	| aCostume |	^ (aCostume _ self costume) isFlexMorph		ifTrue: [aCostume scale]		ifFalse: [1.0]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:42'!getUpDown	^ self getValueFromCostume: #upDown! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:50'!getY	^ self costume y! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderColor: aColor	self setCostumeSlot: #borderColor: toValue: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderWidth: aWidth	self setCostumeSlot: #borderWidth: toValue: aWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:24'!setColor: aColor	self costume renderedMorph color: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:16'!setCostume: someOtherMorph	^ self costume wearCostume: someOtherMorph! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:47'!setCursor: aNumber	self setCostumeSlot: #cursor: toValue: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'di 9/9/1998 20:13'!setHeading: newHeading	| aCostume |	aCostume _ self costume.	newHeading = 0.0		ifTrue: 			[self getScaleFactor = 1.0 ifTrue:				[aCostume isFlexMorph ifTrue:					[aCostume rotationDegrees: newHeading.					aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	self costume rotationDegrees: newHeading.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setName: aName	^ self costume renameTo: aName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!setRotationStyle: aStyle	self setCostumeSlot: #rotationStyle toValue: aStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/18/1998 11:53'!setScaleFactor: aNumber	| aCostume |	aCostume _ self costume.	1.0 = aNumber		ifTrue:			[0.0 = self getHeading ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	aCostume scale: (aNumber asFloat max: 0.125)! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume _ self costume.	((renderedMorph _ aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setX: val	^ self costume x: val! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:22'!setY: val	^ self costume y: val! !!Player methodsFor: 'slots-user' stamp: 'sw 9/15/1998 14:01'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: typeChosen.	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 8/11/1998 12:47'!compileInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self class compileUnlogged: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self class compileUnlogged: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil.! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:06'!initialValueForSlotOfType: aType	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color random].	aType == #string ifTrue: [^ 'abc'].	aType == #sound ifTrue: [^ 'croak'].	aType == #point ifTrue: [^ 20 @ 30].	^ nil! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:20'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true.	aWatcher growable: true;		getSelector: (getSel _ Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName).	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	self costume primaryHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:23'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true;		getSelector: (Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	self costume primaryHand attachMorph: aWatcher! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:03'!valueOfType: aType from: oldValue	"The user has changed a slot's type to aType; convert its former value, oldValue, to something of the appropriate type.  For now, does not take oldValue into account"	^ self initialValueForSlotOfType: aType! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/11/1998 12:45'!acceptScript: aScriptEditorMorph for: aSelector	| classif |	classif _ aScriptEditorMorph isAnonymous ifTrue: ['anonymous scripts'] ifFalse: ['named scripts'].	self class		compileUnlogged: aScriptEditorMorph methodString		classified: classif		notifying: nil.	self class atSelector: aSelector putScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/18/1998 11:56'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym reply aType |	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MVCMenuMorph new.	aType == #number "later others" ifTrue:		[aMenu add: 'simple watcher' action: #simpleWatcher.		aMenu add: 'fancier watcher' action: #fancyWatcher].	(self slotInfo includesKey: (slotSym _ aSlotName asSymbol))		ifTrue:  "User slot"			[aMenu add: 'change data type' action: #chooseSlotType.			aMenu add: 'remove "', aSlotName, '"' action: #removeSlot.			aMenu add: 'rename  "', aSlotName, '"' action: #renameSlot].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	reply _  aMenu invokeAt: self costume primaryHand position in: self costume world.	reply == nil ifTrue: [^ self].	reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: slotSym].	reply == #removeSlot ifTrue: [^ self removeSlotNamed:  slotSym].	reply == #renameSlot ifTrue: [^ self renameSlot: slotSym].	reply == #simpleWatcher ifTrue: [^ self tearOffWatcherFor: slotSym].	reply == #fancyWatcher ifTrue: [^ self tearOffFancyWatcherFor: slotSym]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/20/1998 17:40'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self costume actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:13'!okayToDestroyScriptNamed: scriptName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:21'!okayToRemoveSlotNamed: aSlotName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunning	self costume arrangeToStartStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunningScripts	self startRunning.	self costume arrangeToStartStepping.  "emergency patch, if not going already"	self costume presenter startRunningScripts! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!beep: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:22'!bounce: soundName	| box bounced aCostume |	(aCostume _ self costume) ifNil: [^ self].	(aCostume owner == nil or: [aCostume owner isHandMorph]) ifTrue: [^ self].	box _ aCostume owner bounds.	bounced _ false.	(aCostume left < box left)			ifTrue: [self headRight. bounced _ true].	(aCostume right > box right)		ifTrue: [self headLeft. bounced _ true].	(aCostume top < box top)			ifTrue: [self headDown. bounced _ true].	(aCostume bottom > box bottom)	ifTrue: [self headUp. bounced _ true].	bounced ifTrue: [^ self makeBounceSound: soundName].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!changeScript: scriptName toStatus: statusSymbol	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: statusSymbol.					^ self costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'scripts-standard' stamp: 'di 9/3/1998 00:43'!forward: dist 	| rho radians delta didStray p fractionalP newP aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	rho _ (aCostume asNumber: dist) asFloat.	radians _ (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta _ (radians cos @ radians sin) * rho.	((aCostume owner isHandMorph not) and:	 [aCostume presenter fenceEnabled]) ifTrue:		[(aCostume owner bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my owner, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray _ false.			((aCostume left < aCostume owner left and: [delta x < 0]) or:			 [aCostume right > aCostume owner right and: [delta x > 0]]) ifTrue: [				delta _ delta x negated @ delta y.				didStray _ true].			((aCostume top < aCostume owner top and: [delta y < 0]) or:			 [aCostume bottom > aCostume owner bottom and: [delta y > 0]]) ifTrue: [				delta _ delta x @ delta y negated.				didStray _ true].			didStray ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p _ aCostume referencePosition.	fractionalP _ aCostume actorState fractionalPosition.	(fractionalP == nil or: [fractionalP asIntegerPoint ~= p])		ifTrue: [newP _ p asFloatPoint + delta]		ifFalse: [newP _ fractionalP + delta]."Transcript cr; print: p; space; print: fractionalP;cr; cr; print: newP asIntegerPoint; space; print: newP; show: ''."	aCostume actorState fractionalPosition: newP.	aCostume referencePosition: newP asIntegerPoint.! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!goToRightOf: aPlayer	| hisCostume aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(hisCostume _ aPlayer costume) isInWorld ifFalse: [^ self].	((aCostume _ self costume) owner == hisCostume owner) ifFalse:		[hisCostume owner addMorphFront: aCostume].	aCostume position:		(hisCostume bounds rightCenter - (0 @ (aCostume height // 2)))! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!hide	self costume hide! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!initiatePainting	(self costume isKindOf: PasteUpMorph) ifTrue:		[self costume makeNewDrawingWithin]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!moveToward: aPlayer	| angle aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	((aCostume _ self costume) bounds intersects: aPlayer costume bounds) ifTrue: [^ self].	angle _ aCostume referencePosition bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!pauseScript: scriptName	self changeScript: scriptName toStatus: #paused! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!show	self costume show! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/18/1998 11:52'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	self costume isWorldOrHandMorph ifTrue:		[^ #((command beep: sound)			(command stopScript: string)			(command pauseScript: string)			(command startScript: string)			(command initiatePainting))].	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)		"	(command stopProgramatically)  "			(command stopScript: string)			(command pauseScript: string)			(command startScript: string))].	(aBank == 3 and: [self costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command liftAllPens)			(command lowerAllPens)			(command clearTurtleTrails)			(command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard)			(command initiatePainting))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!startScript: scriptName	self changeScript: scriptName toStatus: #ticking! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!stopScript: scriptName	self changeScript: scriptName toStatus: #normal! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:13'!wrap	self costume wrap! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!actorState	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 13:19'!assureUniClass	"If I am not currently a member of a UniClass, become one now"! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:44'!checkCostume	| found |	costumes ifNotNil:		[found _ costumes detect: [:c | c isInWorld] ifNone: [nil].		(found ~~ nil and: [found ~~ costume renderedMorph]) ifTrue:			[self halt: 'wrong costume'.			costume _ found]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!color: myColor sees: externalColor	^ self costume color: myColor sees: externalColor! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 17:14'!getInfo	"Open up some kind of editing window on the receiver's class comment, perhaps -- to be hooked up, perhaps, both via the viewer thumbnail and from the player's costume's red-dot menu" 	self notYetImplemented	"self class comment editxxx"! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!grabPlayerIn: aWorld	aWorld primaryHand attachMorph: self costume		! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!lastEvent	"A convenience for user scripts written in Squeak to call"	^ self costume primaryHand lastEvent! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:12'!makeBounceSound: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName].! !!Player methodsFor: 'misc' stamp: 'sw 8/18/1998 11:54'!owningPlayer	"Answer the player who wears my costume's owner as its costume.  Speculative, not currently used"	| itsOwner |	self costume ifNotNil:		[(itsOwner _ self costume owner) ifNotNil:			[^ itsOwner player]].	^ nil! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!presenter	"Convenience for calling from user scripts"	^ self costume presenter! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:14'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' (', self asOop printString, ')').	self costume ifNil: [aStream nextPutAll: ' (with nil costume)'.  ^ self].	aStream nextPutAll: ' named ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!renderedCostumeRespondsTo: aSelector	^ self costume renderedMorph respondsTo: aSelector! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 08:42'!revealPlayerIn: aWorld	| aMorph |	(aMorph _ self costume) isInWorld ifTrue: [^ aMorph goHome].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue: [^ self]].	self inform: 'Sorry.  Unaccountably, this objectseems to be irretrievably lost'			! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 14:39'!revertToUnscriptedPlayerIfAppropriate	| anInstance |	((self class selectors size > 0) or: [self class instVarNames size > 0]) ifTrue: [^ self].	anInstance _ UnscriptedPlayer new.	anInstance initializeCostumesFrom: self.	self become: anInstance! !!Player methodsFor: 'misc' stamp: 'sw 9/10/1998 14:35'!seesColor: aColor	^ self costume touchesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:20'!standardHolder	| aCostume |	aCostume _ self costume.	^ aCostume ifNotNil: [aCostume presenter ifNotNil: [aCostume presenter standardHolder]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:25'!tearOffTileForSelf	self costume world primaryHand attachMorph: self tileReferringToSelf! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:46'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld |	aWorld _ aMorph world.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu addLine.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'object fileIn' stamp: 'ack 8/27/1998 13:33'!convertdc0: varDict dcc0: smartRefStrm	"These variables are automatically stored into the new instance ('costume' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('costumes' ) and deal with the information in ()"! !!Player class methodsFor: 'initialization' stamp: 'sw 6/16/1998 15:32'!copyStateFrom: anotherClass	| dupScript |	scripts _ IdentityDictionary new.	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]].	slotInfo _ anotherClass slotInfo deepCopy.	self copyAddedStateFrom: anotherClass.  "The player-ref jump table"! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 8/2/1998 22:52'!tileScriptNames	scripts ifNil: [^ OrderedCollection new].	"The following is an emergency workaround for damaged script dictionaries occurring in Alan's demo image 8/2/98; no selector should be nil but somehow some is, so here we filter such damaging things out"	^ scripts collect: [:aScript | aScript selector] thenSelect: [:n | n ~~ nil]! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:45'!privateSlotInfo	"for copying"	^ slotInfo! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:44'!slotInfo: aDict	"for copying"	slotInfo _ aDict! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii _ BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className _ (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii _ ii + 1].	BiggestSubclassNumber _ ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ name endsWithDigit not! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:35'!anonymousUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializeAnonymousScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:42'!privateScripts	"for copying"	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'sw 8/11/1998 12:52'!removeScriptNamed: aScriptName	aScriptName ifNotNil:		[scripts removeKey: aScriptName.		self removeSelectorUnlogged: aScriptName]! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:41'!scripts: aDict	"for copying"	scripts _ aDict! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:33'!userScriptForPlayer: aPlayer selector: aSelector	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ scripts at: aSelector ifAbsent: [nil].	entry ifNil:		[entry _ UserScript new player: aPlayer selector: aSelector.		scripts at: aSelector put: entry].	^ entry! !!Player class methodsFor: 'namespace' stamp: 'sw 8/11/1998 12:46'!compileReferenceAccessorFor: varName	self class compileUnlogged: ((self referenceAccessorSelectorFor: varName), '	^ ', varName)		classified: 'reference' notifying: nil! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 16:28'!abandonUnnecessaryUniclasses	"Player abandonUnnecessaryUniclasses"	| oldCount oldFree newFree newCount report |	oldCount _ self subclasses size - 1.	oldFree _ Smalltalk garbageCollect.	self allSubInstances do:		[:aPlayer | aPlayer revertToUnscriptedPlayerIfAppropriate].	aPlayer _ nil.  "encourage last one to get garbage-collected"	ScriptingSystem spaceReclaimed.	newFree _ Smalltalk garbageCollect.	newCount _ self subclasses size - 1.	report _ 'Before: ', oldCount printString, ' uniclasses, ', oldFree printString, ' bytes freeAfter:  ', newCount printString, ' uniclasses, ', newFree printString, ' bytes free'.	Transcript cr; show: 'abandonUnnecessaryUniclasses:'; cr; show: report.	^ report	! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:25'!cleansePlayersWithDamagedScripts	"Track down all Players with damaged scripts and repair their script dictionaries.  Report how many were fixed."	"Player cleansePlayersWithDamagedScripts"	| aList |	aList _ self class allSubInstances select:		[:c | c scripts ~~ nil and: [c scripts includesKey: nil]].	aList do:		[:c | c scripts removeKey: nil].	^ aList size printString, ' uniclasses fixed up'! !!Player class methodsFor: 'housekeeping' stamp: 'jm 5/20/1998 20:54'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are housekeepingwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have not references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c |		((c name asString beginsWith: 'Player') and:		 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0])			ifTrue: [Smalltalk removeKey: c name ifAbsent: []. false]			ifFalse: [true]].	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not]) ifTrue: [			newSubclasses add: c.			Smalltalk at: c name put: c]].	subclasses _ newSubclasses.	SystemOrganization removeMissingClasses.! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:06'!playersWithDamagedScripts	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithDamagedScripts"	^ self allSubInstances select:		[:p | p class scripts ~~ nil and: [p class scripts includesKey: nil]]! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 14:33'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self class allSubInstances select:		[:p | p isSystemDefined not and: [p scripts size == 0 and: [p instVarNames size == 0]]] ! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/11/1998 13:23'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval _ candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 8/11/1998 16:47'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredPlayer.	self changed! !!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/8/1998 16:18'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledNextIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 6/26/1998 11:07'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !!PluggableButtonMorph methodsFor: 'accessing'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol.! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonMorph class methodsFor: 'instance creation'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:14'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:28'!font	^ font! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	font _ aFontOrNil.	self list: self getList.  "update display"! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:30'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item font: font].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: (index = 0 ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:11'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	"Set up for one line, or a full pane less one line"	scrollBar scrollDelta: (scroller firstSubmorph height / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph height / range) asFloat ! !!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'jm 8/20/1998 09:44'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:12'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector _ getMenuTitleSel! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu _ model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu _ model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableListViewByItem methodsFor: 'all' stamp: 'jm 9/20/1998 17:13'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableTest methodsFor: 'music type pane' stamp: 'sw 8/18/1998 12:31'!musicTypeListTitle	^ 'Choose a command'! !!PluggableTest methodsFor: 'menu commands' stamp: 'sw 8/18/1998 12:29'!perform: sel orSendTo: otherObject	(self respondsTo: sel) ifTrue: [self perform: sel] ifFalse: [otherObject perform: sel]! !!PluggableTest class methodsFor: 'example' stamp: 'sw 8/18/1998 12:25'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	listView1  menuTitleSelector: #musicTypeListTitle.	listView2 _		PluggableListView on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open.! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:13'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'di 8/24/1998 09:57'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  "	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu yellowButtonActivity "<-note change")"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 9/11/1998 15:46'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:55'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	scrollBar scrollDelta: (scroller firstSubmorph defaultLineHeight / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph defaultLineHeight / range) asFloat ! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'wod 5/26/1998 17:03'!setSelection: sel	selectionInterval _ sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [scroller changed].! !!PluggableTextMorph methodsFor: 'model access' stamp: 'ls 7/20/1998 22:50'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ TextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 8/24/1998 09:57'!prettyPrint	self handleEdit: [textMorph editor prettyPrint]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 6/26/1998 11:09'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'updating' stamp: 'ls 7/23/1998 03:47'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #autoSelect ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self world ifNotNil: [ self world displayWorld]].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self world displayWorld].! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/22/1998 15:14'!handleEdit: editBlock	| result |	textMorph editor model: model.  "For evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 7/3/1998 00:53'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform invertRect: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'jm 8/20/1998 08:39'!mouseLeave: event	textMorph ifNotNil: [selectionInterval _ textMorph editor selectionInterval].	super mouseLeave: event.	event hand newKeyboardFocus: nil.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 6/21/1998 21:10'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft + 1) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:36'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/21/1998 21:10'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'editing' stamp: 'jm 6/3/1998 14:29'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1).! !!PolygonMorph methodsFor: 'menu' stamp: 'di 6/21/1998 12:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	quickFill		ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]		ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 21:15'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent+2. "for anyShapeFill"	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill].	^ filledForm! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 6/3/1998 16:43'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	nLines _ (frame height - 4) // marker height.	allLabels := labelString findTokens: Character cr asString.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines) startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PositionableStream methodsFor: 'positioning' stamp: 'di 5/25/1998 15:16'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| aString length |	"read the length in binary mode"	self binary.	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ length - 192.		1 to: 3 do: [:ii | length _ length * 256 + self next]].	aString _ String new: length.	"read the characters in ASCII mode"	self ascii.	self nextInto: aString.	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ (length - 192) * 256 + self next].	aString _ String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 5/29/1998 09:41'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s.	^s! !!Preferences class methodsFor: 'initialization' stamp: 'di 9/22/1998 15:56'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	self disable: #browseWithPrettyPrint.	self enable: #cautionBeforeClosing.	self enable: #cmdDotEnabled.	self enable: #confirmFirstUseOfStyle.	self disable: #disableSounds.	self disable: #editPlayerScriptsInPlace.	self disable: #fastDragWindowForMorphic.	self enable: #ignoreStyleIfOnlyBold.	self enable: #logDebuggerStackToFile.	self disable: #noviceMode.	self enable: #reverseWindowStagger.	self enable: #showDebugHaloHandle.	self disable: #showTimeStampsInMenuTitles.	self disable: #suppressCheckForSlips.	self enable: #thoroughSenders.	self disable: #uniformWindowColors.	self enable: #warnIfNoChangesFile.	self enable: #warnIfNoSourcesFile.! !!Preferences class methodsFor: 'initialization' stamp: 'sw 9/19/1998 22:47'!initialize	"Preferences initialize"	"Sometimes placed in a change-set even though unchanged, to trigger reinitialization upon update."	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/10/1998 16:09'!defaultAuthorName	"Answer the author name to be planted, by default, in a changeset-preamble template.  You can hard-code this to hold your name, thus saving you time when writing the preambles of subsequent changesets"	^ 'Your Name'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!disable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: false! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!enable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: true! !Optionally associated with a PasteUpMorph, provides presentation services.Holds control buttons:	stopButton stepButton goButton.Holds state flags:	mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabledHolds a viewerCache Holds, optionally three 'standard items' originally providing idiomatic support of ongoing squeak-team internal work, but now extended to more general applicability:   standardPlayer standardPlayfield standardPalette !!Presenter methodsFor: 'button creation' stamp: 'sw 9/14/1998 12:38'!addTrashCan	| aPosition aCan |	(aCan _ associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan _ TrashCanMorph newSticky.	aPosition _ associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setProperty: #scriptingControl toValue: true.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/24/1998 15:14'!goButton	| aDict |	goButton == nil  ifTrue:		[aDict _ ScriptingSystem formDictionary.		goButton _ ThreePhaseButtonMorph new.		goButton image:  (aDict at: 'GoPicOn');			offImage: (aDict at: 'GoPic');			pressedImage: (aDict at: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			setBalloonText:'Resume runningall paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/25/1998 12:10'!stepButton	| aDict aPosition |	stepButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (aDict at: 'StepPicOn');			offImage: (aDict at: 'StepPic'); pressedImage:  (aDict at: 'StepPicOn');				arguments: (Array with: nil with: stepButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every pausedscript exactly once.  Keepthe mouse button down over "Step"and everything will keep runninguntil you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/30/1998 15:54'!stopButton	| aDict aPosition anExtent |	stopButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (aDict at: 'StopPic');			offImage: (aDict at: 'StopPic'); pressedImage:  (aDict at: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottomLeft;			setBalloonText:'Pause all ticking scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ (associatedMorph left + 128) @ (associatedMorph bottom - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/3/1998 12:25'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		(TabbedPalette)		(BasicButton JoystickMorph ClockMorph RecordingControlsMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/3/1998 14:17'!controlPanel	|  aPanel |	(aPanel _ associatedMorph world allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel].	aPanel _ PasteUpMorph new extent:  128 @ 48.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/6/1998 14:07'!createControlPanel	associatedMorph primaryHand attachMorph: self controlPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/5/1998 00:16'!customPagesForPartsBin	| aPage |	^ #(BookMorph WebBookMorph) collect:		[:sym |			aPage _ self newPageForStandardPartsBin.			aPage addMorphBack: (Smalltalk at: sym) authoringPrototype.			aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.			aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.			aPage fixLayout.			aPage]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/5/1998 00:13'!launchMyPartsBin	associatedMorph primaryHand attachMorph: ScriptingSystem partsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/30/1998 17:06'!newStandardPartsBin	| aBook aPage aSize |	aSize _ 340 @ 160.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 2.	aBook removeEverything.	aBook openToDragNDrop: false.	aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: 'Parts Bin').	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette _ aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/15/1998 19:44'!standardPaletteIsAlready: aPalette	^ standardPalette == aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/3/1998 16:39'!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	aPage makeAllTilesGreen.	aPage fixLayout.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 9/20/1998 22:12'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formDictionary at: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 7/4/1998 14:29'!positionStandardPlayer	standardPlayer costume position: (associatedMorph bottomLeft - (0 @ standardPlayer costume height))! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:44'!borderColorWhenRunning	borderColorWhenRunning ifNil:		[borderColorWhenRunning _ ScriptingSystem runningPlayfieldBorderColor].	^ borderColorWhenRunning! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 15:27'!borderColorWhenStopped	borderColorWhenStopped ifNil:		[borderColorWhenStopped _ ScriptingSystem frozenPlayfieldBorderColor].	^ borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:58'!startRunningScripts	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:37'!stepStillDown: dummy with: theButton	self stepButtonState: true.	self stopButtonState: false.	associatedMorph stepAll.	associatedMorph world displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:45'!stopRunningScripts	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 8/5/1998 07:37'!balloonHelpEnabled	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	^ associatedMorph world balloonHelpEnabled! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 6/8/1998 11:06'!mouseOverHalosEnabled	^ mouseOverHalosEnabled == true! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 8/5/1998 07:37'!toggleShowBalloons	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	self world toggleShowBalloons! !!Presenter methodsFor: 'tile support' stamp: 'sw 6/25/1998 13:29'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (TilePadMorph colorForType: #color)).	tiles add: (TileMorph new typeColor: (TilePadMorph colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!Presenter methodsFor: 'misc' stamp: 'sw 7/8/1998 13:04'!drawingJustCompleted: aSketchMorph	| pal aPaintBox |	(aPaintBox _ associatedMorph world paintBox) ifNotNil:		[aPaintBox delete].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[(pal _ aSketchMorph standardPalette) ifNotNil:				[pal viewMorph: aSketchMorph]]! !!Presenter methodsFor: 'misc' stamp: 'sw 8/5/1998 07:38'!initializeToggles	mouseOverHalosEnabled _ true.	soundsEnabled _ true.	fenceEnabled _ true.	coloredTilesEnabled _ false! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:58'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield _ aPlayfield! !!Presenter methodsFor: 'misc' stamp: 'sw 8/5/1998 07:35'!toggleButtons	| aButton aDict aList |	aDict _ ScriptingSystem formDictionary.	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help:If green, then when thecursor pauses over an objectthat has balloon help,that help balloon is shown''Sounds:If green, sounds will be heard when appropriate; ifred, sounds are suppressed.''Fence:If green, an invisible "fence"keeps your objects from strayingoutside their containers whentheir scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (aDict at: q second);				offImage: (aDict at: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown;				target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (aDict at: q second) extent.			aButton].	^ aList! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/11/1998 16:58'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (associatedMorph allMorphsIncludingBookPages select: [:m | m player ~~ nil] thenCollect: [:m | m player]) asArray! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList _ nil! !!Presenter methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:51'!convertassgbmsfcvsssspbb0: varDict assgmsfcvsssspbb0: smartRefStrm	"These variables are automatically stored into the new instance ('associatedMorph' 'stopButton' 'stepButton' 'goButton' 'mouseOverHalosEnabled' 'soundsEnabled' 'fenceEnabled' 'coloredTilesEnabled' 'viewerCache' 'standardPlayer' 'standardPlayfield' 'standardPalette' 'standardHolder' 'playerList' 'borderColorWhenRunning' 'borderColorWhenStopped' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('balloonHelpEnabled' )"! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!program	^ program! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange	program _ midiProgramChange.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange channel: midiChannel	program _ midiProgramChange.	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46'!isProgramChange	^ true! !!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rC0		channel: channel		byte: program.! !!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': prog '.	program printOn: aStream.	aStream nextPut: $).! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 15:42'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				vanishingPoint _ Sensor cursorPoint.				(entering ifTrue: [self] ifFalse: [previousProject]) dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [vanishingPoint _ v windowBox center]].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 14:14'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'di 6/23/1998 09:36'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	world isMorph		ifTrue: [world _ World.				self dependents do:					[:d | (d isKindOf: SystemWindow)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]].				world sleep "Release all space possible in old world"]		ifFalse: [world _ ScheduledControllers.				ScheduledControllers unCacheWindows.				self dependents do:					[:d | (d isKindOf: StandardSystemView)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]].	transcript _ Transcript.	displayDepth _ Display depth.	activeProcess _ nil! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project methodsFor: 'release' stamp: 'di 6/22/1998 09:40'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	ProjectViewMorph allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'sw 9/15/1998 16:42'!maybeForkInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[self interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'class initialization' stamp: 'di 6/20/1998 10:31'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	NavList _ OrderedCollection with: CurrentProject.	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!Project class methodsFor: 'instance creation' stamp: 'sw 7/6/1998 11:23'!newMorphicConstruction	"ProjectView open: Project newMorphicConstruction"	| aProject |	aProject _ self newMorphic.	aProject world configureForConstruction.	^ aProject! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:29'!addItem: item toMenu: menu selection: action	(menu isKindOf: MenuMorph)		ifTrue: [menu add: item selector: #jumpToSelection: argument: action]		ifFalse: [menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:28'!buildJumpToMenu: menu	"Present a list of potential projects."	"Time millisecondsToRun: [Project jumpToMenu]"	| prev |	"First a FIFO list"	(prev _ CurrentProject previousProject) ifNotNil:		[1 to: 5 do:			[:i | 			prev ifNotNil: 				[self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: '%back' , i printString.				prev _ prev previousProject]].		menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: [		self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent.		menu addLine].	"Finally all the projects"	Project allNames do: [:n | self addItem: n toMenu: menu selection: n].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:24'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUp! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:03'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."	"Project jumpToProject"	| nBack prev |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true]].	selection = #parent ifTrue: [CurrentProject parent enter: false. ^ self].	(Project named: selection) enter: false! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self maybeRelabel: model labelString].	^ super update: aSymbol! !!ProjectView methodsFor: 'displaying' stamp: 'di 5/27/1998 16:58'!displayView	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 19:44'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/15/1998 16:21'!enter	"Enter my project."	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	project enter: false.! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 12:36'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and:	 [image depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP "scaleP x asFloat max: scaleP y asFloat".				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self image: (Form extent: newExtent depth: Display depth).		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 11:46'!mouseDown: evt	"Quick hack: use old-fashioned menu."	| menu selection |	menu _ CustomMenu new		add: 'enter' action: #enter;		add: 'jump to project...' action: #jumpToProject.	selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: nil.	selection = #enter ifTrue: [^ self enter].	selection = #jumpToProject ifTrue: [Project jumpToProject. ^ self].! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'sw 7/6/1998 11:27'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !I am a parser for news files in the format output by the Unix 'rn' program.!!RNInboxFile methodsFor: 'scanning'!nextStringOf: aStream equals: aString	aString do:		[: c | (c == (aStream next) ) ifFalse: [^false]].	^true! !!RNInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by delimiters that includes the newsgroup name. Ignore text before the first article delimiter."	| done line groupName |	currentNewsgroup _ nil.  "have not found start of article"	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 groupName _ self startOfArticle: line.		 (groupName notNil) ifTrue:			[self endOfArticleDo: aBlock.			 currentNewsgroup _ groupName.			 line _ MailDB readStringLineFrom: aStream].		 (currentNewsgroup notNil) ifTrue: [self appendLine: line]].! !!RNInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer the newsgroup name if the given string is the start of a news article, for example:		Article 2958 of comp.lang.smalltalk:	Otherwise, answer nil."	| s name |	s _ ReadStream on: aString.	(self nextStringOf: s equals: 'Article ') ifFalse: [^nil].	[s next isDigit] whileTrue.	"consumes digits plus the following space"	(self nextStringOf: s equals: 'of ') ifFalse: [^nil].	name _ s through: $:.	((name size > 1) & (s atEnd)) ifFalse: [^nil].	^name copyFrom: 1 to: (name size - 1)! !!RadioButtonInput methodsFor: 'access' stamp: 'ls 8/11/1998 19:52'!valueIfPressed	^value! !!RadioButtonInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:46'!inputSet: anInputSet  value: aString	inputSet _ anInputSet.	value _ aString.	state _ false.! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed	^state! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed: aBoolean	state _ aBoolean.	self changed: #pressed.	^true! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 20:28'!toggle	"my button has been clicked on!!"	self pressed: self pressed not.	inputSet  buttonToggled: self.	^true! !!RadioButtonInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:47'!inputSet: anInputSet  value: aString	^self new inputSet: anInputSet  value: aString! !!RadioButtonSetInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:25'!name: aString	name _ aString.	buttons _ OrderedCollection new.! !!RadioButtonSetInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^true! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:48'!addInput: buttonInput	buttons add: buttonInput! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:30'!defaultButton: aButton	"set which button to toggle on after a reset"	defaultButton _ aButton! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:24'!name	^name! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!active	"we are active if and only if one of our buttons is pressed"	buttons do: [ :b |		b pressed ifTrue: [ ^true ] ].	^false! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:27'!buttonToggled: aButton	"a button was toggled; turn all other buttons off"	buttons do: [ :b |		b == aButton ifFalse: [			b pressed: false  ] ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:30'!reset	buttons do: [ :b |		b pressed: (b == defaultButton) ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!value	buttons do: [ :b |		b pressed ifTrue: [ ^b valueIfPressed ] ].	self error: 'asked for value when inactive!!'.! !!RadioButtonSetInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:29'!name: aString	^self new name: aString! !!RandomEnvelope methodsFor: 'initialization' stamp: 'jm 8/13/1998 21:25'!initialize	rand _ Random new.	lowLimit _ 0.996.	highLimit _ 1.004.	delta _ 0.0001.	currValue _ 1.0.	scale _ 1.0.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18'!centerPitch: aNumber	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."	updateSelector = #pitch: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta	^ delta! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta: aNumber	delta _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit	^ highLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit: aNumber	highLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!lowLimit	^ lowLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!lowLimit: aNumber	lowLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17'!volume: aNumber	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."	updateSelector = #volume: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'applying' stamp: 'jm 8/13/1998 18:25'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| r |	r _ rand next.	r > 0.5		ifTrue: [			currValue _ currValue + delta.			currValue > highLimit ifTrue: [currValue _ highLimit]]		ifFalse: [			currValue _ currValue - delta.			currValue < lowLimit ifTrue: [currValue _ lowLimit]].	currValue = lastValue ifTrue: [^ false].	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].	target		perform: updateSelector		with: scale * currValue.	lastValue _ currValue.	^ true! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29'!duration	^ 1.0! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!duration: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!name	^ 'random ', updateSelector! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30'!sustainEnd: seconds	"Do nothing."! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!for: aSelector	"Answer a random envelope for the given selector."	^ self new updateSelector: aSelector! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 17:09'!new	^ super new initialize! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:17'!initialize	| m1 m2 |	super initialize.	self typeColor: (TilePadMorph colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:44'!numericValue	^ super numericValue atRandom! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:45'!storeCodeOn: aStream indent: tabCount	aStream			nextPut: $(;			nextPutAll: literal printString;			nextPutAll: ' atRandom)'.! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:14'!updateLiteralLabel	|  desiredW leader myLabel myReadout |	(myLabel _ self labelMorph) ifNil: [^ self].	myReadout _ submorphs reversed detect: [:m | m isKindOf: StringMorph].	myReadout contents: literal stringForReadout.	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width + myReadout width + 5.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myReadout position: (self left + (leader + 0)) @ (bounds top + 2); fullBounds.	myLabel position: myReadout topRight + (5@0).	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !I am a parser for news files in the format output by the Unix 'readnews' program.!!ReadNewsInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for news inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!ReadNewsInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for news inboxes."	self error: 'News inboxes are read only!!'! !!ReadNewsInboxFile methodsFor: 'scanning'!allDashes: aString	"Answer true if the given string is not empty and consists entirely of dash characters."	(aString isEmpty) ifTrue: [^false].	aString detect: [: ch | ch ~= $-] ifNone: [^true].	^false	"we must have detected a non-dash"! !!ReadNewsInboxFile methodsFor: 'scanning'!appendLine: aString	"Append the given line to the buffer."	msgBuffer nextPutAll: aString; cr.! !!ReadNewsInboxFile methodsFor: 'scanning'!endOfArticleDo: aBlock	"We've just hit the end of an article. Evaluate the given block on the article we've been accumulating in the buffer (if any) and reset the buffer for the next article."	| msgText end |	"get text and remove trailing separators (blanks, cr's, etc)"	msgText _ msgBuffer contents.	end _ msgText size.	[(end > 0) and: [(msgText at: end) isSeparator]] whileTrue: [end _ end - 1].	(end > 1) ifTrue:		[aBlock value: currentNewsgroup value: (msgText copyFrom: 1 to: end)].	msgBuffer reset.	"reset the buffer for the next message"! !!ReadNewsInboxFile methodsFor: 'scanning'!newsMessagesDo: aBlock	"Invoke the given block for each message in the news inbox file. The block arguments are the newsgroup name and the text of a new message."	| fileStream stream |	fileStream _ FileStream fileNamed: filename.	(fileStream size < 50000)		ifTrue:			["for small inboxes, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile)]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	self parse: stream do: aBlock.	fileStream close.! !!ReadNewsInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by two kinds of delimiters. The first kind indicates the start of a new newsgroup and includes the newsgroup name. The second kind indicates the start of a new article within a newsgroup."	| done line nextLine |	currentNewsgroup _ 'unknown newsgroup'.	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 (self allDashes: line) ifTrue:	"leading line of dashes"			["could be a newsgroup header"			 nextLine _ MailDB readStringLineFrom: aStream.			 ((nextLine size >= 10) and:			  [(nextLine copyFrom: 1 to: 10) = 'Newsgroup '])				ifTrue:					["yep, it is a newsgroup header"					 self endOfArticleDo: aBlock.					 self setNewsGroup: nextLine.					 MailDB skipRestOfLine: aStream.	"skip trailing line of dashes"					 MailDB skipRestOfLine: aStream.	"skip blank line"					 MailDB skipRestOfLine: aStream.	"skip next article delimiter"					 line _ MailDB readStringLineFrom: aStream]				ifFalse:					["nope, it's not a newsgroup header"					 self appendLine: line.					 line _ nextLine]].		 (self startOfArticle: line) ifTrue:			[self endOfArticleDo: aBlock.			 line _ MailDB readStringLineFrom: aStream].		 self appendLine: line].	"normal line: append it to the message buffer"! !!ReadNewsInboxFile methodsFor: 'scanning'!setNewsGroup: aLine	"Set the current newsgroup name from the given line of text, which is of the form:		Newsgroup comp.lang.smalltalk"	(aLine size > 11)		ifTrue: [currentNewsgroup _ aLine copyFrom: 11 to: aLine size]		ifFalse: [currentNewsgroup _ 'unknown newsgroup'].! !!ReadNewsInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer true if the given string is the start of a new news article. That is, does it start with the string 'Article ' and end with a period?"	^((aString size >= 8) and:	   [((aString copyFrom: 1 to: 8) = 'Article ') & (aString last = $.)])! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:47'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [Smalltalk changes preambleString == nil])		ifTrue: [Smalltalk changes preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [Smalltalk changes postscriptString == nil])		ifTrue: [Smalltalk changes postscriptString: chunk].							! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| val chunk |	'Reading ' , self name		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:59'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen.  5/22/96 sw"	| allOrigins screenRight screenBottom initialExtent putativeOrigin putativeFrame allowedArea staggerOrigin |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView].	allowedArea _ Display usableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	initialExtent _ aView initialExtent.	allOrigins _ ScheduledControllers windowOriginsInUse.	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:43'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!screenTopSetback	Smalltalk isMorphic		ifTrue: [^ 0]		ifFalse: [^ 18]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!scrollBarSetback	Smalltalk isMorphic		ifTrue: [^ 16-3]  "width = 16; inset from border by 3"		ifFalse: [^ 24]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:00'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:01'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self scrollBarSetback @ self screenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:01'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self scrollBarSetback @ self screenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:43'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 8/17/1998 20:35'!show	"Show my samples in a WaveEditor."	| ed w |	recorder pause.	ed _ WaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w _ self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 7/4/1998 14:49'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 7/12/1998 13:30'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	ref isInteger ifFalse: [short _ false].	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:38'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references _ IdentityDictionary new: 4096 * 5."	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new."	blockers ifNil: [blockers _ IdentityDictionary new]. ! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:58'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream class methodsFor: 'all' stamp: 'tk 5/26/1998 14:51'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	" 4 = If UniClasses (subclasses of Player) have class instance variables, append their values in the form (#Class43 (val1 val2 vla3)).  An array of those.  Can still read version 3."	^ 4! !!RemoteHandMorph methodsFor: 'other' stamp: 'di 7/5/1998 21:07'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt anyButtonPressed and:		 [evt controlKeyPressed and:		 [lastEvent anyButtonPressed not]]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent]! !Used for creating the right HTML links for Rendered Files!!RenderedSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID! !This class only exists to provide a different pageURL for the rendered pagesHere's how to set them up:For FTP rendering:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server:'cleon.cc.gatech.edu';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.For local rendering:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RendererSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID,'.html'! !An authorized Swiki that can generate cached pages with no link back to theSwikiExamples of setting them up:Here's one that renders to an external, FTP-accessible website:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server: 'flintstone.com';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction new restore: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.Here's one that renders to a local directory accessible from a webserver:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RenderingSwikiAction methodsFor: 'accessing' stamp: 'mjg 8/31/1998 14:40'!serverDirectory: anObject	serverDirectory _ anObject. "Should be an instance ofServerDirectory, or a path string."! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg8/31/1998 12:57'!browse: pageRef from: request	"Just reply with a page in HTML format -- use the rendering pagetemplate rpage.html"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'rpage') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''rpage.html'' not found'].	request reply: htmlForUser.! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/23/1998 09:14'!generate: pageRef	"Generate the page to the serverDirectory. Use the render.html page as a template"	| formattedPage renderedFile newmap file|	"Make a copy, then format the text."	formattedPage _ pageRef copy.	newmap _ urlmap copy.		" Create a new action with different action for cached form."	newmap action: (RendererSwikiAction new).	newmap action name: '.'.	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | newmap					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	(serverDirectory isKindOf: String)	ifTrue: [ "Just save the file into the directory"		renderedFile _ (serverDirectory),(pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.]	ifFalse: [ "Assume it's FTP and send it off"		renderedFile _ (pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.		serverDirectory putFile: (FileStream fileNamed: renderedFile) named: renderedFile.		"FileDirectory deleteFilePath: renderedFile"]! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'BJP9/9/1998 21:35'!pageURL: aPage	"make the URL suited to aPage"	^(self name),'.',aPage coreID! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/9/1998 14:24'!process: request	"Handle requests of the form {swikiname}.{coreRef}.render"	(request message size > 2) ifTrue: [		((request message at: 3) = 'render') ifTrue:		[ self generate: (urlmap atID: (request message at: 2)).		request reply: (PWS success) ; reply: (PWS contentHTML).		^self browse: (urlmap atID: (request message at: 2)) from:request].		((request message at: 3) = 'html') ifTrue: "Handle 1.html refs"		[^self browse: (urlmap atID: (request message at: 2)) from:request]].	super process: request.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28'!reset	super reset.	sound reset.	samplesPerIteration _ sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:29'!samplesRemaining	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:16'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs addFirst: 1.		values addFirst: value]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs addLast: 1.		values addLast: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs add: times.		values add: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs addLast: times.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs addLast: 1.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ls 8/20/1998 10:56'!copyFrom: start to: stop	| newRuns | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new	^self runs: OrderedCollection new values: OrderedCollection new! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (OrderedCollection with: size) values: (OrderedCollection with: value)! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 10:15'!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	addr _ NetNameResolver addressForName: serverName.	addr == nil ifTrue: [		self error: 'could not resolve host name' ].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:38'!data: messageData	"send the data of a message"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkSMTPResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:13'!getSMTPResponse	"wait for an SMTP response, and return the number of the response"	| line |	[ line _ self getResponse.	Transcript show: line.	(line at: 4) = $- ] whileTrue.	^(line copyFrom: 1 to: 3) asNumber! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:21'!mailFrom: fromAddress	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:31'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	self sendCommand: 'QUIT'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:20'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 22:37'!checkSMTPResponse	"get an SMTP response, and check that it's in the 200's or 300's.  If it's not, close the socket and issue an error:"	(#(2 3) includes: self getSMTPResponse // 100) ifFalse: [		self close.		self error: 'server responded with an error' ].! !!SMTPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 22:32'!deliverMailTo: server from: fromAddress to: recipientList text: messageText	^self notYetImplemented! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:40'!example	"SMTPSocket example"	"send a message over SMTP"	self deliverMailFrom: 'lex@cc.gatech.edu' to: #(root src) text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'localhost'.! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:36'!example2	"SMTPSocket example2"	"send a message using the low-level protocol methods.  Normally one would just use the high-level class message"	| sock |	sock _ self new.	sock connectToSMTPServer: 'localhost'.	sock mailFrom: 'lex@cc.gatech.edu'.	sock recipient: 'lex@localhost'.	sock recipient: 'root'.	sock data:'From: testTo: "not listed"Subject: this is a testHi, this is a test message.'.	sock quit.	sock close.! !!SMTPSocket class methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:49'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"deliver mail to a list of users.  NOTE: the recipient list should be a collection of bare addresses--no '<>' or '()' stuff"	| sock |	Socket initializeNetwork.	sock _ self new.	(sock connectToSMTPServer: serverName)		ifFalse: [ ^false ].	sock mailFrom: fromAddress.	recipientList do: [ :recipient |		sock recipient: recipient ].	sock data: messageText.	sock quit.	sock closeAndDestroy.	^true! !See SameGame>>helpString for an explanation of how to play!!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 19:36'!initialize	| |	super initialize.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self addMorph: self makeControls.	self addMorph: self board.	helpText _ nil.	self newGame.! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		inset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; centering: #center; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:40'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		inset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'access' stamp: 'tao 5/23/1998 10:32'!helpString^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'actions' stamp: 'tao 5/23/1998 10:51'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count _ self board selectionCount.	count = 0 ifTrue:		[score _ scoreDisplay value + (selectionDisplay value - 2) squared.		board findSelection ifNil:			[count _ board tilesRemaining.			count = 0				ifTrue: [score _ score + (5 * board rows * board columns)]				ifFalse: [score _ score - count].			scoreDisplay flash: true].		scoreDisplay value: score].	selectionDisplay value: count.! !I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:25'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	hResizing _ #rigid.	vResizing _ #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self fixLayout.	self resetBoard.! !!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:39'!resetBoard	selection _ nil.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom]! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'geometry' stamp: 'tao 5/18/1998 20:41'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	(bounds extent // protoTile extent) = (aPoint // protoTile extent)		ifFalse:			[self changed.			bounds _ bounds topLeft extent: (aPoint truncateTo: protoTile extent).			self layoutChanged.			self changed]! !!SameGameBoard methodsFor: 'dropping/grabbing' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 17:57'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MorphicEvent new]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 16:53'!removeSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) disabled: true; setSwitchState: false].		self collapseColumns: (selection collect: [:loc | loc x]) asSet asSortedCollection.		selection _ nil.		flash _ false.		(target ~~ nil and: [actionSelector ~~ nil])			ifTrue: [target perform: actionSelector withArguments: arguments]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 20:20'!tileClickedAt: location newSelection: isNewSelection	| tile |	isNewSelection		ifTrue:			[self deselectSelection.			tile _ self tileAt: location.			selectionColor _ tile color.			selection _ OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1				ifTrue: [self deselectSelection]				ifFalse:					[(target ~~ nil and: [actionSelector ~~ nil])					ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse:			[self removeSelection].! !!SameGameBoard methodsFor: 'private' stamp: 'tao 5/18/1998 20:42'!fixLayout	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !I am a single tile for the SameGame.  I act much like a switch.!!SameGameTile methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:59'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/18/1998 20:51'!color: aColor	color _ aColor.	onColor _ aColor.	offColor _ aColor.	self changed.! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!SameGameTile methodsFor: 'drawing' stamp: 'tao 5/15/1998 12:31'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color darker			bottomRightColor: color lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/17/1998 09:53'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		target			perform: actionSelector			withArguments: (arguments copyWith: switchState)].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!allSampleSets: sortedNotes	| keyMap |	keyMap _ self midiKeyMapFor: sortedNotes.	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04'!initialize	sustainedThreshold _ 0.15.	loudThreshold _ 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!loudThreshold: aNumber	loudThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.	staccatoSoft _ staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoLoudSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoSoftSampleSet: sortedNotes	staccatoSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedLoudSampleSet: sortedNotes	sustainedLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedSoftSampleSet: sortedNotes	sustainedSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!sustainedThreshold: aNumber	sustainedThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedLoud]				ifFalse: [keymap _ staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedSoft]				ifFalse: [keymap _ staccatoSoft]].	keymap ifNil: [keymap _ sustainedLoud].	note _ (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 12:39'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r _ IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i _ 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i _ i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower _ sortedNotes at: i - 1.	higher _ sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r _ OrderedCollection new: aNoteList size.	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch _ 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch _ n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud _ self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft _ self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud _ self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft _ self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap _ Array new: 128 withAll: aNote.	sustainedLoud _ oneNoteMap.	sustainedSoft _ oneNoteMap.	staccatoLoud _ oneNoteMap.	staccatoSoft _ oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 18:22'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd _ LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 20:32'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all _ OrderedCollection new.	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		info _ AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 17:15'!tempTest	(AbstractSound bachFugueVoice1On: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern _ (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:27'!new	^ super new initialize! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir _ orchestraDir, ':', instName.	memBefore _ Smalltalk garbageCollect.	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd _ SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 18:06'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' f'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:10'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !a basic web browser.It downloads things in a background thread; the background thread puts downloaded objects onto downloadQueue as they arrive.  The queue is checked in the step method.A custom start page is provided for.  It's not as convenient as bookmarks are, but it does have a lot of flexibility--the user can put anything on the start page that is desired.There is a hook for displaying the "lint" of a page; currently it's not a very effective linter.!!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItContext	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItReceiver	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 7/29/1998 03:28'!release	self stopEverything.	super release.! !!Scamper methodsFor: 'lint' stamp: 'ls 8/1/1998 03:10'!hasLint	"whether the current page has any questionable HTML in it"	document ifNil: [ ^false ].	^document lint ~= ''! !!Scamper methodsFor: 'lint' stamp: 'ls 9/14/1998 20:38'!lint	"return a string describing any questionable HTML that was noticed in the current page"	"(not currently very comprehensive)"	document ifNil: [ ^'' ].	^document lint! !!Scamper methodsFor: 'lint' stamp: 'ls 7/29/1998 00:07'!showLint	(StringHolder new contents: self lint) openLabel: 'lint for ', self currentUrl printString.! !!Scamper methodsFor: 'testing' stamp: 'ls 7/14/1998 21:44'!isWebBrowser	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 01:43'!displayHistory	"let the user selecet a previous page to view"	| menu |	menu _ MenuMorph entitled: 'Recent URLs'.	menu defaultTarget: self.	menu addStayUpItem.	menu addLine.	recentDocuments reverseDo: [ :doc |		menu add: doc url toText selector: #displayDocument: argument: doc ].	menu popUpAt: Sensor mousePoint  forHand: World primaryHand! !!Scamper methodsFor: 'menus' stamp: 'ls 8/8/1998 03:59'!editStartPage	| win textMorph |	World ifNil: [ self error: 'only works for morphic currently' ].	win _ SystemWindow labelled: 'edit Bookmark page'.	textMorph _ PluggableTextMorph on: self text: #startPage  accept: #startPage:.	win addMorph: textMorph frame: (0@0 extent: 1@1).	win openInWorld.	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 17:54'!inspectParseTree	"inspect a parse tree of the current page's source"	document ifNotNil: [ document inspect ]! !!Scamper methodsFor: 'menus' stamp: 'ls 9/7/1998 07:48'!menu: menu  shifted: shifted	| lines selections linePositions |	lines _ 'new URLhistoryview sourceinspect parse treego to start pageedit start page'.	linePositions _ #(2 4).	selections _ #(jumpToNewUrl displayHistory viewSource inspectParseTree visitStartPage editStartPage ).	downloadingProcess ifNotNil: [ 		lines _ lines, String cr, 'stop downloading'.		linePositions _ linePositions, selections size.		selections _ selections, #(stopEverything) ].	menu labels: lines lines: linePositions selections: selections.	^menu.! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 02:28'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!Scamper methodsFor: 'menus' stamp: 'ls 7/27/1998 23:16'!viewSource	"view the source HTML of this page"	(StringHolder new contents: (pageSource withSqueakLineEndings)) openLabel: 'source for ',currentUrl printString.! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 02:01'!visitStartPage	self jumpToAbsoluteUrl: 'browser:start'.	^true! !!Scamper methodsFor: 'changing page' stamp: 'di 9/23/1998 11:46'!displayDocument: mimeDocument	"switch to viewing the given MIMEDocument"	| newUrl  newSource handled  formatter fileName file image imageMorph attrib text |	newUrl _ mimeDocument url.	newSource _ mimeDocument.	handled _ false.	"add it to the history"	recentDocuments removeAllSuchThat: [ :d | d url = mimeDocument url ].	recentDocuments addLast: mimeDocument.	recentDocuments size > 20 ifTrue: [ recentDocuments removeFirst ].			newSource mainType = 'image' ifTrue: [		"an image--embed it in a text"		document _ nil.		formattedPage _ [			image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.			imageMorph _ ImageMorph new image: image.			attrib _ TextAnchor new anchoredMorph: imageMorph.			text _ ' * ' asText.			text addAttribute: attrib from: 2 to: 2.			text		] ifError: [ :msg :ctx | msg ].		currentUrl _ newUrl.		pageSource _ newSource content.		handled _ true. 		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  		"remove it from the history--these thigns are too big!!"		"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."		recentDocuments removeLast.	].	newSource contentType = 'text/html' ifTrue: [		"HTML page--format it"		currentUrl _ newUrl.		pageSource _ newSource content.		self status: 'parsing...'.		document _ (HtmlParser parse: (ReadStream on: pageSource)).		self status: 'laying out...'.		formatter _ HtmlFormatter new.		formatter browser: self.		formatter baseUrl: currentUrl.		document addToFormatter: formatter.		formattedPage _ formatter text.		currentUrl fragment			ifNil: [ currentAnchorLocation _ nil ]			ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].		self startDownloadingMorphState: (formatter incompleteMorphs).		handled _ true.		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  ].	(#('audio/midi' 'audio/x-midi') includes: newSource contentType) ifTrue: [		Smalltalk at: #MIDIFileReader ifPresent:			[:reader |			reader playStream: (RWBinaryOrTextStream with: newSource content) reset binary.			self status: 'sittin'.			handled _ true]].	(handled not and: [ newSource mainType = 'text']) ifTrue: [		"treat as plain text"		pageSource _ newSource content.		document _ nil.		formattedPage _ pageSource withSqueakLineEndings.		currentUrl _ newUrl.				self status: 'sittin'.		self changed: #currentUrl.		self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.  		handled _ true].	handled ifFalse: [		"offer to save it to a file"		self status: 'sittin'.		(self confirm: 'unkown content-type ', newSource contentType,'--Would you like to save to a file?') ifFalse: [			^self ].		fileName _ ''.		[			fileName _ FillInTheBlank request: 'file to save in' initialAnswer: fileName.			fileName isEmpty ifTrue: [ ^self ].			file _ FileStream fileNamed: fileName.			file == nil		] whileTrue.		file reset.		file binary.		file nextPutAll: newSource content.		file close.	].! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/13/1998 07:14'!jumpToAbsoluteUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	|  newUrl newSource |	self stopEverything.	"get the new url"	newUrl _ urlText asUrl.	"if it fundamentally doesn't fit the pages-and-contents model used internally, spawn off an external viewer for it"	newUrl hasContents ifFalse: [ newUrl activate.  ^true ].	"fork a Process to do the actual downloading, parsing, and formatting.  It's results will be picked up in #step"	self status: 'downloading ', newUrl toText, '...'.	downloadingProcess _ [ 	  	newSource _ [ newUrl retrieveContentsForBrowser: self ] ifError: [ :msg :ctx |			MIMEDocument contentType: 'text/plain' content: msg ].		newSource 			ifNil: [ newSource _ MIMEDocument contentType: 'text/plain' content: 'Error retrieving this URL' ].			newSource url ifNil: [				newSource _ MIMEDocument contentType: newSource contentType  content: newSource content  url: newUrl ].			documentQueue nextPut: newSource.			downloadingProcess _ nil.	] newProcess.	downloadingProcess resume.	^true! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 08:56'!jumpToNewUrl	"change to a new, user-specified page"	| newUrl |	newUrl _ FillInTheBlank request: 'url to visit' initialAnswer: currentUrl toText.	(newUrl isNil or: [ newUrl isEmpty ]) ifTrue: [ ^self ].	self jumpToAbsoluteUrl: newUrl! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 11:22'!jumpToUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	self jumpToAbsoluteUrl: (urlText asUrlRelativeTo: currentUrl)! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/5/1998 18:12'!startDownloadingMorphState: morphs	downloadingProcess _ [		morphs do: [ :m | m downloadState ].	] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/12/1998 00:56'!startDownloadingStateIn: aDocument  url: aUrl	"download the state for the given document in a background thread.  signal the foreground when the data has arrived"	downloadingProcess _ [			aDocument allSubentitiesDo: [ :e |			e downloadState: aUrl ].		documentQueue nextPut: #stateDownloaded.		downloadingProcess _ nil. ] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 7/24/1998 01:28'!stopEverything	"stop all background threads and empty queues for communicating with them; bring this Scamper to a sane state before embarking on something new"		downloadingProcess ifNotNil: [		downloadingProcess terminate.		downloadingProcess _ nil. ].	[ documentQueue isEmpty ] whileFalse: [ documentQueue next ].	self status: 'sittin'.! !!Scamper methodsFor: 'changing page' stamp: 'tk 9/22/1998 20:26'!submitFormWithInputs: inputs  url: url  method: method	| newUrl newSource | 	self stopEverything.	(method asLowercase ~= 'get' and: [ method asLowercase ~= 'post' ]) ifTrue: [		self notify: 'unkown FORM method: ', method.		^false ].	newUrl _ url asUrlRelativeTo: currentUrl.		newUrl schemeName ~= 'http' ifTrue: [		self notify: 'I can only submit forms via HTTP'.		^false ].	self status: 'submitting form...'.	downloadingProcess _ [			method asLowercase = 'get' 				ifTrue: [newSource _ newUrl retrieveContentsArgs: inputs] 				ifFalse: [newSource _ newUrl postFormArgs: inputs].			documentQueue nextPut:  newSource.			downloadingProcess _ nil.		] newProcess.		downloadingProcess resume.		^true! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 03:18'!currentUrl	^currentUrl! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 02:47'!document	"return the current parsed HTML document, or nil if we aren't viewing a page"	^document! !!Scamper methodsFor: 'access' stamp: 'ls 7/21/1998 01:16'!formattedPage	"format the current page and return it as a Text" 	^formattedPage ifNil: [ ^Text new ].	! !!Scamper methodsFor: 'access' stamp: 'ls 9/10/1998 03:38'!formattedPageSelection	currentAnchorLocation ifNil: [ ^0 to: -1 ].	^currentAnchorLocation to: currentAnchorLocation! !!Scamper methodsFor: 'access' stamp: 'ls 8/1/1998 03:10'!title	"return the title of the current page, or nil if there is none"	document == nil		ifTrue: [ ^nil ]		ifFalse: [ ^self document head title ifNil: ['(untitled)'] ]! !!Scamper methodsFor: 'stepping' stamp: 'ls 8/12/1998 01:39'!step	"check if a new document has arrived"	| results |	[documentQueue isEmpty] whileFalse: [		results _ documentQueue next.		results == #stateDownloaded ifTrue: [ 			"images and such have been downloaded; update the page"			self status: 'reformatting page...'.			formattedPage _ document formattedTextForBrowser: self defaultBaseUrl: currentUrl.			self changed: #formattedPage.			self status: 'sittin'. ]		 ifFalse: [					self displayDocument: results 			] ]! !!Scamper methodsFor: 'initialization' stamp: 'ls 8/12/1998 01:21'!initialize	documentQueue _ SharedQueue new.	recentDocuments _ OrderedCollection new.	currentUrl _ 'http://minnow.cc.gatech.edu/squeak.1' asUrl.	pageSource _ ''.	document _ HtmlParser parse: (ReadStream on: '').	self status: 'sittin'.	self jumpToUrl: currentUrl.! !!Scamper methodsFor: 'browser urls' stamp: 'ls 8/12/1998 01:23'!browserUrlContents: aRequest	aRequest = 'start' ifTrue: [ 		^MIMEDocument contentType: 'text/html' content: self startPage ].	^ nil! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status	^status! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status: aSymbol	status _ aSymbol.	self changed: #status.! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:01'!startPage	"return the contents of the user's personal start page"	| file |	file _ FileStream oldFileOrNoneNamed: 'StartPage.html'.	file 		ifNil: [ ^'<title>Personal Start Page</title>\<h1>Personal Start Page</h1>\This space is empty' withCRs ]		ifNotNil: [ ^file contentsOfEntireFile ]! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:02'!startPage: newPage	"fill in the contents of the user's personal start page"	| file |	FileDirectory default deleteFileNamed: 'StartPage.html'.	file _ FileStream fileNamed: 'StartPage.html'.	file ifNil: [ self error: 'could not save file' ].	file nextPutAll: newPage asString.	file close.		self changed: #startPage.	^true! !!Scamper methodsFor: 'user interface' stamp: 'ls 9/18/1998 06:43'!openAsMorph	"open a set of windows for viewing this browser"	|win urlMorph |	"create a window for it"	win _ SystemWindow labelled: 'Scamper'.	win model: self.	win setProperty: #webBrowserView toValue: true.	"create a title view"	win addMorph: (PluggableTextMorph on: self text: #title accept: nil) frame: (0.0@0 extent: 1@0.1).	"create a view of the current url"	"win addMorph: (RectangleMorph new) frame: (0@0.1 extent: 0.3@0.1)."	urlMorph _  PluggableTextMorph on: self text: #currentUrl accept: #jumpToAbsoluteUrl:.	urlMorph acceptOnCR: true.	win addMorph: urlMorph frame: (0@0.1 extent: 1@0.1).	"create a status view"	win addMorph: (PluggableTextMorph on: self text: #status accept: nil) frame: (0@0.9 extent: 1.0@0.1).	"create the text area"	win addMorph: (PluggableTextMorph on: self text: #formattedPage accept: nil readSelection: #formattedPageSelection menu: #menu:shifted:)		frame: (0@0.2 extent: 1@0.7).		win openInWorld.	^win! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 7/17/1998 23:02'!new	^super new initialize! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 23:21'!openAsMorph	"Scamper openAsMorph"	^self new openAsMorph! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!StartUrl: aUrl	"specify the URL to start from"	StartUrl _ aUrl asUrl.! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!initialize	self StartUrl: 'http://minnow.cc.gatech.edu/squeak'.  "the Squeak home page"! !This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.!!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 08:38'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 09:54'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07'!doControl	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	self processAllAtTick: ticksSinceStart asInteger.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/5/1998 23:07'!isPlaying	^ SoundPlayer isPlaying: self! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |	myLeftVol _ (leftVol * overallVolume) asInteger.	myRightVol _ (rightVol * overallVolume) asInteger.	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:06'!processAllAtTick: scoreTick	self processTempoMapAtTick: scoreTick.	midiPort		ifNil: [self processNoteEventsAtTick: scoreTick]		ifNotNil: [self processMIDIEventsAtTick: scoreTick].	self processAmbientEventsAtTick: scoreTick.	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:50'!processAmbientEventsAtTick: scoreTick	"Process ambient events through the given tick."	| i evt |	i _ trackEventIndex at: trackEventIndex size.	[evt _ score ambientEventAfter: i ticks: scoreTick.	 evt ~~ nil] whileTrue: [		i _ i + 1.		evt occurAtTime: scoreTick inScorePlayer: self atIndex: i inEventTrack: score ambientTrack secsPerTick: secsPerTick].	trackEventIndex at: trackEventIndex size put: i.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:49'!processNoteEventsAtTick: scoreTick	"Process note events through the given score tick using internal Squeak sound synthesis."	| instr j evt snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [				snd _ instr					soundForMidiKey: evt midiKey					dur: secsPerTick * evt duration					loudness: evt velocity asFloat / 127.0.				activeSounds add: (Array with: snd with: i)].			j _ j + 1.			trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:51'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	activeMIDINotes _ OrderedCollection new.	score resetFrom: self.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!closeMIDIPort	"Close my MIDI port, if it is open. Music will be played using the built-in sound synthesis."	self pause.	midiPort ifNil: [^ self].	midiPort close.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 21:37'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 10.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	self closeMIDIPort.	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 18:31'!processMIDIEventsAtTick: scoreTick	"Process note events through the given score tick using MIDI."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			evt isNoteEvent				ifTrue: [					(muted at: i) ifFalse: [						evt startNoteOnMidiPort: midiPort.						activeMIDINotes add: (Array with: evt with: i)]]				ifFalse: [evt outputOnMidiPort: midiPort].			j _ j + 1.			trackEventIndex at: i put: j]].	self turnOffActiveMIDINotesAt: scoreTick.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:45'!startMIDIPlaying	"Start up a process to play this score via MIDI."	midiPort ensureOpen.	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ [self midiPlayLoop] newProcess.	midiPlayerProcess		priority: Processor userInterruptPriority;		resume.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!stopMIDIPlaying	"Terminate the MIDI player process and turn off any active notes."	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ nil.	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].	activeMIDINotes _ activeMIDINotes species new.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!turnOffActiveMIDINotesAt: scoreTick	"Turn off any active MIDI notes that should be turned off at the given score tick."	| evt someNoteEnded |	midiPort ifNil: [^ self].	someNoteEnded _ false. 	activeMIDINotes do: [:pair |		evt _ pair first.		evt endTime <= scoreTick ifTrue: [			evt endNoteOnMidiPort: midiPort.			someNoteEnded _ true]].	someNoteEnded ifTrue: [		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:54'!msecsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 17:25'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!overallVolume	^ overallVolume! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!overallVolume: aNumber	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!panForTrack: i	| left right fullVol pan |	left _ leftVols at: i.	right _ rightVols at: i.	left = right ifTrue: [^ 0.5].  "centered"	fullVol _ left max: right.	left < fullVol		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].	^ pan roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:58'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	fullVol _ (leftVols at: i) max: (rightVols at: i).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: i put: right asInteger.	leftVols at: i put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!ticksForMSecs: mSecs	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!ticksSinceStart	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!volumeForTrack: i	| vol |	vol _ (leftVols at: i) max: (rightVols at: i).	^ (vol asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/30/1998 20:22'!volumeForTrack: i put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: i.	oldRight _ rightVols at: i.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: i put: left asInteger.	rightVols at: i put: right asInteger.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:46'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	score pauseFrom: self.	super pause.	activeSounds _ activeSounds species new.	midiPort ifNotNil: [self stopMIDIPlaying].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:45'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	score resumeFrom: self.	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!tempoOrRateChanged	"This method should be called after changing the tempo or rate."	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!closeMIDI	scorePlayer closeMIDIPort.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!instrumentChoicesForTrack: trackIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	names add: 'edit ', (instrumentSelector at: trackIndex) contents.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:40'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('reload instruments'		updateInstrumentsFromLibrary)		('play via built in synth'	closeMIDI)		('play via MIDI port 0'		openMIDIPort0)		('play via MIDI port 1'		openMIDIPort1)).	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:43'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	repeatSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Repeat';		actionSelector: #repeat:;		target: scorePlayer;		setSwitchState: scorePlayer repeat.	r addMorphBack: repeatSwitch.	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:05'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll h |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	h _ self world activeHand.	h		ifNil: [self world addMorph: pianoRoll]		ifNotNil: [h attachMorph: pianoRoll].	pianoRoll startStepping.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:32'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort0	scorePlayer openMIDIPort: 0.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort1	scorePlayer openMIDIPort: 1.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:29'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:10'!scorePlayer	^ scorePlayer! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:09'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 14:32'!aboutThisSystem 	"Identify software version"	| aString eToySystem aNumber |	aString _ Smalltalk version.	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'EToy System: ', eToySystem version, ' of ', eToySystem versionDate].	aNumber _ ChangeSorter highestNumberedChangeSet.	(aNumber notNil and: [aNumber > 0]) ifTrue:		[aString _ aString, 'Highest-numbered update: ', aNumber printString].	aString _ aString, 'Current Change Set: ', Smalltalk changes name.	^ self inform: aString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 8/5/1998 18:40'!browseChangedMessages	Smalltalk browseChangedMessages! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:09'!durableChangesMenu 	Utilities windowFromMenu: self changesMenu target: self title: 'Changes'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:29'!durableHelpMenu 	Utilities windowFromMenu: self helpMenu target: self title: 'Help'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 14:40'!durableOpenMenu 	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern:		#(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan lightBlue lightBlue white white lightOrange lightOrange lightOrange )! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 14:36'!durableScreenMenu 	Utilities windowFromMenu: self projectScreenMenu target: self title: 'Squeak'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:15'!durableWindowMenu 	Utilities windowFromMenu: self windowMenu target: self title: 'Window controls'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/23/1998 02:06'!fontSizeSummary	Utilities fontSizeSummary! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 10:17'!newChangeSet	ChangeSorter newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:07'!openConstructionProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView openAndEnter: Project newMorphicConstruction! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicConstructionWorld 	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph openWithStandardPartsBinShowing! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:06'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: Project newMorphic.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph new open.! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 8/31/1998 16:18'!openSelectorBrowser	"Create and schedule a selector fragment window."	SelectorBrowser new open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/2/1998 15:37'!soundOnOrOff	Preferences setPreference: #disableSounds		toValue: (Preferences valueOfFlag: #disableSounds) not! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/14/1998 10:14'!viewImageImports	"Open an inspector on forms imported from Image files."	Smalltalk viewImageImports! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 14:54'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'file out changes'			'create new change set...'			'browse changed methods'			'simple change sorter'			'dual change sorter'			'browse recent submissions'			'recent change log'			)		lines: #(1 4 6)		selections: #(durableChangesMenufileOutChanges newChangeSet browseChangedMessagesopenSimpleChangeSorter openChangeManagerbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/23/1998 02:07'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'keep this menu up'			'edit preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view image imports'			'full screen on'			'full screen off'			'set display depth...'			'set desktop color...' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) ,		#(	'update code from server'			'about this system'			'set author initials...'			'vm statistics'			'space left')		lines: #(1 6 11)		selections: #(durableHelpMenueditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsfullScreenOn fullScreenOff setDisplayDepth setDesktopColor soundOnOrOffabsorbUpdatesFromServer aboutThisSystem setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 14:29'!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'simple change sorter'			'dual change sorter'			'morphic window'			'construction window'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 8 10)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowser openSimpleChangeSorter openChangeManageropenMorphicWorld openMorphicConstructionWorldopenProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:05'!popUpMenuFor: aSymbol	| reply |	reply _ (self perform: aSymbol) startUp.	reply ifNil: [^ self].	self perform: reply! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 22:46'!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(	'keep this menu up'			'previous project'			'jump to project...'			'restore display'			'open window...'			'windows...'			'changes...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 9)		selections: #(durableScreenMenureturnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 15:14'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'keep this menu up'			'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows' ) , 			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(1 4 7)		selections: #(durableWindowMenufindWindow chooseDirtyBrowser chooseDirtyWindowcollapseAll expandAll closeUnchangedWindowsfastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:06'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[^ self popUpMenuFor: reply].	^ self perform: reply! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted _ anActorMorph player! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/14/1998 14:47'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters my bounds, button up'		'mouseLeave -- when mouse exits my bounds, button up'		'mouseEnterDragging -- when mouse enters my bounds, button down'		'mouseLeaveDragging -- when mouse exits my bounds, button down'		'opening -- when I am being opened'		'closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/11/1998 11:22'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	Preferences editPlayerScriptsInPlace		ifTrue:			[self addTextualScript: newBrowser]		ifFalse:			[Browser openBrowserView: (newBrowser openMessageEditString: nil) label: ('textual script for "', scriptName, '" in ', playerScripted externalName)]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:11'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/3/1998 15:08'!isTextuallyCoded	(self topEditor isKindOf: ScriptEditorMorph) ifFalse: [^ false].  "workaround for the case where the receiver is embedded in a free-standing CompoundTileMorph.  Yecch!!"	^ self userScriptObject isTextuallyCoded! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/29/1998 10:43'!storeCodeOn: aStream indent: tabCount	| lastOwner |	lastOwner _ nil.	self tileRows do: [:r |		r do: [:m |			((m isKindOf: TileMorph) or:			 [(m isKindOf: CompoundTileMorph) or:			 [m isKindOf: PhraseTileMorph]]) ifTrue: [				tabCount timesRepeat: [aStream tab].				((m owner ~= lastOwner) and: [lastOwner ~= nil])					ifTrue:						[aStream nextPut: $.; cr; tab.						m storeCodeOn: aStream indent: tabCount]					ifFalse:						[(lastOwner ~= nil) ifTrue: [aStream space].						m storeCodeOn: aStream indent: tabCount].				lastOwner _ m owner]]].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 17:40'!userScriptObject	^ self topEditor playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 8/6/1998 13:59'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 7/4/1998 18:02'!wantsDroppedMorph: aMorph	^ false   "though later we could drop onto formal args in the header"! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:20'!runIfClosing	| result |	(result _ status == #closing) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:19'!runIfOpening	| result |	(result _ status == #opening) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 5/7/1998 22:06'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 23:43'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #resetTimer to: self.	pagingArea on: #mouseStillDown send: #scrollByPage: to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeUpButton	upButton := RectangleMorph		newBounds: ((bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!nextPage: event	"Note: this method is no longer called, except by old scrollBars"	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	event cursorPoint y >= slider center y		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!scrollByPage: event	nextPageDirection == nil ifTrue:		[nextPageDirection _ event cursorPoint y >= slider center y].	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollDown	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:44'!scrollDownInit	downButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollUp	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:45'!scrollUpInit	upButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/14/1998 15:19'!setValue: newValue	^ super setValue: (newValue truncateTo: scrollDelta)! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:22'!resetTimer	timeOfMouseDown _ Time millisecondClockValue.	timeOfLastScroll _ timeOfMouseDown - 1000 max: 0.	nextPageDirection _ nil.	currentScrollDelay _ nil! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:38'!waitForDelay1: delay1 delay2: delay2	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll == nil ifTrue: [self resetTimer]. "Only needed for old instances"	now _ Time millisecondClockValue.	now < timeOfLastScroll ifTrue: [self resetTimer  "rare clock rollover"].	(scrollDelay _ currentScrollDelay) == nil ifTrue: [scrollDelay _ delay1  "initial delay"].	now > (timeOfLastScroll + scrollDelay) ifFalse: [^ false  "not time yet"].	currentScrollDelay _ scrollDelay*9//10 max: delay2.  "decrease the delay"	timeOfLastScroll _ now.	^ true! !!ScrollController methodsFor: 'control defaults' stamp: 'di 6/26/1998 13:11'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's menu."	| menu sel |	menu _ view getMenu: shiftKeyState.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !The scroller (a transform) of a scrollPane is driven by the scrollBar.  The scroll values vary from 0.0, meaning zero offset to 1.0 meaning sufficient offset such that the bottom of the scrollable material appears halfway down the pane.  The total distance to achieve this range is called the totalScrollRange.!!ScrollPane methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:05'!fullCopy	| copy |	self mouseEnter: nil.		 "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.		"So that references are updated properly"		"Will fail of any Players with scripts are in the ScrollPane"	self mouseLeave: nil.	^ copy mouseLeave: nil! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/16/1998 01:09'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar bounds containsRect: aRectangle]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 7/6/1998 13:11'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset r |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	(r _ self totalScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/14/1998 15:52'!totalScrollRange	^ (scroller submorphBounds encompass: 0@0) height - (bounds height * 3 // 4) max: 0! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 8/13/1998 10:14'!mouseLeave: event	retractableScrollBar ifTrue:		[self privateRemoveMorph: scrollBar.		scrollBar privateOwner: nil]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:29'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !allows a user to select from a number of options!!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:38'!active	^listMorph getCurrentSelectionIndex > 0! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:15'!name	^name! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:16'!reset	listMorph selection: defaultValue! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:39'!value	^values at: listMorph getCurrentSelectionIndex! !!SelectionInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue0  list: list0 values: values0	name _ name0.	defaultValue _ defaultValue0.	listMorph _ list0.	values _ values0.! !!SelectionInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue  list: list  values: values	^self new name: name0  defaultValue: defaultValue  list: list  values: values! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'di 8/20/1998 09:18'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	"Labels can be either a sting with embedded crs, or a collection of strings"	| labelString |	(labels isMemberOf: String)		ifTrue: [labelString _ labels]		ifFalse: [labelString _ String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:20'!classList	^ classList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:23'!classListIndex	^ classListIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:46'!classListIndex: anInteger	classListIndex _ anInteger.	classListIndex > 0 ifTrue: [		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex _ 0"]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:33'!classListSelectorTitle	^ 'Class List Menu'! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 16:08'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	contents _ aString.	classList _ #().  classListIndex _ 0.	selectorIndex _ 0.   	selectorList _ Cursor wait showWhile: [		(Symbol selectorsContaining: contents asString) asSortedArray].	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/21/1998 17:35'!defaultBackgroundColor	^ #lightCyan! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!implementors	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllImplementorsOf: aSelector]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:19'!messageList	"Find all the selectors containing what the user typed in."	^ selectorList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 10:58'!messageListIndex	"Answer the index of the selected message selector."	^ selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 19:28'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger.  Find all classes it is in."	selectorIndex _ anInteger.	selectorIndex = 0 ifFalse: [		classList _ Smalltalk allImplementorsOf: (selectorList at: selectorIndex).		classListIndex _ 0.		self changed: #messageListIndex.		"update my selection"		self changed: #classList]! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 17:04'!open	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	|  selectorListView typeInView topView classListView |	World ifNotNil: [^ self openAsMorph].	selectorIndex _ classListIndex _ 0.	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	typeInView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView window: (0@0 extent: 100@14);		askBeforeDiscardingEdits: false.	topView addSubView: typeInView.	selectorListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	selectorListView window: (0 @ 0 extent: 100 @ 86).	topView addSubView: selectorListView below: typeInView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil	"never anything selected"		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	classListView window: (0 @ 0 extent: 100 @ 100).	topView addSubView: classListView toRightOf: typeInView.	topView label: 'Full Browser from Selector Fragment'.	topView minimumSize: 300 @ 200; maximumSize: 450@200.	topView subViews do: [:each | each controller].	topView controller open.! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 17:05'!openAsMorph	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	| window typeInView selectorListView classListView |	window _ (SystemWindow labelled: 'later') model: self.	selectorIndex _ classListIndex _ 0.	typeInView _ PluggableTextMorph on: self 		text: #contents accept: #contents:notifying:		readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"typeInView askBeforeDiscardingEdits: false."	window addMorph: typeInView frame: (0@0 corner: 0.5@0.14).	selectorListView _ PluggableListMorph on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	window addMorph: selectorListView frame: (0@0.14 corner: 0.5@1).	classListView _ PluggableListMorph on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	window addMorph: classListView frame: (0.5@0 corner: 1@1).	window setLabel: 'Full Browser from Selector Fragment'.	window openInWorldExtent: 450@200! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:50'!selectedClass	"Answer the currently selected class."	classListIndex = 0 ifTrue: [^nil].	MessageSet parse: (classList at: classListIndex) 		toClassAndSelector: [:cls :sel | ^ cls].! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:48'!selectedClassName	"Answer the name of the currently selected class."	classListIndex = 0 ifTrue: [^nil].	^ self selectedClass name! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:29'!selectedMessageName	"Answer the name of the currently selected message."	selectorIndex = 0 ifTrue: [^nil].	^ selectorList at: selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:32'!selectorMenu: aMenu	^ aMenu labels: 'sendersimplementors'	lines: #()	selections: #(senders implementors)! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:37'!selectorMenuTitle	^ self selectedMessageName ifNil: ['<no selection>']! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!senders	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllCallsOn: aSelector]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:36'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index _ self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index _ self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:04'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur + snd duration].	^ dur! !Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.			(for file://, directory is converted to local delimiters.)type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.altURL		When a FTP server holds some web pages, the altURL of those pages is often			different from the FTP directory.  Put the altURL here.  If the directory is 			'public_html/Squeak/', the altURL might be 'www.webPage.com/~kaehler2/			Squeak/'.urlObject	An instance of a subclass of Url.  It is very good at parsing complex urls.			Relative references.  file:// uses this.  Use this in the future instead of 			server and directory inst vars.			!]style[(677 8 685)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/18/1998 23:25'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: (resp _			FileStream oldFileNamed: server,(self serverDelimiter asString), self bareDirectory,				(self serverDelimiter asString),fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/16/1998 08:46'!openNoDataFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  No dataPort is opened.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	^ so! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:20'!checkNames: list	"Look at these names for update and see if they are OK"list do: [:local |	(local count: [:char | char == $.]) > 1 ifTrue: [		self inform: 'File name ',local,'may not have more than one period'.	^ false].	(local at: 1) isDigit ifTrue: [		self inform: 'File name ',local,'may not begin with a number'.	^ false].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		self inform: 'File name ',local,'may not contain % / * or space'.	^ false]].^ true! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 9/5/1998 17:20'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (altURL size > 0) ifTrue: [			strm _ HTTPSocket httpGet: altURL accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:25'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2051)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:24'!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind).			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:24'!bareDirectory	^ directory first == $/ 		ifTrue: [directory copyFrom: 2 to: directory size]		ifFalse: [directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/19/1998 18:54'!copy	| new |	new _ self clone.	new urlObject: urlObject copy.	^ new! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 11:50'!directory	^ directory! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:18'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:23'!moniker	"a plain language name for this directory"	moniker ifNotNil: [^ moniker].	directory ifNotNil: [^ self slashDirectory].	urlObject ifNotNil: [^ urlObject toText].	^ ''! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/23/1998 09:41'!printOn: aStrm	aStrm nextPutAll: self class name; nextPut: $<.	aStrm nextPutAll: self moniker.	aStrm nextPut: $>.! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:22'!slashDirectory	^ directory first == $/ 		ifTrue: [directory]		ifFalse: ['/', directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:43'!type	^ type! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:44'!urlObject	^ urlObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:56'!urlObject: aUrl	urlObject _ aUrl! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:04'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	type == #file ifTrue: [FileDirectory createDirectory: localName].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:20'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	type == #file ifTrue: [FileDirectory deleteFileNamed: localName].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:49'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:58'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	urlObject ifNotNil: [		new urlObject path: (new urlObject path) copy.		(new urlObject path) removeLast; addLast: localFileName; addLast: ''.		^ new].	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:44'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForFile) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 19:29'!fullNameFor: aFileName	"Convention: 	If it is an absolute path, directory stored with a leading slash, and url has no user@.	If relative path, directory stored with no leading slash, and url begins user@.	Should we include ftp:// on the front?"	urlObject ifNotNil: [^ urlObject pathString, aFileName].	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	directory isEmpty ifTrue: [^ server, 		self pathNameDelimiter asString, aFileName].	^ (directory first == $/ ifTrue: [''] ifFalse: [user,'@']), 		server, self slashDirectory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:27'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:40'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:25'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readOnly.	file type == #file ifTrue: [		^ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)].	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:59'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/18/1998 23:26'!pathName	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [user, '@', server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:34'!pathNameDelimiter	"the separator that is used in URLs"	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:12'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	urlObject ifNotNil: [^ (urlObject path copy) removeLast; yourself].	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 15:11'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:36'!serverDelimiter	"the separator that is used in the place where the file actually is.  ftp server or local disk."	^ type == #file: ifTrue: [FileDirectory default pathNameDelimiter]		ifFalse: [^ $/]	"for ftp, http"! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group	"NOTE: This is an association whose key is the anme of the group, and	whose value is an array of serverDirectories, the first of which is	deemed to be the group directory."	^ group! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:54'!removeFromGroup	"Allowable if not in a group presently"	group ifNotNil:		["Group is an association shared by all members.		Therefore all will feel this removal"		group value: (group value copyWithout: self).		group _ nil  "...and I'm outa here"]! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 9/8/1998 11:57'!newFrom: aSimilarObject	"Must copy the urlObject, so they won't be shared"	| inst |	inst _ super newFrom: aSimilarObject.	inst urlObject: aSimilarObject urlObject copy.	^ inst! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 16:01'!addGroup: serverArray named: nameString	| groupAssn |	serverArray do: [:server | server removeFromGroup].	groupAssn _ nameString -> serverArray asArray copy.	serverArray do: [:server | server group: groupAssn].! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:24'!addServer: server named: nameString	Servers at: nameString put: server! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:15'!groupNamed: nameString	"Return the first server in the group of this name."	| grp server |	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [nameString = server groupName						ifTrue: [^ server]]].	^ self error: 'Server name not found'! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:03'!groupNames	"Return the names of all registered groups of servers, including individual servers not in any group.  Note: A serverDirectory that is a member of a group will return an array of the servers in its group.  The first server in that array represents the group, and its name is the name of the goup."	| grp names server |	names _ OrderedCollection new.	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [names add: server groupName]].	^ names asSortedArray! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 14:29'!removeServerNamed: nameString	Servers removeKey: nameString! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:16'!serverNamed: nameString	^ Servers at: nameString		ifAbsent: [self error: 'Server name not found']! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 13:30'!serverNames	^ Servers keys asSortedArray! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/8/1998 10:59'!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForFile, fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/6/1998 17:29'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	type == #file ifTrue: [fileName _  ''. ^ self].	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'jm 6/17/1998 09:01'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.The 'get' commands above make use of an internal buffer.  So intermixing these two commands and regular Socket recieve commands can cause problems.!!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done _ (chunk = ('.', String cr)) ].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 02:10'!getResponse	"Get a one-line response from the server.  The final LF is removed from the line, but the CR is left, so that the line is in Squeak's text format"	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line _ WriteStream on: String new.	buffer ifNil: [		buffer _ String new.		bufferPos _ 0 ].	[		"look for a LF in the buffer"		idx _ buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos _ idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos _ 0.		buffer _ String new.		self waitForDataQueryingUserEvery: 30.		buffer _ self getData.		true	] whileTrue.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/16/1998 14:37'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				self isConnected ifFalse: [					self destroy.					self error: 'server closed connection'].				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 6/8/1998 16:05'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !This is a first cut at a simple MIDI output port.!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!close	"Close this MIDI port."	portNumber ifNil: [^ self].	self primMIDIClosePort: portNumber.		portNumber _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:40'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	| portNum |	portNumber ifNil: [^ self openOnPortNumber: 'Use "openOn:" to open a MIDI port initially'].	portNum _ portNumber.	self close.	self openOnPortNumber: portNum.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	portNumber _ portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	lastCommandByteOut _ Array new: 16 withAll: 0.  "initialize running status state for output"! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:55'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:54'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte1			with: dataByte2)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 18:39'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	self primMIDIWritePort: portNumber from: aByteArray at: 0.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIClosePort: portNum	<primitive: 521>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:14'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33'!initialize	"SimpleMIDIPort initialize"	InterfaceClockRate _ 1000000.	DefaultPortNumber _ 0.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!openDefault	"Answer a new instance of me opened on the default MIDI port."	^ self openOnPortNumber: DefaultPortNumber! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:38'!openOnPortNumber: portNum	"Answer a new instance of me open on the given MIDI port."	^ super new openOnPortNumber: portNum! !Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph's registration point, rotation center, or ticksToDwell.New -- using transform morphs to rotate the finished player.  How get it rotated back and the rotationDegrees to be right?  We cancel out rotationDegrees, so how remember it?Registration point convention:  In a GraphicFrame, reg point is relative to this image's origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 20:12'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| w aPaintBox aPal  aPosition |	(w _ aPasteUpMorph world) addMorphFront: self.	aPaintBox _ w paintBox.	(aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPosition _ aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[aPosition _ aPaintBox position].	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	aPaintBox position: aPosition.	palette _  aPaintBox.	w addMorphFront: aPaintBox.  "bring to front"	palette position: aPosition.	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 8/2/1998 13:39'!addRotationScaleHandles	"Rotation and scaling handles"	| fwdButton pt toggle |	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView setupAngle direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 8/5/1998 20:13'!cancelOutOfPainting	self delete.	dimForm ifNotNil: [dimForm delete].	emptyPicBlock value.	"note no args to block!!"	hostView changed.	^ nil	"Tell them we cancelled"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 7/30/1998 16:21'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^true! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^true! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/30/1998 17:30'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !The morph that results when the user draws a color bitmap using the PaintBox (SketchEditorMorph and PaintBoxMorph).  forwardDirection is the angle at which the object will go forward.  When the rotationStyle is not #normal, then forwardDirection is any angle, while the rotation is highly restricted.  If flexed, this is remembered by the Transform morph.  For non-normal rotationStyle, it is rotationDegrees.setupAngle (a property) is where the user put the green arrow to indicate which direction on the picture is forward.  When #normal, draw the morph initially at (0.0 - setupAngle).  The enclosing TransformationMorph then rotates it to the true angle. rotationDegrees  In a #normal object, rotationDegrees is constant an equal to setupAngle.	For non-normal, it is the direction the object is going.When repainting, set it back to its original state. The green arrow is set to setupAngle, and the sketch is shown as drawn originally (rotationDegrees = 0). rotationStyle = normal (turns), leftRight, upDown, fixed.  When leftRight upDown or fixed, bit map has severe restrictions.!!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:11'!forwardDirection	"Return my forward direction.  If #normal I am not flexed."	^ rotationStyle == #normal 		ifTrue: [0.0]		ifFalse: [rotationDegrees]	"fwd dir kept here when leftRight, upDown, none"! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:52'!forwardDirection: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #forwardDirection]		ifFalse: [self setProperty: #forwardDirection toValue: degrees].! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/9/1998 13:15'!originalForm: aForm	originalForm _ aForm! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 11:54'!setupAngle	"Return the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	^ (self valueOfProperty: #setupAngle) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:53'!setupAngle: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #setupAngle]		ifFalse: [self setProperty: #setupAngle toValue: degrees].! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:35'!doesOwnRotation	"When not #normal, don't let to TransformMorph to rotate my image"	^ rotationStyle ~~ #normal! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 12:05'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ 0.0 - self setupAngle]			"let TransformationMorph do directional image turn, we subtract green arrow angle"		ifFalse: [adjustedAngle _ 0.0].	"leftRight, upDown, none"	((adjustedAngle = 0.0) and: [0.0@0.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: ["do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!SketchMorph methodsFor: 'menu' stamp: 'tk 7/6/1998 15:31'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	"costumee ifNotNil: [self forwardDirection: costumee direction]."  "how say this?"	self editDrawingIn: self pasteUpMorph forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'sw 9/23/1998 10:57'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w oldRotation bnds sketchEditor |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	oldRotation _ rotationDegrees.	forBackground		ifTrue:			[bnds _ aPasteUpMorph boundsInWorld]		ifFalse:			[bnds _ (self boundsInWorld expandBy: (60 @ 60)) intersect: self world bounds.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds pasteUpMorph: aPasteUpMorph.		"self rotationDegrees: 0.  inside the init"	self rotationDegrees: oldRotation.  "restore old rotation so that cancel leaves it right"	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self topRendererOrSelf position: aRect origin.			self rotationStyle: sketchEditor rotationStyle.			self setupAngle: sketchEditor forwardDirection.			self rotationDegrees: sketchEditor forwardDirection.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil:				[aPasteUpMorph standardPalette viewMorph: self]]! !!SketchMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:02'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'change reporting' stamp: 'tk 7/6/1998 14:26'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form.			All normal rotation handled by TransformMorph.rotationDegrees:"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #editDrawing to: aHalo innerTarget! !My instances are 30-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmallInteger methodsFor: 'copying' stamp: 'tk 8/19/1998 16:04'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 14:47'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:09'!moreObjects	"Return true if there appears to be another object following this one on the file."	| byte |	byteStream atEnd ifTrue: [^ false].	"off end of file"	(byte _ byteStream peek) ifNil: [^ false].	"off end of file"	byte = 33 "$!! asciiValue" ifTrue: [^ false].	byte = 0 ifTrue: [^ false].	^ byte <= RefTypes size		"between 1 and 16"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:01'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ #marked.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 9/9/1998 14:01'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses (i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo) ...)"	| normal aName newName newCls trans rList |	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars" 	classInstVars _ super next.	"Array of arrays"	normal _ Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: #()) = #(0 'dependents' 'costume') ifTrue: [		trans _ 1].	"now (0 costume costumes).  Do the conversion of Player class 			inst vars in Update 509."	classInstVars do: [:list |		aName _ (list at: 1) asSymbol.		rList _ list.		newName _ renamed at: aName ifAbsent: [aName].		newCls _ Smalltalk at: newName 				ifAbsent: [self error: 'UniClass definition missing'].		(trans == 1 and: [newCls inheritsFrom: Player]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList _ rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		newCls class instSize = (normal+(rList size)-1) ifFalse: [			self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		2 to: rList size do: [:ii |			newCls instVarAt: normal+ii-1 put: (rList at: ii)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:28'!saveClassInstVars	"Install the values of the instance variables of UniClasses.  classInstVars is an array of arrays (#Player3 (Player3 class's inst var scripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	self uniClasesDo: [:aUniClass | 		mySize _ aUniClass class instSize.		mySize = normal ifFalse: [			list _ OrderedCollection new.			list add: aUniClass name.	"a symbol"			normal+1 to: mySize do: [:ii | 				list addLast: (aUniClass instVarAt: ii)]].		classInstVars add: list asArray].	classInstVars _ classInstVars asArray.	! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:02'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream reading: true.	ScannedObject _ self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:56'!setStream: aStream reading: isReading	"Initialize me. "	super setStream: aStream reading: isReading.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new].		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:32'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class." | uniClasses normal more aUniClass mySize |"Any classes used in the structure of classInstVars must be written out also!!	dummy nextPut: (OrderedCollection new).But for now, only uses Arrays."uniClasses _ Set new.normal _ Object class instSize.more _ true.[more] whileTrue: [	more _ false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass _ each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize _ aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more _ true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 06:44'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ self new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 19:18'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	Socket initializeNetwork.	^ super new initialize! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount _ self monoSampleCount.	bytes _ ByteArray new: 2 * sampleCount.	dst _ 0.	1 to: sampleCount do: [:src |		s _ self at: src.		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 8/15/1998 14:35'!fromByteArray: aByteArray	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."	| n buf src w |	n _ aByteArray size // 2.	buf _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		w _ ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).		w > 32767 ifTrue: [w _ w - 65536].		buf at: i put: w.		src _ src + 2].	^ buf! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 9/11/1998 15:34'!initialize	"SoundPlayer initialize"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothing, especially during other activities. If it is too high, there will be an overly long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. It is typically in the range 50-200."	"SoundPlayer initialize; shutDown; startUp"	SamplingRate _ 22050.	BufferMSecs _ 100.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 18:02'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences disableSounds ifTrue: [^ self].	doQuickStart _ quickStart.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 8/19/1998 08:11'!startReverb	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:32'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordLevel _ 0.5.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel _ (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 7/4/1998 14:35'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 13:37'!convertssrrbpmmscn0: varDict ssrrrbpmmscn0: smartRefStrm	"These variables are automatically stored into the new instance ('stereo' 'samplingRate' 'recordedBuffers' 'recordProcess' 'bufferAvailableSema' 'paused' 'meteringBuffer' 'meterLevel' 'soundPlaying' 'currentBuffer' 'nextIndex' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('recordLevel' ) and deal with the information in ()"! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!comment	comment ifNil: [^ ''] ifNotNil: [^ comment].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!comment: aString	aString isEmpty		ifTrue: [comment _ nil]		ifFalse: [comment _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:45'!contentsMorph	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 12:41'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds].	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	self updateThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 17:45'!thumbnail	^ thumbnail! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!title	title ifNil: [^ ''] ifNotNil: [^ title].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!title: aString	aString isEmpty		ifTrue: [title _ nil]		ifFalse: [title _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url	url ifNil: [^ ''] ifNotNil: [^ url].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url: aString	aString isEmpty		ifTrue: [url _ nil]		ifFalse: [url _ aString].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/25/1998 12:14'!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].	WebBookMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/18/1998 11:31'!updateThumbnail	"Update my thumbnail from my morph."	| f scale scaleX scaleY shrunkF |	contentsMorph ifNil: [thumbnail _ nil. ^ self].	f _ contentsMorph imageForm.	scaleX _ MaxThumbnailWidthOrHeight asFloat / f height.	scaleY _ MaxThumbnailWidthOrHeight asFloat/ f width.	scale _ scaleX min: scaleY.  "choose scale that maintains aspect ratio"	shrunkF _ (f magnify: f boundingBox by: scale@scale smoothing: 2).	thumbnail _ Form extent: shrunkF extent depth: 8.  "force depth to be 8"	shrunkF displayOn: thumbnail.	contentsMorph allMorphsDo: [:m | m releaseCachedState].! !!SqueakPage class methodsFor: 'all' stamp: 'jm 6/18/1998 11:15'!initialize	"SqueakPage initialize"	MaxThumbnailWidthOrHeight _ 60.! !!SqueakPage class methodsFor: 'all' stamp: 'sw 7/6/1998 11:49'!newURLAndPageFor: aMorph	"Create a new SqueakPage whose contents is the given morph. Assign a URL for that page, record it in the page cache, and answer its URL."	| pg newURL stamp |	pg _ self new.	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: aMorph author: stamp.	newURL _ SqueakPageCache generateURL.	SqueakPageCache atURL: newURL put: pg.	^ newURL ! !A global cache of web pages known to this Squeak image. All pages currently live only in memory; management of pages stored on servers and the local disk will be added later.Since there is a single, global page cache, it is implemented entirely as class methods.!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'jm 6/16/1998 18:12'!initialize	"SqueakPageCache initialize"	(PageCache notNil and: [PageCache size > 0]) ifTrue: [		(self confirm: 'Are you certain that you wish to delete all SqueakPages?')			ifFalse: [^ self]].	NextURL _ 1.	PageCache _ Dictionary new: 100.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:06'!allURLs	"Answer a collection of URLs for all pages in the cache."	^ PageCache keys! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString		ifAbsent: [self error: 'no page with the given URL in the cache']! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 15:39'!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString ifAbsent: failBlock! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:08'!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| url |	NextURL ifNil: [NextURL _ 1].	NextURL _ NextURL + 1.	url _ 'memoryPage', NextURL printString.	[PageCache includesKey: url] whileTrue: [		NextURL _ NextURL + 1.		url _ 'memoryPage', NextURL printString].	^ url! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 18:12'!removeURL: aURLString	"Remove the cache entry for the given URL. Do nothing if it has no cache entry."	PageCache removeKey: aURLString ifAbsent: [].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 11:11'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		WebBookMorph allInstancesDo: [:book |			book urls do: [:url | unreferenced remove: url ifAbsent: []]].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 13:00'!releaseCachedStateOfPages	"Note: This shouldn't be necessary if we are doing a good job of releasing cached state as we go. If running this doesn't do very much, we're doing well!!"	"SqueakPageCache releaseCachedStateOfPages"	| memBytes |	memBytes _ Smalltalk garbageCollect.	PageCache do: [:pg |		pg contentsMorph allMorphsDo: [:m | m releaseCachedState]].	^ (Smalltalk garbageCollect - memBytes) printString, ' bytes recovered'! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:05'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:01'!closed	"Answer true if this file is closed."	^ fileID isNil! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:41'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	fileID _ self primOpen: fileName writable: writeMode.	fileID ifNil: [^ nil].  "allows sender to detect failure"	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readWrite	"Make this file writable."	rwmode _ true.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 14:11'!next	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:56'!verbatim: aString	"A version of nextPutAll that can be called knowing it won't call nextPut: "	^ self nextPutAll: aString! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 150>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primClose: id	"Close this file."	<primitive: 151>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:04'!primGetPosition: id	"Get this files current position."	<primitive: 152>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:06'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 154>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 155>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSize: id	"Answer the size of this file."	<primitive: 157>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 157>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 158>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:13'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| dir localName choice newName |	(self isAFileNamed: fileName)		ifFalse: [^ self new open: fileName forWrite: true].	"file already exists:"	dir _ FileDirectory forFileName: fileName.	localName _ FileDirectory localNameFor: fileName.	choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fileName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: fileName.		^ self newFileNamed: newName].	self error: 'Please close this to abort file opening'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:16'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:19'!readOnlyFileNamed: fileName	"Open an existing file with the given name for reading."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/29/1998 18:02'!frozenPlayfieldBorderColor	^ Color red! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/30/1998 09:50'!runningPlayfieldBorderColor	^ Color green! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 9/14/1998 14:41'!statusColorSymbolFor: statusSymbol	#(	(normal					green)		(ticking					blue)		(paused					red)		(mouseDown				yellow)		(mouseStillDown			lightYellow)		(mouseUp				lightBlue)		(mouseEnter				lightBrown)		(mouseLeave			lightRed)		(mouseEnterDragging	lightGray)		(mouseLeaveDragging	darkGray)		(keyStroke				lightGreen)) do:			[:pair | statusSymbol == pair first ifTrue: [^ pair second]].		^ #blue! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 7/4/1998 14:36'!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	self formDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 9/10/1998 14:23'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(colorSees		boolean'Whether any part of thisobject is over the specified color')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(objectNameInHalo  control'Object''s name -- To change:click here; backspace over old name,type in new name; hit ENTER')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:13'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:09'!guessDOLProxy	"Decide if we need to go through the DOL proxy server to reach the EToy servers, and set the HTTPSocket proxy server appropriately."	| addr s |	Socket initializeNetwork.	"try several times with increasing timeout values"	#(10 20 40 80) do: [:seconds |		"can we see the DOL proxy server?"		addr _ NetNameResolver addressForName: 'web-proxy.online.disney.com' timeout: seconds.		addr ifNotNil: [			HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.			^ self].		"can we connect to an EToy server?"		self serverUrls do: [:serverName |			addr _ NetNameResolver addressForName: (serverName copyUpTo: $/) timeout: seconds.			addr ifNotNil: [				s _ HTTPSocket new.				s connectTo: addr port: 80.				s waitForConnectionUntil: (Socket deadlineSecs: seconds).				s isConnected ifTrue: [					s destroy.					HTTPSocket stopUsingProxyServer.					^ self].				s destroy]]]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'di 9/16/1998 00:38'!prepareForExternalReleaseNamed: aReleaseName	"ScriptingSystem prepareForExternalReleaseNamed: '2.2Beta'"	EToySystem stripMethodsForExternalRelease.	self class compile: 'guessDOLProxy	"deleted for external release"' classified: 'stripped'.	ScriptingSystem saveFormsToFileNamed: aReleaseName, '.Dis.Forms'.	ScriptingSystem stripGraphicsForExternalRelease.	ScriptingSystem cleanupsForRelease.	ScreenController initialize.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 6/25/1998 12:29'!reasonablePaintingExtent	"Answer a reasonable maximum extent for the painting area when the user paints a new objects or repaints an old one.  Temporarily made large here in order *not* to apply any restraint, as per current sentiment"	^  1800 @ 1800! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:14'!serverUrls	"Private to Disney; stripped before external release"	| list |	list _  #('doltest1.disney.com/squeak/'	'www.webpage.com/~kaehler2/').	(list includes: Socket deadServer) ifTrue: [		list _ list asOrderedCollection.		list remove: Socket deadServer ifAbsent: [].		list addLast: Socket deadServer].	^ list asArray! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/14/1998 14:39'!standardEventStati	^ #(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging keyStroke)! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:12'!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	| aDict replacement |	aDict _ ScriptingSystem formDictionary.	replacement _ aDict at: 'Gets'.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | aDict at: aKey put: replacement]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/10/1998 14:42'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(stopScript				'stop script')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(stopScript:				'stop script')		(startScript:				'start script')		(pauseScript:			'pause script')		(max:					'max')		(min:					'min')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(clearTurtleTrails		'clear pen trails')		(seesColor:				'is over color')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:10'!initializePartsBin	"ScriptingSystem initializePartsBin"	PartsBin _ Presenter new newStandardPartsBin! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:09'!partsBin	PartsBin ifNil: [self initializePartsBin].	^ PartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:36'!setPartsBinFrom: aMorph	PartsBin _ aMorph! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:23'!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	self initializeSystemSlotDictionary.	self new initializeHelpStrings! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:21'!initializeSystemSlotDictionary	"StandardScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(seesColor		boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 6/10/1998 15:10'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view topView isCollapsed ifFalse: [model modelWakeUp].! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:42'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]. ].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'framing' stamp: 'tk 8/11/1998 16:22'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUp]! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 11:40'!print: anObject	anObject printOn: self! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 17:13'!printHtml: anObject	anObject printHtmlOn: self! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:46'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| eval |	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	emphasis > 0 ifTrue: [self error: 'Synthietic fonts do not get written out. Proceed for plain font.'].	eval _ 'StrikeFont familyName: #', self name ,' size: ', self height printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval).! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:49'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $)! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 9/20/1998 10:35'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'copying' stamp: 'tk 8/19/1998 16:15'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 7/2/1998 16:44'!familyName: aName size: aSize	| aStyle both ind |	(aStyle _ TextStyle named: aName asSymbol) ifNil: [		both _ aName splitInteger.		(both at: 2) > 0 			ifTrue: ["old style"				ind _ #('ComicB' 'Comic' 'ComicAll') indexOf: (both at: 1).				ind = 0 ifTrue: [^ self familyName: (both at: 1) size: aSize].				aStyle _ TextConstants at: (#(ComicBold ComicPlain ComicPlain) at: ind)]			ifFalse: [aStyle _ TextStyle default]].	"Substitute. Read-only so OK not to copy"	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'examples' stamp: 'tk 6/26/1998 15:19'!update	"A temporary method to change the names of StrikeFonts.  New convention is that each StrikeFont is in a TextStyle that has only fonts of the same name (family).  The name of that TextStyle in TextConstants is the same name as the family name of this font.  Sizes are no longer in the name of the font."	"StrikeFont update"| sty |TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		"Transcript show: assoc key; space."		sty _ assoc value.		sty fontArray do: [:font | font name: assoc key]		]]].TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		sty _ assoc value.		sty fontArray do: [:font | 			(StrikeFont familyName: font name size: font height) == font ifFalse: [				self error: 'not same']]]]].! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'tk 6/21/1998 11:41'!atPin: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  "	<primitive: 63>	^(super atWrap: index) asCharacter! !!String methodsFor: 'accessing' stamp: 'tk 8/31/1998 17:42'!findInsensitive: subStringLowercase allUpper: subStringUppercase	"Answer the index of subString within the receiver case insensitive. If the receiver does not contain subString, answer 0.  subStringLowercase and subStringUppercase must be identical except one is all lowercase and the other is all uppercase.  (pass these in so don't have to generate them every time when searching all symbols)  Caller must test for subStringLowercase being empty."	| index firstLo firstHi |	firstLo _ subStringLowercase first.	firstHi _ subStringUppercase first.	1 to: self size - subStringLowercase size + 1 do:		[:startIndex |		((self at: startIndex) = firstLo or: [(self at: startIndex) = firstHi]) ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (subStringLowercase at: index) or:				[(self at: startIndex+index-1) = (subStringUppercase at: index)]]					whileTrue:					[index = subStringLowercase size ifTrue: [^startIndex].					index _ index+1]]].	^ 0! !!String methodsFor: 'accessing' stamp: 'ls 8/17/1998 23:28'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	ans _ String indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:20'!indexOfAnyOf: aCharacterSet	"returns the index of the first character in the given set.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  ifAbsent: aBlock	"returns the index of the first character in the given set.  Returns the evaluation of aBlock if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1  ifAbsent: aBlock! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  startingAt: start	"returns the index of the first character in the given set, starting from start.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: start  ifAbsent: [ 0 ]! !!String methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:27'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ String findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'ls 9/10/1998 22:27'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start _ 1.	[ start <= self size ] whileTrue: [		end _ self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2. ].! !!String methodsFor: 'comparing' stamp: 'di 9/14/1998 16:29'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString species == String ifFalse: [^ false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 9/20/1998 14:33'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'converting' stamp: 'ls 9/5/1998 01:19'!asIRCLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase, where 'lowercase' is by IRC's definition"	^self collect: [ :c | c asIRCLowercase ]! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:33'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^self copy asString translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 6/29/1998 00:35'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: 'converting' stamp: 'ls 7/15/1998 18:40'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'converting' stamp: 'tk 7/2/1998 16:32'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.  '43Sam' yields #(43 'Sam').  'Try90' yields #('Try' 90) "	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 			with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 10:31'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	String translate: self  from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'ls 8/18/1998 07:44'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:30'!translateWith: table	"translate the characters in the string by the given table, in place"	^self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location	aPoint on aDisplayMedium."	(self asDisplayText foregroundColor: Color black backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'sw 7/3/1998 18:31'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!String methodsFor: 'internet' stamp: 'ls 9/15/1998 02:47'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size + 1 ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                               specialValue _ String valueOfHtmlEntity: special.                         specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"								  scIndex > self size ifTrue: [ scIndex _ self size ].                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !!String methodsFor: 'internet' stamp: 'ls 7/22/1998 22:19'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| inStream ans c tok asciiVal |	inStream _ ReadStream on: self.	ans _ WriteStream on: String new.	[ c _ inStream next.  c = nil ] whileFalse: [ 		c = $+ ifTrue: [ ans nextPut: $ ] ifFalse: [			(c = $%) ifTrue: [				tok _ inStream next: 2.				asciiVal _ Integer readFrom: (ReadStream on: tok) base: 16.				ans nextPut: (Character value: asciiVal). ]			ifFalse: [				ans nextPut: c ] ] ].	^ans contents ! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:16'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are allvalid line endings.  Replace each occurence with a single CR"	| cr lf input c |	cr _ Character cr.	lf _ Character linefeed.	^String streamContents: [ :str |		input _ ReadStream on: self.		[input atEnd] whileFalse: [			c _ input next.			c == cr ifTrue: [				str cr.				input peek == lf ifTrue: [ input next ] ]			ifFalse: [				c == lf ifTrue: [ str cr ] ifFalse: [ strnextPut: c ] ] ] ]! !!String methodsFor: 'internet' stamp: 'ls 7/1/1998 02:26'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote _ self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'initialization' stamp: 'di 9/20/1998 14:09'!initialize  "String initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String new: 256.	Character allCharacters do: [ :c |		LowercasingTable at: (c asciiValue+1) put: c asLowercase ].		"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!String class methodsFor: 'primitives' stamp: 'ls 9/14/1998 07:50'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 244>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i _ start.	stringSize _ aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i _ i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!String class methodsFor: 'primitives' stamp: 'ls 8/17/1998 23:26'!indexOfAscii: num inString: aString  startingAt: start	|  stringSize |	<primitive: 245>	self var: #aCharacter  declareC: 'int num'.	self var: #aString declareC: 'char *aString'.	stringSize _ aString size.	start to: stringSize do: [ :pos |		(aString at: pos) asciiValue = num ifTrue: [ ^pos ] ].	^0.! !!String class methodsFor: 'primitives' stamp: 'ls 8/15/1998 12:15'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 243>	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned char *aString'.	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!String class methodsFor: 'internet' stamp: 'ls 8/15/1998 20:22'!valueOfHtmlEntity: specialEntity	specialEntity = 'quot' ifTrue: [ ^$" ].	specialEntity = 'lt' ifTrue: [ ^$< ].	specialEntity = 'amp' ifTrue: [ ^$& ].	specialEntity = 'gt' ifTrue: [ ^ $>].	specialEntity = 'nbsp' ifTrue: [ ^ Character nbsp ].	(specialEntity beginsWith: '#') ifTrue: [		^Character value: (specialEntity copyFrom: 2 to: specialEntity size) asNumber ].	^nil ! !!StringHolder methodsFor: 'initialize-release' stamp: 'di 5/27/1998 21:21'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 8/4/1998 18:21'!openAsMorphLabel: labelString  inWorld: aWorld	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld: aWorld! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| shiftMenu |	^ shifted 	ifFalse: [aMenu 		labels: PluggableTextController yellowButtonMenu labelString 		lines: PluggableTextController yellowButtonMenu lineArray		selections: PluggableTextController yellowButtonMessages]	ifTrue: [shiftMenu _ PluggableTextController shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: PluggableTextController shiftedYellowButtonMessages]! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/14/1998 06:51'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[ParagraphEditor new clipboardTextPut: selector asString asText]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/8/1998 13:25'!messageListSelectorTitle	| selector aString aStamp |	Preferences showTimeStampsInMenuTitles		ifFalse:			[^ nil].	(selector _ self selectedMessageName) ifNotNil:		[aString _ selector truncateWithElipsisTo: 28.		^ (aStamp _ self timeStamp) size > 0			ifTrue:				[aString, String cr, aStamp]			ifFalse:				[aString]].	^ nil! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:51'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:46'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/18/1998 12:16'!timeStamp	| class selector recordList |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		(recordList _ class changeRecordsAt: selector) size > 0			ifTrue:				[^ recordList first stamp]].	^ nil! !!StringMorph methodsFor: 'initialization' stamp: 'sw 6/15/1998 15:34'!addOptionalHandlesTo: aHalo box: box	self flag: #deferred.	"Eventually...	self addFontHandlesTo: aHalo box: box"! !!StringMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 18:03'!valueAsConstant	^ self contents! !SwikiAction is the action to implement a Swiki, a collaborative website.This is a web server in Squeak.  Each page served has an "Edit this Page"link.  The syntax rules for editing pages (from any web browser) are in thefile FormattingRules.The pages may be viewed from any web browser, and the URL ishttp://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swikiarea.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an examplefocused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by WardCunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or theSqueak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do notsnapshot the image during normal server operation.  Restart the server byloading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of thefolder is the name of the Wiki.  Each page is a file.  (Inefficient on Macsbecause of large minimum page size, but that's an OS problem.)  Allversions of all pages are kept.  Each page contains chunks, just like achanges file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text:'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytesfrom the start of the chunk to just in front of the number.  This allowsback-chaining to old versions.  On startup, the chunk is executedexplicitly using evaluate:for:logged:.  It supplies the page name to aSwikiPage and installs it in the URLmap.  By doing this for all files inthe folder, the map (url->page) is built.  During operation, the chunk isnot executed.  Instead, take the file directly, look at 'back:' at the end,jump back to the start of the chunk, scan for 'text:' and read the text.The looks of the pages served are controlled by templates.  They live inthe 'swiki' folder in the 'Server' folder.  See page.html for how to changethe look of a served page.  Beware that templates are cached byHTMLformatter.  If you change a template, you will not see the effect untilyou reload the Swiki.A symbol *append here* may be added anywhere in the page.  Clicking on itwill bring up a page with a text editing form.  The what you type will beinserted just before the *append here* marker.  This allows append-onlypages, or multiple questions with places to add to the answer.!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter	^formatter! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter: anHTMLformatter	formatter _ anHTMLformatter! !!SwikiAction methodsFor: 'accessing' stamp: 'TPR 7/21/1998 18:06'!url	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'save and restore' stamp: 'ls 7/27/1998 23:26'!fixAllLineEndings	"for each page in the swiki, fixes line endings to be CR only.This is used to bring older Swikis up to date with the newer convention.If a page has no LF's, then it is left alone"	| origText newText pagesDone |	pagesDone _ 0.	'updating pages...' displayProgressAt: Sensor cursorPoint from: 0to: urlmap pages size during: [ :bar |		urlmap pages do: [ :page |			origText _ page text.			newText _ origText withSqueakLineEndings.			origText = newText ifFalse: [ page text: newText ].			pagesDone _ pagesDone + 1.			bar value: pagesDone. ] ]! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 8/28/1998 21:05'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct theurl map."	| map page folder dir rep templateFolder |	map _ URLmap new.	self map: map.	self formatter: (HTMLformatter new initialize).	self formatter specialCharacter: $*.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,(ServerActionpathSeparator),fName action: self.			(page time isNil) ifTrue: [page time: Time now].			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/28/1998 20:59'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'page') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''page.html'' not found'].	request reply: htmlForUser.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/1998 15:32'!edit: pageRef from: request	request reply: (HTMLformatter evalEmbedded:							(self fileContents:source , 'edit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:31'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit""	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store textin a specific place	{swikiname}.searchresult  {with a field named 'searchFor'} conducts thesearch for that text and sends back the result"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			((self formatterFor: 'recent') format: (urlmapsearchFor:						(request fields at:'searchFor' ifAbsent:['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/7/1998 00:55'!pageURL: aPage	"make the URL suited to aPage in this Action"	^(self name),'.',aPage coreID! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 9/16/1998 15:58'!process: request	"URLs are of the form:	{swikiname} 		browse Front Page	{swikiname}.{coreID} browse the page number coreID	{swikiname}.{coreID}.edit  request to edit the page	{swikiname}.{coreID}.versions show the last three versions of the page	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in aspecific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  storetext in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper orlower case) return	the picture or static page stored in the {swikiname} folder."	| coreRef pageRef command formattedPage theLast pvtPageRef htmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success;		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].			command = 'insert' ifTrue:					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (request message at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor: 'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file ''insert.html'' not found'].					request reply: htmlForUser.					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue:					[request reply: ((self formatterFor: 'results')						format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue:					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			(request message at: 1) = (request message at: 2) ifTrue: [				request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.				request message: (request message copyFrom: 2 to: request message size).				^ self process: request].	"(success and contentHTML will be sent twice!!)"			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 4/18/98 18:09'!smtlk: request	"Return Smalltalk sourcecode.  URL =machine:80/myswiki.smtlk.Point|at;  included are:  Point|at:Point|Comment   Point|Hierarchy  Point|Definition   Point|class|x;y;  NOTE:use ; instead of : in selector names!!!!!!"	| classAndMethod set |	classAndMethod _ request message atPin: 3.	classAndMethod _classAndMethod copyReplaceAll: '|' with: ' '.	classAndMethod _classAndMethod copyReplaceAll: ';' with: ':'.	set _ LinkedMessageSetmessageList: (Array with: classAndMethod).	request reply: PWS crlf,((self formatterFor: 'smtlk') format: set).! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/5/98 17:20'!clearFormatterCache	"remove all formatters"	formatters _ nil.! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/7/98 22:04'!formatterFor: formatterName	"get the formatter for the given name.uses lazy initialization.  Could eventually check whether the on-disk filehas been updated."	| fileName fileModTime |		"first,create the dictionary of formatters if it isn't already"	formatters== nil ifTrue: [		formatters _ Dictionary new. ].	"get the filename for the template source"	fileName _formatterName, '.html'.	"get its modification time"	fileModTime_ ((FileDirectory on: ServerAction serverDirectory, source) entryAt:fileName) at: 3.	"create the formatter if necessary"	((formatters includesKey: formatterName) not or: [	((formatters at: formatterName) at: 2) < fileModTime ])	ifTrue: [		Transcript show: '(recompiling formatter ',formatterName, ')'; cr.		formatters at: formatterName put:(Array with:			(HTMLformatter forEvaluatingEmbedded: (selffileContents: (source, formatterName, '.html')))	with: fileModTime)	].	"return the formatter"	^(formatters at: formatterName) at: 1! !!SwikiAction class methodsFor: 'initialization' stamp: 'BJP 9/9/1998 21:41'!setUp: actionName	"Set up a named Swiki"	| action map page dir |	action _ self new.	map _ self mapClass new.	"URLmap or PURLmap"	action formatter: (HTMLformatter new initialize).	action formatter specialCharacter: $*.	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName.	dir _ FileDirectory on: (ServerAction serverDirectory).	(dir directoryNames includes: actionName) ifFalse: [		^ self inform: 'You need to create a folder in Server called ',actionName].		"A directory in the ServerDirectory for storing pages."	page _ map newpage: actionName,': Front Page' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage')contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules')contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.	^action! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 21:32'!by	| who |	who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].	^who.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/10/1998 15:26'!by: who	self address: who.! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:34'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."		(anObject isKindOf: String)			ifTrue: [date _ anObject asDate]			ifFalse: [date := anObject]! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/1/1998 09:58'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject.	^''! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/10/1998 14:14'!outputFormat	^self class outputFormat! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 19:41'!pageStatus	"The basic stati ;) are #new and #standard. If the pageStatus is nil,we make make the page #standard, as that is the old behavior. You could addother types to get e.g., different kinds of URLs, or to exclude pages froma search, or alter the formatter, or..."	pageStatus ifNil: [pageStatus _ #standard].	^pageStatus! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 13:55'!pageStatus: aSymbol	"While I'm trying to be careful about default behavior if the type isunknown, one should still be careful to check all the places that pageTypeis used."	pageStatus _ aSymbol.! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	^ temp! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID: idNum	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	temp _ idNum! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/13/1998 12:37'!text: aString	"Add onto the end of the file"	| this aFile start end realString |	realString _ self uniqueInsertionPoints: aString.	this _ String streamContents: [:ss |		ss nextPutAll: self chunk1.		realString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:37'!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	steps timesRepeat: [bb _ self backupAChunk: theFile.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Removedouble !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 19:41'!time	"Answer the receiver's 'time'."	^time! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:29'!time: anObject	"Set the receiver's instance variable 'time' to be anObject."	(anObject isKindOf: String)		ifTrue: [time _ anObject asTime]		ifFalse: [time := anObject]! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:36'!backupAChunk: aFile	"We are positioned at the end of a chunk.  Read the size of thischunk from its end.  Back up one chunk.  Return the position of the spacebefore the back number."	| back pp aPiece isDigitFlag |	aFile skip: -2.	isDigitFlag _ false.	[isDigitFlag] whileFalse:	[aPiece := aFile next. aPiece isNil ifTrue: [^0].	aPiece isDigit ifFalse: [aFile skip: -2] ifTrue: [isDigitFlag _true].].	"[aFile next isDigit] whileFalse: [aFile skip: -2]." "This wasTed's elegant version.									Theuglier one above is to be able to test backing up too far."	aFile skip: -2.	[pp _ aFile position + 1. aFile next isDigit] whileTrue: [		aFile skip: -2].	back  _ (aFile upTo: $!!) asNumber.	aFile position: pp; skip: 0-back.	^ pp "now positioned at the end"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/7/1998 11:30'!chunk1	^self formatForOutput	"| who |	^ String streamContents: [:ss |		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  time print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/10/1998 14:16'!formatForOutput	^ String streamContents: [:ss |		ss nextPutAll: 'self '.		self outputFormat do: [:block |							ss nextPutAll:(block value: self)					"ifError: [:msg :rec |							 ss nextPutAll:'*** ', rec asString, ': ', msgasString ]"].		ss nextPutAll: 'text: ']."		   nextPutAll: name printString;		   nextPutAll: ' date: ''';		   nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.		     Time now print24: true on: ss.		who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: ';		   nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:15'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	self scanFrom: theFile.	"name, date"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 19:43'!name: pageName date: dateString time: timeString by: who text: theStringback: bytes	"Record the name of this page during startup.  When reading thepage in order to serve it, this is NOT executed.  The text is read from thefile explicitly."	name _ pageName.	date _ dateString asDate.	time _ timeString asTime.	address _ who! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/8/1998 18:08'!text: theString back: bytes	"Record the name of this page during startup.  When reading the page inorder to serve it, this is NOT executed.  The text is read from the fileexplicitly.""Which means that you'd better not cascade text & back or you're royallyscrewed ;) BJP"! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/13/1998 13:33'!unique: aTag in: aSet	"If aTag is not in aSet, put it in and return aTag.  If it's there,make up a new tag, insert it, and return it.  For keeping insertion pointsin text unique, so can tell where to put incoming text."	| base new |	((aSet includes: aTag) not and: [aTag size > 0]) ifTrue: [aSet add:aTag.  ^ aTag].	base _ 0.	[new _ (100 atRandom + base) printString.		aSet includes: new] whileTrue:			[base _ base + 50].	aSet add: new.	^ new! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/14/1998 20:52'!uniqueInsertionPoints: aString	"Find all occurances of '*append here'.  Make them lower case.  Ifthey don't have a number after them, assign one.  Don't use the same numbertwice in this page.  Place ID can actually be any string."| sourceStream targetStream ids char pos inside rest |sourceStream := ReadStream on: aString.targetStream := WriteStream on: String new.ids _ Set new.	"id numbers that have been used"[sourceStream atEnd	] whileFalse: [	targetStream nextPut: (char _ sourceStream next).	char == $* ifTrue: [		pos _ sourceStream position.		inside _ sourceStream upTo: $*.		(inside asLowercase beginsWith: 'append here')			ifFalse: [sourceStream position: pos.	"ignore"				((inside = '') and: [sourceStream atEndnot]) ifTrue: [					targetStream nextPut: (char _sourceStream next)]]	"Honor **"			ifTrue: ["See if it has a number"				targetStream nextPutAll: 'append here '.				rest _ inside copyFrom: (13 min: insidesize +1) to: inside size.				targetStream nextPutAll: (self unique: restin: ids); nextPut: $*]]].^ targetStream contents! !!SwikiPage class methodsFor: 'initialization' stamp: 'BJP 9/7/1998 12:23'!initialize	"SwikiPage initialize"	OutputFormat _ OrderedCollection new.	OutputFormat		add: [:thePage | 'name: ', thePage name printString, '; '];		add: [:thePage | 'date: ', thePage date mmddyyyyprintString, '; '];		add: [:thePage | 'time: ''', thePage time asString, '''; '];		add: [:thePage | 'by: ', thePage by printString, '; '];		add: [:thePage | 'pageStatus: #', thePage pageStatus, '; ']";		add: [:thePage | 'text: ']."! !!SwikiPage class methodsFor: 'accessing' stamp: 'BJP 9/7/1998 11:32'!outputFormat	^OutputFormat! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Symbol class methodsFor: 'access' stamp: 'tk 8/11/1998 22:12'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString list binary |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	list _ lookupString correctAgainst: table.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | list addFirst: him]].	^ list! !!Symbol class methodsFor: 'access' stamp: 'tk 8/31/1998 17:48'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive."	| size table candidate selectorList selectorTable keyLo keyHi |	keyLo _ aString asLowercase.	keyHi _ aString asUppercase.	selectorList _ OrderedCollection new.	keyLo size = 0 ifTrue: [^ selectorList].	"this test is necessary!!"	size _ keyLo size.	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate findInsensitive: keyLo 						allUpper: keyHi) > 0) ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon'    "! !!SyntaxError methodsFor: 'other' stamp: 'di 8/17/1998 10:28'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	(class compile: aString classified: category notifying: aController)		ifNil: [^ false]		ifNotNil: [aController hasUnacceptedEdits: false.  self proceed].! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:22'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph on: aSyntaxError list: #list			selected: #listIndex changeSelected: nil menu: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph on: aSyntaxError text: #contents			accept: #contents:notifying: readSelection: #contentsSelection			menu: #codePaneMenu:shifted:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:10'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	World ifNotNil:		[self buildMorphicViewOn: aSyntaxError.		Project current spawnNewProcess.		^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/5/1998 18:41'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	SystemChanges isEmpty ifTrue: [^ self inform: 'There are no changed messagesin the current change set.'].	ChangedMessageSet openFor: SystemChanges! !!SystemDictionary methodsFor: 'browsing' stamp: 'jm 5/29/1998 14:30'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-sensitive, unless the shift key is pressed, in which case the search is case-insensitive (and consequently somewhat slower)."	| caseBlind testString suffix |	(caseBlind _ Sensor controlKeyPressed)		ifTrue:			[testString _ aString asLowercase.			suffix _ ' (case-blind)']		ifFalse:			[testString _ aString.			suffix _ ' (case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: testString caseSensitive: caseBlind not]]]		name:  'Methods with string ''', aString, '''', suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 8/11/1998 13:23'!removeClassFromSystemUnlogged: aClass	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	SystemOrganization removeElement: aClass name.	self removeKey: aClass name.	self flushClassNameCache! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 13:00'!discardMorphic	"Discard Morphic."	| subs |	subs _ OrderedCollection new.	Morph allSubclassesWithLevelDo: [:c :i | subs addFirst: c]		startingLevel: 0.	subs do: [:c | c removeFromSystem].	SystemOrganization removeCategoriesMatching: 'User Objects'.	SystemOrganization removeCategoriesMatching: 'Experimental-'.	SystemOrganization removeCategoriesMatching: 'Morphic-*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 14:59'!discardNetworking	"Discard the support for TCP/IP networking."	Smalltalk discardPluggableWebServer.	SystemOrganization removeCategoriesMatching: 'HTML-*'.	SystemOrganization removeCategoriesMatching: 'NetTools-*'.	SystemOrganization removeCategoriesMatching: 'Network-*'.	SystemOrganization removeCategoriesMatching: 'System-Network'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 13:27'!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	Smalltalk at: #FormEditor ifPresent: [:c | c removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk at: #SampledSound ifPresent: [:c |		(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [c initialize]].	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 11:55'!discardSoundSynthesis	"Discard the sound synthesis facilities, and the methods and classes that use it. This also discards MIDI."	Smalltalk discardMIDI.	Smalltalk removeClassNamed: #EnvelopeLineMorph.	Smalltalk removeClassNamed: #EnvelopeEditorMorph.	Smalltalk removeClassNamed: #PianoKeyboardMorph.	Smalltalk removeClassNamed: #WaveEditor.	Smalltalk removeClassNamed: #SoundSequencerMorph.	Smalltalk removeClassNamed: #SoundMorph.	Smalltalk removeClassNamed: #SoundLoopMorph.	Smalltalk removeClassNamed: #InterimSoundMorph.	Smalltalk removeClassNamed: #RecordingControlsMorph.	Smalltalk removeClassNamed: #PermanentRecordingControlsMorph.	Smalltalk removeClassNamed: #SoundDemoMorph.	Smalltalk at: #GraphMorph ifPresent: [:graphMorph |		#(loadCoffeeCupClink play playBach playOnce		  readDataFromFile registerWaveform stopPlaying)			do: [:sel | graphMorph removeSelector: sel]].	Smalltalk at: #TrashCanMorph ifPresent: [:trashMorph |		trashMorph class removeSelector: #samplesForDelete.		trashMorph class removeSelector: #samplesForMouseEnter.		trashMorph class removeSelector: #samplesForMouseLeave].	SystemOrganization removeCategoriesMatching: 'System-Sound'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 13:50'!discardVMConstruction	"Discard the virtual machine construction classes and the Smalltalk-to-C translator. These are only needed by those wishing to build or study the Squeak virtual machine, or by those wishing to construct new primitives via Smalltalk-to-C translation."	"remove the code for virtual machines"	Smalltalk removeKey: #InterpreterLog ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Squeak-Jitter'.	SystemOrganization removeCategoriesMatching: 'Squeak-Interpreter'.	"remove the Smalltalk-to-C translator"	Smalltalk at: #CCodeGenerator ifPresent: [:codeGen | codeGen removeCompilerMethods].	SystemOrganization removeCategoriesMatching: 'Squeak-Translation to C'.	Smalltalk removeClassNamed: #SystemTracer.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 15:38'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around ?? in size."Smalltalk discardVMConstruction.  "663k"Smalltalk discardSoundSynthesis.  "330k"Smalltalk discardOddsAndEnds.  "228k"Smalltalk discardNetworking.  "261k"Smalltalk discardMorphic.  "2,231k""Above altogether saves 3,541k"	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete lots of classes.."	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'System-Object Storage'.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	RemoteString removeSelector: #makeNewTextAttVersion.	Utilities class removeSelector: #absorbUpdatesFromServer.	Smalltalk removeClassNamed: #PenPointRecorder.	Smalltalk removeClassNamed: #Path.	Smalltalk removeClassNamed: #Base64MimeConverter.	Smalltalk removeClassNamed: #EToySystem.	Smalltalk removeClassNamed: #RWBinaryOrTextStream.	Smalltalk removeClassNamed: #AttributedTextStream.	TextStyle allInstancesDo:		[:ts | ts newFontArray: (ts fontArray copyFrom: 1 to: 2)].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 15:46'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(printSpaceAnalysis		dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 6/17/1998 13:16'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Project current interruptName: 'Space is low'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 9/23/1998 16:49'!version	"Answer the version of this release."	^ 'Squeak 2.2 of Sept 23, 1998'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'tk 9/22/1998 23:15'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #MailDB ifPresent: [:mailDB |		mailDB allInstancesDo: [:db | db saveDB]].  "snapshot all mail databases to disk"	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	Smalltalk at: #HttpUrl ifPresent: [:urlClass | urlClass shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sw 8/22/1998 22:41'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'TPR 5/10/1998 21:33'!saveAs	| dir newName newImageName newChangesName |	dir _ FileDirectory default.	newName _ (FillInTheBlank		request: 'New File Name?'		initialAnswer: 'NewImageName') asFileName.	newName _ FileDirectory baseNameFor: newName.	newImageName _ newName, FileDirectory dot, FileDirectory imageSuffix.	newChangesName _ newName, FileDirectory dot, FileDirectory changeSuffix.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 9/23/1998 15:23'!makeExternalRelease		"Smalltalk makeExternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	Smalltalk obsoleteClasses isEmpty ifFalse: [self halt].	Display newDepth: 8.	Project allInstancesDo: [:p | p displayDepth: 8].	Utilities removeDisney.	ScriptingSystem prepareForExternalReleaseNamed: 'Squeak2.2beta'.	StandardScriptingSystem removeSelector: #serverUrls.	EToySystem class removeSelector: #serverUrls.	ServerDirectory removeServerNamed: 'UpdatesAtDOL'.	ServerDirectory removeServerNamed: 'UpdatesAtWebPage'.	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).	SystemDictionary removeSelector: #makeExternalRelease.	Symbol rehash.	self halt: 'Ready to condense sources'.	Smalltalk condenseSources! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Decompiling all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Decompiler Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/28/1998 06:06'!testFormatter2    "Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged"	 | newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			newCodeString _ (cls compilerClass new)				format: oldCodeString				in: cls notifying: nil.			oldTokens _ oldCodeString findTokens: Character separators.			newTokens _ newCodeString findTokens: Character separators.			oldTokens = newTokens ifFalse:					[Transcript cr; show: '***' , cls name , ' ' , selector.					badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 9/23/1998 16:11'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[Project current interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:04'!hasMorphic	"Answer whether the Morphic classes are available in the system (they may have been stripped, such as by a call to Smalltalk removeMorphic"	^ ((Smalltalk at: #WorldMorph ifAbsent: [nil]) isKindOf: Class)! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:42'!imageImports	"Answer the global dictionary of image imports, creating it if necessary.  7/24/96 sw"	"Smalltalk viewImageImports"	(self includesKey: #ImageImports)		ifFalse:			[self at: #ImageImports put: Dictionary new].	^ self at: #ImageImports! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:26'!imageReaderClass	"Answer, if present, a class to handle the importing of various graphic image files	from disk. If none, return nil.   tao 10/26/97"	| aClass |	^ ((aClass _ self at: #ImageReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:23'!jpegReaderClass	"Answer, if present, a class to handle the importing of JPEG files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #JPEGReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:03'!verifyMorphicAvailability	"If Morphic is available, return true; if not, put up an informer and return false"	self hasMorphic ifFalse:		[self beep.		self inform: 'Sorry, Morphic mustbe present to use this feature'.		^ false].	^ true! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:53'!viewImageImports	"Open up a special Form inspector on the dictionary of image imports."	self imageImports inspectFormsWithLabel: 'Image Imports'! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:48'!actualObject	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:46'!initialize	super initialize.	self removeAllMorphs.	resultType _ #boolean! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:50'!isBoolean	^ true! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:51'!storeCodeOn: aStream indent: tabCount	submorphs first storeCodeOn: aStream indent: tabCount! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/8/1998 16:56'!initCompactClasses	| c |	c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: PseudoContext.	compactClasses _ c.	"Leave 16 to 31 for user defined compact classes."	"Attempt to correctly write contextCache image.."	"compactClasses _ Smalltalk compactClassesArray"! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/8/1998 16:55'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: file fullName		type: 'STim'		creator: 'FAST'.	file close.! !!SystemWindow methodsFor: 'geometry' stamp: 'ls 9/16/1998 05:01'!extent: newExtent	| inner panelRect labelRect paneColor |	self removeHandles.	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	panelRect _ self panelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	paneMorphs with: paneRects do:		[:m :frame |  "m color: paneColor."		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated].	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].	self isActive ifTrue: [self addHandles]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:56'!labelRect	^ self innerBounds withHeight: self labelHeight.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:55'!panelRect	"Return the area below title bar, devoted to panes"	^ self innerBounds topLeft + (0@(self labelHeight))					corner: self innerBounds bottomRight! !!SystemWindow methodsFor: 'label' stamp: 'di 6/10/1998 13:53'!relabel	| newLabel |	newLabel _ FillInTheBlank request: 'New label for this window'						initialAnswer: labelString.	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!SystemWindow methodsFor: 'open/close' stamp: 'jm 8/20/1998 18:32'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model windowIsClosing; release.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld.! !!SystemWindow methodsFor: 'open/close' stamp: 'ls 7/21/1998 00:29'!openInWorld	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVC].	self bounds: (RealEstateAgent initialFrameFor: self).	World addMorph: self.	self activate.	World startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 8/12/1998 14:40'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !!SystemWindow methodsFor: 'open/close' stamp: 'ls 7/21/1998 00:30'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self position: (RealEstateAgent initialFrameFor: self) topLeft; extent: extent.	World addMorph: self.	self activate.	World startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 7/3/1998 01:29'!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color yellow; extent: (i<=6 ifTrue: [1@20] ifFalse: [20@1]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorphBack: handle].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 6/24/1998 21:30'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		super bounds: fullFrame.		paneMorphs reverseDo: [:m | self addMorph: m].		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		paneMorphs do: [:m | m delete; releaseCachedState].		collapsedFrame			ifNil:	[self extent: (label width + 50) @ (self labelHeight + 2).					self position: (RealEstateAgent assignCollapsePointFor: self)]			ifNotNil: [super bounds: collapsedFrame]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 6/17/1998 11:55'!mouseLeaveEvent: event fromPane: pane	"For backward compatibility only.  Not used by any newly created window"	(pane isKindOf: ScrollPane) ifTrue: [pane mouseLeave: event].! !!SystemWindow methodsFor: 'top window' stamp: 'di 6/24/1998 22:27'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	owner firstSubmorph == self ifFalse: [owner addMorphFront: self].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp]! !!SystemWindow methodsFor: 'top window' stamp: 'di 7/3/1998 01:30'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	"Note - the following code is equiv to simply:		self removeHandles.	It has been rewritten so that only 4 damage rects will get repainted, 	all within this window, and none within its subpanes"	"First do the top and bottom handles, together with the label"	self invalidRect: (self bounds topLeft corner: self right@(self top+1)).	self invalidRect: (self left@(self bottom-1) corner: self bounds bottomRight).	(self submorphs select: [:m | (m isMemberOf: Morph)			and: [m bottom <= (self top+1) or: [m top >= (self bottom-1)]]])		do: [:m | m delete].self world displayWorld.	"Now do the left and right handles"	self invalidRect: (self bounds topLeft corner: (self left+1)@self bottom).	self invalidRect: ((self right-1)@self top corner: self bounds bottomRight).	self removeHandles.  "Only these are left"self world displayWorld.	self submorphsDo: [:m | m lock].! !!SystemWindow methodsFor: 'events' stamp: 'di 9/21/1998 22:49'!handlesMouseDown: evt	"If I am not the topWindow, then my mouseDown action dominates"	Preferences fastDragWindowForMorphic ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'di 9/21/1998 22:51'!mouseDown: evt	| cp offset newBounds |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[Preferences fastDragWindowForMorphic		ifTrue: [offset _ self position - Sensor cursorPoint.				newBounds _ self bounds newRectFrom:					[:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft]		ifFalse: [^ evt hand grabMorph: self]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseMove: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!SystemWindow methodsFor: 'stepping' stamp: 'ls 8/3/1998 21:49'!stepTime	(model respondsTo: #stepTime) ifTrue: [ ^model stepTime ].	^ 200 "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'ls 9/16/1998 04:47'!wantsSteps	"Return true if the model responds to step (except if it is a debugger)."	| c |	(model respondsTo: #wantsSteps) ifTrue: [ ^model wantsSteps ].	c _ model class.	[c == nil] whileFalse:		[(c includesSelector: #step) ifTrue: [^ c ~= Debugger].		c _ c superclass].	^ false! !!SystemWindow methodsFor: 'menu' stamp: 'di 5/27/1998 15:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'relabel' action: #relabel.! !!SystemWindow methodsFor: 'drawing' stamp: 'di 8/16/1998 01:14'!areasRemainingToFill: aRectangle	| areas |	(areas _ super areasRemainingToFill: aRectangle) isEmpty		ifTrue: [^ areas "good news -- complete occlusion"].	"Check for special case that this is scrollbar damage"	((bounds topLeft - (14@0) corner: bounds bottomRight) containsRect: aRectangle) ifTrue:		[paneMorphs do: [:p | ((p isKindOf: ScrollPane) and: [p scrollBarFills: aRectangle])							ifTrue: [^ Array new]]].	^ areas! !A tab in a palette.  The contents is the name to be shown.  If it represents a book, that book is pointed to in my morphToInstall.!!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:28'!morphToInstall	^ morphToInstall! !!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:38'!morphToInstall: m	morphToInstall _ m.	self contents: m externalName.	self actionSelector: #tabSelected.	self target: self! !!TabMorph methodsFor: 'all' stamp: 'sw 7/3/1998 11:42'!representsBook	^ morphToInstall ~~ nil! !!TabMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:59'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be a TabbedPalette"	self player ifNotNil: [self player runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/2/1998 16:48'!defaultNameStemForInstances	^ 'tab'! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/3/1998 11:49'!forBook: aBook	^ self new morphToInstall: aBook! !A sorter for the tabs of a TabbedPalette!!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:05'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ TabMorph forBook: m].		(m isKindOf: TabTokenMorph) ifTrue:			[toAdd _ m tabRepresented contents: m contents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 15:24'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #cancelSort).	self addMorphFront: r.! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:06'!cancelSort	| oldOwner |	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 18:51'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder _ PasteUpMorph new.	pageHolder resizeToFit: true; autoLineLayout: true; fixLayout; layoutChanged.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:57'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs _ aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect:			[:aTab | TabTokenMorph new forTab: aTab]).	self position: aTabbedPalette position.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:30'!substituteForMorph: aMorph beingDroppedOn: aPage	(aMorph isKindOf: BookMorph) ifFalse: [^ nil].	^ TabTokenMorph new forTab: (TabMorph new morphToInstall: aMorph)! !An element of a TabSorter.!!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:02'!forTab: aTab	tabRepresented _ aTab.	self contents: aTab contents! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:51'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	super justDroppedInto: aMorph event: anEvent.	self world ifNotNil: [self world abandonAllHalos]! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:03'!tabRepresented	^ tabRepresented! !A structure of tabs and associated books.  Pressing a tab brings into focus the associated book.  Some tabs can have simple actions rather than books as their focus -- in this case, the palette is cleared and the action taken. !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 17:52'!addTabForBook: aBook	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	^ aTab! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:19'!addTabNamed: str color: aColor atIndex: anIndex	| aBook |	aBook _ BookMorph new setNameTo: str.	aBook color: aColor.	self addTabForBook: aBook! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:05'!defaultPageSize	^ 156 @ 232! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:10'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	color _ Color r: 0.0 g: 0.6 b: 0.6.  "background for menu bar, primarily"	borderWidth _ 1.	tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 14:57'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 |	pages _ pages species new.	tabsMorph ifNotNil:		[color1 _ tabsMorph  highlightColor.		color2 _ tabsMorph regularColor.		tabsMorph delete].	tabsMorph _ IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2].	currentPage ifNotNil:		[currentPage delete.		currentPage _ nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			(itsBook _ aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage _ itsBook]]].! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 9/14/97 01:12'!setInitialState	super setInitialState.	inset _ 0.	pageSize _ 156 @ 232! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 16:55'!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'scraps'.	scrapsBook removeEverything; insertPage.	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 18:13'!addToTrash: aMorph	"Paste the object onto a page of my Scraps tab. This is only called in situations where a presenter has a standard palette specified."	| aPage aBook |	self hasScrapsTab ifFalse:		[self addScrapsTab].	aBook _ self scrapsBook.	aMorph position: aBook pages first position + (0@40).	aBook pages do: [:pp | 		(pp submorphs size = 1 and: [pp hasProperty: #trash]) ifTrue:  "perhaps remove that property here"			["page is blank"			^ pp addMorph: aMorph]].	aPage _ aBook insertPageLabel: 'From Trash Can:'		morphs: (Array with: aMorph).	aPage setProperty: #trash toValue: true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:36'!hasScrapsTab	pages detect: [:p | (p hasProperty: #scraps)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:42'!scrapsBook	^ pages detect: [:p | p hasProperty: #scraps] ifNone: [nil]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:18'!addViewerTab	| viewerBook |	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 6/16/1998 16:02'!hasViewerTab	pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:17'!selectViewerTab	| viewerTab |	viewerTab _ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	self hasViewerTab ifFalse: [self addViewerTab].	self selectViewerTab.	currentPage setPlayer: aMorph assuredPlayer.	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self layoutChanged.	self ownerChanged.! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'tk 8/3/1998 15:56'!viewerBook	^ pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [nil]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:12'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	self hasMenuTab		ifFalse:			[aCustomMenu add: 'add palette menu' action: #addMenuTab].	aCustomMenu add: 'become the Standard palette' action: #becomeStandardPalette! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 21:00'!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 9/11/1998 16:02'!addScriptableTab	^ self addScriptableTabWithTitle: 'aTab'! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 8/30/1998 09:11'!addScriptableTabWithTitle: aTitle	| aTab |	aTab _ tabsMorph addActionTabWithTitle: aTitle.	aTab actionSelector: #tabSelected; target: aTab.	^ aTab! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:11'!hasMenuTab	^ self hasSubmorphWithProperty: #tabsMenu! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/15/1998 19:45'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette ifNotNil:		[aMenu add:  'clear' action: #showNoPalette.		aMenu addLine].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasViewerTab ifFalse:	[aMenu add:  'add "view" tab' action: #addViewerTab].	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 6/16/1998 16:17'!becomeStandardPalette	self presenter standardPalette: self! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/4/1998 14:12'!recolorTabs	"Prompt the user for new on and off colors for tabs"	| onColor offColor |	self inform: 'Choose the ''on'' color'.	onColor _ Color fromUser.	self inform: 'Okay, now please choosethe ''off'' color'.	offColor _ Color fromUser.	tabsMorph highlightColor: onColor regularColor: offColor.	currentPage ifNotNil:		[tabsMorph highlightTabFor: currentPage]! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/8/1998 13:22'!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	self snapToEdgeIfAppropriate! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/3/1998 18:17'!sortTabs: evt	TabSorterMorph new sortTabsFor: self.  "it directly replaces me"	self delete! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ openToDragNDrop not! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/8/1998 13:27'!selectTab: aTab	| currentPalette |	self currentPalette ifNotNil: [self currentPalette currentPlayerDo:		[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!selectTabNamed: aName	"For bkwrd compat with etoys"	| aTab |	aTab _ self tabMorphs detect: [:m | m contents = aName] ifNone: [nil].	aTab ifNil: [self error: 'tab not found'].	tabsMorph selectTab: aTab! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:40'!selectTabOfBook: aBook	self tabMorphs do:		[:aTab | aTab morphToInstall == aBook ifTrue: [^ self selectTab: aTab]]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!tabMorphs	^ tabsMorph tabMorphs! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 5/31/1998 00:20'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: evt cursorPoint) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 6/23/1998 12:31'!currentPalette	"A stylistic convenience to reduce confusion caused by the fact that a palette is a book of books"	^ currentPage! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'tk 8/3/1998 22:30'!releaseCachedState	| vv |	(vv _ self viewerBook) ifNotNil: [		(self currentPage ~~ vv) ifTrue: [vv removeEverything]].	super releaseCachedState! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 9/30/97 10:10'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result _ super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'jm 11/16/97 17:59'!tabsMorph	^ tabsMorph! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 7/4/1998 16:36'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 180 @ 88.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: EllipseMorph authoringPrototype.	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 6/3/1998 21:27'!defaultNameStemForInstances	^ 'tabbedPalette'! !!TempoEvent methodsFor: 'all' stamp: 'jm 9/10/1998 08:37'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': tempo '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !!Text methodsFor: 'accessing' stamp: 'ls 7/29/1998 01:17'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs withStartStopAndValueDo: [ :start :stop :attribs | attribs do: [ :attrib |		(attrib isKindOf: TextAnchor) ifTrue: [  morphs add: attrib anchoredMorph ] ] ].	^morphs select: [ :m | m isKindOf: Morph ]! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asUrl	^self asString asUrl! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!Text methodsFor: 'emphasis' stamp: 'ls 7/4/1998 16:13'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle fontAt: 1].	"null text tolerates access"	attributes _ runs at: characterIndex.	font _ aTextStyle fontAt: 1.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font	! !!TextAnchor methodsFor: 'all' stamp: 'di 7/1/1998 14:35'!= other 	^ (other class == self class) 		and: [other anchoredMorph == anchoredMorph]! !create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount	"number of tab spaces to indent by"	^amount! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:54'!tabs: numTabs	"create an indentation by the given number of tabs"	^self amount: numTabs! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text _ 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg _ text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !a textual input; it takes text input straight from the user via a PluggableText!!TextInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 04:01'!name: name0  defaultValue: defaultValue0  textMorph: textMorph0	name _ name0.	defaultValue _ defaultValue0.	textMorph _ textMorph0.! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:34'!name	^name! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 09:02'!reset	textMorph setText: defaultValue! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/6/1998 09:31'!value	textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].	^textMorph getText withInternetLineEndings! !!TextInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:23'!name: name0  defaultValue: defaultValue  textMorph: textMorph	^self new name: name0  defaultValue: defaultValue  textMorph: textMorph	! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 6/30/1998 22:03'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !!TextMorph methodsFor: 'accessing' stamp: 'ls 9/15/1998 19:36'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@-1000)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self world ifNotNil: [ 		self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 12:37'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 8/11/1998 13:04'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 8/14/1998 15:50'!defaultLineHeight	^ textStyle lineGrid! !!TextMorph methodsFor: 'menu' stamp: 'sw 6/15/1998 15:13'!addOptionalHandlesTo: aHalo box: box	self addFontHandlesTo: aHalo box: box! !!TextMorph methodsFor: 'private' stamp: 'di 9/14/1998 11:35'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		editor storeSelectionInParagraph: self paragraph.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 6/22/1998 20:22'!updateFromParagraph  	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last.		self editor setEmphasisHere]! !!TextMorph methodsFor: 'containment' stamp: 'sw 6/25/1998 10:44'!ownerChanged	super ownerChanged.	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!TextMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 17:16'!authoringPrototype	| t |	t _ super authoringPrototype."Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:11'!readKeyboard	super readKeyboard.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/14/1998 13:12'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 9/14/1998 12:02'!storeSelectionInParagraph: aParagraph	paragraph == aParagraph		ifTrue: [self storeSelectionInParagraph]		ifFalse: ["Should never get here."				aParagraph selectionStart: nil selectionStop: nil]! !!TextMorphEditor methodsFor: 'binding' stamp: 'ls 7/24/1998 21:06'!bindingOf: aString	^model bindingOf: aString! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 8/16/1998 21:17'!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self installEditor.  "Make sure editor is installed"	self editor sensor: (KeyboardBuffer new startingEvent: evt).  "Fool MVC"	self editor model: editView model.  "For evaluateSelection"	self selectionChanged.  "Note old selection"		interActionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:43'!initialize	super initialize.	acceptOnCR _ false! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:49'!keyStroke: evt	| view |	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/30/1998 08:50'!mouseDown: event	event yellowButtonPressed ifTrue: [^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextOnCurve methodsFor: 'all' stamp: 'di 9/14/1998 11:46'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultStartBlock]! !!TextStyle methodsFor: 'accessing' stamp: 'tk 6/26/1998 15:03'!fontNamesAndSizes  "TextStyle default fontNames"	^ fontArray collect: [:x | x name, ' ', x height printString]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 6/26/1998 15:58'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.	"Only works if file created by special code above"	newName _ this fontArray first name.	this fontArray do: [:aFont | aFont name = newName ifFalse: [		self error: 'All must be same family']].	style _ TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights _ style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 8/20/1998 08:48'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	| new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	new _ self clone.	deepCopier references at: self put: new.	"remember"	^ new! !!TextURL methodsFor: 'as yet unclassified' stamp: 'di 9/19/1998 16:19'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m browser | 		"if it's a web browser, tell it to jump"		anObject isWebBrowser ifTrue: [			anObject jumpToUrl: url.			^true ].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m _ anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [ 					m  jumpToUrl: url.  					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m _ m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	(self confirm: 'open a browser to view this URL?') ifTrue: [		browser _ Scamper new.		browser jumpToUrl: url.		browser openAsMorph.		^ true ].		"couldn't display in a browser.  Offer to put up just the source"		response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Couldn''t find a web browser.  View page as source?'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/24/1998 17:05'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	actualViewee isInWorld		ifTrue:			[(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].			(actualViewee isKindOf: SketchMorph)				ifTrue:					[diag _ actualViewee form extent r asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds].			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c _ c copyOffset: viewedMorphBox topLeft negated.			actualViewee fullDrawOn: c.		"recursion happens here"			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter]! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/15/1998 15:18'!tearOffTile	(objectToView isKindOf: Player) ifTrue: [^ objectToView tearOffTileForSelf].	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[objectToView costume]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/10/1998 08:33'!colorChangedForSubmorph: aSubmorph	"Invoked when the user selects a new color on a colorTile or a color-seer-tile; need to recompile the script."	self acceptNewLiteral! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!bePossessive	possessive _ true.	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 18:00'!bringUpToDate	| newLabel |	type == #objRef ifTrue:		[newLabel _ actualObject externalName.		self isPossessive ifTrue:			[newLabel _ newLabel, '''s'].		self line1: newLabel]	! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!isPossessive	possessive == nil ifTrue: [^ false].	^ possessive! !!TileMorph methodsFor: 'initialization' stamp: 'sw 7/2/1998 09:50'!setLiteral: anObject	| m |	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.  "BUT this doesn't do it, damnit"	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorph: m.	self literal: anObject.! !!TileMorph methodsFor: 'accessing' stamp: 'sw 7/4/1998 18:01'!resultType	type == #literal ifTrue:		[(literal isKindOf: Number) ifTrue: [^ #number].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Point) ifTrue: [^ #point].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Boolean) ifTrue: [^ #boolean].		(literal isKindOf: Morph) ifTrue: [^ #costume]  "This last one dubious!!"].	type == #expression ifTrue:		[^ #number].	type == #objRef ifTrue: [^ #player].	^ #unknown! !!TileMorph methodsFor: 'arrows' stamp: 'sw 7/15/1998 19:24'!showSuffixChoices	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: literal 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter coloredTilesEnabled ifFalse:		[phrase topEditor			ifNotNil:				[phrase topEditor makeAllTilesGreen]			ifNil:				[phrase makeAllTilesGreen]]! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:12'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:04'!storeCodeOn: aStream indent: tabCount	| op refType playerBearingCode |	"Must determine whom is scripted for what follows to work"	playerBearingCode _ self playerBearingCode.  "If it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["This is the critical point -- if the object is the method's own 'self' then we MUST, rather than just MAY, put out self rather than the referencer call, though the latter will temporarily work as long we have true uniclasses."				aStream nextPutAll: 'self']			ifFalse:				[aStream nextPutAll: 'self class '.				aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'private' stamp: 'sw 6/26/1998 16:26'!updateLiteralLabel	"now works for operator tiles also"	|  desiredW leader myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel contents:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + (leader + 0)) @ (bounds top + 3); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!TileMorph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 10:17'!convertbosfcepcbbtsloadustlno0: varDict bosfcebbtsloadustlnop0: smartRefStrm	"These variables are automatically stored into the new instance ('type' 'slotName' 'literal' 'operatorOrExpression' 'actualObject' 'downArrow' 'upArrow' 'suffixArrow' 'typeColor' 'lastArrowTick' 'nArrowTicks' 'operatorReadoutString' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('possessive' ) and deal with the information in ()"	"Morph's conversion method already deals with this, so no extra code here."! !!TilePadMorph methodsFor: 'all' stamp: 'sw 6/15/1998 09:21'!acceptDroppingMorph: aMorph event: evt	| editor wasPossessive |	wasPossessive _ submorphs size > 0 and: [submorphs first isPossessive].	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	wasPossessive ifTrue: [aMorph bePossessive].	(editor _ self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TilePadMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	submorphs do: [:m | m storeCodeOn: aStream indent: tabCount].! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 9/9/1998 17:35'!initialize	"TilePadMorph initialize"	ColorsForType _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(point			(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | ColorsForType at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Time fromSeconds: secondCount \\ 86400)		with: (Date fromSeconds: secondCount)! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	| secondCount d t |	secondCount _ self primSecondsClock.	d _ Date fromSeconds: secondCount.	t _ Time fromSeconds: secondCount \\ 86400.	^ Array with: d with: t! !an input from a toggle button!!ToggleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 07:33'!fixTargetPresenters	"ToggleButtonMorph fixTargetPresenters"	"Repair faulty instances from the first 'etoy-template' experiment, such that the instances refer to the local presenter rather than to a phantom and irrelevant world"	self allInstancesDo:		[:m | (m target isKindOf: Presenter) ifTrue:			[m target: m presenter]]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	World ifNotNil: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:37'!morphsIn: aRectangle addTo: mList	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  Map through my transform.  "	| r |	(self bounds intersects: aRectangle) ifFalse:		["TransformMorph clips to bounds"		^ mList].	r _ Rectangle encompassing: (aRectangle corners collect: [:p | transform transform: p]).	submorphs do: [:m | m morphsIn: r addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'jm 6/17/1998 12:22'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageForm.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 7/31/1998 12:35'!forwardDirection	"Same as rotationDegrees"| m |^ (((m _ self renderedMorph) isKindOf: SketchMorph) and: [m rotationStyle ~~ #normal]) 			ifTrue: [m rotationDegrees]			ifFalse: [self angle radiansToDegrees negated]! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 8/20/1998 13:44'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on ', submorphs first printString! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 9/3/1998 00:19'!referencePosition	^ transform invert: self renderedMorph referencePosition! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 9/3/1998 00:18'!referencePosition: aPoint	self position: self position + (aPoint - self referencePosition)! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 14:37'!rotationDegrees: degrees	| m |	self adjustAfter:		[(m _ self renderedMorph) doesOwnRotation			ifTrue: ["is SketchMorph and rotationStyle is not #normal"				m rotationDegrees: degrees.				"self angle: 0.0 or not flexed"]			ifFalse: [self angle: degrees degreesToRadians negated]]	"usual case"! !!TransformationMorph methodsFor: 'menu' stamp: 'di 9/9/1998 19:53'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed player: self player.	self player ifNotNil:		[self player rawCostume: unflexed.		self player: nil].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/3/1998 10:02'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ self referencePosition.	changeBlock value.	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.! !!TranslucentColor methodsFor: 'printing' stamp: 'jm 6/2/1998 08:26'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'jm 6/2/1998 08:35'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TrashCanMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 14:28'!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:17'!handlesDragOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:33'!handlesMouseOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseEnter: event	"Present feedback for potential deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self presenter soundsEnabled ifTrue: [self class playMouseEnterSound].			hand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[self presenter soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand endDisplaySuppression.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 8/4/1998 18:42'!acceptDroppingMorph: aMorph event: evt	| palette |	self presenter soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self standardPalette.	palette ifNotNil: [palette addToTrash: aMorph].! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:44'!findActivePaintBox	"If painting, return the active PaintBoxMorph. If not painting, or if the paint box cannot be found, return nil."	| w m |	w _ self world.	w ifNil: [^ nil].	(w findA: SketchEditorMorph) ifNil: [^ nil].  "not painting"	(m _ w findA: PaintBoxMorph) ifNotNil: [^ m].	^ nil! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:45'!openTrash	"User wants to see what is in the trash."	| paintBox |	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"! !!TrashCanMorph methodsFor: 'other' stamp: 'sw 9/14/1998 12:02'!printOn: aStream	aStream nextPutAll: 'a TrashCanMorph'! !This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it is a bookmorph, it can act on a particular book or it can act on whatever book it happens to be in at the time. The former is primarily used for making a graphical page index allowing random access to any page in the book.!!URLMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 07:16'!initialize	super initialize.	color _ Color lightGray.	isBookmark _ false.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book	^ book! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book: aWebBookMorph	"Set the book morph to be invoked when this url is used as a bookmark. If nil, then this bookmark operates on whatever book it is currently in."	book _ aWebBookMorph.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:16'!isBookmark	^ isBookmark! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:17'!isBookmark: aBoolean	"Make this morph behave as a clickable bookmark if the argument is true."	isBookmark _ aBoolean.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:07'!page	"Answer the cached page that this morph represents."	^ page! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:05'!url	"Answer the URL for the page that this morph represents."	^ url! !!URLMorph methodsFor: 'drawing' stamp: 'jm 6/25/1998 11:14'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." 	| thumbnail |	aCanvas frameRectangle: bounds width: 1 color: Color blue.	thumbnail _ self thumbnailOrNil.	thumbnail		ifNil: [aCanvas fillRectangle: (bounds insetBy: 1) color: color]		ifNotNil: [aCanvas image: thumbnail at: bounds origin + 1].! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 07:18'!handlesMouseDown: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 21:50'!mouseDown: evt	| bk |	book		ifNil: [bk _ self enclosingBook]		ifNotNil: [bk _ book].	bk ifNotNil: [bk goToURL: url].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:28'!enclosingBook	"Answer the inner-most book that contains this morph, or nil if there isn't one."	| m |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: WebBookMorph) ifTrue: [^ m].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:21'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	self pageHasChanged: page.! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:05'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [^ nil].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:35'!newBookmarkForURL: aURLString	^ (self newForURL: aURLString) isBookmark: true! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:09'!newForURL: aURLString	| pg |	pg _ SqueakPageCache		atURL: aURLString		ifAbsent: [^ self new setURL: aURLString page: nil].	^ self new setURL: aURLString page: pg! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:41'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(self isStringRooted: uString)		ifTrue: ["an external URL"			(self isStringAnImage: uString)				ifTrue: ["Looks like an image URL"						^self imageURL: string]				ifFalse: [^self externalURL: string]]		ifFalse: [ "Serious!! Gotta provide-a-link!! But check forimage or local action first"				(self isStringAnImage: uString)					ifTrue: [^self localImageURL: string].				(self isStringALocalAction: uString)					ifTrue:[^self localActionURL: string].			newpage _ pages at: string asLowercase ifAbsent: [nil].			newpage isNil				ifTrue: [ "Create a new page"					newpage _ self newpage: stringfrom: peer.].			(aList indexOf: newpage) ~= 0				ifFalse: [aList add: newpage]. "Add only ifnot there"			^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:47'!linkFor: string from: peer storingTo: aList page: aPage	| uString placeID |	uString _ string asUppercase.	(uString beginsWith: 'APPEND HERE') ifTrue: [		placeID _ uString copyFrom: (13 min: uString size) to:uString size.		^'<a href="', aPage url, '.insert.', placeID ,'">','AppendHere','</a>'].			"later an image here"	^self linkFor: string from: peer storingTo: aList.! !!URLmap methodsFor: 'searching' stamp: 'BJP 9/7/1998 01:06'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new]."We definitely want the reject: first, so we sort a smaller collection.Having the variable name be 'sortedPages' is a bit of a misnomer, though.""I think we shouldn't do all this for each call to recent changes. Afterall, most of the time, it's *hasn't* changed, and when it *has*, it'spretty much only added something to the end. At the very least we shouldcache the sorted, filtered collection.""And really, why is this in URLmap? Recent Changes is a kind of page. I'drather see it as a swikipage, perhaps standardly defined (that is, when youset up a swiki, you get a front page, a formatting page, and a RecentChanges page). That is, SwikiPages could store text (as they do now) orcgi-ish functions (like recent). That way, we could design custom templatesfor them, etc.At the very least, there needs to be better labeling. Why not call thecategory with these page functions, 'dynamic pages', or somethign similar?""A different condsideration: It would be nice to have arbitrary filters:e.g., 'past ten days', 'all pages *not* yet edited', etc., and be able tocombine them. Would work as a 'search for various attributes' feature whichone might or might not expose to the user."	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(pageaddress).].	response nextPutAll: '</ul>'.	^response contents		! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:16'!externalURL: aString	"make a non-local  URL"	^'<a href="',aString,'">',aString,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:15'!imageURL: aString	"make a non-local image URL"	^'<img src="', aString,'" alt="', aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:10'!localActionURL: aString	|string|	"fake up a more ordinary URL by dropping the shriek chars"	string _ aString copyWithout: $!!.	^'<a href="',string,'">',string,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/1/1998 12:32'!localImageURL: aString	"make a local image URL"	^'<img src="',action name, '/', aString,'" alt="', action name,'/',aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/11/1998 10:32'!pageURL: aPage	(aPage pageStatus = #new)		ifTrue:			[^'<u>',(aPage name),'</u><a href="', (actionpageURL: aPage),'.edit">?</a>'] "Underlines new but not yet edited pages"		ifFalse:			[^'<a href="', (action pageURL: aPage),'">',(aPagename),'</a>']"Logically, there should be editPageUrl in SwikiAction as well. After all,we might want to define other URL schemes." ! !!URLmap methodsFor: 'creating' stamp: 'BJP 9/7/1998 00:52'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	"This filtering should be generalized a tad, methinks. Perhapsincorparated into the	linkhandler."	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'mjg 9/10/1998 15:24'!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p |		p coreID asNumber > max ifTrue: [p coreID asNumber]				ifFalse: [max]]) + 1) printString.	newpage _ SwikiPage new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage time: (Time now).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory),		directory, (ServerAction pathSeparator), newfile).	newpage pageStatus: #new.	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'mjg 8/28/1998 19:48'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page time: (Time now).	page text: text.	page address: peer.	^ page! !!URLmap methodsFor: 'creating' stamp: 'tk 7/14/1998 19:32'!storeID: id text: insertedText insertAt: idString	"Insert in a place in the text.  Just before '*append here 34*' ifidString is '34'."	| page bigText ind toInsert |	page _ self atID: id.	page date: (Date today).	bigText _ page text.	ind _ bigText findString: '*append here ',idString,'*' startingAt:1.	"always lower case"	ind = 0 ifTrue: [^ page].		"could not find that place"	"Make sure new text surrounded by line feeds"	toInsert _ (insertedText last == Character linefeed)		ifTrue: [insertedText]		ifFalse: [insertedText, (String with: Character linefeed)].	((insertedText first == Character linefeed) or: [		(bigText at: (ind-1 max: 1)) == Character linefeed])			ifFalse: [toInsert _ (String with: Characterlinefeed), toInsert].	page text: (bigText copyReplaceFrom: ind to: ind-1 with: toInsert).	"page address: peer.  Don't sign with person who only added"	^ page! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:51'!isStringALocalAction: anUpperCasedString	"check the string to see if it starts and end with  a shriek - codefor a Swiki action such as Comment or whatever"	^(anUpperCasedString size >=2) and:	[anUpperCasedString first = $!! and:	[anUpperCasedString last= $!!]]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:39'!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes itlkely to be an image URL"	^(anUpperCasedString endsWith: 'GIF') or:		[(anUpperCasedString endsWith: 'JPEG') or:		[anUpperCasedString endsWith: 'JPG']]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:37'!isStringRooted: anUpperCasedString	"check the string to see if it starts with something that makes itlkely to be a rooted URL"	^(anUpperCasedString indexOfSubCollection: 'HTTP' startingAt: 1) =1 or:	[(anUpperCasedString indexOfSubCollection: 'FTP' startingAt: 1) = 1 or:	[(anUpperCasedString indexOfSubCollection: 'MAILTO' startingAt: 1)= 1]]! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 8/31/1998 16:53'!addToGlossary: myName as: myURL	|aStream |	"Add to a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	aStream setToEnd.	aStream nextPutAll: myName,'|',myURL; cr.	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:44'!readGlossary: aStream	|aLine pieces name url newpage|	"Expect a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	self pages: (Dictionary new).	aStream open.	[aStream atEnd] whileFalse:		[aLine := aStream upTo: (Character cr).		pieces _ aLine findTokens: '|'.		name _ pieces at: 1.		url _ pieces at: 2.		newpage _ SwikiPage new.		newpage coreID: url.		newpage map: self.		newpage name: name.		pages at: name asLowercase put: newpage].	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:47'!writeGlossary	"Write out the pages dictionary as a CR-delimited file of pagenameand URL"	|aStream |	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	pages keys asSortedCollection do: [:each |		aStream nextPutAll: (pages at: each) name,'|',(pages at:each) coreID; cr.].	aStream close.	! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 9/12/1998 23:05'!default	"UnloadedSound default play"	| snd p |	snd _ super new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !My instances are Player objects that have not been scripted, and which hence do not require a unique scripts dictionary, etc.  As soon as the needed, I am transformed automatically into a unique subclass of Player.!!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:21'!assureUniClass	| anInstance |	anInstance _ Player instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!belongsToUniClass	^ false! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:13'!copyUniClass	self error: 'oops, copyUniClass sent to an UnscriptedPlayer'! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!acceptsLoggingOfCompilation	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:33'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self new! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:34'!officialClass	^ self! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:49'!wantsChangeSetLogging	^ true! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 17:45'!valueAsConstant	^ self readFromTarget! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'sw 6/26/1998 07:41'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.	growable _ true! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 6/11/1998 16:27'!valueAsConstant	^ self valueFromContents! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:22'!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ self growable		ifTrue:			['stop']		ifFalse:			['start'].	menu add: prefix, ' being growable' action: #toggleGrowability! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable _ self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!Url methodsFor: 'parsing' stamp: 'ls 8/5/1998 00:57'!newFromRelativeText: aString	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"	"if the scheme is the same, or not specified, then use the same class"	| newSchemeName remainder fragmentStart newFragment newUrl bare |	bare _ aString withBlanksTrimmed.	newSchemeName _ Url schemeNameForString: bare.	(newSchemeName isNil not and: [ newSchemeName ~= self schemeName ]) ifTrue: [		"different scheme -- start from scratch"		^Url absoluteFromText: aString ].	remainder _ bare.	"remove the fragment, if any"	fragmentStart _ remainder indexOf: $#.	fragmentStart > 0 ifTrue: [		newFragment _ remainder copyFrom: fragmentStart+1 to: remainder size. 		remainder _ remainder copyFrom: 1 to: fragmentStart-1].	"remove the scheme name"	newSchemeName ifNotNil: [		remainder _ remainder copyFrom: (newSchemeName size + 2) to: remainder size ].	"create and initialize the new url"	newUrl _ self class new privateInitializeFromText: remainder  relativeTo: self.	"set the fragment"	newUrl privateFragment: newFragment.	^newUrl! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:50'!privateInitializeFromText: aString	^self subclassResponsibility! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:55'!privateInitializeFromText: aString relativeTo: aUrl	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"	"by default, just do regular initialization"	^self privateInitializeFromText: aString! !!Url methodsFor: 'classification' stamp: 'ls 6/16/1998 16:22'!scheme	"return a string with the scheme of this URL.  For instance, HTTP"	^self subclassResponsibility! !!Url methodsFor: 'classification' stamp: 'ls 7/3/1998 21:11'!schemeName	"return a lowercase string with the scheme of this URL.  For instance, 'http'"	^self subclassResponsibility! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!printOn: aStream	aStream nextPutAll: self toText! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!toText	"give a String representation of the Url, suitable for printing, etc."	^self subclassResponsibility! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:41'!activate	"spawn an external handler for this URL"	! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:40'!hasContents	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"	^false! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContents	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved"	^nil! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContentsForBrowser: aBrowser	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved.  Since aBrowser is specified, this could do browser specific things"	^self retrieveContents! !!Url methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asText	^self asString asText! !!Url methodsFor: 'converting' stamp: 'ls 6/29/1998 00:36'!asUrl	^self! !!Url methodsFor: 'converting' stamp: 'ls 7/3/1998 21:11'!asUrlRelativeTo: aUrl	^self! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:41'!fragment	^fragment! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:02'!privateFragment: aString	fragment _ aString! !!Url class methodsFor: 'parsing' stamp: 'ls 8/4/1998 20:42'!absoluteFromText: aString	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"	"Url absoluteFromText: 'file:/etc/passwd'"	| remainder scheme fragment ind newUrl |	"trim surrounding whitespace"	remainder _ aString withBlanksTrimmed.		"extract the fragment, if any"	ind _ remainder indexOf: $#.	ind > 0 ifTrue: [		fragment _ remainder copyFrom: ind+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: ind-1 ].	"choose class based on the scheme name, and let that class do the bulk of the parsing"	scheme _ self schemeNameForString: remainder.	scheme = nil ifTrue: [		newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'http') ifTrue: [ newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'msw') ifTrue: [ newUrl _ MswUrl new privateInitializeFromText: remainder ]. 	(scheme = 'ftp') ifTrue:[ newUrl _ FtpUrl new privateInitializeFromText: remainder ].	(scheme = 'file') ifTrue: [newUrl _ FileUrl new privateInitializeFromText: remainder ].		(scheme = 'browser') ifTrue: [ newUrl _ BrowserUrl new privateInitializeFromText: remainder ].	(scheme = 'mailto') ifTrue: [ newUrl _ MailtoUrl new privateInitializeFromText: remainder ].	newUrl ifNil: [  newUrl _ GenericUrl new privateInitializeFromText: remainder ].	"set the fragment"	newUrl privateFragment: fragment.	"all done"	^newUrl! !!Url class methodsFor: 'parsing' stamp: 'ls 7/26/1998 20:37'!schemeNameForString: aString	"get the scheme name from a string, or return nil if it's not specified.  used in internal parsing routines--an outsider may as well use asUrl.  lowercases the return value."	"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| idx schemeName |	idx _ aString indexOf: $:.	idx = 0 ifTrue: [ ^nil ].	schemeName _ aString copyFrom: 1 to: idx-1.	schemeName do: [ :c |		"make sure it is all alphabetic"		c isLetter ifFalse: [ ^nil ]. ].	^schemeName asLowercase! !!Url class methodsFor: 'testing' stamp: 'ls 8/4/1998 02:42'!quickieTest	"run some quick tests on the Url hierarchy"	"	Url quickieTest	"	| tests url block correct actual numCorrect numWrong baseUrl |	"each item in tests in a two-element array.  it has a block, followed by the string the block should evaluate to"	tests _ OrderedCollection new.	"parsing absolute urls of various kinds"	tests add: (Array with: 		[url _ 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.		url schemeName, '|', url authority, '|', url path first, '|', url path size printString, '|', url query, '|',url fragment.]		with: 'http|chaos.resnet.gatech.edu:8000|docs|3|A%20query%20|part').	tests add: (Array with:		[url _ 'ftP://some.server/some/directory/' asUrl.		url schemeName, '|', url class name, '|', url authority, '|', url path first , '|', url path size printString]		with: 'ftp|FtpUrl|some.server|some|3').	tests add: (Array with:		[url _ 'telNet:chaos.resnet.gatech.edu#goo' asUrl.		url schemeName, '|', url locator, '|', url fragment] 		with: 'telnet|chaos.resnet.gatech.edu|goo').	tests add: (Array with:		[url _ Url absoluteFromText: 'file:/etc/passwd#foo'.		url schemeName, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|etc|2|foo').	tests add: (Array with: 		[url _ Url absoluteFromText: 'browser:bookmarks#mainPart'.		url schemeName, '|', url locator, '|', url fragment, '|', url class name ]		with: 'browser|bookmarks|mainPart|BrowserUrl').	tests add: (Array with:		[url _ 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.		url schemeName, '|', url class name, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|FileUrl|foo|5|fragger').	"relative urls of each kind, relative to the original"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp://a.b'.		url toText]		with: 'ftp://a.b/').	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp:xyz'.		url toText.]		with: 'ftp://somewhere/some/dir/xyz').	tests add: (Array with: [		baseUrl _ 'http://some.where/some/dir?query1#fragment1' asUrl.		url _ baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.		url toText]		with: 'http://some.where/another/dir/?query2#fragment2').	tests add: (Array with: [		baseUrl _ 'file:/some/dir#fragment1' asUrl.		url _ baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.		url toText]		with: 'file:/another/dir/#fragment2').	"relative urls of a different scheme"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'http:xyz'.		url toText.]		with: 'http://xyz/').	"run the tests"	numCorrect _ 0.	numWrong _ 0.	tests do: [ :test |		block _ test at: 1.		correct _ test at: 2.		actual _ block value.		Transcript show: actual.		correct = actual 			ifTrue: [ numCorrect _ numCorrect + 1 ]			ifFalse: [				numWrong _ numWrong + 1.				Transcript show: '<-- should be: ', correct ].		Transcript cr. ].	Transcript show: numCorrect printString, ' correct, ', numWrong printString, ' wrong.', String cr.	numWrong > 0 		ifTrue: [ Transcript show: 'happy hacking!!' ]		ifFalse: [ Transcript show: 'yay!!!!!!' ].	Transcript cr.! !!UserScript methodsFor: 'initialization' stamp: 'tk 6/13/1998 14:25'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [		currentScriptEditor == #textuallyCoded ifFalse: [			currentScriptEditor donorActor: player1 ownActor: player2]].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!UserScript methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:06'!initializeForPlayer: aPlayer afterShallowCopyFrom: aDonorUserScript	player _ aPlayer.	formerScriptEditors _ nil.	aDonorUserScript isTextuallyCoded		ifFalse:			[currentScriptEditor _ currentScriptEditor fullCopy.				"We have a rule that ScriptEditors can't have Players in them"			currentScriptEditor playerScripted: aPlayer.			currentScriptEditor donorActor: aDonorUserScript player ownActor: aPlayer]		! !!UserScript methodsFor: 'script editor' stamp: 'sw 8/21/1998 16:35'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 8/22/1998 22:10'!absorbUpdatesFromServer	"Go to two common servers and look for updates.  Do not bring themto the user's disk.  A file on the server called updates.list has the namesof the last N update files.  We look backwards for the first one we do nothave, and start there bringing them in.  tk 9/10/97""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""wod 6/18/1998: stop after first failure""Utilities absorbUpdatesFromServer"| doc urls failed loaded str |Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"Cursor wait showWhile: [	(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']).	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil: [			doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			"check here that it worked"			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse: [					doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse: [							"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							ChangeSorter newChangesFromStream: doc								named: (this findTokens: '/') last.							self saveUpdate: doc onFile: (this findTokens: '/') last.	"if wanted"							loaded _ loaded + 1]]]].	].str _ 'Loaded ', loaded printString ,' new update files.'.failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',					'\Starting with "' withCRs, failed, '".'].self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 6/30/1998 15:49'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger > 412]].	Utilities absorbUpdatesWriteFiles: true zapNums: false.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #()."	| fileNames fileNamesInOrder fileNamesUnnumbered names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	fileNames _ FileDirectory default fileNames select:		[:n | n first isDigit			and: [(n initialInteger between: n1 and: n2)			and: [(skipList includes: n initialInteger) not]]].	fileNamesInOrder _ fileNames asSortedCollection.	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | FileDirectory default rename: n toBe: nu].	(ServerDirectory groupNamed: choice) putUpdateMulti: fileNamesUnnumbered! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/23/1998 08:55'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted"	| index him |	UpdateUrlLists size > 1 ifTrue: [		index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 			startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.		index > 0 ifTrue: [			him _ UpdateUrlLists at: index.			UpdateUrlLists removeAt: index.			UpdateUrlLists addFirst: him].		^ index > 0].	^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'wod 5/21/1998 18:38'!saveUpdate: doc onFile: fileName	"See if the user wants the update stored on a local file.  With or without the update number on the front."	| file fName pos |	(Preferences valueOfFlag: #updateSavesFile) ifFalse: [^ self].	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue: [		pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(FileDirectory default fileExists: fName) ifFalse: [		file _ FileStream newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 9/14/1998 13:27'!serverUrls	"Return the current list of server URLs.  For code updates.  Format of UpdateUrlLists is #( ('squeak updates' ('url1' 'url2'))    ('some other updates' ('url3' 'url4')))"	^ UpdateUrlLists first last! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'support windows' stamp: 'di 5/28/1998 12:11'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selection<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 01:53'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(StringHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 02:02'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(StringHolder new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!Utilities class methodsFor: 'support windows' stamp: 'sw 9/22/1998 16:44'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 5000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.(FileStream oldFileNamed: 'DryRot.cs') edit.(FileStream oldFileNamed: 'change.cs') fileInChangeList browseFile: 'Elvis.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspectSystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/22/1998 17:12'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream oldFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream oldFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'common requests' stamp: 'di 9/22/1998 16:04'!closeAllDebuggers	"Utilities closeAllDebuggers"	Smalltalk isMorphic	ifTrue:		[(SystemWindow allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w delete]]	ifFalse:		[(StandardSystemController allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w closeAndUnscheduleNoTerminate]]! !!Utilities class methodsFor: 'common requests' stamp: 'di 9/22/1998 16:06'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw	 5/10/96 sw: converted over to new format of StringHolder"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapseUtilities closeAllDebuggersSensor keyboardCursor normal show----------------------------------ScriptingSystem inspectFormDictionaryPreferences enable: #showTimeStampsInMenuTitlesPreferences enable: #cmdDotEnabledForm fromUser bitEditDisplay border: (0@0 extent: 640@480) width: 2----------------------------------Undeclared inspectUndeclared removeUnreferencedKeys; inspectTranscript clearChangeSorter removeEmptyUnnamedChangeSets'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 9/23/1998 02:03'!fontSizeSummary	"Utilities fontSizeSummary"	| aStream aList |	aStream _ ReadWriteStream on: ''.	aList _ Utilities knownTextStyles.	aList do: [:aStyleName |		aStream nextPutAll:			aStyleName, '  ',			(Utilities fontSizesFor: aStyleName) asArray storeString.		aStream cr].	(StringHolder new contents: aStream contents)		openLabel: 'Font styles and sizes'! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:49'!windowFromMenu: aMenu target: aTarget title: aTitle	"Supply a default list of colors"	^ self windowFromMenu: aMenu target: aTarget title: aTitle		colorPattern: #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange)! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:48'!windowFromMenu: aMenu target: aTarget title: aTitle colorPattern: aColorPattern	| labelList targetList selectionList i |	selectionList _ aMenu selections.	labelList _ (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList _  (1 to: selectionList size) collect: [:ind | aTarget].	(i _ labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList _ selectionList copyReplaceFrom: i to: i with: Array new.		labelList _ labelList copyReplaceFrom: i to: i with: Array new.		targetList _ targetList copyReplaceFrom: i to: i with: Array new].	self windowMenuWithLabels:  labelList colorPattern: aColorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:44'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ WorldMorph new.	colorList _  (1 to: labelList size) collect:		[:ind | Color perform: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents: newContents	contents _ newContents.	self changed: #contents! !Serves as the container for displaying one or more viewers in a tabbed palette.!!ViewerBook methodsFor: 'all' stamp: 'sw 6/19/1998 18:25'!partsViewer	^ submorphs size == 0 ifTrue: [nil] ifFalse: [submorphs first]! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/21/1998 23:21'!repelsMorph:  aMorph event: evt	^ true! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/1/1998 18:04'!setPlayer: aPlayer	| aPartsViewer |	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "viewer cache soon"	"self presenter viewerCache at: aPlayer ifPresent:		[^ self ".	self world "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky).	aPartsViewer setPlayer: aPlayer.	self presenter coloredTilesEnabled ifFalse:		[aPartsViewer makeAllTilesGreen].	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 17:29'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol _ points last y * decayScale.			mSecsForChange _ 0.			nextRecomputeTime _ mSecs + 1000000.			^ self].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime _ loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 4.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 9/10/1998 07:04'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 08:00'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale _ aNumber asFloat.! !This tool was created to aid in the preparation of LoopedSampledSound objects. It includes support for finding good loop points with a little help from the user.  Namely, the user must identify a good ending point for the loop (typically just before the decay phase begins) and identify one cycle of the waveform. After that, the  "choose loop point" menu command can be invoked to search backwards to find and rank all possible loop starting points. Some experimentation is usually required to find a loop that "breaths" in a natural way.This tool can also be used as a general viewer of numerical sequences of any kind, such as time-varying functions, FFT data, etc.!!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 09:16'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';					actionSelector: #delete).	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';				actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After';			actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Play Loop';			actionSelector: #playLoop).	r addMorphBack: (b fullCopy label: 'Test';				actionSelector: #playTestNote).	r addMorphBack: (b fullCopy label: 'Save';				actionSelector: #saveInstrument).	r addMorphBack: (b fullCopy label: 'Set Loop End';		actionSelector: #setLoopEnd).	r addMorphBack: (b fullCopy label: 'One Cycle';			actionSelector: #setOneCycle).	r addMorphBack: (b fullCopy label: 'Set Loop Start';		actionSelector: #setLoopStart).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m _ Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 8/17/1998 20:31'!addLoopPointControls	| r m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Loop end: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop length: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop cycles: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Frequency: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 08:27'!initialize	super initialize.	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"	self extent: 5@5;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ GraphMorph new extent: 450@100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:43'!chooseLoopStart	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...'			during: [possibleLoopStarts _ self findPossibleLoopStartsFrom: graph cursor]].	bestLoops _ possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu _ CustomMenu new.	bestLoops do: [:entry |		secs _ ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: secs printString, ' secs' action: entry].	choice _ menu startUp.	choice ifNil: [^ self].	loopCycles _ choice at: 3.	start _ self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:04'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('play straight through'		play)		('play before cursor'		playBeforeCursor)		('play after cursor'			playAfterCursor)		('play test note'				playTestNote)		('play loop'					playLoop)		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		('choose loop start'			chooseLoopStart)		('jump to loop start'			jumpToLoopStart)		('jump to loop end'			jumpToLoopEnd)		('make unlooped'			setUnlooped)		('make unpitched'			setUnpitched)		('show envelope'			showEnvelope)		('show FFT'					showFFTAtCursor)).	aMenu invokeOn: self defaultSelection: nil.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:42'!jumpToLoopEnd	graph cursor: loopEnd; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 10:09'!jumpToLoopStart	graph cursor: (loopEnd - loopLength) truncated; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 09:23'!play	graph data size < 2 ifTrue: [^ self].	(SampledSound samples: graph data samplingRate: samplingRate) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:40'!playAfterCursor	self playFrom: graph cursor to: graph data size.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:39'!playBeforeCursor	self playFrom: 1 to: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz _ graph data size.	i1 _ ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 _ (loopEnd min: sz) max: i1.	len _ (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd _ LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data _ graph data.	end _ (loopEnd min: data size) max: 1.	snd _ LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur _ (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur _ (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 14:24'!saveInstrument	| name data end snd basePitch |	name _ FillInTheBlank request: 'Instrument name?'.	name isEmpty ifTrue: [^ self].	data _ graph data.	((loopEnd = 0) or: [loopLength = 0])		ifTrue: [  "save as unlooped"			loopLength * loopCycles = 0				ifTrue: [basePitch _ 100.0]				ifFalse: [basePitch _ (samplingRate * loopCycles) / loopLength].			snd _ LoopedSampledSound new				unloopedSamples: data pitch: basePitch samplingRate: samplingRate]		ifFalse: [			end _ (loopEnd min: data size) max: 1.			basePitch _ (samplingRate * loopCycles) / loopLength.			snd _ LoopedSampledSound new				samples: data loopEnd: end loopLength: loopLength				pitch: basePitch samplingRate: samplingRate].	snd addReleaseEnvelope.	AbstractSound soundNamed: name put: snd.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 11:06'!setLoopEnd	graph cursor: (self zeroCrossingAfter: graph cursor) - 1.	self loopEnd: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 08:21'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start _ graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.'].	len _ (loopEnd - start) + 1.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len _ loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles _ 1.		self loopLength: len].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength _ 0.	loopCycles _ 1.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength _ 0.	loopCycles _ 0.	perceivedFrequency _ 100.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuanta."	| data mSecsPerQuanta samplesPerQuanta result endOfQuanta maxThisQuanta s |	data _ graph data.	mSecsPerQuanta _ 10.	samplesPerQuanta _ (mSecsPerQuanta / 1000.0) * self samplingRate.	result _ WriteStream on: (Array new: data size // samplesPerQuanta).	endOfQuanta _ samplesPerQuanta.	maxThisQuanta _ 0.	1 to: data monoSampleCount do: [:i |		i asFloat > endOfQuanta ifTrue: [			result nextPut: maxThisQuanta.			maxThisQuanta _ 0.			endOfQuanta _ endOfQuanta + samplesPerQuanta].		s _ data at: i.		s < 0 ifTrue: [s _ 0 - s].		s > maxThisQuanta ifTrue: [maxThisQuanta _ s]].	WaveEditor openOn: result contents.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:21'!showFFTAtCursor	| data start availableSamples nu n fft r |	data _ graph data.	start _ graph cursor max: 1.	availableSamples _ (data size - start) + 1.	nu _ 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.'].	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r _ (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	WaveEditor openOn: r.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:48'!trimAfterCursor	graph data: (graph data copyFrom: 1 to: graph cursor).! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:52'!trimBeforeCursor	graph data: (graph data copyFrom: graph cursor to: graph data size).	graph cursor: 1.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/5/1998 12:43'!data: newData	graph data: newData.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/3/2004 18:16'!graph	^ graph! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 09:48'!loopCycles	^ loopCycles! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles _ aNumber.	self loopLength: loopLength.  "updates frequency"! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 6/30/1998 17:20'!loopEnd	^ loopEnd! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd _ (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts _ nil.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 08:38'!loopLength	^ loopLength! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength _ aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency _ samplingRate asFloat * loopCycles / loopLength].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 10:08'!loopStart	^ (loopEnd - loopLength) truncated + 1! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start _ self fractionalLoopStartAt: index.	len _ (loopEnd asFloat - start) + 1.0.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:31'!perceivedFrequency	^ perceivedFrequency! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency _ aNumber.	(loopCycles > 0) ifTrue: [		loopLength _ samplingRate asFloat * loopCycles / perceivedFrequency].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate	^ samplingRate! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate _ samplesPerSecond.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data _ graph data.	error _ 0.	i1 _ index1.	index2 to: (index2 + length - 1) do: [:i2 |		e _ (data at: i1) - (data at: i2).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e.		i1 _ i1 + 1].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error _ 0.	1 to: sampleArray1 size do: [:i |		e _ (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:25'!findPossibleLoopStartsFrom: index	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r _ OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart _ loopEnd + 1.  "Assumed to be a zero-crossing."	i _ self zeroCrossingAfter: postLoopCycleStart + (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength _ i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i _ self zeroCrossingAfter: postLoopCycleStart - (1.1 * postLoopCycleLength) asInteger.	cycleLength _ postLoopCycleStart - i.	cycleCount _ 1.	[cycleLength > 0] whileTrue: [		err _ self autoCorrolationBetween: i and: postLoopCycleStart length: postLoopCycleLength.		r add: (Array				with: i				with: err				with: cycleCount				with: (((loopEnd - i) asFloat / self samplingRate) roundTo: 0.01)).		oldI _ i.		i _ self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.		cycleLength _ oldI - i.  "will be zero when start of data is encountered"		cycleCount _ cycleCount + 1].	r _ r asSortedCollection: [:e1 :e2 | (e1 at: 2) < (e2 at: 2)].	^ r asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle _ (samplingRate / perceivedFrequency) rounded.	w1 _ self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr _ SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 _ self interpolatedWindowAt: i width: oneCycle.		err _ self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex _ i.			minErr _ err]].	^ bestIndex! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale _ 10000.	data _ graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex _ index truncated.	scaledFrac _ ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac _ scale - scaledFrac.	prevSample _ data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample _ data at: i.		v _ ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample _ nextSample.		v].! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/19/1998 15:03'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/30/1998 16:11'!scrollTime: relativeValue	graph startIndex: relativeValue * (graph data size - (graph width // 2)).! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data _ graph data.	end _ data size.	index <= 1 ifTrue: [^ 1].	i _ index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i _ i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i _ i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i _ i + 1].  "find next non-negative sample"	^ i! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 21:04'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	(self new data: dataCollection) openInWorld.! !A viewer for a collection of URLs for SqueakPages. Pages can be stepped through in sequence or a bookmark can be used to jump to a specific page.!!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:35'!initialize	super initialize.	self setInitialState.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!WebBookMorph methodsFor: 'initialization' stamp: 'sw 6/25/1998 17:01'!removeEverything	self setInitialState.	urls _ OrderedCollection new.	self removeAllMorphs! !!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:18'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	urls _ OrderedCollection new.	currentURL _ nil.	currentContents _ nil.	pageSize _ 200@250.! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 14:04'!currentPage	^ currentContents! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 14:28'!urls	^ urls! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/25/1998 13:27'!urls: urlList	urls _ urlList copy asOrderedCollection.	self class turnOffSoundWhile: [		urls size = 0 ifTrue: [self insertPage].		self goToPage: 1].! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 15:21'!acceptSortedContentsFrom: aHolderMorph	"Update my url list from the given page sorter."	| newURLs |	newURLs _ urls species new.	aHolderMorph submorphsDo: [:m |		(m isKindOf: URLMorph) ifTrue: [newURLs add: m url]].	urls _ newURLs.	urls isEmpty ifTrue: [^ self insertPage].	self goToPage: aHolderMorph cursor.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 22:23'!bookmarksForAllPages	| mList sorter |	mList _ self morphsForPageSorter.	mList do: [:m | m isBookmark: true; book: self].	sorter _ BookPageSorterMorph new book: self morphsToSort: mList.	sorter closeButtonOnly.	sorter pageHolder cursor: (urls indexOf: currentURL ifAbsent: [0]).	self presentResultMorph: sorter.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'sw 7/4/1998 16:07'!indexOfCurrentPage	^ urls indexOf: currentURL ifAbsent: [0]! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/16/1998 18:18'!morphsForPageSorter	| pg sorterMorphs |	sorterMorphs _ OrderedCollection new: urls size.	urls do: [:url |		pg _ SqueakPageCache atURL: url ifAbsent: [nil].		pg ifNotNil: [sorterMorphs addLast: (URLMorph newForURL: url)]].	^ sorterMorphs! !!WebBookMorph methodsFor: 'menu' stamp: 'jm 6/17/1998 22:25'!invokeBookMenu	"Answer the menu for the the book-control panel."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('save page'					savePage)		('reload page'				reloadPage)		('bookmark for this page'	bookmarkForThisPage)		('bookmarks for all pages'	bookmarksForAllPages)		('sort pages'					sortPages)		('text'						newTextMorph)		('hide page controls'			hidePageControls)		('save book'					saveBookToFile)).	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu invokeOn: self defaultSelection: nil.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!bookmarkForThisPage	"Make a Bookmark for the current URL."	| b |	currentURL ifNil: [^ self].	self savePage.	b _ URLMorph newBookmarkForURL: currentURL.	self presentResultMorph: b.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 14:50'!deletePage	| oldURL |	(self confirm: 'Really delete this page?') ifFalse: [^ self].	oldURL _ currentURL.	self nextPage.	urls remove: oldURL ifAbsent: [].	urls isEmpty ifTrue: [self insertPage].! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:37'!goToPage: pageNumber	| i |	urls isEmpty ifTrue: [^ self].	i _ pageNumber asInteger.	pageNumber < 1 ifTrue: [i _ urls size].	pageNumber > urls size ifTrue: [i _ 1].	self goToURL: (urls at: i).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 11:57'!goToURL: aURLString	| newIndex ascending oldIndex pg |	newIndex _ urls indexOf: aURLString.	newIndex = 0		ifTrue: [ascending _ nil]		ifFalse: [			oldIndex _ urls indexOf: currentURL ifAbsent: [0].			ascending _ newIndex > oldIndex].	self savePageIfNecessary.	pg _ SqueakPageCache atURL: aURLString ifAbsent: [^ self].	currentURL _ aURLString.	self revealPage: pg contentsMorph ascending: ascending.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 18:20'!lastPage	self goToPage: urls size.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!newTextMorph	"Create a new, empty TextMorph that can be placed in this book."	self presentResultMorph: (TextMorph new extent: currentContents width@30).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!nextPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [0]) + 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!previousPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [2]) - 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 12:46'!reloadPage	"Reload the current page."	currentContentsChanged _ false.  "don't ask about changes"	self goToURL: currentURL. ! !!WebBookMorph methodsFor: 'commands' stamp: 'tk 8/13/1998 13:11'!saveBookToFile	"Save this book in a file."	| fileName fileStream |	self ensurePagesAreExternal ifFalse: [^ self].	fileName _ FillInTheBlank request: 'File name for this Book?'.	fileName isEmpty ifTrue: [^ self].  "abort"	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: fileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:45'!savePage	"Save the current page."	currentContentsChanged _ true.  "force save to happen"	self savePageIfNecessary.! !!WebBookMorph methodsFor: 'commands' stamp: 'tk 8/13/1998 13:16'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentContents ifNotNil:		[newPagePrototype _ currentContents veryDeepCopy].! !!WebBookMorph methodsFor: 'updating' stamp: 'jm 6/25/1998 12:44'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| myPage |	myPage _ SqueakPageCache atURL: currentURL ifAbsent: [nil].	myPage == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	currentContentsChanged ifFalse: [		myPage contentsMorph == originalContents ifTrue: [^ self].		self class turnOffSoundWhile: [self goToURL: currentURL]]. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/16/1998 18:21'!ensurePagesAreExternal	"Check that all the pages referred to by this book have external homes, and answer false if they do not. Answer true if all pages have external homes or if the user decides to proceed anyway. Pages without external homes will be missing when the book is read back in."	self halt: 'not yet implemented'.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:07'!insertPageColored: aColor	| sz bw bc newContents newURL |	newPagePrototype		ifNil: [			currentContents				ifNil: [					sz _ pageSize.					bw _ 0.					bc _ Color blue muchLighter]				ifNotNil: [					sz _ currentContents extent.					bw _ currentContents borderWidth.					bc _ currentContents borderColor].			newContents _ PasteUpMorph new extent: sz; color: aColor.			newContents borderWidth: bw; borderColor: bc]		ifNotNil: [			newContents _ newPagePrototype veryDeepCopy].	newContents resizeToFit: false.	newURL _ SqueakPage newURLAndPageFor: newContents.	urls isEmpty		ifTrue: [urls add: newURL]		ifFalse: [urls add: newURL after: currentURL].	self nextPage.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:05'!insertPageLabel: labelString morphs: morphList	| pg m c labelAllowance |	self insertPage.	pg _ currentContents.	labelString ifNotNil:			[m _ (TextMorph new extent: pg width@20; contents: labelString).		m lock.		m position: pg position + (((pg width - m width) // 2) @ 5).		pg addMorph: m.		labelAllowance _ 40]		ifNil:			[labelAllowance _ 0].	"use a column to align the given morphs, then add them to the page"	c _ AlignmentMorph newColumn centering: #center.	c addAllMorphs: morphList.	c position: pg position + (0 @ labelAllowance).	pg addAllMorphs: morphList.	^ pg! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:10'!layoutChanged	super layoutChanged.	currentContentsChanged _ true.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 22:22'!presentResultMorph: aMorph	"Add the given morph to the world."	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:07'!revealPage: aMorph ascending: ascending	| w r oldOrigin |	w _ self world.	w ifNotNil: [self primaryHand newKeyboardFocus: nil].	currentContents ifNotNil: [		(r _ currentContents screenRectangle) ifNotNil: [oldOrigin _ r origin].		currentContents delete].	originalContents _ aMorph.	currentContents _ aMorph veryDeepCopy.	self addMorphBack: currentContents.	w ifNotNil: [		w startSteppingSubmorphsOf: currentContents.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	currentContentsChanged _ false.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:16'!savePageIfNecessary	"About to go to a new page; save the current page if necessary."	| oldPage morphToSave |	currentContentsChanged ifNil: [currentContentsChanged _ false].	currentContentsChanged ifFalse: [		"no need to save, but do release cached state of viewed page"		originalContents allMorphsDo: [:m | m releaseCachedState].		^ self].	oldPage _ SqueakPageCache atURL: currentURL ifAbsent: [^ self].	oldPage contentsMorph ~~ originalContents ifTrue: [		(self confirm: 'Someone else has changed this page; save this copy?')			ifFalse: [^ self]].	morphToSave _ currentContents fullCopy.		self flag: #noteToTed.	"Must use veryDeepCopy.  Saving must write Player code too."  	currentContentsChanged _ false.	originalContents _ morphToSave.	oldPage saveMorph: morphToSave author: Utilities authorInitials. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:31'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	| f |	((ascending == nil) | (oldOrigin == nil) | (currentContents == nil))		ifTrue: [^ self].	PageFlipSoundOn ifTrue: [		f _ currentContents imageForm.		self playPageFlipSound.		Display wipeImage: f				at: oldOrigin				delta: (ascending ifTrue: [0@-10] ifFalse: [0@10])].! !!WebBookMorph class methodsFor: 'all' stamp: 'sw 6/25/1998 17:25'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: Color white.	book borderWidth: 1; borderColor: Color black.	book showPageControls; insertPage.	book layoutChanged.	^ book! !!WebBookMorph class methodsFor: 'all' stamp: 'jm 9/24/97 08:42'!initialize	"WebBookMorph initialize"	PageFlipSoundOn _ true.! !!WebBookMorph class methodsFor: 'all' stamp: 'tk 8/13/1998 13:06'!newFromOldBook: oldBookMorph	"Make a new instance of me whose pages are copies of the pages in the given book. Does not modify the original book."	| urlList |	urlList _ oldBookMorph pages collect:		[:oldPg | SqueakPage newURLAndPageFor: oldPg veryDeepCopy].	^ self new urls: urlList! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 9/14/1998 12:36'!configureForConstruction	| aPanel aCan |	self addMorph: (self presenter newStandardPartsBin position: 10@10).	presenter standardPlayer.	aPanel _ presenter controlPanel.	self addMorph: aPanel.	self positionControlPanel: aPanel.	aCan _ self presenter addTrashCan.	aCan position: (Display boundingBox bottomRight - aCan extent).  "This oddity necessary to avoid the trashcan's showing up at top-left until an ownerChanged is sent to it; the problem is that addTrashCan: is called too early otherwise."! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 07:29'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	balloonHelpEnabled _ true.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 9/21/1998 17:55'!openWithTitle: aString cautionOnClose: aBoolean	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString cautionOnClose: aBoolean! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/3/1998 14:12'!positionControlPanel: aPanel	| referencePos |	referencePos _ bounds width > 200		ifTrue:		[bounds bottomRight]		ifFalse:		[Display boundingBox bottomRight].	aPanel position:  (referencePos - ((70 + aPanel width) @ (aPanel height + 4)))! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!exit	self sleep.	Project current exit.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!goBack	self sleep.	Project returnToPreviousProject.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 9/10/1998 16:38'!sleep	canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this project to save space?']) ifTrue: [self clearTurtleTrails].	self canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 8/16/1998 00:12'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 9/10/1998 16:27'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: viewBox extent).	damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				(mm fullBounds intersects: r) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'events' stamp: 'jm 6/10/1998 07:57'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.	evt hand invokeMetaMenu: evt.! !!WorldMorph methodsFor: 'stepping' stamp: 'sw 8/21/1998 16:32'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: self]]! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/14/1998 12:56'!activeHand: aHandMorph	activeHand _ aHandMorph! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/12/1998 08:21'!doOneCycle	self interCyclePause.	self doOneCycleNow.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:50'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	lastCycleTime _ Time millisecondClockValue.	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:45'!interCyclePause	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	MinCycleLapse ifNotNil: [		lastCycleTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastCycleTime + MinCycleLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinCycleLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 8/22/1998 22:45'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	refPoint _ (aPalette _ self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'sensing' stamp: 'di 9/9/1998 22:45'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	^ (self patchAt: (aPoint extent: 1@1) belowMorph: aMorph) colorAt: 0@0! !!WorldMorph methodsFor: 'sensing' stamp: 'di 9/9/1998 22:43'!patchAt: patchRect belowMorph: aMorph	"Return the image of the given patch rectangle immediately behind the given morph."	| c root |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsIn: patchRect) reverseDo:				[:subM |				subM == aMorph ifTrue: [^ c form].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsIn: patchRect) reverseDo:					[:subM |					subM == aMorph ifTrue: [^ c form].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'sw 7/19/1998 12:46'!addMorphsAndModel: aMorphOrList	"Dump in submorphs, model, and stepList from aMorphOrList.  Used to bring a world, paste-up, or other morph in from an object file."	aMorphOrList isMorph		ifTrue:			[aMorphOrList isWorldMorph				ifFalse:					["one morph, put on hand"					"aMorphOrList installModelIn: self.  	a chance to install model pointers"					aMorphOrList privateOwner: nil.					self hands first attachMorph: aMorphOrList.					self startSteppingSubmorphsOf: aMorphOrList]				ifTrue: 					[model == nil						ifTrue:							[self setModel: (aMorphOrList modelOrNil)]						ifFalse:							[aMorphOrList modelOrNil ifNotNil:								[aMorphOrList modelOrNil privateOwner: nil.								self addMorph: (aMorphOrList modelOrNil)]].					aMorphOrList privateSubmorphs reverseDo: [:m |						m privateOwner: nil.						self addMorph: m.						m changed].					(aMorphOrList instVarNamed: 'stepList') do:						[:entry | entry first startSteppingIn: self]]]		ifFalse:  "list, add them all"			[aMorphOrList reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				self startSteppingSubmorphsOf: m.	"It may not want this!!"				m changed]]! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 8/20/1998 22:18'!veryDeepCopyWith: deepCopier	"Does a WorldMorph really need to be veryDeepCopied?  If so, only copy submorphs, model, and stepList.  Lots of special stuff.  See storeDataOn:"	^ self error: 'not specialized yet'! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 6/25/1998 08:35'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts."	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:)				(mouseX			number		readOnly	getMouseX			unused)				(mouseY		number		readOnly	getMouseY			unused))]		ifFalse:			[Array new]! !!WorldMorph methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 17:11'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcebbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' 'balloonHelpEnabled' ) and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 7/15/1998 19:39'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' ) and deal with the information in ()"! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:56'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' 'lastCycleTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('balloonHelpEnabled' ) and deal with the information in ()"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 20:33'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'lastCycleTime' 'balloonHelpEnabled' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!balloonHelpEnabled	^ balloonHelpEnabled ~~ false! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!toggleShowBalloons	balloonHelpEnabled _ self balloonHelpEnabled not! !!WorldMorph class methodsFor: 'all' stamp: 'ls 7/13/1998 00:44'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!WorldMorph class methodsFor: 'all' stamp: 'ls 9/20/1998 11:36'!initialize	"WorldMorph initialize"	self MinCycleLapse: 20.		"allows 50 frames per second..."! !!WorldMorph class methodsFor: 'all' stamp: 'sw 8/3/1998 14:12'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aPanel |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aPanel _ aWorld presenter controlPanel.	aWorld addMorph: aPanel.	aWorld positionControlPanel: aPanel.	aWorld addMorph: ((aWorld presenter newStandardPartsBin) position: 10@10).	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !Serves as a model for a WorldView -- a morphic world viewed within an mvc project.!!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:50'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	^ (0@0 extent: DisplayScreen actualScreenSize) copy! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent	initialExtent ifNotNil: [^ initialExtent].	^ super initialExtent! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent: anExtent	initialExtent _ anExtent! !!WriteStream methodsFor: 'accessing' stamp: 'ls 8/20/1998 10:19'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse: [		^super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue: [		collection _ collection,			(collection species new: (newEnd - writeLimit + (collection size max: 20)) ).		writeLimit _ collection size ].	collection replaceFrom: position+1 to: newEnd  with: aCollection.	position _ newEnd.! !Smalltalk condenseChanges!Browser initialize!----SNAPSHOT----(23 September 1998 5:12:15 pm ) priorSource: 1894817!----QUIT----(23 September 1998 5:13:28 pm ) priorSource: 1894866!'From Squeak 2.2beta of Sept 16, 1998 on 24 September 1998 at 6:41:22 am'!!Utilities class methodsFor: 'fetching updates' stamp: 'tk 9/24/1998 06:26' prior: 22228964!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt _ true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:13:48 am'!!HTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:08' prior: 34035856!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1. ]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>'; cr.]]].	^targetStream contents.! !!LessHTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:11' prior: 34536799!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.]]].	^targetStream contents.! !!URLmap methodsFor: 'private' stamp: 'mjg 9/21/1998 10:47' prior: 35365307!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes it likely to be an image URL"	^(anUpperCasedString endsWith: '.GIF') or:		[(anUpperCasedString endsWith: '.JPEG') or:		[anUpperCasedString endsWith: '.JPG']]! !'From Squeak 2.0 of May 22, 1998 on 23 September 1998 at 11:28:01 pm'!!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:05' prior: 17302009!addClass: class 	"Include indication that a new class was created."	self atClass: class add: #add.	self addCoherency: class name! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:06' prior: 17303270!changeClass: class 	"Include indication that a class definition has been changed. 	 6/10/96 sw: don't accumulate this information for classes that don't want logging	 7/12/96 sw: use wantsChangeSetLogging flag"	class wantsChangeSetLogging ifTrue: 		[			self atClass: class add: #change.			self addCoherency: class name		]! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:16'!verifyClassRemoves	"Verify the internal collection of classes to be	removed. For every class name there, check if	a class named like that exists. If it does, then	remove it from the classRemoves. If it doesn't, 	leave it alone. Use this to fix change sets broken	by classes deleted and then added back.	Also, delete the deleted items that are not symbols (?!!)"	classRemoves _ classRemoves reject: [:one | (Smalltalk at: one ifAbsent: []) isNil not or: [one ~~ one asSymbol]]! !!ChangeSet methodsFor: 'private' stamp: 'SqR!!!! 9/23/1998 23:08'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:22:19 am'!"Change Set:		New ChangesDate:			24 September 1998Author:			Dan IngallsChanged the screenMenu item 'open window...' to 'open...' to differentiate better from the following 'windows...' item."!!HandMorph methodsFor: 'world menu' stamp: 'di 9/24/1998 08:19' prior: 34089726!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: World action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'scripting...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/24/1998 08:18' prior: 35071139!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(	'keep this menu up'			'previous project'			'jump to project...'			'restore display'			'open...'			'windows...'			'changes...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 9)		selections: #(durableScreenMenureturnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:28:50 am'!"Change Set:		shrinkFix-diDate:			24 September 1998Author:			Dan IngallsSeveral tweaks to support for shrinking the system...Fixes a bug in qCompress due to the do: protocol change.Makes discardOddsAndEnds tolerant to missing textStyles in TextConstants.Makes abandonSources disable the warning for no source file (duh)."!!CompiledMethod methodsFor: 'source code management' stamp: 'di 9/23/1998 19:22' prior: 17604218!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 21:55' prior: 21745897!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile.	Smalltalk allBehaviorsDo: [: b | b zapOrganization]."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 18:51' prior: 35264850!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	Smalltalk at: #FormEditor ifPresent: [:c | c removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk at: #SampledSound ifPresent: [:c |		(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [c initialize]].	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k ifAbsent: []].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).! !'From Squeak 2.2 of Sept 23, 1998 on 26 September 1998 at 9:42:20 pm'!"Change Set:		scaleFix-swDate:			26 September 1998Author:			Scott WallaceFixes the bug that could drop you into a debugger if you set the scale of an unflexed morph from a Viewer."!!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/26/1998 21:40' prior: 34865389!setScaleFactor: aNumber	| aCostume |	aCostume _ self costume.	1.0 = aNumber		ifTrue:			[0.0 = self getHeading ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	costume scale: (aNumber asFloat max: 0.125)! !'From Squeak 2.2 of Sept 23, 1998 on 29 September 1998 at 8:12:04 am'!"Change Set:		paintingTweaks-swDate:			29 September 1998Author:			Scott WallaceWhen user chooses 'make new drawing' from the New Morph menu, she now gets an about-to-paint icon attached to the house; the first click lets her choose the receptor for the putative painting.Adds a preference, #unlimitedPaintArea -- if true, no limits are put on the onion-skin area for painting; if false, a nominal limit (given by whatever is returned by Preferences defaultPaintingExtent) is used, in an effort to reduce the likelihood of running out of memory.Also, exclude SketchMorph from the textual New Morph menu"!!HandMorph methodsFor: 'world menu' stamp: 'sw 9/28/1998 17:48' prior: 34093881!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self action: #newDrawingFromMenu.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/28/1998 17:48'!newDrawingFromMenu	self attachMorph: PaintInvokingMorph new markAsPartsDonor! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 9/22/1998 12:26' prior: 34820108!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ self reasonablePaintingExtent.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 9/29/1998 07:35'!reasonablePaintingExtent	^ Preferences unlimitedPaintArea		ifTrue:			[3000 @ 3000]		ifFalse:			[Preferences defaultPaintingExtent]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/29/1998 07:35'!defaultPaintingExtent	"Answer the preferred size for the onion-skin paint area when launching a new painting within a paste-up morph.  Feel free to change the parameters to suit your configuration."	^ 320 @ 240! !!SketchMorph class methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1998 17:15'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !StandardScriptingSystem removeSelector: #reasonablePaintingExtent!StandardScriptingSystem removeSelector: #reasonablePaintingExtent!WorldMorph removeSelector: #reasonablePaintingExtent!"Postscript:"Preferences setPreference: #unlimitedPaintArea toValue: false.!'From Squeak 2.2 of Sept 23, 1998 on 29 September 1998 at 9:56:56 am'!"Change Set:		dropSysWindow-swDate:			29 September 1998Author:			Scott WallaceKeeps system windows from being annoyingly repelled by parts bins, etc, and from being annoyingly embedded in playfields/pages when dropped;  System windows, unless you set a preference to the contrary, generally all live on the world desktop and do not ever wish to be embedded in other morphs.Adds preference 'allowSysWindowEmbedding' -- if true, then SystemWindows will be readily droppable within pasteups, but if not true, system windows will generally be kept at the desktop level, at least when manipulating them via the drag-and-drop UI"!!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 9/29/1998 09:50' prior: 19005407!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto.  Return nil if we must repel the morph.  Return the world, if no other morph wants the dropping morph."	| root coreSample |	root _ nil.	owner submorphsReverseDo: [:m |		((m fullContainsPoint: evt cursorPoint) and:		 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].	root == nil ifTrue: [^ self world].	coreSample _ root morphsAt: evt cursorPoint.	(Preferences allowSysWindowEmbedding not and:		[(aMorph isKindOf: SystemWindow)]) ifTrue: [^ self world].	coreSample do:		[:m |			(m repelsMorph: aMorph event: evt) ifTrue:				[^ nil]].	coreSample do:		[:m |			(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ self world! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/29/1998 09:25' prior: 34811020!repelsMorph: aMorph event: ev	(Preferences allowSysWindowEmbedding not and:		[aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/29/1998 09:29' prior: 34812369!wantsDroppedMorph: aMorph event: evt	(self isPartsBin or: [self openToDragNDrop]) not ifTrue: [^ false].	(self bounds containsPoint: evt cursorPoint) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences allowSysWindowEmbedding not])		ifTrue:	[^ false].	^ true ! !"Postscript:"Preferences setPreference:  #allowSysWindowEmbedding toValue: false!'From Squeak 2.2 of Sept 23, 1998 on 29 September 1998 at 3:05:14 pm'!!DosFileDirectory methodsFor: 'all' stamp: 'tk 9/29/1998 15:05' prior: 33884112!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	(fileName size = 2 and: [fileName first isLetter and: [fileName last = $:]])		ifTrue: [^ fileName].	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue:[''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'msk 9/28/1998 15:51' prior: 34049362!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxyServer _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'examples' stamp: 'msk 9/28/1998 15:52' prior: 34060907!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'msk 9/28/1998 15:52' prior: 34067075!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxyServer _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/24/1998 17:14' prior: 21232343!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'STOR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'store via port ', dd portNum printString; cr.	dd sendData: fileStream contentsOfEntireFile.	dd close.	(rr _ so responseOK) == true ifFalse: [		(rr beginsWith: '426 ') ifTrue: [^ rr, ' (Server may be full.)'].			"Connection closed, transfer aborted"		^ rr].	"150 Opening BINARY mode data connection"	(resp _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"226 Transfer complete."! !HTTPSocket initialize!"Postscript:"(Smalltalk allCallsOn: (HTTPSocket classPool associationAt: #HTTPProxy ifAbsent: [#HTTPProxy])) isEmpty ifFalse: [	self notify: 'there should be no references left to ''HTTPProxy'''].HTTPSocket classPool removeKey: #HTTPProxy ifAbsent: [].!'From Squeak 2.2 of Sept 23, 1998 on 29 September 1998 at 10:24:05 pm'!"Change Set:		TweaksFor2.2-diDate:			29 September 1998Author:			Dan IngallsSeveral minor tweaks for the 2.2 release...Make lowSpaceWatcher work when Morphic has been removed.Amend the set of messages retained by majorShrink.Allow invalidRect: to propagate in an inactive WorldMorph.Allow quitting a system with a mail reader that has been moved away from its files.Make prettyPrinting work in ChangeSorters.Better (?) choice of colors for shift-prettyPrinting."!!MessageFile methodsFor: 'file operations' stamp: 'di 9/29/1998 16:01' prior: 34638332!save	"Make sure the message file is flushed to disk. This is NOT atomic because MessageFiles can get large and there might not be enough disk space to save them atomically. Besides, it would be very slow."	file ifNil: [^ self].	file ensureOpen.	file closed  "Will still be closed if no file present"		ifFalse: [file setToEnd; close; reopen].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/29/1998 20:09' prior: 34785690!prettyPrint	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model selectedMessageName ifNil: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParseNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:08' prior: 20490989!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	"Show comments in red"	aStream withAttribute: (TextColor color: Color red)		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!BlockNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:11' prior: 17075808!printArgumentsOn: aStream indent: level	arguments size = 0		ifFalse: 			[arguments do: 				[:arg | 				aStream nextPut: $:.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: arg key].				aStream space].			aStream nextPutAll: '| '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/24/1998 14:00' prior: 21751572!lastRemoval  "Smalltalk lastRemoval"	#(abandonSources browseAllSelect: printSpaceAnalysis browseObsoleteReferences  lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/24/1998 14:00' prior: 35276367!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(browseAllSelect: printSpaceAnalysis lastRemoval		dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 9/24/1998 16:33' prior: 35277732!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Smalltalk isMorphic			ifTrue: [Project current interruptName: 'Space is low']			ifFalse: [ScheduledControllers interruptName: 'Space is low']! !!VariableNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:13' prior: 22268628!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color blue)		do: [aStream nextPutAll: name].! !!TempVariableNode methodsFor: 'printing' stamp: 'di 9/29/1998 22:06' prior: 21932587!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color green)			do: [aStream nextPutAll: name]! !!WorldMorph methodsFor: 'change reporting' stamp: 'di 9/29/1998 21:08' prior: 22354994!invalidRect: damageRect	"Record the given rectangle in the damage list."	damageRecorder == nil ifTrue: [^ self].	damageRecorder recordInvalidRect: damageRect.! !'From Squeak 2.2 of Sept 23, 1998 on 30 September 1998 at 12:41:40 pm'!"Change Set:		unscriptedFix-swDate:			30 September 1998Author:			Scott WallaceFixes the bug that had added inst vars and methods to vanilla UnscriptedPlayer class (the metaclass) when executing the Try button associated with a method that had a player reference in it, such as 'car move toward dot'.  This update removes the bug and also patches up the instance structure of UnscriptedPlayer class and its method dictionary to get rid of whichever undesired inst vars and methods may have accumulated in the host image because of the bug."!UnscriptedPlayer class	instanceVariableNames: 'ephemeralPlayerRef '!!UnscriptedPlayer class methodsFor: 'reference' stamp: 'sw 9/30/1998 09:14'!ephemeralPlayerRef	"UnscriptedPlayer ephemeralPlayerRef"	^ ephemeralPlayerRef! !!UnscriptedPlayer class methodsFor: 'reference' stamp: 'sw 9/30/1998 09:05'!referenceSelectorFor: anObject	"The use of this is for immediate evaluation of lines of script in a Viewer.  The class inst var 'ephemeralPlayerRef' is constantly reused for this purpose."	ephemeralPlayerRef _ anObject.	^ 'ephemeralPlayerRef'! !!ViewerBook methodsFor: 'all' stamp: 'sw 9/30/1998 12:39' prior: 35397717!setPlayer: aPlayer	| aPartsViewer |	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "deploy viewer cache soon"	self presenter associatedMorph "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky).	aPartsViewer setPlayer: aPlayer.	self presenter coloredTilesEnabled ifFalse:		[aPartsViewer makeAllTilesGreen].	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1! !"Postscript:"(UnscriptedPlayer class selectors select:		[:aSel | aSel beginsWith: 'refU'])	do:		[:aSel | UnscriptedPlayer class removeSelector: aSel].UnscriptedPlayer class instanceVariableNames: 'ephemeralPlayerRef'!'From Squeak 2.2 of Sept 23, 1998 on 1 October 1998 at 3:58:09 pm'!"Change Set:		MorphicFixes-diDate:			30 September 1998Author:			Dan IngallsMakes the default color for DropShadows be black.Makes HandMorph>>grabMorph: work properly when grabbing from a flexed context.Makes implementors of wantsDroppedMorph:event: transform global coordinates.Makes black and brown-handled moves work properly in flexed contexts.Makes command-drag work properly in flexed contexts.Makes colorUnder work properly in flexed contexts, 	at least to the extent that fullDrawOn has not been overridden.Improves accuracy of flexMorph bounds and responsiveness during flexing.Makes color:sees: and touchesColor: work correctly in flexes."!!CompositeTransform methodsFor: 'transformations' stamp: 'di 10/1/1998 13:51' prior: 17637481!invert: aPoint	^ globalTransform invert: (localTransform invert: aPoint)! !!Morph methodsFor: 'drawing' stamp: 'di 9/30/1998 15:34' prior: 34671246!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		["draw back-to-front"		submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  ! !!Morph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:42'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	(aCanvas isVisible: self fullBounds) ifFalse: [^ false].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		["draw back-to-front"		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere)								ifTrue: [^ true]]]].  	^ false! !!Morph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:53'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect hitStop |	rect _ self fullBounds.	canvas _ FormCanvas extent: rect extent depth: Display depth.	hitStop _ self fullDrawOn: (canvas copyOffset: rect topLeft negated)					without: stopMorph andStopThere: stopThere.	^ Array with: (canvas form offset: rect topLeft)			with: hitStop! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 10:37'!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) transform: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 12:11'!positionInWorld	^ self pointInWorld: self position.! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:10' prior: 34674947!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map patchBelowMe tfm morphAsFlexed i1 |	"Make a mask with black where sensitiveColor is, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	myImage _ morphAsFlexed imageForm offset: 0@0.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ Bitmap new: (1 bitShift: (myImage depth min: 15)).	map at: (i1 _ sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form at: 0@0 colorMap: map.	"get an image of the world below me"	patchBelowMe _ self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false."sensitivePixelMask displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: i1 put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: patchBelowMe boundingBox		from: patchBelowMe at: 0@0 clippingBox: patchBelowMe boundingBox		rule: Form and fillColor: nil map: map."sensitivePixelMask displayAt: 200@0."	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:54' prior: 34677042!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm tfm morphAsFlexed |	"Make a sahdow mask with black in my shape, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	shadowForm _ morphAsFlexed shadowForm offset: 0@0.	"get an image of the world below me"	patchBelowMe _ (self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false) offset: 0@0."shadowForm displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map."shadowForm displayAt: 200@0."	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:43' prior: 19919051!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^ (self valueOfProperty: #openToDragAndDrop) == true! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38' prior: 33661593!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!DropShadowMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 08:21' prior: 17924718!initialize	super initialize.	self color: Color black.	shadowOffset _ 3@3! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 11:32' prior: 18975015!doDrag: evt with: dragHandle	target setConstrainedPositionFrom:		(target pointFromWorld: evt cursorPoint - positionOffset).! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 12:07' prior: 18977908!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - target positionInWorld.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 9/30/1998 10:44' prior: 34087713!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		newOwner _ self dropTargetFor: m event: evt.		newOwner ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		morphToDrop _ newOwner morphToDropFrom: m. 		morphToDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm transform: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 9/30/1998 12:39' prior: 34089013!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	localPt _ m pointFromWorld: self position.	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'special gestures' stamp: 'di 9/30/1998 12:06' prior: 34110629!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph positionInWorld.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom:					(mouseDownMorph pointFromWorld: self position - targetOffset)].! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38' prior: 35472180!wantsDroppedMorph: aMorph event: evt	(self isPartsBin or: [self openToDragNDrop]) not ifTrue: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences allowSysWindowEmbedding not])		ifTrue:	[^ false].	^ true ! !!TabbedPalette methodsFor: 'user-interface' stamp: 'di 9/30/1998 10:39' prior: 35313060!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TextContainer methodsFor: 'container protocol' stamp: 'di 9/30/1998 23:17' prior: 21970514!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	self shadowForm.  "Compute the shape".	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/1/1998 15:54' prior: 35346319!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageFormDepth: aCanvas depth.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:53'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect pair hitStop |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas without: stopMorph andStopThere: stopThere)								ifTrue: [^ true]]]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | m == stopMorph ifTrue: [stopThere ifTrue: [^ true]].			pair _ m imageFormWithout: stopMorph andStopThere: stopThere.			imageForm _ pair first.			hitStop _ pair second.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits.			hitStop ifTrue: [stopThere ifTrue: [^ true]]]].	^ false! !!TransformationMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 23:12'!flexing: aMorph byTransformation: tfm	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	(aMorph isKindOf: TransformationMorph)		ifTrue: [aMorph submorphsDo: [:m | self addMorph: m clone]]		ifFalse: [self addMorph: aMorph].	transform _ tfm.	self chooseSmoothing.	self layoutChanged.! !!TransformationMorph methodsFor: 'change reporting' stamp: 'di 9/30/1998 15:12' prior: 22137878!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (Rectangle merging:					(self submorphs collect:						[:m | transform invertRect: m fullBounds]))				expandBy: 1].	super layoutChanged! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:49' prior: 35349156!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ self referencePosition.	changeBlock value.	self chooseSmoothing.	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:48'!chooseSmoothing	"Choose appropriate smoothing, after a change of scale or rotation."	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1]! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/1/1998 12:02' prior: 35441476!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	^ (self patchAt: (aPoint extent: 1@1) without: aMorph andNothingAbove: true)		colorAt: 0@0! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/1/1998 12:01'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	submorphs reverseDo:		[:m | (m fullDrawOn: c without: stopMorph andStopThere: stopThere)				ifTrue: [^ c form]].  	hands reverseDo: [:h |		h submorphsReverseDo:		[:m | m == stopMorph			ifTrue: [stopThere ifTrue: [^ c form]]			ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)						ifTrue: [^ c form]]]].  	^ c form! !Morph removeSelector: #morphsIn:!Morph removeSelector: #morphsIn:!Morph removeSelector: #morphsIn:addTo:!Morph removeSelector: #morphsIn:addTo:!TransformMorph removeSelector: #morphsIn:addTo:!TransformMorph removeSelector: #morphsIn:addTo:!WorldMorph removeSelector: #patchAt:belowMorph:!WorldMorph removeSelector: #patchAt:belowMorph:!'From Squeak 2.2 of Sept 23, 1998 on 2 October 1998 at 12:12:53 pm'!"Change Set:		MorphicFixes2-diDate:			2 October 1998Author:			Dan IngallsChanged the TransformMorph #invertRect: to #invertBoundsRect:	to clarify that it returns the resulting outer bounds.Aggregated submorph display in TransformMorph (much faster).Passed depth to subCanvas in TransformMorph>>fullDispOn:without.."!!Morph methodsFor: 'drawing' stamp: 'di 10/2/1998 08:54' prior: 34670720!flash	| w |	w _ self world.	w ifNotNil:		[Display flash: (((self transformFrom: w) invertBoundsRect: bounds)								translateBy: w viewBox origin)].! !!Morph methodsFor: 'geometry' stamp: 'di 10/2/1998 08:54' prior: 19913997!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) invertBoundsRect: bounds.! !!Morph methodsFor: 'geometry' stamp: 'di 10/2/1998 08:54' prior: 19914704!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) invertBoundsRect: self fullBounds.! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/2/1998 08:57'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		^ outerRect expandBy: 1]! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/2/1998 08:54' prior: 20019727!invertRect: aRectangle	self error: 'method name changed to emphasize enclosing bounds'.	^ self invertBoundsRect: aRectangle! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/2/1998 09:09'!transformBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from global to local coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self transform: aRectangle topLeft)			corner: (self transform: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self transform: p]).		^ outerRect expandBy: 1]! !!PluggableListMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 08:54' prior: 20704873!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) invertBoundsRect: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 10/2/1998 08:54' prior: 34911189!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform invertBoundsRect: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 09:58' prior: 35499337!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform transformBoundsRect: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo:			[:m | m fullDrawOn: offsetCanvas].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits]	! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 11:26' prior: 35500291!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform transformBoundsRect: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !!TransformMorph methodsFor: 'change reporting' stamp: 'di 10/2/1998 08:54' prior: 22133851!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: ((transform invertBoundsRect: damageRect) intersect: bounds)! !!TransformationMorph methodsFor: 'change reporting' stamp: 'di 10/2/1998 08:59' prior: 35502161!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (transform invertBoundsRect:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds])))				expandBy: 1].	super layoutChanged! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/2/1998 11:51' prior: 35503268!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point.	NOTE: due to some bounds wobble in flexing, we take the middle of 3x3 rect."	^ (self patchAt: (aPoint-1 extent: 3) without: aMorph andNothingAbove: true)		colorAt: 1@1! !Morph removeSelector: #imageFormDepth:clippedTo:!Morph removeSelector: #imageFormDepth:without:andStopThere:!'From Squeak 2.2 of Sept 23, 1998 on 2 October 1998 at 3:38:46 pm'!"Change Set:		MorphicFixes3-diDate:			2 October 1998Author:			Dan IngallsMakes halo bounds work better inside flexes.Makes grow, scale and rotate work better inside flexes."!!HaloMorph methodsFor: 'stepping' stamp: 'di 10/2/1998 13:35' prior: 34069006!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target renderedMorph fullBoundsInWorld].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:28' prior: 34070112!addHandles	| box s |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.	self bounds: target renderedMorph fullBoundsInWorld.  "update my size"	box _ (self bounds expandBy: s+1)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color transparent		on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[self addHandleAt: (box rightCenter + (0 @ ((s+2) negated)) min: box rightCenter + box bottomRight // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 13:58' prior: 18975649!doGrow: evt with: growHandle	| newExtent |	newExtent _ (target pointFromWorld: (evt cursorPoint - positionOffset)) - target topLeft.	target extent: (newExtent max: minExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 13:47' prior: 34074223!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	(degrees abs < 1.0) ifTrue: [degrees _ 0.0].	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	target rotationDegrees: (degrees						detentBy: 10.0						atMultiplesOf: 90.0 snap: false).	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:24' prior: 18976872!doScale: evt with: scaleHandle	"Update the scale of my target if it is scalable."	| newExtent newHandlePos |	newHandlePos _ evt cursorPoint - (scaleHandle extent // 2).	newExtent _ (target pointFromWorld: newHandlePos) - target center * 2.	target scaleToFit: ((newExtent max: minExtent) min: Display extent).	target scale = 1.0		ifTrue: [scaleHandle color: Color yellow]		ifFalse: [scaleHandle color: Color orange].	scaleHandle position: newHandlePos.	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 14:01' prior: 18978153!startGrow: evt with: growHandle	"Initialize resizing of my target."	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	positionOffset _ evt cursorPoint - (target pointInWorld: target bottomRight).	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 1@1].! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 14:03' prior: 18978554!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable."	target isFlexMorph ifFalse: [target addFlexShell].	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset _ Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees.! !!HaloMorph methodsFor: 'private' stamp: 'di 10/2/1998 15:26' prior: 18979013!startScale: evt with: scaleHandle	"Initialize scaling of my target."	target isFlexMorph ifFalse: [target addFlexShell].	growingOrRotating _ true.	self removeAllHandlesBut: scaleHandle.  "remove all other handles"	positionOffset _ 0@0.	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 3@3].! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 10/2/1998 15:11' prior: 22137364!scaleToFit: anExtent	| scaleFactor |	scaleFactor _ anExtent r / submorphs first fullBounds extent r.	((scaleFactor - 1.0) abs < 0.05) ifTrue: [scaleFactor _ 1.0].	self scale: ((scaleFactor min: 8.0) max: 0.05).! !'From Squeak 2.2 of Sept 23, 1998 on 3 October 1998 at 12:11:10 am'!"Change Set:		BWMorphic-diDate:			3 October 1998Author:			Dan IngallsA number of fixes that make Morphic work reasonably in B&W, to wit...Made handMorph>>restoreSavedPatch use opaque white in B&W.Made flexes do a prefatory erasure of the (warped) shape of the submorphs."!!Canvas methodsFor: 'drawing' stamp: 'di 10/3/1998 00:01' prior: 33709854!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'di 10/2/1998 21:39'!imageWithOpaqueWhite: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm but with the convention that zero represents opaque white."	self image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form over.! !!Canvas methodsFor: 'private' stamp: 'di 10/2/1998 22:28'!shadowDrawing	^ shadowDrawing! !!FormCanvas methodsFor: 'private' stamp: 'di 10/2/1998 22:27'!stipple	^ shadowStipple! !!HandMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 21:53' prior: 34075607!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 10/2/1998 23:57' prior: 18988198!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas depth = 1			ifTrue: [aCanvas imageWithOpaqueWhite: savedPatch at: savedPatch offset]			ifFalse: [aCanvas image: savedPatch at: savedPatch offset].		((userInitials size = 0) and:		 [(submorphs size = 0) and:		 [temporaryCursor == nil]]) ifTrue: [			"Make the transition to using hardware cursor. Clear savedPatch and			 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"			savedPatch _ nil]].! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/3/1998 00:10' prior: 35508892!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		["Prepare an appropriate warp from patch to innerRect"		innerRect _ self innerBounds.		patchRect _ transform transformBoundsRect:						(aCanvas clipRect intersect: innerRect).		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing.  "installs a colormap if smoothing > 1"		"Render the submorphs visible in the clipping rectangle, as patchForm"		start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])			"If this is true B&W, then we need a first pass for erasure."			ifTrue: [1] ifFalse: [2].		start to: 2 do:			[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"			subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.			i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.						warp combinationRule: Form erase]				ifFalse: [aCanvas shadowDrawing ifTrue:						[subCanvas setShadowDrawing; stipple: aCanvas stipple].						warp combinationRule: Form paint].			offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.			submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].			warp sourceForm: subCanvas form; warpBits.			warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]]! !'From Squeak 2.2 of Sept 23, 1998 on 3 October 1998 at 12:21:48 am'!"Change Set:		FlexBoundsFix-diDate:			3 October 1998Author:			Dan IngallsFlexed bounds required an extra pixel on the right and bottom to cover subsequent truncation of floats."!!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18' prior: 35505975!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18' prior: 35506802!transformBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from global to local coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self transform: aRectangle topLeft)			corner: (self transform: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self transform: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !'From Squeak 2.2 of Sept 23, 1998 on 5 October 1998 at 6:07:25 pm'!"Change Set:		loadFromDisk-swDate:			5 October 1998Author:			Scott WallaceAdds a single menu item to the New Morph menu which will present you with a list of all files loadable as morphs from disk, whether they be .morph files or .gif files or .jpg files, etc."!!HandMorph methodsFor: 'world menu' stamp: 'sw 10/5/1998 18:04' prior: 35467211!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'from a file...' target: self action: #readMorphFromAFile.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self action: #newDrawingFromMenu.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/5/1998 17:59'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:  #('.morph' '.gif' '.bmp' '.jpg' '.form' ) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names must end in .morph, .gif,.bmp, .jpeg, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream oldFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			self world addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ self drawingClass new form: f.			self attachMorph: m]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/5/1998 17:58'!chooseFileWithSuffixFromList: aSuffixList withCaption: aCaption	"Pop up a list of all files in the default directory which have a suffix in the list.  Return #none if there are none; return nil if the user backs out of the menu without making a choice."	"Utilities chooseFileWithSuffixFromList: #('.gif' '.jpg')"	| aList aName |	aList _ OrderedCollection new.	aSuffixList do:		[:aSuffix | aList addAll: (FileDirectory default fileNamesMatching: '*', aSuffix)].	^ aList size > 0		ifTrue:			[aName _ (SelectionMenu selections: aList) startUpWithCaption: aCaption.			aName]		ifFalse:			[#none]! !'From Squeak 2.0 of May 22, 1998 on 6 October 1998 at 8:47:20 am'!"Change Set:		RoundTwo-diDate:			5 October 1998Author:			Dan IngallsAdds a method canvasForSubmorphs: that allows three formerly idiosyncratic implementations of fullDrawOn: to be replaced by simple inheritance of the general method in Morph.Failure to click in a morphic menu should now result in dismissal as expected.Drop shadows are no longer incorrectly affected by text color emphasis.MVC inspect no longer offered in a morphic world (duh).Numerous fixes for flexed SystemWindows, including	Coming to the top when clicked	Only getting control when cursor is over flexed shape	Retaining control when scrollbar flops out of window bounds	Making reshape handles work properly.Introduces a mechanism for retaining ParagraphEditor state across reinstantiation such as happens when an edit causes recomposition due to line break.  This corrects the multiple selections and erroneous screen artifacts.Makes repeated edits and undos work right in morphic, even when line breaks are involved.Makes the find command defeat substitution from a prior change command.Makes text deletion set typing emphasis according to the first character deleted."!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor backgroundColor lastSourceDepth fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!DisplayScanner methodsFor: 'scanning' stamp: 'di 10/5/1998 09:29' prior: 17894004!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern displaying: true.		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:30'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:33' prior: 17901411!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!FormCanvas methodsFor: 'drawing' stamp: 'di 10/5/1998 09:32' prior: 34015845!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c) background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil])		ignoreColorChanges: shadowDrawing.	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!GrafPort methodsFor: 'all' stamp: 'di 10/5/1998 09:31'!displayScannerFor: para foreground: foreColor background: backColor		rule: rule halftone: halftone ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setDestForm: destForm sourceForm: destForm			fillColor: halftone combinationRule: rule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect! !!Morph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:09'!canvasForSubmorphs: canvasForMe	"Provide a canvas for drawing my submorphs.  This may be overridden	to provide for clipping and other related behavior."	^ canvasForMe! !!Morph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:17' prior: 35487841!fullDrawOn: aCanvas	| canvasForSubmorphs |	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'geometry testing' stamp: 'di 10/4/1998 20:53' prior: 19917780!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"	submorphs do: [:m |		m allMorphsDo: [:n |			(n fullContainsPoint: aPoint) ifTrue: [^ true]]].	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'di 10/5/1998 11:50' prior: 34710760!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	aMenu add: 'temp command' action: #tempCommand.	^ aMenu! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 00:37' prior: 34079484!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				self newMouseFocus: m.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 00:57' prior: 34085817!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: [mouseDownMorph owner deleteIfPopUp]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 10/5/1998 11:58' prior: 34100225!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorphInMorphic].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'special gestures' stamp: 'di 10/6/1998 00:38' prior: 34111387!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	self newMouseFocus: nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/6/1998 08:41' prior: 20371163!initialize	"Initialize a new ParagraphEditor."	super initialize.	self initializeYellowButtonMenu.! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13' prior: 34784329!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 23:57'!stateArray	^ (Array with: ChangeText		with: FindText		with: UndoInterval		with: UndoMessage) ,	(Array  with: UndoParagraph		with: UndoSelection		with: Undone) ,	(Array with: self selectionInterval		with: self startOfTyping		with: emphasisHere)! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing' stamp: 'di 10/6/1998 00:02' prior: 20374512!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/5/1998 21:55' prior: 20391455!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:43' prior: 20447971!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [self startOfTyping].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ startBlock stringIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:31' prior: 20449444!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin start stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			start _ startBlock stringIndex.			stop _ stopBlock stringIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:39' prior: 20452254!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ startBlock stringIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!PasteUpMorph methodsFor: 'display' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/5/1998 08:54' prior: 21851867!enterHandle: event morph: handle pointName: ptName	"The mouse has entered reframing mark.  Start a reframe operation."	| resizer b localPt |	event anyButtonPressed		ifTrue: [^ self  "Don't activate resizer if button down"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			b _ self bounds.			ptName = #topCenter ifTrue: [self bounds: (b withTop: localPt y)].			ptName = #bottomCenter ifTrue: [self bounds: (b withBottom: localPt y)].			ptName = #leftCenter ifTrue: [self bounds: (b withLeft: localPt x)].			ptName = #rightCenter ifTrue: [self bounds: (b withRight: localPt x)].			ptName = #topLeft ifTrue: [self bounds: (b bottomRight rect: localPt)].			ptName = #bottomRight ifTrue: [self bounds: (b topLeft rect: localPt)].			ptName = #bottomLeft ifTrue: [self bounds: (b topRight rect: localPt)].			ptName = #topRight ifTrue: [self bounds: (b bottomLeft rect: localPt)]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/5/1998 08:20' prior: 35295607!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph _ self topRendererOrSelf.	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/5/1998 08:20' prior: 35297392!mouseDown: evt	| cp offset newBounds |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[Preferences fastDragWindowForMorphic		ifTrue: [offset _ self position - Sensor cursorPoint.				newBounds _ self bounds newRectFrom:					[:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft]		ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!TextMorph methodsFor: 'accessing' stamp: 'di 10/5/1998 13:56' prior: 22001223!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55' prior: 22003388!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55' prior: 22003531!chooseEmphasis	self editor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55' prior: 22003672!chooseFont	self editor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55' prior: 22003808!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:59' prior: 22004349!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection"	"Also couple ParagraphEditor to Morphic keyboard events"	self editor sensor: (KeyboardBuffer new startingEvent: evt).	self selectionChanged.  "Note old selection"		interactionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 14:02' prior: 22005120!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self editor "Forces install"]]		ifFalse: ["A hand has clicked elsewhere..."				w _ self world.				(w notNil and: 					[(w hands collect: [:h | h keyboardFocus]) includes: self])					ifFalse: ["Release control unless some hand is still holding on"							self releaseEditor]].! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 13:53' prior: 22014930!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 17:04'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 16:39' prior: 35321615!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 21:59' prior: 35321883!updateFromParagraph  	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/5/1998 21:48'!find	super find.	morph installEditorToReplace: self! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 10/6/1998 00:02' prior: 22030379!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 10/5/1998 14:03' prior: 35327455!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self editor model: editView model.  "For evaluateSelection, etc"	^ super handleInteraction: interActionBlock fromEvent: evt! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06' prior: 35328665!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:25'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for simple translation."	^ canvasForMe copyOffset: transform offset negated truncated									clipRect: self innerBounds! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:28' prior: 35523785!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform transformBoundsRect:					(aCanvas clipRect intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'geometry' stamp: 'di 10/4/1998 02:34' prior: 22132762!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform transform: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !DisplayScanner removeSelector: #text:textStyle:foreground:background:fillBlt:!DisplayScanner removeSelector: #text:textStyle:foreground:background:fillBlt:!GrafPort removeSelector: #displayScannerFor:foreground:background:rule:halftone:!GrafPort removeSelector: #displayScannerFor:foreground:background:rule:halftone:!NewParagraph removeSelector: #defaultStartBlock!NewParagraph removeSelector: #defaultStartBlock!NewParagraph removeSelector: #defaultStopBlock:!NewParagraph removeSelector: #defaultStopBlock:!Paragraph removeSelector: #defaultStartBlock!Paragraph removeSelector: #defaultStartBlock!Paragraph removeSelector: #defaultStopBlock:!Paragraph removeSelector: #defaultStopBlock:!PasteUpMorph removeSelector: #fullDrawOn:!PasteUpMorph removeSelector: #fullDrawOn:!PianoRollScoreMorph removeSelector: #fullDrawOn:!PianoRollScoreMorph removeSelector: #fullDrawOn:!TextMorphEditor removeSelector: #storeSelectionInParagraph:!TextMorphEditor removeSelector: #storeSelectionInParagraph:!'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 11:54:23 am'!"Change Set:		RoundTwoTweaks-diDate:			6 October 1998Author:			Your NameFixes three problems with the Round Two update:Dismissal of a mouse-up menu by clicking outsidewill not invoke other mouseDown activity.Erroneous return of a non-boolean is fixedin TransformMorph>>fullDrawOn:without:.Typing across the boundary of linked textMorphsnow works properly again."!!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:45' prior: 35538607!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:48' prior: 35540191!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: ["Crock: If a menu is proffered with the mouse up						and the user clicks down outside it (as is normal in MVC),						then the menu goes away and nothing else happens."						mouseDownMorph owner deleteIfPopUp.						^ nil]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/6/1998 11:17' prior: 20068083!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!TextMorph methodsFor: 'editing' stamp: 'di 10/6/1998 10:32' prior: 22006402!passKeyboardFocusTo: otherMorph	| w |	(w _ self world) ifNotNil: 		[w hands do:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!TextMorph methodsFor: 'private' stamp: 'di 10/6/1998 11:22' prior: 35555685!updateFromParagraph  	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 09:53' prior: 35510371!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform transformBoundsRect: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 1:15:21 pm'!!DataStream methodsFor: 'all' stamp: 'tk 10/6/1998 13:14' prior: 17742097!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes _ byteStream position.			byteStream padToEndWith: $ .			byteStream close]		ifTrue: [bytes _ 'unknown'].	^ bytes! !!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/30/1998 13:39' prior: 35452647!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start 						to: start+1 with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString)  					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',					(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',					(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',					(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',					aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [				((aLine beginsWith: '|') and: [(aLine count: [:c | c= $|]) > 2])							"Then treat it as a table"				ifTrue: [targetStream nextPutAll: '<tr><td>',					(aLine allButFirst allButLast copyReplaceAll: '|' with:						'</td><td>'),'</td></tr>'.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.].]			ifTrue: [targetStream cr.].].	^targetStream contents.! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/1998 16:49'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1),		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName)		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!EmbeddedServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/199816:44' prior: 18533329!replyTo: pieces from: request	| theLast |	(StandardFileStream isAFileNamed: pieces)		ifTrue:			[theLast _ request message last asLowercase.			theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].			theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			request reply: PWS success;			 reply: PWS contentHTML , PWS crlf.			request reply: (HTMLformatter evalEmbedded: 				(FileStream fileNamed: pieces) contentsOfEntireFile with: request)]		ifFalse: [request error: PWS notFound]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 10/6/1998 13:13'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad _ self isBinary & (aChar class == Character) 		ifTrue: [aChar asciiValue] ifFalse: [aChar].	self nextPutAll: (String new: ((self size - self position) min: 20000) 							withAll: pad).! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 10/5/1998 16:22' prior: 35252307!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo count |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	bb _ 1. count _ steps.	[count > 0 and: [bb > 0]] whileTrue: [		bb _ self backupAChunk: theFile. count := count - 1.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Remove double !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 1:49:29 pm'!"Change Set:		sortedProjectListDate:			6 October 1998Author:			Scott WallaceMakes the presentation of the full list of project names in the bottom part of the jump-to-project  menu be in case-blind alphabetical order"!!Project class methodsFor: 'utilities' stamp: 'sw 10/6/1998 13:48' prior: 34949715!buildJumpToMenu: menu	"Present a list of potential projects, excluding the current one"	| prev |	"First a FIFO list -- inelegantly, this may include repeats."	(prev _ CurrentProject previousProject) ifNotNil:		[1 to: 5 do:			[:i | 			prev ifNotNil: 				[self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: '%back' , i printString.				prev _ prev previousProject]].		menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent.		menu addLine].	"Finally all the projects, other than the current one"	(Project allNames asSortedCollection: [:n1 :n2 | n1 asLowercase < n2 asLowercase]) do: [:n | self addItem: n toMenu: menu selection: n].	^ menu! !'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 2:15:40 pm'!"Change Set:		diskLoadTweaks-swDate:			6 October 1998Author:			Scott WallaceAdds two variant spellings of the .jpg suffix to the list of suffixes being looked for in the new-morph-from-file command, and splits out the acceptable-graphics-suffix list into a separate method."!!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/6/1998 14:13' prior: 35529201!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream oldFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			self world addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ self drawingClass new form: f.			self attachMorph: m]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/1998 14:09'!graphicsFileSuffixes	"Answer a list of filename suffixes which signal file content which we are able to internalize"	^#('.gif' '.bmp' '.jpg' '.jpeg' '.jpe', '.form')! !'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 2:53:22 pm'!"Change Set:		projChangeSet-swDate:			6 October 1998Author:			Scott WallaceFixes the long-standing bug whereby you often weren't allowed to delete a change set because you were told that it belonged to a project when in fact it no longer did.  (The old workaround was to exit and reenter the project!!)  The fix consists of eagerly updating the project's change set whenever Smalltalk newChanges: is called, rather than only upon project exit."!!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 10/6/1998 14:36' prior: 21781473!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChanges _ aChangeSet.	Project current setChangeSet: aChangeSet! !'From Squeak 2.2 of Sept 23, 1998 on 7 October 1998 at 1:06:06 pm'!"Change Set:		TwoFixes-arDate:			7 October 1998Author:			Andreas RaabFix1: Clear all RootBits when the image is loaded.Fix2: Correct a 32bit shift in BBSimulation>>alphaBlendConst:with:paint:"!!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 10/7/1998 13:04' prior: 33642442!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	"Moved into next state for checking degenerate shifts -- ar 10/4/1998"	"pixMask _ (1<<destPixSize) - 1."	destPixSize = 16 ifTrue: [		bitsPerColor _ 5.		pixMask _ 65535.	] ifFalse: [		bitsPerColor _ 8.		pixMask _ -1.	].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!ObjectMemory methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:01' prior: 20162267!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	"ar 10/7/1998 - Clear the RootBit of all objects"	| oop last header |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			(self isIntegerObject: oop) ifFalse:[				header _ self longAt: oop.				self longAt: oop put: (header bitAnd: AllButRootBit)].			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].! !'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:09:49 am'!"Change Set:		Finalization-RoundOneDate:			7 October 1998Author:			Andreas RaabThis is the first round of Finalization updates.It introduces weak classes having a special class format (=4) and all the associated changes in ObjectMemory/Interpreter/DynamicInterpreter. For a comment see ObjectMemory>>aFinalizationComment. In addition,a finalization semaphore is added to the special objects array.Weak classes have both fixed and variable fields of which *only* thevariable fields are weak. Thus, you can mix weak and non-weak fieldin a weak class."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FreeSizeMask GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!ObjectMemory subclass: #DynamicInterpreterState	instanceVariableNames: 'localCP pseudoReceiver newReceiver theTemporaryPointer localIP localSP messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache mcProbe nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex BlockArgumentCountIndex CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheClassCol MethodCacheColumns MethodCacheDelayCol MethodCacheEntries MethodCacheMask MethodCacheMethodCol MethodCachePrimIndexCol MethodCacheSelectorCol MethodCacheSize MethodCacheTMethodCol MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart TranslatedMethodIndex ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Jitter'!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache reclaimableContextCount mcProbe nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheEntries MethodCacheMask MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ObjectMemory methodsFor: 'interpreter access' stamp: 'ar 3/21/98 02:38' prior: 20168324!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 00:30' prior: 20175748!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)        4      both fixed and indexable weak fields (possibly containing pointers).        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 02:38'!isWeak: oop	"Answer true if the argument has only weak fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) = 4! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'ar 3/21/98 02:38' prior: 20181786!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	self inline: true.	fmt _ self formatOf: objectPointer.	fmt <= 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/23/98 22:46' prior: 20203363!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object's indexed fields if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Set lastFieldOffset before the weak fields in the receiver"			lastFieldOffset := (self nonWeakFieldsOf: oop) << 2.		] ifFalse:[			"Do it the usual way"			lastFieldOffset _ self lastPointerOf: oop.		].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 10/7/1998 13:52' prior: 20204204!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'ar 3/21/98 02:38' prior: 20217488!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/21/98 23:14'!aFinalizationComment	"This finalization scheme assumes to have weak classes in which the fields are not traced during the mark phase of a GC. This means, if an object is referenced only by any instances of weak classes it can be collected. In turn, we need to find out if an object referenced by a weak class is actually being collected because we have to invalidate the weak object pointer and to signal that the object has gone.	How do we know that an object referenced by a weak class is being collected? Well,  this is based on two observations. First, objects will not change their relative locations in memory, meaning that if object A is created BEFORE object B it will always have a physical memory address which is LESS than B. Secondly, GC always works from a given starting address (youngStart during incremental GC; startOfMemory during fullGC) up to end of memory. If we can somehow garantuee that the weak reference is created after the object it points to we can easily implement the following simple scheme:	1) Mark phase		Do not trace the fields of any instances of weak classes.	2) Sweep phase:		a) Explicitly mark all free objects.		b) 	If a weak reference is encountered check the the object it points to. 			If the object is marked as free than we know that this weak reference's object is gone.			Signal that it is gone.	There is, however, one small problem with this approach. We cannot always garantuee that WeakReferences point backwards such as in the following piece of code:		| o1 o2 w1 w2 |		o1 _ Object new.		w1 _ WeakReference on: o1.		o2 _ Object new.		w2 _ WeakReference on: o2.		o1 become: o2.The become: operation makes w1 point to o2 and because o2 has been created AFTER w1 the object reference in w1 points forward. Why might this be a problem? Well, if the GC would start after the weak reference AND free the object then the weak reference would simply point to an invalid memory location (since we've not been checking the weak reference during sweep phase).	Fortunately, this can not happen in the current ObjectMemory implementation. Why? Well, the only GC not starting at the beginning of the memory is incremental GC. Incremental GC however is only executed in so-called youngSpace. If both, the weak reference AND the object it points to reside in youngSpace then we can still check the weak reference. If however, the weak reference is not in youngSpace but the object is, then the object is itself a root in young space and will be marked by the GC even if it is only referenced by the WeakReference.	In the end, we just need a little adjustment in step 2b) of the above procedure which looks as follows:		If the weak reference points 			* backwards: check if the object header is marked free			* forwards: check if the object has been marked in markPhase.	Note that a number of finalizations will only be executed during a fullGC. This happens if either the WeakReference or the object reside outside youngSpace. So, if you must garantuee that some object has been finalized you definitely need to do a fullGC.ar 3/20/98 17:20"	self error:'Comment only'.! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/23/98 22:39'!finalizeReference: oop	"During sweep phase we have encountered a weak reference. Check if	its object has gone away (or is about to) and if so, signal a semaphore."	| weakOop oopGone chunk firstField lastField |	"Do *not* inline this in sweepPhase - it is quite an unlikely case to run into a weak reference"	self inline: false.	firstField := BaseHeaderSize + ((self nonWeakFieldsOf: oop) << 2).	lastField := self lastPointerOf: oop.	firstField to: lastField by: 4 do:[:i|		weakOop := self longAt: oop+i.		((weakOop == nilObj) or:[(self isIntegerObject: weakOop)]) ifFalse:[			"Check if the object is being collected.			If the weak reference points 				* backward: check if the weakOops chunk is free				* forward: check if the weakOoop has been marked by GC"			weakOop < oop 				ifTrue:[	chunk _ self chunkFromOop: weakOop.						oopGone _ ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]				ifFalse:[oopGone _ ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].			oopGone ifTrue:[					"Store nil in the pointer and signal the interpreter"					self longAt: oop+i put: nilObj.					self signalFinalization: oop].		].	].! !!DynamicInterpreter methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:59' prior: 17972131!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self inline: false.	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	messageSelector			_ nilObj.	newReceiver			_ nilObj.	newMethod				_ nilObj.	newTranslatedMethod	_ nilObj.	pseudoReceiver			_ 0.	self initializeTranslator.	self initMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!DynamicInterpreter methodsFor: 'object format' stamp: 'ar 3/21/98 02:32' prior: 17999569!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 4) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!DynamicInterpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:33' prior: 18053094!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:33' prior: 18053618!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ar 10/7/1998 14:02' prior: 33892404!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		semaClass _ self splObj: ClassSemaphore.		(self fetchClassOf: sema) = semaClass 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ar 3/21/98 13:58'!signalFinalization: weakReferenceOop	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	interruptCheckCounter _ 0.	pendingFinalizationSignals _ pendingFinalizationSignals + 1.! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ar 3/21/98 02:37' prior: 18158458!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:59' prior: 19168419!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/21/98 02:37' prior: 19190006!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 4) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:37' prior: 19261834!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:38' prior: 19262351!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!Interpreter methodsFor: 'processes' stamp: 'ar 10/7/1998 14:01' prior: 34289043!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		semaClass _ self splObj: ClassSemaphore.		(self fetchClassOf: sema) = semaClass 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'ar 3/21/98 18:39'!signalFinalization: weakReferenceOop	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	interruptCheckCounter _ 0.	pendingFinalizationSignals _ pendingFinalizationSignals + 1.! !!Interpreter methodsFor: 'debug support' stamp: 'ar 3/21/98 02:37' prior: 19348597!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ar 10/7/1998 14:03' prior: 20230023!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.! !!SystemDictionary methodsFor: 'special objects' stamp: 'ar 3/21/98 15:30' prior: 21768792!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 42.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	newArray at: 42 put: Semaphore new. "finalization Semaphore"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemTracer methodsFor: 'private' stamp: 'ar 3/21/98 00:31' prior: 21837791!formatOf: obj	"Make the code that tells the format of this object.	It is like the class's instSpec, but with added low bits for byte size""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields        4=      both fixed and indexable weak fields        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	| class spec |	class _ obj class.	spec _ class instSpec.    "just use what's there"	spec < 8 ifTrue: [^ spec]			ifFalse: ["For byte objects, size = wordSize - spec.lowBits"					^ spec + (3 - (obj size+3 bitAnd: 3))]! !'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:09:52 am'!"Change Set:		Finalization-RoundTwoDate:			7 October 1998Author:			Andreas RaabRound two of the Finalization updates installs all the necessary modifications in Behavior/ClassDescription/Class/Metaclass for definingweakSubclasses. Note that a number of methods have becomeobsolete (they're flagged with #obsolete) but not yet removedto avoid inconsistencies."!!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/21/98 02:36' prior: 16917755!kindOfSubclass 	"Answer a String that is the keyword that describes the receiver's kind of 	subclass, either a regular subclass, a variableSubclass, a 	variableByteSubclass, a variableWordSubclass, or a weakSubclass"	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Behavior methodsFor: 'private' stamp: 'ar 3/23/98 22:55' prior: 16929798!becomeCompact	| cct index |	self isWeak ifTrue:[^self halt:'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09' prior: 16931219!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	self flag: #obsolete.	^self format: nInstVars variable: isVar words: isWords pointers: isPointers weak: false! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:12' prior: 17432056!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	self flag: #obsolete.	^self		subclassOf: newSuper 		oldClass: oldClass 		instanceVariableNames: newInstVarString 		variable: v 		words: w 		pointers: p 		weak: false		ifBad: badBlock ! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:11'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p weak: beWeak ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass ifNotNil: [superclass removeSubclass: self.				"Object flushCache"		"done in removeSubclass"].			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p		weak: beWeak.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12' prior: 33811518!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			weak: sub isWeak			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 3/21/98 02:36' prior: 17460248!kindOfSubclass	"Answer a string that describes what kind of subclass the receiver is, i.e.,	weak, variable, variable byte, variable word, or not variable."	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:15' prior: 17412715!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: self instanceVariablesString , aString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:16' prior: 17413239!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: newInstVarString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:18' prior: 17421373!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	self isVariable		ifTrue: 			[self isPointers 				ifTrue: [^self							variableSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			self isBytes 				ifTrue: [^self							variableByteSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			^self				variableWordSubclass: t				instanceVariableNames: f				classVariableNames: d				poolDictionaries: s				category: cat].	^self class		name: t		inEnvironment: Smalltalk		subclassOf: self		instanceVariableNames: f		variable: false		words: true		pointers: true		weak: false		classVariableNames: d		poolDictionaries: s		category: cat		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16' prior: 17422396!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(self isVariable and: [self isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a byte subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: false 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16' prior: 17423358!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:17' prior: 17424054!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 					'cannot make a word subclass of a class with named fields'].	self isBytes		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a word subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 3/21/98 02:36'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: true		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12' prior: 34648482!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				weak: false				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 10/7/1998 14:14' prior: 34650692!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	self flag: #obsolete.	^self 		name: newName 		inEnvironment: environ 		subclassOf: sup 		instanceVariableNames: instVarString 		variable: v 		words: w 		pointers: p 		weak: false		classVariableNames: classVarString 		poolDictionaries: poolString 		category: categoryName 		comment: commentString 		changed: changed ! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 10/7/1998 14:13'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:20:15 am'!"Change Set:		Finalization-RoundThreeDate:			7 October 1998Author:			Andreas RaabRound three adds weak collections to the systeme.g., WeakArray, WeakKeyDictionary,WeakValueDictionary, and WeakRegistry."SystemOrganization addCategory: 'Collections-Weak' before: 'Collections-Support' asSymbol.!Array weakSubclass: #WeakArray	instanceVariableNames: ''	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore IsFinalizationSupported '	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakValueAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/8/1998 11:16'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	self wait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	^blockValue! !!WeakArray commentStamp: '<historical>' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'class initialization' stamp: 'ar 10/7/1998 16:45'!initialize	"WeakArray initialize"	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	"Check if Finalization is supported by this VM"	IsFinalizationSupported _ nil.	self isFinalizationSupported ifFalse:[^self].	FinalizationProcess notNil ifTrue:[FinalizationProcess terminate].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents isNil ifTrue:[		FinalizationDependents := WeakArray new: 10.	].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] newProcess.	FinalizationProcess priority: Processor userInterruptPriority.	FinalizationProcess resume.! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!addWeakDependent: anObject	| finished index weakDependent |	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject _ WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported _false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported _ (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!removeWeakDependent: anObject	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/8/1998 11:19'!finalizationProcess	[true] whileTrue:[		FinalizationSemaphore wait.		FinalizationLock critical:[			FinalizationDependents do:[:weakDependent|				weakDependent isNil 					ifFalse:[weakDependent finalizeValues].			].		] ifError:[:msg :rcvr| rcvr error: msg].	].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/7/1998 15:24'!pvtCreateTemporaryObjectIn: tempObject	"We have to create the temporary object in a separate stack frame"	tempObject at: 1 put: Object new! !!WeakKeyAssociation commentStamp: '<historical>' prior: 0!I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:47'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:44'!key: aKey value: anObject	key := WeakArray with: key.	value := anObject.! !!WeakKeyDictionary commentStamp: '<historical>' prior: 0!I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 3/21/98 16:15'!finalizeValues	"default action is to re-hash the receiver and to remove nil-keys"	self rehash.	self removeKey: nil ifAbsent:[].! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 3/22/98 00:21'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf := self species new: self size.	self associationsDo:[:each| newSelf noCheckAdd: each].	array := newSelf array.	tally := newSelf size.! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ar 3/22/98 00:19'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/21/98 16:33'!size	^self protected:[		valueDictionary size	].! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'private' stamp: 'ar 10/8/1998 11:18'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !!WeakValueAssociation commentStamp: '<historical>' prior: 0!I am an association holding only weakly on my value.!!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:53'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:55'!value	^value isNil		ifTrue:[nil]		ifFalse:[value at: 1]! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakValueDictionary commentStamp: '<historical>' prior: 0!I am a dictionary holding only weakly on my values. Clients may expect to get a nil value for any object they request.!!WeakValueDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:02'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !WeakArray class removeSelector: #pvtCreateTemporaryObject!WeakArray initialize!'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:09:59 am'!"Change Set:		Finalization-SockStreamDate:			7 October 1998Author:			Andreas RaabRound four of the Finalization updates installs weak registriesin class Socket and StandardFileStream, but does not activate them.(this has to do with the fileIn order of certain methods)"!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry ThisEndClosed Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'System-Network'!FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1 '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'System-Files'!!FileDirectory methodsFor: 'file operations' stamp: 'ar 3/21/98 18:08' prior: 18636075!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock.	If the first deletion attempt fails do a GC to force finalization of any lost references. ar 3/21/98 17:53"	(self 		retryWithGC:[self primDeleteFileNamed: (self fullNameFor: localFileName)]		until:[:result| result notNil]) == nil			ifTrue: [^failBlock value].! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 3/21/98 18:10' prior: 18636381!rename: oldFileName toBe: newFileName	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	(self retryWithGC:[self primRename: (self fullNameFor: oldFileName)						to: (self fullNameFor: newFileName)]		until:[:result| result notNil]) == nil ifTrue:[	self error:'Attempt to rename a non-existent file,or to use a name that is already in use'].! !!FileDirectory methodsFor: 'private' stamp: 'ar 3/21/98 18:04' prior: 18641821!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.	Changed to return nil instead of failing ar 3/21/98 18:04"	<primitive: 159>	^nil! !!Socket methodsFor: 'primitives' stamp: 'ar 3/21/98 17:43'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 210>! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:40'!register	^self class register: self! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:41'!unregister	^self class unregister: self! !!Socket methodsFor: 'finalization' stamp: 'ar 3/21/98 17:44'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObject: semaphore.! !!FTPSocket methodsFor: 'finalization' stamp: 'ar 3/21/98 18:19'!actAsExecutor	super actAsExecutor.	dataSocket := nil.! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:22'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!register	^self class register: self! !!StandardFileStream methodsFor: 'registry' stamp: 'ar 3/21/98 17:23'!unregister	^self class unregister: self! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 3/21/98 18:16'!actAsExecutor	super actAsExecutor.	name := nil.! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 10/7/1998 15:44'!finalize	self primCloseNoError: fileID.! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:23'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:10:01 am'!"Change Set:		Finalization-RoundFiveDate:			7 October 1998Author:			Andreas RaabRound five of the Finalization updates activatesthe weak registries in class Socket and StandardFileStream"!!Socket methodsFor: 'initialize-destroy' stamp: 'ar 10/7/1998 14:42' prior: 21409652!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isValid ifTrue: [self primSocketDestroy: socketHandle].			Smalltalk unregisterExternalObject: semaphore.			socketHandle _ nil.			semaphore _ nil.			self unregister].! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 10/7/1998 14:43' prior: 21410103!initialize	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex |	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: 0			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil	] ifFalse:[self register].! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 10/7/1998 14:43' prior: 35184652!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		self unregister.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 10/7/1998 14:44' prior: 35185202!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	fileID _ self retryWithGC:[self primOpen: fileName writable: writeMode] until:[:id| id notNil].	fileID ifNil: [^ nil].  "allows sender to detect failure"	self register.	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !'From Squeak 2.2 of Sept 23, 1998 on 9 October 1998 at 12:09:21 am'!"Change Set:		Round Three-diDate:			6 October 1998Author:			Dan IngallsThis ChangeSet includes Bob Arning's fix for indent/outdent in morphic [thanks!!].ZoomMorphs have been removed from the 'new morph' menu.A CursorWithMask class has been added.  You can try it out by executing...		Cursor initNormalWithMask.  Cursor normal show.	and you can revert by executing...		Cursor initNormal.  Cursor normal show.There is a general method that will derive all the cursors automatically from their unmasked counterparts.  However the above method simply installs a hand-tweaked masked version of the normal cursor.TextMorphs with drop-shadows can now fill their owner's shape.TextMorphs with drop-shadows can be embedded in Project links.Embedded text now remembers its fill properties when duplicated."!Cursor subclass: #CursorWithMask	instanceVariableNames: 'maskForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor _ (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/6/1998 13:29' prior: 17706274!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormal.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		"Cursor initialize"! !!Cursor class methodsFor: 'instance creation' stamp: 'di 10/6/1998 13:53' prior: 17712669!new	^ self extent: 16 @ 16		fromArray: (Array new: 16 withAll: 0)		offset: 0 @ 0	"Cursor new bitEdit show"! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57' prior: 17712964!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor _ aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/6/1998 15:16'!beCursor	maskForm unhibernate.	^ self beCursorWithMask: maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!maskForm	^ maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm _ aForm! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 10/8/1998 16:46'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask |	cursor _ self new.	cursor copy: (1@1 extent: 16@16) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: 16@16.	(0@0) eightNeighbors do:		[:p | mask copy: (p extent: 16@16) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: aForm offset - (1@1).	^ cursor! !!DropShadowMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 14:43'!ownerChanged	super ownerChanged.	self submorphsDo: [:m | m ownerChanged].	self computeBounds! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:30'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr |	cr _ Character cr.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:04'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex ! !!String methodsFor: 'paragraph support' stamp: 'RAA 8/30/1998 15:20'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:24' prior: 21972781!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText _ textMorph meOrMyDropShadow.	bounds _ theText owner bounds.	theText owner submorphsBehind: theText do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:21' prior: 21973059!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fillsOwner		ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: canvas]		ifFalse: [canvas fillRectangle: textMorph bounds color: Color black].	self avoidsOcclusions ifTrue:		[back _ canvas form deepCopy.		canvas form fillWhite.		theText owner submorphsInFrontOf: theText do:			[:m | (textMorph isLinkedTo: m)				ifTrue: []				ifFalse: [m fullDrawOn: canvas]].		back displayOn: canvas form at: 0@0 rule: Form reverse].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 23:46' prior: 22007035!bounds	container ifNil: [^ bounds].	^ container bounds ifNil: [bounds]! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 14:22' prior: 22009039!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	outer _ self meOrMyDropShadow owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 23:40' prior: 22010561!followCurve	self setContainer: (TextOnCurveContainer new baseline: 0; textDirection: 1).	self changed! !!TextMorph methodsFor: 'private' stamp: 'di 10/8/1998 14:23' prior: 22015377!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: self meOrMyDropShadow owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 14:17'!meOrMyDropShadow	^ (owner isKindOf: DropShadowMorph)			ifTrue: [owner]			ifFalse: [self]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 23:20' prior: 22022733!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [newOwner isWorldOrHandMorph ifTrue: [self setContainer: nil]]! !!ZoomMorph class methodsFor: 'as yet unclassified' stamp: 'di 10/6/1998 13:15'!includeInNewMorphMenu	"Zooms aren't meaningful without initializations"	^ false! !Cursor initialize!'From Squeak 2.2 of Sept 23, 1998 on 9 October 1998 at 4:12:52 pm'!!Socket class methodsFor: 'instance creation' stamp: 'tk 10/9/1998 16:05' prior: 35169617!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !'From Squeak 2.2 of Sept 23, 1998 on 9 October 1998 at 5:22:01 pm'!"Change Set:		RoundFour-diDate:			9 October 1998Author:			Dan IngallsA few more fixes to curves and text...* Polygons and curves no longer offer fill mode choice if not closed.* Curve editing handles appear in front of embedded text, if any.* Text on curves now shows when dragging.* Brown handle drag and cmd-drag now flow text around occlusions....and a number of items from the Squeak Bug List...* Proceeding from a syntax error in MVC now works again.* If you have a syntax error in a do-it in a fileIn, you can proceed after correction.  this never worked before.* In morphic browsers, after you do a spawn, the spawned text is cleared from the original browser.* In the morphic debugger's code pane, 'cancel' now discards unaccepted edits properly.* Similarly, after a cancel (e.g. cmd-l) the old text is cleared from the browser."!Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark prevToken prevMark encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!StringHolder subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Debugger'!!Compiler methodsFor: 'error handling' stamp: 'di 10/9/1998 16:50' prior: 17613797!notify: aString at: location	"Refer to the comment in Object|notify:."	requestor == nil		ifTrue: [^SyntaxError 					errorInClass: class					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false]		ifFalse: [^requestor					notify: aString					at: location					in: sourceStream]! !!Debugger methodsFor: 'accessing' stamp: 'di 10/9/1998 17:15' prior: 17789537!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	contents == nil ifTrue: [^ String new].	^ contents copy! !!Morph methodsFor: 'geometry' stamp: 'di 10/9/1998 15:22' prior: 34673638!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!Parser methodsFor: 'public access' stamp: 'di 10/9/1998 16:22' prior: 20495827!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth |	self init: sourceStream notifying: req failBlock: [^aBlock value].	doitFlag _ noPattern.	encoder _ Encoder new init: class context: ctxt notifying: self.	failBlock_ aBlock.	meth _ self method: noPattern context: ctxt.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^meth! !!Parser methodsFor: 'error handling' stamp: 'di 10/9/1998 16:23' prior: 20509751!notify: string at: location	requestor isNil		ifTrue: [encoder == self ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxError 					errorInClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!PolygonMorph methodsFor: 'editing' stamp: 'di 10/9/1998 14:35' prior: 20781465!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)].	self addHandles! !!PolygonMorph methodsFor: 'menu' stamp: 'di 10/9/1998 14:30' prior: 34917602!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	closed		ifTrue:		[aCustomMenu add: 'open polygon' action: #makeOpen.		quickFill			ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]			ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true]]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!StringHolderController methodsFor: 'edit flag' stamp: 'di 10/9/1998 15:41'!hasUnacceptedEdits: aBoolean	^ view hasUnacceptedEdits: aBoolean! !!SyntaxError methodsFor: 'initialization' stamp: 'di 10/9/1998 16:17'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	contents _ aString.	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:36' prior: 35260912!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	doitFlag	ifTrue: [Compiler new evaluate: aString in: nil to: nil						notifying: aController ifFail: [^ false]]	ifFalse: [(class compile: aString classified: category						notifying: aController) ifNil: [^ false]].	aController hasUnacceptedEdits: false.	self proceed! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:51' prior: 21717018!notify: error at: location in: source	"Open a syntax error view, inserting the given error message into the given source at the given location. This message is sent to the 'requestor' when the parser or compiler finds a syntax error."	| aClass aString |	aClass _ thisContext sender receiver encoder classEncoding.	aString _		source contents			copyReplaceFrom: location			to: location - 1			with: error.	self setClass: aClass		code: aString		debugger: (Debugger context: thisContext)		doitFlag: false.	self class open: self.! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 10/9/1998 16:18'!errorInClass: aClass withCode: codeString doitFlag: doit	"Open a view whose model is a syntax error. The error occurred when trying to add the given method code to the given class."	self open:		(self new setClass: aClass			code: codeString			debugger: (Debugger context: thisContext)			doitFlag: doit).! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/9/1998 15:50' prior: 22008721!privateMoveBy: delta	self releaseEditor.	super privateMoveBy: delta.	paragraph ifNotNil: [paragraph moveBy: delta].! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/9/1998 16:55' prior: 22027004!cancel	"Cancel the changes made so far to this text"	morph cancelEdits! !SyntaxError removeSelector: #setClass:code:debugger:!SyntaxError removeSelector: #setClass:code:debugger:!SyntaxError class removeSelector: #errorInClass:withCode:!SyntaxError class removeSelector: #errorInClass:withCode:!'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:16 am'!"Change Set:		CCodeGenerator-Extensions-arDate:			11 October 1998Author:			Andreas RaabThe change set contains three additional translation rules for	#/ 			- being translated like #// for float computations	#asFloat		- translated into '((double) rcvr)'	#asInteger	- translated into '((int) rcvr)'"!!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/3/1998 13:45'!generateAsFloat: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((double) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' )'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/3/1998 13:45'!generateAsInteger: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll:'((int) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' )'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/11/1998 00:56' prior: 33702236!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	#asFloat				#generateAsFloat:on:indent:	#asInteger			#generateAsInteger:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:21 am'!"Change Set:		Pluggable-Primitives-arDate:			11 October 1998Author:			Andreas RaabThis change set provides the framework for pluggable primitives by:* extending Parser to handle named primitives* adding primitiveExternalCall in the Interpreter* Changing TMethod to handle the #export: directive* Changing TSendNode for plugin code generation* Adding class PluggableCodeGenerator* Adding the following classes for simulating plugins	InterpreterPlugin	InterpreterProxy	CObjectAccessor	CArrayAccessor* Adding methods in ObjectMemory/Interpreter for plugin support."!Object subclass: #CObjectAccessor	instanceVariableNames: 'object offset '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!CObjectAccessor subclass: #CArrayAccessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!Object subclass: #InterpreterPlugin	instanceVariableNames: 'interpreterProxy '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!Object subclass: #InterpreterProxy	instanceVariableNames: 'successFlag remapBuffer stack method argumentCount '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!CCodeGenerator subclass: #PluggableCodeGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!Object subclass: #TMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!Object methodsFor: 'translation support' stamp: 'ar 9/18/1998 23:27'!export: aBoolean	"For translation only; noop when running in Smalltalk."! !!CCodeGenerator methodsFor: 'utilities' stamp: 'ar 10/7/1998 17:53'!isGeneratingPluginCode	^false! !!CObjectAccessor commentStamp: '<historical>' prior: 0!I am used to simulate the indexed access to any object during plugin simulation.!!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object instVarAt: index + offset + 1! !!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object instVarAt: index + offset + 1 put: value! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+ increment	^self clone += increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+= increment	offset _ offset + increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!- decrement	^self clone -= decrement! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!-= decrement	offset _ offset - decrement! !!CObjectAccessor methodsFor: 'printing' stamp: 'ar 9/16/1998 21:38'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:' on: ';		print: object.! !!CObjectAccessor methodsFor: 'private' stamp: 'ar 10/9/1998 21:56'!setObject: anObject	object _ anObject.	offset _ 0.! !!CArrayAccessor commentStamp: '<historical>' prior: 0!I am used to simulate the indexed access to arrays during plugin simulation.!!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object at: index + offset + 1! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object at: index + offset + 1 put: value! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index	| idx |	idx _ (offset + index) // 4 + 1.	"Note: This is a special hack for BitBlt."	(idx = (object basicSize + 1)) ifTrue:[^0].	^object basicAt: idx! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index put: value	^object basicAt: (offset + index) // 4 + 1 put: value! !!CObjectAccessor class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 21:36'!on: anObject	^self new setObject: anObject! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ar 10/11/1998 00:19' prior: 33902701!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 10/11/1998 00:19' prior: 34299245!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterPlugin methodsFor: 'initialize' stamp: 'ar 10/11/1998 02:06'!setInterpreter: anInterpreter	| ok |	self export: true.	self var: #anInterpreter declareC: 'struct VirtualMachine *anInterpreter'.	interpreterProxy _ anInterpreter.	"Note: 	The following is coded so that it can be run from Squeak			where the return value is ignored."	ok _ self cCode: 'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'.	ok == false ifTrue:[^false].	ok _ self cCode: 'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'.	^ok! !!InterpreterPlugin class methodsFor: 'class initialization' stamp: 'ar 9/16/1998 20:26'!initialize	"Nothing to do ..."! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 9/16/1998 20:27'!declareCVarsIn: aCCodeGenerator	"Note: This method must be implemented by all subclasses to declare variables"	aCCodeGenerator var: 'interpreterProxy'		declareC: 'struct VirtualMachine *interpreterProxy'.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName all: classes doInlining: inlineFlag	"Time millisecondsToRun: [		InterpreterPlugin translate:'all.c' all:{FloatArrayPlugin. FFTPlugin} doInlining: true.		Smalltalk beep]"	| cg theClass |	cg _ PluggableCodeGenerator new initialize.	classes do:[:cls|		theClass _ cls.		theClass initialize.		[theClass == InterpreterPlugin] whileFalse:[			cg addClass: theClass.			theClass declareCVarsIn: cg.			theClass _ theClass superclass]].	(classes includes: InterpreterPlugin) ifFalse:[		cg addClass: InterpreterPlugin.		InterpreterPlugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ PluggableCodeGenerator new initialize.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 9/11/1998 18:03'!translateDoInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translateDoInlining: true.		Smalltalk beep]"	^self translate: (self moduleName,',c') doInlining: inlineFlag! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^''! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/30/1998 23:12'!simulatorClass	"For running from Smalltalk - return a class that can be used to simulate the receiver.	By default every plugin can simulate itself."	^self! !!InterpreterPlugin class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:45'!doPrimitive: primitiveName	| proxy plugin |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin _ self simulatorClass new.	plugin setInterpreter: proxy.	plugin perform: primitiveName asSymbol.	^proxy stackValue: 0! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 9/16/1998 01:35'!initialize	successFlag _ true.	remapBuffer _ OrderedCollection new.	stack _ OrderedCollection new.! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 10/3/1998 18:50'!loadStackFrom: aContext	self push: aContext receiver.	method _ aContext method.	argumentCount _ method numArgs.	1 to: argumentCount do:[:i| self push: (aContext at: i) ].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems	1 to: nItems do:[:i| stack removeLast].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems thenPush: oop	self pop: nItems.	self push: oop.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:42'!push: object	stack addLast: object! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushBool: trueOrFalse	(trueOrFalse == true or:[trueOrFalse == false]) ifFalse:[self error:'Not a Boolean'].	self push: trueOrFalse! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushFloat: f	self var: #f declareC: 'double f'.	f class == Float ifFalse:[^self error:'Not a Float'].	self push: f.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:20'!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/27/1998 15:22'!stackFloatValue: offset	| oop |	self returnTypeC: 'double'.	oop _ self stackValue: offset.	(self isFloatObject: oop) ifFalse: [self primitiveFail. ^0.0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackIntegerValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifFalse: [self primitiveFail. ^0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackObjectValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 11:47'!stackValue: offset	^stack at: stack size - offset.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!argumentCountOf: methodPointer	^methodPointer numArgs! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/11/1998 03:01'!arrayValueOf: oop	self returnTypeC: 'void *'.	self success: (self isWordsOrBytes: oop).	^CArrayAccessor on: oop.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:23'!byteSizeOf: oop	"Return the size of the receiver in bytes"	^oop class isBytes		ifTrue:[(self slotSizeOf: oop)]		ifFalse:[(self slotSizeOf: oop) * 4]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:22'!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:07'!fetchClassOf: oop	^oop class! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:21'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:19'!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchPointer: index ofObject: oop	^oop instVarAt: index+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchWord: fieldIndex ofObject: oop	^oop instVarAt: fieldIndex+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/18/1998 20:26'!firstFixedField: oop	self returnTypeC:'void *'.	^CObjectAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:22'!firstIndexableField: oop	self returnTypeC:'void *'.	^CArrayAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:38'!literal: offset ofMethod: methodPointer	^methodPointer literals at: offset+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!literalCountOf: methodPointer	^methodPointer numLiterals! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodArgumentCount	^argumentCount! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodPrimitiveIndex	^method primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:39'!primitiveIndexOf: methodPointer	^methodPointer primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 19:03'!sizeOfSTArrayFromCPrimitive: cPtr	"Note: Only called by translated primitive code."	self var: #cPtr declareC: 'void *cPtr'.	^self shouldNotImplement! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	^(oop basicSize) + (oop class instSize)! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index	^array at: index! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index put: value	^array at: index put: value! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:26'!stSizeOf: oop	"Return the number of indexable fields in the receiver"	^oop basicSize! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:25'!storeInteger: index ofObject: oop withValue: integer	(self isIntegerValue: integer) 		ifTrue:[^self storeWord: index ofObject: oop withValue: integer]		ifFalse:[^self primitiveFail]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:25'!storePointer: index ofObject: oop withValue: valuePointer	^oop instVarAt: index+1 put: valuePointer! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:00'!is: oop KindOf: aString	"InterpreterProxy new is: 42 KindOf: 'Number'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isKindOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:01'!is: oop MemberOf: aString	"InterpreterProxy new is: 42 MemberOf:'SmallInteger'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isMemberOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isBytes: oop	^oop class isBytes! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:44'!isFloatObject: oop	^oop class == Float! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:45'!isIndexable: oop	^oop isVariable! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:12'!isIntegerObject: objectPointer	^objectPointer class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:13'!isIntegerValue: intValue	^intValue class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isPointers: oop	^oop class isPointers! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:16'!isWeak: oop	^oop class isWeak! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 10/9/1998 22:19'!isWords: oop	^oop class isPointers not and:[oop class isBytes not]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:05'!isWordsOrBytes: oop	^(self isBytes: oop) or:[self isWords: oop]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 21:27'!booleanValueOf: obj	obj == true ifTrue:[^true].	obj == false ifTrue:[^false].	self primitiveFail.	^nil! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/4/1998 15:47'!checkedIntegerValueOf: intOop	(self isIntegerObject: intOop)		ifTrue:[^self integerValueOf: intOop]		ifFalse:[self primitiveFail. ^0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:08'!floatObjectOf: aFloat	self var: #aFloat declareC: 'double aFloat'.	aFloat class == Float ifFalse:[self error:'Not a float object'].	^aFloat! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:09'!floatValueOf: oop	self returnTypeC:'double'.	oop class == Float		ifTrue:[^oop]		ifFalse:[self primitiveFail. ^0.0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:13'!integerObjectOf: value	value class == SmallInteger ifFalse:[self error:'Not a SmallInteger object'].	^value! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:10'!integerValueOf: oop	oop class == SmallInteger ifFalse:[self error:'Not a SmallInteger'].	^oop! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:11'!positive32BitIntegerFor: integerValue	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue > 0		ifTrue:[integerValue]		ifFalse:[ (1 bitShift: 32) + integerValue]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:12'!positive32BitValueOf: oop	oop isInteger ifFalse:[self error:'Not an integer object'].	oop < 0 		ifTrue:[self primitiveFail. ^0]		ifFalse:[^oop]! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:43'!characterTable	^Character characterTable! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:42'!displayObject	^Display! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!falseObject	^false! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!nilObject	^nil! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:41'!trueObject	^true! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:42'!classArray	^Array! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classBitmap	^Bitmap! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classByteArray	^ByteArray! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classCharacter	^Character! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classFloat	^Float! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classLargePositiveInteger	^LargePositiveInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classPoint	^Point! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classSemaphore	^Semaphore! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 21:43'!classSmallInteger	^SmallInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classString	^String! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/18/1998 20:11'!clone: oop	^oop clone! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:11'!instantiateClass: classPointer indexableSize: size	^size = 0 		ifTrue:[classPointer basicNew]		ifFalse:[classPointer basicNew: size]! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 10/10/1998 16:14'!makePointwithxValue: xValue yValue: yValue	(xValue class == SmallInteger and:[yValue class == SmallInteger]) 		ifFalse:[self error:'Not SmallInteger objects'].	^xValue@yValue! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!popRemappableOop	^remapBuffer removeLast! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!pushRemappableOop: oop	remapBuffer addLast: oop! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!become: array1 with: array2	array1 elementsExchangeIdentityWith: array2! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!failed	^successFlag not! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!fullDisplayUpdate	Display display! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!fullGC	Smalltalk garbageCollect.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!incrementalGC	Smalltalk garbageCollectMost.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!primitiveFail	(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt].	successFlag _ false.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	aForm == Display ifTrue:[		Display forceToScreen: (Rectangle left: l right: r top: t bottom: b)].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!signalSemaphoreWithIndex: semaIndex	((Smalltalk specialObjectsArray at: 39) at: semaIndex) signal! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/19/1998 13:30'!success: aBoolean	successFlag not ifTrue:[^self].	successFlag _ successFlag and:[aBoolean].	successFlag not ifTrue:[		(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt]].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!superclassOf: classPointer	^classPointer superclass! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!byteAt: accessor	^accessor byteAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:12'!byteAt: accessor put: value	^accessor byteAt: 0 put: value! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor	^accessor longAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor put: value	^accessor longAt: 0 put: value! !!InterpreterProxy class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 00:23'!new	^super new initialize! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 18:45'!generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass _ InterpreterProxy.	cg _ PluggableCodeGenerator new initialize.	cg addClass: proxyClass.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList _ catList collect:[:cat| cat -> (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 19:04'!validateProxyImplementation: anInterpreter	"InterpreterProxy validateProxyImplementation: Interpreter"	"InterpreterProxy validateProxyImplementation: DynamicInterpreter"	| proxyClass catList |	proxyClass _ InterpreterProxy.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList do:[:category|		(proxyClass organization listAtCategoryNamed: category) do:[:selector|			(anInterpreter canUnderstand: selector) 				ifFalse:[self notify: selector, ' is not implemented in ', anInterpreter name]]].! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!characterTable	^self splObj: CharacterTable! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classArray	^self splObj: ClassArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classBitmap	^self splObj: ClassBitmap! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classByteArray	^self splObj: ClassByteArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classCharacter	^self splObj: ClassCharacter! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classFloat	^self splObj: ClassFloat! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classLargePositiveInteger	^self splObj: ClassLargePositiveInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classPoint	^self splObj: ClassPoint! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSemaphore	^self splObj: ClassSemaphore! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSmallInteger	^self splObj: ClassInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!classString	^self splObj: ClassString! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!displayObject	^self splObj: TheDisplay! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!falseObject	^falseObj! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:16'!trueObject	^trueObj! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ar 10/7/1998 18:41'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: self stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'ar 10/7/1998 18:42'!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ar 10/9/1998 11:21'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger)		* The function address (Integer)	"	| thisSession lit functionAddress addr moduleName functionName moduleLength functionLength session |	self var: #thisSession declareC:'static int thisSession = 0'.	"Make sure the session is initialized"	thisSession = 0 ifTrue:[		thisSession _ self ioMicroMSecs bitAnd: 16r1FFFFFFF.		thisSession = 0 ifTrue:[thisSession _ 1]].	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0.	"@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function address and session id in case it has been loaded before"	addr _ self positive32BitValueOf: (self fetchPointer: 3 ofObject: lit).	session _ self fetchInteger: 2 ofObject: lit.	"If so, call the function directly"	(successFlag and:[session = thisSession and:[addr ~= 0]])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'].	"Clean up session id and function address"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	addr _ self ioLoadExternalFunction: functionName + 4				OfLength: functionLength 				FromModule: moduleName + 4				OfLength: moduleLength.	self success: addr ~= 0.	"If the function has been successfully loaded process it"	successFlag ifTrue:[		"Store the session ID"		self storeInteger: 2 ofObject: lit withValue: thisSession.		"Store the address back in the literal"		self pushRemappableOop: lit.		functionAddress _ self positive32BitIntegerFor: addr.		lit _ self popRemappableOop.		self storePointer: 3 ofObject: lit withValue: functionAddress.		(successFlag and:[addr ~= 0])			ifTrue:[self cCode:' ((int (*) (void)) addr) ()'].	].! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!byteSizeOf: oop	| slots |	(self isIntegerObject: oop) ifTrue:[^0].	slots _ self slotSizeOf: oop.	(self isBytes: oop)		ifTrue:[^slots]		ifFalse:[^slots * 4]! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| srcName name length |	self var: #className declareC:'char *className'.	self var: #srcName declareC:'char *srcName'.	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	length _ self stSizeOf: name.	srcName _ self cCoerce: (self arrayValueOf: name) to:'char *'.	0 to: length-1 do:[:i|		(srcName at: i) = (className at: i) ifFalse:[^false].	].	"Check if className really ends at this point"	^(className at: length) = 0! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!firstFixedField: oop	self returnTypeC:'void *'.	^self cCoerce: oop+4 to:'void *'.! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!firstIndexableField: oop	| hdr fmt totalLength fixedFields |	self returnTypeC:'void *'.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	fmt < 8 ifTrue:["32 bit field objects"		^ self cCoerce: oop+4+ (fixedFields << 2) to:'void *'.	] ifFalse:["Byte objects"		^ self cCoerce: oop+4+fixedFields to:'void *'.	]! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!floatObjectOf: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	^newFloatObj! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!is: oop KindOf: className	"Support for external primitives."	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	[oopClass == nilObj] whileFalse:[		(self classNameOf: oopClass Is: className) ifTrue:[^true].		oopClass _ self superclassOf: oopClass].	^false! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!is: oop MemberOf: className	"Support for external primitives"	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	^(self classNameOf: oopClass Is: className)! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!isFloatObject: oop	^(self fetchClassOf: oop) == self classFloat! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!isIndexable: oop	^(self formatOf: oop) >= 2! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!methodArgumentCount	^argumentCount! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!methodPrimitiveIndex	^primitiveIndex! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/10/1998 21:25'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	(self isIntegerObject: oop) ifTrue:[^0].	^self lengthOf: oop! !!Interpreter methodsFor: 'contexts' stamp: 'ar 10/7/1998 18:16'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 10/7/1998 18:14'!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 10/9/1998 11:21'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger)		* The function address (Integer)	"	| thisSession lit functionAddress addr moduleName functionName moduleLength functionLength session |	self var: #thisSession declareC:'static int thisSession = 0'.	"Make sure the session is initialized"	thisSession = 0 ifTrue:[		thisSession _ self ioMicroMSecs bitAnd: 16r1FFFFFFF.		thisSession = 0 ifTrue:[thisSession _ 1]].	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0.	"@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function address and session id in case it has been loaded before"	addr _ self positive32BitValueOf: (self fetchPointer: 3 ofObject: lit).	session _ self fetchInteger: 2 ofObject: lit.	"If so, call the function directly"	(successFlag and:[session = thisSession and:[addr ~= 0]])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'].	"Clean up session id and function address"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	addr _ self ioLoadExternalFunction: functionName + 4				OfLength: functionLength 				FromModule: moduleName + 4				OfLength: moduleLength.	self success: addr ~= 0.	"If the function has been successfully loaded process it"	successFlag ifTrue:[		"Store the session ID"		self storeInteger: 2 ofObject: lit withValue: thisSession.		"Store the address back in the literal"		self pushRemappableOop: lit.		functionAddress _ self positive32BitIntegerFor: addr.		lit _ self popRemappableOop.		self storePointer: 3 ofObject: lit withValue: functionAddress.		(successFlag and:[addr ~= 0])			ifTrue:[self cCode:' ((int (*) (void)) addr) ()'].	].! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:34'!byteSizeOf: oop	| slots |	(self isIntegerObject: oop) ifTrue:[^0].	slots _ self slotSizeOf: oop.	(self isBytes: oop)		ifTrue:[^slots]		ifFalse:[^slots * 4]! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| srcName name length |	self var: #className declareC:'char *className'.	self var: #srcName declareC:'char *srcName'.	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	length _ self stSizeOf: name.	srcName _ self cCoerce: (self arrayValueOf: name) to:'char *'.	0 to: length-1 do:[:i|		(srcName at: i) = (className at: i) ifFalse:[^false].	].	"Check if className really ends at this point"	^(className at: length) = 0! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!firstFixedField: oop	self returnTypeC:'void *'.	^self cCoerce: oop+4 to:'void *'.! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!firstIndexableField: oop	| hdr fmt totalLength fixedFields |	self returnTypeC:'void *'.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	fmt < 8 ifTrue:["32 bit field objects"		^ self cCoerce: oop+4+ (fixedFields << 2) to:'void *'.	] ifFalse:["Byte objects"		^ self cCoerce: oop+4+fixedFields to:'void *'.	]! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!floatObjectOf: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	^newFloatObj! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop KindOf: className	"Support for external primitives."	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	[oopClass == nilObj] whileFalse:[		(self classNameOf: oopClass Is: className) ifTrue:[^true].		oopClass _ self superclassOf: oopClass].	^false! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop MemberOf: className	"Support for external primitives"	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	^(self classNameOf: oopClass Is: className)! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isFloatObject: oop	^(self fetchClassOf: oop) == self classFloat! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isIndexable: oop	^(self formatOf: oop) >= 2! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:38'!methodArgumentCount	^argumentCount! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!methodPrimitiveIndex	^primitiveIndex! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/10/1998 21:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	(self isIntegerObject: oop) ifTrue:[^0].	^self lengthOf: oop! !!Parser methodsFor: 'primitives' stamp: 'ar 10/7/1998 20:15' prior: 20519750!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse:[^0].	prim _ here.	(self match: #number) ifTrue:[^prim].	"Indexed primitives"	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^117! !!PluggableCodeGenerator commentStamp: '<historical>' prior: 0!I generate code that can be loaded dynamically from external libraries (e.g., DSOs on Unix or DLLs on Windows)!!PluggableCodeGenerator methodsFor: 'testing' stamp: 'ar 10/7/1998 17:54'!isGeneratingPluginCode	^true! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'ar 10/11/1998 03:04'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define successFlag (!!interpreterProxy->failed())#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayValueOf(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value)EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter);/*** Variables ***/struct VirtualMachine *interpreterProxy;EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == false) {		return false;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'ar 10/10/1998 21:36'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */';cr.	aStream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/7/1998 20:31'!storeVirtualMachineProxyHeader: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr; crtab.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitProxyFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; crtab]].	stream nextPutAll:'} VirtualMachine;#endif /* _SqueakVM_H */'.	stream close.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/11/1998 00:52'!storeVirtualMachineProxyImplementation: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"'; cr;cr.	stream nextPutAll:'/*** Function prototypes ***/'.	categoryList do:[:assoc|		stream cr; cr; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitCFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; cr]].	stream cr; nextPutAll:'struct VirtualMachine *VM = NULL;'; cr.	stream cr; nextPutAll:'static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; crtab.		assoc value asSortedCollection do:[:sel|		stream nextPutAll:'VM->';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:' = ';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:';';			crtab]].	stream cr; crtab; nextPutAll:'return VM;'; cr; nextPutAll:'}'; cr.	stream close.! !!TMethod methodsFor: 'initialization' stamp: 'ar 9/18/1998 23:24' prior: 21871254!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	export _ self extractExportDirective.	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'primitive compilation' stamp: 'ar 10/10/1998 23:36' prior: 21880246!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	"ar 10/7/1998 -- 	Add the export directive for translated primitives.				--	Use the name of the primitive if it's called by name."	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	primArgCount _ args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn _ self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	"Check for pluggable primitive"	primitive = 117 		ifTrue:[	selector _ (aClass compiledMethodAt: selector) literals first at: 2.				export _ true]		ifFalse:[selector _ 'prim', aClass name, selector].	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].! !!TMethod methodsFor: 'transformations' stamp: 'ar 10/7/1998 18:55'!extractExportDirective	"Scan the top-level statements for an inlining directive of the form:		self export: <boolean>	 and remove the directive from the method body. Return the argument of the directive or false if there is no export directive."	| result newStatements |	result _ false.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #export:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25' prior: 21911515!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	export 		ifTrue:[aStream nextPutAll:'EXPORT('; nextPutAll: returnType; nextPutAll:') ']		ifFalse:[aStream nextPutAll: returnType; space].	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25'!emitProxyFunctionPrototype: aStream generator: aCodeGen	"Emit an indirect C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: '(*', (aCodeGen cFunctionNameFor: selector), ')('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TSendNode methodsFor: 'all' stamp: 'ar 10/7/1998 17:53' prior: 21916900!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Special case for pluggable modules. Replace messages to interpreterProxy	by interpreterProxy->message(..) if the message is not builtin"	(aCodeGen isGeneratingPluginCode and:[		receiver isVariable and:[			receiver name = 'interpreterProxy' and:[				self isBuiltinOperator not]]]) 		ifTrue:[aStream nextPutAll:'interpreterProxy->'].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !InterpreterPlugin initialize!'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:28 am'!"Change Set:		PluggablePrims-Support-arDate:			11 October 1998Author:			Andreas RaabThis change set includes the necessary modificationsin the VM support code by* Adding the files sqVirtualMachine.h and sqVirtualMachine.c  for the InterpreterProxy* Changing the sq.h file by	* Adding the EXPORT() macro	* Adding the function declaration for sqGetInterpreterProxy()	* Adding the function declaration for platform-dependent	  loading of named functions from external libraries* Changing the sqPlatformSpecific.h file to include the necessary  Win32 definitions* Providing a stub for the Mac implementation of loading    named primitives* Changing the writeMacSourceFiles function to reflect the above changes"!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'ar 10/9/1998 12:25' prior: 34313665!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self squeakVirtualMachineHeaderFile	onFileNamed: 'sqVirtualMachine.h'.	self storeString: self squeakVirtualMachineFile	onFileNamed: 'sqVirtualMachine.c'.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	self storeString: self macExternalPrimsFile		onFileNamed: 'sqMacExternalPrims.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives													onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/10/1998 23:23'!macExternalPrimsFile^'/*	Stubbed out for now.*/#include "sq.h"int ioLoadExternalFunctionOfLengthFromModuleOfLength(int functionNameIndex, int functionNameLength, int moduleNameIndex, int moduleNameLength){  return success(false);}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 00:21' prior: 34475198!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define LITTLE_ENDIAN_BITBLT# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  define  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   if defined(ITSY)#     define LITTLE_ENDIAN_BITBLT#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 01:05' prior: 34482993!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** pluggable primitive support ***/struct VirtualMachine* sqGetInterpreterProxy(void);int ioLoadExternalFunctionOfLengthFromModuleOfLength(int functionNameIndex, int functionNameLength, int moduleNameIndex,   int moduleNameLength);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 00:24' prior: 34494727!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*//* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"#ifdef macintosh/* macintosh memory allocation */#include <Memory.h>#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) NewPtr(desiredHeapSize)/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWritetypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num) #endif /* ACORN */#ifdef LITTLE_ENDIAN_BITBLT#define ifLittleEndianDoelseDo(a, b) a#else#define ifLittleEndianDoelseDo(a, b) b#endif#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#ifdef _MSC_VER#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif #endif /* WIN32 */'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 03:01'!squeakVirtualMachineFile^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"/*** Function prototypes ***//* InterpreterProxy methodsFor: ''stack access'' */int pop(int nItems);int popthenPush(int nItems, int oop);int push(int object);int pushBool(int trueOrFalse);int pushFloat(double f);int pushInteger(int integerValue);double stackFloatValue(int offset);int stackIntegerValue(int offset);int stackObjectValue(int offset);int stackValue(int offset);/* InterpreterProxy methodsFor: ''object access'' */int argumentCountOf(int methodPointer);void * arrayValueOf(int oop);int byteSizeOf(int oop);void * fetchArrayofObject(int fieldIndex, int objectPointer);int fetchClassOf(int oop);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);int fetchPointerofObject(int index, int oop);int fetchWordofObject(int fieldIndex, int oop);void * firstFixedField(int oop);void * firstIndexableField(int oop);int literalofMethod(int offset, int methodPointer);int literalCountOf(int methodPointer);int methodArgumentCount(void);int methodPrimitiveIndex(void);int primitiveIndexOf(int methodPointer);int sizeOfSTArrayFromCPrimitive(void *cPtr);int slotSizeOf(int oop);int stObjectat(int array, int index);int stObjectatput(int array, int index, int value);int stSizeOf(int oop);int storeIntegerofObjectwithValue(int index, int oop, int integer);int storePointerofObjectwithValue(int index, int oop, int valuePointer);/* InterpreterProxy methodsFor: ''testing'' */int isKindOf(int oop, char *aString);int isMemberOf(int oop, char *aString);int isBytes(int oop);int isFloatObject(int oop);int isIndexable(int oop);int isIntegerObject(int objectPointer);int isIntegerValue(int intValue);int isPointers(int oop);int isWeak(int oop);int isWords(int oop);int isWordsOrBytes(int oop);/* InterpreterProxy methodsFor: ''converting'' */int booleanValueOf(int obj);int checkedIntegerValueOf(int intOop);int floatObjectOf(double aFloat);double floatValueOf(int oop);int integerObjectOf(int value);int integerValueOf(int oop);int positive32BitIntegerFor(int integerValue);int positive32BitValueOf(int oop);/* InterpreterProxy methodsFor: ''special objects'' */int characterTable(void);int displayObject(void);int falseObject(void);int nilObject(void);int trueObject(void);/* InterpreterProxy methodsFor: ''special classes'' */int classArray(void);int classBitmap(void);int classByteArray(void);int classCharacter(void);int classFloat(void);int classLargePositiveInteger(void);int classPoint(void);int classSemaphore(void);int classSmallInteger(void);int classString(void);/* InterpreterProxy methodsFor: ''instance creation'' */int clone(int oop);int instantiateClassindexableSize(int classPointer, int size);int makePointwithxValueyValue(int xValue, int yValue);int popRemappableOop(void);int pushRemappableOop(int oop);/* InterpreterProxy methodsFor: ''other'' */int becomewith(int array1, int array2);int byteSwapped(int w);int failed(void);int fullDisplayUpdate(void);int fullGC(void);int incrementalGC(void);int primitiveFail(void);int showDisplayBitsLeftTopRightBottom(int aForm, int l, int t, int r, int b);int signalSemaphoreWithIndex(int semaIndex);int success(int aBoolean);int superclassOf(int classPointer);struct VirtualMachine *VM = NULL;static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;	/* InterpreterProxy methodsFor: ''stack access'' */	VM->pop = pop;	VM->popthenPush = popthenPush;	VM->push = push;	VM->pushBool = pushBool;	VM->pushFloat = pushFloat;	VM->pushInteger = pushInteger;	VM->stackFloatValue = stackFloatValue;	VM->stackIntegerValue = stackIntegerValue;	VM->stackObjectValue = stackObjectValue;	VM->stackValue = stackValue;		/* InterpreterProxy methodsFor: ''object access'' */	VM->argumentCountOf = argumentCountOf;	VM->arrayValueOf = arrayValueOf;	VM->byteSizeOf = byteSizeOf;	VM->fetchArrayofObject = fetchArrayofObject;	VM->fetchClassOf = fetchClassOf;	VM->fetchFloatofObject = fetchFloatofObject;	VM->fetchIntegerofObject = fetchIntegerofObject;	VM->fetchPointerofObject = fetchPointerofObject;	VM->fetchWordofObject = fetchWordofObject;	VM->firstFixedField = firstFixedField;	VM->firstIndexableField = firstIndexableField;	VM->literalofMethod = literalofMethod;	VM->literalCountOf = literalCountOf;	VM->methodArgumentCount = methodArgumentCount;	VM->methodPrimitiveIndex = methodPrimitiveIndex;	VM->primitiveIndexOf = primitiveIndexOf;	VM->sizeOfSTArrayFromCPrimitive = sizeOfSTArrayFromCPrimitive;	VM->slotSizeOf = slotSizeOf;	VM->stObjectat = stObjectat;	VM->stObjectatput = stObjectatput;	VM->stSizeOf = stSizeOf;	VM->storeIntegerofObjectwithValue = storeIntegerofObjectwithValue;	VM->storePointerofObjectwithValue = storePointerofObjectwithValue;		/* InterpreterProxy methodsFor: ''testing'' */	VM->isKindOf = isKindOf;	VM->isMemberOf = isMemberOf;	VM->isBytes = isBytes;	VM->isFloatObject = isFloatObject;	VM->isIndexable = isIndexable;	VM->isIntegerObject = isIntegerObject;	VM->isIntegerValue = isIntegerValue;	VM->isPointers = isPointers;	VM->isWeak = isWeak;	VM->isWords = isWords;	VM->isWordsOrBytes = isWordsOrBytes;		/* InterpreterProxy methodsFor: ''converting'' */	VM->booleanValueOf = booleanValueOf;	VM->checkedIntegerValueOf = checkedIntegerValueOf;	VM->floatObjectOf = floatObjectOf;	VM->floatValueOf = floatValueOf;	VM->integerObjectOf = integerObjectOf;	VM->integerValueOf = integerValueOf;	VM->positive32BitIntegerFor = positive32BitIntegerFor;	VM->positive32BitValueOf = positive32BitValueOf;		/* InterpreterProxy methodsFor: ''special objects'' */	VM->characterTable = characterTable;	VM->displayObject = displayObject;	VM->falseObject = falseObject;	VM->nilObject = nilObject;	VM->trueObject = trueObject;		/* InterpreterProxy methodsFor: ''special classes'' */	VM->classArray = classArray;	VM->classBitmap = classBitmap;	VM->classByteArray = classByteArray;	VM->classCharacter = classCharacter;	VM->classFloat = classFloat;	VM->classLargePositiveInteger = classLargePositiveInteger;	VM->classPoint = classPoint;	VM->classSemaphore = classSemaphore;	VM->classSmallInteger = classSmallInteger;	VM->classString = classString;		/* InterpreterProxy methodsFor: ''instance creation'' */	VM->clone = clone;	VM->instantiateClassindexableSize = instantiateClassindexableSize;	VM->makePointwithxValueyValue = makePointwithxValueyValue;	VM->popRemappableOop = popRemappableOop;	VM->pushRemappableOop = pushRemappableOop;		/* InterpreterProxy methodsFor: ''other'' */	VM->becomewith = becomewith;	VM->byteSwapped = byteSwapped;	VM->failed = failed;	VM->fullDisplayUpdate = fullDisplayUpdate;	VM->fullGC = fullGC;	VM->incrementalGC = incrementalGC;	VM->primitiveFail = primitiveFail;	VM->showDisplayBitsLeftTopRightBottom = showDisplayBitsLeftTopRightBottom;	VM->signalSemaphoreWithIndex = signalSemaphoreWithIndex;	VM->success = success;	VM->superclassOf = superclassOf;		return VM;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 10/11/1998 03:02'!squeakVirtualMachineHeaderFile^ '#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);	/* InterpreterProxy methodsFor: ''stack access'' */	int (*pop)(int nItems);	int (*popthenPush)(int nItems, int oop);	int (*push)(int object);	int (*pushBool)(int trueOrFalse);	int (*pushFloat)(double f);	int (*pushInteger)(int integerValue);	double (*stackFloatValue)(int offset);	int (*stackIntegerValue)(int offset);	int (*stackObjectValue)(int offset);	int (*stackValue)(int offset);		/* InterpreterProxy methodsFor: ''object access'' */	int (*argumentCountOf)(int methodPointer);	void * (*arrayValueOf)(int oop);	int (*byteSizeOf)(int oop);	void * (*fetchArrayofObject)(int fieldIndex, int objectPointer);	int (*fetchClassOf)(int oop);	double (*fetchFloatofObject)(int fieldIndex, int objectPointer);	int (*fetchIntegerofObject)(int fieldIndex, int objectPointer);	int (*fetchPointerofObject)(int index, int oop);	int (*fetchWordofObject)(int fieldIndex, int oop);	void * (*firstFixedField)(int oop);	void * (*firstIndexableField)(int oop);	int (*literalofMethod)(int offset, int methodPointer);	int (*literalCountOf)(int methodPointer);	int (*methodArgumentCount)(void);	int (*methodPrimitiveIndex)(void);	int (*primitiveIndexOf)(int methodPointer);	int (*sizeOfSTArrayFromCPrimitive)(void *cPtr);	int (*slotSizeOf)(int oop);	int (*stObjectat)(int array, int index);	int (*stObjectatput)(int array, int index, int value);	int (*stSizeOf)(int oop);	int (*storeIntegerofObjectwithValue)(int index, int oop, int integer);	int (*storePointerofObjectwithValue)(int index, int oop, int valuePointer);		/* InterpreterProxy methodsFor: ''testing'' */	int (*isKindOf)(int oop, char *aString);	int (*isMemberOf)(int oop, char *aString);	int (*isBytes)(int oop);	int (*isFloatObject)(int oop);	int (*isIndexable)(int oop);	int (*isIntegerObject)(int objectPointer);	int (*isIntegerValue)(int intValue);	int (*isPointers)(int oop);	int (*isWeak)(int oop);	int (*isWords)(int oop);	int (*isWordsOrBytes)(int oop);		/* InterpreterProxy methodsFor: ''converting'' */	int (*booleanValueOf)(int obj);	int (*checkedIntegerValueOf)(int intOop);	int (*floatObjectOf)(double aFloat);	double (*floatValueOf)(int oop);	int (*integerObjectOf)(int value);	int (*integerValueOf)(int oop);	int (*positive32BitIntegerFor)(int integerValue);	int (*positive32BitValueOf)(int oop);		/* InterpreterProxy methodsFor: ''special objects'' */	int (*characterTable)(void);	int (*displayObject)(void);	int (*falseObject)(void);	int (*nilObject)(void);	int (*trueObject)(void);		/* InterpreterProxy methodsFor: ''special classes'' */	int (*classArray)(void);	int (*classBitmap)(void);	int (*classByteArray)(void);	int (*classCharacter)(void);	int (*classFloat)(void);	int (*classLargePositiveInteger)(void);	int (*classPoint)(void);	int (*classSemaphore)(void);	int (*classSmallInteger)(void);	int (*classString)(void);		/* InterpreterProxy methodsFor: ''instance creation'' */	int (*clone)(int oop);	int (*instantiateClassindexableSize)(int classPointer, int size);	int (*makePointwithxValueyValue)(int xValue, int yValue);	int (*popRemappableOop)(void);	int (*pushRemappableOop)(int oop);		/* InterpreterProxy methodsFor: ''other'' */	int (*becomewith)(int array1, int array2);	int (*byteSwapped)(int w);	int (*failed)(void);	int (*fullDisplayUpdate)(void);	int (*fullGC)(void);	int (*incrementalGC)(void);	int (*primitiveFail)(void);	int (*showDisplayBitsLeftTopRightBottom)(int aForm, int l, int t, int r, int b);	int (*signalSemaphoreWithIndex)(int semaIndex);	int (*success)(int aBoolean);	int (*superclassOf)(int classPointer);	} VirtualMachine;#endif /* _SqueakVM_H */'! !'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:30 am'!"Change Set:		PluggablePrims-Examples-arDate:			11 October 1998Author:			Andreas RaabThe change set includes two examples for pluggable primitives.FloatArrays - Arrays storing 32bit IEEE floating point numberfor numerically heavy computations.FFT - Using FloatArrays to speed up the FFT computation byabout a factor of 150 (yes, really!!). The FFTPlugin is also anexample how entire plugins can be simulated from Smalltalkcode and how to deal with instance specific data in a primitive.Finally, the translation methods of Interpreter DynamicInterpreterhave been modified to translate the two plugins in the source code."!InterpreterPlugin subclass: #FFTPlugin	instanceVariableNames: 'nu fftSize sinTable sinTableSize permTable permTableSize realData realDataSize imagData imagDataSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!InterpreterPlugin subclass: #FloatArrayPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!ArrayedCollection variableWordSubclass: #FloatArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!ArrayedCollection variableWordSubclass: #IntegerArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!ArrayedCollection variableWordSubclass: #WordArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!DynamicInterpreter class methodsFor: 'translation' stamp: 'ar 10/11/1998 00:32' prior: 18190114!translate: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: false.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: false.		Smalltalk beep]"	self	translate: fileName		doInlining: inlineFlag		doAssertions: assertionFlag		fromClasses: (OrderedCollection new				add: BitBltSimulation;				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;				add: FFTPlugin;				add: FloatArrayPlugin;			yourself)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginPrepareData	"The FFT plugin requires data to be represented in WordArrays or FloatArrays"	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ realData asFloatArray.	imagData _ imagData asFloatArray.! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginTest  "Display restoreAfter: [(FFT new nu: 12) pluginTest]."	"Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self pluginPrepareData.	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: true]); endEntry.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: false]); endEntry.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/11/1998 02:52'!pluginTransformData: forward	"Plugin testing -- if the primitive is not implemented 	or cannot be found run the simulation. See also: FFTPlugin"	<primitive: 'primitiveFFTTransformData'>	^FFTPlugin doPrimitive: 'primitiveFFTTransformData'.! !!FFTPlugin commentStamp: '<historical>' prior: 0!FFTPlugin is an example  of how plugins are written. It shows the use of FloatArray for heavy numerical stuff as well as the simulation of plugins from Squeak.See also:		FFT pluginTransformData:!]style[(173 24 1)f1,f1LFFT pluginTransformData:;,f1!!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTPermuteData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData].! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTScaleData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self scaleData.! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTTransformData	| rcvr forward |	self export: true.	forward _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	rcvr _ interpreterProxy stackObjectValue: 1.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self transformData: forward.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 00:25'!permuteData	| i end a b tmp |	self var: #tmp declareC: 'float tmp'.	i _ 0.	end _ permTableSize.	[i < end] whileTrue:		[a _ (permTable at: i) - 1.		b _ (permTable at: i+1) - 1.		(a < realDataSize and:[b < realDataSize]) ifFalse:[^interpreterProxy success: false].		tmp _ realData at: a.		realData at: a put: (realData at: b).		realData at: b put: tmp.		tmp _ imagData at: a.		imagData at: a put: (imagData at: b).		imagData at: b put: tmp.		i _ i + 2]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 10/3/1998 18:10'!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	self var: #realN declareC: 'float realN'.	fftSize <= 1 ifTrue:[^nil].	realN _ self cCoerce: (1.0 / (self cCoerce: fftSize to: 'double')) to: 'float'.	0 to: fftSize-1 do:		[:i |		realData at: i put: (realData at: i) * realN.		imagData at: i put: (imagData at: i) * realN]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 20:21'!transformData: forward	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData.		^nil].	self transformForward: forward.	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 21:28'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i fftSize2 fftSize4 fftScale ii |	self var: #realU declareC:'float realU'.	self var: #realT declareC:'float realT'.	self var: #imagU declareC:'float imagU'.	self var: #imagT declareC:'float imagT'.	fftSize2 _ fftSize // 2.	fftSize4 _ fftSize // 4.	1 to: nu do:		[:level |		lev _ 1 bitShift: level.		lev1 _ lev // 2.		fftScale _ fftSize // lev.		1 to: lev1 do:			[:j |			theta _ j-1 * fftScale.   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < fftSize4  "Compute U, the complex multiplier for each level"				ifTrue:					[realU _ sinTable at: sinTableSize - theta - 1.					imagU _ sinTable at: theta]				ifFalse:					[realU _ 0.0 - (sinTable at: theta - fftSize4).					imagU _ sinTable at: fftSize2 - theta].			forward ifFalse: [imagU _ 0.0 - imagU]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i _ j.			[i <= fftSize] whileTrue:				[ip _ i + lev1 - 1.				ii _ i-1.				realT _ ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT _ ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: ii) - realT.				imagData at: ip put: (imagData at: ii) - imagT.				realData at: ii put: (realData at: ii) + realT.				imagData at: ii put: (imagData at: ii) + imagT.				i _ i + lev]]].! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedFloatPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'float *'.	interpreterProxy success: (interpreterProxy isWords: oop).	interpreterProxy failed ifTrue:[^0].	^self cCoerce: (interpreterProxy firstIndexableField: oop) to:'float *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedWordPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'unsigned int *'.	interpreterProxy success: (interpreterProxy isWords: oop).	^self cCoerce: (interpreterProxy firstIndexableField: oop) to: 'unsigned int *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 10/10/1998 21:43'!loadFFTFrom: fftOop	| oop |	interpreterProxy success: (interpreterProxy slotSizeOf: fftOop) >= 6.	interpreterProxy failed ifTrue:[^false].	nu _ interpreterProxy fetchInteger: 0 ofObject: fftOop.	fftSize _ interpreterProxy fetchInteger: 1 ofObject: fftOop.	oop _ interpreterProxy fetchPointer: 2 ofObject: fftOop.	sinTableSize _ interpreterProxy stSizeOf: oop.	sinTable _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 3 ofObject: fftOop.	permTableSize _ interpreterProxy stSizeOf: oop.	permTable _ self checkedWordPtrOf: oop.	oop _ interpreterProxy fetchPointer: 4 ofObject: fftOop.	realDataSize _ interpreterProxy stSizeOf: oop.	realData _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 5 ofObject: fftOop.	imagDataSize _ interpreterProxy stSizeOf: oop.	imagData _ self checkedFloatPtrOf: oop.	"Check assumptions about sizes"	interpreterProxy success:		(1 << nu = fftSize) & 		(fftSize // 4 + 1 = sinTableSize) & 		(fftSize = realDataSize) & 		(fftSize = imagDataSize) &		(realDataSize = imagDataSize).	^interpreterProxy failed == false! !!FFTPlugin class methodsFor: 'accessing' stamp: 'ar 9/14/1998 23:51'!moduleName	^'sqFFT'! !!FFTPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:27'!declareCVarsIn: cg	cg var: 'sinTable' declareC:'float *sinTable'.	cg var: 'realData' declareC: 'float *realData'.	cg var: 'imagData' declareC:'float *imagData'.	cg var: 'permTable' declareC:'unsigned int *permTable'.! !!FloatArray class methodsFor: 'primitive generation' stamp: 'ar 10/11/1998 03:06'!cCodeString	"FloatArray cCodeString"	^PluggableCodeGenerator new codeStringForPrimitives:#(		(FloatArray primAddArray:withArray:from:to:)		(FloatArray primSubArray:withArray:from:to:)		(FloatArray primMulArray:withArray:from:to:)	)! !!FloatArrayPlugin commentStamp: '<historical>' prior: 0!FloatArrayPlugin defines the basic access messages for FloatArray (e.g., floatAt: and floatAt:put:).!!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:46'!primitiveFloatArrayAt	| index rcvr floatValue floatPtr |	self export: true.	self var: #floatValue declareC:'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	index _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatValue _ (floatPtr at: index-1) asFloat.	interpreterProxy pop: 2.	interpreterProxy pushFloat: floatValue.! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:46'!primitiveFloatArrayAtPut	| value floatValue index rcvr floatPtr |	self export: true.	self var: #floatValue declareC: 'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	value _ interpreterProxy stackObjectValue: 0.	floatValue _ interpreterProxy floatValueOf: value.	index _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatPtr at: index-1 put: (self cCoerce: floatValue to:'float').	interpreterProxy failed ifFalse:[interpreterProxy pop: 3 thenPush: value].! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayEqual	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 2.	length _ interpreterProxy stSizeOf: arg.	length = (interpreterProxy stSizeOf: rcvr) ifFalse:[^interpreterProxy pushBool: false].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		(rcvrPtr at: i) = (argPtr at: i) ifFalse:[^interpreterProxy pushBool: false].	].	^interpreterProxy pushBool: true! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayHash	| rcvr rcvrPtr length result |	self export: true.	self var: #rcvrPtr declareC:'int *rcvrPtr'.	rcvr _ interpreterProxy stackObjectValue: 0.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int *'.	result _ 0.	0 to: length-1 do:[:i|		result _ result + (rcvrPtr at: i).		rcvrPtr _ rcvrPtr + 4.	].	interpreterProxy pop: 1.	^interpreterProxy pushInteger: (result bitAnd: 16r1FFFFFFF)! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	"Check if any of the argument's values is zero"	0 to: length-1 do:[:i|		(interpreterProxy longAt: (argPtr + i)) = 0 ifTrue:[^interpreterProxy primitiveFail]].	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) / (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value inverse length |	self export: true.	self var: #value declareC:'double value'.	self var: #inverse declareC:'double inverse'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	value = 0.0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	inverse _ 1.0 / value.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * inverse.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^'SqFloatArray'! !!FloatArrayPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:30'!declareCVarsIn: cg	"Nothing to declare..."! !!Interpreter class methodsFor: 'translation' stamp: 'ar 10/11/1998 00:26' prior: 19388316!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray _ FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray _ IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray _ WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!FloatArray commentStamp: '<historical>' prior: 0!FloatArrays store 32bit IEEE floating point numbers.!!FloatArray methodsFor: 'accessing' stamp: 'ar 10/11/1998 02:45'!at: index	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!FloatArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 21:54'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!* anObject	^self clone *= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!*= anObject	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!+ anObject	^self clone += anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:48'!+= anObject	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!- anObject	^self clone -= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!-= anObject	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:34'!/ anObject	^self clone /= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 10/7/1998 19:58'!/= anObject	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!= aFloatArray	| length |	<primitive:'primitiveFloatArrayEqual'>	length _ self size.	(length = aFloatArray size) ifFalse:[^false].	1 to: self size do:[:i| (self at: i) = (aFloatArray at: i) ifFalse:[^false]].	^true! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/11/1998 03:10'!primAddArray: floatArray	<primitive: 'primitiveFloatArrayAddFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primAddScalar: scalarValue	<primitive: 'primitiveFloatArrayAddScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primDivArray: floatArray	<primitive: 'primitiveFloatArrayDivFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primDivScalar: scalarValue	<primitive: 'primitiveFloatArrayDivScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primMulArray: floatArray	<primitive: 'primitiveFloatArrayMulFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primMulScalar: scalarValue	<primitive: 'primitiveFloatArrayMulScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:01'!primSubArray: floatArray	<primitive: 'primitiveFloatArraySubFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primSubScalar: scalarValue	<primitive: 'primitiveFloatArraySubScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/11/1998 03:06'!primAddArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayAddFloatArrayFromTo' module: 'sqPlugin'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) + (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primMulArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayMulFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) * (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primSubArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArraySubFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) - (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asFloatArray	^self! !!FloatArray methodsFor: 'private' stamp: 'ar 10/10/1998 17:40'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!FloatArray methodsFor: 'private' stamp: 'ar 10/10/1998 17:40'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.! !!FloatArray methodsFor: 'private' stamp: 'ar 10/9/1998 11:27'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!IntegerArray commentStamp: '<historical>' prior: 0!IntegerArrays store 32bit signed Integer values.Negative values are stored as 2's complement.!!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index put: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger - 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'converting' stamp: 'ar 10/10/1998 16:18'!asIntegerArray	^self! !!WordArray commentStamp: '<historical>' prior: 0!IntegerArrays store 32bit unsigned Integer values.!!WordArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asWordArray	^self! !'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 7:53:29 pm'!!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 19:52' prior: 35810147!primitiveFloatArrayAtPut	| value floatValue index rcvr floatPtr |	self export: true.	self var: #floatValue declareC: 'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	value _ interpreterProxy stackValue: 0.	(interpreterProxy isIntegerObject: value)		ifTrue:[floatValue _ (interpreterProxy integerValueOf: value) asFloat]		ifFalse:[floatValue _ interpreterProxy floatValueOf: value].	index _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatPtr at: index-1 put: (self cCoerce: floatValue to:'float').	interpreterProxy failed ifFalse:[interpreterProxy pop: 3 thenPush: value].! !'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 1:55:25 pm'!"Change Set:		TR-VM-FixesDate:			13 October 1998Author:			Andreas RaabTwo fixes suggested by Tim Rowledge:#1 fixes a possibly fatal bug in argumentCountOf:#2 fixes a problem from using #normalSend in bytecodePrimAt and bytecodePrimAtPut"!!DynamicInterpreter methodsFor: 'compiled methods' stamp: 'ar 10/13/1998 13:49' prior: 17986208!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r0F! !!Interpreter methodsFor: 'compiled methods' stamp: 'ar 10/13/1998 13:50' prior: 19180603!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r0F! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 10/13/1998 13:51' prior: 19250955!commonAt: stringy	"This version of at: is called from the special byteCode, from	primitiveAt, and from primStringAt.  The boolean 'stringy'	indicates that the result should be converted to a Character."	| index rcvr result |	self inline: true.	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		result _ self stObject: rcvr at: index.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result].	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 2 thenPush: result.	].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 10/13/1998 13:52' prior: 19251757!commonAtPut: stringy	"See the comment in commonAt:."	| value valToStore index rcvr |	self inline: true.	value _ valToStore _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 3 thenPush: value.	].! !'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 12:38:25 pm'!"Change Set:		isUnderMouse-swDate:			13 October 1998Author:			Scott WallaceAdds an #isUnderMouse slot to the Viewer, for use in scripting.  isUnderMouse returns true if any part of the player's current costume is under the current mouse location, whether the object is occluded at that point or not.  The implementation is 'flex-aware'.Also, moves initialization of the scripting help-dictionary to the instance side of StandardScriptingSystem, remedying an anomaly attributable to historical accident."!!Player methodsFor: 'slots-kernel' stamp: 'sw 10/7/1998 09:12' prior: 34859207!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 10/7/1998 09:31'!getIsUnderMouse	costume isInWorld ifFalse: [^ false].	^ costume containsPoint: (costume pointFromWorld: costume primaryHand lastEvent cursorPoint)! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 10/7/1998 09:49' prior: 35194770!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(isOverColor		boolean'Whether any part of thisobject is directly over thespecified color')(isUnderMouse	boolean'Whether any part of thisobject is beneath the currentmouse-cursor position')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(objectNameInHalo  control'Object''s name -- To change:click here; backspace over old name,type in new name; hit ENTER')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 10/7/1998 09:32'!initializeSystemSlotDictionary	"ScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(seesColor		boolean)		(isUnderMouse	boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 10/13/1998 12:32' prior: 35202676!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	Smalltalk at: #ScriptingSystem put: (self new initializeSystemSlotDictionary; initializeHelpStrings; yourself)! !StandardScriptingSystem class removeSelector: #initializeSystemSlotDictionary!StandardScriptingSystem class removeSelector: #initializeSystemSlotDictionary!StandardScriptingSystem initialize!'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 12:46:04 pm'!"Change Set:		watcherFormat-swDate:			13 October 1998Author:			Scott WallaceAdds menu items allowing specification of number of decimal places, font size, and font family to the UpdatingStringMorph, used in watchers and viewers.Also, removes the 'tear-off-value-tile' feature I added in August 1998 -- turns out I had misunderstood Alan's request.  The watchers turned out to be the solution to his wishes, but I never until now got around to ripping out the falsely-interpreted path"!!Morph methodsFor: 'scripting' stamp: 'sw 10/6/1998 17:10' prior: 34699959!tearOffTile	^ self assuredPlayer tearOffTileForSelf! !!StrikeFont methodsFor: 'accessing' stamp: 'sw 10/5/1998 16:38'!textStyle	^ Utilities actualTextStyles detect:		[:aStyle | aStyle fontArray includes: self] ifNone: [nil]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/6/1998 08:02' prior: 22214804!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target scriptPerformer perform: getSelector.	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 08:26' prior: 35370419!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ self growable		ifTrue:			['stop']		ifFalse:			['start'].	menu add: prefix, ' being growable' action: #toggleGrowability.	menu add: 'decimal places...' action: #setPrecision.	menu add: 'font size...' action: #setFontSize.	menu add: 'font style...' action: #setFontStyle! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 17:34'!setFontSize	| sizes reply family aPair |	family _ font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family _ TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes _ 	family fontNamesAndSizes collect: [:aString |		aPair _ aString findTokens: ' '.		aPair second asNumber].	reply _ (SelectionMenu labelList: (sizes collect: [:s | s printString]) selections: sizes) startUp.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/6/1998 17:42'!setFontStyle	| aList reply style |	aList _ (TextConstants select: [:anItem | anItem isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		self font: (style fontArray at: 2)]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 10/5/1998 15:31'!setPrecision	| aList aMenu reply |	aList _ #('0' '1' '2' '3' '4' '5').	aMenu _ SelectionMenu labels: aList selections: aList.	reply _ aMenu startUpWithCaption: 'How many decimal places?'.	reply ifNotNil:		[self floatPrecision:			(#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001) at: (aList indexOf: reply))]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/1998 17:41'!actualTextStyles   "Utilities actualTextStyles"	| aCollection |	aCollection _ OrderedCollection new.	(TextConstants select: [:anItem | anItem isKindOf: TextStyle]) do:		[:aStyle | aCollection add: aStyle].	^ aCollection! !Morph removeSelector: #valueAsConstant!Morph removeSelector: #valueAsConstant!StringMorph removeSelector: #valueAsConstant!StringMorph removeSelector: #valueAsConstant!UpdatingRectangleMorph removeSelector: #valueAsConstant!UpdatingRectangleMorph removeSelector: #valueAsConstant!UpdatingStringMorph removeSelector: #valueAsConstant!UpdatingStringMorph removeSelector: #valueAsConstant!'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 12:47:20 pm'!"Change Set:		dropThumbnail-swDate:			13 October 1998Author:			Scott WallaceWhen a MorphThumbnail is dropped on a pasteup that is not showing thumbnails, what gets dropped will be the original representee, if all is well"!!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/8/1998 16:18' prior: 34808900!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 1:48:49 pm'!"Change Set:		timeStamp-swDate:			13 October 1998Author:			Scott WallaceMakes the extracting of the time-stamp for a method from a source file (finally) a much less heavy-weight operation, by just retrieving the current source, not all historical versions."!!StringHolder methodsFor: 'message list menu' stamp: 'sw 10/13/1998 13:31' prior: 35235195!timeStamp	|  selector  aMethod |	^ (selector _ self selectedMessageName) ifNotNil:		[aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: [nil].		aMethod ifNotNil: [Utilities timeStampForMethod: aMethod]]! !!Utilities methodsFor: 'read me' stamp: 'sw 10/13/1998 13:14'!seeClassSide	"All the code for Utilitites is on the class side"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 10/13/1998 13:38'!timeStampForMethod: method	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file, or nil if none is found"	| position preamble tokens stamp file tokenCount |	method fileIndex == 0 ifTrue: [^ nil].	position _ method filePosition.	file _ (SourceFiles at: method fileIndex) readOnlyCopy.	file position: (0 max: position - 150).  "Skip back to before the preamble"		[file position < (position - 1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		stamp _ nil.		tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp _ tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokenCount]].	file close.	^ stamp! !'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 6:39:46 pm'!"Change Set:		preferencesPanel-swDate:			13 October 1998Author:			Scott WallaceProvides a live panel for dealing with all the boolean preferences; the user can see all of them at once, get balloon help for any of them, and can toggle any value by clicking on it.Also, a number of simplifications to the protocols and methods relating to absorbing updates, including clearing out some old disused cruft, and also providing a protocol whereby updates can be downloaded to the local hard disk without their being absorbed into the image."!Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'DesktopColor FlagDictionary HelpDictionary '	poolDictionaries: ''	category: 'System-Support'!UpdatingStringMorph subclass: #UpdatingBooleanStringMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!EToySystem class methodsFor: 'housekeeping' stamp: 'sw 10/13/1998 16:17' prior: 33912227!prepareRelease	"To prepare a release of the EToy system, first make a copy of your image. Start that image and:		1. close all windows and projects		2. clean any garbage out of the following:			Smalltalk at: #ImageImports.			(Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Behavior) not])				asSortedCollection asArray.			SampledSound soundLibrary.		3. run this method		4. save the image"	"EToySystem prepareRelease"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: []. 	Preferences setPreference: #quitWhenExitingImagineeringStudio toValue: true.	Preferences setPreference: #showDevelopersEToys toValue: false.	Preferences setPreference: #startImagineeringStudio toValue: true.	Preferences setPreference: #updateFromServerAtStartup toValue: false.	Preferences setPreference: #warnIfNoChangesFile toValue: false.	Preferences setPreference: #warnIfNoSourcesFile toValue: false.	Smalltalk minorShrink.	SystemOrganization removeSystemCategory: 'Morphic-Windows'.	SystemOrganization removeSystemCategory: 'Graphics-Files'. "No license for GIF reader"	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Socket deadServer: ''.	"Don't reveal any specific server name"	Symbol rehash.	Preferences desktopColor: (Color r: 0.2 g: 0.2 b: 0.2).	ScheduledControllers updateGray; restore.! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 10/8/1998 12:41' prior: 19971273!showBalloon: msgString	"Pop up a balloon containing the given string, first removing any existing BalloonMorphs in the world."	| w balloon worldBounds |	w _ self world.	w ifNil: [^ self].	balloon _ BalloonMorph string: msgString for: self corner: #bottomRight.	w submorphsDo: [:m |  "delete any existing balloons"		(m isKindOf: BalloonMorph) ifTrue: [m delete]].	balloon lock.  "So that if the translation below makes it overlap the receiver, it won't interfere with the rootMorphsAt: logic and hence cause flashing.  Without this, flashing happens, believe me!!"	w addMorphFront: balloon.	((worldBounds _ w bounds) containsRect: balloon bounds) ifFalse:		[balloon bounds: (balloon bounds translatedToBeWithin: worldBounds)].	self setProperty: #balloon toValue: balloon.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/13/1998 16:16' prior: 34092133!helpDo	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #absorbUpdatesFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/13/1998 16:16'!absorbUpdatesFromServer	Utilities updateFromServer! !!Preferences methodsFor: 'read me' stamp: 'sw 10/1/1998 14:45'!readMe	"All the code for Preferences is on the class side"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 10/13/1998 18:16' prior: 34923513!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(logDebuggerStackToFile				true)		(noviceMode							false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showTimeStampsInMenuTitles		false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 10/8/1998 08:44'!initializeHelpMessages	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic,SystemWindows should automaticallybe droppable into willing receptors')(browseWithPrettyPrint'If true, browsers will automaticallyformat their contents')(cautionBeforeClosing 'If true, Morphic windows seen in anmvc project will put up a warning beforeallowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit amethod with non-standard style willbring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts areedited in place in Scriptors(still imperfectly implemented)')(fastDragWindowForMorphic'If true, morphic window dragwill be done by dragging anoutline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submissionin which the only style change is forbolding will be treated as a methodwith no style specifications')(logDebuggerStackToFile'If true, whenever you fall into adebugger a summary of its stack willbe written to a file named''debugger stack''')(noviceMode 'If true, certain novice-modeaccommodations are made.')(reverseWindowStagger'If true, a reverse-stagger strategy  isused for determining where newly launchedwindows will be placed; if false, a direct-stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handleis displayed at the right of the halo; if false,no such handle is shown.')(showTimeStampsInMenuTitles'If true, then the author''s timestampis displayed as the menu title of anymessage list; if false, no author''stimestamps are shown')(suppressCheckForSlips 'If false, then whenever you file outa change set, it is checked for ''slips'' andif any are found, you are so informed andgiven a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choicewhen updating code from the server issuppressed.  Set this to true to leave theserver choice unchanged from update toupdate.')(thoroughSenders'If true, then ''senders'' browsers will diveinside structured literals in their search')(uniformWindowColors'If true, then all standard windows are giventhe same color rather than their customizedwindow-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawingwill not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold downmemory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequencenumber from the filename before automaticallysaving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded fromthe server, a copy of it will automaticallybe saved on a local file as well.')(warnIfNoChangesFile'If true, then you will be warned,whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned,whenever you start up, if no sourcesfile can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/8/1998 12:46'!deletePreferenceIfFalse: aSymbol	"If aSymbol is currently in the FlagDictionary and the corresponding value is currently false, then remove that element from the dictionary.  The result is that the preference will remain false when interrogated from the outside, but it will not show up in a Preferences control panel.  This keeps obscure preferences from distracting the user"	| val |	val _ FlagDictionary at: aSymbol ifAbsent: [^ self].	val == false ifTrue: [self deletePreference: aSymbol]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/5/1998 13:09'!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present"	"Preferences inspectPreferences"	FlagDictionary inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/5/1998 13:10' prior: 20825448!openPreferencesInspector	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"		Smalltalk hasMorphic		ifFalse:	[self inspectPreferences]		ifTrue:	[self openPreferencesControlPanel]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/1/1998 15:24'!helpMessageForPreference: aSymbol	HelpDictionary ifNil: [self initializeHelpMessages].	^ HelpDictionary at: aSymbol ifAbsent: ['No help available for ', aSymbol]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/5/1998 12:35'!initialExtent	^ 216 @ ((FlagDictionary size * 19) + 20)! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/13/1998 14:24'!openPreferencesControlPanel	"Preferences openPreferencesControlPanel"	| aPanel aWindow aRow wrapper but aList odd aColor w width1 width2 spacer |	Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].	aPanel _ AlignmentMorph newColumn.	aPanel beSticky.	aList _ OrderedCollection new.	FlagDictionary associationsDo: [:assoc | aList add: (Array				with: assoc key				with: assoc value				with: (self helpMessageForPreference: assoc key))].	odd _ false.	Smalltalk isMorphic		ifTrue:			[width1 _ 172.			spacer _ 4.			width2 _ 14]		ifFalse:			[width1 _ 172.			spacer _ 50.			width2 _ 90].	(aList asSortedCollection: [:a :b | a first < b first])		do: 			[:triplet | 			aPanel addMorphBack: (aRow _ AlignmentMorph newRow).			aRow color: (aColor _ odd							ifTrue: [Color green muchLighter]							ifFalse: [Color red veryMuchLighter]).			odd _ odd not.			aRow addMorph: (wrapper _ Morph new color: aColor).			wrapper setBalloonText: triplet third.			wrapper extent: width1 @ 15.			wrapper addMorph: (StringMorph new contents: triplet first).			aRow addMorphBack: (Morph new color: aColor; extent: (spacer @ 15)).			aRow addMorphBack: (wrapper _ Morph new color: aColor).			wrapper extent: width2 @ 15.			wrapper addMorphBack: (but _ UpdatingBooleanStringMorph new contents: triplet second printString).			but getSelector: triplet first;			 putSelector: #setPreference:toValue:;			 target: self].	Smalltalk isMorphic		ifTrue:			[aWindow _ SystemWindow new model: self.			aWindow addMorph: aPanel frame: (0 @ 0 extent: 1 @ 1).			aWindow setLabel: 'Preferences'.			aWindow openInWorld]		ifFalse:			[w _ WorldMorph new addMorph: aPanel.			w startSteppingSubmorphsOf: aPanel.			MorphWorldView openOn: w				label: 'Preferences'				extent: w fullBounds extent]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 10/1/1998 16:55'!scriptPerformer	^ self! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/13/1998 16:03' prior: 21090091!absorbUpdatesFromServer 	Utilities updateFromServer! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/8/1998 09:19' prior: 35076821!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	(Preferences valueOfFlag: #editPlayerScriptsInPlace)		ifTrue:			[self addTextualScript: newBrowser]		ifFalse:			[Browser openBrowserView: (newBrowser openMessageEditString: nil) label: ('textual script for "', scriptName, '" in ', playerScripted externalName)]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sw 10/13/1998 16:06' prior: 21784486!processUpdates	"Process update files from a well-known update server.  This method is called at system startup time,   Only if the preference #updateFromServerAtStartup is true is the actual update processing undertaken automatically"	| choice |	(Preferences valueOfFlag: #updateFromServerAtStartup) ifTrue:		[choice _ (PopUpMenu labels: 'Yes, Update\No, Not now' withCRs)			startUpWithCaption: 'Shall I look for new code\updates on the server?' withCRs.		choice = 1 ifTrue: [Utilities updateFromServer]].! !!UpdatingBooleanStringMorph commentStamp: '<historical>' prior: 0!A customized updating-string-morph used for displaying and editing boolean values; mouse-down on one of these is inerpreted as a request to toggle.!!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/1/1998 16:59'!handlesMouseDown: evt	^ true! !!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/1/1998 16:49'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target scriptPerformer perform: putSelector with: getSelector with: newValue.			target isMorph ifTrue: [target changed]].			self growable ifTrue:				[self readFromTarget; fitContents.				owner updateLiteralLabel]]! !!UpdatingBooleanStringMorph methodsFor: 'all' stamp: 'sw 10/5/1998 12:12'!mouseDown: evt	self contentsClipped: (target perform: getSelector) not asString.	self informTarget! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 15:57' prior: 35384466!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger > 412]].	Utilities readServerUpdatesSaveLocally: true updateImage: true.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #().	Utilities readServerUpdatesSaveLocally: true updateImage: false       The expression above ftps all updates not in the current image over to the local       hard disk, but does NOT absorb them into the current image"	| fileNames fileNamesInOrder fileNamesUnnumbered names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	fileNames _ FileDirectory default fileNames select:		[:n | n first isDigit			and: [(n initialInteger between: n1 and: n2)			and: [(skipList includes: n initialInteger) not]]].	fileNamesInOrder _ fileNames asSortedCollection.	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | FileDirectory default rename: n toBe: nu].	(ServerDirectory groupNamed: choice) putUpdateMulti: fileNamesUnnumbered! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 15:02' prior: 35385571!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted.  If the preference #suppressUpdateServerPrompt is true, then suppress that prompt, in effect using the same server choice that was used the previous time (a convenience for those of us who always answer the same thing to the prompt.)"	| index him |	((UpdateUrlLists size > 1) and: [(Preferences valueOfFlag: #suppressUpdateServerPrompt) == false])		ifTrue:			[index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 				startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.			index > 0 ifTrue:				[him _ UpdateUrlLists at: index.				UpdateUrlLists removeAt: index.				UpdateUrlLists addFirst: him].			^ index > 0].	^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 15:48'!readServerUpdatesSaveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates.  If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesSaveLocally: true updateImage: true.""Utilities readServerUpdatesSaveLocally: false updateImage: true.""Utilities readServerUpdatesSaveLocally: true updateImage: false."	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']).	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse:					[doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse:							["(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							updateImage ifTrue:									[ChangeSorter newChangesFromStream: doc									named: (this findTokens: '/') last].							saveLocally ifTrue:								[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"							loaded _ loaded + 1]]]]].	str _ loaded printString ,' new update files processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',						'\Starting with "' withCRs, failed, '".'].	self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 16:13' prior: 35386213!saveUpdate: doc onFile: fileName	"Save the update on a local file.  With or without the update number on the front, depending on the preference #updateRemoveSequenceNum"	| file fName pos |	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue:		[pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(FileDirectory default fileExists: fName) ifFalse:		[file _ FileStream newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 10/13/1998 16:03'!updateFromServer	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesSaveLocally: Preferences updateSavesFile updateImage: true! !EToySystem class removeSelector: #guessDOLProxy!EToySystem class removeSelector: #guessDOLProxy!HandMorph removeSelector: #updateFromServer!HandMorph removeSelector: #updateFromServer!Utilities class removeSelector: #absorbUpdatesWriteFiles:zapNums:!Utilities class removeSelector: #absorbUpdatesWriteFiles:zapNums:!Utilities class removeSelector: #absorbUpdatesFromServer!Utilities class removeSelector: #absorbUpdatesFromServer!"Postscript:"Preferences deletePreference: #cautionBeforeClosing.Preferences disable: #suppressUpdateServerPrompt.Preferences disable: #unlimitedPaintArea.Preferences disable: #updateSavesFile.Preferences deletePreferenceIfFalse: #editPlayerScriptsInPlace.Preferences deletePreferenceIfFalse: #uniformWindowColors.!'From Squeak 2.2 of Sept 23, 1998 on 13 October 1998 at 8:03:43 pm'!"Change Set:		dropThumbnailFix-swDate:			13 October 1998Author:			Scott WallaceSome methods inadvertently omitted from the dropThumbnail update"!!Morph methodsFor: 'thumbnail' stamp: 'sw 10/8/1998 16:17'!representativeNoTallerThan: maxHeight thumbnailHeight: thumbnailHeight	"Return a morph representing the receiver but which is no taller than aHeight.  If the receiver is already small enough, just return it, else return a MorphThumbnail companioned to the receiver"	self height <= maxHeight  ifTrue: [^ self].	^ MorphThumbnail new extent: thumbnailHeight @ thumbnailHeight; morphRepresented: self! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/8/1998 16:18' prior: 35845419!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/8/1998 16:22'!replaceTallSubmorphsByThumbnails	|  itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing |	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	self submorphs do:		[:aMorph |			itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[self replaceSubmorph: aMorph by: itsThumbnail]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/8/1998 16:21' prior: 34819087!updateSubmorphThumbnails	| thumbsUp itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing |	thumbsUp _ self alwaysShowThumbnail.	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/8/1998 16:50' prior: 34824742!heightForThumbnails	^ self valueOfProperty: #heightForThumbnails ifAbsent: [50]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/8/1998 16:50'!maxHeightToAvoidThumbnailing	^ self valueOfProperty: #maxHeightToAvoidThumbnailing ifAbsent: [80]! !'From Squeak 2.2 of Sept 23, 1998 on 14 October 1998 at 7:17:16 am'!"Change Set:		jhmCelesteTweaksDate:			12 October 1998Author:			John MaloneyVarious improvements and bug fixes to Celeste. Fixes the bugresulting in 'Block cannot return' notifier when serveris unavailable. This was caused by having a return inan ifError: block, which left the old error handlerblock installed, even though the block could not be usedsince it had already returned.Fixes all other methods containing returns in error blocks.Includes Lex's fix of indexOfAscii:inString:startingAt: primitiveto handle characters > 127."!Model subclass: #Celeste	instanceVariableNames: 'mailDB currentCategory currentMessages currentTOC currentMsgID lastCategory subjectFilter fromFilter dateFilter customFilterBlock formatMessages lastCategoryList lastCategoryMenu messageTextView userPassword '	classVariableNames: 'CCList CustomFilters DeleteInboxAfterFetching FormatWhenFetching PopServer PopUserName SmtpServer SuppressWorthlessHeaderFields UserName '	poolDictionaries: ''	category: 'NetTools-Celeste'!!CategoriesFile methodsFor: 'categories access' stamp: 'jm 10/4/1998 11:16' prior: 33713599!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = '.all.' | oldName = '.unclassified.' |	 (self categories includes: newName)) ifTrue:		[^ self].  "can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!Celeste methodsFor: 'open-close' stamp: 'jm 10/4/1998 14:01' prior: 33716272!close	"Close the mail database."	userPassword _ nil.	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/12/1998 09:33' prior: 33717868!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\fetch mail\send queued mail\add category' withCRs.	lineSeparations _ #(1 2).	selectors _ #(save fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\import into category\export category (Celeste)\export category (Unix/Eudora)' withCRs.			lineSeparations _ lineSeparations, #(3 3).			selectors _ selectors, #(renameCategory removeCategory importIntoCategory exportCategory exportCategoryUnix)]		ifFalse: [			lineSeparations _ lineSeparations, #(1)].	labels _ labels, '\empty trash\compact\find duplicates\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(3 1 5).	selectors _ selectors, #(emptyTrash compact findDuplicates toggleSuppressHeaders setUserName setCCList setPopServer setPopUserName setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer)]		ifFalse: [labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching)].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [:i |		lines at: i put: ((lines at: i) + (lines at: i-1))].	^ aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 14:06' prior: 33722247!fetchMail	"Append messages from the user's mailbox to this mail database."	| server password msgCount |	server _ self class popServer.	password _ self popPassword.	(password isNil or: [password isEmpty]) ifTrue: [^ self].	msgCount _ mailDB fetchMailFromPOP: server		userName: self class popUserName		password: password		doFormatting: FormatWhenFetching		deleteFromServer: DeleteInboxAfterFetching.	msgCount < 0		ifTrue: [self inform: 'could not connect to the mail server']		ifFalse: [self inform: msgCount printString, ' messages fetched'].	msgCount <= 0 ifTrue: [^ self].	currentCategory _ 'new'. 	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:46' prior: 33723694!findDuplicates	"Find duplicate messages, and move the redundant copies to a given category."	| duplicatesCategory |	duplicatesCategory _ FillInTheBlank		request: 'File duplicates in category?'		initialAnswer: 'duplicates'.	duplicatesCategory isEmpty ifTrue:[^ self].	Utilities informUser: 'Searching for duplicates...'		during: [mailDB fileDuplicatesIn: duplicatesCategory].	self changed: #categoryList.	self setCategory: duplicatesCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39' prior: 33725091!nextCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i < catList size		ifTrue: [self setCategory: (catList at: i + 1)]		ifFalse: [self setCategory: (catList at: 1)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39' prior: 33725501!previousCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i > 1		ifTrue: [self setCategory: (catList at: i - 1)]		ifFalse: [self setCategory: (catList at: catList size)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:37' prior: 33725914!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	currentCategory ifNil: [ ^self ].	msgList _ mailDB messagesIn: currentCategory.	(mailDB messagesIn: '.trash.') do: [: id |		msgList remove: id ifAbsent: []].	msgList isEmpty ifFalse: [		(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].	mailDB removeCategory: currentCategory.	self changed: #categoryList.	self setCategory: nil.! !!Celeste methodsFor: 'message text pane' stamp: 'jm 10/2/1998 16:14' prior: 33746375!messageText	(currentMsgID isNil) ifTrue: [^''].	SuppressWorthlessHeaderFields		ifTrue: [^ self formatedMessageText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:55' prior: 33749167!composeText	"Answer the template for a new message."	^ String streamContents: [:str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName; cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList; cr].		str cr].! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:55' prior: 33749591!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^ self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) body, '-------------------------------'! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 14:23'!popPassword	"Answer the password to use when retrieving mail via POP3. The password is stored in an instance variable, which disappears when you close the Celeste window."	userPassword ifNotNil: [^ userPassword].	userPassword _ FillInTheBlank request: 'POP password'.	^ userPassword! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 11:11' prior: 33752221!queueMessageWithText: aStringOrText	"Queue a message to be sent later. The message is added to the database and filed in the '.tosend.' category."	| messageText id |	"add a x-mailer line"	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText).	mailDB file: id inCategory: '.tosend.'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:59' prior: 33754018!sendQueuedMail	"Post queued messages to the SMTP server."	| outgoing sender n message recipients ok |	outgoing _ mailDB messagesIn: '.tosend.'.	outgoing isEmpty ifTrue: [^ self inform: 'no mail to be sent'].	sender _ (MailAddressParser addressesIn: self class userName) first.	('sending ', outgoing size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 1		to: outgoing size		during: [:progressBar |			n _ 0.			outgoing do: [:id |				progressBar value: (n _ n + 1).				message _ mailDB getMessage: id.				recipients _ Set new.				recipients addAll: (MailAddressParser addressesIn: message to).				recipients addAll: (MailAddressParser addressesIn: message cc).				ok _ SMTPSocket 					deliverMailFrom: sender					to: recipients 					text: message text 					usingServer: Celeste smtpServer.				ok					ifTrue: [						mailDB remove: id fromCategory: '.tosend.'.						mailDB file: id inCategory: '.sent.']					ifFalse: [^ self error: 'error posting mail']]].	mailDB saveDB.	self changed: #categoryList.	self updateTOC.! !!Celeste class methodsFor: 'class initialization' stamp: 'jm 10/4/1998 13:55' prior: 33755467!initialize	"Celeste initialize"	"user preferences"	CCList _ nil.	DeleteInboxAfterFetching _ false.	PopServer _ nil.	PopUserName _ nil.	SmtpServer _ nil.	SuppressWorthlessHeaderFields _ true.	UserName _ nil.	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 10/4/1998 14:44' prior: 33756141!buildButtonsFor: model	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on:		(Switch new			onAction: [model subjectFilterOn];			offAction: [model subjectFilterOff]).	b	label: ('Subj. F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model fromFilterOn];			offAction: [model fromFilterOff]).	b	label: ('From F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model customFilterOn];			offAction: [model customFilterOff]).	b	label: ('Custom F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model compose]);		action: #turnOn;		label: ('New' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model reply]);		action: #turnOn;		label: ('Reply' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model forward]);		action: #turnOn;		label: ('Forward' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model moveAgain]);		action: #turnOn;		label: ('Move Again' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model deleteMessage]);		action: #turnOn;		label: ('Delete' asParagraph centered);		borderWidth: 1.	buttons add: b.	^ buttons! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 10/4/1998 14:46' prior: 33759107!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: [			topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 2) frame: (0.125@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 3) frame: (0.25@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 4) frame: (0.375@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 5) frame: (0.50@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 6) frame: (0.625@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 7) frame: (0.75@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 8) frame: (0.875@0.0 extent: 0.125@0.05).			topWindow addMorph: (views at: 1) frame: (0.0@0.05 extent: 0.2@0.25).			topWindow addMorph: (views at: 2) frame: (0.2@0.05 extent: 0.8@0.25).			topWindow addMorph: (views at: 3) frame: (0.0@0.30 extent: 1.0@0.70).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: [			topWindow _ StandardSystemView new				model: model;				label: 'Celeste';				minimumSize: 400@250.			(views at: 1) window: (0@0 extent: 20@25).			(views at: 2) window: (0@0 extent: 80@25).			(views at: 3) window: (0@0 extent: 100@70).			(buttons at: 1) window: (0@0 extent: 12@5).			(buttons at: 2) window: (0@0 extent: 12@5).			(buttons at: 3) window: (0@0 extent: 12@5).			(buttons at: 4) window: (0@0 extent: 10@5).			(buttons at: 5) window: (0@0 extent: 13@5).			(buttons at: 6) window: (0@0 extent: 13@5).			(buttons at: 7) window: (0@0 extent: 15@5).			(buttons at: 8) window: (0@0 extent: 13@5).			topWindow				addSubView: (buttons at: 1);				addSubView: (buttons at: 2) toRightOf: (buttons at: 1);				addSubView: (buttons at: 3) toRightOf: (buttons at: 2);				addSubView: (buttons at: 4) toRightOf: (buttons at: 3);				addSubView: (buttons at: 5) toRightOf: (buttons at: 4);				addSubView: (buttons at: 6) toRightOf: (buttons at: 5);				addSubView: (buttons at: 7) toRightOf: (buttons at: 6);				addSubView: (buttons at: 8) toRightOf: (buttons at: 7);				addSubView: (views at: 1) below: (buttons at: 1);				addSubView: (views at: 2) toRightOf: (views at: 1);				addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].! !!Celeste class methodsFor: 'sending' stamp: 'jm 10/2/1998 16:24' prior: 33767087!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	self inform:'The "keep" feature is not yet implemented;please cc: yourself to retain a copy of your message.'! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 9/27/1998 21:34'!fullNamesOfAllFilesInSubtree	"Answer a collection containing the full names of all the files in the subtree of the file system whose root is this directory."	| result todo dir |	result _ OrderedCollection new: 100.	todo _ OrderedCollection with: self.	[todo size > 0] whileTrue: [		dir _ todo removeFirst.		dir fileNames do: [:n | result add: (dir fullNameFor: n)].		dir directoryNames do: [:n | todo add: (dir directoryNamed: n)]].	^ result asArray! !!IRCConnection methodsFor: 'access' stamp: 'jm 10/3/1998 08:37' prior: 34210559!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IRCConnection methodsFor: 'UI' stamp: 'jm 10/3/1998 08:43' prior: 34222674!sendRawCommand: aString	"Send a command directly."	| message |	message _ [IRCProtocolMessage fromString: aString asString] ifError: [:a :b | nil].	message ifNil: [^ false].	self sendMessage: message.	^ true! !!IRCMorph methodsFor: 'interface' stamp: 'jm 10/3/1998 08:44' prior: 34245334!sendCommand: aString	| message |	[message _ IRCProtocolMessage fromString: aString asString] ifError: [nil].	message ifNil: [^ false].	connection sendMessage: message.	^ true! !!IRCMorph methodsFor: 'access' stamp: 'jm 10/3/1998 08:37' prior: 34246199!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 10/12/1998 09:34' prior: 34268927!textHas: stringOrList	^ self field: self getMessage text has: stringOrList! !!JPEGReadWriter methodsFor: 'testing' stamp: 'jm 10/3/1998 08:33' prior: 34503992!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!MailDB methodsFor: 'open-create-save' stamp: 'jm 10/12/1998 13:53' prior: 34594196!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	| dir localName |	dir _ FileDirectory forFileName: rootFilename.	localName _ FileDirectory localNameFor: rootFilename.	messageFile _ dir includesKey: localName, '.messages'.	indexFile _ dir includesKey: localName, '.index'.	categoriesFile _ dir includesKey: localName, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:29'!fetchMailFromPOP: server userName: userName password: password doFormatting: doFormatting deleteFromServer: deleteFromServer	"Download mail from the given POP3 mail server and append it this mail database. Answer the number of messages fetched. If doFormatting is true, messages will be formatted as they are received. If deleteFromServer is true, then messages will be removed from the POP3 server after being successfully retrieved. (Note: If there is a failure while fetching mail, all messages will be left on the server.)"	| popConnection msgCount |	popConnection _ POPSocket createIfFail: [^ -1].	popConnection serverName: server;			userName: userName;		password: password;		addProgressObserver: Transcript.	Utilities		informUser: 'connecting to ', server		during: [popConnection connectToPOP].	popConnection isConnected ifFalse: [^ -1].	msgCount _ popConnection numMessages.	msgCount > 0 ifTrue: [		self fetchMessageCount: msgCount			fromPOPConnection: popConnection			doFormatting: doFormatting.		deleteFromServer ifTrue: [			self removeMessageCount: msgCount fromPOPConnection: popConnection]].	popConnection disconnectFromPOP.	^ msgCount! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 16:10'!fetchMessageCount: msgCount fromPOPConnection: popConnection doFormatting: doFormatting	"Download the given number of messages from the given open POP3 connection. If doFormatting is true, messages will be formatted as they are received."	| nextID msgText msg location |	nextID _ self nextUnusedID.	messageFile beginAppend.	('Downloading ', msgCount printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					messageFile endAppend.					LastID _ nextID.					self saveDB.					^ self inform: 'Server connection unexpectedly closed.'].				"get a message"				msgText _ popConnection retrieveMessage: messageNum.				"save that message"				msg _ MailMessage from: msgText.				doFormatting ifTrue: [msg format].				location _ messageFile basicAppend: msg text id: nextID.				indexFile					at: nextID					put: (IndexFileEntry						message: msg						location: location						messageFile: messageFile						msgID: nextID).				categoriesFile file: nextID inCategory: 'new'.				nextID _ nextID + 1]].	messageFile endAppend.	LastID _ nextID.	self saveDB.! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:39' prior: 34604798!importMailFrom: inboxFileName intoCategory: category	"Append the messages from the given mail file to this mail database, and store them in the given category. Answer the number of messages imported."	| inbox nextID count msg location |	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo: [:msgText |		 msg _ MailMessage from: msgText.		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: category.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	self saveDB.	^ count! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:51'!removeMessageCount: msgCount fromPOPConnection: popConnection	"Remove messages 1 through msgCount from the given POP3 server."	('Removing ', msgCount printString, ' messages from the server...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					^ self inform: 'Server connection unexpectedly closed.'].				popConnection deleteMessage: messageNum]].! !!MailDB methodsFor: 'housekeeping' stamp: 'jm 10/4/1998 11:06' prior: 34607391!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).  "never go backwards!!"	LastID _ id.	^ id! !!MailDB methodsFor: 'categories' stamp: 'jm 10/4/1998 11:16' prior: 34611484!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('.all.' or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages' stamp: 'jm 10/4/1998 11:13'!addNewMessage: message	"Add the given message to the database, and answer its message id."	| id location |	id _ self nextUnusedID.	location _ messageFile append: message text id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	^ id! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/2/1998 16:05' prior: 34752545!disconnectFromPOP	"Send a QUIT message, then disconnect."	self isValid ifFalse: [^ self].  "already closed"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/3/1998 07:55' prior: 34753107!numMessages	"Query the server and answer the number of messages that are in the user's mailbox."	| response answerString |	numMessages ifNotNil: [^ numMessages].  "cached result of earlier query"	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [^ 0].  "error"	answerString _ (response findTokens: Character separators) second.	^ answerString asNumber asInteger! !!PWS class methodsFor: 'Serving' stamp: 'jm 10/3/1998 08:48' prior: 20287063!doBackupJobs	"This is just a wrapper so we don't have to restart the server loop when we add/remove jobs."	| problemReport |	BackupJobs do: [:block |		problemReport _ nil.		[block value] ifError: [:msg :rec |			problemReport _ '*** ', rec asString, ': ', msg asString].		problemReport ifNotNil: [^ problemReport]].	^ 'Backup jobs completed'! !!SMTPSocket commentStamp: '<historical>' prior: 0!This is used to post email messages to an SMTP server. See my class messages for examples of how to use it.!!String class methodsFor: 'primitives' stamp: 'jm 10/12/1998 18:21' prior: 35229795!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 245>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !Celeste removeSelector: #underConstruction!Celeste removeSelector: #underConstruction!Celeste removeSelector: #fetchNews!Celeste removeSelector: #fetchNews!Celeste removeSelector: #checkTrash!Celeste removeSelector: #checkTrash!Celeste removeSelector: #setInOutFolder!Celeste removeSelector: #setInOutFolder!Celeste class removeSelector: #postToUnixOutbox:!Celeste class removeSelector: #postToUnixOutbox:!Celeste initialize!Celeste class removeSelector: #inOutFolder!Celeste class removeSelector: #inOutFolder!Celeste class removeSelector: #popPassword!Celeste class removeSelector: #popPassword!Celeste class removeSelector: #setInOutFolder!Celeste class removeSelector: #setInOutFolder!Celeste class removeSelector: #postToEudoraOutbox:!Celeste class removeSelector: #postToEudoraOutbox:!MailDB removeSelector: #fetchMailFrom:doFormatting:deleteInbox:!MailDB removeSelector: #fetchMailFrom:doFormatting:deleteInbox:!MailDB removeSelector: #POPMailFrom:userName:password:doFormatting:deleteInbox:informingUser:!MailDB removeSelector: #POPMailFrom:userName:password:doFormatting:deleteInbox:informingUser:!MailDB removeSelector: #release!MailDB removeSelector: #release!MailDB removeSelector: #addNewMessage:inCategory:!MailDB removeSelector: #addNewMessage:inCategory:!MailDB removeSelector: #do:andInform:!MailDB removeSelector: #do:andInform:!MailDB removeSelector: #showProgress:from:to:message:during:!MailDB removeSelector: #showProgress:from:to:message:during:!SMTPSocket class removeSelector: #deliverMailTo:from:to:text:!SMTPSocket class removeSelector: #deliverMailTo:from:to:text:!'From Squeak 2.2 of Sept 23, 1998 on 14 October 1998 at 12:56:09 pm'!"Change Set:		jhmNetInitFixDate:			14 October 1998Author:			John MaloneyFixes a problem introduced by fixing the Socket double-initializationbug. Namely, the socket creation code was doing a network initialize,but is no longer doing so. This fix makes sure that clients are doingtheir own network initialization, rather than expecting it to be doneas a side-effect of socket creation."!!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/14/1998 12:31' prior: 35894769!fetchMailFromPOP: server userName: userName password: password doFormatting: doFormatting deleteFromServer: deleteFromServer	"Download mail from the given POP3 mail server and append it this mail database. Answer the number of messages fetched. If doFormatting is true, messages will be formatted as they are received. If deleteFromServer is true, then messages will be removed from the POP3 server after being successfully retrieved. (Note: If there is a failure while fetching mail, all messages will be left on the server.)"	| popConnection msgCount |	Socket initializeNetwork.	popConnection _ POPSocket new		serverName: server;			userName: userName;		password: password;		addProgressObserver: Transcript.	Utilities		informUser: 'connecting to ', server		during: [popConnection connectToPOP].	popConnection isConnected ifFalse: [^ -1].	msgCount _ popConnection numMessages.	msgCount > 0 ifTrue: [		self fetchMessageCount: msgCount			fromPOPConnection: popConnection			doFormatting: doFormatting.		deleteFromServer ifTrue: [			self removeMessageCount: msgCount fromPOPConnection: popConnection]].	popConnection disconnectFromPOP.	^ msgCount! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:51' prior: 34751138!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find host address'].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:52' prior: 34991675!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	Socket initializeNetwork.	addr _ NetNameResolver addressForName: serverName.	addr ifNil: [self error: 'Could not find host address'].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!Socket class methodsFor: 'instance creation' stamp: 'jm 10/14/1998 12:08' prior: 35170079!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	^ super new initialize! !POPSocket class removeSelector: #getMessagesNotifying:andForEachDo:!POPSocket class removeSelector: #getMessagesNotifying:andForEachDo:!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!'From Squeak 2.2 of Sept 23, 1998 on 14 October 1998 at 11:12:08 pm'!"Change Set:		jhmMIDIInputDate:			14 October 1998Author:			John MaloneyImproves the MIDI facilities in a number of ways, including the abilityto parse, filter, and process incoming MIDI commands. Includes the beginningof a simple MIDI-controlled synthesizer. One can also create slidersto control for various MIDI parameters, can play an external MIDI devicevia an on-screen keyboard, can select MIDI ports by name, and more."!AlignmentMorph subclass: #MIDIControllerMorph	instanceVariableNames: 'channel controller midiPort lastValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!Object subclass: #MIDIInputParser	instanceVariableNames: 'cmdActionTable midiPort received rawDataBuffer sysExBuffer ignoreSysEx startTime timeNow state lastSelector lastCmdByte argByte1 argByte2 '	classVariableNames: 'DefaultMidiTable '	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #MIDISynth	instanceVariableNames: 'midiParser channels process '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #MIDISynthChannel	instanceVariableNames: 'channel instrument masterVolume channelVolume pitchBend activeSounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!PianoKeyboardMorph subclass: #MIDIPianoKeyboardMorph	instanceVariableNames: 'midiPort channel velocity '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!AlignmentMorph subclass: #ScorePlayerMorph	instanceVariableNames: 'scorePlayer trackInstNames instrumentSelector '	classVariableNames: 'LastMIDIPort '	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #SimpleMIDIPort	instanceVariableNames: 'portNumber accessSema lastCommandByteOut '	classVariableNames: 'DefaultPortNumber InterfaceClockRate '	poolDictionaries: ''	category: 'Music-Scores'!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 10/14/1998 16:04' prior: 34541885!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26'!originalSamplingRate	^ originalSamplingRate! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'jm 9/28/1998 22:38'!initialize	| slider |	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ vResizing _ #shrinkWrap.	self color: (Color r: 0.484 g: 0.613 b: 0.0).	self borderWidth: 1.	channel _ 0.	controller _ 7.  "channel volume"	slider _ SimpleSliderMorph new		target: self;		actionSelector: #newSliderValue:;		minVal: 0;		maxVal: 127;		extent: 128@10.	self addMorphBack: slider.	self addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!channel	^ channel! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!channel: anInteger	channel _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!controller	^ controller! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!controller: anInteger	controller _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:54'!midiPort	^ midiPort! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:55'!midiPort: anInteger	midiPort _ anInteger.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set channel' action: #setChannel:.	aCustomMenu add: 'set controller' action: #setController:.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!controllerList	"Answer a list of controller name, number pairs to be used in the menu."	^ #((1 modulation)		(2 'breath control')		(7 volume)		(10 pan)		(11 expression)		(92 'tremolo depth')		(93 'chorus depth')		(94 'celeste depth')		(95 'phaser depth'))! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:09'!controllerName: controllerNumber	"Answer a name for the given controller. If no name is available, use the form 'CC5' (CC is short for 'continuous controller')."	self controllerList do: [:pair |		pair first = controllerNumber ifTrue: [^ pair last]].	^ 'CC', controllerNumber asString! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:46'!setChannel: evt	| menu |	menu _ MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!setController: evt	| menu |	menu _ MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 10/12/1998 16:02'!newSliderValue: newValue	"Send a control command out the MIDI port."	| val |	midiPort ifNil: [^ self].	val _ newValue asInteger.	lastValue = val ifTrue: [^ self].	lastValue _ val.	midiPort midiCmd: 16rB0 channel: channel byte: controller byte: val.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 9/29/1998 09:10'!updateLabel	| label |	(label _ self findA: StringMorph) ifNil: [^ self].	label contents: (self controllerName: controller), ', ch: ', (channel + 1) printString.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/27/1998 21:44' prior: 34563466!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	((chunkSize < 6) or: [chunkSize > 100])		ifTrue: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08' prior: 34564526!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/27/1998 22:15' prior: 19751758!metaEventAt: ticks	"Read a meta event. Event types appear roughly in order of expected frequency."	| type length tempo |	type _ trackStream next.	length _ self readVarLengthIntFrom: trackStream.	type = 16r51 ifTrue: [  "tempo"		tempo _ 0.		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].		track add: (TempoEvent new tempo: tempo; time: ticks).		^ self].	type = 16r2F ifTrue: [  "end of track"		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].		self endAllNotesAt: ticks.		trackStream skip: length.		^ self].	type = 16r58 ifTrue: [  "time signature"		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].		trackStream skip: length.		^ self].	type = 16r59 ifTrue: [  "key signature"		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].		trackStream skip: length.		^ self].	((type >= 1) and: [type <= 7]) ifTrue: [  "string"		strings add: (trackStream next: length) asString.		^ self].	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"	 [(type = 16r7F) or:  "sequencer specific meta event"	 [(type = 16r00) or:  "sequence number"	 [(type = 16r20)]]])  "MIDI channel prefix"		ifTrue: [			trackStream skip: length.			^ self].	type = 16r54 ifTrue: [		"SMPTE offset"		self report: 'Ignoring SMPTE offset'.		trackStream skip: length.		^ self].	"skip unrecognized meta event"	self report:		'skipping unrecognized meta event: ', (type printStringBase: 16),		' (', length printString, ' bytes)'.	trackStream skip: length.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57' prior: 34565864!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15' prior: 34567792!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIInputParser commentStamp: '<historical>' prior: 0!I am a parser for a MIDI data stream. I support:	real-time MIDI recording,	overdubbing (recording while playing),	monitoring incoming MIDI, and	interactive MIDI performances.Note: MIDI controllers such as pitch benders and breath controllers generate large volumes of data which consume processor time. In cases where this information is not of interest to the program using it, it is best to filter it out as soon as possible. I support various options for doing this filtering, including filtering by MIDI channel and/or by command type.!!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:39'!ignoreChannel: channel	"Don't record any events arriving on the given MIDI channel (in the range 1-16)."	((channel isInteger not) | (channel < 1) | (channel > 16))		ifTrue: [^ self error: 'bad MIDI channel number', channel printString].	"two-arg channel messages"	#(128 144 160 176 224) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreTwo:].	"one-arg channel messages"	#(192 208) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreOne:].! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:40'!ignoreCommand: midiCmd	"Don't record the given MIDI command on any channel."	| cmd sel | 	((midiCmd isInteger not) | (midiCmd < 128) | (midiCmd > 255))		ifTrue: [^ self error: 'bad MIDI command'].	midiCmd < 240 ifTrue: [  "channel commands; ignore on all channels"		cmd _ midiCmd bitAnd: 2r11110000.		sel _ (#(128 144 160 176 224) includes: cmd)			ifTrue: [#ignoreTwo:]			ifFalse: [#ignoreOne:].		 1 to: 16 do: [:ch | cmdActionTable at: (cmd bitOr: ch - 1) put: sel].		^ self].	(#(240 241 244 245 247 249 253) includes: midiCmd) ifTrue: [		^ self error: 'You can''t ignore the undefined MIDI command: ', midiCmd printString].	midiCmd = 242 ifTrue: [  "two-arg command"		cmdActionTable at: midiCmd put: #ignoreTwo:.		 ^ self].	midiCmd = 243 ifTrue: [  "one-arg command"		cmdActionTable at: midiCmd put: #ignoreOne:.		^ self].	(#(246 248 250 251 252 254 255) includes: midiCmd) ifTrue:	[  "zero-arg command"		cmdActionTable at: midiCmd put: #ignore.		 ^ self].	"we should not get here"	self error: 'implementation error'.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:38'!ignoreSysEx: aBoolean	"If the argument is true, then ignore incoming system exclusive message."	ignoreSysEx _ aBoolean.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:46'!ignoreTuneAndRealTimeCommands	"Ignore tuning requests and real-time commands."	cmdActionTable at: 246 put: #ignoreZero:.	"tune request"	cmdActionTable at: 248 put: #ignoreZero:.	"timing clock"	cmdActionTable at: 250 put: #ignoreZero:.	"start"	cmdActionTable at: 251 put: #ignoreZero:.		"continue"	cmdActionTable at: 252 put: #ignoreZero:.	"stop/Clock"	cmdActionTable at: 254 put: #ignoreZero:.	"active sensing"	cmdActionTable at: 255 put: #ignoreZero:.	"system reset"! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:37'!noFiltering	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."	cmdActionTable _ DefaultMidiTable deepCopy.	ignoreSysEx _ false.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:50'!recordOnlyChannels: channelList	"Record only MIDI data arriving on the given list of channel numbers (in the range 1-16)."	channelList do: [:ch |		((ch isInteger not) | (ch < 1) | (ch > 16))			ifTrue: [^ self error: 'bad Midi channel specification: ', ch printString]].	1 to: 16 do: [:ch | (channelList includes: ch) ifFalse: [self ignoreChannel: ch]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/9/1998 07:52'!clearBuffers	"Clear the MIDI record buffers. This should be called at the start of recording or real-time MIDI processing."		received _ received species new: 5000.	rawDataBuffer _ ByteArray new: 1000.	sysExBuffer _ WriteStream on: (ByteArray new: 100).	midiPort ensureOpen; flushInput.	startTime _ Time millisecondClockValue.	state _ #idle.! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 21:06'!processMIDIData	"Process all MIDI data that has arrived since the last time this method was executed. This method should be called frequently to process, filter, and timestamp MIDI data as it arrives."	| bytesRead |	[(bytesRead _ midiPort readInto: rawDataBuffer) > 0] whileTrue: [		timeNow _ (midiPort bufferTimeStampFrom: rawDataBuffer) - startTime.		5 to: bytesRead do: [:i | self processByte: (rawDataBuffer at: i)]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 20:24'!received	"Answer my current collection of all MIDI commands received. Items in this list have the form (<time><cmd byte>[<arg1>[<arg2>]]). Note that the real-time processing facility, midiDo:, removes items from this list as it processes them."	^ received! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/9/1998 07:53'!midiDo: aBlock	"Poll the incoming MIDI stream in real time and call the given block for each complete command that has been received. The block takes one argument, which is an array of the form (<time><cmd byte>[<arg1>[<arg2>]]). The number of arguments depends on the command byte. For system exclusive commands, the argument is a ByteArray containing the system exclusive message."	self processMIDIData.	[received isEmpty] whileFalse:		[aBlock value: received removeFirst].! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/8/1998 21:21'!midiDoUntilMouseDown: midiActionBlock	"Process the incoming MIDI stream in real time by calling midiActionBlock for each MIDI event. This block takes three arguments: the MIDI command byte and two argument bytes. One or both argument bytes may be nil, depending on the MIDI command. If not nil, evaluatue idleBlock regularly whether MIDI data is available or not. Pressing any mouse button terminates the interaction."	| time cmd arg1 arg2 |	self clearBuffers.	[Sensor anyButtonPressed] whileFalse: [		self midiDo: [:item |			time _ item at: 1.			cmd _ item at: 2.			arg1 _ arg2 _ nil.			item size > 2 ifTrue: [				arg1 _ item at: 3.				item size > 3 ifTrue: [arg2 _ item at: 4]].				midiActionBlock value: cmd value: arg1 value: arg2]].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/8/1998 21:22'!monitor	"Print MIDI messages to the transcript until any mouse button is pressed."	self midiDoUntilMouseDown: [:cmd :arg1 :arg2 |		self printCmd: cmd with: arg1 with: arg2].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/9/1998 10:19'!printCmd: cmdByte with: arg1 with: arg2	"Print the given MIDI command."	| cmd ch bend |	cmdByte < 240		ifTrue: [  "channel message" 			cmd _ cmdByte bitAnd: 2r11110000.			ch _ (cmdByte bitAnd: 2r00001111) + 1]		ifFalse: [cmd _ cmdByte].  "system message"	cmd = 128 ifTrue: [		^ Transcript show: ('key up ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 144 ifTrue: [		^ Transcript show: ('key down: ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 160 ifTrue: [		^ Transcript show: ('key pressure: ', arg1 printString, ' val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 176 ifTrue: [		^ Transcript show: ('CC', arg1 printString, ': val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 192 ifTrue: [		^ Transcript show: ('prog: ', (arg1 + 1) printString, ' chan: ', ch printString); cr].	cmd = 208 ifTrue: [		^ Transcript show: ('channel pressure ', arg1 printString, ' chan: ', ch printString); cr].	cmd = 224 ifTrue: [		bend _ ((arg2 bitShift: 7) + arg1) - 8192.		^ Transcript show: ('bend: ', bend printString, ' chan: ', ch printString); cr].	cmd = 240 ifTrue: [		^ Transcript show: ('system exclusive: ', (arg1 at: 1) printString, ' (', arg1 size printString, ' bytes)'); cr].	Transcript show: 'cmd: ', cmd printString, ' arg1: ', arg1 printString, ' arg2: ', arg2 printString; cr.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 18:34'!endSysExclusive: cmdByte	"Error!! Received 'end system exclusive' command when not receiving system exclusive data."	self error: 'unexpected ''End of System Exclusive'' command'.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreOne: cmdByte	"Ignore a one argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreOne:.	state _ #ignore1.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreTwo: cmdByte	"Ignore a two argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreTwo:.	state _ #ignore2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:45'!ignoreZero: cmdByte	"Ignore a zero argument command, such as tune request or a real-time message. Stay in the current and don't change active status. Note that real-time messages can arrive between data bytes without disruption."		"do nothing"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:36'!processByte: aByte	"Process the given incoming MIDI byte and record completed commands."	"Details: Because this must be fast, it has been hand-tuned. Be careful!!"	aByte > 247 ifTrue: [  "real-time message; can arrive at any time"		^ self perform: (cmdActionTable at: aByte) with: aByte].	#idle = state ifTrue: [		aByte >= 128			ifTrue: [  "command byte in idle state: start new command"				^ self perform: (cmdActionTable at: aByte) with: aByte]			ifFalse: [  "data byte in idle state: use running status if possible"				lastCmdByte ifNil: [^ self].  "running status unknown; skip byte"				"process this data as if it had the last command byte in front of it"				 self perform: lastSelector with: lastCmdByte.				"the previous line put us into a new state; we now 'fall through'				 to process the data byte given this new state."]].	#ignore1 = state ifTrue: [^ state _ #idle].	#ignore2 = state ifTrue: [^ state _ #ignore1].	#want1of2 = state ifTrue: [		argByte1 _ aByte.		^ state _ #want2of2].	#want2of2 = state ifTrue: [		argByte2 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1 with: argByte2).		^ state _ #idle].	#want1only = state ifTrue: [		argByte1 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1).		^ state _ #idle].	#sysExclusive = state ifTrue: [		aByte < 128 ifTrue: [			"record a system exclusive data byte"			ignoreSysEx ifFalse: [sysExBuffer nextPut: aByte].			^ self]		ifFalse: [			aByte < 248 ifTrue: [				"a system exclusive message is terminated by any non-real-time command byte"				ignoreSysEx ifFalse: [					received addLast: (Array with: timeNow with: lastCmdByte with: sysExBuffer contents)].				state _ #idle.				aByte = 247					ifTrue: [^ self]							"endSysExclusive command, nothing left to do"					ifFalse: [^ self processByte: aByte]]]].  	"no endSysExclusive; just start the next command"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordOne: cmdByte	"Record a one argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordOne:.	state _ #want1only.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordTwo: cmdByte	"Record a two argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordTwo:.	state _ #want1of2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:43'!recordZero: cmdByte	"Record a zero-byte message, such as tune request or a real-time message. Don't change active status. Note that real-time messages can arrive between data bytes without disruption."		received addLast: (Array with: timeNow with: cmdByte).! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:38'!startSysExclusive: cmdByte	"The beginning of a variable length 'system exclusive' command."	sysExBuffer resetContents.	lastCmdByte _ nil.  "system exclusive commands clear running status"	lastSelector _ nil.	state _ #sysExclusive.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 17:12'!undefined: cmdByte	"We have received an unexpected MIDI byte (e.g., a data byte when we were expecting a command). This should never happen."	self error: 'unexpected MIDI byte ', cmdByte printString.! !!MIDIInputParser methodsFor: 'private-other' stamp: 'jm 10/9/1998 07:56'!setMIDIPort: aMIDIPort	"Initialize this instance for recording from the given MIDI port. Tune and real-time commands are filtered out by default; the client can send noFiltering to receive these messages."	midiPort _ aMIDIPort.	received _ OrderedCollection new.	self noFiltering.  "initializes cmdActionTable"	self ignoreTuneAndRealTimeCommands.! !!MIDIInputParser class methodsFor: 'class initialization' stamp: 'jm 10/9/1998 07:35'!initialize	"Build the default MIDI command-byte action table. This table maps MIDI command bytes to the action to be performed when that is received. Note that MIDI data bytes (bytes whose value is < 128) are never used to index into this table."	"MIDIInputParser initialize"	DefaultMidiTable _ Array new: 255 withAll: #undefined:.	128 to: 143 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key off"	144 to: 159 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key on"	160 to: 175 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"polyphonic after-touch"	176 to: 191 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"control change"	192 to: 207 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"program change"	208 to: 223 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"channel after-touch"	224 to: 239 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"pitch bend"	DefaultMidiTable at: 240 put: #startSysExclusive:.		"start a system exclusive block"	DefaultMidiTable at: 241 put: #recordOne:.			"MIDI time code quarter frame"	DefaultMidiTable at: 242 put: #recordTwo:.			"song position select"	DefaultMidiTable at: 243 put: #recordOne:.			"song select"	DefaultMidiTable at: 244 put: #undefined:.	DefaultMidiTable at: 245 put: #undefined:.	DefaultMidiTable at: 246 put: #recordZero:.			"tune request"	DefaultMidiTable at: 247 put: #endSysExclusive:.		"end a system exclusive block"	DefaultMidiTable at: 248 put: #recordZero:.			"timing clock"	DefaultMidiTable at: 249 put: #undefined:.	DefaultMidiTable at: 250 put: #recordZero:.			"start"	DefaultMidiTable at: 251 put: #recordZero:.			"continue"	DefaultMidiTable at: 252 put: #recordZero:.			"stop/Clock"	DefaultMidiTable at: 253 put: #undefined:.	DefaultMidiTable at: 254 put: #recordZero:.			"active sensing"	DefaultMidiTable at: 255 put: #recordZero:.			"system reset"! !!MIDIInputParser class methodsFor: 'instance creation' stamp: 'jm 10/8/1998 20:29'!on: aSimpleMIDIPort	"Answer a new MIDI parser on the given port."	^ super new setMIDIPort: aSimpleMIDIPort! !!MIDISynth commentStamp: '<historical>' prior: 0!I implement a simple real-time MIDI synthesizer on platforms that support MIDI input. I work best on platforms that allow the sound buffer to be made very short--under 50 milliseconds is good and under 20 milliseconds is preferred (see below). The buffer size is changed by modifying the class initialization method of SoundPlayer and executing the do-it there to re-start the sound player.Each instance of me takes input from a single MIDI input port. Multiple instances of me can be used to handle multiple MIDI input ports. I distribute incoming commands among my sixteen MIDISynthChannel objects. Most of the interpretation of the MIDI commands is done by these channel objects. Buffer size notes: At the moment, most fast PowerPC Macintosh computers can probably work with buffer sizes down to 50 milliseconds, and the Powerbook G3 works down to about 15 milliseconds. You will need to experiment to discover the minimum buffer size that does not result in clicking during sound output. (Hint: Be sure to turn off power cycling on your Powerbook. Other applications and extensions can steal cycles from Squeak, causing intermittent clicking. Experimentation may be necessary to find a configuration that works for you.)!!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 22:16'!channel: i	^ channels at: i! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:46'!masterVolume: aNumber	| vol |	vol _ (aNumber asFloat min: 1.0) max: 0.0.	channels do: [:ch | ch masterVolume: vol].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 21:52'!midiParser	^ midiParser! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 12:09'!midiTrackingLoop	midiParser clearBuffers.	[true] whileTrue: [		self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:07'!on: aSimpleMIDIPort	"Prepare the receiver to process MIDI arriving on the given port."	midiParser _ MIDIInputParser on: aSimpleMIDIPort.	channels _ (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:13'!processMIDI	"Process some MIDI commands. Answer true if any commands were processed."	| didSomething cmdByte byte1 byte2 cmd chan |	didSomething _ false.	midiParser midiDo: [:item |		didSomething _ true.		cmdByte _ item at: 2.		byte1 _ byte2 _ nil.		item size > 2 ifTrue: [			byte1 _ item at: 3.			item size > 3 ifTrue: [byte2 _ item at: 4]].		cmdByte < 240			ifTrue: [  "channel message" 				cmd _ cmdByte bitAnd: 2r11110000.				chan _ (cmdByte bitAnd: 2r00001111) + 1.				(channels at: chan) doChannelCmd: cmd byte1: byte1 byte2: byte2]			ifFalse: [  "system message"				"process system messages here"			]].	^ didSomething! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:14'!processMIDIUntilMouseDown	"Used for debugging. Do MIDI processing until the mouse is pressed."	midiParser clearBuffers.	[Sensor anyButtonPressed] whileFalse: [self processMIDI].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:37'!startMIDITracking	midiParser ifNil: [^ self].	self stopMIDITracking.	process _ [self midiTrackingLoop] newProcess.	process priority: Processor userInterruptPriority.	process resume.! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:21'!stopMIDITracking	process ifNotNil: [		process terminate.		process _ nil].! !!MIDISynth class methodsFor: 'examples' stamp: 'jm 10/14/1998 22:53'!example	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."	| portNum synth |	portNum _ SimpleMIDIPort inputPortNumFromUser.	portNum ifNil: [^ self].	synth _ MIDISynth new on:		(SimpleMIDIPort openOnPortNumber: portNum).	synth midiParser ignoreCommand: 224.  "filter out pitch bends"	1 to: 16 do: [:i |		(synth channel: i) instrument: 			 (AbstractSound soundNamed: 'oboe1')].	synth masterVolume: 0.2.	synth processMIDIUntilMouseDown.! !!MIDISynthChannel commentStamp: '<historical>' prior: 0!I implement one polyphonic channel of a 16-channel MIDI synthesizer. Many MIDI commands effect all the notes played on a particular channel, so I record the state for a single channel, including a list of notes currently playing.This initial implementation is extremely spartan, having just enough functionality to play notes. Things that are not implemented include:  1. program changes  2. sustain pedal  3. aftertouch (either kind)  4. most controllers  5. portamento  6. mono-mode!!MIDISynthChannel methodsFor: 'initialization' stamp: 'jm 10/14/1998 13:15'!initialize	instrument _ FMSound default.	masterVolume _ 1.0.	channelVolume _ 1.0.	pitchBend _ 0.0.	activeSounds _ OrderedCollection new.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument	^ instrument! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument: aSound	instrument _ aSound.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:47'!masterVolume	^ masterVolume! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 11:49'!masterVolume: aNumber	"Set the master volume the the given value (0.0 to 1.0)."	masterVolume _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:40'!channelPressure: newPressure	"Handle a channel pressure (channel aftertouch) change."	self newVolume: newPressure.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:48'!control: control value: newValue	"Handle a continuous controller change."	control = 2 ifTrue: [self newVolume: newValue].  "breath controller"! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:44'!doChannelCmd: cmdByte byte1: byte1 byte2: byte2	"Dispatch a channel command with the given arguments."	"Details: Cases appear in order of expected frequency, most frequent cases first."	cmdByte = 144 ifTrue: [		byte2 = 0			ifTrue: [^ self keyUp: byte1 vel: 0]			ifFalse: [^ self keyDown: byte1 vel: byte2]].	cmdByte = 128 ifTrue: [^ self keyUp: byte1 vel: byte2].	cmdByte = 224 ifTrue: [^ self pitchBend: ((byte2 bitShift: 7) + byte1) - 8192].	cmdByte = 176 ifTrue: [^ self control: byte1 value: byte2].	cmdByte = 208 ifTrue: [^ self channelPressure: byte1].	cmdByte = 160 ifTrue: [^ self key: byte1 pressure: byte2].	cmdByte = 192 ifTrue: [^ self programChange: byte1].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!key: key pressure: press	"Handle a key pressure (polyphonic aftertouch) change. Rarely implemented."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:09'!keyDown: key vel: vel	"Handle a key down event with non-zero velocity."	| pitch snd |	pitch _ AbstractSound pitchForMIDIKey: key.	snd _ instrument		soundForPitch: pitch		dur: 10000.0  "sustain a long time, or until turned off"		loudness: masterVolume * channelVolume * (self convertVelocity: vel).	SoundPlayer resumePlaying: snd quickStart: false.	activeSounds add: (Array with: key with: snd with: pitch).! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!keyUp: key vel: vel	"Handle a key up event."	| snd |	activeSounds copy do: [:entry |		(entry at: 1) = key ifTrue: [			snd _ entry at: 2.			snd stopGracefully.			activeSounds remove: entry]].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 21:45'!pitchBend: bend	"Handle a pitch-bend change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:50'!programChange: newProgram	"Handle a program (instrument) change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 21:45'!adjustPitch: bend	"Handle a pitch-bend change."	| snd pitchAdj centerPitch |	pitchBend _ bend.	pitchAdj _ 2.0 raisedTo: (bend asFloat / 8192.0) / 6.0.	activeSounds copy do: [:entry |		snd _ entry at: 2.		centerPitch _ entry at: 3.		snd pitch: pitchAdj * centerPitch.		snd internalizeModulationAndRatio].! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:43'!convertVelocity: valueByte	"Map a value in the range 0..127 to a volume in the range 0.0..1.0."	"Details: A quadratic function seems to give a good keyboard feel."	| r |	r _ (valueByte * valueByte) / 12000.0.	r > 1.0 ifTrue: [^ 1.0].	r < 0.08 ifTrue: [^ 0.08].	^ r! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:41'!newVolume: valueByte	"Set the channel volume to the level given by the given number in the range 0..127."	| snd newVolume |	channelVolume _ valueByte asFloat / 127.0.	newVolume _ masterVolume * channelVolume.	activeSounds do: [:entry |		snd _ entry at: 2.		snd adjustVolumeTo: newVolume overMSecs: 10].! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16' prior: 34837183!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/24/1998 18:27' prior: 34838940!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 23.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!MIDIPianoKeyboardMorph commentStamp: '<historical>' prior: 0!I implement a piano keyboard that can be played with the mouse. I can output to a MIDI port, if MIDI is supported on this platform. I can also spawn controllers for other MIDI parameters, such as pitch bend.!!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:13'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	midiPort		ifNil: [aCustomMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aCustomMenu add: 'play via built in synth' action: #closeMIDIPort.			aCustomMenu add: 'new MIDI controller' action: #makeMIDIController:].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:57'!closeMIDIPort	midiPort _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:30'!initialize	super initialize.	SimpleMIDIPort midiIsSupported		ifTrue: [midiPort _ SimpleMIDIPort openDefault].	channel _ 1.	velocity _ 100.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:11'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: midiPort).! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [^ super mouseDownEvent: event noteMorph: noteMorph pitch: midiKey - 1].	noteMorph color: playingKeyColor.	soundPlaying		ifNil: [midiPort ensureOpen]		ifNotNil: [self turnOffNote].	self turnOnNote: midiKey + 23.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:43'!mouseUpEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [		^ super mouseUpEvent: event noteMorph: noteMorph pitch: midiKey].	noteMorph color:		((#(0 1 3 5 6 8 10) includes: midiKey \\ 12)			ifTrue: [whiteKeyColor]			ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [self turnOffNote].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:44'!turnOffNote	midiPort notNil & soundPlaying notNil ifTrue: [		soundPlaying isInteger ifTrue: [			midiPort midiCmd: 16r90 channel: channel byte: soundPlaying byte: 0]].	soundPlaying _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!turnOnNote: midiKey	midiPort midiCmd: 16r90 channel: channel byte: midiKey byte: velocity.	soundPlaying _ midiKey.! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 10/6/1998 23:47'!buildSmallOrchestra	"Example of how to build a skeleton orchestra that uses less memory."	"SampledInstrument buildSmallOrchestra"	AbstractSound unloadSampledTimbres.	#(clarinet oboe bassoon trombone tympani) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].	#(flute bass) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 17:13' prior: 35048152!closeMIDIPort	"Stop using MIDI for output. Music will be played using the built-in sound synthesis."	self pause.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/24/1998 22:33' prior: 35048409!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 5.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 15:56' prior: 35048892!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:58'!midiPort	^ midiPort! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/14/1998 15:53' prior: 21079010!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection	| oldSnd name snd |	oldSnd _ scorePlayer instrumentForTrack: trackIndex.	(selection beginsWith: 'edit ') ifTrue: [		name _ selection copyFrom: 6 to: selection size.		aPopUpChoice contentsClipped: name.		(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd title: name].		(oldSnd isKindOf: SampledInstrument) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].		^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((trackIndex ~= i) and:		 [selection = (instrumentSelector at: i) contents])			ifTrue: [snd _ scorePlayer instrumentForTrack: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:14'!closeMIDIPort	scorePlayer closeMIDIPort.	LastMIDIPort _ nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:06' prior: 35055906!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'reload instruments' action: #updateInstrumentsFromLibrary.	scorePlayer midiPort		ifNil: [			aMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aMenu add: 'play via built in synth' action: #closeMIDIPort.			aMenu add: 'new MIDI controller' action: #makeMIDIController:].	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/28/1998 23:05'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: scorePlayer midiPort).! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:31' prior: 35058029!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	scorePlayer openMIDIPort: portNum.	LastMIDIPort _ portNum.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:18' prior: 21085120!rewind	scorePlayer pause; reset.! !!ScorePlayerMorph class methodsFor: 'all' stamp: 'jm 10/12/1998 16:29' prior: 21088560!openOn: aScore title: aString	| player |	player _ ScorePlayer onScore: aScore.	(self new onScorePlayer: player title: aString) openInWorld.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:06' prior: 35134289!close	"Close this MIDI port."	portNumber ifNil: [^ self].	self primMIDIClosePort: portNumber.	accessSema _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:06' prior: 35134509!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	portNumber ifNil: [^ self error: 'Use "openOn:" to open a MIDI port initially'].	self close.	self openOnPortNumber: portNumber.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:13' prior: 35134959!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	self primMIDIClosePort: portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	portNumber _ portNum.	accessSema _ Semaphore forMutualExclusion.	lastCommandByteOut _ Array new: 16 withAll: 0.  "initialize running status state for output"! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 15:48'!portNumber	"Answer my port number."	^ portNumber! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00' prior: 35135325!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00' prior: 35135690!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte1					with: dataByte2)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00' prior: 35136093!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber from: aByteArray at: 0].! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:47'!bufferTimeStampFrom: aByteArray	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."	^ ((aByteArray at: 1) bitShift: 24) +	  ((aByteArray at: 2) bitShift: 16) +	  ((aByteArray at: 3) bitShift: 8) +	   (aByteArray at: 4)! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:53'!flushInput	"Read any lingering MIDI data from this port's input buffer."	| buf |	buf _ ByteArray new: 1000.	[(self readInto: buf) > 0] whileTrue.! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/12/1998 15:49'!readInto: aByteArray	"Read any data from this port into the given buffer."	^ self primMIDIReadPort: portNumber into: aByteArray! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/12/1998 16:04' prior: 35136339!primMIDIClosePort: portNum	"Close the given MIDI port. Don't fail if port is already closed."	<primitive: 521>! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:48'!primMIDIReadPort: portNum into: byteArray	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."	<primitive: 528>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:49' prior: 35137067!primMIDIWritePort: portNum from: byteArray at: midiClockValue	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 10/12/1998 16:36' prior: 35137655!openOnPortNumber: portNum	"Answer a new instance of me for the given MIDI port number."	"Details: All clients of a particular MIDI port should share the same instance of me. This allows accesses to the port to be serialized and shared port-related state state to be maintained."	SimpleMIDIPort allInstancesDo: [:p |		p portNumber = portNum ifTrue: [			"share the existing port object for this port number"			^ p]].	^ super new openOnPortNumber: portNum! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:27'!closeAllPorts	"Close all MIDI ports."	"SimpleMIDIPort closeAllPorts"	| n |	n _ self primPortCount.	0 to: n - 1 do: [:portNum | self basicNew primMIDIClosePort: portNum].! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:57'!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for input:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:10'!midiIsSupported	"Answer true if this platform supports MIDI."	^ self primPortCount > 0! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:58'!outputPortNumFromUser	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort outputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for output:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 2) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:46'!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName _ self primPortNameOf: portNum.	dir _ self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:22'!primPortCount	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."	<primitive: 523>	^ 0! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:27'!primPortDirectionalityOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 524>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:23'!primPortNameOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 525>	self primitiveFailed.! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 10/14/1998 23:03' prior: 35173115!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate _ 22050.	BufferMSecs _ 100.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !MIDIInputParser initialize!MIDISynth removeSelector: #initialize!MIDISynth removeSelector: #removePort:!MIDISynth removeSelector: #addPort:!MIDISynth removeSelector: #midiPlayLoop!MIDISynth removeSelector: #removeAllPorts!MIDISynth class removeSelector: #new!MIDISynthChannel removeSelector: #channel!MIDISynthChannel removeSelector: #keyUp:vel:chan:!MIDISynthChannel removeSelector: #channel:!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort0!MIDIPianoKeyboardMorph removeSelector: #midiPort:!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort1!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort:!ScorePlayerMorph removeSelector: #openMIDIPort0!ScorePlayerMorph removeSelector: #openMIDIPort0!ScorePlayerMorph removeSelector: #closeMIDI!ScorePlayerMorph removeSelector: #closeMIDI!ScorePlayerMorph removeSelector: #openMIDIPort1!ScorePlayerMorph removeSelector: #openMIDIPort1!SimpleMIDIPort removeSelector: #isOpen!SimpleMIDIPort removeSelector: #setPortNumber:!SimpleMIDIPort class removeSelector: #inputPortFromUser!SimpleMIDIPort class removeSelector: #outputPortFromUser!SimpleMIDIPort class removeSelector: #openOutputPortFromUser!SimpleMIDIPort class removeSelector: #primMIDIGetPortCount!SimpleMIDIPort class removeSelector: #portCount!SimpleMIDIPort class removeSelector: #openInputPortFromUser!SimpleMIDIPort class removeSelector: #portNameOf:!SimpleMIDIPort class removeSelector: #portDirectionalityOf:!SoundPlayer initialize!Smalltalk removeClassNamed: #SimpleMIDISynth!Smalltalk removeClassNamed: #SimpleMIDISynth!'From Squeak 2.2 of Sept 23, 1998 on 15 October 1998 at 9:49:48 am'!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 10/12/1998 08:58' prior: 21230381!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 ') == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	Transcript show: resp; cr.	(resp beginsWith: '227 ') ifFalse: [ "Check for Entering Passive Mode"		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 10/15/1998 09:30' prior: 35575769!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad _ self isBinary 		ifTrue: [aChar asCharacter asciiValue]	"ok for char or number"		ifFalse: [aChar asCharacter].	self nextPutAll: (buffer1 class new: ((self size - self position) min: 20000) 							withAll: pad).! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 10/9/1998 13:05' prior: 35239311!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct theurl map."	| map page folder dir rep templateFolder |	map _ self class mapClass new.	self map: map.	self formatter: (HTMLformatter new initialize).	self formatter specialCharacter: $*.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,				(ServerAction pathSeparator),fName action: self.			(page time isNil) ifTrue: [page time: Time now].			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 10/13/1998 12:29' prior: 33707437!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents: source, 'results.html')				with: (urlmap searchFor: (					request fields at: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only if logged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.		^ self].	"return self means do serve the edited page afterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag) withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.			^ self]].		"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!URLmap methodsFor: 'accessing' stamp: 'JZH 10/13/1998 22:56' prior: 22194375!atID: id	"Return page of a given key."	| idString |	idString _ id isInteger ifTrue: [id printString] ifFalse: [id].	^ pages detect: [:page | page coreID = idString] ifNone: [selfatID: '1']! !!URLmap methodsFor: 'accessing' stamp: 'mjg 10/14/1998 14:38' prior: 35361538!pageURL: aPage	(aPage pageStatus = #new)		ifTrue:			[(action isKindOf: CachedSwikiAction)			ifFalse: [^'<u>',(aPage name),'</u><a href="', 				(action pageURL: aPage),'.edit">?</a>']			ifTrue: [^'<u>',(aPage name),'</u><a href="',				(action pwsURL),(action name),'.',(aPage coreID),'.edit">?</a>']				"Underlines new but not yet edited pages"]		ifFalse:			[^'<a href="', (action pageURL: aPage),'">',(aPage name),'</a>']"Logically, there should be editPageUrl in SwikiAction as well. After all,we might want to define other URL schemes." ! !!URLmap methodsFor: 'creating' stamp: 'mjg 10/9/1998 13:06' prior: 35363119!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p |		p coreID asNumber > max ifTrue: [p coreID asNumber]				ifFalse: [max]]) + 1) printString.	newpage _ action class pageClass new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage time: (Time now).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory),		directory, (ServerAction pathSeparator), newfile).	newpage pageStatus: #new.	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !'From Squeak 2.2 of Sept 23, 1998 on 15 October 1998 at 11:42:42 am'!"Change Set:		miscTweaks-swDate:			15 October 1998Author:			Scott WallaceA variety of minor tweaks, including:* Restore the feature of presenting the core-sample list upon 'inspect' request from morph meta-menu.* Take down scrollbar in mvc-variant of SelectorBrowser before going off to new window.* Fix-up change-set-list after submerge-into-other-side command.* Wording change from 'scripting' to 'authoring tools' in world menu.* More morphic things work properly when requested in morphic worlds embedded in mvc projects. * If inactive SystemWindow gets dropped, activate it.* Several obsolete methods deleted."!!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/15/1998 11:29' prior: 17338418!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	self class gatherChangeSets.	parent modelWakeUp.	"(parent other: self) changed: #classList.	(parent other: self) changed: #messageList."! !!Morph methodsFor: 'initialization' stamp: 'sw 10/9/1998 08:41' prior: 34655094!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	self openInWorld: World! !!Morph methodsFor: 'initialization' stamp: 'sw 10/9/1998 08:40' prior: 34655368!openInWorld: aWorld	"Add this morph to the requested World."	aWorld addMorph: self.	aWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'geometry' stamp: 'sw 10/9/1998 08:56'!positionSubmorphs	self submorphsDo:		[:aMorph | aMorph snapToEdgeIfAppropriate]! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/9/1998 15:40' prior: 35457494!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: self world action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'authoring tools...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/8/1998 16:30' prior: 35540576!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorph].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!PluggableListView methodsFor: 'model access' stamp: 'sw 10/9/1998 08:24'!setSelectionSelectorIs: aSelector	^ aSelector == setSelectionSelector! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 10/9/1998 08:26' prior: 35092096!classListIndex: anInteger	classListIndex _ anInteger.	classListIndex > 0 ifTrue:		[self dependents do:			[:dep | ((dep isKindOf: PluggableListView) and:				[dep setSelectionSelectorIs: #classListIndex:])					ifTrue: [dep controller controlTerminate]].		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex _ 0"]! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/8/1998 13:42' prior: 35291067!extent: newExtent	| inner labelRect paneColor |	self removeHandles.	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].	self isActive ifTrue: [self addHandles]! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/15/1998 11:27' prior: 21847607!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [self position: ((self position max: 0@0) grid: 8@8).				collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds.				TopWindow ~~ self ifTrue: [self activate]]! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/8/1998 13:41'!setBoundsOfPaneMorphs	| panelRect |	panelRect _ self panelRect.	paneMorphs with: paneRects do:		[:m :frame |  "m color: paneColor."		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated]! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 10/15/1998 11:13'!positionSubmorphs	"Feels like overkill, but effect needed"	super positionSubmorphs.	self submorphsDo:		[:aMorph | aMorph positionSubmorphs]! !!SystemWindow methodsFor: 'top window' stamp: 'sw 10/9/1998 08:50' prior: 35551416!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph _ self topRendererOrSelf.	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !Presenter removeSelector: #addPageTwoControlsTo:!Presenter removeSelector: #addPageTwoControlsTo:!Presenter removeSelector: #newPlayfieldButton!Presenter removeSelector: #newPlayfieldButton!Presenter removeSelector: #makeNewPlayfield!Presenter removeSelector: #makeNewPlayfield!SystemWindow removeSelector: #openInWorld!SystemWindow removeSelector: #openInWorld!'From Squeak 2.2 of Sept 23, 1998 on 18 October 1998 at 9:27:17 am'!"Change Set:		SqTConstructDate:			18 October 1998Author:			Dan IngallsMakes ScorePlayerMorphs and MoviePlayerMorphs able to be instantiated without an open file.  You can then open a file via menu command.A movie player can be created from the new morphs...Demo menu, but the ScorePlayer is not currently available from any of these menus.  However, both can be instantiated by executing...	MoviePlayerMorph new openInWorld.	ScorePlayerMorph new openInWorld."!!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/13/1998 14:46'!openMovieFile	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.movie')					withCaption: 'Choose a movie file to open'.	fileName ifNotNil: [self openFileNamed: fileName]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/14/1998 15:50' prior: 34728437!setInitialState	super setInitialState.	self borderWidth: 2.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/13/1998 14:42'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('make thumbnail'		thumbnailForThisPage)			('open movie file'		openMovieFile)		).	(sel _ aMenu invokeAt: self primaryHand position in: self world)		ifNotNil: [self perform: sel].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/18/1998 06:53' prior: 35952460!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'reload instruments' action: #updateInstrumentsFromLibrary.	aMenu add: 'open a MIDI file' action: #openMIDIFile.	scorePlayer midiPort		ifNil: [			aMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aMenu add: 'play via built in synth' action: #closeMIDIPort.			aMenu add: 'new MIDI controller' action: #makeMIDIController:].	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/14/1998 15:30' prior: 35056330!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	scorePlayer ifNotNil:		[repeatSwitch _ SimpleSwitchMorph new			offColor: color;			onColor: (Color r: 1.0 g: 0.6 b: 0.6);			borderWidth: 2;			label: 'Repeat';			actionSelector: #repeat:;			target: scorePlayer;			setSwitchState: scorePlayer repeat.		r addMorphBack: repeatSwitch].	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/18/1998 09:07' prior: 35953193!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer.	scorePlayer ifNotNil:		[scorePlayer  reset.		instrumentSelector _ Array new: scorePlayer score tracks size].	self addMorph: self makeControls.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	scorePlayer ifNil: [^ self].	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 10/14/1998 15:46'!openMIDIFile	"Open a MIDI score and re-init controls..."	| score fileName f player |	fileName _ Utilities chooseFileWithSuffixFromList: #('.mid' '.midi')					withCaption: 'Choose a MIDI file to open'.	fileName ifNil: [^ self].	f _ FileStream readOnlyFileNamed: fileName.	score _ (MIDIFileReader new readMIDIFrom: f binary) asScore.	f close.	player _ ScorePlayer onScore: score.	self onScorePlayer: player title: fileName! !'From Squeak 2.2 of Sept 23, 1998 on 23 October 1998 at 10:03:58 am'!"Change Set:		PaneBorderEditsDate:			23 October 1998Author:			Dan IngallsThis fileIn adds pane resizing to morphic windows.  The old code has been refactored and the new code shares rectangle functions with the MVC resizing logic.  Also fixed a couple of bugs in the logic for minimum pane size limits.This new code also eliminates sensitive morphs as the basis for spawning window resize handles.  Instead it uses enter and leave events from panes and the window as a whole.  This makes things simpler, and easier use as well.Also added a stopgap feature for editing window labels, simlar to that in MVC."!!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00' prior: 20940381!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side _ self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09' prior: 20946727!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:22' prior: 21165798!mouseEnter: event	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event].	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self privateAddMorph: scrollBar atIndex: 1.				self resizeScrollBar.				scrollBar changed]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:24' prior: 35087792!mouseLeave: event	retractableScrollBar ifTrue:		[self privateRemoveMorph: scrollBar.		scrollBar privateOwner: nil].	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event]! !!SystemWindow methodsFor: 'initialization' stamp: 'di 10/22/1998 23:23' prior: 21844731!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabel to: self.	self extent: 300@200! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/20/1998 16:45' prior: 35977371!extent: newExtent	| inner labelRect paneColor |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/23/1998 09:39'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| panelRect |	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | 		(m bounds translateBy: panelRect topLeft negated)			scaleBy: (1.0 asPoint / panelRect extent)]! !!SystemWindow methodsFor: 'label' stamp: 'di 10/22/1998 23:28' prior: 21848271!setLabel: aString	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: bounds topCenter + (0@borderWidth)! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/21/1998 16:12'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen box |	theLen _ 0.	paneMorphs do:		[:pane | box _ pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane _ pane.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ thePane! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 22:55'!reframePanesAdjoining: growingPane along: side to: aDisplayBox 	| delta newRect minDim theMin horiz |	growingPane ifNil: [^ self].  "As from click outside"	newRect _ aDisplayBox.	horiz _ #(left right) includes: side.	theMin _ horiz ifTrue: [40] ifFalse: [20].	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ (((paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side])		collect: [:pane | pane bounds adjustTo: newRect along: side]) copyWith: aDisplayBox)			inject: 999 into:				[:was :rect | was min: (horiz ifTrue: [rect width] ifFalse: [rect height])].	"If so, amend newRect as required"	minDim > theMin ifFalse:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (growingPane bounds perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	paneMorphs do:		[:pane | (pane bounds bordersOn: growingPane bounds along: side) ifTrue:			[pane bounds: (pane bounds adjustTo: newRect along: side)]].	"And adjust the growing pane itself"	growingPane bounds: newRect.	"Finally force a recomposition of the whole window"	self setPaneRectsFromBounds.	self extent: self extent! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 23:18'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds |	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			side = #top ifTrue: [newBounds _ growingPane bounds withTop: localPt y].			side = #bottom ifTrue: [newBounds _ growingPane bounds withBottom: localPt y].			side = #left ifTrue: [newBounds _ growingPane bounds withLeft: localPt x].			side = #right ifTrue: [newBounds _ growingPane bounds withRight: localPt x].			self reframePanesAdjoining: growingPane along: side to: newBounds]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/23/1998 09:59'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [self bounds: (self bounds withTop: localPt y)].			ptName = #bottom ifTrue: [self bounds: (self bounds withBottom: localPt y)].			ptName = #left ifTrue: [self bounds: (self bounds withLeft: localPt x)].			ptName = #right ifTrue: [self bounds: (self bounds withRight: localPt x)].			ptName = #topLeft ifTrue: [self bounds: (self bounds bottomRight rect: localPt)].			ptName = #bottomRight ifTrue: [self bounds: (self bounds topLeft rect: localPt)].			ptName = #bottomLeft ifTrue: [self bounds: (self bounds topRight rect: localPt)].			ptName = #topRight ifTrue: [self bounds: (self bounds bottomLeft rect: localPt)]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/20/1998 16:44' prior: 35979147!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph _ self topRendererOrSelf.	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/20/1998 16:46' prior: 35296078!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	self submorphsDo: [:m | m lock].! !!SystemWindow methodsFor: 'events' stamp: 'di 10/23/1998 09:22'!paneTransition: event	"Mouse has entered or left a pane"	^ self spawnReframeHandle: event! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15' prior: 21546381!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect _ aDisplayBox.	theMin _ 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12' prior: 21557865!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen _ 0.	subViews do:		[:sub | box _ sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub _ sub.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ theSub! !Rectangle removeSelector: #forPoint:closestSideAndDist:!SystemWindow removeSelector: #updateIfOld!SystemWindow removeSelector: #updateIfOld!SystemWindow removeSelector: #addHandles!SystemWindow removeSelector: #addHandles!SystemWindow removeSelector: #addCustomMenuItems:hand:!SystemWindow removeSelector: #addCustomMenuItems:hand:!SystemWindow removeSelector: #removeHandles!SystemWindow removeSelector: #removeHandles!SystemWindow removeSelector: #enterHandle:morph:pointName:!SystemWindow removeSelector: #enterHandle:morph:pointName:!SystemWindow removeSelector: #spawnHandle:!View removeSelector: #bordersOn:along:!View removeSelector: #bordersOn:along:!StandardSystemView removeSelector: #newDisplayBoxFor:adjoining:along:!StandardSystemView removeSelector: #newDisplayBoxFor:adjoining:along:!SystemWindow allInstancesDo: 	[:w |	(w submorphs select: [:m | m isMemberOf: Morph])		do: [:m | m delete].	w on: #mouseEnter send: #spawnReframeHandle: to: w.	w on: #mouseLeave send: #spawnReframeHandle: to: w.	(w instVarNamed: 'label') on: #mouseDown send: #relabel to: w]!'From Squeak 2.2 of Sept 23, 1998 on 24 October 1998 at 12:42:07 pm'!"Change Set:		ReframeMinSizeDate:			24 October 1998Author:			Dan IngallsA simple tweak that prevents making SystemWindows too small."!!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/24/1998 12:40' prior: 35994756!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [newBounds _ self bounds withTop: localPt y].			ptName = #bottom ifTrue: [newBounds _ self bounds withBottom: localPt y].			ptName = #left ifTrue: [newBounds _ self bounds withLeft: localPt x].			ptName = #right ifTrue: [newBounds _ self bounds withRight: localPt x].			ptName = #topLeft ifTrue: [newBounds _ self bounds bottomRight rect: localPt].			ptName = #bottomRight ifTrue: [newBounds _ self bounds topLeft rect: localPt].			ptName = #bottomLeft ifTrue: [newBounds _ self bounds topRight rect: localPt].			ptName = #topRight ifTrue: [newBounds _ self bounds bottomLeft rect: localPt].			self bounds: (newBounds topLeft extent: (newBounds extent max: 60@40))]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !'From Squeak 2.2 of Sept 23, 1998 on 24 October 1998 at 1:11:01 pm'!"Change Set:		ReframeMinSize2Date:			24 October 1998Author:			Dan IngallsA second tweak that prevents making SystemWindows too small.  This one prevents changing any dimension other than the one being dragged."!!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/24/1998 12:47' prior: 36000670!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [newBounds _ self bounds withTop: localPt y].			ptName = #bottom ifTrue: [newBounds _ self bounds withBottom: localPt y].			ptName = #left ifTrue: [newBounds _ self bounds withLeft: localPt x].			ptName = #right ifTrue: [newBounds _ self bounds withRight: localPt x].			ptName = #topLeft ifTrue: [newBounds _ self bounds bottomRight rect: localPt].			ptName = #bottomRight ifTrue: [newBounds _ self bounds topLeft rect: localPt].			ptName = #bottomLeft ifTrue: [newBounds _ self bounds topRight rect: localPt].			ptName = #topRight ifTrue: [newBounds _ self bounds bottomLeft rect: localPt].			newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !'From Squeak 2.2 of Sept 23, 1998 on 24 October 1998 at 1:28:03 pm'!"Change Set:		ReframeMin3Date:			24 October 1998Author:			Dan IngallsA third tweak that prevents making SystemWindows too small.  This one really really prevents changing any dimension other than the one being dragged."!!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/24/1998 13:19' prior: 36002722!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [newBounds _ self bounds withTop: localPt y].			ptName = #bottom ifTrue: [newBounds _ self bounds withBottom: localPt y].			ptName = #left ifTrue: [newBounds _ self bounds withLeft: localPt x].			ptName = #right ifTrue: [newBounds _ self bounds withRight: localPt x].			ptName = #topLeft ifTrue: [newBounds _ localPt corner: bounds bottomRight].			ptName = #bottomRight ifTrue: [newBounds _ bounds topLeft corner: localPt].			ptName = #bottomLeft ifTrue: [newBounds _ (bounds withBottom: localPt y) withLeft: localPt x].			ptName = #topRight ifTrue: [newBounds _ (bounds withTop: localPt y) withRight: localPt x].			newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !'From Squeak 2.2 of Sept 23, 1998 on 25 October 1998 at 4:16:15 pm'!!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/25/1998 16:16' prior: 35718905!storeInteger: index ofObject: oop withValue: integer	(self isIntegerValue: integer) 		ifTrue:[^self storePointer: index ofObject: oop withValue: integer]		ifFalse:[^self primitiveFail]! !'From Squeak 2.2 of Sept 23, 1998 on 25 October 1998 at 4:31:10 pm'!"Change Set:		SoundFixDate:			25 October 1998Author:			Andreas RaabThis change set disables sounds automatically if the sound startprimitive fails."!!SoundPlayer class methodsFor: 'playing' stamp: 'ar 10/25/1998 16:28' prior: 35174375!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	doQuickStart _ quickStart.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		"Playing may have been disabled in startup, so check"		Preferences disableSounds ifTrue: [^ self].		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 10/25/1998 16:30' prior: 21460702!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	ActiveSounds _ OrderedCollection new.	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	Preferences setPreference: #disableSounds toValue: false. "set to true if startup fails"	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	Preferences disableSounds ifTrue:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 10/25/1998 16:19' prior: 21466749!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	"ar 10/25/1998: Disable sounds if the primitive fails"	<primitive: 170>	Preferences setPreference: #disableSounds toValue: true.! !'From Squeak 2.2 of Sept 23, 1998 on 31 October 1998 at 1:49:48 pm'!Object subclass: #FWT	instanceVariableNames: 'alpha beta coeffs h g hTilde gTilde samples nSamples nLevels transform '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!FWT commentStamp: '<historical>' prior: 0!This class implements the Fast Wavelet Transform.  It follows Mac Cody's article in Dr. Dobb's Journal, April 1992.Notable features of his implementation include...1.  The ability to generate a large family of wavelets (including the Haar (alpha=beta) and Daubechies) from two parameters, alpha and beta, which range between -pi and pi.2.  All data arrays have 5 elements added on to allow for convolution overrun with filters up to 6 in length (the max for this implementation).3.  After a forward transform, the detail coefficients of the deomposition are found in transform at: 2*i, for i = 1, 2, ... nLevels;  and the approximation coefficients are in transform at: (2*nLevels-1).  these together comprise the complete wavelet transform.The following changes from cody's listings should also be noted...1.  The three DotProduct routines have been merged into one.2.  The four routines WaveletDecomposition, DecomposeBranches, WaveletReconstruction, ReconstructBranches have all been merged into transformForward:.3.  All indexing follows the Smalltalk 1-to-N convention, naturally.!!FWT methodsFor: 'initialization' stamp: 'di 10/31/1998 12:23'!nSamples: n nLevels: nLevs	"Initialize a wavelet transform."	"Note the sample array size must be N + 5, where N is a multiple of 2^nLevels"	| dyadSize |	(n // (1 bitShift: nLevs)) > 0 ifFalse: [self error: 'Data size error'].	(n \\ (1 bitShift: nLevs)) = 0 ifFalse: [self error: 'Data size error'].	nSamples _ n.	samples _ Array new: n + 5.	nLevels _ nLevs.	transform _ Array new: nLevels*2.  "Transformed data is stored as a tree of coeffs"	dyadSize _ nSamples.	1 to: nLevels do:		[:i |  dyadSize _ dyadSize // 2.		transform at: 2*i-1 put: (Array new: dyadSize + 5).		transform at: 2*i put: (Array new: dyadSize + 5)]! !!FWT methodsFor: 'initialization' stamp: 'di 10/30/1998 10:59'!setAlpha: alph beta: bet	"Set alpha and beta, compute wavelet coeefs, and derive hFilter and lFilter"	| tcosa tcosb tsina tsinb |	alpha _ alph.	beta _ bet.	"WaveletCoeffs..."	"precalculate cosine of alpha and sine of beta"	tcosa _ alpha cos.	tcosb _ beta cos.	tsina _ alpha sin.	tsinb _ beta sin.	coeffs _ Array new: 6.		"calculate first two wavelet coefficients a _ a(-2) and b _ a(-1)"	coeffs at: 1 put: ((1.0 + tcosa + tsina) * (1.0 - tcosb - tsinb)					+ (2.0 * tsinb * tcosa)) / 4.0.	coeffs at: 2 put: ((1.0 - tcosa + tsina) * (1.0 + tcosb - tsinb)					- (2.0 * tsinb * tcosa)) / 4.0.	"precalculate cosine and sine of alpha minus beta"	tcosa _ (alpha - beta) cos.	tsina _ (alpha - beta) sin.	"calculate last four wavelet coefficients c _ a(0), d _ a(1), e _ a(2), and f _ a(3)"	coeffs at: 3 put: (1.0 + tcosa + tsina) / 2.0.	coeffs at: 4 put: (1.0 + tcosa - tsina) / 2.0.	coeffs at: 5 put: 1.0 - (coeffs at: 1) - (coeffs at: 3).	coeffs at: 6 put: 1.0 - (coeffs at: 2) - (coeffs at: 4).	"MakeFiltersFromCoeffs..."	"Select the non-zero wavelet coefficients"	coeffs _ coeffs copyFrom: (coeffs findFirst: [:c | c abs > 1.0e-14])						to: (coeffs findLast: [:c | c abs > 1.0e-14]).	"Form the low pass and high pass filters for decomposition"	hTilde _ coeffs reversed collect: [:c | c / 2.0].	gTilde _ coeffs collect: [:c | c / 2.0].	1 to: gTilde size by: 2 do:		[:i | gTilde at: i put: (gTilde at: i) negated].	"Form the low pass and high pass filters for reconstruction"	h _ coeffs copy.	g _ coeffs reversed.	2 to: g size by: 2 do:		[:i | g at: i put: (g at: i) negated]! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:19'!coeffs	"Return all coefficients neede to reconstruct the original samples"	| header csize strm |	header _ Array with: nSamples with: nLevels with: alpha with: beta.	csize _ header size.	1 to: nLevels do: [:i | csize _ csize + (transform at: i*2) size].	csize _ csize + (transform at: nLevels*2-1) size.	coeffs _ Array new: csize.	strm _ WriteStream on: coeffs.	strm nextPutAll: header.	1 to: nLevels do: [:i | strm nextPutAll: (transform at: i*2)].	strm nextPutAll: (transform at: nLevels*2-1).	^ coeffs! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:23'!coeffs: coeffArray	"Initialize this instance from the given coeff array (including header)."	| header strm |	strm _ ReadStream on: coeffArray.	header _ strm next: 4.	self nSamples: header first nLevels: header second.	self setAlpha: header third beta: header fourth.	1 to: nLevels do: [:i | transform at: i*2 put: (strm next: (transform at: i*2) size)].	transform at: nLevels*2-1 put: (strm next: (transform at: nLevels*2-1) size).	strm atEnd ifFalse: [self error: 'Data size error'].! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:26'!samples	^ samples copyFrom: 1 to: nSamples! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:25'!samples: anArray	1 to: anArray size do:		[:i | samples at: i put: (anArray at: i)].	nSamples+1 to: nSamples+5 do:		[:i | samples at: i put: 0.0]! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 09:20'!convolveAndDec: inData dataLen: inLen filter: filter out: outData	"convolve the input sequence with the filter and decimate by two"	| filtLen offset outi dotp |	filtLen _ filter size.	outi _ 1.	1 to: inLen+9 by: 2 do:		[:i | 		i < filtLen		ifTrue:			[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: i inc: 1]		ifFalse:			[i > (inLen+5)			ifTrue:				[offset _ i - (inLen+5).				dotp _ self dotpData: inData endIndex: inLen+5 filter: filter						start: 1+offset stop: filtLen inc: 1]			ifFalse:				[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: filtLen inc: 1]].		outData at: outi put: dotp.		outi _ outi + 1]! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 09:51'!convolveAndInt: inData dataLen: inLen filter: filter sumOutput: sumOutput into: outData	"insert zeros between each element of the input sequence and	   convolve with the filter to interpolate the data"	| outi filtLen oddTerm evenTerm |	outi _ 1.	filtLen _ filter size.	"every other dot product interpolates the data"	filtLen // 2 to: inLen + filtLen - 2 do:		[:i |		oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.		evenTerm _ self dotpData: inData endIndex: i+1 filter: filter									start: 1 stop: filter size inc: 2.		sumOutput			ifTrue:				["summation with previous convolution if true"				outData at: outi put: (outData at: outi) + oddTerm.				outData at: outi+1 put: (outData at: outi+1) + evenTerm]			ifFalse:				["first convolution of pair if false"				outData at: outi put: oddTerm.				outData at: outi+1 put: evenTerm].		outi _ outi + 2].	"Ought to be able to fit this last term into the above loop."	i _ inLen + filtLen - 1.	oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.	sumOutput		ifTrue: [outData at: outi put: (outData at: outi) + oddTerm]		ifFalse: [outData at: outi put: oddTerm].! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 12:55'!dotpData: data endIndex: endIndex filter: filter start: start stop: stop inc: inc	| sum i j |	sum _ 0.0.	j _ endIndex.	i _ start.	[i <= stop] whileTrue:		[sum _ sum + ((data at: j) * (filter at: i)).		i _ i + inc.		j _ j - 1].	^ sum! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 15:53'!transformForward: forward	| inData inLen outData |	forward	ifTrue:		["first InData is input signal, following are intermediate approx coefficients"		inData _ samples.  inLen _ nSamples.		1 to: nLevels do:			[:i |			self convolveAndDec: inData dataLen: inLen					filter: hTilde out: (transform at: 2*i-1).			self convolveAndDec: inData dataLen: inLen					filter: gTilde out: (transform at: 2*i).			inData _ transform at: 2*i-1.  inLen _ inLen // 2]]	ifFalse:		[inLen _ nSamples >> nLevels.		"all but last outData are next higher intermediate approximations,		last is final reconstruction of samples"		nLevels to: 1 by: -1 do:			[:i |			outData _ i = 1 ifTrue: [samples]						ifFalse: [transform at: 2*(i-1)-1].			self convolveAndInt: (transform at: 2*i-1) dataLen: inLen					filter: h sumOutput: false into: outData.			self convolveAndInt: (transform at: 2*i) dataLen: inLen					filter: g sumOutput: true into: outData.			inLen _ inLen * 2]]! !!FWT methodsFor: 'testing' stamp: 'di 10/31/1998 12:25'!doWaveDemo  "FWT new doWaveDemo"	"Printing the above should yield a small number -- I get 1.1e-32"	| originalData |	self nSamples: 312 nLevels: 3.	self setAlpha: 0.0 beta: 0.0.	"Install a sine wave as sample data"	self samples: ((1 to: nSamples) collect: [:i | ((i-1) * 0.02 * Float pi) sin]).	originalData _ samples copy.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (0@0 extent: nSamples@100).	"Transform forward and plot the decomposition"	self transformForward: true.	transform withIndexDo:		[:w :i |		FFT new plot: (w copyFrom: 1 to: w size-5)			in: (i-1\\2*320@(i+1//2*130) extent: (w size-5)@100)].	"Test copy out and read in the transform coefficients"	self coeffs: self coeffs.	"Ttransform back, plot the reconstruction, and return the error figure"	self transformForward: false.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (320@0 extent: nSamples@100).	^ self meanSquareError: originalData! !!FWT methodsFor: 'testing' stamp: 'di 10/30/1998 15:58'!meanSquareError: otherData	"Return the mean-square error between the current sample array and	some other data, presumably to evaluate a compression scheme."	| topSum bottomSum pointDiff |	topSum _ bottomSum _ 0.0.	1 to: nSamples do:		[:i |  pointDiff _ (samples at: i) - (otherData at: i).		topSum _ topSum + (pointDiff * pointDiff).		bottomSum _ bottomSum + ((otherData at: i) * (otherData at: i))].	^ topSum / bottomSum! !!FWT methodsFor: 'testing' stamp: 'di 10/30/1998 15:53'!viewPhiAndPsi  "(FWT new sampleSize: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p _ Sensor cursorPoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !'From Squeak 2.2 of Sept 23, 1998 on 2 November 1998 at 9:46:33 am'!"Change Set:		sw_emptyCheckDate:			2 November 1998Author:			Scott WallaceFixes a long-standing bug in ParagraphEditor.lineSelectAndEmptyCheck:, which resulted, among other things, in the paste-buffer erroneously being cleared when you attempt to copy an empty selection.Also, makes morphic text-editing consistent with mvc text-editing in that commands that are rejected because of an empty selection result in the same flashing of the pane"!!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 11/2/1998 09:43' prior: 20392864!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	startBlock = stopBlock ifTrue: [self flash.  ^ returnBlock value]! !'From Squeak 2.2 of Sept 23, 1998 on 2 November 1998 at 2:29:19 pm'!"Change Set:		FWTtweaksDate:			2 November 1998Author:			Dan IngallsA couple of comment fixes to my wavelet transform."!!FWT commentStamp: '<historical>' prior: 36010011!This class implements the Fast Wavelet Transform.  It follows Mac Cody's article in Dr. Dobb's Journal, April 1992.  See also... 	http://www.dfw.net/~mcody/fwt/fwt.htmlNotable features of his implementation include...1.  The ability to generate a large family of wavelets (including the Haar (alpha=beta) and Daubechies) from two parameters, alpha and beta, which range between -pi and pi.2.  All data arrays have 5 elements added on to allow for convolution overrun with filters up to 6 in length (the max for this implementation).3.  After a forward transform, the detail coefficients of the deomposition are found in transform at: 2*i, for i = 1, 2, ... nLevels;  and the approximation coefficients are in transform at: (2*nLevels-1).  these together comprise the complete wavelet transform.The following changes from cody's listings should also be noted...1.  The three DotProduct routines have been merged into one.2.  The four routines WaveletDecomposition, DecomposeBranches, WaveletReconstruction, ReconstructBranches have all been merged into transformForward:.3.  All indexing follows the Smalltalk 1-to-N convention, naturally.!!FWT methodsFor: 'testing' stamp: 'di 10/31/1998 22:17' prior: 36019873!viewPhiAndPsi  "(FWT new nSamples: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p _ Sensor cursorPoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !'From Squeak 2.2 of Sept 23, 1998 on 3 November 1998 at 12:55:55 am'!"Change Set:		PPrim-DecompileFix-arDate:			3 November 1998Author:			PPrim-DecompileFixFixed the decompilation of methods by printing the primitive names if appropriate."!!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/3/1998 00:50'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ self primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: self primitive].	aStream nextPut: $>; cr! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/3/1998 00:51' prior: 17592509!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each." 	| aStream |	self isQuick ifTrue: 		[self isReturnSpecial ifTrue: [^ 'Quick return ' ,				(#('self' 'true' 'false' 'nil' '-1' '0' '1' '2')						at: self primitive - 255)].		^ 'Quick return field ' , self returnField printString , ' (0-based)'].	aStream _ WriteStream on: (String new: 1000).	self printPrimitiveOn: aStream.	(InstructionPrinter on: self) printInstructionsOn: aStream.	^aStream contents! !!MethodNode methodsFor: 'printing' stamp: 'ar 11/3/1998 00:52' prior: 19868882!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ encoder literals at: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: self primitive].	aStream nextPut: $>.! !'From Squeak 2.2 of Sept 23, 1998 on 3 November 1998 at 1:14:42 am'!!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 11/3/1998 01:14' prior: 35711484!translateDoInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translateDoInlining: true.		Smalltalk beep]"	^self translate: (self moduleName,'.c') doInlining: inlineFlag! !'From Squeak 2.2 of Sept 23, 1998 on 4 November 1998 at 12:33:05 pm'!"Change Set:		SelectionOfItFixes-diDate:			2 November 1998Author:			Dan IngallsPasses TextMorph selection on to ParagraphEditor in order for the various commands, such as sendersOfIt, to operate on the correct range of text.Also includes Scott Wallace's fix for choosing 'more...' in the shifted branch of the text-pane menu (used to fall into a debugger)."!!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02' prior: 20739431!fileItIn	self handleEdit: [textMorph editor fileItIn]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02' prior: 20739946!implementorsOfIt	self handleEdit: [textMorph editor implementorsOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01' prior: 20740367!methodNamesContainingIt	self handleEdit: [textMorph editor methodNamesContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01' prior: 20740514!methodSourceContainingIt	self handleEdit: [textMorph editor methodSourceContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01' prior: 20740663!methodStringsContainingit	self handleEdit: [textMorph editor methodStringsContainingit]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:59' prior: 20741742!referencesToIt	self handleEdit: [textMorph editor referencesToIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:31' prior: 20742168!sendersOfIt	self handleEdit: [textMorph editor sendersOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/2/1998 17:49'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu event |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		event _ self primaryHand lastEvent.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 11/2/1998 15:57' prior: 34910894!handleEdit: editBlock	| result |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !'From Squeak 2.2 of Sept 23, 1998 on 5 November 1998 at 5:42:49 pm'!"Change Set:		PPrim-DecompileFix-arDate:			3 November 1998Author:			PPrim-DecompileFixFixed the decompilation of methods by printing the primitive names if appropriate."!!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/5/1998 17:41' prior: 36024916!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ self primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>; cr! !!MethodNode methodsFor: 'printing' stamp: 'ar 11/5/1998 17:42' prior: 36026144!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0 ifTrue:[^self].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ encoder literals at: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>.! !'From Squeak 2.2 of Sept 23, 1998 on 6 November 1998 at 11:15:56 am'!"Change Set:		newCoercion1Date:			6 November 1998Author:			Dan IngallsThis is the first part of a new arithmetic coercion package for Squeak, based on a single coercion message for every pair of types.  The pattern is as follows:If there is a failure of 	self<Type2> op: arg<Type1>then it is handled by	^ arg adaptToType2: self andSend: #op:and this is resolved by a coercion method such as	<type1> adaptToType2: aType2 andSend: selector		-- If I am involved in arithmetic with a Type2, convert us first. --		^ aType2 coerced perform: selector with: self coercedEach such method exactly summarizes the coercion between type1 and type2.The coercions supported include arithemtic (+ - * / // \\) and comparison (< = > <= >=) between	Integer	Fraction	Float	Pointwith arithmetic also extended to Collections.  The extension to collections includes scalars with collections and commensurate sequenceable collections.The number of coercion messages is less than N squared, where N is the number of arithmetic types.  This compares to M * (N squared) for double dispatching, in the case that M different arithmetic operations are being supported (we have M = 11 for arithmetic plus comparisons).  The actual number is less owing to sharing by inheritance.The entire arithmetic family above is accomplished with only 18 small methods.  This compares to 26 in the previous Squeak coercion, in which Points were not fully supported, and no collections were.  It compares to over a hundred methods in a full double dispatch solution."!!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:34'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with another Collection, return a Collection of	the results of each element combined with the scalar in that expression."	rcvr isSequenceable & self isSequenceable ifFalse:		[self error: 'Only sequenceable collections may be combined arithmetically'].	^ rcvr with: self collect:		[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:34'!adaptToFloat: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:35'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:36'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:37'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Collection methodsFor: 'converting' stamp: 'di 11/6/1998 13:37'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:38'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:07'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Fraction methodsFor: 'converting' stamp: 'di 11/6/1998 13:10'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Fraction."	^ rcvr asFraction perform: selector with: self! !!Integer methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: self asFraction! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:46'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:11'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr asPoint perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a collection, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:48'!adaptToFloat: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:48'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a point, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a string, convert us both to	numbers, and return the printString of the result."	^ (rcvr asNumber perform: selector with: self asNumber) printString! !!Object methodsFor: 'testing' stamp: 'di 11/6/1998 08:04'!isPoint	"Overridden to return true in Point."	^ false! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Collection methodsFor: 'testing' stamp: 'di 11/6/1998 09:16'!isSequenceable	^ false! !!SequenceableCollection methodsFor: 'converting' stamp: 'di 11/6/1998 09:35'!isSequenceable	^ true! !!OrderedCollection methodsFor: 'enumerating' stamp: 'TAG 10/13/1998 22:47'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!Bag methodsFor: 'adding' stamp: 'TAG 10/13/1998 22:39' prior: 16876802!add: newObject withOccurrences: anInteger 	"Add the element newObject to the receiver. Do so as though the element  	were added anInteger number of times. Answer newObject."	contents at: newObject put: (contents at: newObject ifAbsent: [0])			+ anInteger.	^ newObject! !'From Squeak 2.2 of Sept 23, 1998 on 6 November 1998 at 11:16:00 am'!"Change Set:		newCoercion2Date:			6 November 1998Author:			Dan IngallsThis is the second part of a new arithmetic coercion package for Squeak.See the file newCoercion1 for a full description."!!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!* arg	^ arg adaptToCollection: self andSend: #*! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!+ arg	^ arg adaptToCollection: self andSend: #+! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!- arg	^ arg adaptToCollection: self andSend: #-! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!/ arg	^ arg adaptToCollection: self andSend: #/! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!// arg	^ arg adaptToCollection: self andSend: #//! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!\\ arg	^ arg adaptToCollection: self andSend: #\\! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54' prior: 18704781!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ aNumber adaptToFloat: self andSend: #*! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:22' prior: 18705065!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55' prior: 18705335!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ aNumber adaptToFloat: self andSend: #-! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55' prior: 18705617!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0 ifTrue: [self error: 'attempt to divide by zero'].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55' prior: 18712934!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andSend: #<! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55' prior: 18713282!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andSend: #<=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56' prior: 18713643!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andSend: #=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57' prior: 18714028!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57' prior: 18714379!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58' prior: 18885123!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 _ numerator gcd: aNumber denominator.		d2 _ denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58' prior: 18885713!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d _ denominator gcd: aNumber denominator.		n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).		d1 _ d1 * d2.		n _ n // (d2 _ n gcd: d).		(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58' prior: 18886210!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction ifTrue:		[^ self + aNumber negated].	^ aNumber adaptToFraction: self andSend: #-! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58' prior: 18886447!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal].	^ aNumber adaptToFraction: self andSend: #/! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58' prior: 18887179!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58' prior: 18887406!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [aNumber numerator = 0				ifTrue: [^ numerator = 0]				ifFalse: [^ aNumber numerator = numerator 							and: [aNumber denominator = denominator]]].	^ aNumber adaptToFraction: self andSend: #=! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59' prior: 19138582!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59' prior: 19138844!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59' prior: 19139160!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00' prior: 34278916!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00' prior: 34279394!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng _ self negative == aNumber negative == false.		quo _ (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00' prior: 19140820!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00' prior: 19141167!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00' prior: 19141461!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01' prior: 20757754!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01' prior: 20757982!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02' prior: 20758206!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02' prior: 20758437!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02' prior: 20758666!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02' prior: 20759042!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!SmallInteger methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:12' prior: 21361962!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 1>	aNumber isInteger ifTrue: [^ super + aNumber].	^ aNumber adaptToInteger: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!* arg	^ arg adaptToString: self andSend: #*! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!+ arg	^ arg adaptToString: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!- arg	^ arg adaptToString: self andSend: #-! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!/ arg	^ arg adaptToString: self andSend: #/! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!// arg	^ arg adaptToString: self andSend: #//! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!\\ arg	^ arg adaptToString: self andSend: #\\! !Number removeSelector: #adaptFloat:!Number removeSelector: #adaptFloat:!Number removeSelector: #adaptToInteger!Number removeSelector: #adaptToInteger!Number removeSelector: #adaptInteger:!Number removeSelector: #adaptInteger:!Number removeSelector: #adaptToFloat!Number removeSelector: #adaptToFloat!Number removeSelector: #adaptToFraction!Number removeSelector: #adaptToFraction!Number removeSelector: #adaptFraction:!Number removeSelector: #adaptFraction:!Float removeSelector: #adaptToInteger!Float removeSelector: #adaptToInteger!Float removeSelector: #adaptToFraction!Float removeSelector: #adaptToFraction!Float removeSelector: #adaptInteger:!Float removeSelector: #adaptInteger:!Float removeSelector: #adaptFraction:!Float removeSelector: #adaptFraction:!Fraction removeSelector: #adaptToFloat!Fraction removeSelector: #adaptToFloat!Fraction removeSelector: #adaptToInteger!Fraction removeSelector: #adaptToInteger!Fraction removeSelector: #adaptFloat:!Fraction removeSelector: #adaptFloat:!Fraction removeSelector: #adaptInteger:!Fraction removeSelector: #adaptInteger:!Integer removeSelector: #adaptToFloat!Integer removeSelector: #adaptToFloat!Integer removeSelector: #adaptFloat:!Integer removeSelector: #adaptFloat:!Integer removeSelector: #adaptToFraction!Integer removeSelector: #adaptToFraction!Integer removeSelector: #adaptFraction:!Integer removeSelector: #adaptFraction:!Point removeSelector: #adaptToFloat!Point removeSelector: #adaptToFloat!Point removeSelector: #adaptToInteger!Point removeSelector: #adaptToInteger!Point removeSelector: #adaptFloat:!Point removeSelector: #adaptFloat:!Point removeSelector: #adaptInteger:!Point removeSelector: #adaptInteger:!SmallInteger removeSelector: #adaptToFloat!SmallInteger removeSelector: #adaptToFloat!'From Squeak 1.19d of April 13, 1997 on 5 November 1998 at 10:11:05 pm'!SequenceableCollection subclass: #MappedCollection	instanceVariableNames: 'domain map '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!MappedCollection commentStamp: '<historical>' prior: 0!I represent an access mechanism for a sequencable collection re-ordering or filtering its elements.!MappedCollection comment:'I represent an access mechanism for a sequencable collection re-ordering or filtering its elements.'!!MappedCollection methodsFor: 'accessing'!at: anIndex	^domain at: (map at: anIndex)! !!MappedCollection methodsFor: 'accessing'!at: anIndex put: anObject	^domain at: (map at: anIndex) put: anObject! !!MappedCollection methodsFor: 'accessing'!atPin: anIndex 	"Return this element of an indexable object.  Return the first or last element if index is out of bounds.  6/18/96 tk"	^domain at: (map atPin: anIndex)! !!MappedCollection methodsFor: 'accessing'!atWrap: anIndex 	"Return this element of an indexable object.  If index is out of bounds, let it wrap around from the end to the beginning unil it is in bounds.  6/18/96 tk"	^domain at: (map atWrap: anIndex)! !!MappedCollection methodsFor: 'accessing'!contents	"Answer the receiver's domain for mapping, a Dictionary or 	SequenceableCollection."	^map collect: [:mappedIndex | domain at: mappedIndex]! !!MappedCollection methodsFor: 'accessing'!size	^map size! !!MappedCollection methodsFor: 'adding'!add: newObject	self shouldNotImplement! !!MappedCollection methodsFor: 'copying'!copy	"This returns another MappedCollection whereas copyFrom:to: will return	an object like my domain."	^MappedCollection collection: domain map: map! !!MappedCollection methodsFor: 'enumerating'!collect: aBlock 	"Refer to the comment in Collection|collect:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do:		[:domainValue | 		aStream nextPut: (aBlock value: domainValue)].	^aStream contents! !!MappedCollection methodsFor: 'enumerating'!do: aBlock 	"Refer to the comment in Collection|do:."	map do:		[:mapValue | aBlock value: (domain at: mapValue)]! !!MappedCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do:		[:domainValue | 		(aBlock value: domainValue)			ifTrue: [aStream nextPut: domainValue]].	^aStream contents! !!MappedCollection methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	domain storeOn: aStream.	aStream nextPutAll: ' mappedBy: '.	map storeOn: aStream.	aStream nextPut: $)! !!MappedCollection methodsFor: 'private'!setCollection: aCollection map: aDictionary	domain _ aCollection.	map _ aDictionary! !!MappedCollection methodsFor: 'private'!species	^domain species! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MappedCollection class	instanceVariableNames: ''!!MappedCollection class methodsFor: 'instance creation'!collection: aCollection map: aSequenceableCollection 	"Answer an instance of me that maps aCollection by 	aSequenceableCollection."	^self basicNew setCollection: aCollection map: aSequenceableCollection! !!MappedCollection class methodsFor: 'instance creation'!new	self error: 'MappedCollections must be created using the collection:map: message'! !!MappedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ self collection: aCollection map: (1 to: aCollection size)"	MappedCollection newFrom: {1. 2. 3}	{4. 3. 8} as: MappedCollection"! !'From Squeak 2.2 of Sept 23, 1998 on 6 November 1998 at 2:47:17 pm'!!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:32'!atPin: index 	"Return the index'th element of me if possible.	Return the first or last element if index is out of bounds."	index < 1 ifTrue: [^ self first].	index > self size ifTrue: [^ self last].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:42'!atWrap: index 	"Return the index'th element of me.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds."	(index < 1 or: [index > self size]) ifTrue:		[^ self at: (index - 1 \\ self size) + 1].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:46'!atWrap: index put: value	"Store value into the index'th element of me.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds."	(index < 1 or: [index > self size]) ifTrue:		[^ self at: (index - 1 \\ self size) + 1 put: value].	^ self at: index put: value! !Object removeSelector: #atPin:!Object removeSelector: #atPin:!Object removeSelector: #atWrap:!Object removeSelector: #atWrap:!Object removeSelector: #atWrap:put:!Object removeSelector: #atWrap:put:!Path removeSelector: #atPin:!Path removeSelector: #atPin:!Path removeSelector: #atWrap:!Path removeSelector: #atWrap:!Interval removeSelector: #atPin:!Interval removeSelector: #atPin:!Interval removeSelector: #atWrap:!Interval removeSelector: #atWrap:!MappedCollection removeSelector: #atPin:!MappedCollection removeSelector: #atPin:!MappedCollection removeSelector: #atWrap:!MappedCollection removeSelector: #atWrap:!OrderedCollection removeSelector: #atPin:!OrderedCollection removeSelector: #atPin:!OrderedCollection removeSelector: #atWrap:!OrderedCollection removeSelector: #atWrap:!String removeSelector: #atPin:!String removeSelector: #atPin:!String removeSelector: #atWrap:!String removeSelector: #atWrap:!Text removeSelector: #atPin:!Text removeSelector: #atPin:!Text removeSelector: #atWrap:!Text removeSelector: #atWrap:!'From Squeak 2.2 of Sept 23, 1998 on 6 November 1998 at 4:08:22 pm'!!Collection methodsFor: 'accessing' stamp: 'TAG 11/6/1998 16:06'!anyOne	"Return a representative sample of an element, can be very helpful 	when needing to preinfer the nature of the contents of 	semi-homogeneous collections"	self do: [:each | ^ each].	^ self errorEmptyCollection! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!abs	"Absolute value of all elements in the collection"	^ self collect: [:a | a abs]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:57' prior: 17491205!average	^ self sum / self size! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!ceiling	^ self collect: [:a | a ceiling]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:51'!floor	^ self collect: [:a | a floor]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!log	^ self collect: [:each | each log]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:58' prior: 17495004!max	^ self inject: self anyOne into: [:max :each | max max: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!median	^ self asSortedCollection median! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!min	^ self inject: self anyOne into: [:min :each | min min: each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:52'!negated	"Negated value of all elements in the collection"	^ self collect: [:a | a negated]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:00'!range	^ self max - self min! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!reciprocal	"Return the reciever full of reciprocated elements"	^ self collect: [:a | a reciprocal]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!rounded	^ self collect: [:a | a rounded]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!sqrt	^ self collect: [:each | each sqrt]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:53'!squared	^ self collect: [:each | each * each]! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:02' prior: 17496106!sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample _ self anyOne.	sum _ self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 15:54'!truncated	^ self collect: [:a | a truncated]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'TAG 11/6/1998 16:06'!anyOne	^ self at: 1! !!SequenceableCollection methodsFor: 'converting' stamp: 'TAG 11/6/1998 15:55'!@ aCollection 	^ self with: aCollection collect: [:a :b | a @ b]! !Collection removeSelector: #raisedToInteger:!'From Squeak 2.2 of Sept 23, 1998 on 4 November 1998 at 7:49:12 pm'!!DataStream methodsFor: 'all' stamp: '' prior: 35570978!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes _ byteStream position.			byteStream close]		ifTrue: [bytes _ 'unknown'].	^ bytes! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/4/1998 19:47' prior: 35161070!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 11/4/1998 19:17'!isReadOnly	^ rwmode not! !SmartRefStream removeSelector: #close!'From Squeak 2.2 of Sept 23, 1998 on 9 November 1998 at 1:43:31 pm'!"Change Set:		CoercionTweaksDate:			9 November 1998Author:			Dan IngallsAdds a couple of isFoo messages to Object and removes them from Number so that coercion tests work with collections.Also adds handlers for adaptToInteger/Fraction/Float in Object that resends these as adaptToNumber.  This means you only need the one adaptToNumber method in, eg, Collection, Point, Complex or whatever."!!Object methodsFor: 'testing' stamp: 'di 11/9/1998 09:38'!isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'len 1/13/98 21:18'!isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToFloat: rcvr andSend: selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:14'!adaptToFraction: rcvr andSend: selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToInteger: rcvr andSend: selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Collection methodsFor: 'converting' stamp: 'di 11/9/1998 12:16'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:element | rcvr perform: selector with: element]! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!String methodsFor: 'converting' stamp: 'di 11/9/1998 12:17'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !Collection removeSelector: #adaptToFraction:andSend:!Collection removeSelector: #adaptToFraction:andSend:!Collection removeSelector: #adaptToFloat:andSend:!Collection removeSelector: #adaptToFloat:andSend:!Collection removeSelector: #adaptToInteger:andSend:!Collection removeSelector: #adaptToInteger:andSend:!Number removeSelector: #isFraction!Number removeSelector: #isFraction!Number removeSelector: #isInteger!Number removeSelector: #isInteger!Number removeSelector: #isFloat!Number removeSelector: #isFloat!Point removeSelector: #adaptToFraction:andSend:!Point removeSelector: #adaptToFraction:andSend:!Point removeSelector: #adaptToInteger:andSend:!Point removeSelector: #adaptToInteger:andSend:!Point removeSelector: #adaptToFloat:andSend:!Point removeSelector: #adaptToFloat:andSend:!String removeSelector: #adaptToFraction:andSend:!String removeSelector: #adaptToFraction:andSend:!String removeSelector: #adaptToInteger:andSend:!String removeSelector: #adaptToInteger:andSend:!String removeSelector: #adaptToFloat:andSend:!String removeSelector: #adaptToFloat:andSend:!'From Squeak 2.2 of Sept 23, 1998 on 9 November 1998 at 12:08:36 pm'!"Change Set:		ChangeSetMsgs-diDate:			9 November 1998Author:			Dan IngallsA number of cleanups and improved do-its resulting from isolating the function of	ChangeSorter>>changeSetsNamedSuchThat: nameBlock."!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 11/8/1998 16:36' prior: 33782456!summaryString	"Answer the string summarizing this changeSet"	| ps s2 date author line |	^ String streamContents:		[:s |		s nextPutAll: self name.		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:		'.  date _ s2 upTo: Character cr.			s2 match: 'Author:			'.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]]."To summarize all recent changeSets...(FileStream newFileNamed: 'ChangeSummaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialInteger >= 373]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);	close"! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/8/1998 16:31'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ (self allChangeSetNames		select: [:csName | nameBlock value: csName])		collect: [:csName | self changeSetNamed: csName]! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/8/1998 16:32' prior: 17354573!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | AllChangeSets remove: cs wither]! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/9/1998 10:23' prior: 33802069!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | AllChangeSets remove: cs wither].	self inform: toGo size printString, ' change set(s) removed.'! !ChangeSorter class removeSelector: #removeOldChangeSets!ChangeSorter class removeSelector: #removeOldChangeSets!'From Squeak 2.2 of Sept 23, 1998 on 9 November 1998 at 6:53:21 pm'!"Change Set:		KubwaDate:			9 November 1998Author:			Scott WallaceMajor changes to Parts Bins, Scripting Spaces, and Viewers, and a large number of lesser changes all over the map."!PasteUpMorph subclass: #IndexTabs	instanceVariableNames: 'highlightColor regularColor basicHeight basicWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!AlignmentMorph subclass: #PhraseWrapperMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'DesktopColor FlagDictionary HelpDictionary Parameters '	poolDictionaries: ''	category: 'System-Support'!Model subclass: #ScriptingDomain	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #SlotInformation	instanceVariableNames: 'type documentation '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #StandardScriptingSystem	instanceVariableNames: ''	classVariableNames: 'CustomPartsBin FormDictionary HelpStrings PartsBin ScriptHelp StandardPartsBin StandardScriptInfo StandardSlotInfo SystemSlotDictionary TypeColorDictionary '	poolDictionaries: ''	category: 'Morphic-Scripting'!SystemWindow subclass: #PartsWindow	instanceVariableNames: 'book prevButton nextButton menuButton openForEditing '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!SystemWindow subclass: #PreDebugWindow	instanceVariableNames: 'proceedButton debugButton '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!TileMorph subclass: #UndescribedTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!UpdatingStringMorph subclass: #UpdatingStringMorphWithArgument	instanceVariableNames: 'argumentTarget argumentGetSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!AlignmentMorph subclass: #Viewer	instanceVariableNames: 'scriptedPlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Viewer subclass: #CategoryViewer	instanceVariableNames: 'prevButton nextButton newButton clearButton namePane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Viewer subclass: #StandardViewer	instanceVariableNames: 'firstPanel '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!AlignmentMorph subclass: #ViewerEntry	instanceVariableNames: 'helpPane editingPane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!AlignmentMorph subclass: #ViewerRow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!Object methodsFor: 'printing' stamp: 'sw 5/2/1998 13:55' prior: 20122683!stringForReadout	^ self stringRepresentation! !!Object methodsFor: 'message handling' stamp: 'sw 10/30/1998 18:27'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ otherTarget perform: selector! !!Object methodsFor: 'user interface' stamp: 'sw 10/5/1998 14:39'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection _ self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 10/27/1998 13:53'!lookForSlips	| slips |	slips _ self checkForSlips.	slips size == 0 ifTrue:		[^ self inform: 'No slips detected in thecurrent change set.'].	(self confirm:'Some methods in the current change sethave halts or references to the Transcriptor other ''slips'' in them.Would you like to browse them?')		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ClockMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 15:36'!authoringPrototype	^ super authoringPrototype contents: Time now printString! !!Color class methodsFor: 'instance creation' stamp: 'sw 11/9/1998 19:25'!colorFrom: parm	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol, else just return the thing"	(parm isKindOf: Color) ifTrue: [^ parm].	(parm isKindOf: Symbol) ifTrue: [^ self perform: parm].	^ parm! !!Morph methodsFor: 'accessing' stamp: 'sw 11/9/1998 18:44' prior: 34657544!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ (ScriptingSystem helpStringFor: val) withNoLineLongerThan: Preferences maxBalloonHelpLineLength].	^ nil! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:28' prior: 35536706!fullDrawOn: aCanvas	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'drawing' stamp: 'sw 10/30/1998 18:27' prior: 34671591!hide	owner ifNil: [^ self].	self visible ifTrue: [self visible: false.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:29' prior: 34672841!show	"Make sure this morph is on-stage."	self visible ifFalse: [self visible: true.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'sw 10/19/1998 22:21'!visible	extension ifNil: [^ true].	^ extension visible! !!Morph methodsFor: 'drawing' stamp: 'sw 10/20/1998 00:28'!visible: aBoolean	extension ifNil: [aBoolean ifTrue: [^ self]].	self visible == aBoolean ifTrue: [^ self].	self assuredExtension visible: aBoolean.	self changed! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:00' prior: 19955278!addTransparentSpacerOfSize: aPoint	self addMorphBack: (self transparentSpacerOfSize: aPoint)! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:01'!beTransparent	self color: Color transparent! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 11:50'!transparentSpacerOfSize: aPoint	^ (Morph new extent: aPoint) color: Color transparent! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/30/1998 16:22' prior: 34679402!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow |	self isPartsDonor: false.	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	self isInWorld ifTrue:		[self world startSteppingSubmorphsOf: self]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:46' prior: 19939138!externalName	^ self knownName ifNil: [self innocuousName]! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:47' prior: 34688583!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/8/1998 17:18' prior: 34691477!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:32' prior: 34696377!setBalloonText: stringOrText	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: Preferences maxBalloonHelpLineLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:29'!setBalloonText: stringOrText maxLineLength: aLength	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: aLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:39' prior: 35852861!showBalloon: msgString	"Pop up a balloon containing the given string, first removing any existing BalloonMorphs in the world."	| w balloon worldBounds |	w _ self world.	w ifNil: [^ self].	balloon _ BalloonMorph string: msgString for: self corner: #bottomRight.	w submorphsDo: [:m |  "delete any existing balloons"		(m isKindOf: BalloonMorph) ifTrue: [m delete]].	balloon lock.  "So that if the translation below makes it overlap the receiver, it won't interfere with the rootMorphsAt: logic and hence cause flashing.  Without this, flashing happens, believe me!!"	w addMorphFront: balloon.	((worldBounds _ w bounds) containsRect: balloon bounds) ifFalse:		[balloon bounds: (balloon bounds translatedToBeWithin: worldBounds)].	self setProperty: #balloon toValue: balloon.! !!Morph methodsFor: 'player' stamp: 'sw 10/21/1998 09:30' prior: 34711783!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/22/1998 20:28'!currentPlayerDo: aBlock	"If the receiver is a viewer/scriptor associated with a current Player object, evaluate the given block against that object"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/30/1998 16:07'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: self frame: (0@0 extent: 1@1).	^ window! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 09:51'!enforceTileColorPolicy	| aPresenter |	(aPresenter _ self presenter) ifNotNil: [^ aPresenter harmonizeTileColorPolicyFor: self].	self makeAllTilesGreen "fallback - ack current preference"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 15:54'!isAViewer	^ false! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:27' prior: 34705872!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:28'!assuredExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29' prior: 34710577!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29' prior: 35537486!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu addLine.	aMenu add: 'call #tempCommand' action: #callTempCommand.	aMenu add: 'define #tempCommand' action: #defineTempCommand.	aMenu addLine.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:54'!defineTempCommand	"To use this, comment out what's below here, and substitute your own code.You will then be able to invoke it from the standard debugging menus.  If invoked from the world menu, you'll always get it invoked on behalf of the world, but if invoked from an individual morph's meta-menu, it will be invoked on behalf of that individual morph.Note that you can indeed reimplement tempCommand in an individual morph's class if you wish"	Browser openMessageBrowserForClass: Morph		selector: #tempCommand editString: nil! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:31' prior: 34706512!inspectOwnerChain	self ownerChain inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:28'!ownerChain	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	^ c asArray! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:51' prior: 19980974!tempCommand	"Generic backstop.  If you care to, you can comment out what's below here, and substitute your own code, though the intention of design of the feature is that you leave this method as it is, and instead reimplement tempCommand in the class of whatever individual morph you care to.  In any case, once you have your own #tempCommand in place, you will then be able to invoke it from the standard debugging menus."	self inform: 'Before calling tempCommand, youshould first give it a definition.  Todo this, choose "define tempCommand"from the debug menu.'! !!AlignmentMorph methodsFor: 'initialization' stamp: 'sw 10/24/1998 14:25'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder _ Morph new extent: 16 @ 16; beTransparent.	downArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/23/1998 14:18' prior: 16831171!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'accessing' stamp: 'sw 10/16/1998 22:39' prior: 17081059!currentPage	(submorphs includes: currentPage) ifFalse: [currentPage _ nil].	^ currentPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/26/1998 16:04' prior: 33662363!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil:			[newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: 'page'.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/19/1998 23:51' prior: 33663489!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/26/1998 15:41'!goto: aPlayer	self goToPageMorph: aPlayer costume! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/21/1998 23:09' prior: 33664867!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	subMenu add: 'Establish Custom Parts Bin' action: #saveAsCustomPartsBin.	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'Book...' subMenu: subMenu! !!BookMorph methodsFor: 'other' stamp: 'sw 10/1/1998 13:40'!resizePagesTo: anExtent	pages do:		[:aPage | aPage extent: anExtent]! !!BookMorph methodsFor: 'other' stamp: 'sw 10/9/1998 08:00'!wrappedInPartsWindowWithTitle: aTitle	| aWindow |	aWindow _ (PartsWindow labelled: aTitle) model: MorphicModel new.	aWindow book: self.	aWindow extent: self extent.	^ aWindow! !!ClockMorph methodsFor: 'all' stamp: 'sw 10/8/1998 17:21'!initialize	super initialize.	self contents: Time now printString! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:57' prior: 34090754!changesDo	"Build the changes menu for the world."	self changesMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 13:49'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Change management') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: ScreenController new action: #fileOutChanges.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu add: 'check for slips' target: Smalltalk changes action: #lookForSlips.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu add: 'recent change log' action: #openChangesLog.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15' prior: 34091640!debugDo	"Build the scripting menu for the world."	self debugMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15'!debugMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Debugging...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'inspect model' action: #inspectWorldModel.	menu add: 'start MessageTally' action: #startMessageTally.	menu addLine.	menu add: 'call #tempCommand' action: #callTempCommand.	menu add: 'define #tempCommand' action: #defineTempCommand.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:56' prior: 35853731!helpDo	"Build and show the help menu for the world."	self helpMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:51'!helpMenu	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'world menu help' target: self action: #worldMenuHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #absorbUpdatesFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:16'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:16' prior: 34095270!openWindow	self openMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17' prior: 34096378!remoteDo	self remoteMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17'!remoteMenu	"Build the Telemorphic menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Telemorphic') defaultTarget: self.	menu addStayUpItem.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 13:39' prior: 34096907!scriptingDo	self scriptingMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 10:48'!scriptingMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Authoring Tools') defaultTarget: self.	menu addStayUpItem.	menu add: 'standard parts bin' target: self presenter action: #createStandardPartsBin.	menu balloonTextForLastItem: 'A bin of standard parts, from which you can drag out useful morphs.'.	menu add: 'custom parts bin' target: self presenter action: #launchCustomPartsBin.	menu balloonTextForLastItem: 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'.	menu add: 'new scripting area' target: self action: #detachableScriptingSpace.	menu balloonTextForLastItem: 'A window set up for simple scripting.'.	menu add: 'control panel' target: self presenter action: #createControlPanel.	menu balloonTextForLastItem: 'A little panel that lets you choose whether or not things like the showing of balloon help should be enabled or disabled.'.	menu addLine.	menu add: 'unlock locked objects' action: #unlockWorldContents.	menu balloonTextForLastItem: 'If any items on the world desktop are currently locked, unlock them.'.	menu add: 'unhide hidden objects' action: #showHiders.	menu balloonTextForLastItem: 'If any items on the world desktop are currently hidden, make them visible.'.	menu add: 'round up stray objects' action: #roundUpStrayObjects.	menu balloonTextForLastItem: 'If any items on the desktop are currently off-screen (because their coordinates are outside the bounds of the desktop), bring them back within view.'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:18' prior: 34097861!windowsDo	"Build the windows menu for the world."	self windowsMenu popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 11:24'!windowsMenu	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Window management') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu add: 'expand all windows' action: #expandAll.	menu add: 'close unchanged windows' action: #closeUnchangedWindows.	menu add: 'delete all non-windows' action: #deleteNonWindows.	menu addLine.	menu add: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])		target: ScreenController new action: #changeWindowPolicy.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:53'!worldMenuHelp	| aList aMenu cnts explanation |	"HandMorph new worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu remoteMenu scriptingMenu windowsMenu) 		with:	#('help' 'changes' 'open' 'debug' 'remote' 'authoring tools' 'windows')do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | ((cnts _ it contents) = 'keep this menu up')					ifFalse: [aList add: (cnts, ' - ', title)]]].	aList _ aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation _ ReadWriteStream on: ''.	aList do:		[:anItem | explanation nextPutAll: anItem; cr].	(StringHolder new contents: explanation contents)		openLabel: 'Where in the world menu is...'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/18/1998 08:44'!defineTempCommand	argument		ifNotNil:			[argument defineTempCommand]		ifNil:			[self world defineTempCommand]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/6/1998 11:27'!deleteNonWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all objectsthat are not in windows?')		ifFalse: [^ self].	self world submorphs copy do:		[:m | (m isKindOf: SystemWindow) ifFalse: [m delete]]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/9/1998 08:38' prior: 34103599!detachableScriptingSpace	ScriptingSystem newScriptingSpace openInWorld: self world! !!MenuLineMorph methodsFor: 'drawing' stamp: 'sw 11/3/1998 11:35' prior: 19776752!drawOn: aCanvas	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: Preferences menuLineUpperColor.	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: Preferences menuLineLowerColor! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:25' prior: 19777806!initialize	super initialize.	self setDefaultParameters.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:19'!setDefaultParameters	self setColor: Preferences menuColor borderWidth: Preferences menuBorderWidth borderColor: Preferences menuBorderColor.	inset _ 3! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:23'!setTitleParametersFor: aMenuTitle	aMenuTitle setColor: Preferences menuTitleColor borderWidth: Preferences menuTitleBorderWidth borderColor: Preferences menuTitleBorderColor! !!MenuMorph methodsFor: 'construction' stamp: 'sw 10/9/1998 16:00' prior: 19782891!addTitle: aString	"Add a title line at the top of this menu."	| title |	title _ AlignmentMorph new.	self setTitleParametersFor: title.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	(aString asString findTokens: String cr) do:		[:line | title addMorphBack: (StringMorph new contents: line)].	self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/5/1998 21:13'!balloonTextForLastItem: balloonText	submorphs last setBalloonText: balloonText! !!MorphExtension methodsFor: 'other' stamp: 'sw 10/20/1998 00:00' prior: 34720023!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == false ifTrue: [aStream nextPutAll: '[not visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !!MorphicModel methodsFor: 'menu' stamp: 'sw 10/5/1998 14:55' prior: 20010994!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	model ifNotNil: [model addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph].	self isOpen ifTrue: [aCustomMenu add: 'close editing' action: #closeToEdits]			ifFalse: [aCustomMenu add: 'open editing' action: #openToEdits].! !!NewHandleMorph methodsFor: 'all' stamp: 'sw 11/5/1998 10:24' prior: 20060687!initialize	waitingForClickInside _ true.	super initialize.	Preferences noviceMode ifTrue: [self setBalloonText: 'stretch']! !!PaintBoxMorph class methodsFor: 'all' stamp: 'sw 10/19/1998 23:17'!flushPrototype	"Later we will be a subclass of Model, and it will have a general version of this"	Prototype _ self new! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50' prior: 20433977!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 10/21/1998 09:39' prior: 34796831!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 11/7/1998 22:36' prior: 20523552!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: self morph;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  30@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ self morph updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 10/21/1998 09:39' prior: 34797967!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self enforceTileColorPolicy. "prematurely here to avoid momentarily flashing wrong policyh"	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self beRepelling.	self enforceTileColorPolicy.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self layoutChanged.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 10/21/1998 16:44' prior: 34798422!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 11/9/1998 18:27' prior: 20527646!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 09:54'!coloredTilesEnabled	self flag: #isThisEverCalled.	^ self presenter coloredTilesEnabled! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/15/1998 15:22'!presenter	^ super presenter ifNil:		[scriptedPlayer costume presenter]! !!PartsViewer methodsFor: 'private' stamp: 'sw 11/9/1998 18:27' prior: 20530054!commandTiles	"Return a list of tiles for my scriptedPlayer's commands."	| resultType cmd m argType argTile selfTile aRow names bank  |	names _ scriptedPlayer class namedTileScriptSelectors.	bank _ self scriptsBank.	^ (scriptedPlayer typedCommandsForBank: bank) collect: [:entry |		aRow _ PartsBinMorph newRow borderWidth: 0;			color: self color.		resultType _ (entry at: 1).		cmd _ (entry at: 2).		entry size = 2			ifTrue:				[m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player.				(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]			ifFalse: 				[argType _ entry at: 3.				m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ scriptedPlayer tileForArgType: argType.				argTile position: m lastSubmorph position.				m lastSubmorph addMorph: argTile.				m markAsPartsDonor].		selfTile _ self tileForSelf.		selfTile position: m firstSubmorph position.		m firstSubmorph addMorph: selfTile.			aRow addMorph: (ScriptingSystem tryButtonFor: m).		aRow addMorphBack: (Morph new extent: 4@2; color: self color).		aRow addMorphBack: m.		aRow beSticky; openToDragNDrop: false.		aRow]	"	m addMorphFront: (Morph new color: self color; extent: 2@10). "! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/22/1998 00:13' prior: 20531397!commandTilesPartsBin	| bin |	bin _ PhraseWrapperMorph new		color: self color;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: self commandTiles.	^ bin! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/23/1998 14:12' prior: 20531732!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot]).	^ aButton! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/15/1998 17:23' prior: 34800906!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'type coercion' stamp: 'sw 11/9/1998 18:26' prior: 20538503!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel _ (retrieverType == #number)		ifTrue:		[#<]		ifFalse:		[#=].	outerPhrase _ PhraseTileMorph new setOperator: rel type: #boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase _  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #player.	getterPhrase submorphs last setSlotRefOperator: (Utilities inherentSelectorForGetter: retrieverOp).	receiverTile _ (self tileForPlayer: aPlayer) bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile _ aPlayer tileForArgType: retrieverType.	retrieverType == #number ifTrue: [finalTile addArrows].	outerPhrase submorphs last addMorph: finalTile.	^ outerPhrase! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/15/1998 18:27' prior: 35873445!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 11/6/1998 10:27' prior: 34813986!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #impartPrivatePresenter].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/28/1998 13:15'!automaticViewing: aBoolean	self setProperty: #automaticViewing toValue: aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/8/1998 16:46'!setPartsBinStatusTo: aBoolean	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ aBoolean.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m stopStepping.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/30/1998 17:24' prior: 34818473!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	self setPartsBinStatusTo: self isPartsBin not! !!IndexTabs methodsFor: 'initialization' stamp: 'sw 10/15/1998 17:12' prior: 34270281!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	basicWidth _ 200.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth	basicWidth ifNil: [basicWidth _ 200].	^ basicWidth! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth: w	basicWidth _ w! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12' prior: 34271599!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) max: self basicWidth) @ self basicHeight)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:00' prior: 20595143!brightenTiles	brightenedOnEnter _ true.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem brightColorFor: m color)]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:00'!isCommand	"Answer whether the receiver is a true line of phrase-command.  If not, it is a fragment that will not be able to serve as a line of script on its own"	| rcvrTile pad |	pad _ submorphs first.	(((pad isKindOf: TilePadMorph) ifTrue:		[(submorphs second isKindOf: AssignmentTileMorph) ifTrue: [^ true].		(rcvrTile _ pad submorphs first) isKindOf: TileMorph]) and: [rcvrTile isPossessive]) ifTrue: [^ false].	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/21/1998 09:41' prior: 20599880!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	| aPartsViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aPartsViewer _ PartsViewer new invisiblySetPlayer: aPlayer.		aPhrase _ aPartsViewer booleanPhraseFromPhrase: self.		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01' prior: 20600318!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:46' prior: 20601142!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((TileMorph new setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: argType)]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01' prior: 20601608!setSlotRefOperator: opSymbol type: opType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:48' prior: 20603010!unbrightenTiles	brightenedOnEnter ifFalse: [^ self].	brightenedOnEnter _ false.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem unbrightColorFor: m color)]]! !!PhraseWrapperMorph commentStamp: '<historical>' prior: 0!An alignment morph designed for use in scripting Viewers; it wraps a set of phrases in a category viewer, and repels attempts to drop phrases upon it.!!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 5/6/1998 18:13'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or: [aMorph hasProperty: #newAnonymousScript]! !!PhraseWrapperMorph class methodsFor: 'all' stamp: 'sw 11/9/1998 16:16'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!firstPage	self sendMessageToCostume: #firstPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!goto: aPlayer	self sendMessageToCostume: #goto: with: aPlayer! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!lastPage	self sendMessageToCostume: #lastPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!nextPage	self sendMessageToCostume: #nextPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!previousPage	self sendMessageToCostume: #previousPage! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:57' prior: 34854079!forgetOtherCostumes	costumes _ nil.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 23:18'!hasCostumeOfClass: aClass	(costume class == aClass) ifTrue: [^ true].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ true]]].	^ false! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:48' prior: 20623779!newCostume	| aMenu reply |	aMenu _ SelectionMenu selections: self availableCostumeNames.	(reply _ aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:55'!sendMessageToCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:54'!sendMessageToCostume: aSelector with: arg	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector with: arg].	^ nil! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/5/1998 19:57'!categories	| aList |	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/7/1998 22:31'!commandPhraseFor: commandSpec inViewer: aViewer	"Too lazy at the moment to do this cleanly"	| entry aRow resultType cmd m names argType argTile selfTile |	entry _ (commandSpec copy asOrderedCollection removeFirst; yourself) asArray.	names _ self class namedTileScriptSelectors.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	resultType _ (entry at: 1).	cmd _ (entry at: 2).	entry size = 2		ifTrue:			[m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player.			(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]		ifFalse: 			[argType _ entry at: 3.			m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	m markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	aRow addMorph: (ScriptingSystem tryButtonFor: m).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: m.	aRow beSticky; openToDragNDrop: false.	aRow addDetailButton.	^ aRow! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/30/1998 18:33'!phraseSpecFor: aPair	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| info prefix |	info _ (prefix _ aPair first) == #slot		ifTrue:			[ScriptingSystem slotInfoFor: aPair second]		ifFalse:			[ScriptingSystem scriptInfoFor: aPair second].	^ (Array with: prefix), info! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/21/1998 15:27'!slotPhraseFor: aSpec inViewer: aViewer	^ aViewer phraseForSlot: aSpec second type: aSpec third readOnly: aSpec fourth == #readOnly getSelector: aSpec fifth putSelector: aSpec sixth! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 16:29'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/5/1998 19:59'!tileForArgType: typeSymbol inViewer: aViewer	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 15:51'!tilePhraseSpecsForPlayerCategory: aCategory	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| aList specList toks prefix |	aList _ (Player organization listAtCategoryNamed: aCategory asSymbol) collect:		[:aSelector |			prefix _ #(script).			specList _ ScriptingSystem scriptInfoFor: aSelector.			specList ifNil:				[specList _ OrderedCollection with: #command.				toks _ aSelector keywords.				toks do:					[:aTok |						specList add: aTok.						(aTok endsWith: ':') ifTrue: [specList add: #object]]].			prefix, specList].	^ aList select: [:spec | spec size < 5]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/22/1998 20:41'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return an array of phrases, each in one of the following two formats:		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	^ (self tilePhrasesSpecsForCategory: aCategory) collect:		[:aSpec |			aSpec first == #slot				ifTrue:					[self slotPhraseFor: aSpec inViewer: aViewer]				ifFalse:					[self commandPhraseFor: aSpec inViewer: aViewer]]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/3/1998 12:10'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString |	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))].	(aCategory = 'tests') ifTrue:		[aList _ #((slot isOverColor) (slot isUnderMouse) (slot colorSees) )].	(aCategory = 'color & border') ifTrue:		[aList _ #((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ #((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]. 	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/6/1998 10:43' prior: 20629688!typeForSlot: aSlotName	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	^ ScriptingSystem typeForSystemSlotNamed: aSlotName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 10/24/1998 23:15' prior: 34861403!getAmount	^ self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15' prior: 20632332!getLeft	^ self costume left! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:33' prior: 34866371!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:36' prior: 20639784!addSlotNamedLike: suggestedName withValue: aValue	| otherNames numericSuffix nameToUse  stem itsInfo |	stem _ suggestedName first asLowercase asString , suggestedName allButFirst.	stem _ stem stemAndNumericSuffix first.	nameToUse _ stem.	otherNames _ self class allInstVarNames.	numericSuffix _ 1.	[otherNames includes: nameToUse]		whileTrue: [numericSuffix _ numericSuffix + 1. (nameToUse _ stem, numericSuffix printString)].	self class addInstVarName: nameToUse.	self instVarAt: self class instSize put: aValue.  "Assumes added as last field"	self compileAccessorsFor: nameToUse.	itsInfo _ SlotInformation new type: aValue basicType.	self slotInfo at: nameToUse asSymbol put: itsInfo.	^ nameToUse! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:41' prior: 20640701!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	typeChoices _ #(number player boolean color point string costume).	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:40'!slotInfoAt: slotName	| info |	info _ self slotInfo at: slotName ifAbsent: [nil].	info ifNil:		[self slotInfo at: slotName put: (info _ SlotInformation new)].	(info isKindOf: Symbol) "bkward compat"		ifTrue:			[self slotInfo at: slotName put: (info _ SlotInformation new type: info)].	^ info! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 11/5/1998 10:33'!sourceCodeFor: sel	^ self class sourceCodeAt: sel ifAbsent: 		[Player sourceCodeAt: sel ifAbsent: ['this space for rent']]	! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/24/1998 22:31'!tileScriptCommands	"Return a list of typed-command arrays of the form:		#script <result type> <command> <argType>"	^  self class namedTileScriptSelectors asSortedArray collect:			[:sel | Array with: #script with: #command with: sel]! !!Player methodsFor: 'misc' stamp: 'sw 11/5/1998 15:48' prior: 20659583!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors |	viewers _ OrderedCollection new.	scriptors _ OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	viewers do: [:v |  v noteDeletionOf: aMorph].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'misc' stamp: 'sw 10/26/1998 15:45' prior: 34882663!seesColor: aColor	costume isInWorld ifFalse: [^ false].	^ costume touchesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:00' prior: 34883131!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume]])		ifTrue:			[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add an empty new script' target: aViewer action: #newEmptyScript.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'misc' stamp: 'sw 10/29/1998 16:05' prior: 20661389!tileReferringToSelf	| aTile |	aTile _ TileMorph new		setObjectRef: nil "disused parm" actualObject: self;		typeColor: (ScriptingSystem colorForType: #player).	self costume presenter harmonizeTileColorPolicyFor: aTile.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:22' prior: 20662152!updateAllViewers	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter viewers all |	(aPresenter _ self costume presenter) ifNil: [^ self].	all _ self costume world allMorphs.	viewers _ all select:		[:m | (m isKindOf: PartsViewer)  and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updatePartsViewer: m].	viewers _ all select:		[:m | (m isKindOf: StandardViewer) and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updateViewer: m]! !!PreDebugWindow class methodsFor: 'all' stamp: 'sw 11/4/1998 09:20'!includeInNewMorphMenu	^ false! !!Preferences class methodsFor: 'initialization' stamp: 'sw 11/5/1998 20:59' prior: 35855771!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(logDebuggerStackToFile				true)		(noviceMode							false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showScriptSource					false)		(showTimeStampsInMenuTitles		false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 11/8/1998 18:01' prior: 35856723!initializeHelpMessages	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic, SystemWindows should automatically be droppable into willing receptors')(browseWithPrettyPrint'If true, browsers will automatically format their contents')(cautionBeforeClosing 'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts are edited in place in Scriptors (still imperfectly implemented)')(eToyScheme'If true, new scripting spaces place the Playfield to the left and the the palette to the right of the window; if false, the opposite is true.')(fastDragWindowForMorphic'If true, morphic window drag will be done by dragging an outline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(logDebuggerStackToFile'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(noviceMode 'If true, certain novice-mode accommodations are made.')(reverseWindowStagger'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')(showPlayerSource'If true, then all Player methods with fewer than 2 arguments are included in Viewers, whether or not they are intended for end-user use.  This can be dangerous')(showScriptSource'If true, then the actual Smalltalk source code for methods is shown in the detail panes for scripts in a viewer; if false, then a help message for scripts is shown instead.')(showTimeStampsInMenuTitles'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')(suppressCheckForSlips 'If false, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choice when updating code from the server is suppressed.  Set this to true to leave the server choice unchanged from update to update.')(thoroughSenders'If true, then ''senders'' browsers will dive inside structured literals in their search')(uniformWindowColors'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequence number from the filename before automatically saving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.')(useNewViewers'If true, then the new kinds of viewers introduced in Squeak 2.3 are used; if false, then the old style, from earlier releases, are still used.  Old viewers will hopefully soon be removed from the system.')(warnIfNoChangesFile'If true, then you will be warned, whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned, whenever you start up, if no sources file can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/5/1998 15:04' prior: 35469476!defaultPaintingExtent	"Answer the preferred size for the onion-skin paint area when launching a new painting within a paste-up morph.  Feel free to change the parameters to suit your configuration."	^ 400 @ 300! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 19:50'!initializeParameters	"Preferences initializeParameters"	Parameters _ IdentityDictionary new.	self restoreDefaultMenuParameters.	Parameters at: #maxBalloonHelpLineLength put: 28! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 16:49'!maxBalloonHelpLineLength	^ Parameters at: #maxBalloonHelpLineLength! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/27/1998 13:57'!viewerEditingPaneHeight	^ 42! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/5/1998 19:55' prior: 35861813!openPreferencesControlPanel	"Preferences openPreferencesControlPanel"	| aPanel aWindow aRow wrapper but aList odd aColor w width1 width2 spacer |	Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].	aPanel _ AlignmentMorph newColumn.	aPanel beSticky.	aList _ OrderedCollection new.	FlagDictionary associationsDo: [:assoc | aList add: (Array				with: assoc key				with: assoc value				with: (self helpMessageForPreference: assoc key))].	odd _ false.	width1 _ 172.	spacer _ 4.	width2 _ 14.	(aList asSortedCollection: [:a :b | a first < b first])		do: 			[:triplet | 			aPanel addMorphBack: (aRow _ AlignmentMorph newRow).			aRow color: (aColor _ odd							ifTrue: [Color green muchLighter]							ifFalse: [Color red veryMuchLighter]).			odd _ odd not.			aRow addMorph: (wrapper _ Morph new color: aColor).			wrapper setBalloonText: triplet third.			wrapper extent: width1 @ 15.			wrapper addMorph: (StringMorph new contents: triplet first).			aRow addMorphBack: (Morph new color: aColor; extent: (spacer @ 15)).			aRow addMorphBack: (wrapper _ Morph new color: aColor).			wrapper extent: width2 @ 15.			wrapper addMorphBack: (but _ UpdatingBooleanStringMorph new contents: triplet second printString).			but getSelector: triplet first;			 putSelector: #setPreference:toValue:;			 target: self].	Smalltalk isMorphic		ifTrue:			[aWindow _ SystemWindow new model: self.			aWindow addMorph: aPanel frame: (0 @ 0 extent: 1 @ 1).			aWindow setLabel: 'Preferences'.			aWindow openInWorld]		ifFalse:			[w _ WorldMorph new addMorph: aPanel.			w startSteppingSubmorphsOf: aPanel.			MorphWorldView openOn: w				label: 'Preferences'				extent: w fullBounds extent]! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuBorderColor	^ Parameters at: #menuBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuBorderWidth	^ Parameters at: #menuBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuColor	^ Parameters at: #menuColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:37'!menuLineLowerColor	^ Parameters at: #menuLineLowerColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:36'!menuLineUpperColor	^ Parameters at: #menuLineUpperColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderColor	^ Parameters at: #menuTitleBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderWidth	^ Parameters at: #menuTitleBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuTitleColor	^ Parameters at: #menuTitleColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:33'!restoreDefaultMenuParameters	"Preferences restoreDefaultMenuParameters"	"Restore the four color choices of the original implementors of MorphicMenus"	Parameters at: #menuColor put: (Color r: 0.8 g: 0.8 b: 0.8).	Parameters at: #menuBorderColor put: #raised.	Parameters at: #menuBorderWidth put: 2.	Parameters at: #menuTitleColor put: (Color r: 0.5 g: 1 b: 0.75).	Parameters at: #menuTitleBorderColor put: #inset.	Parameters at: #menuTitleBorderWidth put: 1.	Parameters at: #menuLineUpperColor put: (Color r: 0.667 g: 0.667 b: 0.667).	Parameters at: #menuLineLowerColor put: (Color r: 0.833 g: 0.833 b: 0.833).! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:38'!setAltMenuChoices	"Preferences setAltMenuChoices"	Parameters at: #menuTitleColor put: (Color r: 0.4 g: 0.8 b: 0.9).	Parameters at: #menuColor put: (Color r: 0.97 g: 0.97 b: 0.97).	Parameters at: #menuTitleBorderColor put: Color blue muchLighter.	Parameters at: #menuBorderColor put: Color blue lighter.	Parameters at: #menuLineUpperColor put: Color blue lighter.	Parameters at: #menuLineLowerColor put: (Color r: 0.97 g: 0.97 b: 0.97)! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/9/1998 13:45' prior: 20829190!addStopStepGoButtonsTo: aPasteUpMorph	| controls |	controls _ ScriptingSystem scriptControlButtons.	controls setToAdhereToEdge: #bottomLeft.	aPasteUpMorph addMorphBack: controls! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53' prior: 20829853!flushButton	"for debugging only"	| aButton |	aButton _ EllipseMorph new extent: 41@25.	aButton addMorphCentered: (StringMorph new contents: 'Flush') lock;			color: (Color r: 0.548 g: 0.935 b: 0.935);			on: #mouseUp send: #flushUp:with: to: self;			setNameTo: 'Flush';			setProperty: #scriptingControl toValue: true;			setBalloonText: 'Don''t worry, you can *never* go down the drain. Clears out the Viewer and flushes the viewer cache';			beRepelling.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53' prior: 34926342!goButton	goButton == nil  ifTrue:		[goButton _ ThreePhaseButtonMorph new.		goButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			setBalloonText:'Resume running all paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:18' prior: 20831124!newControlsButton	|  aButton aForm |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ ScriptingSystem formAtKey: 'Controls');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createControlPanel; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Controls';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to get a Control panel'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53' prior: 20831681!newPaintingButton	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'PaintBrush');		offImage: (ScriptingSystem formAtKey: 'PaintBrush'); pressedImage:  (ScriptingSystem formAtKey: 'PaintBrush').	aButton actionSelector: #dragAndDropToMakeNewDrawing; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'New Painting';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag a paintbrush into any playfield to start drawing a new player there.'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:19' prior: 20832308!newPartsBinButton	|  aButton aForm |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ ScriptingSystem formAtKey: 'PartsBin');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createStandardPartsBin; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Parts Bin';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to create a new Parts Bin'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53' prior: 34927086!stepButton	| aPosition |	stepButton ifNil:		[stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic'); pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');				arguments: (Array with: nil with: stepButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:20' prior: 34928198!stopButton	|  aPosition anExtent |	stopButton ifNil:		[stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (ScriptingSystem formAtKey: 'StopPic');			offImage: (ScriptingSystem formAtKey: 'StopPic'); pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottomLeft;			setBalloonText:'Pause all ticking scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ (associatedMorph left + 128) @ (associatedMorph bottom - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 17:27' prior: 34929193!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		( RecordingControlsMorph PianoKeyboardMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/22/1998 13:35' prior: 34929525!controlPanel	|  aPanel itsWorld |	(itsWorld _ associatedMorph world) ifNotNil:		[(aPanel _ itsWorld allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel]].	aPanel _ PasteUpMorph new extent:  128 @ 48.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/16/1998 18:47' prior: 20837522!createStandardPartsBin	associatedMorph primaryHand attachMorph: self standardPartsWindow activate! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/9/1998 13:08' prior: 34930271!customPagesForPartsBin	| aPage aWindow anotherPage pu |	aPage _ self newPageForStandardPartsBin.	aPage addMorphBack: BookMorph authoringPrototype.	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	#(TabbedPalette BasicButton JoystickMorph ClockMorph) do:		[:aName | aPage addMorphBack: (Smalltalk at: aName) authoringPrototype].	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow.	aPage addMorphBack: FileList openAsMorph.	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	anotherPage _ self newPageForStandardPartsBin.	anotherPage addMorphBack: ScriptingSystem newScriptingSpace.	anotherPage addMorphBack: ScriptingSystem scriptControlButtons.	anotherPage addMorphBack: TrashCanMorph new.	anotherPage addMorphBack: PasteUpMorph authoringPrototype.	anotherPage addMorphBack: ((pu _ PasteUpMorph newSticky) embeddedInMorphicWindowLabeled: 'assembly window').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	anotherPage replaceTallSubmorphsByThumbnails.	anotherPage fixLayout.	^ Array with: aPage with: anotherPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/23/1998 15:30'!launchCustomPartsBin	associatedMorph primaryHand attachMorph: ScriptingSystem customPartsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/16/1998 11:27' prior: 20837690!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new.	aPage color: Color white; padding: 6.	aPage autoLineLayout: true.	aPage isPartsBin: true; openToDragNDrop: false.	aPage setProperty: #alwaysShowThumbnail toValue: true.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 15:16'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook openToDragNDrop: false.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/21/1998 23:13'!standardPartsWindow	| aPartsWindow |	aPartsWindow _ ScriptingSystem newStandardPartsBin wrappedInPartsWindowWithTitle: 'Standard Parts'.	associatedMorph world addMorph: aPartsWindow.	aPartsWindow closeEditing.  "a bit redundant but gets the last details right"	^ aPartsWindow! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/21/1998 09:44' prior: 34931961!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	self harmonizeTileColorPolicyFor: aPage.	aPage fixLayout.	aPage replaceTallSubmorphsByThumbnails.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 10/16/1998 09:17' prior: 34932863!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 10/30/1998 15:36' prior: 20841159!goUp: evt with: aMorph	self startRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 10/30/1998 18:33' prior: 34935332!balloonHelpEnabled	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	^ associatedMorph world ifNotNil: [associatedMorph world balloonHelpEnabled] ifNil: [true]! !!Presenter methodsFor: 'tile support' stamp: 'sw 11/9/1998 18:48' prior: 20845221!constantTile: anObject	(anObject isKindOf: Color) ifTrue:		[^ ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)].	^ anObject newTileMorphRepresentative		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'tile support' stamp: 'sw 10/29/1998 16:06' prior: 34936158!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/22/1998 20:36' prior: 20849524!nascentPartsViewer	"EToyPlayer creates one that is sticky, here it's movable"	^ Preferences useNewViewers		ifTrue:			[StandardViewer new]		ifFalse:			[PartsViewer new]! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 14:53' prior: 20849855!updatePartsViewer: aPartsViewer	| aPlayer aPosition aNewPartsViewer oldOwner wasSticky |	aPlayer _ aPartsViewer scriptedPlayer.	aPosition _ aPartsViewer position.	wasSticky _ aPartsViewer isSticky.	aNewPartsViewer _ aPartsViewer species new visible: false.	wasSticky ifTrue: [aNewPartsViewer beSticky].	oldOwner _ aPartsViewer owner.	aPartsViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: aNewPartsViewer].	aNewPartsViewer obtainBankInfoFrom: aPartsViewer.	aNewPartsViewer setPlayer: aPlayer.	aNewPartsViewer position: aPosition.	self harmonizeTileColorPolicyFor: aNewPartsViewer.	aNewPartsViewer visible: true.	aNewPartsViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 21:14'!updateViewer: aViewer	| aPlayer aPosition newViewer oldOwner wasSticky |	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	newViewer initializeFor: aPlayer.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	aViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: newViewer].	newViewer obtainBankInfoFrom: aViewer.	newViewer position: aPosition.	self harmonizeTileColorPolicyFor: newViewer.	newViewer visible: true.	newViewer world startSteppingSubmorphsOf: newViewer.	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/21/1998 09:44' prior: 34936722!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	self harmonizeTileColorPolicyFor: aViewer.	aMorph primaryHand attachMorph: (aViewer visible: true)! !!Presenter methodsFor: 'misc' stamp: 'sw 10/30/1998 14:48'!harmonizeTileColorPolicyFor: aMorph	self coloredTilesEnabled		ifTrue:			[aMorph makeAllTilesColored]		ifFalse:			[aMorph makeAllTilesGreen]! !!Presenter methodsFor: 'misc' stamp: 'sw 10/21/1998 09:47' prior: 20852288!harmonizeTilesWithColorSetting	self harmonizeTileColorPolicyFor: self world! !!Presenter methodsFor: 'misc' stamp: 'sw 10/16/1998 18:34' prior: 34937682!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	((aMorph isKindOf: PaintInvokingMorph) and: [aMorph isPartsDonor])		ifTrue: "Ugly, I know, but we don't want automatic viewing if we're going to trigger painting"			[^ self].	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 11/5/1998 16:54' prior: 34938012!toggleButtons	| aButton  aList |	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help: If green, then when the cursor pauses over an object that has balloon help, that help balloon is shown''Sounds: If green, sounds will be  heard when appropriate; if red, sounds are suppressed.''Fence: If green, an invisible "fence" keeps your objects from straying outside their containers when their scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (ScriptingSystem formAtKey: q second);				offImage: (ScriptingSystem formAtKey: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown;				target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (ScriptingSystem formAtKey: q second) extent.			aButton].	^ aList! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMorphicProject	^ Color r: 0.935 g: 1.0 b: 0.355! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMvcProject	^ Color r: 1.0 g: 1.0 b: 0.065! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28' prior: 20869935!defaultBackgroundColor	^ (world isKindOf: WorldMorph) ifTrue: [self backgroundColorForMorphicProject] ifFalse: [self backgroundColorForMvcProject]! !!ProjectViewMorph methodsFor: 'all' stamp: 'sw 11/5/1998 14:45' prior: 20882783!drawOn: aCanvas	(project ~~ nil and: [project thumbnail ~~ lastProjectThumbnail]) ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	project ifNotNil: [project thumbnail ifNil: [image fill: (0@0 extent: image extent) rule: Form over fillColor: project defaultBackgroundColor]].	super drawOn: aCanvas.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/5/1998 21:41' prior: 35065661!durableOpenMenu 	| colorPattern |	colorPattern _ #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan lightBlue lightBlue) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/5/1998 16:17' prior: 21093849!fileOutChanges	"File out changes to a file whose name is a function of the current date and time."	Smalltalk changes fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/27/1998 14:27'!lookForSlips	Smalltalk changes lookForSlips! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 10/27/1998 14:27' prior: 35068114!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'file out changes'			'create new change set...'			'browse changed methods'			'check for slips'			'simple change sorter'			'dual change sorter'			'browse recent submissions'			'recent change log'			)		lines: #(1 5 7)		selections: #(durableChangesMenufileOutChanges newChangeSet browseChangedMessages lookForSlipsopenSimpleChangeSorter openChangeManagerbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 10/9/1998 08:05' prior: 35069733!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'simple change sorter'			'dual change sorter'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 8)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowser openSimpleChangeSorter openChangeManager"openMorphicWorld openMorphicConstructionWorld"openProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 11/3/1998 17:20' prior: 21115004!myMorph	"Answer the morph that serves as the costume of my associated player.  If for some reason I have no associated player, answer nil"	| aPlayer |	^ (aPlayer _ self playerScripted) ifNotNil: [aPlayer costume]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/21/1998 09:41' prior: 35073462!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/29/1998 16:06' prior: 21118684!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii |	hand _ self primaryHand.	(hand lastEvent redButtonPressed)		ifTrue:		[hand submorphCount > 0 ifTrue:			[insertion _ hand firstSubmorph.			insHt _ insertion height.			self removeSpaces.			i _ (ii _ self indexOfMorphAbove: insertion fullBounds topLeft)					min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty					ifTrue: [insertion]					ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))					color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]		ifFalse:		[self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)]]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 11/9/1998 18:37' prior: 21121530!buttonRowForEditor	| r aString aButtonMorph buttonFont aStatusMorph aStatus |	buttonFont _ ScriptingSystem fontForScriptorButtons.	r _ AlignmentMorph newRow color: Color transparent; inset: 0.	r addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	r addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	r addMorphBack:		(aButtonMorph _ SimpleButtonMorph new label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	r addTransparentSpacerOfSize: 6@10.	aStatus _ self scriptInstantiation status.	r addMorphBack:			(aStatusMorph _ SimpleButtonMorph new label: aStatus font: buttonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger;				setBalloonText: (ScriptingSystem helpStringFor: #chooseTrigger) maxLineLength: 65;				balloonTextSelector: #chooseTrigger).	r addTransparentSpacerOfSize: 10@10.	r addMorphBack:		((SimpleButtonMorph new label: '' font: buttonFont)			target: self;			color: Color veryLightGray;			actWhen: #buttonDown;			actionSelector: #addYesNoToHand;			balloonTextSelector: #addYesNoToHand).	r addTransparentSpacerOfSize: 12@10.	self addDismissButtonTo: r.	self updateStatusMorph: aStatusMorph.	^ r! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/22/1998 11:25' prior: 35075273!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal'		" -- run when called"				'paused' 		"ready to run all the time"		'ticking'		"run all the time"		'mouseDown'	"run when mouse goes down on me"		'mouseStillDown'	"while mouse still down"		'mouseUp'		"when mouse comes back up"		'mouseEnter'	"when mouse enters my bounds, button up"		'mouseLeave'	"when mouse exits my bounds, button up"		'mouseEnterDragging'	"when mouse enters my bounds, button down"		'mouseLeaveDragging'	"when mouse exits my bounds, button down"		'opening'	"when I am being opened"		'closing'	"when I am being closed"	"	'keyStroke'	run when user hits a key"		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 11/2/1998 14:23' prior: 35078589!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color colorFrom: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 10/5/1998 14:47'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	super addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph.  "nominally nothing"	aCustomMenu add: 'take out of window' action: #takeOutOfWindow	! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 9/30/1998 13:00'!initialExtent	^ 640 @ 480! !!ScrollPane methodsFor: 'menu' stamp: 'sw 11/5/1998 14:14'!retractable: aBoolean	retractableScrollBar == aBoolean ifFalse: [self retractableOrNot "toggles it"]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/2/1998 17:49' prior: 36028732!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu event |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		event _ self primaryHand lastEvent.		menu popUpAt: event cursorPoint event: event]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:27'!sixth	"Answer the sixth element of the receiver. Create an error notification if 	the receiver contains fewer than five elements."	^ self at: 6 ifAbsent: [self error: 'element not found']! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sw 10/22/1998 20:37' prior: 35128293!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [oldColor ifNotNil: [self color: (oldColor mixed: 1/2 with: Color white)].				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [oldColor ifNotNil: [self color: oldColor]].! !!SlotInformation commentStamp: '<historical>' prior: 0!Holds information about user-defined instance variables in Players.!!SlotInformation methodsFor: 'all' stamp: 'sw 11/9/1998 14:09'!documentation	documentation ifNil: [documentation _ 'This is an instance variable defined by you.  Please edit this into your own meaningful documentation.'].	^ documentation! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:33'!documentation: d	documentation _ d! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type	type ifNil: [type _ #number].	^ type! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type: aType	type _ aType! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:31' prior: 21511700!formAtKey: aKey	"ScriptingSystem saveForm: (TileMorph downPicture) atKey: 'downArrow'"	^ FormDictionary at: aKey ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21' prior: 21511966!inspectFormDictionary	"ScriptingSystem inspectFormDictionary"	FormDictionary inspectFormsWithLabel: 'Standard Graphics'! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21' prior: 35194461!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	FormDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:29'!saveForm: aForm atKey: aKey	FormDictionary at: aKey put: aForm! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/24/1998 14:12'!squeakyMouseForm	^ self formAtKey: 'squeakyMouse'"	ScriptingSystem saveForm: (Form	extent: 30@29	depth: 16	fromArray: #( 1811114995 1878286257 2012637171 1811180532 1811180533 1811179508 1811180532 1811179508 1744006133 1878289396 1811180533 1878289396 1744007156 1674736630 1744006132 1811114995 1811181556 1744006131 1811246068 1811180532 1811179508 1811180532 1744071668 1811113972 1811180532 1811180532 1811179507 1878288338 1945529332 1744071668 1743941620 1811112945 1811179506 1811114995 1744006131 1744006130 1744005106 1811048434 1811113969 1743939570 1811179506 1743939571 1676833782 1676765171 1811047410 1744006131 1811048435 1811116020 1811180531 1743939571 1811048435 1743939570 1743939570 1743939570 1743940594 1744005106 1811181556 1811180532 1676766196 1743939570 1878420468 1676963830 1189896082 1811245044 1744137204 1744070644 1811179508 1811113971 1743939571 1811179508 1811246070 1811309524 1811302093 1811310580 1811246068 1674867703 1744049472 1120606594 1118465013 1744137205 1811179508 1811180532 1744071667 1744006132 1811112947 1811247095 1605584589 358761132 289435638 1676830707 1741975543 1462778473 1811312631 702891724 1811310548 1945528308 1811178450 1945528307 1878288372 1878353875 1878421494 1051471335 1809213397 1118524175 1811246068 1945659348 1185698607 1878486005 1672694510 1118531574 1607626741 1878420467 1811180533 1743942645 1744072693 1811301035 1185770487 1878486006 1324239597 1811180533 1811116019 1120623438 1878352818 1945462739 704868339 1878289395 1811049459 1878221808 1878223859 1743876083 1811162563 1945463796 1811181556 1464746666 1811116018 1809019893 1120551562 1945464821 1741844468 1466842760 1878289395 1811048434 1811050483 1811050483 1878223859 1049188174 1741910004 1811181556 1256998634 1811114994 1878289396 1466840647 1744007156 1744006131 1676877216 1743940596 1878222835 1743938545 1878351792 1676833781 358641652 1743940596 1811050484 845566798 1811113970 1811114995 1811163652 1811112913 1878420468 1878282028 1811179506 1607560178 1878289395 1676900342 1878351825 1466853330 1811113971 1811116019 635659217 1811179506 1811245045 1676942754 1744137206 1744201717 1676962806 1676962805 1811310581 1676896245 1744199635 1811376117 1744072695 1744005109 1811244019 499279861 1811310581 1811244020 1811293668 1399943159 1605528567 1744136181 982063522 986342388 1744070645 1744189066 430063308 1744071669 1744070644 1744067504 566519797 1744136181 1744137205 1743999854 912813044 1811311606 1742162607 4195488 283139922 1945531382 1253113857 144710948 1601400791 1811246069 1811167879 1464821747 1744136180 1674799094 1811178482 843473875 1811311606 1878533542 2106790 2080066222 1876193270 696845376 627472380 1185772536 1878355957 1743990309 1744007157 1676898294 1744006132 1811114996 1743941620 1811180533 1809204941 4194368 4217681 1878290421 1252982848 4194336 1670540278 1739811795 1878353906 1744006131 1811179506 1744007157 1744005106 1945462771 1811182582 1811311574 1393641133 1462856629 2012638196 1876382449 1112301394 1742041045 1945596917 1676833781 1811113970 1811179507 1811180532 1672705014 1674735606 1672697648 1945725943 1878551479 1809215479 1811312629 1809216504 1809215479 1809215478 1462853490 1878487029 1744007158 1744005075 1811239726 704979363 495004132 700789287 562372997 631646663 1739998892 4194400 1116497846 698688932 562375109 770124262 633609569 495070758 1257010166 562315916 1809279958 2012894002 1047280171 980237901 910966381 1668677696 4194400 6314867 1047281260 908804749 910968495 1393719290 1809279959 1185750370 1809214455 1878469062 423836236 1532188466 1601592148 1462986647 1672937568 4194368 6319062 1603622706 1601525554 1601522417 1047336194 770206679 1878487031 1878409899 977955830 1809145716 1118586509 980105834 980045584 1811372914 980104778 1605526483 1395605131 910769804 1118651052 1534358520 1809136234 1118596053 1532059506 1878485973 1326456163 1945660374 1742106615 1811311607 1945725942 1742107641 1744072693 1811311605 1744203767 1878551543 564478604 1878553591 1603428242 1811048433 1811049459 1051290611 1744006131 1811049459 1878156273 1743874034 1744007156 1743874033 1811048434 1811113970 1743939571 1743933228 1603301363 1743875059 1811049458 1945461745 1811181556 1811113971 1811049458 1811048434 1811116020 1878287346 1878223857 1743940594 1744006130 1744007157 1945395153 1945400309 1811048434 1743810547 1676765170 1878353906 1811113970 1743874032 1810983921 1743874033 1811113971 1676765169 1743874034 1743940593 1743939569 1811047409 1676765168 1743940595 1810981872 1945397235 1607560179 1743941620 1810982897 1810983921 1811048433 1744007155 1743875059 1811048434 1743875058 1743939568 1676832754 1811116019 1811114994 1811244019 1676962805 1677029367 1811244020 1744005106 1743940594 1811246068 1744070645 1676961781 1744004084 1676897269 1811180533 1878353908 1744004083 1744070645)	offset: 0@0) atKey: 'squeakyMouse'"! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 13:50' prior: 35836738!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object is facing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upward from the bottom of the container')(colorUnder		color'The color under the center of the object')(penDown		boolean'Whether the object''s pen is down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in the object is over another given color')(isOverColor		boolean'Whether any part of this object is directly over the specified color')(isUnderMouse	boolean'Whether any part of this object is beneath the current mouse-cursor position')(scaleFactor		number'The amount by which the object is scaled')(width			number'The distance between the left and right edges of the object')(height			number'The distance between the top and bottom edges of the object')(isOverColor		color'Whether any part of the object is over a given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate of the mouse pointer')(mouseY		number'The y coordinate of the mouse pointer')(left		number'My left edge, measured from the left edge of the World')(right		number'My right edge, measured from the left edge of the world')(top		number'My top edge, measured downward from the top edge of the world')(bottom		number'My bottom edge, measured downward from the top edge of the world')(tryMe			command'Click here to run this script once; hold button down to run repeatedly.')(try			command'Run this command once.')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')(chooseTrigger	command'when this script should be run	normal -- run when called	paused -- ready to run all the time	ticking -- run all the time	mouseDown -- run when mouse goes down on me	mouseStillDown -- while mouse still down	mouseUp -- when mouse comes back up	mouseEnter -- when mouse enters my bounds, button up	mouseLeave -- when mouse exits my bounds, button up	mouseEnterDragging -- when mouse enters my bounds, button down	mouseLeaveDragging -- when mouse exits my bounds, button down	opening -- when I am being opened	closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)(offerScriptorMenu	command'Press here to get a menu of options for this Scriptor')(objectNameInHalo  control'Object''s name -- To change: click here; backspace over old name, type in new name; hit ENTER')(userSlot		control'This is an instance variable defined by you.  Click here to change its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:53'!initializeScriptHelp" | helpDict |	helpDict _ IdentityDictionary new.	#(	(aTest 'testing one two three') 	(acceptScript:for: 'submit the contents of the given script editor as the code defining the given selector')	(actorState 'return the ActorState object for the receiver, creating it if necessary')	(addInstanceVariable 'start the interaction for adding a new instance variable to the receiver')	(addPlayerMenuItemsTo:hand: 'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')	(addSlotNamedLike:withValue: 'add a slot with a unique name derived from the first parameter, giving it the second parameter as its initial value')	(allScriptEditors 'answer a list off the extant ScriptEditors for the receiver')	(anonymousScriptEditorFor: 'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')	(assignDecrGetter:setter:amt: 'evaluate the decrement variant of assignment')	(assignGetter:setter:amt: 'evaluate the vanilla variant of assignment')	(assignIncrGetter:setter:amt: 'evalute the increment version of assignment')	(assignMultGetter:setter:amt: 'evaluate the multiplicative version of assignment')	(assureEventHandlerRepresentsStatus 'make certain that the event handler associated with my current costume is set up to conform to my current script-status')	(assureExternalName 'if I do not currently have an external name assigned, get one now')	(assureUniClass 'make certain that I am a member a uniclass (i.e. a unique Player subclass); if I am not, create one now and become me into an instance of it')	(availableCostumeNames 'answer a list of strings representing the names of all costumes currently available for me')	(availableCostumesForArrows 'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')	(beep: 'make the requested sound')	(bounce: 'if I have just run into a boundary, bounce off of it, making the stated sound')	(clearTurtleTrails 'erase all the pen trails within me')	(deleteCard 'delete the current card')	(firstPage 'make the first page of this book be the current one')	(forward: 'move forward by the specified amount')	(goto: 'make the given page be seen as my current page')	(goToNextCard 'make the next card within me be the currently-visible one')	(goToPreviousCard 'make the previous card within me be the currently-visible one')	(goToRightOf: 'move me until I lie directly to the right of the other object.')	(hide 'make me be invisible')	(initiatePainting 'let the user start painting a new object with me')	(lastPage 'make the last page of this book be the current one')	(liftAllPens 'lift the pens of all the objects within me')	(lowerAllPens 'lower the pens of all the objects within me')	(moveToward: 'move toward another object')	(newCard 'create a new card and make it my currently-visible one')	(nextPage 'go to the next page following the current one')	(pauseScript: 'make the specified script become paused')	(previousPage 'go to the page preceding the current one.')	(show 'make me be visible (if I was formerly hidden')	(startScript: 'make the specified script start ticking')	(stopScript: 'make the specified script stop running')	(turn: 'turn by the specified amount')	(wearCostumeOf: 'wear a costume resembling that of another player')	(wrap 'if I have just run into a boundary, reappear at the corresponding point on the opposite side')	 		) do: [:pair | helpDict at: pair first put: pair second].	ScriptingSystem scriptHelp: helpDict"	| aDoIt |	aDoIt _ StandardScriptingSystem firstCommentAt: #initializeScriptHelp.	Compiler evaluate: aDoIt"ScriptingSystem initializeScriptHelp""(     basicType beNotZero:   categories changeScript:toStatus: changeVariableType checkCostume choosePenColor: choosePenSize chooseSlotTypeFor: chooseUserSlot color color:sees: colorUnder commandPhraseFor:inViewer: compileAccessorsFor: compileInstVarAccessorsFor: convertdc0:dcc0: copyStateFrom: copyUniClass costume costume: costumeRespondingTo: costumeSlotNamesAndTypesForBank: costumes costumesDo: createNewCard defaultLabelForInspector defaultPenColor defaultPenSize  dummy externalName  forgetOtherCostumes  getAmount getAngle getBorderColor getBorderWidth getBottom getColor getColorUnder getCursor getHeading getHeadingUnrounded getHeight getInfo getIsUnderMouse getLeft getLeftRight getMouseX getMouseY getName getPenColor getPenDown getPenSize getRight getRotationStyle getScaleFactor getSpeed getTop getUpDown getValueAtCursor getValueFromCostume: getWidth getX getY     grabPlayerIn: hasCostumeOfClass: hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: headDown headLeft headRight headUp  infoFor: initialTypeForSlotNamed: initialValueForSlotOfType: initializeCostumesFrom: initiatePainting instantiatedUserScriptsDo: isFlagshipForClass justClonedFrom: knownSketchCostumeWithSameFormAs: lastEvent   liftPen  lowerPen makeBounceSound: maxPartsBankNumber maxScriptsBankNumber   newCostume  noteDeletionOf:fromWorld: okayToDestroyScriptNamed: okayToRemoveSlotNamed: owningPlayer  penColor: personalSlotNamesAndTypesForBank: phraseSpecFor: presenter  printOn: rawCostume: rememberCostume: removeSlotNamed: renameSlot: renameTo: renderedCostume: renderedCostumeRespondsTo: revealPlayerIn: revertToUnscriptedPlayerIfAppropriate runAllClosingScripts runAllOpeningScripts runAllTickingScripts scriptEditorFor: scriptEvaluatorFor:phrase: scriptInstantiationForSelector: scriptPerformer seesColor: sendMessageToCostume: sendMessageToCostume:with: setBorderColor: setBorderWidth: setBottom: setColor: setCostume: setCostumeSlot:toValue: setCursor: setHeading: setHeight: setLeft: setName: setPenColor: setPenDown: setPenSize: setRight: setRotationStyle: setScaleFactor: setTop: setValueAtCursor: setWidth: setX: setY:  slotInfo slotNames slotNamesAndTypesForViewerBank: slotPhraseFor:inViewer: standardCommandsForBank: standardSlotsForBank: standardWorldSlotsForBank: startRunning startRunningScripts  step stopProgramatically stopRunning  tearOffFancyWatcherFor: tearOffTileForSelf tearOffWatcherFor: thumbnailMenuEvt:forMorph: tileForArgType: tileForArgType:inViewer: tilePhraseSpecsForPlayerCategory: tilePhrasesForCategory:inViewer: tilePhrasesSpecsForCategory: tileReferringToSelf tileScriptCommands tileScriptCommandsForBank:  typeForSlot: typedCommandsForBank: unusedScriptName updateAllViewers valueOfType:from:  wearCostumeOfClass: wearCostumeOfName: wearSketchCostumeResembling: width  "! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/6/1998 17:24'!scriptHelp: aDictionary	ScriptHelp _ aDictionary.	Transcript cr; show: 'script help loaded; ', aDictionary size printString, ' entries.'! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:28'!scriptHelpFor: aSelector	| help |	help _ self scriptHelpOrNilFor: aSelector.	help ifNotNil: [^ help].	^ HelpStrings at: aSelector ifAbsent: ['sorry, no description yet provided for ', aSelector]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:27'!scriptHelpOrNilFor: aSelector	^ ScriptHelp at: aSelector ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 11/8/1998 18:02'!newScriptingSpace	"Answer a complete scripting space"	| aTemplate  palette aPlayfield aWindow |	aWindow _ (SystemWindow labelled: 'scripting area') model: ScriptingDomain new.	aWindow extent: 640 @ 480.	aTemplate _ PasteUpMorph new setNameTo: 'etoy'.	aTemplate extent: 638 @ 470.	aWindow addMorph: aTemplate frame: (0@0 corner: 1@1).	aTemplate setStandardTexture.	aTemplate impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky.	palette _ TabbedPalette new pageSize: 200@320.	palette beSticky.	aTemplate addMorph: palette.	palette addMenuTab.	palette addPartsTab.	palette addControlsTab.	palette addScrapsTab.	"palette addViewerTab."	aPlayfield _ PasteUpMorph new setNameTo: 'playfield'.	(Preferences valueOfFlag: #eToyScheme)  "Not widely advertised"		ifFalse:				[aPlayfield setToAdhereToEdge: #topRight.			palette setToAdhereToEdge: #topLeft]		ifTrue:			[aPlayfield setToAdhereToEdge: #topLeft.			palette setToAdhereToEdge: #topRight].	aTemplate addMorph: aPlayfield.	aPlayfield extent: 340@300; position: aTemplate topRight - (400@0).	aPlayfield beSticky.	aPlayfield automaticViewing: true.	aPlayfield wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aWindow! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/16/1998 09:22' prior: 35200939!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	|  replacement |	replacement _ FormDictionary at: 'Gets'.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | FormDictionary at: aKey put: replacement]! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/23/1998 15:34'!customPartsBin	CustomPartsBin ifNil: [self initializeCustomPartsBin].	^ CustomPartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/23/1998 15:28'!initializeCustomPartsBin	"ScriptingSystem initializeCustomPartsBin"	CustomPartsBin _ Presenter new standardPartsWindow! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/21/1998 23:14'!newStandardPartsBin	"StandardPartsBin _ nil"	StandardPartsBin ifNil:		[StandardPartsBin _ Presenter new newStandardPartsBinTitled: 'objects' includeControls: false].	^ StandardPartsBin fullCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/27/1998 13:35'!resetStandardPartsBin	"ScriptingSystem resetStandardPartsBin"	StandardPartsBin _ nil! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/21/1998 23:08'!setCustomPartsBinFrom: aMorph	CustomPartsBin _ aMorph! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/26/1998 15:41'!initStandardScriptInfo	"ScriptingSystem initStandardScriptInfo"	StandardScriptInfo _ Dictionary new.	#(	(command beep: sound)		(command stopScript: string)		(command pauseScript: string)		(command startScript: string)		(command initiatePainting)		(command forward: number)		(command turn: number)		(command wearCostumeOf: player)		(command moveToward: player)		(command beep: sound)		(command show)		(command hide)		(command bounce: sound)		(command wrap)		(command goToRightOf: player)		(command stopScript: string)		(command pauseScript: string)		(command startScript: string)		(command liftAllPens)		(command lowerAllPens)		(command clearTurtleTrails)		(command goToNextCard)		(command goToPreviousCard)		(command newCard)		(command deleteCard)		(command initiatePainting)		(command nextPage)		(command previousPage)		(command firstPage)		(command lastPage)		(command goto: player ))	do:		[:anArray | StandardScriptInfo at: anArray second put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:52'!initStandardSlotInfo	"ScriptingSystem initStandardSlotInfo"	StandardSlotInfo _ Dictionary new.	#((color			color		readWrite	getColor				setColor:)	(borderWidth 	number		readWrite	getBorderWidth	setBorderWidth:)	(borderColor		color		readWrite	getBorderColor	setBorderColor:)		(leftRight	number		readOnly	getLeftRight				unused)		(upDown	number		readOnly	getUpDown				unused)		(angle		number		readOnly	getAngle				unused)		(amount	number		readOnly	getAmount				unused)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused)		(rotationStyle	rotationStyle									readWrite	getRotationStyle		setRotationStyle:)		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused)		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:)		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:))	do:		[:anArray | StandardSlotInfo at: anArray first put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:51'!scriptInfoFor: aSlotName	^ StandardScriptInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:53'!slotInfoFor: aSlotName	^ StandardSlotInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/5/1998 16:54'!goButton	| aButton |	aButton _  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setBalloonText:'Resume running all paused scripts'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:31'!goUp: evt with: aMorph	aMorph presenter startRunningScripts! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:59'!mouseUpBalk: evt! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 16:09'!scriptControlButtons	"World primaryHand attachMorph: ScriptingSystem scriptControlButtons"	| wrapper |	wrapper _ AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/5/1998 16:55'!stepButton	| aButton |	aButton _ ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:33'!stepDown: evt with: aMorph	aMorph presenter stopRunningScripts! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepStillDown: dummy with: theButton	theButton presenter stepStillDown: dummy with: theButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepUp: evt with: aMorph	aMorph presenter stepUp: evt with: aMorph! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:50'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Pause all ticking scripts.'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:32'!stopUp: dummy with: theButton	| aPresenter |	(aPresenter _ theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScripts! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:30'!brightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 1) = aColor ifTrue: [^ (pair at: 2)]].	^ aColor! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 15:58'!colorForType: typeSymbol	^ (TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 1! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:18'!colorFudge	^ 0.4! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:49'!initializeTypeColors	"ScriptingSystem initializeTypeColors"	TypeColorDictionary _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(object			(1.0 0.26 0.98)		(1.0 0.26 0.98))   		(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | TypeColorDictionary at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:01'!unbrightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 2) = aColor ifTrue: [^ (pair at: 1)]].	^ aColor! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 10/22/1998 10:32' prior: 35840623!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	Smalltalk at: #ScriptingSystem put: (self new initializeSystemSlotDictionary; initializeHelpStrings; yourself).	ScriptingSystem initStandardSlotInfo! !!EToySystem class methodsFor: 'development support' stamp: 'sw 10/16/1998 09:31' prior: 18502523!stripMethodsForExternalRelease	"EToySystem stripMethodsForExternalRelease"	Utilities stripMethods: self methodsToStripForExternalRelease messageCode: '2.3External'! !!EToySystem class methodsFor: 'external release' stamp: 'sw 10/16/1998 09:30' prior: 33914078!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		serverUrls)		(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!String methodsFor: 'converting' stamp: 'sw 11/5/1998 19:47'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'testing' stamp: 'sw 11/5/1998 17:41'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!StringButtonMorph methodsFor: 'events' stamp: 'sw 10/23/1998 15:57' prior: 21639046!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue:			[self color: (oldColor mixed: 1/2 with: Color white).			actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:37' prior: 35231056!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	(self embeddedInMorphicWindowLabeled: labelString) openInWorld! !!Browser methodsFor: 'initialize-release' stamp: 'sw 11/2/1998 13:32' prior: 17132160!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #editComment.	commentSwitch		label: '?' asText allBold asParagraph;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	^ row! !!Debugger methodsFor: 'initialize' stamp: 'sw 10/15/1998 12:59' prior: 33863035!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (PreDebugWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!SystemWindow methodsFor: 'initialization' stamp: 'sw 11/5/1998 10:26' prior: 35989202!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	Preferences noviceMode ifTrue:		[closeBox setBalloonText: 'close window'.		collapseBox 	setBalloonText: 'collapse/expand window'].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabel to: self.	self extent: 300@200! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 11/2/1998 14:23' prior: 35990425!extent: newExtent	| inner labelRect paneColor |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	paneColor _ Color colorFrom: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'panes' stamp: 'sw 11/2/1998 14:23' prior: 21855000!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		color: (Color colorFrom: model defaultBackgroundColor);		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'sw 11/2/1998 14:23' prior: 21855497!paneColor	^ Color colorFrom: model defaultBackgroundColor! !!SystemWindow methodsFor: 'menu' stamp: 'sw 10/5/1998 14:56'!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size == 1 ifFalse: [^ self beep].	aMorph _ paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 16:41'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'parts window controls...' action: #invokePartsWindowMenu! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:48'!adjustBookControls	| inner |	prevButton ifNil: [^ self].	prevButton align: prevButton topLeft with: (inner _ self innerBounds) topLeft + (20@0).	nextButton align: nextButton topRight with: inner topRight - (20@0).	menuButton align: menuButton topLeft with: inner topLeft + (40@5).! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/1/1998 10:10'!book: aBook	book _ aBook.	self addMorph: aBook frame: (0@0 extent: 1@1).	book beSticky.	book hResizing: #none; vResizing: #none.	nextButton target: aBook.	prevButton target: aBook! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!closeEditing	openForEditing _ false.	self color: Color white.	book pages do:		[:aPage | aPage setPartsBinStatusTo: true]! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:44'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!initialize	| aFont aForm |	super initialize.	color _ Color white.	openForEditing _ false.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (prevButton _ SimpleButtonMorph new borderWidth: 0;			label: '<' font: aFont; color: Color transparent;			setBalloonText: 'previous page';			actionSelector: #previousPage; target: self; extent: 16@16).	self addMorph: (nextButton _ SimpleButtonMorph new borderWidth: 0;			label: '>' font: aFont; color: Color transparent;			setBalloonText: 'next page';			actionSelector: #nextPage; target: self; extent: 16@16).	menuButton _ ThreePhaseButtonMorph new onImage: (aForm _ ScriptingSystem formAtKey: 'OfferToUnlock'); offImage: (ScriptingSystem formAtKey: 'OfferToLock'); pressedImage: (ScriptingSystem formAtKey: 'OfferToLock'); extent: aForm extent; state: #on.	menuButton target: self; actionSelector: #toggleStatus; actWhen: #buttonUp.	menuButton setBalloonText: 'open for editing'.	self addMorph: menuButton."	self addMorph: (menuButton _ SimpleButtonMorph new borderWidth: 0;			label: '' font: aFont; color: Color transparent;			actWhen: #buttonDown;			actionSelector: #invokePartsWindowMenu; target: self; extent: 16@16)."	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 17:35'!invokePartsWindowMenu	| aMenu sel |	aMenu _ MVCMenuMorph new.	openForEditing		ifTrue:			[aMenu add: 'resume being a parts bin' action:	#toggleStatus]		ifFalse:			[aMenu add: 'open for editing'			action:	#toggleStatus].	aMenu add: 'sort pages'	action: #sortPages.	aMenu add: 'save as Custom Parts Bin' action: #saveAsCustomPartsBin.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!openEditing	openForEditing _ true.	self color: Color green.	book pages do:		[:aPage | aPage setPartsBinStatusTo: false]! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 17:37'!saveAsCustomPartsBin	| aBin |	self closeEditing.	aBin _ self veryDeepCopy.	ScriptingSystem setCustomPartsBinFrom: aBin.	self inform: 'Okay; from now on, when you request''custom parts bin'' from the ''authoring tools...''menu, you will obtain a copy of this parts bin'! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:57'!setBoundsOfPaneMorphs	| panelRect bookBorder bookExtent |	panelRect _ self panelRect.	book ifNotNil:		[book bounds: ((panelRect origin + (bookBorder _ book borderWidth asPoint)) 			extent: (bookExtent _ panelRect extent - (2 * bookBorder))).		book resizePagesTo: (bookExtent - (7 @ 7))]! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:12'!sortPages	book sortPages! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!toggleStatus	openForEditing _ openForEditing not.	openForEditing		ifTrue:			[self openEditing.			menuButton state: #off.			menuButton setBalloonText: 'resume being a parts bin']		ifFalse:			[self closeEditing.			menuButton state: #on.			menuButton setBalloonText: 'open for editing']! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 14:23'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	debugButton align: debugButton topRight with: inner topRight - (16@4).! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!debug	model debug! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 09:50'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 14:15'!initialize	| aFont proceedLabel debugLabel |	super initialize.	labelString size > 45 ifTrue: [^ self].   "No proceed/debug buttons if label too long"	labelString size > 25		ifTrue:			[proceedLabel _ 'p'.			debugLabel _ 'd']		ifFalse:			[proceedLabel _ 'proceed'.			debugLabel _ 'debug'].	aFont _ Preferences fontForScriptorButtons.	self addMorph: (proceedButton _ SimpleButtonMorph new borderWidth: 0;			label: proceedLabel font: aFont; color: Color transparent;			actionSelector: #proceed; target: self).	proceedButton setBalloonText: 'continue execution'.	self addMorph: (debugButton _ SimpleButtonMorph new borderWidth: 0;			label: debugLabel font: aFont; color: Color transparent;			actionSelector: #debug; target: self).	debugButton setBalloonText: 'bring up a debugger'.	proceedButton submorphs first color: Color blue.	debugButton submorphs first color: Color red.	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!proceed	model proceed! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 10/29/1998 17:35'!addTabForBook: aBook withBalloonText: text	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	text ifNotNil: [aTab setBalloonText: text].	^ aTab! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:37'!addControlsTab	| controlWrapper controlPage |	controlPage _ AlignmentMorph newColumn beSticky color: Color white.	controlWrapper _ AlignmentMorph newRow beSticky vResizing: #spaceFill; color: Color white.	controlWrapper centering: #center.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlWrapper addMorphBack: self presenter controlPanel beSticky.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlPage addMorphBack: controlWrapper.	controlPage addMorphBack: (Morph new beTransparent extent: (1 @ 10)).	controlPage addMorphBack: RecordingControlsMorph newSticky.	controlPage setNameTo: 'Controls'.	self addTabForBook: controlPage  withBalloonText:'recording controls, andcontrols to turn sound,balloon help, etc., on and off'! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:39'!addPartsTab	| partsBook aPage |	partsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Supplies'.	partsBook removeEverything.	aPage _ self presenter newPageForStandardPartsBin.	aPage extent: pageSize.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph   StringMorph) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	partsBook insertPage: aPage pageSize: pageSize.	self addTabForBook: partsBook withBalloonText: 'parts bin'! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 11/7/1998 22:49' prior: 35306272!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Scraps'.	scrapsBook removeEverything; showPageControls; insertPage.	scrapsBook currentPage addMorph: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook  withBalloonText: 'a storage place for anything; also, objects dragged into the trash can will be found here.'.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 11/7/1998 22:53' prior: 35307605!addViewerTab	| viewerBook |	"A now disused branch, though it may be invoked in some grandfathered palettes"	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/30/1998 18:35'!oldViewMorph: aMorph	"View the morph using the old type of viewer."	| aPlayer currentViewer viewerBook |	self hasViewerTab ifFalse:		[self addViewerTab].	self visible: false.	aPlayer _ aMorph assuredPlayer.	viewerBook _ self viewerBook.  "Just to make this code easier to read"	(currentViewer _ viewerBook currentPage)		ifNil:			[currentViewer _ viewerBook setPlayer: aPlayer]		ifNotNil:			[currentViewer scriptedPlayer == aPlayer				ifFalse:					[currentViewer setPlayer: aPlayer]				ifTrue:					[currentViewer isInWorld ifFalse: [self halt]]].	"currentViewer makeAllTilesGreen. "  "yecch; overkill"	 "This stuff is generally still weird and objectionable, but since the PartsViewer path is being abandoned, to hell with it. "	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self selectViewerTab.	self snapToEdgeIfAppropriate.	self visible: true.	currentViewer visible: true"	self layoutChanged.	self ownerChanged.	self world displayWorld"! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:45' prior: 35308024!selectViewerTab	| viewerTab |	(viewerTab _ self viewerTab) ifNil: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/25/1998 22:37' prior: 35308266!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer |	Preferences useNewViewers ifFalse: [^ self oldViewMorph: aMorph].	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	self visible: false.	aPlayer _ aMorph assuredPlayer.	aViewer _  StandardViewer new initializeFor: aPlayer.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage _ aViewer).	self snapToEdgeIfAppropriate..	self world startSteppingSubmorphsOf: aViewer.	self visible: true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:44'!viewerTab	^ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [nil]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/7/1998 22:50' prior: 35309188!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		setBalloonText: 'menu';		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/7/1998 22:53' prior: 35309942!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette ifNotNil:		[aMenu add:  'clear' action: #showNoPalette.		aMenu addLine].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 10/15/1998 15:51' prior: 35311383!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	"self snapToEdgeIfAppropriate"! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/19/1998 23:53' prior: 35311987!selectTab: aTab	| currentPalette |	(currentPage notNil and: [(currentPage hasProperty: #placeHolder) not]) ifTrue:		[self currentPalette currentPlayerDo:			[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate.! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 10/19/1998 23:50' prior: 35313764!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	self visible ifFalse: [^ self].	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 10/16/1998 11:30' prior: 35314464!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 200 @ 300.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'sw 10/18/1998 10:17'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	morph tempCommand.	^ true! !!TextMorphForEditView methodsFor: 'debugging' stamp: 'sw 11/2/1998 15:51'!tempCommand	"Smalltalk browseAllImplementorsOf: #tempCommand"	"Place your definition for tempCommand for this class here"! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/6/1998 11:02'!associatedPlayer	^ actualObject! !!TileMorph methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:55' prior: 22093466!playerBearingCode	"Answer the actual Player object who will be the 'self' when the receiver is being asked to generate code"	| anEditor |	(anEditor _ self topEditor) ifNotNil: [^ anEditor playerScripted].	^ (self nearestOwnerThat: [:m | m isAViewer]) scriptedPlayer! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/9/1998 14:18' prior: 22094039!slotName	"Caution: the slotName is not in use!!"	^ slotName! !!TileMorph methodsFor: 'arrows' stamp: 'sw 10/21/1998 09:45' prior: 35336015!showSuffixChoices	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: literal 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter harmonizeTileColorPolicyFor: (phrase topEditor ifNil: [phrase])! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 10/25/1998 00:25'!colorSwatch	^ colorSwatch! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:06' prior: 34961696!initialize	| m1 m2 |	super initialize.	self typeColor: (ScriptingSystem colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:07' prior: 22110147!mouseEnter: evt	"Show drag/drop feedback."	| h m |	h _ evt hand.	h submorphCount ~= 1 ifTrue: [^ self].	m _ h firstSubmorph.	(self canAccept: m) ifTrue:		[self color: (ScriptingSystem brightColorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem brightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08' prior: 22110559!mouseLeave: evt	"Clear drag/drop feedback."	color ~= (ScriptingSystem colorForType: type) ifTrue:		[self color: (ScriptingSystem colorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem unbrightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08' prior: 22111302!rootForGrabOf: aMorph	"Allow submorph to be extracted."	| root |true ifTrue: [^ super rootForGrabOf: aMorph].	self inPartsBin ifTrue: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[root color: (ScriptingSystem colorForType: root resultType).			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08' prior: 22111740!setType: aSymbol	type _ aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (TileMorph defaultW)@(TileMorph defaultH).! !!TrashCanMorph methodsFor: 'initialization' stamp: 'sw 11/5/1998 16:55' prior: 35350401!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'To remove an object, drop it on this trash can.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 10/30/1998 15:57' prior: 22145501!handlesMouseDown: evt	^ self inPartsBin not! !!UndefinedObject methodsFor: 'printing' stamp: 'sw 10/29/1998 16:34'!newTileMorphRepresentative	^ UndescribedTile new! !!UndescribedTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:45'!initialize	super initialize.	self extent: (20 @ 22)! !!UpdatingRectangleMorph methodsFor: 'display' stamp: 'sw 10/24/1998 21:23'!drawOn: aCanvas 	"Copied down from BorderedMorph, with the substitution that the color inst var of the receiver here might well be something like #raised or some other symbol, which the frameAndFillRectangle... methods barf on."	| insetColor colorToFill |	colorToFill _ (color isKindOf: Color) ifTrue: [color] ifFalse: [Color gray].	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue:		[^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: colorToFill lighter			bottomRightColor: colorToFill darker].	borderColor == #inset ifTrue:		[insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: colorToFill		borderWidth: borderWidth		borderColor: borderColor.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:53'!acceptValueFromTarget: v	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:56' prior: 35842081!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target scriptPerformer perform: getSelector.	^ self acceptValueFromTarget: v! !!UpdatingStringMorphWithArgument methodsFor: 'as yet unclassified' stamp: 'sw 10/25/1998 00:57'!readFromTarget	| v |	argumentTarget ifNil: [^ super readFromTarget].	v _ target perform: getSelector with: (argumentTarget perform: argumentGetSelector).	^ self acceptValueFromTarget: v! !!UpdatingStringMorphWithArgument methodsFor: 'all' stamp: 'sw 10/25/1998 00:20'!argumentTarget: t argumentGetSelector: s	argumentTarget _ t.	argumentGetSelector _ s! !!Utilities class methodsFor: 'common requests' stamp: 'sw 10/15/1998 15:14' prior: 35393260!closeAllDebuggers	"Utilities closeAllDebuggers"	Smalltalk isMorphic	ifTrue:		[(SystemWindow allSubInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w delete]]	ifFalse:		[(StandardSystemController allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w closeAndUnscheduleNoTerminate]]! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 11/2/1998 14:27' prior: 35396032!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ WorldMorph new.	colorList _  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34' prior: 22301238!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35' prior: 22302745!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!colorSeesPhrase	| outerPhrase |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	outerPhrase addMorphBack: ColorSeerTile new.	(outerPhrase submorphs at: 2) goBehind.		"Make it third"	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:25'!controlButtonColor	^ Color blue muchLighter! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph	| pal |	aMorph player == scriptedPlayer ifTrue:		[(pal _ self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 20:32'!obtainBankInfoFrom: anotherViewer	"Grandfathered in from old archictecture.   Probably dubious"! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:56'!scriptedPlayer	^ scriptedPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/20/1998 13:20'!scriptedPlayer: aPlayer	scriptedPlayer _ aPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:09'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/23/1998 09:10'!setPlayer: aPlayer	"bridging to old interface"	self initializeFor: aPlayer! !!CategoryViewer commentStamp: '<historical>' prior: 0!A viewer on an object.  Consists of three panes:   Header pane -- category-name, arrows for moving among categories, etc.   List pane -- contents are a list of subparts in the chosen category.   Editing pane -- optional, a detail pane with info relating to the selected element of the list pane.!!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/24/1998 23:10'!initializeFor: aPlayer	^ self initializeFor: aPlayer categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/25/1998 22:28'!initializeFor: aPlayer categoryChoice: aChoice	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 1;		beSticky.	self color: Color green muchLighter muchLighter.	scriptedPlayer _ aPlayer.	self addHeaderMorph.	self categoryChoice: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/9/1998 16:15'!categoryChoice: aCategory	| bin |	namePane contents: aCategory; color: Color black.	bin _ PhraseWrapperMorph new		borderWidth: 0;		orientation: #vertical.	bin addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: aCategory inViewer: self) collect:			[:aViewerRow | self viewerEntryFor: aViewerRow]).	bin enforceTileColorPolicy.	submorphs size < 2		ifTrue:			[self addMorphBack: bin]		ifFalse:			[self replaceSubmorph: self listPane by: bin].	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/3/1998 13:22'!chooseCategory	"The mouse went down on the receiver; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList _ scriptedPlayer categories.	aLinePosition _ aList indexOf: 'miscellaneous' ifAbsent: [nil].	lineList _ aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aMenu _ CustomMenu labels: aList lines: lineList selections: aList.	reply _ aMenu startUpWithCaption: 'category'.	reply ifNil: [^ self].	self categoryChoice: reply! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 14:09'!currentCategory	^ namePane contents! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:24'!downArrowHit	self previousCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:28'!nextCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [0].	newIndex _ anIndex = aList size		ifTrue:		[1]		ifFalse:		[anIndex + 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:31'!previousCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [aList size + 1].	newIndex _ anIndex = 1		ifTrue:		[aList size]		ifFalse:		[anIndex - 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:25'!upArrowHit	self nextCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/5/1998 09:09'!viewerEntryFor: aViewerRow	| anEntry |	anEntry _ ViewerEntry newColumn.	anEntry addMorphBack: aViewerRow.	^ anEntry! !!CategoryViewer methodsFor: 'editing pane' stamp: 'sw 10/30/1998 18:16'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	self beep.	^ false! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 11/5/1998 20:21'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Delete this Viewer'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	header beSticky.	self addMorph: header.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.		namePane _ (StringButtonMorph contents: '-----' "font: ScriptingSystem fontForScriptorButtons") color: Color black.	namePane target: self; arguments: Array new; actionSelector: #chooseCategory.	namePane actWhen: #buttonDown.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category'.	header addMorphBack: namePane.	self categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!CategoryViewer methodsFor: 'list pane' stamp: 'sw 10/23/1998 13:50'!listPane	^ submorphs second! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 10/30/1998 18:23'!addIsOverColorDetailTo: aRow	| clrTile readout aTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer".	aRow addMorphBack: (clrTile _ Color blue newTileMorphRepresentative).	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	readout _ UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile _ StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/9/1998 14:14'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton setBalloonText: 'menu'.	"aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot])."	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:31'!phraseForSlot: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a PhraseTileMorph representing the slot in the viewer"	| r anArrow |	r _ ViewerRow newRow		color: self color;		beSticky;		centering: #center.	r addDetailButton.	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: slotName type: partType).	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[readOnly ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				r addMorphBack: (anArrow _ self arrowSetterButtonFor: slotName type: partType)].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:37'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: scriptedPlayer costume;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!arrowSetterButtonFor: partName type: partType	| m |	m _ RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 1.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m on: #mouseDown send: #makeSetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!getterButtonFor: partName type: partType	| m |	m _ TileMorph new setOperator: partName.	m typeColor: (ScriptingSystem colorForType: partType).	m on: #mouseDown send: #makeGetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/21/1998 16:44'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 16:04'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType inViewer: self.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/30/1998 18:15'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/24/1998 23:41'!obtainBankInfoFrom: aViewer	self categoryChoice: aViewer currentCategory! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/29/1998 15:59'!tileForPlayer: aPlayer	"Return a tile representing aPlayer"	^ TileMorph new		setObjectRef: nil "disused parm" actualObject: aPlayer;		typeColor: (ScriptingSystem colorForType: #player)! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/21/1998 14:55'!tileForSelf	"Return a tile representing the target morph itself."	^ self tileForPlayer: scriptedPlayer! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/23/1998 21:54'!addCategoryViewer		| aCategory |	aCategory _ self categoryNotCurrentlyViewing.	self addCategoryViewerFor: aCategory! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 21:19'!addCategoryViewerFor: aStartingCategory	| aViewer |	self addMorphBack: (aViewer _ CategoryViewer new initializeFor: scriptedPlayer categoryChoice: aStartingCategory).	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 11/5/1998 16:11'!addHeaderMorph	| header aFont aButton aTextMorph nail wrpr costs |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #dismiss;			setBalloonText: 'Delete'.	header addTransparentSpacerOfSize: 4@1.	header addMorphBack: (aButton _ SimpleButtonMorph new label: '+' font: aFont).	aButton target: self; beTransparent;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother viewer'.	header addTransparentSpacerOfSize: 4@1.	(((costs _ scriptedPlayer costumes) size > 1) or: [costs size == 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume'].		nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		header beSticky.	self addMorph: header! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:38'!categoryMorphs	^ self submorphsSatisfying: [:m | m isKindOf: CategoryViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 23:11'!categoryNotCurrentlyViewing	| aList |	aList _ scriptedPlayer categories asOrderedCollection.	self categoryMorphs do:		[:m | aList remove: m currentCategory ifAbsent: []].	^ aList size > 0		ifTrue:			[aList first]		ifFalse:			['basic']! !!StandardViewer methodsFor: 'all' stamp: 'sw 11/5/1998 16:15'!dismiss	"User hit the dismiss button."	(owner isKindOf: TabbedPalette)		ifTrue:			[^ owner showNoPalette].	self delete! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:34'!downArrowHit	self nextCostume! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 09:24'!initializeFor: aPlayer	scriptedPlayer _ aPlayer.	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		borderWidth: 1.	self addHeaderMorph.	self addCategoryViewerFor: 'basic'.	self addCategoryViewerFor: 'tests'! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:37'!obtainBankInfoFrom: anotherViewer	anotherViewer categoryMorphs with: self categoryMorphs do:		[:old :new | new obtainBankInfoFrom: old]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:33'!upArrowHit	self previousCostume! !!ViewerBook methodsFor: 'all' stamp: 'sw 10/19/1998 23:21' prior: 35486113!setPlayer: aPlayer	| aPartsViewer |	"caution: returns an object not yet visible"	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "deploy viewer cache soon"	aPlayer costume pasteUpMorph "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky visible: false).		aPartsViewer setPlayer: aPlayer.	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1.	currentPage _ aPartsViewer.	^ aPartsViewer! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 13:54'!addHelpPane	helpPane ifNotNil: [^ self].	helpPane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	helpPane extent: ((self width - 4) @ (Preferences viewerEditingPaneHeight)).	helpPane retractable: true; scrollBarOnLeft: false.	self addMorphBack: helpPane! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 13:57'!codePaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'menueventuallywillbeuseful'		lines: #(1)		selections: #(beep flash beep flash beep)! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:26'!contents	| aType  newText sel info |	(info _ self userSlotInformation) ifNotNil:		[^ info documentation].	(aType _ self entryType) == #slot ifTrue: "system-defined slot"		[^ ScriptingSystem helpStringFor: self slotName].	aType == #script ifTrue:		[sel _ self phraseTileMorph submorphs second operatorOrExpression.		newText _ (Preferences showScriptSource or: [self playerBearingCode class tileScriptNames includes: sel])			ifTrue:				[self playerBearingCode sourceCodeFor: sel]			ifFalse:				[ScriptingSystem scriptHelpFor: sel]].	^ newText ifNil: ['?????']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:14'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	| info |	(info _ self userSlotInformation)		ifNotNil:			[info documentation: c.			^ true].	self beep.	^ false! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 09:31'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 21:04'!detailButtonPressed	helpPane		ifNotNil:			[helpPane delete.			helpPane _ nil]		ifNil:			[self addHelpPane]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!entryType	^ self viewerRow entryType! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 16:14'!initialize	super initialize.	color _ Color r: 1.0 g: 0.91 b: 1.0.	inset _ 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:34'!phraseTileMorph	"Answer the phraseTileMorph within the receiver"	^ self entryType == #script		ifTrue:			[self viewerRow submorphs fourth]		ifFalse:			[self error: 'slot rows do not contain a phrase tile morph']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:10'!playerBearingCode	^ self viewerRow playerBearingCode! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 20:56'!rootForGrabOf: aMorph	^ aMorph == self		ifTrue: [nil]		ifFalse:	[super rootForGrabOf: aMorph]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow submorphs sixth operatorOrExpression! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	(self entryType == #slot)		ifFalse:			[^ nil].	aSlotName _ self slotName.	^ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!viewerRow	"Answer the ViewerRow object, that contains the controls and the phraseTile"	^ submorphs first! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/9/1998 13:36'!addDetailButton	| aButton |	aButton _ SimpleButtonMorph new		target: self;		actionSelector: #detail;		beTransparent;		setBalloonText: 'detail';		label: ''.	self addMorphFront: aButton! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 09:16'!detail	owner detailButtonPressed! !!ViewerRow methodsFor: 'all' stamp: 'sw 10/27/1998 21:27'!entryType	"systemSlot userSlot systemScript userScript, eventually?!!"	| keyElement |	keyElement _ submorphs second submorphs first contents.	keyElement = '!!' ifTrue: [^ #script].	keyElement = '' ifTrue: [^ #slot].	^ #unknown! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/7/1998 22:31'!initialize	super initialize.	inset _ 1! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 10:17'!playerBearingCode	^ submorphs fourth associatedPlayer! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/9/1998 15:57'!rootForGrabOf: aMorph	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ nil].	^ aMorph fullCopy isPartsDonor: false! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 10/16/1998 18:49' prior: 35433589!configureForConstruction	| aPanel aCan |	self addMorph: (self presenter standardPartsWindow position: 10@10).	presenter standardPlayer.	aPanel _ presenter controlPanel.	self addMorph: aPanel.	self positionControlPanel: aPanel.	aCan _ self presenter addTrashCan.	aCan position: (Display boundingBox bottomRight - aCan extent).  "This oddity necessary to avoid the trashcan's showing up at top-left until an ownerChanged is sent to it; the problem is that addTrashCan: is called too early otherwise."! !!WorldMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 18:51' prior: 35447688!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aPanel aWindow |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aPanel _ aWorld presenter controlPanel.	aWorld addMorph: aPanel.	aWorld positionControlPanel: aPanel.	aWorld addMorph: (aWindow _ aWorld presenter standardPartsWindow position: 10@10).	aWindow activate.	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !Morph removeSelector: #standardHolder!Morph removeSelector: #standardHolder!BookMorph removeSelector: #saveAsMyPartsBin!BookMorph removeSelector: #saveAsMyPartsBin!HandMorph removeSelector: #flushViewerCache!HandMorph removeSelector: #flushViewerCache!PasteUpMorph removeSelector: #releaseCachedState!PasteUpMorph removeSelector: #releaseCachedState!PhraseTileMorph removeSelector: #inPartsBin!PhraseTileMorph removeSelector: #inPartsBin!Player removeSelector: #standardHolder!Player removeSelector: #standardHolder!Presenter removeSelector: #removeFromViewerCache:!Presenter removeSelector: #removeFromViewerCache:!Presenter removeSelector: #cacheViewer:forPlayer:!Presenter removeSelector: #cacheViewer:forPlayer:!Presenter removeSelector: #viewerCache!Presenter removeSelector: #viewerCache!Presenter removeSelector: #launchMyPartsBin!Presenter removeSelector: #launchMyPartsBin!Presenter removeSelector: #flushViewerCache!Presenter removeSelector: #flushViewerCache!Presenter removeSelector: #partsBinFor:!Presenter removeSelector: #partsBinFor:!Presenter removeSelector: #standardHolder!Presenter removeSelector: #standardHolder!Presenter removeSelector: #newStandardPartsBin!Presenter removeSelector: #newStandardPartsBin!Presenter removeSelector: #partsBinFor:color:!Presenter removeSelector: #partsBinFor:color:!Presenter removeSelector: #standardHolder:!Presenter removeSelector: #standardHolder:!StandardScriptingSystem removeSelector: #setPartsBinFrom:!StandardScriptingSystem removeSelector: #setPartsBinFrom:!StandardScriptingSystem removeSelector: #formDictionary!StandardScriptingSystem removeSelector: #formDictionary!StandardScriptingSystem removeSelector: #initializePartsBin!StandardScriptingSystem removeSelector: #initializePartsBin!StandardScriptingSystem removeSelector: #partsBin!StandardScriptingSystem removeSelector: #partsBin!StandardScriptingSystem initialize!EToySystem class removeSelector: #loadImages4!EToySystem class removeSelector: #loadImages4!EToySystem class removeSelector: #shrinkPics!EToySystem class removeSelector: #shrinkPics!EToySystem class removeSelector: #openEToyWorkspace!EToySystem class removeSelector: #openEToyWorkspace!EToySystem class removeSelector: #prepareForExternalReleaseNamed:!EToySystem class removeSelector: #prepareForExternalReleaseNamed:!EToySystem class removeSelector: #stripGraphicsForExternalRelease!EToySystem class removeSelector: #stripGraphicsForExternalRelease!EToySystem class removeSelector: #loadImages2!EToySystem class removeSelector: #loadImages2!EToySystem class removeSelector: #setFirstVersion!EToySystem class removeSelector: #setFirstVersion!EToySystem class removeSelector: #shrinkPics2!EToySystem class removeSelector: #shrinkPics2!EToySystem class removeSelector: #loadPurpleWalt!EToySystem class removeSelector: #loadPurpleWalt!EToySystem class removeSelector: #eToyDoItStrings!EToySystem class removeSelector: #eToyDoItStrings!EToySystem class removeSelector: #loadImages3!EToySystem class removeSelector: #loadImages3!EToySystem class removeSelector: #stuff!EToySystem class removeSelector: #stuff!EToySystem class removeSelector: #readCedarAndKayaPics!EToySystem class removeSelector: #readCedarAndKayaPics!EToySystem class removeSelector: #loadImages!EToySystem class removeSelector: #loadImages!EToySystem class removeSelector: #loadImages5!EToySystem class removeSelector: #loadImages5!EToySystem class removeSelector: #readCollagePic!EToySystem class removeSelector: #readCollagePic!WorldMorph removeSelector: #standardHolder!WorldMorph removeSelector: #standardHolder!"Postscript:"ScriptingSystem saveForm: TileMorph downPicture atKey: 'DownArrow'.ScriptingSystem saveForm: TileMorph upPicture atKey: 'UpArrow'.ScriptingSystem initStandardScriptInfo.ScriptingSystem initStandardSlotInfo.ScriptingSystem initializeHelpStrings.Preferences disable: #showPlayerSource.Preferences disable: #showScriptSource.Preferences enable: #useNewViewers.ScriptingSystem resetStandardPartsBin.ScriptingSystem initializeTypeColors.	ScriptingSystem saveForm: (Form	extent: 30@29	depth: 16	fromArray: #( 1811114995 1878286257 2012637171 1811180532 1811180533 1811179508 1811180532 1811179508 1744006133 1878289396 1811180533 1878289396 1744007156 1674736630 1744006132 1811114995 1811181556 1744006131 1811246068 1811180532 1811179508 1811180532 1744071668 1811113972 1811180532 1811180532 1811179507 1878288338 1945529332 1744071668 1743941620 1811112945 1811179506 1811114995 1744006131 1744006130 1744005106 1811048434 1811113969 1743939570 1811179506 1743939571 1676833782 1676765171 1811047410 1744006131 1811048435 1811116020 1811180531 1743939571 1811048435 1743939570 1743939570 1743939570 1743940594 1744005106 1811181556 1811180532 1676766196 1743939570 1878420468 1676963830 1189896082 1811245044 1744137204 1744070644 1811179508 1811113971 1743939571 1811179508 1811246070 1811309524 1811302093 1811310580 1811246068 1674867703 1744049472 1120606594 1118465013 1744137205 1811179508 1811180532 1744071667 1744006132 1811112947 1811247095 1605584589 358761132 289435638 1676830707 1741975543 1462778473 1811312631 702891724 1811310548 1945528308 1811178450 1945528307 1878288372 1878353875 1878421494 1051471335 1809213397 1118524175 1811246068 1945659348 1185698607 1878486005 1672694510 1118531574 1607626741 1878420467 1811180533 1743942645 1744072693 1811301035 1185770487 1878486006 1324239597 1811180533 1811116019 1120623438 1878352818 1945462739 704868339 1878289395 1811049459 1878221808 1878223859 1743876083 1811162563 1945463796 1811181556 1464746666 1811116018 1809019893 1120551562 1945464821 1741844468 1466842760 1878289395 1811048434 1811050483 1811050483 1878223859 1049188174 1741910004 1811181556 1256998634 1811114994 1878289396 1466840647 1744007156 1744006131 1676877216 1743940596 1878222835 1743938545 1878351792 1676833781 358641652 1743940596 1811050484 845566798 1811113970 1811114995 1811163652 1811112913 1878420468 1878282028 1811179506 1607560178 1878289395 1676900342 1878351825 1466853330 1811113971 1811116019 635659217 1811179506 1811245045 1676942754 1744137206 1744201717 1676962806 1676962805 1811310581 1676896245 1744199635 1811376117 1744072695 1744005109 1811244019 499279861 1811310581 1811244020 1811293668 1399943159 1605528567 1744136181 982063522 986342388 1744070645 1744189066 430063308 1744071669 1744070644 1744067504 566519797 1744136181 1744137205 1743999854 912813044 1811311606 1742162607 4195488 283139922 1945531382 1253113857 144710948 1601400791 1811246069 1811167879 1464821747 1744136180 1674799094 1811178482 843473875 1811311606 1878533542 2106790 2080066222 1876193270 696845376 627472380 1185772536 1878355957 1743990309 1744007157 1676898294 1744006132 1811114996 1743941620 1811180533 1809204941 4194368 4217681 1878290421 1252982848 4194336 1670540278 1739811795 1878353906 1744006131 1811179506 1744007157 1744005106 1945462771 1811182582 1811311574 1393641133 1462856629 2012638196 1876382449 1112301394 1742041045 1945596917 1676833781 1811113970 1811179507 1811180532 1672705014 1674735606 1672697648 1945725943 1878551479 1809215479 1811312629 1809216504 1809215479 1809215478 1462853490 1878487029 1744007158 1744005075 1811239726 704979363 495004132 700789287 562372997 631646663 1739998892 4194400 1116497846 698688932 562375109 770124262 633609569 495070758 1257010166 562315916 1809279958 2012894002 1047280171 980237901 910966381 1668677696 4194400 6314867 1047281260 908804749 910968495 1393719290 1809279959 1185750370 1809214455 1878469062 423836236 1532188466 1601592148 1462986647 1672937568 4194368 6319062 1603622706 1601525554 1601522417 1047336194 770206679 1878487031 1878409899 977955830 1809145716 1118586509 980105834 980045584 1811372914 980104778 1605526483 1395605131 910769804 1118651052 1534358520 1809136234 1118596053 1532059506 1878485973 1326456163 1945660374 1742106615 1811311607 1945725942 1742107641 1744072693 1811311605 1744203767 1878551543 564478604 1878553591 1603428242 1811048433 1811049459 1051290611 1744006131 1811049459 1878156273 1743874034 1744007156 1743874033 1811048434 1811113970 1743939571 1743933228 1603301363 1743875059 1811049458 1945461745 1811181556 1811113971 1811049458 1811048434 1811116020 1878287346 1878223857 1743940594 1744006130 1744007157 1945395153 1945400309 1811048434 1743810547 1676765170 1878353906 1811113970 1743874032 1810983921 1743874033 1811113971 1676765169 1743874034 1743940593 1743939569 1811047409 1676765168 1743940595 1810981872 1945397235 1607560179 1743941620 1810982897 1810983921 1811048433 1744007155 1743875059 1811048434 1743875058 1743939568 1676832754 1811116019 1811114994 1811244019 1676962805 1677029367 1811244020 1744005106 1743940594 1811246068 1744070645 1676961781 1744004084 1676897269 1811180533 1878353908 1744004083 1744070645)	offset: 0@0) atKey: 'squeakyMouse'.ScriptingSystem saveForm: (Form extent: 7@7 depth: 16	fromArray: #( 0 1879273475 1879244800 0 28675 1879273475 1879273475 0 1879273475 1879273475 1879273475 1879244800 1879273475 1879273475 1879273475 1879244800 1879273475 1879273475 1879273475 1879244800 28675 1879273475 1879273475 0 0 1879273475 1879244800 0)	offset: 0@0) atKey: 'OfferToLock'.ScriptingSystem saveForm: (Form extent: 7@7 depth: 16	fromArray: #( 0 58852226 58851328 0 898 58852226 58852226 0 58852226 58852226 58852226 58851328 58852226 58852226 58852226 58851328 58852226 58852226 58852226 58851328 898 58852226 58852226 0 0 58852226 58851328 0)	offset: 0@0) atKey: 'OfferToUnlock'.ScriptingSystem initializeHelpStrings.Preferences initializeParameters.Preferences setAltMenuChoices.ScriptingSystem initializeScriptHelp.ScriptingSystem newStandardPartsBin.!'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 11:43:42 am'!"Change Set:		PunchList-diDate:			10 November 1998Author:			Dan IngallsNumerous simple fixes requested by Scott Wallace and Ivan Brusic, including...If you attempt to add an instVar that is already used in a sublcass, you are now warned about the problem before the class hierarchy gets trashed.When you open a browser in morphic with the directive that it pre-select something (class, or more commonly class + method) -- such via a browse-full or browse-it request in a different browser -- it now properly scrolls the selections into view.The size of a window's collapsed image is adjusted appropriately whenever the label is changed.A flash in a text pane is now limited to its visible boundary on the display.Frame adjustment handles are now only offered for the active window.colorUnder now works correctly whether an object's immediate owner is the World or not."!!ClassDescription methodsFor: 'instance variables' stamp: 'di 11/9/1998 20:21'!checkForInstVarsOK: instVarString	"Return true if instVarString does no include any names used in a subclass"	| instVarArray |	instVarArray _ Scanner new scanFieldNames: instVarString.	self allSubclasses do:		[:cl | cl instVarNames do:			[:n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!Metaclass methodsFor: 'class hierarchy' stamp: 'di 11/9/1998 20:18' prior: 35641319!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName].			(oldClass checkForInstVarsOK: instVarString)				ifFalse: [^ false]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !!Morph methodsFor: 'drawing' stamp: 'di 11/10/1998 10:15' prior: 35505352!flash	| c w |	c _ self color.	self color: Color black.	(w _ self world) ifNotNil: [w doOneCycle].	self color: c! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 11/10/1998 09:31' prior: 20704073!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.! !!SystemWindow methodsFor: 'label' stamp: 'di 11/10/1998 09:48' prior: 35991654!setLabel: aString	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	self isCollapsed		ifTrue: [self extent: (label width + 50) @ (self labelHeight + 2)]		ifFalse: [label fitContents; setWidth: (label width min: bounds width - 50).				label align: label bounds topCenter with: bounds topCenter + (0@borderWidth).				collapsedFrame ifNotNil:					[collapsedFrame _ collapsedFrame withWidth: label width + 50]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 11/10/1998 10:20' prior: 36004772!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	self isActive ifFalse: [^ self  "Mouse-over of an inactive window"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [newBounds _ self bounds withTop: localPt y].			ptName = #bottom ifTrue: [newBounds _ self bounds withBottom: localPt y].			ptName = #left ifTrue: [newBounds _ self bounds withLeft: localPt x].			ptName = #right ifTrue: [newBounds _ self bounds withRight: localPt x].			ptName = #topLeft ifTrue: [newBounds _ localPt corner: bounds bottomRight].			ptName = #bottomRight ifTrue: [newBounds _ bounds topLeft corner: localPt].			ptName = #bottomLeft ifTrue: [newBounds _ (bounds withBottom: localPt y) withLeft: localPt x].			ptName = #topRight ifTrue: [newBounds _ (bounds withTop: localPt y) withRight: localPt x].			newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 11/10/1998 10:13'!flash	^ editView flash! !!Utilities class methodsFor: 'miscellaneous' stamp: 'di 11/10/1998 10:24' prior: 22241015!emergencyCollapse	World ifNotNil: [^ self].	ScheduledControllers screenController emergencyCollapse! !!WorldMorph methodsFor: 'sensing' stamp: 'di 11/10/1998 11:41' prior: 35503551!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	submorphs reverseDo:		[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ c form]]				ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)							ifTrue: [^ c form]]].  	hands reverseDo: [:h |		h submorphsReverseDo:		[:m | m == stopMorph			ifTrue: [stopThere ifTrue: [^ c form]]			ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)						ifTrue: [^ c form]]]].  	^ c form! !'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 1:03:13 pm'!"Change Set:		Oops-swDate:			10 November 1998Author:			Scott WallaceQuick fixes for two oversights in the Kubwa update:*  The tile-script-command to 'initiate painting' is restored to the viewer.*  The obsolete 'establish as custom parts bin' menu item is removed from BookMorph's menu"!!BookMorph methodsFor: 'menu' stamp: 'sw 11/10/1998 12:57' prior: 36090410!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'book...' subMenu: subMenu! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/10/1998 12:45' prior: 36127924!categories	| aList |	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack' 'playfield')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/10/1998 13:03' prior: 36133572!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString |	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))].	(aCategory = 'tests') ifTrue:		[aList _ #((slot isOverColor) (slot isUnderMouse) (slot colorSees) )].	(aCategory = 'color & border') ifTrue:		[aList _ #((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ #((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]. 	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'playfield') ifTrue:		[aList _ #((script initiatePainting))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 2:02:29 pm'!"Change Set:		jhmAlignAndOtherFixesDate:			10 November 1998Author:			John MaloneyFixes Alignment morph to keep track of fractional widths sothat, for example, browser buttons don't leave little gaps.Other fixes include:  a. fixes to forkAt: and dateAndTimeFromSeconds: from the list  b. a slightly different space tallying facility (produces a collection     for analysis, rather than printing to a file)  c. set buffer size in MIDISynth example  d. show one-pixel inter-note gaps in PianoRoll  e. facility for removing even the compressed temp     names from an image when every byte counts"!!AlignmentMorph methodsFor: 'private' stamp: 'jm 11/10/1998 13:14' prior: 16834732!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ 2 * (inset + borderWidth).	orientation = #horizontal ifTrue: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize).			(m isAlignmentMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize).			(m isAlignmentMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra asFloat / spaceFillingMorphs! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 11/10/1998 13:33' prior: 16835583!fixLayout	| extraPerMorph fractionalExtra fractionAccumulator nextPlace extra space |	extraPerMorph _ self extraSpacePerMorph asFloat.	fractionalExtra _ extraPerMorph fractionPart.	extraPerMorph _ extraPerMorph truncated.	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	fractionAccumulator _ 0.0.	submorphs do: [:m |		fractionAccumulator _ fractionAccumulator + fractionalExtra.		fractionAccumulator > 0.5			ifTrue: [				extra _ extraPerMorph + 1.				fractionAccumulator _ fractionAccumulator - 1.0]			ifFalse: [extra _ extraPerMorph].		space _ self placeAndSize: m at: nextPlace padding: extra.		nextPlace _ nextPlace + space].! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 11/9/1998 10:16' prior: 17067098!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess |	forkedProcess _ self newProcess.	forkedProcess priority: priority.	^ forkedProcess resume! !!ClassDescription methodsFor: 'private' stamp: 'jm 11/1/1998 11:47' prior: 17466773!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space method |	space _ 0.	self selectorsDo: [:sel |		space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space _ space + 12].			(lit isMemberOf: String) ifTrue: [space _ space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space _ space + ((lit size + 1) * 4)]]].	(self isMemberOf: Metaclass)		ifTrue: [^ space]		ifFalse: [^ space + self class spaceUsed].! !!MIDISynth class methodsFor: 'examples' stamp: 'jm 11/10/1998 13:42' prior: 35938381!example	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."	"MIDISynth example"	| portNum synth |	portNum _ SimpleMIDIPort inputPortNumFromUser.	portNum ifNil: [^ self].	SoundPlayer useShortBuffer.	synth _ MIDISynth new on:		(SimpleMIDIPort openOnPortNumber: portNum).	synth midiParser ignoreCommand: 224.  "filter out pitch bends"	1 to: 16 do: [:i |		(synth channel: i) instrument: 			 (AbstractSound soundNamed: 'oboe1')].	synth masterVolume: 0.2.	synth processMIDIUntilMouseDown.	SoundPlayer shutDown; initialize.  "revert to normal buffer size"! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 10/20/1998 15:15' prior: 34843189!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"		track _ score ambientTrack.		i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								("PianoRollNoteMorph"  Morph  "<-- Change comment quotes here**"									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 11/10/1998 13:42'!useShortBuffer	"Experimental support for real-time MIDI input. This only works on platforms whose hardware allows very short buffer sizes. It has been tested on a Macintosh Powerbook G3."	"SoundPlayer useShortBuffer"	self shutDown.	BufferMSecs _ 15.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 11/1/1998 08:31'!abandonTempNames	"Replaces every method by a copy with no source pointer or encoded temp names."	"Smalltalk abandonTempNames"	 | continue oldMethods newMethods n m |	continue _ (self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.').	continue ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts; garbageCollect.	oldMethods _ OrderedCollection new.	newMethods _ OrderedCollection new.	n _ 0.	'Removing temp names to save space...'		displayProgressAt: Sensor cursorPoint		from: 0 to: CompiledMethod instanceCount		during: [:bar |			Smalltalk allBehaviorsDo: [:cl |				cl selectors do: [:sel |					bar value: (n _ n + 1).					m _ cl compiledMethodAt: sel.					oldMethods addLast: m.					newMethods addLast: (m copyWithTrailerBytes: #(0))]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk closeSourceFiles.	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:38'!spaceForInstancesOf: aClass	"Answer the number of bytes consumed by all instances of the given class, including thier object headers."	| instCount isCompact instVarBytes bytesPerElement contentBytes headerBytes total |	instCount _ aClass instanceCount.	instCount = 0 ifTrue: [^ 0].	isCompact _ aClass indexIfCompact > 0.	instVarBytes _ aClass instSize * 4.	aClass isVariable		ifTrue: [			bytesPerElement _ aClass isBytes ifTrue: [1] ifFalse: [4].			total _ 0.			aClass allInstancesDo: [:inst |				contentBytes _ instVarBytes + (inst size * bytesPerElement).				headerBytes _					contentBytes > 255						ifTrue: [12]						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].				total _ total + headerBytes + contentBytes].			^ total]		ifFalse: [			headerBytes _				instVarBytes > 255					ifTrue: [12]					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].			^ instCount * (headerBytes + instVarBytes)].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:45'!spaceTally	"Answer a collection of tuples representing the memory space (in bytes) consumed by the code and instances of each class in the system. The tuples have the form:	<class> <code size> <instance count> <space for instances>Code sizes do not currently report memory consumed by class variables. The arrays used to record these results consume a relatively insignificant amount of space."	"(Smalltalk spaceTally asSortedCollection: [:a :b | a last > b last]) asArray"	| results entry c |	"pre-allocate array of entries for results"	results _ OrderedCollection new: self size.	self do: [:cl |		(cl isKindOf: Class) ifTrue: [			entry _ Array new: 4.			entry at: 1 put: cl.			results add: entry]].	results _ results asArray.	Smalltalk garbageCollect.	1 to: results size do: [:i |		entry _ results at: i.		c _ entry at: 1.		entry at: 2 put: c spaceUsed.		entry at: 3 put: c instanceCount.		entry at: 4 put: (self spaceForInstancesOf: c).		Smalltalk garbageCollectMost].	^ results! !!Time class methodsFor: 'general inquiries' stamp: 'JZH 11/8/1998 13:03' prior: 35343126!dateAndTimeFromSeconds: secondCount	^ Array		with: (Date fromSeconds: secondCount)		with: (Time fromSeconds: secondCount \\ 86400)! !SoundPlayer class removeSelector: #useLongBuffer!'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 2:54:50 pm'!"Change Set:		PunchList2-di.stDate:			10 November 1998Author:			Dan IngallsThis changeSet provides a new class, PluggableListMorphOfMany designed solely to provide the multiple selection capability required for squeak's ChangeLists.  No warantees."!PluggableListMorph subclass: #PluggableListMorphOfMany	instanceVariableNames: 'dragOnOrOff '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ChangeList class methodsFor: 'instance creation' stamp: 'di 11/10/1998 13:34' prior: 33773941!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: ((multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!PluggableListMorph methodsFor: 'events' stamp: 'di 11/10/1998 13:59' prior: 34900507!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"If hit old highlight, then deselect it"	aMorph == selectedMorph		ifTrue: [autoDeselect ifTrue: [self setSelectedMorph: nil]]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 13:39'!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(model listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) invertBoundsRect: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:46'!list: listOfStrings	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:50'!mouseDown: event onItem: aMorph	| index |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Set meaning for subsequent dragging of selection"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane broder drag"].	dragOnOrOff _ (model listSelectionAt: index) not.	"If hit old highlight, then deselect it"	aMorph == selectedMorph		ifTrue: [autoDeselect ifTrue: [self setSelectedMorph: nil]]		ifFalse: [self setSelectedMorph: aMorph].	"If hit a selection, then set drag off, else drag on"	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:48'!mouseEnterDragging: event onItem: aMorph	| index |	dragOnOrOff ifNil: [^ self "spurious drag did not start with mouseDown"].	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	"Extend the selection with the current state of dragOnOrOff"	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:47'!mouseUp: event onItem: aMorph	dragOnOrOff _ nil.  "So improperly started drags will have not effect"! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 11/10/1998 14:44'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 2:59:49 pm'!!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33' prior: 36304378!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 4:29:51 pm'!!Browser methodsFor: 'initialize-release' stamp: 'jm 11/10/1998 16:24' prior: 17133173!openAsMorphClassEditing: editString	"Create a pluggable version a Browser on just a single class."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #classListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #classListMenu:)		frame: (0@0 extent: 0.5@0.06).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.5@0 extent: 0.5@0.06).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0@0.06 extent: 0.5@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:)		frame: (0.5@0.06 extent: 0.5@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 11/10/1998 16:25' prior: 33683388!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane aListMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.4 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 11/10/1998 16:25' prior: 17137701!openAsMorphSysCatEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0@0.06 extent: 0.3333@0.24).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0@0.3 extent: 0.3333@0.06).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.3333@0.06 extent: 0.3333@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:)		frame: (0.6666@0.06 extent: 0.3333@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	^ window! !'From Squeak 2.2 of Sept 23, 1998 on 10 November 1998 at 6:46:01 pm'!"Change Set:		misc10Nov-swDate:			10 November 1998Author:			Scott Wallace*  Offer costume-appropriate script categories in viewer even when costume is flexed.*  Don't try to project a viewer into a palette that is not currently in world*  Make change-costume work even when the object's parent is not a PasteUpMorph*  Offer 'cursor' and 'valueAtCursor' in Viewer for PasteUpMorphs*  Don't fail on first attempt to create custom parts bin."!!Player methodsFor: 'costume' stamp: 'sw 11/10/1998 15:43' prior: 36126927!hasCostumeOfClass: aClass	(costume renderedMorph class == aClass) ifTrue: [^ true].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ true]]].	^ false! !!Player methodsFor: 'costume' stamp: 'sw 11/10/1998 17:03' prior: 34855474!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner replaceSubmorph: costume by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			aMorph setNameTo: costume knownName.			costume _ aMorph]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/10/1998 17:23' prior: 36290145!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString |	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))].	(aCategory = 'tests') ifTrue:		[aList _ #((slot isOverColor) (slot isUnderMouse) (slot colorSees) )].	(aCategory = 'color & border') ifTrue:		[aList _ #((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ #((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]. 	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/10/1998 17:57' prior: 36162972!standardPartsWindow	| aPartsWindow aWorld |	aPartsWindow _ ScriptingSystem newStandardPartsBin wrappedInPartsWindowWithTitle: 'Standard Parts'.	aWorld _ (associatedMorph == nil or: [associatedMorph isInWorld not])		ifTrue:		[World]		ifFalse:		[associatedMorph world].	aWorld addMorph: aPartsWindow.  "So that closeEditing won't bomb"	aPartsWindow closeEditing.  "a bit redundant but gets the last details right"	^ aPartsWindow! !!Presenter methodsFor: 'viewer' stamp: 'sw 11/10/1998 15:36' prior: 36167884!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	self harmonizeTileColorPolicyFor: aViewer.	aMorph primaryHand attachMorph: (aViewer visible: true)! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 11/10/1998 17:39' prior: 36204474!initStandardSlotInfo	"ScriptingSystem initStandardSlotInfo"	StandardSlotInfo _ Dictionary new.	#((color			color		readWrite	getColor				setColor:)	(borderWidth 	number		readWrite	getBorderWidth	setBorderWidth:)	(borderColor		color		readWrite	getBorderColor	setBorderColor:)		(leftRight	number		readOnly	getLeftRight				unused)		(upDown	number		readOnly	getUpDown				unused)		(angle		number		readOnly	getAngle				unused)		(amount	number		readOnly	getAmount				unused)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused)		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)		(rotationStyle	rotationStyle									readWrite	getRotationStyle		setRotationStyle:)		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused)		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:)		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:))	do:		[:anArray | StandardSlotInfo at: anArray first put: anArray]! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 11/10/1998 18:18'!brightColorForType: typeSymbol	^ (TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 2! !"Postscript:"ScriptingSystem initStandardSlotInfo.!'From Squeak 2.2 of Sept 23, 1998 on 11 November 1998 at 9:58:14 am'!"Change Set:		InboardScrollbarPrefDate:			11 November 1998Author:			Dan IngallsThis changeSet installs a preference for using inboard scrollbars in Morphic.  It is initialized to false.  The same preference controls the side on which scrollbars appear.  Inboard scrollbars appear on the right; retractable scrollbars appear on the left."!!Preferences class methodsFor: 'initialization' stamp: 'di 11/11/1998 08:16' prior: 36143445!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(inboardScrollbars					false)		(logDebuggerStackToFile				true)		(noviceMode							false)		(printAlternateSyntax				false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showScriptSource					false)		(showTimeStampsInMenuTitles		false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'di 11/11/1998 08:21' prior: 36144444!initializeHelpMessages	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic, SystemWindows should automatically be droppable into willing receptors')(browseWithPrettyPrint'If true, browsers will automatically format their contents')(cautionBeforeClosing 'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts are edited in place in Scriptors (still imperfectly implemented)')(eToyScheme'If true, new scripting spaces place the Playfield to the left and the the palette to the right of the window; if false, the opposite is true.')(fastDragWindowForMorphic'If true, morphic window drag will be done by dragging an outline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(inboardScrollbars'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit')(logDebuggerStackToFile'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(noviceMode 'If true, certain novice-mode accommodations are made.')(printAlternateSyntax'If true, thenprettyPrint using experimental syntax.Otherwise use normal ST-80 syntax.')(reverseWindowStagger'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')(showPlayerSource'If true, then all Player methods with fewer than 2 arguments are included in Viewers, whether or not they are intended for end-user use.  This can be dangerous')(showScriptSource'If true, then the actual Smalltalk source code for methods is shown in the detail panes for scripts in a viewer; if false, then a help message for scripts is shown instead.')(showTimeStampsInMenuTitles'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')(suppressCheckForSlips 'If false, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choice when updating code from the server is suppressed.  Set this to true to leave the server choice unchanged from update to update.')(thoroughSenders'If true, then ''senders'' browsers will dive inside structured literals in their search')(uniformWindowColors'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequence number from the filename before automatically saving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.')(useNewViewers'If true, then the new kinds of viewers introduced in Squeak 2.3 are used; if false, then the old style, from earlier releases, are still used.  Old viewers will hopefully soon be removed from the system.')(warnIfNoChangesFile'If true, then you will be warned, whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned, whenever you start up, if no sources file can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!ScrollBar methodsFor: 'geometry' stamp: 'di 11/11/1998 09:27' prior: 21148647!extent: p	p x > p y		ifTrue: [super extent: (p max: 36@8)]		ifFalse: [super extent: (p max: 8@36)]! !!ScrollPane methodsFor: 'initialization' stamp: 'di 11/11/1998 09:53' prior: 21162796!initialize	super initialize.	borderWidth _ 2.  borderColor _ #inset.	retractableScrollBar _ scrollBarOnLeft _		(Preferences valueOfFlag: #inboardScrollbars) not.	scrollBar := ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 2; borderColor: #inset.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	scroller := TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	self on: #mouseEnter send: #mouseEnter: to: self.	self on: #mouseLeave send: #mouseLeave: to: self.	self extent: 150@120! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 08:59' prior: 21164214!extent: newExtent	super extent: (newExtent max: (self scrollbarWidth + 20)@16).	self resizeScrollBar; resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:52'!innerBounds	| inner w |	inner _ super innerBounds.	w _ self scrollbarWidth.	retractableScrollBar		ifTrue: [^ inner]		ifFalse: [^ (scrollBarOnLeft					ifTrue: [inner topLeft + ((w-1)@0) corner: inner bottomRight]					ifFalse: [inner topLeft corner: inner bottomRight - ((w-2)@0)])]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:11' prior: 21164374!resizeScrollBar	| w topLeft |	w _ self scrollbarWidth.	topLeft _ scrollBarOnLeft		ifTrue: [retractableScrollBar ifTrue: [bounds topLeft - ((w-1)@0)]									ifFalse: [bounds topLeft]]		ifFalse: [retractableScrollBar ifTrue: [bounds topRight]									ifFalse: [bounds topRight - ((w-1)@0)]].	scrollBar bounds: (topLeft extent: w @ bounds height)! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:48' prior: 21164657!resizeScroller	scroller bounds: self innerBounds! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:54'!scrollbarWidth  "Includes border"	^ 16! !"Postscript:Install a preference for inboard scrollbars, and set it to false."Preferences setPreference: #inboardScrollbars toValue: false.Preferences setHelpFor: #inboardScrollbars toString: 'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit'.!'From Squeak 2.2 of Sept 23, 1998 on 11 November 1998 at 12:07:31 pm'!"Change Set:		mouseLeavingsEtc-swDate:			11 November 1998Author:			Scott Wallace(revised 4:41pm 11Nov and patched back onto server)* Allows PasteUpMorphs to be dispatched mouseEnter and mouseLeave events,* Takes advantage of Dan's recent fixes to the inboard scroll panes, by incorporating them into the detail panes of the new viewers -- this precludes their annoying jumping around on mouseover.* Initializes the help message for the new inboardScrollbars.* Improves the Preferences #doesNotUnderstand: intercept so that Preferences class won't just silently swallow messages like the one that the postscript of update 689 tried to send it."!!HandMorph methodsFor: 'event dispatching' stamp: 'sw 11/11/1998 11:00' prior: 34084968!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	"[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p]."  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/11/1998 11:58' prior: 36149302!viewerEditingPaneHeight	^ 30! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 11/11/1998 11:40' prior: 20825247!doesNotUnderstand: aMessage	"Look up the message selector as a flag."	aMessage arguments size > 0 ifTrue: [^ super doesNotUnderstand: aMessage].	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/11/1998 11:27'!setHelpFor: prefName toString: aString	HelpDictionary ifNil: [self initializeHelpMessages].	HelpDictionary at: prefName put: aString! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/11/1998 11:50' prior: 36264115!addHelpPane	helpPane ifNotNil: [^ self].	helpPane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	helpPane extent: ((self width - 4) @ (Preferences viewerEditingPaneHeight)).	helpPane scrollBarOnLeft: false; retractable: false.	self addMorphBack: helpPane! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/11/1998 11:53' prior: 36266083!initialize	super initialize.	color _ Color r: 1.0 g: 0.985 b: 0.985.	inset _ 0! !"Postscript:"Preferences setHelpFor: #inboardScrollbars toString: 'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit'.!'From Squeak 2.2 of Sept 23, 1998 on 11 November 1998 at 5:40:36 pm'!"Change Set:		paintBoxLocEtc-swDate:			11 November 1998Author:			Scott WallaceA few fixes centered around work toward getting the paintbox properly aligned with the standard palette in constructions such as the etoy-template-from-bare-parts one (though some of the changes here ultimately are quite unrelated to that.)  Specifically;*  The 'make detachable' command no longer adds stop-step-go buttons and trashcan; add them manually from a parts bin if you need them.  And, to assist *  A workaround remedy is added for the not-yet-fully-understood phenomenon in which two StandardViewers stack up in the same palette.*  Stop-step-go buttons in the default 'standard scripting area' are again linked together for proper highlighting.*  Stop-step-go buttons dragged from the parts bin dock up dynamically and fairly cleverly with the appropriate presenter.*  The step button highlighting is left in the correct state, a situation that had not obtained for at least the past nine months.*  Find-changed-browsers and find-changed-windows features no longer bring up a debugger if they find no qualifying windows.*  The former failure associated with the situation where you drag something into a trash can which is statically associated with a palette that no longer is in the world is now avoided.*  The fix to a Preferences method for setting a help string which got omitted from an earlier, retracted, version of mouseLeavingsEtc-sw.cs, is included.*  Several obsolete methods removed."!!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:20' prior: 34104428!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:22' prior: 34104882!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 11/11/1998 16:10' prior: 36118789!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/11/1998 13:45' prior: 34824889!impartPrivatePresenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles.		presenter standardPlayer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/11/1998 16:13'!makeDetachable	presenter ifNil:		[self impartPrivatePresenter.		self borderWidth: 1;  borderColor: Color green darker]! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 11/11/1998 17:33' prior: 34831616!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter;  extent: 100 @ 80; borderColor: (Color r: 0.645 g: 0.935 b: 0.161).	proto setProperty: #expandedExtent toValue: 300 @ 240.	proto beSticky.	^ proto! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/11/1998 16:39' prior: 36330488!setHelpFor: prefName toString: aString	HelpDictionary ifNil: [self initializeHelpMessages].	HelpDictionary at: prefName put: aString! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/11/1998 15:06' prior: 36153525!addStopStepGoButtonsTo: aPasteUpMorph	| controls |	controls _ ScriptingSystem scriptControlButtons.	controls setToAdhereToEdge: #bottomLeft.	aPasteUpMorph addMorphBack: controls.	stopButton _ controls submorphs first.	stepButton _ controls submorphs second.	goButton _ controls submorphs third! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:18'!startRunningScriptsFrom: aGoButton	(goButton == nil or: [goButton isInWorld not]) ifTrue: [goButton _ aGoButton].	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:51' prior: 34934519!stepStillDown: dummy with: theButton	(stepButton == nil or: [stepButton isInWorld not]) ifTrue: [stepButton _ theButton].	self stepButtonState: true.	self stopButtonState: false.	associatedMorph stepAll.	associatedMorph world displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:50' prior: 20842225!stepUp: evt with: aMorph	(stepButton == nil or: [stepButton isInWorld not]) ifTrue: [stepButton _ aMorph].	stepButton state: #off! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/11/1998 15:16'!stopRunningScriptsFrom: aStopButton	(stopButton == nil or: [stopButton isInWorld not]) ifTrue: [stopButton _ aStopButton].	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 11/11/1998 13:46' prior: 36200597!newScriptingSpace	"Answer a complete scripting space"	| aTemplate  palette aPlayfield aWindow |	aWindow _ (SystemWindow labelled: 'scripting area') model: ScriptingDomain new.	aWindow extent: 640 @ 480.	aTemplate _ PasteUpMorph new setNameTo: 'etoy'.	aTemplate extent: 638 @ 470.	aWindow addMorph: aTemplate frame: (0@0 corner: 1@1).	aTemplate setStandardTexture.	aTemplate impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky.	aTemplate presenter addStopStepGoButtons; addTrashCan.	palette _ TabbedPalette new pageSize: 200@320.	palette beSticky.	aTemplate addMorph: palette.	palette addMenuTab.	palette addPartsTab.	palette addControlsTab.	palette addScrapsTab.	"palette addViewerTab."	aPlayfield _ PasteUpMorph new setNameTo: 'playfield'.	(Preferences valueOfFlag: #eToyScheme)  "Not widely advertised"		ifFalse:				[aPlayfield setToAdhereToEdge: #topRight.			palette setToAdhereToEdge: #topLeft]		ifTrue:			[aPlayfield setToAdhereToEdge: #topLeft.			palette setToAdhereToEdge: #topRight].	aTemplate addMorph: aPlayfield.	aPlayfield extent: 340@300; position: aTemplate topRight - (400@0).	aPlayfield beSticky.	aPlayfield automaticViewing: true.	aPlayfield wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aWindow! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/11/1998 15:24' prior: 36207109!goUp: evt with: aGoButton	aGoButton presenter startRunningScriptsFrom: aGoButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/11/1998 15:49' prior: 36207797!stepButton	| aButton |	aButton _ ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			actWhen: #whilePressed;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/11/1998 15:16' prior: 36209693!stopUp: dummy with: theButton	| aPresenter |	(aPresenter _ theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScriptsFrom: theButton! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/11/1998 14:42' prior: 36231494!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette		ifNotNil:			[aMenu add:  'clear' action: #showNoPalette.			aMenu addLine]		ifNil:			[submorphs size > 1				ifTrue: 					[aMenu add: 'clear!!' action: #showNoPalette.					aMenu addLine]].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 11/11/1998 14:02' prior: 36232283!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	submorphs size > 1 ifTrue: "spurious submorphs, yecch"		[(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]].	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	"self snapToEdgeIfAppropriate"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'sw 11/11/1998 15:01' prior: 22082008!printOn: aStream	| string |	aStream nextPutAll: '3PButton'.	arguments size > 0 ifTrue: [string _ arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	(string ~~ nil and: [string ~~ self])		ifTrue:			[aStream print: string; space]		ifFalse:			[aStream print: actionSelector; space].	aStream print: self identityHash;			nextPutAll: ')'.! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 11/11/1998 16:01' prior: 35352353!acceptDroppingMorph: aMorph event: evt	| palette |	self presenter soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self standardPalette.	(palette notNil and: [palette isInWorld]) ifTrue: [palette addToTrash: aMorph].! !Presenter removeSelector: #flushButton!Presenter removeSelector: #flushButton!Presenter removeSelector: #newControlsButton!Presenter removeSelector: #newControlsButton!Presenter removeSelector: #stopButton!Presenter removeSelector: #stopButton!Presenter removeSelector: #newPaintingButton!Presenter removeSelector: #newPaintingButton!Presenter removeSelector: #goButton!Presenter removeSelector: #goButton!Presenter removeSelector: #newPartsBinButton!Presenter removeSelector: #newPartsBinButton!Presenter removeSelector: #stepButton!Presenter removeSelector: #stepButton!"Postscript:"ScriptingSystem resetStandardPartsBin.ScriptingSystem newStandardPartsBin.!'From Squeak 2.2 of Sept 23, 1998 on 12 November 1998 at 7:07:16 pm'!Dictionary subclass: #PluggableDictionary	instanceVariableNames: 'hashBlock equalBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!Set subclass: #PluggableSet	instanceVariableNames: 'hashBlock equalBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!PluggableDictionary commentStamp: '<historical>' prior: 0!Class PluggableDictionary allows the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the dictionary. See the class comment of PluggableSet for an example.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.!!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!copy	^super copy postCopyBlocks! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2].! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableSet commentStamp: '<historical>' prior: 0!PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.Example: Adding 1000 integer points in the range (0@0) to: (100@100) to a set.	| rnd set max pt |	set _ Set new: 1000.	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].The above is way slow since the default hashing function of points leads to an awful lot of collisions in the set. And now the same, with a somewhat different hash function:	| rnd set max pt |	set _ PluggableSet new: 1000.	set hashBlock:[:item| (item x bitShift: 16) + item y].	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].!!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:47'!copy	^super copy postCopyBlocks! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2]! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:40'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !'From Squeak 2.2 of Sept 23, 1998 on 13 November 1998 at 3:29:55 pm'!"Change Set:		LittleStuff-diDate:			13 November 1998Author:			Dan IngallsThis changeSet...Fixes a small problem with the PianoKeyboard (makes it not play when draggin things over it (as I tell my toddler, only use your hand ;-)Cleans up SeqCollection>>pairsDo: and adds a similar pairsCollect:Removes SeqCollection>>adjacent which was unused and did what pairsCollect: does.Uses ClassOrganizer default instead of the literal 'as yet unclassified' in two methods, for better factoring and easer maintenance.  [thanks to R.A. Harmon]"!!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 11/13/1998 15:25' prior: 17460695!methods	"Answer a ClassCategoryReader for compiling messages that are not classified, as in fileouts made with Smalltalk/V"	^ ClassCategoryReader new setClass: self category: ClassOrganizer default! !!InspectorBrowser methodsFor: 'all' stamp: 'di 11/13/1998 15:27' prior: 19117178!msgAccept: newText from: editor	| category |	category _ msgListIndex = 0		ifTrue: [ClassOrganizer default]		ifFalse: [object class organization categoryOfElement: (msgList at: msgListIndex)].	^ (object class compile: newText classified: category notifying: editor) ~~ nil! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 11/13/1998 08:43' prior: 35945496!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	event hand hasSubmorphs ifTrue: [^ self  "no response if drag something over me"].	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 23.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsCollect: aBlock 	"Evaluate aBlock with my elements taken two at a time, and return an Array with the results"	^ (1 to: self size // 2) collect:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect:	[:a :b | b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01' prior: 21201890!pairsDo: aBlock 	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"	1 to: self size // 2 do:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !SequenceableCollection removeSelector: #adjacent:!SequenceableCollection removeSelector: #adjacent:!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:03:10 am'!"Change Set:		Balloon-1-PreparationsDate:			2 November 1998Author:			Andreas RaabSmall changes throughout the system for the following change sets."!!BitBlt methodsFor: 'private' stamp: 'ar 10/25/1998 17:30'!copyBitsFrom: x0 to: x1 at: y	destX _ x0.	destY _ y.	sourceX _ x0.	width _ (x1 - x0).	self copyBits.! !!CObjectAccessor methodsFor: 'private' stamp: 'ar 11/3/1998 22:37'!getObject	^object! !!Collection methodsFor: 'enumerating' stamp: 'ar 11/3/1998 14:11'!contains: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false"	self do:[:item|		(aBlock value: item) ifTrue:[^true].	].	^false! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:43'!isBlack	"Return true if the receiver represents black"	^rgb = 0! !!Color methodsFor: 'queries' stamp: 'ar 11/12/1998 19:44'!isGray	"Return true if the receiver represents a shade of gray"	^(self privateRed = self privateGreen) and:[self privateRed = self privateBlue]! !!Dictionary methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:22'!at: key ifAbsentPut: aBlock 	"Return the value at the given key.	If key is not included in the receiver store the result	of evaluating aBlock as new value."	^self at: key ifAbsent:[self at: key put: aBlock value]! !!Form methodsFor: 'private' stamp: 'ar 10/9/1998 23:47'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	self bitsSize = bitmap size ifFalse:[^self error:'Bad dimensions'].	bits _ bitmap! !!Form class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 23:44'!extent: extentPoint depth: bitsPerPixel bits: aBitmap	"Answer an instance of me with blank bitmap of the given dimensions and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel bits: aBitmap! !!ReadStream methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:20'!size	"Compatibility with other streams (e.g., FileStream)"	^readLimit! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:20'!identityIndexOf: anElement 	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer 0."	^self identityIndexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:21'!identityIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | (self at: i) == anElement ifTrue: [^ i]].	^ exceptionBlock value! !!Bitmap methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!FloatArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0.0! !!FloatArray methodsFor: 'private' stamp: 'ar 11/7/1998 20:17' prior: 35829139!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!WordArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:03:36 am'!"Change Set:		Balloon-2-BBChangesDate:			2 November 1998Author:			Andreas RaabAdds a new combination rule (34: alphaBlendScaled:with:) to BitBlt and a specialized inner loop for optimized execution from the graphics engine. Also fixes the check for OpTableSize in BBSim>>loadBitBltFrom:"!!BitBlt commentStamp: '<historical>' prior: 33607361!I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBltSimulation commentStamp: '<historical>' prior: 33613804!This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/31/1998 22:05' prior: 33615453!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/31/1998 20:50' prior: 33621861!copyBits	| done |	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self tryCopyingBitsQuickly.	done ifTrue:[^nil].	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/11/1998 22:29'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/14/1998 00:44'!tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34"	(combinationRule = 34) ifFalse:[^false].	"We handle only sourcePixSize 32"	(sourcePixSize = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].	"We need at least 8bit deep dest forms"	(destPixSize < 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destPixSize = 8 and:[colorMap = interpreterProxy nilObject]) ifTrue:[^false].	destPixSize = 32 		ifTrue:[self alphaSourceBlendBits32].	destPixSize = 16		ifTrue:[self alphaSourceBlendBits16].	destPixSize = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL _ dx.	affectedR _ dx + bbW.	affectedT _ dy.	affectedB _ dy + bbH.	^true! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:37'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	(dx bitAnd: 1) = 0 		ifTrue:[	mask1 _ 16r0000FFFF.				srcShift _ 16.				adjust _ 0]		ifFalse:[mask1 _ 16rFFFF0000.				srcShift _ 0.				adjust _ 16r0F0F0F0F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r0F0F0F0F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r0F0F0F0F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 2)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			"Treat srcAlpha >= 240 as opaque"			srcAlpha = 240 ifTrue:[				sourceWord _ self rgbMap: sourceWord from: 8 to: 5.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha <= 15 ifTrue:[					"Treat srcAlpha <= 15 as transparent"				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ self rgbMap: destWord from: 5 to: 8.					destWord _ destWord bitOr: 16rFF000000.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.										sourceWord _ self rgbMap: sourceWord from: 8 to: 5.					sourceWord _ sourceWord << srcShift.					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask.					interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).				].			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"			adjust _ adjust bitXor: 16r0F0F0F0F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/2/1998 02:20'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register int srcIndex'.	self var: #dstIndex declareC:'register int dstIndex'.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + dx) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ interpreterProxy longAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				interpreterProxy longAt: dstIndex put: sourceWord.				srcIndex _ srcIndex + 4.				dstIndex _ dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX _ deltaX - 1) ~= 0 and:[					(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 255]]						whileTrue:[							interpreterProxy longAt: dstIndex put: sourceWord.							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].				"Adjust deltaX"				deltaX _ deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX _ deltaX - 1) ~= 0 and:[						(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].					"Adjust deltaX"					deltaX _ deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ self alphaBlendScaled: sourceWord with: destWord.					interpreterProxy longAt: dstIndex put: destWord.					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.				].			].		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:56'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable |	self inline: false. "This particular method should be optimized in itself"	self var: #mappingTable declareC:'unsigned int *mappingTable'.	mappingTable _ self default8To32Table.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	mask1 _ 24 - ((dx bitAnd: 3) * 8).	mask2 _ AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust _ 0]		ifFalse:[adjust _ 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r1F1F1F1F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 4)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		srcShift _ mask1.		dstMask _ mask2.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ mappingTable at: destWord.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord _ self rgbMap: sourceWord from: 8 to: cmBitsPerColor.				sourceWord _ interpreterProxy fetchWord: sourceWord ofObject: colorMap.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[				dstIndex _ dstIndex + 4.				srcShift _ 24.				dstMask _ 16r00FFFFFF.			] ifFalse:[				srcShift _ srcShift - 8.				dstMask _ (dstMask >> 8) bitOr: 16rFF000000.			].			adjust _ adjust bitXor: 16r1F1F1F1F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 11/11/1998 22:33'!alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	self inline: false.	"Do NOT inline this into optimized loops"	unAlpha _ 255 - (sourceWord >> 24).  "High 8 bits of source pixel"	dstMask _ destinationWord.	srcMask _ sourceWord.	b _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	g _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	r _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	a _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	^(((((a << 8) + r) << 8) + g) << 8) + b! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 11/16/1998 00:23'!default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs _ (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex _ (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	self returnTypeC:'unsigned int *'.	self var: #theTable declareC:'static unsigned int theTable[256] = { 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};'.	^theTable! !!BitBltSimulation methodsFor: 'translation support' stamp: 'ar 10/12/1998 17:43' prior: 33647825!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'ar 10/12/1998 17:42' prior: 33650599!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:03:59 am'!"Change Set:		Balloon-3-MatrixTransformDate:			2 November 1998Author:			Andreas RaabAdds a 2x3 matrix representation for 2D geometric transformations.Also includes a Matrix2x3Plugin for several transformation primitives."!Object subclass: #DisplayTransform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Transformations'!DisplayTransform subclass: #CompositeTransform	instanceVariableNames: 'globalTransform localTransform '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Transformations'!InterpreterPlugin subclass: #Matrix2x3Plugin	instanceVariableNames: 'm23ResultX m23ResultY m23ArgX m23ArgY '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!DisplayTransform variableWordSubclass: #MatrixTransform2x3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Transformations'!DisplayTransform subclass: #MorphicTransform	instanceVariableNames: 'offset angle scale '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Transformations'!!DisplayTransform commentStamp: '<historical>' prior: 0!This class represents a base for generic transformations of 2D points between different coordinate systems (including scaling and rotation). The transformations map objects between one coordinate system and another where it is assumed that a nested hierarchy of transformations can be defined.It is assumed that transformations deal with Integer points. All transformations should return Integer coordinates (even though float points may be passed in as argument).Compositions of transformations MUST work in the following order. A 'global' transformation (the argument in #composedWithGlobal:) is defined as a transformation that takes place between the receiver (the 'local') transformation and any 'global' point computations, whereas a 'local' transformation (e.g., the argument in #composedWithLocal:) takes place between the receiver ('global') and any 'local' points. For the transformation methods this means that combining a global and a local transformation will result in the following order:		globalPointToLocal: globalPoint			"globalPoint -> globalTransform -> localTransform -> locaPoint"			^localTransform globalPointToLocal:				(globalTransform globalPointToLocal: globalPoint)		localPointToGlobal: localPoint			"localPoint -> localTransform -> globalTransform -> globalPoint"			^globalTransform localPointToGlobal:				(localTransform localPointToGlobal: localPoint)!!DisplayTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:18'!setIdentity	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:43'!inverseTransformation	"Return the inverse transformation of the receiver"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:47'!isCompositeTransform	"Return true if the receiver is a composite transformation.	Composite transformations may have impact on the accuracy."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:17'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMorphicTransform	"Return true if the receiver is a MorphicTransform, that is specifies the transformation values explicitly."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:16'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:15'!composedWithGlobal: aTransformation	"Return the composition of the receiver and the global transformation passed in.	A 'global' transformation is defined as a transformation that takes place	between the receiver (the 'local') transformation and any 'global' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	^aTransformation composedWithLocal: self! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:41'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in.	A 'local' transformation is defined as a transformation that takes place	between the receiver (the 'global') transformation and any 'local' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	self isIdentity ifTrue:[^ aTransformation].	aTransformation isIdentity ifTrue:[^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransformation! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:17'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!globalPointsToLocal: inArray	"Transform all the points of inArray from global into local coordinates"	^inArray collect:[:pt| self globalPointToLocal: pt]! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:18'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!localPointsToGlobal: inArray	"Transform all the points of inArray from local into global coordinates"	^inArray collect:[:pt| self localPointToGlobal: pt]! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^Rectangle encompassing: (self globalPointsToLocal: aRectangle corners)! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^Rectangle encompassing: (self localPointsToGlobal: aRectangle corners)! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:59'!asCompositeTransform	"Represent the receiver as a composite transformation"	^CompositeTransform new		globalTransform: self		localTransform: self species identity! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:01'!asMatrixTransform2x3	"Represent the receiver as a 2x3 matrix transformation"	^self subclassResponsibility! !!CompositeTransform commentStamp: '<historical>' prior: 17636646!A composite transform provides the effect of several levels of coordinate transformations.!!CompositeTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:00'!isCompositeTransform	^true! !!CompositeTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:45'!inverseTransformation	"Return the inverse transformation of the receiver"	^self species new		globalTransform: localTransform inverseTransformation		localTransform: globalTransform inverseTransformation! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^localTransform globalPointToLocal:		(globalTransform globalPointToLocal: aPoint)! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^globalTransform localPointToGlobal:		(localTransform localPointToGlobal: aPoint)! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:00'!asCompositeTransform	^self! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:56'!asMatrixTransform2x3	^globalTransform asMatrixTransform2x3		composedWithLocal: localTransform asMatrixTransform2x3! !!DisplayTransform class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 20:55'!identity	^self new setIdentity! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:30'!m23PrimitiveComposeMatrix	| m1 m2 m3 result |	self export: true.	self inline: false.	self var: #m1 declareC:'float *m1'.	self var: #m2 declareC:'float *m2'.	self var: #m3 declareC:'float *m3'.	m3 _ self loadArgumentMatrix: (result _ interpreterProxy stackObjectValue: 0).	m2 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	m1 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3ComposeMatrix: m1 with: m2 into: m3.	interpreterProxy pop: 3.	interpreterProxy push: result.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/2/1998 19:27'!m23PrimitiveInvertPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3InvertPoint: matrix.	self roundAndStoreResultPoint: 2.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 14:09'!m23PrimitiveInvertRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:27'!m23PrimitiveIsIdentity	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 2) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 5) = (self cCoerce: 0.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/9/1998 16:27'!m23PrimitiveIsPureTranslation	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/2/1998 19:27'!m23PrimitiveTransformPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3TransformPoint: matrix.	self roundAndStoreResultPoint: 2.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 14:09'!m23PrimitiveTransformRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 9/28/1998 00:55'!matrix2x3ComposeMatrix: m1 with: m2 into: m3	"Multiply matrix m1 with m2 and store the result into m3."	| a11 a12 a13 a21 a22 a23 |	self var: #m1 declareC:'const float *m1'.	self var: #m2 declareC:'const float *m2'.	self var: #m3 declareC:'float *m3'.	self var: #a11 declareC:'double a11'.	self var: #a12 declareC:'double a12'.	self var: #a13 declareC:'double a13'.	self var: #a21 declareC:'double a21'.	self var: #a22 declareC:'double a22'.	self var: #a23 declareC:'double a23'.	a11 _ ((m1 at: 0) * (m2 at: 0)) + ((m1 at: 1) * (m2 at: 3)).	a12 _ ((m1 at: 0) * (m2 at: 1)) + ((m1 at: 1) * (m2 at: 4)).	a13 _ ((m1 at: 0) * (m2 at: 2)) + ((m1 at: 1) * (m2 at: 5)) + (m1 at: 2).	a21 _ ((m1 at: 3) * (m2 at: 0)) + ((m1 at: 4) * (m2 at: 3)).	a22 _ ((m1 at: 3) * (m2 at: 1)) + ((m1 at: 4) * (m2 at: 4)).	a23 _ ((m1 at: 3) * (m2 at: 2)) + ((m1 at: 4) * (m2 at: 5)) + (m1 at: 5).	m3 at: 0 put: (self cCoerce: a11 to: 'float').	m3 at: 1 put: (self cCoerce: a12 to: 'float').	m3 at: 2 put: (self cCoerce: a13 to: 'float').	m3 at: 3 put: (self cCoerce: a21 to: 'float').	m3 at: 4 put: (self cCoerce: a22 to: 'float').	m3 at: 5 put: (self cCoerce: a23 to: 'float').! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 11/2/1998 03:37'!matrix2x3InvertPoint: m	"Invert the pre-loaded argument point by the given matrix"	| x y det detX detY |	self var: #m declareC:'float *m'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #det declareC:'double det'.	self var: #detX declareC:'double detX'.	self var: #detY declareC:'double detY'.	x _ m23ArgX - (m at: 2).	y _ m23ArgY - (m at: 5).	det _ ((m at: 0) * (m at: 4)) - ((m at: 1) * (m at: 3)).	det = 0.0 ifTrue:[^interpreterProxy primitiveFail]."Matrix is singular."	det _ 1.0 / det.	detX _ (x * (m at: 4)) - ((m at: 1) * y).	detY _ ((m at: 0) * y) - (x * (m at: 3)).	m23ResultX _ detX * det.	m23ResultY _ detY * det.! !!Matrix2x3Plugin methodsFor: 'transforming' stamp: 'ar 11/9/1998 16:23'!matrix2x3TransformPoint: m	"Transform the pre-loaded argument point by the given matrix"	self var: #m declareC:'float *m'.	m23ResultX _ (m23ArgX * (m at: 0)) + (m23ArgY * (m at: 1)) + (m at: 2).	m23ResultY _ (m23ArgX * (m at: 3)) + (m23ArgY * (m at: 4)) + (m at: 5).! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/9/1998 15:17'!loadArgumentMatrix: matrix	"Load the argument matrix"	self returnTypeC:'float *'.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: matrix) and:[(interpreterProxy slotSizeOf: matrix) = 6]) 		ifFalse:[interpreterProxy primitiveFail.				^nil].	^self cCoerce: (interpreterProxy firstIndexableField: matrix) to:'float *'.! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/9/1998 16:17'!loadArgumentPoint: point	"Load the argument point into m23ArgX and m23ArgY"	| oop isInt |	interpreterProxy failed ifTrue:[^nil].	"Check class of point"	(interpreterProxy fetchClassOf: point) = (interpreterProxy classPoint) 		ifFalse:[^interpreterProxy primitiveFail].	"Load X value"	oop _ interpreterProxy fetchPointer: 0 ofObject: point.	isInt _ interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgX _ interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgX _ interpreterProxy floatValueOf: oop].	"Load Y value"	oop _ interpreterProxy fetchPointer: 1 ofObject: point.	isInt _ interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgY _ interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgY _ interpreterProxy floatValueOf: oop].! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:37'!okayIntValue: value	^(value >= -1073741824 asFloat and:[m23ResultX <= 1073741823 asFloat]) ! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:39'!roundAndStoreResultPoint: nItemsToPop	"Store the result of a previous operation.	Fail if we cannot represent the result as SmallInteger"	m23ResultX _ m23ResultX + 0.5.	m23ResultY _ m23ResultY + 0.5.	(self okayIntValue: m23ResultX) ifFalse:[^interpreterProxy primitiveFail].	(self okayIntValue: m23ResultY) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: nItemsToPop.	interpreterProxy push:		(interpreterProxy makePointwithxValue: m23ResultX asInteger 							yValue: m23ResultY asInteger).! !!Matrix2x3Plugin methodsFor: 'private' stamp: 'ar 11/14/1998 02:38'!roundAndStoreResultRect: dstOop x0: x0 y0: y0 x1: x1 y1: y1	"Check, round and store the result of a rectangle operation"	| minX maxX minY maxY originOop cornerOop rectOop |	self var: #x0 declareC:'double x0'.	self var: #y0 declareC:'double y0'.	self var: #x1 declareC:'double x1'.	self var: #y1 declareC:'double y1'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	minX _ x0 + 0.5.	(self okayIntValue: minX) ifFalse:[^interpreterProxy primitiveFail].	maxX _ x1 + 0.5.	(self okayIntValue: maxX) ifFalse:[^interpreterProxy primitiveFail].	minY _ y0 + 0.5.	(self okayIntValue: minY) ifFalse:[^interpreterProxy primitiveFail].	maxY _ y1 + 0.5.	(self okayIntValue: maxY) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: dstOop.	originOop _ interpreterProxy makePointwithxValue: minX asInteger yValue: minY asInteger.	interpreterProxy pushRemappableOop: originOop.	cornerOop _ interpreterProxy makePointwithxValue: maxX asInteger yValue: maxY asInteger.	originOop _ interpreterProxy popRemappableOop.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: originOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: cornerOop.	^rectOop! !!Matrix2x3Plugin class methodsFor: 'class initialization' stamp: 'ar 11/2/1998 03:39'!declareCVarsIn: cg	cg var: 'm23ResultX' declareC:'double m23ResultX'.	cg var: 'm23ResultY' declareC:'double m23ResultY'.	cg var: 'm23ArgX' declareC:'double m23ArgX'.	cg var: 'm23ArgY' declareC:'double m23ArgY'.! !!MatrixTransform2x3 commentStamp: '<historical>' prior: 0!This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix containing the transformation from the local coordinate system in the global coordinate system. Thus, transforming points from local to global coordinates is fast and cheap whereas transformations from global to local coordinate systems are relatively expensive.Implementation Note: It is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here).!!MatrixTransform2x3 methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:17'!setIdentiy	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	self		a11: 1.0; a12: 0.0; a13: 0.0;		a21: 0.0; a22: 1.0; a23: 0.0.! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 16:28'!at: index	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 16:28'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:15'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r1.	r2 _ (self invertPoint: 0@1) - r1.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:19'!offset	^self a13 @ self a23! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:05'!offset: aPoint	self a13: aPoint x asFloat.	self a23: aPoint y asFloat.! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a11	^self at: 1! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a11: value	 self at: 1 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a12	^self at: 2! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a12: value	 self at: 2 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a13	^self at: 3! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a13: value	 self at: 3 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a21	 ^self at: 4! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a21: value	 self at: 4 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a22	 ^self at: 5! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a22: value	 self at: 5 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a23	 ^self at: 6! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a23: value	 self at: 6 put: value! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:05'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	<primitive: 'm23PrimitiveIsIdentity'>	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:15'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^true! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:06'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	<primitive: 'm23PrimitiveIsPureTranslation'>	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 11/2/1998 19:32'!= MatrixTransform2x3	| length |	<primitive:'primitiveFloatArrayEqual'>	self class = MatrixTransform2x3 class ifFalse:[^false].	length _ self size.	(length = MatrixTransform2x3 size) ifFalse:[^false].	1 to: self size do:[:i| (self at: i) = (MatrixTransform2x3 at: i) ifFalse:[^false]].	^true! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 11/2/1998 19:31'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 19:50'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in"	aTransformation isMatrixTransform2x3 ifFalse:[^super composedWith: aTransformation].	^self composedWithLocal: aTransformation asMatrixTransform2x3 into: self class new! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 23:08'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'm23PrimitiveComposeMatrix'>	matrix _ aTransformation asMatrixTransform2x3.	a11 _ self a11.		b11 _ matrix a11.	a12 _ self a12.		b12 _ matrix a12.	a13 _ self a13.		b13 _ matrix a13.	a21 _ self a21.		b21 _ matrix a21.	a22 _ self a22.		b22 _ matrix a22.	a23 _ self a23.		b23 _ matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/9/1998 13:46'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	<primitive: 'm23PrimitiveInvertPoint'>	^(self invertPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/2/1998 23:09'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a22.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/3/1998 03:04'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'm23PrimitiveTransformPoint'>	^(self transformPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/2/1998 23:09'!transformPoint: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!globalBounds: srcRect toLocal: dstRect	"Transform aRectangle from global coordinates into local coordinates"	<primitive:'m23PrimitiveInvertRectInto'>	^super globalBoundsToLocal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^self globalBounds: aRectangle toLocal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!localBounds: srcRect toGlobal: dstRect	"Transform aRectangle from local coordinates into global coordinates"	<primitive:'m23PrimitiveTransformRectInto'>	^super localBoundsToGlobal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^self localBounds: aRectangle toGlobal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'converting' stamp: 'ar 11/2/1998 15:34'!asMatrixTransform2x3	^self! !!MatrixTransform2x3 methodsFor: 'printing' stamp: 'ar 11/2/1998 23:11'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		cr; print: self a11; tab; print: self a12; tab; print: self a13;		cr; print: self a21; tab; print: self a22; tab; print: self a23;		cr; nextPut:$).! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 16:28'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/15/1998 23:12'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setAngle: angle	"Set the raw rotation angle in the receiver"	| rad s c |	rad := angle degreesToRadians.	s := rad sin.	c := rad cos.	self a11: c.	self a12: s negated.	self a21: s.	self a22: c.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setOffset: aPoint	"Set the raw offset in the receiver"	| pt |	pt _ aPoint asPoint.	self a13: pt x asFloat.	self a23: pt y asFloat.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:16'!setScale: aPoint	"Set the raw scale in the receiver"	| pt |	pt _ aPoint asPoint.	self a11: pt x asFloat.	self a22: pt y asFloat.! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 22:50'!identity	^self new setScale: 1.0! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 7/9/1998 20:09'!new	^self new: 6! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 01:25'!transformFromLocal: localBounds toGlobal: globalBounds	^((self withOffset: (globalBounds center)) composedWithLocal:		(self withScale: (globalBounds extent / localBounds extent) asFloatPoint))			composedWithLocal: (self withOffset: localBounds center negated)"	^(self identity)		setScale: (globalBounds extent / localBounds extent) asFloatPoint;		setOffset: localBounds center negated asFloatPoint;		composedWithGlobal:(self withOffset: globalBounds center asFloatPoint)"! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withAngle: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 02:52'!withOffset: aPoint	^self identity setOffset: aPoint! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:17'!withRotation: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withScale: aPoint	^self new setScale: aPoint! !!MorphicTransform commentStamp: '<historical>' prior: 20017969!This class implements simple translation, scaling and rotation for points, as well as inverse transformations.  These transformations are used in TransformMorphs (clipping scrollers) and TransformationMorphs (general flex-morph wrappers) to map, eg, global mouse coords into local coords, and to invert, eg, local damage rectangles into global damage rectangles.!!MorphicTransform methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:33'!inverseTransformation	"Return the inverse transformation of the receiver"	^MorphicTransform		offset: (self transform: 0@0) - (self transform: offset)		angle: angle negated		scale: scale reciprocal! !!MorphicTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 20:58'!setIdentiy	scale _ 1.0.	offset _ 0@0.	angle _ 0.0.! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57' prior: 20020332!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ self isPureTranslation and: [offset = (0@0)]! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 19:51'!isMorphicTransform	^true! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57' prior: 20020562!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^ angle = 0.0 and: [scale = 1.0]! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:13'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self transform: aPoint! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:32'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self invert: aPoint! !!MorphicTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:14'!asMatrixTransform2x3	^((MatrixTransform2x3 withRotation: angle radiansToDegrees negated) composedWithLocal:		(MatrixTransform2x3 withScale: scale))			offset: offset negated! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:18 am'!!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/15/1998 23:42' prior: 19908924!addMorphFront: aMorph fromWorldPosition: wp	self addMorphFront: aMorph.	aMorph position: (self transformFromWorld globalPointToLocal: wp)! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44' prior: 35505585!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) localBoundsToGlobal: bounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44' prior: 35505768!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) localBoundsToGlobal: self fullBounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42' prior: 35489482!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:43' prior: 19915686!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) localPointToGlobal: aPoint.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/15/1998 23:41' prior: 35493800!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		newOwner _ self dropTargetFor: m event: evt.		newOwner ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		morphToDrop _ newOwner morphToDropFrom: m. 		morphToDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!MorphicEvent methodsFor: 'mouse' stamp: 'ar 11/15/1998 23:42' prior: 19995490!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform globalPointToLocal: cursorPoint)! !!MovieMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42' prior: 34726227!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!PluggableListMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:45' prior: 35507423!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) localBoundsToGlobal: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'ar 11/15/1998 23:45' prior: 36304817!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(model listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) localBoundsToGlobal: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'ar 11/15/1998 23:45' prior: 35507745!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!SketchMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42' prior: 35151918!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!TextMorph methodsFor: 'anchors' stamp: 'ar 11/15/1998 23:42' prior: 22023143!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphFront: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld globalPointToLocal: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42' prior: 22130592!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42' prior: 22131082!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:44' prior: 35560368!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform globalBoundsToLocal:					(aCanvas clipRect intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:44' prior: 35568861!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform globalBoundsToLocal: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !!TransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42' prior: 35562112!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform globalPointToLocal: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !!TransformMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45' prior: 35512474!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: ((transform localBoundsToGlobal: damageRect) intersect: bounds)! !!TransformationMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 23:43' prior: 35347734!referencePosition	^ transform localPointToGlobal: self renderedMorph referencePosition! !!TransformationMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45' prior: 35512769!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (transform localBoundsToGlobal:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds])))				expandBy: 1].	super layoutChanged! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:34 am'!Object subclass: #CompressedBoundaryShape	instanceVariableNames: 'points leftFills rightFills lineWidths lineFills fillStyles '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!Object subclass: #FillStyle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!Object subclass: #LineSegment	instanceVariableNames: 'start end '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!LineSegment subclass: #Bezier2Segment	instanceVariableNames: 'via '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!FillStyle subclass: #OrientedFillStyle	instanceVariableNames: 'origin direction normal '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!OrientedFillStyle subclass: #BitmapFillStyle	instanceVariableNames: 'form '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!OrientedFillStyle subclass: #GradientFillStyle	instanceVariableNames: 'colorRamp pixelRamp radial '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!IntegerArray variableWordSubclass: #PointArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ArrayedCollection variableWordSubclass: #ShortIntegerArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ShortIntegerArray variableWordSubclass: #ShortPointArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ArrayedCollection variableWordSubclass: #ShortRunArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!FillStyle subclass: #SolidFillStyle	instanceVariableNames: 'color pixelValue32 '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!!BitmapFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/13/1998 20:32'!form: aForm	^self new form: aForm! !!Color methodsFor: 'access' stamp: 'ar 11/8/1998 18:33'!pixelValue32	^self pixelWordForDepth: 32! !!Color methodsFor: 'queries' stamp: 'ar 11/7/1998 20:20'!isSolidFill	^true! !!Color methodsFor: 'conversions' stamp: 'ar 11/2/1998 12:19'!asColor	"Convert the receiver into a color"	^self! !!CompressedBoundaryShape commentStamp: '<historical>' prior: 0!This class represents a very compact representation of a boundary shape. It consists of a number of compressed arrays that can be handled by the balloon engine directly. Due to this, there are certain restrictions (see below). Boundaries are always represented by three subsequent points that define a quadratic bezier segment. It is recommended that for straight line segments the control point is set either to the previous or the next point.Instance variables:	points		<PointArray | ShortPointArray>	Point storage area	leftFills		<ShortRunArray>	Containing the "left" fill index of each segment	rightFills	<ShortRunArray>	Containing the "right" fill index of each segment	lineWidths	<ShortRunArray>	Containing the line width of each segment	lineFills		<ShortRunArray>	Containing the line fill (e.g., line color) of each segment	fillStyles	<Collections>			Contains the actual fill styles referenced by the indexesRESTRICTIONS:None of the ShortRunArrays may contain a run of length Zero.Also, due to the use of ShortRunArrays 	a) you cannot have more than 32768 different fill styles	b) you cannot have a line width that exceeds 32768In case you have trouble with a), try to merge some of the fills into one. You might do so by converting colors to 32bit pixel values. In case you have trouble with b) you might change the general resolution of the compressed shape to have less accuracy.!!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:23'!bounds	| min max width |	points isEmpty ifTrue:[^0@0 corner: 1@1].	min _ max _ points first.	points do:[:pt|		min _ min min: pt.		max _ max max: pt	].	width _ 0.	lineWidths valuesDo:[:w| width _ width max: w].	^(min corner: max) insetBy: (w negated asPoint)! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!fillStyles	^fillStyles! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!leftFills	^leftFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineFills	^lineFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineWidths	^lineWidths! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/4/1998 13:50'!numSegments	^points size // 3! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 20:42'!points	^points! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!rightFills	^rightFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:09'!segments	"Return all the segments in the receiver"	| out |	out _ WriteStream on: Array new.	self segmentsDo:[:seg| out nextPut: seg].	^out contents! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:12'!collectFills: aBlock	fillStyles _ fillStyles collect: aBlock.! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:11'!copyAndCollectFills: aBlock	^self copy collectFills: aBlock! !!CompressedBoundaryShape methodsFor: 'enumerating' stamp: 'ar 11/9/1998 14:10'!segmentsDo: aBlock	"Enumerate all segments in the receiver and execute aBlock"	| p1 p2 p3 |	1 to: points size by: 3 do:[:i|		p1 _ points at: i.		p2 _ points at: i+1.		p3 _ points at: i+2.		(p1 = p2 or:[p2 = p3]) ifTrue:[			aBlock value: (LineSegment from: p1 to: p3).		] ifFalse:[			aBlock value: (Bezier2Segment from: p1 via: p2 to: p3).		].	].! !!CompressedBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 18:03'!setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	points _ pointList.	leftFills _ leftFillList.	rightFills _ rightFillList.	lineWidths _ lineWidthList.	lineFills _ lineFillList.	fillStyles _ fillStyleList.! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 16:28'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 18:02'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList! !!FillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 13:53'!pixelValue32	"Return a pixel value of depth 32 for the primary color in the fill style"	^self asColor pixelWordForDepth: 32! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isBitmapFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isGradientFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isSolidFill	^false! !!FillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:53'!asColor	^self subclassResponsibility! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/9/1998 14:05'!ramp: colorRamp	^self new colorRamp: colorRamp! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/10/1998 19:13'!sample	"GradientFill sample"	^(self ramp: { 0.0 -> Color red. 0.5 -> Color green. 1.0 -> Color blue})		origin: 300 @ 300;		direction: 400@0;		normal: 0@400;		radial: true;	yourself! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!LineSegment commentStamp: '<historical>' prior: 0!This class represents a straight line segment between two pointsInstance variables:	start	<Point>	start point of the line	end		<Point>	end point of the line!!LineSegment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:12'!from: startPoint to: endPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!bounds	"Return the bounds containing the receiver"	^(start min: end) corner: (start max: end)! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!end	"Return the end point"	^end! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!start	"Return the start point"	^start! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:12'!hasZeroLength	"Return true if the receiver has zero length"	^start = end! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^false! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isLineSegment	"Return true if the receiver is a line segment"	^true! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:08'!isStraight	"Return true if the receiver represents a straight line"	^true! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!length	"Return the length of the receiver"	^start dist: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	aBlock value: start value: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	^end - start! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtEnd	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtStart	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	^start + (end - start * parameter)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtEnd	"Evaluate the receiver at it's end point (e.g., self valueAtEnd = (self valueAt: 1.0))"	^end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtStart	"Evaluate the receiver at it's start point (e.g., self valueAtEnd = (self valueAt: 0.0))"	^start! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^Bezier2Segment from: start to: end! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asIntegerSegment	"Convert the receiver into integer representation"	^self species from: start asIntegerPoint to: end asIntegerPoint! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asLineSegment	"Represent the receiver as a straight line segment"	^self! !!LineSegment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:13'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' to: ';		print: end;		space.! !!LineSegment methodsFor: 'private' stamp: 'ar 11/6/1998 15:05'!debugDraw	| canvas |	canvas _ FormCanvas on: Display.	self lineSegmentsDo:[:p1 :p2|		canvas line: p1 rounded to: p2 rounded width: 1 color: Color black.	].! !!Bezier2Segment commentStamp: '<historical>' prior: 0!This class represents a quadratic bezier segment between two pointsInstance variables:	via		<Point>	The additional control point (OFF the curve)!!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint	"Initialize the receiver as straight line"	start _ startPoint.	end _ endPoint.	via _ (start + end) // 2.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint via: viaPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.	via _ viaPoint.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve	"Initialize the receiver with the pointOnCurve assumed at the parametric value 0.5"	start _ startPoint.	end _ endPoint.	"Compute via"	via _ (pointOnCurve * 2) - ((start+end) // 2).! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	"Initialize the receiver with the pointOnCurve at the given parametric value"	| t1 t2 t3 |	start _ startPoint.	end _ endPoint.	"Compute via"	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	via _ (pointOnCurve * t2) - (start * t1)  - (end * t3)! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!bounds	"Return the bounds containing the receiver"	^super bounds encompass: via! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!via	"Return the control point"	^via! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!hasZeroLength	"Return true if the receiver has zero length"	^start = end and:[start = via]! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^true! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isStraight	"Return true if the receiver represents a straight line"	^(self tangentAtStart crossProduct: self tangentAtEnd) = 0! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:15'!length	"Return the length of the receiver"	"Note: Overestimates the length"	^(start dist: via) + (via dist: end)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/6/1998 23:39'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| steps last deltaStep t next |	steps _ 1 max: (self length // 10). "Assume 10 pixels per step"	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	| in out |	in _ self tangentAtStart.	out _ self tangentAtEnd.	^in + (out - in * parameter)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtEnd	"Return the tangent for the last point"	^end - via! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtStart	"Return the tangent for the first point"	^via - start! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:17'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	"Return the point at the parametric value t:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:17'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^self! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:18'!asIntegerSegment	"Convert the receiver into integer representation"	^self species 			from: start asIntegerPoint 			to: end asIntegerPoint 			via: via asIntegerPoint! !!Bezier2Segment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:18'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' via: ';		print: via;		nextPutAll: ' to: ';		print: end;		space.! !!LineSegment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:10'!from: startPoint to: endPoint	^self new from: startPoint to: endPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:14'!from: startPoint to: endPoint via: viaPoint	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint to: endPoint withMidPoint: pointOnCurve	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint via: viaPoint to: endPoint 	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint withMidPoint: pointOnCurve at: parameter to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint withMidPoint: pointOnCurve to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction	^direction! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction: aPoint	direction _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:31'!normal	^normal ifNil:[normal _ direction y negated @ direction x]! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!normal: aPoint	normal _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin	^origin! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin: aPoint	origin _ aPoint.! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form	^form! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form: aForm	form _ aForm! !!BitmapFillStyle methodsFor: 'testing' stamp: 'ar 11/11/1998 22:40'!isBitmapFill	^true! !!BitmapFillStyle methodsFor: 'converting' stamp: 'ar 11/11/1998 22:41'!asColor	^form colorAt: 0@0! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:10'!colorRamp	^colorRamp! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:00'!colorRamp: anArray	colorRamp _ anArray.	pixelRamp _ nil.! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:07'!pixelRamp	^pixelRamp ifNil:[pixelRamp _ self computePixelRampOfSize: 256].! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!pixelRamp: aBitmap	pixelRamp _ aBitmap! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!radial	^radial! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:11'!radial: aBoolean	radial _ aBoolean! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isGradientFill	^true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:13'!isRadialFill	^radial == true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isSolidFill	^false! !!GradientFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 14:07'!asColor	^colorRamp first value! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 14:09'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta color lastValue ramp |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		lastIndex+1 to: nextIndex do:[:i|			theta _ (i - lastIndex) asFloat / distance asFloat.			color _ nextColor mixed: theta with: lastColor.			bits at: i put: (color pixelWordForDepth: 32).		].		lastIndex _ nextIndex.		lastColor _ nextColor.	].	lastValue _ lastColor pixelWordForDepth: 32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 16:56'!display	| f ramp |	ramp _ self pixelRamp.	f _ Form extent: ramp size @ 1 depth: 32 bits: ramp.	1 to: 100 do:[:i| f displayAt: 1@i].	[Sensor anyButtonPressed] whileFalse.	[Sensor anyButtonPressed] whileTrue.! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y@x! !!PointArray commentStamp: '<historical>' prior: 0!This class stores 32bit Integer points in place. It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0@0! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!size	"Return the number of elements in the receiver"	^super size // 2! !!PointArray class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 00:04'!new: n	^super new: n*2! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!defaultElement	^0! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!size	^super size * 2! !!ShortPointArray commentStamp: '<historical>' prior: 0!This class stores points that are in short integer range (e.g., -32767 <= value <= 32768). It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!defaultElement	"Return the default element of the receiver"	^0@0! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!size	^self basicSize! !!ShortRunArray commentStamp: '<historical>' prior: 0!This class is run-length encoded representation of short integer (e.g., 16bit signed integer values)!!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:26'!at: index	"Return the short value at the given index"	| rlIndex |	index < 1 ifTrue:[^self errorSubscriptBounds: index].	rlIndex _ index.	self lengthsAndValuesDo:[:runLength :runValue|		rlIndex <= runLength ifTrue:[^runValue].		rlIndex _ rlIndex - runLength].	"Not found. Must be out of range"	^self errorSubscriptBounds: index! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:18'!at: index put: value	"ShortRunArrays are read-only"	^self shouldNotImplement.! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:39'!compressionRatio	"Return the compression ratio.	The compression ratio is computed based	on how much space would be needed to	store the receiver in a ShortIntegerArray"	^(self size asFloat * 0.5) "Would need only half of the amount in ShortIntegerArray"		/ (self runSize max: 1)! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:21'!lengthAtRun: index	"Return the length of the run starting at the given index"	^(self basicAt: index) bitShift: -16! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!runSize	"Return the number of runs in the receiver"	^self basicSize! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!size	"Return the number of elements stored in the receiver"	| n |	n _ 0.	"Note: The following loop is open-coded for speed"	1 to: self basicSize do:[:i|		n _ n + ((self basicAt: i) bitShift: -16).	].	^n! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:29'!species	"Answer the preferred class for reconstructing the receiver."	^ShortIntegerArray! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:22'!valueAtRun: index	"Return the value of the run starting at the given index"	| uShort |	uShort _ (self basicAt: index) bitAnd: 16rFFFF.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:31'!do: aBlock	"Evaluate aBlock with all elements of the receiver"	self lengthsAndValuesDo:[:runLength :runValue|		"Use to:do: instead of timesRepeat: for compiler optimization"		1 to: runLength do:[:i|			aBlock value: runValue.		].	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:25'!lengthsAndValuesDo: aBlock	"Evaluate aBlock with the length and value of each run in the receiver"	| basicValue length value |	1 to: self basicSize do:[:i|		basicValue _ self basicAt: i.		length _ basicValue bitShift: -16.		value _ basicValue bitAnd: 16rFFFF.		value _ (value bitAnd: 16r7FFF) - (value bitAnd: 16r8000).		aBlock value: length value: value.	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 21:05'!valuesCollect: aBlock	"Evaluate aBlock with each of the receiver's values as the argument. 	Collect the resulting values into a collection like the receiver. Answer 	the new collection."	| newArray newValue |	newArray _ self class basicNew: self basicSize.	1 to: self runSize do:[:i|		newValue _ aBlock value: (self valueAtRun: i).		newArray setRunAt: i toLength: (self lengthAtRun: i) value: newValue.	].	^newArray! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/15/1998 17:22'!valuesDo: aBlock	self lengthsAndValuesDo:[:runLength :runValue| aBlock value: runValue]! !!ShortRunArray methodsFor: 'printing' stamp: 'ar 11/3/1998 17:41'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll:' ( '.	self lengthsAndValuesDo:[:runLength :runValue |		aStream			nextPutAll:' (';			print: runLength;			space;			print: runValue;			nextPut:$).	].	aStream nextPutAll:' )'.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:02'!setRunAt: i toLength: runLength value: value	(value < -16r7FFF or:[value > 16r8000]) ifTrue:[^self errorImproperStore].	(runLength < 0 or:[runLength > 16rFFFF]) ifTrue:[^self errorImproperStore].	self basicAt: i put: (runLength bitShift: 16) + 		((value bitAnd: 16r7FFF) - (value bitAnd: -16r8000)).! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:00'!setRuns: runArray values: valueArray	| runLength value |	1 to: runArray size do:[:i|		runLength _ runArray at: i.		value _ valueArray at: i.		self setRunAt: i toLength: runLength value: value.	].! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!new: n	"ShortRunArrays must be created with either		someCollection as: ShortRunArray	or by using		ShortRunArray runs: runCollection values: valueCollection.	"	^self shouldNotImplement! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:35'!newFrom: aCollection	"Compress aCollection into a ShortRunArray"	| lastValue lastRun runs values |	aCollection isEmpty ifTrue:[^self runs:#() values: #()].	runs _ WriteStream on: (WordArray new: 100).	values _ WriteStream on: (ShortIntegerArray new: 100).	lastValue _ aCollection first.	lastRun _ 0.	aCollection do:[:item|		(item = lastValue and:[lastRun < 16r8000]) ifTrue:[			lastRun _ lastRun + 1.		] ifFalse:[			runs nextPut: lastRun.			values nextPut: lastValue.			lastRun _ 1.			lastValue _ item.		].	].	runs nextPut: lastRun.	values nextPut: lastValue.	^self runs: runs contents values: values contents! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!runs: runCollection values: valueCollection	^(self basicNew: runCollection size) setRuns: runCollection values: valueCollection! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/8/1998 18:31'!color: aColor	color _ aColor.	pixelValue32 _ aColor pixelWordForDepth: 32.! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 03:29'!display	^color display! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/8/1998 18:32'!pixelValue32	^pixelValue32! !!SolidFillStyle methodsFor: 'testing' stamp: 'ar 11/8/1998 18:34'!isSolidFill	^true! !!SolidFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:55'!asColor	^color! !!SolidFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/8/1998 18:31'!color: aColor	^self new color: aColor! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:49 am'!"Change Set:		Balloon-6-EngineDate:			11 October 1998Author:			Andreas RaabDefines the actual graphics execution engine.BalloonEngineBase defines the base level of execution for graphical primitives that are executed either at primitive level or by Smalltalk code. BalloonEnginePlugin defines methods for dealing with graphical primitives (currently, bezier and line representations) at the primitive level."(Smalltalk includesKey: #BalloonEngineConstants) ifFalse:[	Smalltalk declare: #BalloonEngineConstants from: Undeclared.].(Smalltalk at: #BalloonEngineConstants) isNil ifTrue:[	(Smalltalk associationAt: #BalloonEngineConstants) value: Dictionary new.].!Object subclass: #BalloonBezierSimulation	instanceVariableNames: 'start end via lastX lastY fwDx fwDy fwDDx fwDDy maxSteps '	classVariableNames: 'HeightSubdivisions LineConversions MonotonSubdivisions OverflowSubdivisions '	poolDictionaries: ''	category: 'Balloon-Simulation'!Object variableWordSubclass: #BalloonBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonEdgeData	instanceVariableNames: 'index xValue yValue zValue lines source '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonEngine	instanceVariableNames: 'workBuffer span bitBlt clipRect destOffset externals aaLevel '	classVariableNames: 'BezierStats BufferCache CacheProtect Counts Debug Times '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine engineStopped geProfileTime edgeTransform dispatchedValue dispatchReturnValue '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!BalloonEngineBase subclass: #BalloonEnginePlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!BalloonEnginePlugin subclass: #BalloonEngineSimulation	instanceVariableNames: 'bbObj '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonFillData	instanceVariableNames: 'index minX maxX yValue source destForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonLineSimulation	instanceVariableNames: 'start end xIncrement xDirection error errorAdjUp errorAdjDown '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonSolidFillSimulation	instanceVariableNames: 'color '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!FormCanvas subclass: #BalloonCanvas	instanceVariableNames: 'transform transformStack engine aaLevel '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end	^end! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end: aPoint	end _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!inTangent	"Return the tangent at the start point"	^via - start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialZ	^0 "Assume no depth given"! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!outTangent	"Return the tangent at the end point"	^end - via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start	^start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start: aPoint	start _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via	^via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via: aPoint	via _ aPoint! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:46'!computeInitialStateFrom: source with: transformation	"Compute the initial state in the receiver."	start _ (transformation localPointToGlobal: source start) asIntegerPoint.	end _ (transformation localPointToGlobal: source end) asIntegerPoint.	via _ (transformation localPointToGlobal: source via) asIntegerPoint.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:39'!computeSplitAt: t	"Split the receiver at the parametric value t"	| left right newVia1 newVia2 newPoint |	left _ self clone.	right _ self clone.	"Compute new intermediate points"	newVia1 _ (via - start) * t + start.	newVia2 _ (end - via) * t + via.	"Compute new point on curve"	newPoint _ ((newVia1 - newVia2) * t + newVia2) asIntegerPoint.	left via: newVia1 asIntegerPoint.	left end: newPoint.	right start: newPoint.	right via: newVia2 asIntegerPoint.	^Array with: left with: right! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 01:34'!floatStepToFirstScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.	"self xDirection: xDir.	self yDirection: yDir."	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:45'!floatStepToNextScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	[yValue asFloat > lastY] whileTrue:[		(fwDx < -50.0 or:[fwDx > 50.0]) ifTrue:[self halt].		(fwDy < -50.0 or:[fwDy > 50.0]) ifTrue:[self halt].		(fwDDx < -50.0 or:[fwDDx > 50.0]) ifTrue:[self halt].		(fwDDy < -50.0 or:[fwDDy > 50.0]) ifTrue:[self halt].		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.	].	edgeTableEntry xValue: lastX asInteger.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 16:23'!intStepToFirstScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	squaredStepSize = ((scaledStepSize * scaledStepSize) bitShift: -24)		ifFalse:[self error:'Bad computation'].	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 04:02'!intStepToNextScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	[maxSteps >= 0 and:[yValue * 256 > lastY]] whileTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].	edgeTableEntry xValue: lastX // 256.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 22:14'!isMonoton	"Return true if the receiver is monoton along the y-axis,	e.g., check if the tangents have the same sign"	^(via y - start y) * (end y - via y) >= 0! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/31/1998 16:36'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	^self intStepToFirstScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 03:40'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	^self intStepToNextScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/1/1998 00:31'!subdivide	"Subdivide the receiver"	| dy dx |	"Test 1: If the bezier curve is not monoton in Y, we need a subdivision"	self isMonoton ifFalse:[		MonotonSubdivisions _ MonotonSubdivisions + 1.		^self subdivideToBeMonoton].	"Test 2: If the receiver is horizontal, don't do anything"	(end y = start y) ifTrue:[^nil].	"Test 3: If the receiver can be represented as a straight line,			make a line from the receiver and declare it invalid"	((end - start) crossProduct: (via - start)) = 0 ifTrue:[		LineConversions _ LineConversions + 1.		^self subdivideToBeLine].	"Test 4: If the height of the curve exceeds 256 pixels, subdivide 			(forward differencing is numerically not very stable)"	dy _ end y - start y.	dy < 0 ifTrue:[dy _ dy negated].	(dy > 255) ifTrue:[		HeightSubdivisions _ HeightSubdivisions + 1.		^self subdivideAt: 0.5].	"Test 5: Check if the incremental values could possibly overflow the scaled integer range"	dx _ end x - start x.	dx < 0 ifTrue:[dx _ dx negated].	dy * 32 < dx ifTrue:[		OverflowSubdivisions _ OverflowSubdivisions + 1.		^self subdivideAt: 0.5].	^nil! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 22:13'!subdivideAt: parameter	"Subdivide the receiver at the given parameter"	| both |	(parameter <= 0.0 or:[parameter >= 1.0]) ifTrue:[self halt].	both _ self computeSplitAt: parameter.	"Transcript cr.	self quickPrint: self.	Transcript space.	self quickPrint: both first.	Transcript space.	self quickPrint: both last.	Transcript endEntry."	self via: both first via.	self end: both first end.	^both last! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/11/1998 22:15'!subdivideToBeLine	"Not a true subdivision.	Just return a line representing the receiver and fake me to be of zero height"	| line |	line _ BalloonLineSimulation new.	line start: start.	line end: end.	"Make me invalid"	end _ start.	via _ start.	 ^line! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:24'!subdivideToBeMonoton	"Subdivide the receiver at it's extreme point"	| v1 v2 t other |	v1 _ (via - start).	v2 _ (end - via).	t _ (v1 y / (v2 y - v1 y)) negated asFloat.	other _ self subdivideAt: t.	self isMonoton ifFalse:[self halt].	other isMonoton ifFalse:[self halt].	^other! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 16:37'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| halfWord1 halfWord2 result |	(value >= 0 and:[value < 16r1000000]) ifFalse:[^self error:'Value out of range'].	halfWord1 _ value bitAnd: 16rFFFF.	halfWord2 _ (value bitShift: -16) bitAnd: 255.	result _ (halfWord1 * halfWord1) bitShift: -16. "We don't need the lower 16bits at all"	result _ result + ((halfWord1 * halfWord2) * 2).	result _ result + ((halfWord2 * halfWord2) bitShift: 16).	"word1 _ halfWord1 * halfWord1.	word2 _ (halfWord2 * halfWord1) + (word1 bitShift: -16).	word1 _ word1 bitAnd: 16rFFFF.	word2 _ word2 + (halfWord1 * halfWord2).	word2 _ word2 + ((halfWord2 * halfWord2) bitShift: 16)."	^result bitShift: -8! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDraw	| entry minY maxY lX lY canvas |	entry _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	self stepToFirstScanLineAt: minY in: entry.	lX _ entry xValue.	lY _ entry yValue.	minY+1 to: maxY do:[:y|		self stepToNextScanLineAt: y in: entry.		canvas line: lX@lY to: entry xValue @ y width: 2 color: Color black.		lX _ entry xValue.		lY _ y.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!debugDraw2	| canvas last max t next |	canvas _ FormCanvas on: Display.	max _ 100.	last _ nil.	0 to: max do:[:i|		t _ i asFloat / max asFloat.		next _ self valueAt: t.		last ifNotNil:[			canvas line: last to: next rounded width: 2 color: Color blue.		].		last _ next rounded.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDrawWide: n	| entry minY maxY canvas curve p1 p2 entry2 y |	curve _ self class new.	curve start: start + (0@n).	curve via: via + (0@n).	curve end: end + (0@n).	entry _ BalloonEdgeData new.	entry2 _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	entry2 yValue: minY + n.	self stepToFirstScanLineAt: minY in: entry.	curve stepToFirstScanLineAt: minY+n in: entry2.	y _ minY.	1 to: n do:[:i|		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p1 _ entry xValue @ y.		canvas line: p1 to: p1 + (n@0) width: 1 color: Color black.	].	[y < maxY] whileTrue:[		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p2 _ (entry xValue + n) @ y.		curve stepToNextScanLineAt: y in: entry2.		p1 _ entry2 xValue @ y.		canvas line: p1 to: p2 width: 1 color: Color black.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:35'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: via;		nextPutAll:' - ';		print: end;		nextPut:$)! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 21:56'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 22:13'!quickPrint: curve first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).	Transcript endEntry.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:53'!stepToFirst	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^self].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:50'!stepToFirstInt	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	self halt.	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^nil].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ (scaledStepSize * scaledStepSize) bitShift: -24.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:26'!stepToNext		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 04:01'!stepToNextInt	"Scaled integer version of forward differencing"	self halt.	(maxSteps >= 0) ifTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:27'!validateIntegerRange	fwDx class == SmallInteger ifFalse:[self halt].	fwDy class == SmallInteger ifFalse:[self halt].	fwDDx class == SmallInteger ifFalse:[self halt].	fwDDy class == SmallInteger ifFalse:[self halt].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!valueAt: parameter	"Return the point at the value parameter:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!BalloonBezierSimulation class methodsFor: 'class initialization' stamp: 'ar 10/30/1998 03:04'!initialize	"GraphicsBezierSimulation initialize"	HeightSubdivisions _ 0.	LineConversions _ 0.	MonotonSubdivisions _ 0.	OverflowSubdivisions _ 0.! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index	"For simulation only"	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index put: anInteger	"For simulation only"	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!mew: n	^self new: (n max: 256)! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!new	^self new: 256.! !!BalloonCanvas class methodsFor: 'instance creation' stamp: 'ar 11/11/1998 19:14'!new	^super new initialize! !!BalloonEdgeData commentStamp: '<historical>' prior: 0!BalloonEdgeData defines an entry in the internal edge table of the Balloon engine.Instance Variables:	index	<Integer>	The index into the external objects array of the associated graphics engine	xValue	<Integer>	The computed x-value of the requested operation	yValue	<Integer>	The y-value for the requested operation	height	<Integer>	The (remaining) height of the edge	source	<Object>		The object from the external objects array!!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!index	^index! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!index: anInteger	index _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines	^lines! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines: anInteger	^lines _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!source	^source! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 21:39'!source: anObject	source _ anObject! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!xValue	^xValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!xValue: anInteger	xValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!yValue	^yValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!yValue: anInteger	yValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue	^zValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue: anInteger	zValue _ anInteger! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToFirstScanLine	source stepToFirstScanLineAt: yValue in: self! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToNextScanLine	source stepToNextScanLineAt: yValue in: self! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/11/1998 22:54'!initialize	externals _ OrderedCollection new: 100.	span _ Bitmap new: 2048.	bitBlt _ nil.	self bitBlt: ((BitBlt toForm: Display) destRect: Display boundingBox; yourself).! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/11/1998 22:52'!release	self class recycleBuffer: workBuffer.	workBuffer _ nil.! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/15/1998 18:46'!reset	workBuffer ifNil:[workBuffer _ self class allocateOrRecycleBuffer: 10000].	self primInitializeBuffer: workBuffer.	self primSetAALevel: self aaLevel.	self primSetOffset: destOffset.	self primSetClipRect: clipRect.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 20:52'!drawBezierShape: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	self primAddBezierShape: points		segments: points size		fill: (self registerFill: fillStyle transform: aTransform)		lineWidth: borderWidth		lineFill: (self registerFill: borderFill transform: aTransform)		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/16/1998 02:16'!drawCompressedShape: shape transform: aTransform	| fillIndexList fills |	self reset.	fills _ shape fillStyles.	fillIndexList _ WordArray new: fills size.	1 to: fills size do:[:i|		fillIndexList at: i put: (self registerFill: (fills at: i) transform: aTransform).	].	self doAddCompressedShape: shape points		segments: shape numSegments		leftFills: shape leftFills		rightFills: shape rightFills		lineWidths: shape lineWidths		lineFills: shape lineFills		fillIndexList: fillIndexList		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 20:52'!drawGeneralBezierShape: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	contours do:[:points|		self primAddBezierShape: points			segments: (points size // 3)			fill: (self registerFill: fillStyle transform: aTransform)			lineWidth: borderWidth			lineFill: (self registerFill: borderFill transform: aTransform)			matrix: aTransform.	].	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 19:54'!drawGeneralPolygon: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	contours do:[:points|		self primAddPolygon: points			segments: points size			fill: (self registerFill: fillStyle transform: aTransform)			lineWidth: borderWidth			lineFill: (self registerFill: borderFill transform: aTransform)			matrix: aTransform.	].	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:54'!drawOval: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	self reset.	self primAddOvalFrom: rect origin 			to: rect corner			fillIndex: (self registerFill: fillStyle transform: aMatrix)			borderWidth: borderWidth			borderColor: (self registerFill: borderColor transform: aMatrix)			matrix: aMatrix.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:53'!drawPolygon: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	self primAddPolygon: points		segments: points size		fill: (self registerFill: fillStyle transform: aTransform)		lineWidth: borderWidth		lineFill: (self registerFill: borderFill transform: aTransform)		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:54'!drawRectangle: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	self reset.	self primAddRectFrom: rect origin 			to: rect corner			fillIndex: (self registerFill: fillStyle transform: aMatrix)			borderWidth: borderWidth			borderColor: (self registerFill: borderColor transform: aMatrix)			matrix: aMatrix.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:53'!registerFill: aFillStyle transform: aTransform	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle pixelValue32].	aFillStyle isGradientFill ifTrue:[		^self doAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill			matrix: aTransform.		].	^0! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:08'!canProceedAfter: failureReason	"Check if we can proceed after the failureReason indicated."	| newBuffer |	failureReason = GErrorNoMoreSpace ifTrue:[		"Work buffer is too small"		newBuffer _ workBuffer species new: workBuffer size * 2.		self primCopyBufferFrom: workBuffer to: newBuffer.		workBuffer _ newBuffer.		^true].	"Not handled"	^false! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:16'!copyBits	self copyLoopFastest.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoop	"This is the basic rendering loop using as little primitive support as possible."	| finished edge fill |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	self primInitializeProcessing. "Initialize the GE for processing"	[self primFinishedProcessing] whileFalse:[		"Step 1: Process the edges in the global edge table that will be added in this step"		[finished _ self primNextGlobalEdgeEntryInto: edge.		finished] whileFalse:[			edge source: (externals at: edge index).			edge stepToFirstScanLine.			self primAddActiveEdgeTableEntryFrom: edge].		"Step 2: Scan the active edge table"		[finished _ self primNextFillEntryInto: fill.		finished] whileFalse:[			fill source: (externals at: fill index).			"Compute the new fill"			fill computeFill.			"And mix it in the out buffer"			self primMergeFill: fill destForm bits from: fill].		"Step 3: Display the current span buffer if necessary"		self primDisplaySpanBuffer.		"Step 4: Advance and resort the active edge table"		[finished _ self primNextActiveEdgeEntryInto: edge.		finished] whileFalse:[			"If the index is zero then the edge has been handled by the GE"			edge source: (externals at: edge index).			edge stepToNextScanLine.			self primChangeActiveEdgeTableEntryFrom: edge].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoopFaster	"This is a copy loop drawing one scan line at a time"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderScanline: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:33'!copyLoopFastest	"This is a copy loop drawing the entire image"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderImage: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:19'!processStopReason: reason edge: edge fill: fill	"The engine has stopped because of some reason.	Try to figure out how to respond and do the necessary actions."	"Note: The order of operations below can affect the speed"	"Process unknown fills first"	reason = GErrorFillEntry ifTrue:[		fill source: (externals at: fill index).		"Compute the new fill"		fill computeFill.		"And mix it in the out buffer"		^self primMergeFill: fill destForm bits from: fill].	"Process unknown steppings in the AET second"	reason = GErrorAETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToNextScanLine.		^self primChangeActiveEdgeTableEntryFrom: edge].	"Process unknown entries in the GET third"	reason = GErrorGETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToFirstScanLine.		^self primAddActiveEdgeTableEntryFrom: edge].	"Process generic problems last"	(self canProceedAfter: reason) ifTrue:[^self]. "Okay."	^self error:'Unkown stop reason in graphics engine'! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel	^aaLevel ifNil:[1]! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel: anInteger	aaLevel _ (anInteger min: 4) max: 1.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!aaTransform	"Return a transformation for the current anti-aliasing level"	| matrix |	matrix _ MatrixTransform2x3 withScale: (self aaLevel) asFloat asPoint.	matrix offset: (self aaLevel // 2) asFloat asPoint.	^matrix composedWith:(MatrixTransform2x3 withOffset: destOffset asFloatPoint)! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 03:04'!bitBlt	^bitBlt! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:07'!bitBlt: aBitBlt	bitBlt _ aBitBlt.	bitBlt isNil ifTrue:[^self].	self clipRect: bitBlt clipRect.	bitBlt 		sourceForm: (Form extent: span size @ 1 depth: 32 bits: span);		sourceRect: (0@0 extent: 1@span size);		colorMap: (Color colorMapIfNeededFrom: 32 to: bitBlt destForm depth);		combinationRule: (bitBlt destForm depth >= 8 ifTrue:[34] ifFalse:[Form paint]).! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:57'!clipRect	^clipRect! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 02:44'!clipRect: aRect	clipRect _ aRect truncated! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:56'!destOffset	^destOffset! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/12/1998 00:22'!destOffset: aPoint	destOffset _ aPoint asIntegerPoint.	bitBlt destX: aPoint x; destY: aPoint y.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!fullTransformFrom: aMatrix	| m |	m _ self aaTransform composedWith: aMatrix.	"m offset: m offset + destOffset."	^m! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primClipRectInto: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive:'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetAALevel	"Set the AA level"	<primitive: 'gePrimitiveGetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetBezierStats: statsArray	<primitive:'gePrimitiveGetBezierStats'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetBezierStats'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetClipRect: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetCounts: statsArray	<primitive:'gePrimitiveGetCounts'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetCounts'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetFailureReason	<primitive: 'gePrimitiveGetFailureReason'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetFailureReason'].	^0! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetOffset	<primitive: 'gePrimitiveGetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetTimes: statsArray	<primitive:'gePrimitiveGetTimes'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetTimes'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetAALevel: level	"Set the AA level"	<primitive: 'gePrimitiveSetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetClipRect: rect	<primitive: 'gePrimitiveSetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetOffset: point	<primitive: 'gePrimitiveSetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:16'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	<primitive: 'gePrimitiveAddBezierWithMatrix' module:'blurb'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezierWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/14/1998 20:53'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	<primitive: 'gePrimitiveAddBezierShape'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezierShape'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:16'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	<primitive: 'gePrimitiveAddCompressedShape'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddCompressedShape'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:18'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'gePrimitiveRegisterExternalEdge'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalEdge'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddExternalFill: index	<primitive: 'gePrimitiveRegisterExternalFill'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalFill'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalFill: index	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	<primitive: 'gePrimitiveAddGradientFill'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddGradientFill'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	<primitive: 'gePrimitiveAddLineWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddLineWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	<primitive: 'gePrimitiveAddOvalWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddOvalWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	<primitive: 'gePrimitiveAddPolygon'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddPolygon'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	<primitive: 'gePrimitiveAddRectWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddRectWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/14/1998 20:47'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	<primitive: 'gePrimitiveAddActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddActiveEdgeEntry'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddActiveEdgeTableEntryFrom: edgeEntry	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	<primitive: 'gePrimitiveChangedActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveChangedActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primDisplaySpanBuffer	"Display the current scan line if necessary"	<primitive: 'gePrimitiveDisplaySpanBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveDisplaySpanBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	<primitive: 'gePrimitiveFinishedProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveFinishedProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	<primitive: 'gePrimitiveInitializeProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	<primitive: 'gePrimitiveMergeFillFrom'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveMergeFillFrom'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	<primitive: 'gePrimitiveNextFillEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextFillEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextGlobalEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextGlobalEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderImage'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderImage'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderScanline'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderScanline'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	<primitive: 'gePrimitiveCopyBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveCopyBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primInitializeBuffer: buffer	<primitive: 'gePrimitiveInitializeBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:53'!registerBezier: aCurve transformation: aMatrix	self primAddBezierFrom: aCurve start		to: aCurve end		via: aCurve via		leftFillIndex: (self registerFill: aCurve leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aCurve rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!registerBoundary: boundaryObject transformation: aMatrix	| external |	external _ boundaryObject asEdgeRepresentation: (self fullTransformFrom: aMatrix).	self subdivideExternalEdge: external from: boundaryObject.! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerExternalEdge: externalEdge from: boundaryObject	externals addLast: externalEdge.	self primAddExternalEdge: externals size		initialX: externalEdge initialX		initialY: externalEdge initialY		initialZ: externalEdge initialZ		leftFillIndex: (self registerFill: boundaryObject leftFill transform: nil)		rightFillIndex: (self registerFill: boundaryObject rightFill transform: nil)! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerLine: aLine transformation: aMatrix	self primAddLineFrom: aLine start to: aLine end		leftFillIndex: (self registerFill: aLine leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aLine rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!subdivideExternalEdge: external from: boundaryObject	| external2 |	external2 _ external subdivide.	external2 notNil ifTrue:[		self subdivideExternalEdge: external from: boundaryObject.		self subdivideExternalEdge: external2 from: boundaryObject.	] ifFalse:[		self registerExternalEdge: external from: boundaryObject.	].! !!BalloonEngine methodsFor: 'profiling' stamp: 'ar 11/11/1998 21:16'!doAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	"Note: This method is for profiling the overhead of loading a compressed shape into the engine."	^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix! !!BalloonEngine methodsFor: 'profiling' stamp: 'ar 11/11/1998 21:16'!doAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	^self primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix! !!BalloonEngine class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:44'!new	^super new initialize! !!BalloonEngine class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:49'!initialize	"BalloonEngine initialize"	BufferCache _ WeakArray new: 1.	Smalltalk garbageCollect. "Make the cache old"	CacheProtect _ Semaphore forMutualExclusion.	Times _ WordArray new: 10.	Counts _ WordArray new: 10.	BezierStats _ WordArray new: 4.	Debug ifNil:[Debug _ false].! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/25/1998 17:37'!debug: aBoolean	"BalloonEngine debug: true"	"BalloonEngine debug: false"	Debug _ aBoolean! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!printBezierStats	"BalloonEngine printBezierStats"	"BalloonEngine resetBezierStats"	Transcript 		cr; nextPutAll:'Bezier statistics:';		crtab; print: (BezierStats at: 1); tab; nextPutAll:' non-monoton curves splitted';		crtab; print: (BezierStats at: 2); tab; nextPutAll:' curves splitted for numerical accuracy';		crtab; print: (BezierStats at: 3); tab; nextPutAll:' curves splitted to avoid integer overflow';		crtab; print: (BezierStats at: 4); tab; nextPutAll:' curves internally converted to lines';	endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:59'!printStat: time count: n string: aString	Transcript		cr;		print: time; tab;		nextPutAll:' mSecs -- ';		print: n; tab;		nextPutAll:' ops -- ';		print: ((time asFloat / (n max: 1) asFloat) roundTo: 0.01); tab;		nextPutAll: ' avg. mSecs/op -- ';		nextPutAll: aString.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/29/1998 19:59'!printStats	"BalloonEngine printStats"	"BalloonEngine resetStats"	Transcript cr; nextPutAll:'/************** BalloonEngine statistics ****************/'.	self printStat: (Times at: 1) count: (Counts at: 1) string: 'Initialization'.	self printStat: (Times at: 2) count: (Counts at: 2) string: 'Finish test'.	self printStat: (Times at: 3) count: (Counts at: 3) string: 'Fetching/Adding GET entries'.	self printStat: (Times at: 4) count: (Counts at: 4) string: 'Adding AET entries'.	self printStat: (Times at: 5) count: (Counts at: 5) string: 'Fetching/Computing fills'.	self printStat: (Times at: 6) count: (Counts at: 6) string: 'Merging fills'.	self printStat: (Times at: 7) count: (Counts at: 7) string: 'Displaying span buffer'.	self printStat: (Times at: 8) count: (Counts at: 8) string: 'Fetching/Updating AET entries'.	self printStat: (Times at: 9) count: (Counts at: 9) string: 'Changing AET entries'.	Transcript cr; print: Times sum; nextPutAll:' mSecs for all operations'.	Transcript cr; print: Counts sum; nextPutAll: ' overall operations'.	Transcript endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!resetBezierStats	BezierStats _ WordArray new: 4.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:38'!resetStats	Times _ WordArray new: 10.	Counts _ WordArray new: 10.! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:50'!allocateOrRecycleBuffer: initialSize	"Try to recycly a buffer. If this is not possibly, create a new one."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		BufferCache at: 1 put: nil.	].	^buffer ifNil:[BalloonBuffer new: initialSize]! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:51'!recycleBuffer: balloonBuffer	"Try to keep the buffer for later drawing operations."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		(buffer isNil or:[buffer size < balloonBuffer size] )			ifTrue:[BufferCache at: 1 put: balloonBuffer].	].! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskGet	^workBuffer at: GWAAColorMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskPut: value	^workBuffer at: GWAAColorMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftGet	^workBuffer at: GWAAColorShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftPut: value	^workBuffer at: GWAAColorShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaHalfPixelGet	^workBuffer at: GWAAHalfPixel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaHalfPixelPut: value	^workBuffer at: GWAAHalfPixel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelGet	^workBuffer at: GWAALevel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelPut: value	^workBuffer at: GWAALevel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskGet	^workBuffer at: GWAAScanMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskPut: value	^workBuffer at: GWAAScanMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaShiftGet	^workBuffer at: GWAAShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:36'!aaShiftPut: value	^workBuffer at: GWAAShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetStartGet	^workBuffer at: GWAETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetStartPut: value	^workBuffer at: GWAETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetUsedGet	^workBuffer at: GWAETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetUsedPut: value	^workBuffer at: GWAETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:43'!clearSpanBufferGet	^workBuffer at: GWClearSpanBuffer! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:44'!clearSpanBufferPut: value	^workBuffer at: GWClearSpanBuffer put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXGet	^workBuffer at: GWClipMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXPut: value	^workBuffer at: GWClipMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYGet	^workBuffer at: GWClipMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYPut: value	^workBuffer at: GWClipMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMinXGet	^workBuffer at: GWClipMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinXPut: value	^workBuffer at: GWClipMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYGet	^workBuffer at: GWClipMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYPut: value	^workBuffer at: GWClipMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!currentYGet	^workBuffer at: GWCurrentY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 21:27'!currentYPut: value	^workBuffer at: GWCurrentY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetXGet	^workBuffer at: GWDestOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetXPut: value	^workBuffer at: GWDestOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetYGet	^workBuffer at: GWDestOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetYPut: value	^workBuffer at: GWDestOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxXGet	^workBuffer at: GWFillMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!fillMaxXPut: value	^workBuffer at: GWFillMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxYGet	^workBuffer at: GWFillMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMaxYPut: value	^workBuffer at: GWFillMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinXGet	^workBuffer at: GWFillMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinXPut: value	^workBuffer at: GWFillMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinYGet	^workBuffer at: GWFillMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinYPut: value	^workBuffer at: GWFillMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetXGet	^workBuffer at: GWFillOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetXPut: value	^workBuffer at: GWFillOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetYGet	^workBuffer at: GWFillOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetYPut: value	^workBuffer at: GWFillOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListGet	^workBuffer at: GWPointListFirst! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListPut: value	^workBuffer at: GWPointListFirst put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getStartGet	^workBuffer at: GWGETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!getStartPut: value	^workBuffer at: GWGETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getUsedGet	^workBuffer at: GWGETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!getUsedPut: value	^workBuffer at: GWGETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/9/1998 15:36'!incrementStat: statIndex by: value	^workBuffer at: statIndex put: (workBuffer at: statIndex) + value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!lastExportedEdgeGet	^workBuffer at: GWLastExportedEdge! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 20:11'!lastExportedEdgePut: value	^workBuffer at: GWLastExportedEdge put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillGet	^workBuffer at: GWLastExportedFill! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillPut: value	^workBuffer at: GWLastExportedFill put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXGet	^workBuffer at: GWLastExportedLeftX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXPut: value	^workBuffer at: GWLastExportedLeftX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXGet	^workBuffer at: GWLastExportedRightX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXPut: value	^workBuffer at: GWLastExportedRightX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!magicNumberGet	^workBuffer at: GWMagicIndex! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:39'!magicNumberPut: value	^workBuffer at: GWMagicIndex put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objStartGet	^workBuffer at: GWObjStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objStartPut: value	^workBuffer at: GWObjStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objUsedGet	^workBuffer at: GWObjUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objUsedPut: value	^workBuffer at: GWObjUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:33'!point1Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint1 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point2Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint2 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point3Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint3 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/1/1998 03:13'!point4Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint4 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndAAGet	^workBuffer at: GWSpanEndAA! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndAAPut: value	^workBuffer at: GWSpanEndAA put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndGet	^workBuffer at: GWSpanEnd! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndPut: value	^workBuffer at: GWSpanEnd put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanSizeGet	^workBuffer at: GWSpanSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanSizePut: value	^workBuffer at: GWSpanSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanStartGet	^workBuffer at: GWSpanStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanStartPut: value	^workBuffer at: GWSpanStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stateGet	^workBuffer at: GWState! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!statePut: value	^workBuffer at: GWState put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stopReasonGet	^workBuffer at: GWStopReason! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!stopReasonPut: value	^workBuffer at: GWStopReason put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!wbSizeGet	^workBuffer at: GWSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:37'!wbSizePut: value	^workBuffer at: GWSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:29'!wbTopGet	^workBuffer at: GWBufferTop! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!wbTopPut: value	^workBuffer at: GWBufferTop put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:36'!objectHeaderOf: obj	^self makeUnsignedFrom:(objBuffer at: obj + GEObjectType)! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:36'!objectIndexOf: obj	^objBuffer at: obj + GEObjectIndex! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectIndexOf: obj put: value	^objBuffer at: obj + GEObjectIndex put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectLengthOf: obj	^objBuffer at: obj + GEObjectLength! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectLengthOf: obj put: value	^objBuffer at: obj + GEObjectLength put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectTypeOf: obj	^(self makeUnsignedFrom:(objBuffer at: obj + GEObjectType)) bitAnd: GEPrimitiveTypeMask! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectTypeOf: obj put: value	^objBuffer at: obj + GEObjectType put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsInvalidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitOr: GEEdgeFillsInvalid)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsValidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitAnd: GEEdgeFillsInvalid bitInvert32)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeLeftFillOf: edge	^objBuffer at: edge + GEFillIndexLeft! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeLeftFillOf: edge put: value	^objBuffer at: edge + GEFillIndexLeft put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeNumLinesOf: edge	^objBuffer at: edge + GENumLines! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeNumLinesOf: edge put: value	^objBuffer at: edge + GENumLines put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeRightFillOf: edge	^objBuffer at: edge + GEFillIndexRight! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeRightFillOf: edge put: value	^objBuffer at: edge + GEFillIndexRight put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeTypeOf: edge	"Return the edge type (e.g., witout the wide edge flag)"	^(self objectTypeOf: edge) >> 1! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeXValueOf: edge	^objBuffer at: edge + GEXValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeXValueOf: edge put: value	^objBuffer at: edge + GEXValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeYValueOf: edge	^objBuffer at: edge + GEYValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeYValueOf: edge put: value	^objBuffer at: edge + GEYValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeZValueOf: edge	^objBuffer at: edge + GEZValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:36'!edgeZValueOf: edge put: value	^objBuffer at: edge + GEZValue put: value! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/31/1998 00:43'!wbStackClear	self wbTopPut: self wbSizeGet.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackPop: nItems	self wbTopPut: self wbTopGet + nItems.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:16'!wbStackPush: nItems	(self allocateStackEntry: nItems) ifFalse:[^false].	self wbTopPut: self wbTopGet - nItems.	^true! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:17'!wbStackSize	^self wbSizeGet - self wbTopGet! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index	^workBuffer at: self wbTopGet + index! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index put: value	^workBuffer at: self wbTopGet + index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/7/1998 22:25'!fillTypeOf: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) >> 8! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index	^self wbStackValue: index+1! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index put: value	^self wbStackValue: index+1 put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:24'!stackFillEntryLength	^2! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:10'!stackFillSize	^self wbStackSize! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index	^self wbStackValue: index! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index put: value	^self wbStackValue: index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:28'!topFill	self stackFillSize = 0		ifTrue:[^0]		ifFalse:[^self topFillValue].! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepth	^self stackFillDepth: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepthPut: value	^self stackFillDepth: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValue	^self stackFillValue: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValuePut: value	^self stackFillValue: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:12'!loadArrayMatrixFrom: matrixOop	"Load a 2x3 matrix from the given array."	| value |	self inline: false.	0 to: 5 do:[:i|		value _ interpreterProxy fetchPointer: i ofObject: matrixOop.		((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])			ifFalse:[^interpreterProxy primitiveFail].		(interpreterProxy isIntegerObject: value)			ifTrue:[edgeTransform at: i put: 				(self cCoerce: (interpreterProxy integerValueOf: value) asFloat to:'float')]			ifFalse:[edgeTransform at: i put: 				(self cCoerce: (interpreterProxy floatValueOf: value) to: 'float')].	].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/11/1998 22:21'!loadEdgeStateFrom: edgeOop	| edge |	self inline: false.	edge _ self lastExportedEdgeGet.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	self edgeXValueOf: edge 		put: (interpreterProxy fetchInteger: ETXValueIndex ofObject: edgeOop).	self edgeYValueOf: edge 		put: (interpreterProxy fetchInteger: ETYValueIndex ofObject: edgeOop).	self edgeZValueOf: edge 		put: (interpreterProxy fetchInteger: ETZValueIndex ofObject: edgeOop).	self edgeNumLinesOf: edge 		put: (interpreterProxy fetchInteger: ETLinesIndex ofObject: edgeOop).	^edge! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:12'!loadMatrixFrom: matrixOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	self inline: false.	matrixOop = interpreterProxy nilObject ifTrue:[^false].	(interpreterProxy isIntegerObject: matrixOop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: matrixOop) = 6 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: matrixOop) 		ifTrue:[self loadWordMatrixFrom: matrixOop]		ifFalse:[self loadArrayMatrixFrom: matrixOop].	"Add the fill offset to the matrix"	edgeTransform at: 2 put: 		(self cCoerce: (edgeTransform at: 2) + self destOffsetXGet asFloat to:'float').	edgeTransform at: 5 put: 		(self cCoerce: (edgeTransform at: 5) + self destOffsetYGet asFloat to:'float').	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/27/1998 21:24'!loadPoint: pointArray from: pointOop	"Load the contents of pointOop into pointArray"	| value |	self inline: false.	self var: #pointArray declareC:'int *pointArray'.	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint 		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchPointer: 0 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 0 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 0 put: (interpreterProxy floatValueOf: value) asInteger].	value _ interpreterProxy fetchPointer: 1 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 1 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 1 put: (interpreterProxy floatValueOf: value) asInteger].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 00:46'!loadSpanBufferFrom: spanOop	"Load the span buffer from the given oop."	self inline: false.	(interpreterProxy fetchClassOf: spanOop) = (interpreterProxy classBitmap) ifFalse:[^false].	spanBuffer _ interpreterProxy firstIndexableField: spanOop.	"Leave last entry unused to avoid complications"	self spanSizePut: (interpreterProxy slotSizeOf: spanOop) - 1.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:13'!loadWordMatrixFrom: matrixOop	"Load a 2x3 float array matrix from the given oop"	| floatPtr |	self inline: false.	self var: #floatPtr declareC:'float *floatPtr'.	floatPtr _ self cCoerce: (interpreterProxy firstIndexableField: matrixOop) to: 'float *'.	0 to: 5 do:[:i| edgeTransform at: i put: (floatPtr at: i)].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 19:37'!loadWorkBufferFrom: wbOop	"Load the working buffer from the given oop"	self inline: false.	(interpreterProxy isIntegerObject: wbOop) ifTrue:[^false].	(interpreterProxy isWords: wbOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: wbOop) < GWMinimalSize ifTrue:[^false].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	self magicNumberGet = GWMagicNumber ifFalse:[^false].	"Sanity checks"	(self wbSizeGet = (interpreterProxy slotSizeOf: wbOop)) ifFalse:[^false].	self objStartGet = GWHeaderSize ifFalse:[^false].	"Load buffers"	objBuffer _ workBuffer + self objStartGet.	getBuffer _ objBuffer + self objUsedGet.	aetBuffer _ getBuffer + self getUsedGet.	"Make sure we don't exceed the work buffer"	GWHeaderSize + self objUsedGet + self getUsedGet + self aetUsedGet > self wbSizeGet ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/11/1998 22:06'!quickLoadEngineFrom: engineOop	"Load the minimal required state from the engineOop, e.g., just the work buffer."	self inline: false.	interpreterProxy failed ifTrue:[^false].	(interpreterProxy isIntegerObject: engineOop) ifTrue:[^false].	(interpreterProxy isPointers: engineOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: engineOop) < BEBalloonEngineSize ifTrue:[^false].	engine _ engineOop.	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engineOop))			ifFalse:[^false].	self stopReasonPut: 0.	engineStopped _ false.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 21:06'!quickLoadEngineFrom: oop requiredState: requiredState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/31/1998 17:23'!quickLoadEngineFrom: oop requiredState: requiredState or: alternativeState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stateGet = alternativeState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:21'!storeEdgeStateFrom: edge into: edgeOop	self inline: false.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: ETIndexIndex ofObject: edgeOop withValue: 		(self objectIndexOf: edge).	interpreterProxy storeInteger: ETXValueIndex ofObject: edgeOop withValue: 		(self edgeXValueOf: edge).	interpreterProxy storeInteger: ETYValueIndex ofObject: edgeOop withValue: 		(self currentYGet).	interpreterProxy storeInteger: ETZValueIndex ofObject: edgeOop withValue: 		(self edgeZValueOf: edge).	interpreterProxy storeInteger: ETLinesIndex ofObject: edgeOop withValue: 		(self edgeNumLinesOf: edge).	self lastExportedEdgePut: edge.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 10/28/1998 19:10'!storeEngineStateInto: oop	"Nothing to do yet"! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:24'!storeFillStateInto: fillOop	| fillIndex leftX rightX |	self inline: false.	fillIndex _ self lastExportedFillGet.	leftX _ self lastExportedLeftXGet.	rightX _ self lastExportedRightXGet.	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: FTIndexIndex ofObject: fillOop withValue: 		(self objectIndexOf: fillIndex).	interpreterProxy storeInteger: FTMinXIndex ofObject: fillOop withValue: leftX.	interpreterProxy storeInteger: FTMaxXIndex ofObject: fillOop withValue: rightX.	interpreterProxy storeInteger: FTYValueIndex ofObject: fillOop withValue: self currentYGet.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/9/1998 15:34'!storeStopStateIntoEdge: edgeOop fill: fillOop	| reason edge |	reason _ self stopReasonGet.	reason = GErrorGETEntry ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1.	].	reason = GErrorFillEntry ifTrue:[		self storeFillStateInto: fillOop.	].	reason = GErrorAETEntry ifTrue:[		edge _ aetBuffer at: self aetStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		"Do not advance to the next aet entry yet"		"self aetStartPut: self aetStartGet + 1."	].! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:34'!areEdgeFillsValid: edge	^((self objectHeaderOf: edge) bitAnd: GEEdgeFillsInvalid) = 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 17:06'!finishedProcessing	"Return true if processing is finished"	^self stateGet = GEStateCompleted! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:36'!isEdge: edge	| type |	type _ self objectTypeOf: edge.	type > GEPrimitiveEdgeMask ifTrue:[^false].	^((self objectTypeOf: edge) bitAnd: GEPrimitiveEdgeMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isFill: fill	^(self isFillColor: fill) or:[self isRealFill: fill]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:31'!isFillColor: fill	^((self makeUnsignedFrom: fill) bitAnd: 16rFF000000) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/27/1998 23:36'!isObject: obj	^obj >= 0 and:[obj < self objUsedGet]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isRealFill: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 23:12'!isStackEntry: entry	^entry >= self wbTopGet and:[entry < self wbSizeGet]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/30/1998 17:38'!isStackIndex: index	^index >= 0 and:[index < self wbStackSize]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:36'!isWide: object	^((self objectTypeOf: object) bitAnd: GEPrimitiveWide) ~= 0! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveGetAALevel	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self aaLevelGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/14/1998 02:40'!gePrimitiveGetClipRect	| rectOop pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMinXGet yValue: self clipMinYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: pointOop.	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMaxXGet yValue: self clipMaxYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: pointOop.	interpreterProxy pop: 2.	interpreterProxy push: rectOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetCounts	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWCountInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWCountFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWCountNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWCountAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWCountNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWCountMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWCountDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWCountNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWCountChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 22:05'!gePrimitiveGetFailureReason	"Return the reason why the last operation failed."	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	"Note -- don't call loadEngineFrom here because this will override the stopReason with Zero"	(interpreterProxy isIntegerObject: engine) ifTrue:[^false].	(interpreterProxy isPointers: engine) ifFalse:[^false].	(interpreterProxy slotSizeOf: engine) < BEBalloonEngineSize ifTrue:[^false].	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy makePointwithxValue: self destOffsetXGet yValue: self destOffsetYGet.	interpreterProxy pop: 1.	interpreterProxy push: pointOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetTimes	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWTimeInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWTimeFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWTimeNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWTimeAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWTimeNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWTimeMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWTimeDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWTimeNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWTimeChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveSetAALevel	| level |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	level _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self setAALevel: level.	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leace rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetClipRect	| rectOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: rectOop).	self loadPoint: self point2Get from: (interpreterProxy fetchPointer: 1 ofObject: rectOop).	interpreterProxy failed ifFalse:[		self clipMinXPut: (self point1Get at: 0).		self clipMinYPut: (self point1Get at: 1).		self clipMaxXPut: (self point2Get at: 0).		self clipMaxYPut: (self point2Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: pointOop.	interpreterProxy failed ifFalse:[		self destOffsetXPut: (self point1Get at: 0).		self destOffsetYPut: (self point1Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:23'!gePrimitiveAddActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForEdge)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self needAvailableSpace: 1) 		ifFalse:[^interpreterProxy primitiveFail].	(self edgeNumLinesOf: edge) > 0 ifTrue:[		self insertEdgeIntoAET: edge.	].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Back to adding edges from GET"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	self incrementStat: GWCountAddAETEntry by: 1.	self incrementStat: GWTimeAddAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:24'!gePrimitiveChangedActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingChange)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self edgeNumLinesOf: edge) = 0 		ifTrue:[	self removeFirstAETEntry]		ifFalse:[	self resortFirstAETEntry.				self aetStartPut: self aetStartGet + 1].	self statePut: GEStateUpdateEdges. "Back to updating edges"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	self incrementStat: GWCountChangeAETEntry by: 1.	self incrementStat: GWTimeChangeAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:05'!gePrimitiveDisplaySpanBuffer	"Note: Must load bitBlt and spanBuffer"	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateBlitBuffer)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[		self displaySpanBufferAt: self currentYGet.		self postDisplayAction.	].	self finishedProcessing ifFalse:[		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		self statePut: GEStateUpdateEdges].	self storeEngineStateInto: engine.	self incrementStat: GWCountDisplaySpan by: 1.	self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:06'!gePrimitiveInitializeProcessing	"Note: No need to load bitBlt but must load spanBuffer"	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked) 		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for clear operation"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	self initializeGETProcessing.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Initialized"	interpreterProxy failed ifFalse:[self storeEngineStateInto: engine].	self incrementStat: GWCountInitializing by: 1.	self incrementStat: GWTimeInitializing by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:23'!gePrimitiveMergeFillFrom	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop bitsOop value |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	bitsOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForFill)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for merging the fill"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check bitmap"	(interpreterProxy fetchClassOf: bitsOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	"Check fillOop"	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize		ifTrue:[^interpreterProxy primitiveFail].	"Check if this was the fill we have exported"	value _ interpreterProxy fetchInteger: FTIndexIndex ofObject: fillOop.	(self objectIndexOf: self lastExportedFillGet) = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMinXIndex ofObject: fillOop.	self lastExportedLeftXGet = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMaxXIndex ofObject: fillOop.	self lastExportedRightXGet = value		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bitsOop) < (self lastExportedRightXGet - self lastExportedLeftXGet)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self fillBitmapSpan: (interpreterProxy firstIndexableField: bitsOop)		from: self lastExportedLeftXGet		to: self lastExportedRightXGet.	self statePut: GEStateScanningAET. "Back to scanning AET"	self storeEngineStateInto: engine.	interpreterProxy pop: 2. "Leave rcvr on stack"	self incrementStat: GWCountMergeFill by: 1.	self incrementStat: GWTimeMergeFill by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:26'!gePrimitiveNextActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUpdateEdges or: GEStateCompleted)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ false.	self stateGet = GEStateCompleted ifFalse:[		hasEdge _ self findNextExternalUpdateFromAET.		hasEdge ifTrue:[			edge _ aetBuffer at: self aetStartGet.			self storeEdgeStateFrom: edge into: edgeOop.			"Do not advance to the next aet entry yet"			"self aetStartPut: self aetStartGet + 1."			self statePut: GEStateWaitingChange. "Wait for changed edge"		] ifFalse:[self statePut: GEStateAddingFromGET]. "Start over"	].	interpreterProxy failed ifTrue:[^nil].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	self incrementStat: GWCountNextAETEntry by: 1.	self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:06'!gePrimitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:26'!gePrimitiveNextGlobalEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateAddingFromGET)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ self findNextExternalEntryFromGET.	hasEdge ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1].	interpreterProxy failed ifTrue:[^nil].	hasEdge		ifTrue:[	self statePut: GEStateWaitingForEdge] "Wait for adding edges"		ifFalse:[ "Start scanning the AET"				self statePut: GEStateScanningAET.				self clearSpanBufferPut: 1. "Clear span buffer at next entry"				self aetStartPut: 0.				self wbStackClear].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	self incrementStat: GWCountNextGETEntry by: 1.	self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderImage	"Start/Proceed rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish this scan line"	engineStopped ifTrue:[^self storeRenderingState].	self proceedRenderingImage. "And go on as usual"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderScanline	"Start rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish the current scan line"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/11/1998 22:24'!loadRenderingState	"Load the entire state from the interpreter for the rendering primitives"	| edgeOop fillOop state |	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	edgeOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^false].	(self quickLoadEngineFrom: engine)		ifFalse:[^false].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^false].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^false].	"Check edgeOop and fillOop"	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^false].	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^false].	"Note: Rendering can only take place if we're not in one of the intermediate	(e.g., external) states."	state _ self stateGet.	(state = GEStateWaitingForEdge or:[		state = GEStateWaitingForFill or:[			state = GEStateWaitingChange]]) ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/5/1998 21:45'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self stopReasonPut: GErrorGETEntry.			self statePut: GEStateWaitingForEdge.			^engineStopped _ true.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self stopReasonPut: GErrorFillEntry.			self statePut: GEStateWaitingForFill.			^engineStopped _ true.		].		self wbStackClear.		self spanEndAAPut: 0.		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self stopReasonPut: GErrorAETEntry.			self statePut: GEStateWaitingChange.			^engineStopped _ true.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 17:29'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self stopReasonPut: GErrorGETEntry.			self statePut: GEStateWaitingForEdge.			^engineStopped _ true.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self stopReasonPut: GErrorFillEntry.			self statePut: GEStateWaitingForFill.			^engineStopped _ true.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self stopReasonPut: GErrorAETEntry.			self statePut: GEStateWaitingChange.			^engineStopped _ true.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:54'!storeRenderingState	self inline: false.	interpreterProxy failed ifTrue:[^nil].	engineStopped ifTrue:[		"Check the stop reason and store the required information"		self storeStopStateIntoEdge: (interpreterProxy stackObjectValue: 1) 			fill: (interpreterProxy stackObjectValue: 0).	].	self storeEngineStateInto: engine.	interpreterProxy pop: 3.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/31/1998 17:23'!gePrimitiveAbortProcessing	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	self statePut: GEStateCompleted.	self storeEngineStateInto: engine.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/29/1998 16:24'!gePrimitiveCopyBuffer	| buf1 buf2 diff src dst |	self export: true.	self inline: false.	self var: #src declareC:'int * src'.	self var: #dst declareC:'int * dst'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	buf2 _ interpreterProxy stackObjectValue: 0.	buf1 _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	"Make sure the old buffer is properly initialized"	(self loadWorkBufferFrom: buf1) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the buffers are of the same type"	(interpreterProxy fetchClassOf: buf1) = (interpreterProxy fetchClassOf: buf2)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure buf2 is at least of the size of buf1"	diff _ (interpreterProxy slotSizeOf: buf2) - (interpreterProxy slotSizeOf: buf1).	diff < 0 ifTrue:[^interpreterProxy primitiveFail].	"Okay - ready for copying. First of all just copy the contents up to wbTop"	src _ workBuffer.	dst _ interpreterProxy firstIndexableField: buf2.	0 to: self wbTopGet-1 do:[:i|		dst at: i put: (src at: i).	].	"Adjust wbSize and wbTop in the new buffer"	dst at: GWBufferTop put: self wbTopGet + diff.	dst at: GWSize put: self wbSizeGet + diff.	"Now copy the entries from wbTop to wbSize"	src _ src + self wbTopGet.	dst _ dst + self wbTopGet + diff.	0 to: (self wbSizeGet - self wbTopGet - 1) do:[:i|		dst at: i put: (src at: i).	].	"Okay, done. Check the new buffer by loading the state from it"	(self loadWorkBufferFrom: buf2) 		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/31/1998 17:05'!gePrimitiveFinishedProcessing	| finished |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	finished _ self finishedProcessing.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: finished.	self incrementStat: GWCountFinishTest by: 1.	self incrementStat: GWTimeFinishTest by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/9/1998 17:04'!gePrimitiveInitializeBuffer	| wbOop size |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	wbOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: wbOop) 		ifFalse:[^interpreterProxy primitiveFail].	(size _ interpreterProxy slotSizeOf: wbOop) < GWMinimalSize		ifTrue:[^interpreterProxy primitiveFail].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	objBuffer _ workBuffer + GWHeaderSize.	self magicNumberPut: GWMagicNumber.	self wbSizePut: size.	self wbTopPut: size.	self statePut: GEStateUnlocked.	self objStartPut: GWHeaderSize.	self objUsedPut: 4.	"Dummy fill object"	self objectTypeOf: 0 put: GEPrimitiveFill.	self objectLengthOf: 0 put: 4.	self objectIndexOf: 0 put: 0.	self getStartPut: 0.	self getUsedPut: 0.	self aetStartPut: 0.	self aetUsedPut: 0.	self stopReasonPut: 0.	self clipMinXPut: 0.	self clipMaxXPut: 0.	self clipMinYPut: 0.	self clipMaxYPut: 0.	self resetGraphicsEngineStats.	interpreterProxy pop: 2.	interpreterProxy push: wbOop.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/10/1998 21:26'!gePrimitiveRegisterExternalEdge	| rightFillIndex leftFillIndex initialZ initialY initialX index  edge |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	initialZ _ interpreterProxy stackIntegerValue: 2.	initialY _ interpreterProxy stackIntegerValue: 3.	initialX _ interpreterProxy stackIntegerValue: 4.	index _ interpreterProxy stackIntegerValue: 5.	engine _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(self allocateObjEntry: GEBaseEdgeSize) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	(leftFillIndex = 0 or:[(self isFillColor: leftFillIndex) or:[		((self isObject: leftFillIndex) and:[self isFill: leftFillIndex])]]) 			ifFalse:[^interpreterProxy primitiveFail].	(rightFillIndex = 0 or:[(self isFillColor: rightFillIndex) or:[		((self isObject: rightFillIndex) and:[self isFill: rightFillIndex])]]) 			ifFalse:[^interpreterProxy primitiveFail].	edge _ self objUsedGet.	self objUsedPut: edge + GEBaseEdgeSize.	"Install type and length"	self objectTypeOf: edge put: GEPrimitiveEdge.	self objectLengthOf: edge put: GEBaseEdgeSize.	self objectIndexOf: edge put: index.	"Install remaining stuff"	self edgeXValueOf: edge put: initialX.	self edgeYValueOf: edge put: initialY.	self edgeZValueOf: edge put: initialZ.	self edgeLeftFillOf: edge put: leftFillIndex.	self edgeRightFillOf: edge put: rightFillIndex.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/10/1998 21:26'!gePrimitiveRegisterExternalFill	| index  fill |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1 		ifFalse:[^interpreterProxy primitiveFail].	index _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Note: We *must* not allocate any fill with index 0"	fill _ 0.	[fill = 0] whileTrue:[		(self allocateObjEntry: GEBaseEdgeSize) 			ifFalse:[^interpreterProxy primitiveFail].		fill _ self objUsedGet.		self objUsedPut: fill + GEBaseFillSize.		"Install type and length"		self objectTypeOf: fill put: GEPrimitiveFill.		self objectLengthOf: fill put: GEBaseFillSize.		self objectIndexOf: fill put: index.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushInteger: fill.	].! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateAETEntry: nSlots	"Allocate n slots in the active edge table"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:06'!allocateGETEntry: nSlots	"Allocate n slots in the global edge table"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the AET"	(self allocateAETEntry: nSlots) ifFalse:[^false].	self aetUsedGet = 0 ifFalse:["Then move the AET upwards"		srcIndex _ self aetUsedGet.		dstIndex _ self aetUsedGet + nSlots.		1 to: self aetUsedGet do:[:i|			aetBuffer at: (dstIndex _ dstIndex - 1) put: (aetBuffer at: (srcIndex _ srcIndex - 1))].	].	aetBuffer _ aetBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:16'!allocateObjEntry: nSlots	"Allocate n slots in the object buffer"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the GET"	(self allocateGETEntry: nSlots) ifFalse:[^false].	self getUsedGet = 0 ifFalse:["Then move the GET upwards"		srcIndex _ self getUsedGet.		dstIndex _ self getUsedGet + nSlots.		1 to: self getUsedGet do:[:i|			getBuffer at: (dstIndex _ dstIndex - 1) put: (getBuffer at: (srcIndex _ srcIndex - 1))].	].	getBuffer _ getBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateStackEntry: nSlots	"AET and Stack allocation are symmetric"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!allocateStackFillEntry	^self wbStackPush: self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!freeStackFillEntry	self wbStackPop: self stackFillEntryLength.! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!needAvailableSpace: nSlots	"Check if we have n slots available"	GWHeaderSize + self objUsedGet + self getUsedGet + self aetUsedGet + nSlots > self wbTopGet ifTrue:[		self stopReasonPut: GErrorNoMoreSpace.		engineStopped _ true.		^false	].	^true! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/1/1998 01:07'!addEdgeToGET: edge	self inline: false.	(self allocateGETEntry: 1) ifFalse:[^0].	"Install edge in the GET"	getBuffer at: self getUsedGet put: edge.	self getUsedPut: self getUsedGet + 1.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/10/1998 17:52'!createGlobalEdgeTable	"Create the global edge table"	| object end |	self inline: false.	object _ 0.	end _ self objUsedGet.	[object < end] whileTrue:[		"Note: addEdgeToGET: may fail on insufficient space but that's not a problem here"		(self isEdge: object) ifTrue:[			"Check if the edge starts below fillMaxY."			(self edgeYValueOf: object) >= self fillMaxYGet ifFalse:[				self checkedAddEdgeToGET: object.			].		].		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalEntryFromGET	"Check the global edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, initialize the the edge and add it to the AET"	| yValue edge type |	yValue _ self currentYGet.	"As long as we have entries in the GET"	[self getStartGet < self getUsedGet] whileTrue:[		edge _ getBuffer at: self getStartGet.		(self edgeYValueOf: edge) > yValue ifTrue:[^false]. "No more edges to add"		type _ self objectTypeOf: edge.		(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 			ifTrue:[^true]. "This is an external edge"		"Note: We must make sure not to do anything with the edge if there is not		enough room in the AET"		(self needAvailableSpace: 1) ifFalse:[^false]. "No more room"		"Process the edge in the engine itself"		self dispatchOn: type in: EdgeInitTable.		"Insert the edge into the AET"		self insertEdgeIntoAET: edge.		self getStartPut: self getStartGet + 1.	].	"No entries in GET"	^false! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/28/1998 21:07'!getSorts: edge1 before: edge2	"Return true if the edge at index i should sort before the edge at index j."	| diff |	self inline: false.	edge1 = edge2 ifTrue:[^true].	"First, sort by Y"	diff _ (self edgeYValueOf: edge1) - (self edgeYValueOf: edge2).	diff = 0 ifFalse:[^diff < 0].	"Then, by X"	diff _ (self edgeXValueOf: edge1) - (self edgeXValueOf: edge2).	^diff < 0! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/15/1998 02:06'!initializeGETProcessing	"Initialization stuff that needs to be done before any processing can take place."	self inline: false.	"Make sure aaLevel is initialized"	self setAALevel: self aaLevelGet.	self clipMinXGet < 0 ifTrue:[self clipMinXPut: 0].	self clipMaxXGet > self spanSizeGet ifTrue:[self clipMaxXPut: self spanSizeGet].	"Convert clipRect to aaLevel"	self fillMinXPut: self clipMinXGet << self aaShiftGet.	self fillMinYPut: self clipMinYGet << self aaShiftGet.	self fillMaxXPut: self clipMaxXGet << self aaShiftGet.	self fillMaxYPut: self clipMaxYGet << self aaShiftGet.	"Reset GET and AET"	self getUsedPut: 0.	self aetUsedPut: 0.	getBuffer _ aetBuffer _ objBuffer + self objUsedGet.	"Create the global edge table"	self createGlobalEdgeTable.	engineStopped ifTrue:[^nil].	self getUsedGet = 0 ifTrue:[		"Nothing to do"		self currentYPut: self fillMaxYGet.		^0].	"Sort entries in the GET"	self sortGlobalEdgeTable.	"Find the first y value to be processed"	self currentYPut: (self edgeYValueOf: (getBuffer at: 0)).	self currentYGet < self fillMinYGet ifTrue:[self currentYPut: self fillMinYGet].	"Load and clear the span buffer"	self spanStartPut: 0.	self spanEndPut: (self spanSizeGet << self aaShiftGet) - 1.	self clearSpanBuffer. "@@: Is this really necessary?!!"! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 17:55'!quickSortGlobalEdgeTable: array from: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	"Note: The original loop has been heavily re-written for C translation"	| di dij dj tt ij k l n tmp again before |	self var: #array declareC:'int *array'.	self inline: false.	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^0].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	before _ self getSorts: di before: dj. "i.e., should di precede dj?"	before ifFalse:[		tmp _ array at: i.		array at: i put: (array at: j).		array at: j put: tmp.		tt _ di.	di _ dj.	dj _ tt].	n <= 2 ifTrue:[^0].	"More than two elements."	ij _ (i + j) // 2.  "ij is the midpoint of i and j."	dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."	before _ (self getSorts: di before: dij). "i.e. should di precede dij?"	before ifTrue:[		before _ (self getSorts: dij before: dj). "i.e., should dij precede dj?"		before ifFalse:["i.e., should dij precede dj?"			tmp _ array at: j.			array at: j put: (array at: ij).			array at: ij put: tmp.			dij _ dj]	] ifFalse:[  "i.e. di should come after dij"		tmp _ array at: i.		array at: i put: (array at: ij).		array at: ij put: tmp.		 dij _ di].	n <= 3 ifTrue:[^0].	 "More than three elements."	"Find k>i and l<j such that dk,dij,dl are in reverse order.	Swap k and l.  Repeat this procedure until k and l pass each other."	k _ i.	l _ j.	again _ true.	[again] whileTrue:[		before _ true.		[before] whileTrue:[			k <= (l _ l - 1)				ifTrue:[	tmp _ array at: l.						before _ self getSorts: dij before: tmp]				ifFalse:[before _ false].		].		before _ true.		[before] whileTrue:[			(k _ k + 1) <= l				ifTrue:[	tmp _ array at: k.						before _ self getSorts: tmp before: dij]				ifFalse:[before _ false]].		again _ k <= l.		again ifTrue:[			tmp _ array at: k.			array at: k put: (array at: l).			array at: l put: tmp]].	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."	self quickSortGlobalEdgeTable: array from: i to: l.	self quickSortGlobalEdgeTable: array from: k to: j.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 23:34'!sortGlobalEdgeTable	"Sort the entire global edge table"	self quickSortGlobalEdgeTable: getBuffer from: 0 to: self getUsedGet-1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/11/1998 00:49'!findNextExternalFillFromAET	"Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false."	| leftEdge rightEdge leftX rightX fill |"self currentYGet >= 680 ifTrue:[self printAET.self halt.]."	self inline: false.	leftX _ rightX _ self fillMaxXGet.	[self aetStartGet < self aetUsedGet] whileTrue:[		leftEdge _ rightEdge _ aetBuffer at: self aetStartGet.		"TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill."		leftX _ rightX _ self edgeXValueOf: leftEdge.		leftX >= self fillMaxXGet ifTrue:[^false]. "Nothing more visible"		"Check if we need to draw the edge"		(self isWide: leftEdge) ifTrue:[			leftX _ rightX _ self drawWideEdge: leftEdge from: leftX.		].		(self areEdgeFillsValid: leftEdge) ifTrue:[			self toggleFillsOf: leftEdge. "Adjust the fills"			engineStopped ifTrue:[^false].		].		self aetStartPut: self aetStartGet + 1.		self aetStartGet < self aetUsedGet ifTrue:[			rightEdge _ aetBuffer at: self aetStartGet.			rightX _ self edgeXValueOf: rightEdge.			rightX >= self fillMinXGet ifTrue:["This is the visible portion"				"Fetch the currently active fill"				fill _ self makeUnsignedFrom: self topFill.				fill = 0 ifFalse:[self fillSpan: fill from: leftX to: rightX]			].		].	].	"Note: Due to pre-clipping we may have to draw remaining stuff with the last fill"	rightX < self fillMaxXGet ifTrue:[		fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[self fillSpan: fill from: rightX to: self fillMaxXGet].	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalUpdateFromAET	"Check the active edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, step the the edge to the next y value."	| edge count type |	self inline: false.	[self aetStartGet < self aetUsedGet] whileTrue:[		edge _ aetBuffer at: self aetStartGet.		count _ (self edgeNumLinesOf: edge) - 1.		count = 0 ifTrue:[			"Edge at end -- remove it"			self removeFirstAETEntry		] ifFalse:[			"Store remaining lines back"			self edgeNumLinesOf: edge put: count.			type _ self objectTypeOf: edge.			(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 				ifTrue:[^true]. "This is an external edge"			self dispatchOn: type in: EdgeStepTable.			self resortFirstAETEntry.			self aetStartPut: self aetStartGet+1.		].	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!indexForInsertingIntoAET: edge	"Find insertion point for the given edge in the AET"	| initialX index |	self inline: false.	initialX _ self edgeXValueOf: edge.	index _ 0.	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) < initialX]]			whileTrue:[index _ index + 1].	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) = initialX and:[			(self getSorts: (aetBuffer at: index) before: edge)]]]				whileTrue:[index _ index + 1].	^index! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 19:52'!insertEdgeIntoAET: edge	"Insert the edge with the given index from the global edge table into the active edge table.	The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX	are both set."	| index |	self inline: false.	"Check for the number of lines remaining"	(self edgeNumLinesOf: edge) <= 0 ifTrue:[^nil]. "Nothing to do"	"Find insertion point"	index _ self indexForInsertingIntoAET: edge.	"And insert edge"	self insertToAET: edge beforeIndex: index.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!insertToAET: edge beforeIndex: index	"Insert the given edge into the AET."	| i |	self inline: false.	"Make sure we have space in the AET"	(self allocateAETEntry: 1) ifFalse:[^nil]. "Insufficient space in AET"	i _ self aetUsedGet-1.	[i < index] whileFalse:[		aetBuffer at: i+1 put: (aetBuffer at: i).		i _ i - 1.	].	aetBuffer at: index put: edge.	self aetUsedPut: self aetUsedGet + 1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 01:39'!moveAETEntryFrom: index edge: edge x: xValue	"The entry at index is not in the right position of the AET. 	Move it to the left until the position is okay."	| newIndex |	self inline: false.	newIndex _ index.	[newIndex > 0 and:[(self edgeXValueOf: (aetBuffer at: newIndex-1)) > xValue]]		whileTrue:[	aetBuffer at: newIndex put: (aetBuffer at: newIndex-1).					newIndex _ newIndex - 1].	aetBuffer at: newIndex put: edge.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!removeFirstAETEntry	| index |	self inline: false.	index _ self aetStartGet.	self aetUsedPut: self aetUsedGet - 1.	[index < self aetUsedGet] whileTrue:[		aetBuffer at: index put: (aetBuffer at: index + 1).		index _ index + 1.	].! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!resortFirstAETEntry	| edge xValue leftEdge |	self inline: false.	self aetStartGet = 0 ifTrue:[^nil]. "Nothing to resort"	edge _ aetBuffer at: self aetStartGet.	xValue _ self edgeXValueOf: edge.	leftEdge _ aetBuffer at: (self aetStartGet - 1).	(self edgeXValueOf: leftEdge) <= xValue ifTrue:[^nil]. "Okay"	self moveAETEntryFrom: self aetStartGet edge: edge x: xValue.! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/11/1998 00:58'!fillSorts: fillEntry1 before: fillEntry2	"Return true if fillEntry1 should be drawn before fillEntry2"	| diff |	self inline: false.	"First check the depth value"	diff _ (self stackFillDepth: fillEntry1) - (self stackFillDepth: fillEntry2).	diff = 0 ifFalse:[^diff < 0].	"See the class comment for aetScanningProblems"	^(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry1)) to:'unsigned') <		(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry2)) to: 'unsigned')! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 10/30/1998 19:43'!hideFill: fillIndex depth: depth	"Make the fill style with the given index invisible"	| index newTopIndex newTop newDepth |	self inline: false.	index _ 0.	[index < self stackFillSize and:[		(self stackFillValue: index) ~= fillIndex or:[			(self stackFillDepth: index) ~= depth]]]				whileTrue:[index _ index + self stackFillEntryLength].	index >= self stackFillSize ifTrue:[^false].	index = 0 ifTrue:[		self freeStackFillEntry.		^true].	"Fill is visible - replace it with the last entry on the stack"	self stackFillValue: index put: (self stackFillValue: 0).	self stackFillDepth: index put: (self stackFillDepth: 0).	self freeStackFillEntry.	(self stackFillSize <= self stackFillEntryLength) ifTrue:[^true]. "Done"	"Find the new top fill"	newTopIndex _ 0.	index _ self stackFillEntryLength.	[index < self stackFillSize] whileTrue:[		(self fillSorts: index before: newTopIndex)			ifTrue:[newTopIndex _ index].		index _ index + self stackFillEntryLength.	].	(newTopIndex + self stackFillEntryLength = self stackFillSize) 		ifTrue:[^true]. "Top fill not changed"	newTop _ self stackFillValue: newTopIndex.	self stackFillValue: newTopIndex put: self topFillValue.	self topFillValuePut: newTop.	newDepth _ self stackFillDepth: newTopIndex.	self stackFillDepth: newTopIndex put: self topFillDepth.	self topFillDepthPut: newDepth.	^true! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 10/30/1998 19:23'!showFill: fillIndex depth: depth	self inline: false.	(self allocateStackFillEntry) ifFalse:[^nil]. "Insufficient space"	self stackFillValue: 0 put: fillIndex.	self stackFillDepth: 0 put: depth.	self stackFillSize = self stackFillEntryLength ifTrue:[^nil]. "No need to update"	(self fillSorts: 0 before: self stackFillSize - self stackFillEntryLength) ifTrue:[		"New top fill"		self stackFillValue: 0 put: self topFillValue.		self stackFillDepth: 0 put: self topFillDepth.		self topFillValuePut: fillIndex.		self topFillDepthPut: depth.	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/9/1998 15:34'!toggleFill: fillIndex depth: depth	"Make the fill style with the given index either visible or invisible"	| hidden |	self inline: false.	self stackFillSize = 0 ifTrue:[		(self allocateStackFillEntry) ifTrue:[			self topFillValuePut: fillIndex.			self topFillDepthPut: depth.		].	] ifFalse:[		hidden _ self hideFill: fillIndex depth: depth.		hidden ifFalse:[self showFill: fillIndex depth: depth].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/9/1998 15:34'!toggleFillsOf: edge	| depth fillIndex |	self inline: false.	(self needAvailableSpace: self stackFillEntryLength * 2) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ self edgeZValueOf: edge.	fillIndex _ self edgeLeftFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth].	fillIndex _ self edgeRightFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaFirstPixelFrom: leftX to: rightX	"Common function to compute the first full pixel for AA drawing"	| firstPixel |	self inline: true.	firstPixel _ (leftX + self aaLevelGet - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.	firstPixel > rightX 		ifTrue:[^rightX]		ifFalse:[^firstPixel]! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaLastPixelFrom: leftX to: rightX	"Common function to compute the last full pixel for AA drawing"	self inline: true.	^(rightX - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:50'!adjustAALevel		"NOTE: 	This method is (hopefully) obsolete due to unrolling 				the fill loops to deal with full pixels."	"Adjust the span buffers values by the appropriate color offset for anti-aliasing.	We do this by replicating the top bits of each color in the lower bits. The idea is that we can scale each color value uniquely from 0 to 255 and thus fill the entire range of colors."	| adjustShift adjustMask x0 x1 pixelValue |	self inline: false.	adjustShift _ 8 - self aaColorShiftGet.	adjustMask _ self aaColorMaskGet bitInvert32.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet.	[x0 < x1] whileTrue:[		pixelValue _ spanBuffer at: x0.		spanBuffer at: x0 put: (pixelValue bitOr: (pixelValue >> adjustShift bitAnd: adjustMask)).		x0 _ x0 + 1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/14/1998 19:31'!clearSpanBuffer	"Clear the current span buffer.	The span buffer is only cleared in the area that has been used by the previous scan line."	| x0 x1 |	self inline: false.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet + 1.	x0 < 0 ifTrue:[x0 _ 0].	x1 > self spanSizeGet ifTrue:[x1 _ self spanSizeGet].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: 0.		x0 _ x0 + 1].	self spanStartPut: self spanSizeGet.	self spanEndPut: 0.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/10/1998 22:05'!displaySpanBufferAt: y	"Display the span buffer at the current scan line."	| targetX0 targetX1 targetY |	self inline: false.	"self aaLevelGet > 1 ifTrue:[self adjustAALevel]."	targetX0 _ self spanStartGet >> self aaShiftGet.	targetX0 < self clipMinXGet ifTrue:[targetX0 _ self clipMinXGet].	targetX1 _ (self spanEndGet + self aaLevelGet - 1) >> self aaShiftGet.	targetX1 > self clipMaxXGet ifTrue:[targetX1 _ self clipMaxXGet].	targetY _ y >> self aaShiftGet.	(targetY < self clipMinYGet or:[targetY >= self clipMaxYGet or:[		targetX1 < self clipMinXGet or:[targetX0 >= self clipMaxXGet]]]) ifTrue:[^0].	self copyBitsFrom: targetX0 to: targetX1 at: targetY.	self showDisplayBits.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 15:35'!drawWideEdge: edge from: leftX	"Draw the given edge starting from leftX with the edge's fill.	Return the end value of the drawing operation."	| rightX fill type lineWidth |	self inline: false. "Not for the moment"	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ self makeUnsignedFrom: dispatchReturnValue.	fill = 0 ifTrue:[^leftX].	"self assert:(self isFillColor: fill)."	rightX _ leftX + lineWidth.	self fillSpan: fill from: leftX to: rightX.	^rightX! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 16:10'!fillBitmapSpan: bits from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge using the given bits.	Note: We always start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those with depth 32) directly."	| x0 x1 x bitX colorMask colorShift baseShift fillValue |	self inline: false.	self var: #bits declareC:'int *bits'.	x0 _ leftX.	x1 _ rightX.	bitX _ -1. "Hack for pre-increment"	self aaLevelGet = 1 ifTrue:["Speedy version for no anti-aliasing"		[x0 < x1] whileTrue:[			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			spanBuffer at: x0 put: fillValue.			x0 _ x0 + 1.		].	] ifFalse:["Generic version with anti-aliasing"		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		baseShift _ self aaShiftGet.		[x0 < x1] whileTrue:[			x _ x0 >> baseShift.			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			fillValue _ (fillValue bitAnd: colorMask) >> colorShift.			spanBuffer at: x put: (spanBuffer at: x) + fillValue.			x0 _ x0 + 1.		].	].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 03:30'!fillColorSpan: pixelValue32 from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge with the given pixel value."	| x0 x1 |	self inline: true.	"Use a unrolled version for anti-aliased fills..."	self aaLevelGet = 1		ifFalse:[^self fillColorSpanAA: pixelValue32 x0: leftX x1: rightX].	x0 _ leftX.	x1 _ rightX.	"Unroll the inner loop four times, since we're only storing data."	[x0 + 4 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		spanBuffer at: x0+1 put: pixelValue32.		spanBuffer at: x0+2 put: pixelValue32.		spanBuffer at: x0+3 put: pixelValue32.		x0 _ x0+4.	].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		x0 _ x0 + 1.	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:52'!fillColorSpanAA: pixelValue32 x0: leftX x1: rightX	"This is the inner loop for solid color fills with anti-aliasing.	This loop has been unrolled for speed and quality into three parts:		a) copy all pixels that fall into the first full pixel.		b) copy aaLevel pixels between the first and the last full pixel		c) copy all pixels that fall in the last full pixel"	| colorMask baseShift x idx firstPixel lastPixel aaLevel pv32 |	self inline: false. "Not now -- maybe later"	"Compute the pixel boundaries."	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	x _ leftX.	"Part a: Deal with the first n sub-pixels"	x < firstPixel ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < firstPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].	"Part b: Deal with the full pixels"	x < lastPixel ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		pv32 _ (pixelValue32 bitAnd: colorMask) >> self aaShiftGet.		[x < lastPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + aaLevel.		].	].	"Part c: Deal with the last n sub-pixels"	x < rightX ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < rightX] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/15/1998 02:04'!fillSpan: fill from: leftX to: rightX	"Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code."	| x0 x1 type |	self inline: false.	fill = 0 ifTrue:[^false]. "Nothing to do"	"Start from spEnd - we must not paint pixels twice at a scan line"	leftX < self spanEndAAGet 		ifTrue:[x0 _ self spanEndAAGet]		ifFalse:[x0 _ leftX].	rightX > (self spanSizeGet << self aaShiftGet) 		ifTrue:[x1 _ (self spanSizeGet << self aaShiftGet)]		ifFalse:[x1 _ rightX].	"Clip left and right values"	x0 < self fillMinXGet ifTrue:[x0 _ self fillMinXGet].	x1 > self fillMaxXGet ifTrue:[x1 _ self fillMaxXGet].	"Adjust start and end values of span"	x0 < self spanStartGet ifTrue:[self spanStartPut: x0].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].	x0 >= x1 ifTrue:[^false]. "Nothing to do"	(self isFillColor: fill) ifTrue:[		self fillColorSpan: fill from: x0 to: x1.	] ifFalse:[		"Store the values for the dispatch"		self lastExportedFillPut: fill.		self lastExportedLeftXPut: x0.		self lastExportedRightXPut: x1.		type _ self fillTypeOf: fill.		type <= 1 ifTrue:[^true].		self dispatchOn: type in: FillTable.	].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 15:13'!postDisplayAction	"We have just blitted a scan line to the screen.	Do whatever seems to be a good idea here."	"Note: In the future we may check the time needed for this scan line and interrupt processing to give the Smalltalk code a chance to run at a certain time."	self inline: false.	"Check if there is any more work to do."	(self getStartGet >= self getUsedGet and:[self aetUsedGet = 0]) ifTrue:[		"No more entries to process"		self statePut: GEStateCompleted.	].	(self currentYGet >= self fillMaxYGet) ifTrue:[		"Out of clipping range"		self statePut: GEStateCompleted.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/8/1998 14:26'!incrementPoint: point by: delta	self var: #point declareC:'int *point'.	point at: 0 put: (point at: 0) + delta.	point at: 1 put: (point at: 1) + delta.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/11/1998 20:33'!transformPoint: point haveMatrix: haveMatrix	"Transform the given point. If haveMatrix is true then use the current transformation."	self var:#point declareC:'int *point'.	haveMatrix ifFalse:[		"Multiply each component by aaLevel and add a half pixel"		point at: 0 put: (point at: 0) + self destOffsetXGet * self aaLevelGet.		point at: 1 put: (point at: 1) + self destOffsetYGet * self aaLevelGet.	] ifTrue:[		"Note: AA adjustment is done in #transformPoint: for higher accuracy"		self transformPoint: point into: point.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/1/1998 16:59'!transformPoint: srcPoint into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This method has been rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	self inline: true.	self transformPointX: ((self cCoerce: srcPoint to: 'int *') at: 0) asFloat 		y: ((self cCoerce: srcPoint to:'int *') at: 1) asFloat		into: (self cCoerce: dstPoint to: 'int *')! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/1/1998 16:56'!transformPointX: xValue y: yValue into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This should be rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	| x y |	self inline: true. "Won't help at the moment ;-("	self var: #dstPoint declareC:'int *dstPoint'.	self var: #xValue declareC: 'double xValue'.	self var: #yValue declareC: 'double yValue'.	x _ ((((edgeTransform at: 0) * xValue) +		((edgeTransform at: 1) * yValue) +		(edgeTransform at: 2)) * self aaLevelGet asFloat) asInteger.	y _ ((((edgeTransform at: 3) * xValue) +		((edgeTransform at: 4) * yValue) +		(edgeTransform at: 5)) * self aaLevelGet asFloat) asInteger.	dstPoint at: 0 put: x.	dstPoint at: 1 put: y.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/11/1998 20:35'!transformPoints: n haveMatrix: haveMatrix	"Transform n (n=1,2,3) points.	If haveMatrix is true then the matrix contains the actual transformation."	self inline: true.	n > 0 ifTrue:[self transformPoint: self point1Get haveMatrix: haveMatrix].	n > 1 ifTrue:[self transformPoint: self point2Get haveMatrix: haveMatrix].	n > 2 ifTrue:[self transformPoint: self point3Get haveMatrix: haveMatrix].	n > 3 ifTrue:[self transformPoint: self point4Get haveMatrix: haveMatrix].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/12/1998 13:29'!transformWidth: w haveMatrix: haveMatrix	"Transform the given width"	| deltaX deltaY destWidth destWidth2 |	self inline: false.	self var: #deltaX declareC:'double deltaX'.	self var: #deltaY declareC:'double deltaY'.	w = 0 ifTrue:[^0].	self point1Get at: 0 put: 0.	self point1Get at: 1 put: 0.	self point2Get at: 0 put: w * 256.	self point2Get at: 1 put: 0.	self point3Get at: 0 put: 0.	self point3Get at: 1 put: w * 256.	self transformPoints: 3 haveMatrix: haveMatrix.	deltaX _ ((self point2Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point2Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	deltaX _ ((self point3Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point3Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth2 _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	destWidth2 < destWidth ifTrue:[destWidth _ destWidth2].	destWidth = 0		ifTrue:[^1]		ifFalse:[^destWidth]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/9/1998 02:06'!accurateLengthOf: deltaX with: deltaY	"Return the accurate length of the vector described by deltaX and deltaY"	| length2 |	deltaX = 0 ifTrue:[deltaY < 0 ifTrue:[^0-deltaY] ifFalse:[^deltaY]].	deltaY = 0 ifTrue:[deltaX < 0 ifTrue:[^0-deltaX] ifFalse:[^deltaX]].	length2 _ (deltaX * deltaX) + (deltaY * deltaY).	^self computeSqrt: length2! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!computeSqrt: length2	length2 < 32 		ifTrue:[^self smallSqrtTable at: length2]		ifFalse:[^(length2 asFloat sqrt + 0.5) asInteger]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 14:33'!estimatedLengthOf: deltaX with: deltaY	"Estimate the length of the vector described by deltaX and deltaY.	This method may be extremely inaccurate - use it only	if you know exactly that this doesn't matter. Otherwise	use #accurateLengthOf:width:"	| absDx absDy |	deltaX >= 0 ifTrue:[absDx _ deltaX] ifFalse:[absDx _ 0 - deltaX].	deltaY >= 0 ifTrue:[absDy _ deltaY] ifFalse:[absDy _ 0 - deltaY].	absDx > absDy 		ifTrue:[^absDx + (absDy // 2)]		ifFalse:[^absDy + (absDx // 2)]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!resetGraphicsEngineStats	self inline: false.	workBuffer at: GWTimeInitializing put: 0.	workBuffer at: GWTimeFinishTest put: 0.	workBuffer at: GWTimeNextGETEntry put: 0.	workBuffer at: GWTimeAddAETEntry put: 0.	workBuffer at: GWTimeNextFillEntry put: 0.	workBuffer at: GWTimeMergeFill put: 0.	workBuffer at: GWTimeDisplaySpan put: 0.	workBuffer at: GWTimeNextAETEntry put: 0.	workBuffer at: GWTimeChangeAETEntry put: 0.	workBuffer at: GWCountInitializing put: 0.	workBuffer at: GWCountFinishTest put: 0.	workBuffer at: GWCountNextGETEntry put: 0.	workBuffer at: GWCountAddAETEntry put: 0.	workBuffer at: GWCountNextFillEntry put: 0.	workBuffer at: GWCountMergeFill put: 0.	workBuffer at: GWCountDisplaySpan put: 0.	workBuffer at: GWCountNextAETEntry put: 0.	workBuffer at: GWCountChangeAETEntry put: 0.	workBuffer at: GWBezierMonotonSubdivisions put: 0.	workBuffer at: GWBezierHeightSubdivisions put: 0.	workBuffer at: GWBezierOverflowSubdivisions put: 0.	workBuffer at: GWBezierLineConversions put: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!setAALevel: level	"Set the anti-aliasing level. Three levels are supported:		1 - No antialiasing		2 - 2x2 unweighted anti-aliasing		4 - 4x4 unweighted anti-aliasing.	"	| aaLevel |	self inline: false.	level >= 4 ifTrue:[aaLevel _ 4].	(level >= 2) & (level < 4) ifTrue:[aaLevel _ 2].	level < 2 ifTrue:[aaLevel _ 1].	self aaLevelPut: aaLevel.	aaLevel = 1 ifTrue:[		self aaShiftPut: 0.		self aaColorMaskPut: 16rFFFFFFFF.		self aaScanMaskPut: 0.	].	aaLevel = 2 ifTrue:[		self aaShiftPut: 1.		self aaColorMaskPut: 16rFCFCFCFC.		self aaScanMaskPut: 1.	].	aaLevel = 4 ifTrue:[		self aaShiftPut: 2.		self aaColorMaskPut: 16rF0F0F0F0.		self aaScanMaskPut: 3.	].	self aaColorShiftPut: self aaShiftGet * 2.	self aaHalfPixelPut: self aaShiftGet.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 15:25'!smallSqrtTable	| theTable |	self inline: false.	self returnTypeC:'int *'.	self var: #theTable declareC:'static int theTable[32] = 	{0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6}'.	^theTable! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 20:57'!squaredLengthOf: deltaX with: deltaY	^(deltaX * deltaX) + (deltaY * deltaY)! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/29/1998 18:45'!errorWrongIndex	self error:'BalloonEngine: Fatal dispatch error'! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/28/1998 20:58'!makeUnsignedFrom: someIntegerValue	^someIntegerValue! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 10/31/1998 00:48'!declareCVarsIn: cg	"Buffers"	cg var: 'workBuffer' declareC:'int *workBuffer'.	cg var: 'objBuffer' declareC:'int *objBuffer'.	cg var: 'getBuffer' declareC:'int *getBuffer'.	cg var: 'aetBuffer' declareC:'int *aetBuffer'.	cg var: 'spanBuffer' declareC:'unsigned int *spanBuffer'.	cg var: 'edgeTransform' declareC: 'float edgeTransform[6]'.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/7/1998 22:26'!initialize	"BalloonEngineBase initialize"	"BalloonEnginePlugin translateDoInlining: true."	EdgeInitTable _ self initializeEdgeInitTable.	EdgeStepTable _ self initializeEdgeStepTable.	WideLineWidthTable _ self initializeWideLineWidthTable.	WideLineFillTable _ self initializeWideLineFillTable.	FillTable _ self initializeFillTable.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeInitTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToFirstLine		stepToFirstWideLine		stepToFirstBezier		stepToFirstWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeStepTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToNextLine		stepToNextWideLine		stepToNextBezier		stepToNextWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/7/1998 22:26'!initializeFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex "Type zero - undefined"		errorWrongIndex "Type one - external fill"		fillLinearGradient "Linear gradient fill"		fillRadialGradient "Radial gradient fill"	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineFill		returnWideBezierFill	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineWidthTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineWidth		returnWideBezierWidth	)! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 10/28/1998 20:48'!moduleName	^'sqBalloonEngine'! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 11/11/1998 21:56'!simulatorClass	^BalloonEngineSimulation! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:33'!a1EngineOutline	"The following is a brief outline on how the engine works.	In general, we're using a pretty straight-forward active edge approach, e.g., 	we classify all edges into three different states:		a) Waiting for processing		b) Active (e.g., being processed)		c) Finished	Before the engine starts all edges are sorted by their y-value in a so-called	'global edge table' (furthermore referred to as GET) and processed in top 	to bottom order (the edges are also sorted by x-value but this is only for 	simplifying the insertion when adding edges).	Then, we start at the first visible scan line and execute the following steps:	1) Move all edges starting at the current scan line from state a) to state b)	This step requires the GET to be sorted so that we only need to check	the first edges of the GET. After the initial state of the edge (e.g., it's current	pixel value and data required for incremental updates) the edges are then 	inserted in the 'active edge table' (called AET). The sort order in the AET is 	defined by the pixel position of each edge at the current scan line and thus 	edges are kept in increasing x-order.	This step does occur for every edge only once and is therefore not the most	time-critical part of the approach.	2) Draw the current scan line	This step includes two sub-parts. In the first part, the scan line is assembled.	This involves walking through the AET and drawing the pixels between	each two neighbour edges. Since each edge can have two associated fills	(a 'left' and a 'right' fill) we need to make sure that edges falling on the	same pixel position do not affect the painted image. This issue is discussed	in the aetScanningProblems documentation.	Wide edges (e.g., edges having an associated width) are also handled during	this step. Wide edges are always preferred over interior fills - this ensures	that the outline of an object cannot be overdrawn by any interior fill of	a shape that ends very close to the edge (for more information see wideEdges 	documentation).	After the scan is assembled it is blitted to the screen. This only happens all	'aaLevel' scan lines (for further information see the antiAliasing documentation).	This second step is done at each scan line in the image, and is usually the most	time-critical part.	3) Update all currently active edges	Updating the active edges basically means either to remove the edge from the AET	(if it is at the end y value) or incrementally computing the pixel value for the	next scan line. Based on the information gathered in the first step, this part	should be executed as fast as possible - it happens for each edge in the AET	at each scan line and may be the bottleneck if many edges are involved in	the drawing operations (see the TODO list; part of it probably deals with the	issue)."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:55'!a2AntiAliasing	"The engine currently used a very simple, but efficient anti-aliasing scheme. It is based on a square unweighted filter of size 1, 2, or 4 resulting in three levels of anti-aliasing:	* No anti-aliasing (filter size 1)	This simply draws each pixel 'as is' on the screen	* Slight anti-aliasing (filter size 2)	Doubles the rasterization size in each direction and assembles the pixel value as the medium of the four sub-pixels falling into the full pixel	* Full anti-aliasing (filter size 4)	Quadruples the rasterization in each direction and assembles the pixel value as the medium of the sixteen sub-pixels falling into the full pixelThe reason for using these three AA levels is simply efficiency of computing. Since the above filters (1x1, 2x2, 4x4) have all power of two elements (1, 4, and 16) we can compute the weighted sum of the final pixel by computing	destColor _ destColor + (srcColor // subPixels)And, since we're only working on 32bit destination buffer we do not need to compute the components of each color separately but can neatly put the entire color into a single formula:	destPixel32 _ destPixel32 + ((srcPixel32 bitAnd: aaMask) >> aaShift).with aaMask = 16rFFFFFFFF for aaLevel = 1, aaMask = 16rFCFCFCFC for aaLevel = 2, aaMask = 16rF0F0F0F0 for aaLevel = 4 and aaShift = 0, 2, or 4 for the different levels. However, while the above is efficient to compute, it also drops accuracy. So, for the 4x4 anti-aliasing we're effectively only using the high 4 bits of each color component. While is generally not a problem (we add 16 sub-pixels into this value) there is a simple arithmetic difficulty because the above cannot fill the entire range of values, e.g.,	16 * (255 // 16) = 16 * 15 = 240and not 255 as expected. We solve this problem by replicating the top n (n=0, 2, 4) bits of each component as the low bits in an adjustment step before blitting to scan line to the screen. This has the nice effect that a zero pixel value (e.g., transparent) will remain zero, a white pixel (as computed above) will result in a value of 255 for each component (defining opaque white) and each color inbetween linearly mapped between 0 and 255. "	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a3RasterizationRules	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a4WideEdges! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:36'!a5AETScanningProblems	"Due to having two fill entries (one left and one right) there can be problems while scanning the active edge table. In general, the AET should look like the following (ri - regions, ei - edges, fi - fills):			|				\				|	r1		|		r2		 \		r3		|		r4			|				  \				|			e1				 e2				e3			with:		f(r1) = fLeft(e1) = 0				(empty fill, denoted -)		f(r2) = fRight(e1) = fLeft(e2)		(denoted x)		f(r3) = fRight(e2) = fLeft(e3)	(denoted o)		f(r4) = fRight(e3) = 0	However, due to integer arithmetic used during computations the AET may look like the following:			X			\|						|			 | \						|			 |   \					|	r1		 | r2 \			r3		|		r4			 |	   \					|			e1		e2				e3			In this case, the starting point of e1 and e2 have the same x value at the first scan line but e2 has been sorted before e1 (Note: This can happen in *many* cases - the above is just a very simple example). Given the above outlined fill relations we have a problem. So, for instance, using the left/right fills as defined by the edges would lead to the effect that in the first scan line region r3 is actually filled with the right fill of e1 while it should actually be filled with the right fill of e2. This leads to noticable artifacts in the image and increasing resolution does not help.	What we do here is defining an arbitrary sort order between fills (you can think of it as a depth value but the only thing that matters is that you can order the fills by this number and that the empty fill is always sorted at the end), and toggle the fills between an 'active' and an 'inactive' state at each edge. This is done as follows:	For each edge ei in the AET do:		* if fLeft(ei) isActive then removeActive(fLeft(ei)) else addActive(fLeft(ei))		* if fRight(ei) isActive then removeActive(fRight(ei)) else addActive(fRight(ei))		* draw the span from ei to ei+1 with currentActive	where addActive adds the fill to the list of currently active fills, removeActive() removes the fill from the active list and currentActive returns the fill AS DEFINED BY THE SORT ORDER from the list of active fills. Note that this does not change anything in the first example above because the list will only contain one entry (besides the empty fill). In the second case however, it will lead to the following sequence:	* toggle fLeft(e2) = f(r2) = 'x'		- makes fLeft(e2) active		- activeList = 'x'	* toggle fRight(e2) = f(r3) = 'o'		- makes fRight(e2) active		- activeList = 'xo'	* draw span from e2 to e1		Depending on the sort order between 'x' and 'o' the region will be drawn with either one of the fills. It is significant to note here that the occurence of such a problem is generally only *very* few pixels large (in the above example zero pixels) and will therefore not be visually noticable. In any case, there is a unique decision for the fill to use here and that is what we need if the problem did not happen accidentally (e.g., someone has manually changed one fill of an edge but not the fill of the opposite edge).	* toggle fLeft(e1) = f(r1) = '-'		- makes fLeft(r1) visible		- activeList = 'xo-'		[Note: empty fills are a special case. 		They can be ignored since they sort last		and the activeList can return the empty		fill if it is itself empty].	* toggle fRight(e1) = f(r2) = 'x'		- makes fRight(e1) invisible		- activeList = 'o-'	* draw span from e2 to e3		Since the active list contains (besides the empty fill) only one fill value this will be used. Fortunately, this is the correct fill because it is the fill we had initially defined for the region r2.An interesting side effect of the above is that there is no such notion as a 'left' or 'right' fill anymore. Another (not-so-nice) side effect is that the entire AET has to be scanned from the beginning even if only the last few edges actually affect the visible region.PS. I need to find a way of clipping the edges for this. More on it later..."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/8/1998 00:06'!a6StuffTODO	"This is an unordered list of things to do:BalloonEnginePlugin>>stepToFirstBezierIn:at:	1)	Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure.BalloonEngineBase>>dispatchOn:in:	1)	Check what dispatches cost most and must be inlined		by an #inlinedDispatchOn:in: Probably this will be		stepping and eventually wide line stuff but we'll see.BalloonEngineBase	1)	Check which variables should become inst vars, if any.		This will remove an indirection during memory access		and might allow a couple of optimizations by the C compiler.Anti-Aliasing:	1)	Check if we can use a weighted 3x3 filter function of the form				1	2	1				2	4	2				1	2	1		Which should be *extremely* nice for fonts (it's sharpening		edges). The good thing about the above is that it sums up to		16 (as in the 4x4 case) but I don't know how to keep a history		without needing two extra scan lines.	2)	Check if we can - somehow - integrate more general filters.	3) Unroll the loops during AA so we can copy and mask aaLevel pixels	   in each step between start and end. This should speed up filling	   by a factor of 2-4 (in particular for difficult stuff like radial gradients).Clipping	1)	Find a way of clipping edges left of the clip rectangle		or at least ignoring most of them after the first scan line.		The AET scanning problems discuss the issue but it should be		possible to keep the color list between spans (if not empty)		and speed up drawing at the very right (such as in the		Winnie Pooh example where a lot of stuff is between the		left border and the clipping rect.	2)	Check if we can determine empty states of the color list and		an edge that is longer than anything left of it. This should		work in theory but might be relatively expensive to compute."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'private' stamp: 'ar 11/9/1998 15:41'!localTranslate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		BalloonEnginePlugin localTranslate: 'sqBalloonEngine.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ CCodeGenerator new initialize.	theClass _ self.	[theClass == InterpreterPlugin] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initEdgeConstants: dict	"Initialize the edge constants"	self initFromSpecArray:	#(		"Edge primitive types"		(GEPrimitiveEdge 2)			"External edge - not handled by the GE"		(GEPrimitiveWideEdge 3)		"Wide external edge"		(GEPrimitiveLine 4)			"Straight line"		(GEPrimitiveWideLine 5)		"Wide line"		(GEPrimitiveBezier 6)		"Quadratic bezier curve"		(GEPrimitiveWideBezier 7)	"Wide bezier curve"		"Special flags"		(GEPrimitiveWide 16r01)		"Flag determining a wide primitive"		(GEPrimitiveWideMask 16rFE)	"Mask for clearing the wide flag"		(GEEdgeFillsInvalid 16r10000) "Flag determining if left/right fills of an edge are invalid"		"General edge state constants"		(GEXValue 4)					"Current raster x"		(GEYValue 5)					"Current raster y"		(GEZValue 6)					"Current raster z"		(GENumLines 7)					"Number of scan lines remaining"		(GEFillIndexLeft 8)				"Left fill index"		(GEFillIndexRight 9)				"Right fill index"		(GEBaseEdgeSize 10)				"Basic size of each edge"		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"General Line state constants"		(GLXDirection 10)				"Direction of edge (1: left-to-right; -1: right-to-left)"		(GLYDirection 11)				"Direction of edge (1: top-to-bottom; -1: bottom-to-top)"		(GLXIncrement 12)				"Increment at each scan line"		(GLError 13)						"Current error"		(GLErrorAdjUp 14)				"Error to add at each scan line"		(GLErrorAdjDown 15)				"Error to subtract on roll-over"			"Note: The following entries are only needed before the incremental			state is computed. They are therefore aliased to the error values above"		(GLEndX 14)						"End X of line"		(GLEndY 15)						"End Y of line"		(GLBaseSize 16)					"Basic size of each line"		"Additional stuff for wide lines"		(GLWideFill 16)					"Current fill of line"		(GLWideWidth 17)				"Current width of line"		(GLWideEntry 18)				"Initial steps"		(GLWideExit 19)					"Final steps"		(GLWideExtent 20)				"Target width"		(GLWideSize 21)					"Size of wide lines"		"General Bezier state constants"		(GBUpdateData 10)				"Incremental update data for beziers"			(GBUpdateX 0)				"Last computed X value (24.8)"			(GBUpdateY 1)				"Last computed Y value (24.8)"			(GBUpdateDX 2)				"Delta X forward difference step (8.24)"			(GBUpdateDY 3)				"Delta Y forward difference step (8.24)"			(GBUpdateDDX 4)				"Delta DX forward difference step (8.24)"			(GBUpdateDDY 5)				"Delta DY forward difference step (8.24)"		"Note: The following four entries are only needed before the incremental			state is computed. They are therefore aliased to the incremental values above"		(GBViaX 12)						"via x"		(GBViaY 13)						"via y"		(GBEndX 14)						"end x"		(GBEndY 15)						"end y"		(GBBaseSize 16)					"Basic size of each bezier.										Note: MUST be greater or equal to the size of lines"		"Additional stuff for wide beziers"		(GBWideFill 16)					"Current fill of line"		(GBWideWidth 17)				"Current width of line"		(GBWideEntry 18)				"Initial steps"		(GBWideExit 19)					"Final steps"		(GBWideExtent 20)				"Target extent"		(GBFinalX 21)					"Final X value"		(GBWideUpdateData 22)	"Update data for second curve"		(GBWideSize 28)					"Size of wide beziers"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initFillConstants: dict	"Initialize the fill constants"	self initFromSpecArray:	#(		"Fill primitive types"		(GEPrimitiveFill 16r100)		(GEPrimitiveLinearGradientFill 16r200)		(GEPrimitiveRadialGradientFill 16r300)		(GEPrimitiveClippedBitmapFill 16r400)		(GEPrimitiveRepeatedBitmapFill 16r500)		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"Gradient fill constants"		(GFOriginX 4)				"X origin of fill"		(GFOriginY 5)				"Y origin of fill"		(GFDirectionX 6)				"X direction of fill"		(GFDirectionY 7)				"Y direction of fill"		(GFNormalX 8)				"X normal of fill"		(GFNormalY 9)				"Y normal of fill"		(GFRampLength 10)			"Length of following color ramp"		(GFRampOffset 12)			"Offset of first ramp entry"		(GGBaseSize 12)	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initFromSpecArray: specArray in: aDictionary	specArray do:[:spec|		self initPoolVariable: spec first value: spec last in: aDictionary.	]! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool	"BalloonEngineBase initPool"	(Smalltalk includesKey: #BalloonEngineConstants) ifFalse:[		Smalltalk declare: #BalloonEngineConstants from: Undeclared.	].	(Smalltalk at: #BalloonEngineConstants) isNil ifTrue:[		(Smalltalk associationAt: #BalloonEngineConstants) value: Dictionary new.	].	self initPool: (Smalltalk at: #BalloonEngineConstants).! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool: aDictionary	self initStateConstants: aDictionary.	self initWorkBufferConstants: aDictionary.	self initPrimitiveConstants: aDictionary.	self initEdgeConstants: aDictionary.	self initFillConstants: aDictionary.	self initializeInstVarNames: BalloonEngine in: aDictionary prefixedBy: 'BE'.	self initializeInstVarNames: BalloonEdgeData in: aDictionary prefixedBy: 'ET'.	self initializeInstVarNames: BalloonFillData in: aDictionary prefixedBy: 'FT'.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolFull	"BalloonEngineBase initPoolFull"	"Move old stuff to Undeclared and re-initialize the receiver"	BalloonEngineConstants associationsDo:[:assoc|		Undeclared declare: assoc key from: BalloonEngineConstants.	].	self initPool.	Undeclared removeUnreferencedKeys.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolVariable: token value: value in: aDictionary	aDictionary declare: token from: Undeclared.	(aDictionary associationAt: token) value: value.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPrimitiveConstants: dict	"Initialize the primitive constants"	self initFromSpecArray:	#(		"Primitive type constants"		(GEPrimitiveUnknown 0)		(GEPrimitiveEdgeMask 16rFF)		(GEPrimitiveFillMask 16rFF00)		(GEPrimitiveTypeMask 16rFFFF)		"General state constants (Note: could be compressed later)"		(GEObjectType 0)				"Type of object"		(GEObjectLength 1)			"Length of object"		(GEObjectIndex 2)			"Index into external objects"		(GEObjectUnused 3)			"Currently unused"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initStateConstants: dict	"Initialize the state Constants"	self initFromSpecArray:	#(		(GEStateUnlocked 0)			"Buffer is unlocked and can be modified as wanted"		(GEStateAddingFromGET 1)	"Adding edges from the GET"		(GEStateWaitingForEdge 2)	"Waiting for edges added to GET"		(GEStateScanningAET 3)		"Scanning the active edge table"		(GEStateWaitingForFill 4)		"Waiting for a fill to mix in during AET scan"		(GEStateBlitBuffer 5)			"Blt the current scan line"		(GEStateUpdateEdges 6)		"Update edges to next scan line"		(GEStateWaitingChange 7)	"Waiting for a changed edge"		(GEStateCompleted 8)			"Rendering completed"		"Error constants"		(GErrorNoMoreSpace 1)		"No more space in collection"		(GErrorBadState 2)			"Tried to call a primitive while engine in bad state"		"Incremental error constants"		(GErrorGETEntry 4)			"Unknown entry in GET"		(GErrorFillEntry 5)			"Unknown FILL encountered"		(GErrorAETEntry 6)			"Unknown entry in AET"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initWorkBufferConstants: dict	"Initialize the work buffer constants"	self initFromSpecArray:	#(		"General work buffer constants"		(GWMagicNumber 16r416E6469)	"Magic number"		(GWHeaderSize 128)				"Size of header"		(GWMinimalSize 256)				"Minimal size of work buffer"		"Header entries"		(GWMagicIndex 0)				"Index of magic number"		(GWSize 1)						"Size of full buffer"		(GWState 2)						"Current state (e.g., locked or not)"		"Buffer entries"		(GWObjStart 8)					"objStart"		(GWObjUsed 9)					"objUsed"		(GWBufferTop 10)				"wbTop"		(GWGETStart 11)					"getStart"		(GWGETUsed 12)					"getUsed"		(GWAETStart 13)					"aetStart"		(GWAETUsed 14)					"aetUsed"		"Span entries"		(GWSpanStart 32)				"spStart"		(GWSpanSize 33)					"spSize"		(GWSpanEnd 34)					"spEnd"		(GWSpanEndAA 35)				"spEndAA"		"Bounds entries"		(GWFillMinX 36)					"fillMinX"		(GWFillMaxX 37)					"fillMaxX"		(GWFillMinY 38)					"fillMinY"		(GWFillMaxY 39)					"fillMaxY"		(GWFillOffsetX 40)				"fillOffsetX"		(GWFillOffsetY 41)				"fillOffsetY"		(GWClipMinX 42)		(GWClipMaxX 43)		(GWClipMinY 44)		(GWClipMaxY 45)		(GWDestOffsetX 46)		(GWDestOffsetY 47)		"AA entries"		(GWAALevel 48)					"aaLevel"		(GWAAShift 49)					"aaShift"		(GWAAColorShift 50)				"aaColorShift"		(GWAAColorMask 51)				"aaColorMask"		(GWAAScanMask 52)				"aaScanMask"		(GWAAHalfPixel 53)				"aaHalfPixel"		"Misc entries"		(GWStopReason 64)				"stopReason"		(GWLastExportedEdge 65)			"last exported edge"		(GWLastExportedFill 66)			"last exported fill"		(GWLastExportedLeftX 67)			"last exported leftX"		(GWLastExportedRightX 68)		"last exported rightX"		(GWClearSpanBuffer 69)			"Do we have to clear the span buffer?"		(GWPointListFirst 70)				"First point list in buffer"		(GWPoint1 80)		(GWPoint2 82)		(GWPoint3 84)		(GWPoint4 86)		(GWCurrentY 88)		"Profile stats"		(GWTimeInitializing 90)		(GWCountInitializing 91)		(GWTimeFinishTest 92)		(GWCountFinishTest 93)		(GWTimeNextGETEntry 94)		(GWCountNextGETEntry 95)		(GWTimeAddAETEntry 96)		(GWCountAddAETEntry 97)		(GWTimeNextFillEntry 98)		(GWCountNextFillEntry 99)		(GWTimeMergeFill 100)		(GWCountMergeFill 101)		(GWTimeDisplaySpan 102)		(GWCountDisplaySpan 103)		(GWTimeNextAETEntry 104)		(GWCountNextAETEntry 105)		(GWTimeChangeAETEntry 106)		(GWCountChangeAETEntry 107)		"Bezier stats"		(GWBezierMonotonSubdivisions 108) 	"# of subdivision due to non-monoton beziers"		(GWBezierHeightSubdivisions 109)		"# of subdivisions due to excessive height"		(GWBezierOverflowSubdivisions 110)	"# of subdivisions due to possible int overflow"		(GWBezierLineConversions 111)		"# of beziers converted to lines"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initializeInstVarNames: aClass in: aDictionary prefixedBy: aString	| token value |	aClass instVarNames doWithIndex:[:instVarName :index|		token _ (aString, instVarName first asUppercase asString, (instVarName copyFrom: 2 to: instVarName size),'Index') asSymbol.		value _ index - 1.		aDictionary declare: token from: Undeclared.		(aDictionary associationAt: token) value: value.	].	token _ (aString, aClass name,'Size') asSymbol.	aDictionary declare:  token from: Undeclared.	(aDictionary associationAt: token) value: aClass instSize.! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/14/1998 20:51'!gePrimitiveAddBezierShape	| transform points haveMatrix lineFill lineWidth fillIndex length isArray segSize nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	lineWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	nSegments _ interpreterProxy stackIntegerValue: 4.	points _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = (nSegments * 3) or:[length = (nSegments * 6)])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = (nSegments * 3)			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth haveMatrix: haveMatrix.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual shape"	isArray ifTrue:[		self loadArrayShape: points nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			haveMatrix: haveMatrix	] ifFalse:[		self loadShape: (interpreterProxy firstIndexableField: points) nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nSegments * 3 = length) haveMatrix: haveMatrix].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/8/1998 15:06'!gePrimitiveAddBezierWithMatrix	| leftFillIndex rightFillIndex viaOop endOop startOop transform nSegments haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	viaOop _ interpreterProxy stackObjectValue: 3.	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFillIndex) and:[self isFillOkay: rightFillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Do a quick check if the fillIndices are equal - if so, just ignore it"	leftFillIndex = rightFillIndex & false ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: viaOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^0].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^0].	self transformPoints: 3 haveMatrix: haveMatrix.	nSegments _ self loadAndSubdivideBezierFrom: self point1Get 						via: self point2Get 						to: self point3Get 						isWide: false.	self needAvailableSpace: nSegments * GBBaseSize.	engineStopped ifFalse:[		self loadWideBezier: 0 lineFill: 0 leftFill: leftFillIndex rightFill: rightFillIndex n: nSegments.	].	engineStopped ifTrue:[		"Make sure the stack is okay"		self wbStackClear.		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/12/1998 21:22'!gePrimitiveAddCompressedShape	| transform fillIndexList lineFills lineWidths rightFills leftFills nSegments points haveMatrix pointsShort |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 8 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	fillIndexList _ interpreterProxy stackObjectValue: 1.	lineFills _ interpreterProxy stackObjectValue: 2.	lineWidths _ interpreterProxy stackObjectValue: 3.	rightFills _ interpreterProxy stackObjectValue: 4.	leftFills _ interpreterProxy stackObjectValue: 5.	nSegments _ interpreterProxy stackIntegerValue: 6.	points _ interpreterProxy stackObjectValue: 7.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 8) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the compressed shape is okay"	(self checkCompressedShape: points 			segments: nSegments 			leftFills: leftFills 			rightFills: rightFills 			lineWidths: lineWidths 			lineFills: lineFills 			fillIndexList: fillIndexList) ifFalse:[^interpreterProxy primitiveFail].	"Now check that we have some hope to have enough free space.	Do this by assuming nSegments boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(self needAvailableSpace: (GBBaseSize max: GLBaseSize) * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if the points are short"	pointsShort _ (interpreterProxy slotSizeOf: points) = (nSegments * 3).	"Then actually load the compressed shape"	self loadCompressedShape: (interpreterProxy firstIndexableField: points)			segments: nSegments 			leftFills: (interpreterProxy firstIndexableField: leftFills)			rightFills: (interpreterProxy firstIndexableField: rightFills)			lineWidths: (interpreterProxy firstIndexableField: lineWidths)			lineFills: (interpreterProxy firstIndexableField: lineFills)			fillIndexList: (interpreterProxy firstIndexableField: fillIndexList)			haveMatrix: haveMatrix			pointShort: pointsShort.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 8. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/8/1998 16:15'!gePrimitiveAddGradientFill	| transform isRadial nrmOop dirOop originOop rampOop haveMatrix fill |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	isRadial _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 1).	nrmOop _ interpreterProxy stackValue: 2.	dirOop _ interpreterProxy stackValue: 3.	originOop _ interpreterProxy stackValue: 4.	rampOop _ interpreterProxy stackValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadGradientFill: rampOop 				from: self point1Get 				along: self point2Get 				normal: self point3Get 				isRadial: isRadial 				haveMatrix: haveMatrix.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 7.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/6/1998 01:39'!gePrimitiveAddLineWithMatrix	| leftFillIndex rightFillIndex endOop startOop transform haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFillIndex) and:[self isFillOkay: rightFillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Load the points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	"Transform points"	self transformPoints: 2 haveMatrix: haveMatrix.	"Load line"	self loadWideLine: 0 from: self point1Get to: self point2Get 		lineFill: 0 leftFill: leftFillIndex rightFill: rightFillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 22:18'!gePrimitiveAddOvalWithMatrix	| fillIndex borderWidth borderIndex endOop startOop transform objUsedNow haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	borderWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth <= 0]]) ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (16 * GBBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Note: If we run out of space, we have to restore objUsed"	objUsedNow _ self objUsedGet.	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth haveMatrix: haveMatrix]		ifFalse:[borderWidth _ 0].	"Load the rectangle points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self loadOval: borderWidth lineFill: borderIndex 		leftFill: 0 rightFill: fillIndex haveMatrix: haveMatrix.	engineStopped ifTrue:[		self wbStackClear.		self objUsedPut: objUsedNow.		^interpreterProxy primitiveFail.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/14/1998 20:09'!gePrimitiveAddPolygon	| transform points haveMatrix lineFill lineWidth fillIndex nPoints length isArray segSize |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	lineWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	nPoints _ interpreterProxy stackIntegerValue: 4.	points _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = nPoints or:[nPoints * 2 = length])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = nPoints			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nPoints)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth haveMatrix: haveMatrix.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual polygon"	isArray ifTrue:[		self loadArrayPolygon: points nPoints: nPoints			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			haveMatrix: haveMatrix	] ifFalse:[		self loadPolygon: (interpreterProxy firstIndexableField: points) nPoints: nPoints 			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nPoints = length) haveMatrix: haveMatrix].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 22:19'!gePrimitiveAddRectWithMatrix	| fillIndex borderWidth borderIndex endOop startOop transform haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	borderWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth = 0]]) ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (4 * GLBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth haveMatrix: haveMatrix]		ifFalse:[borderWidth _ 0].	"Load the rectangle"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^nil].	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).	"Transform the points"	self transformPoints: 4 haveMatrix: haveMatrix.	self loadRectangle: borderWidth lineFill: borderIndex leftFill: 0 rightFill: fillIndex.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 21:28'!gePrimitiveGetBezierStats	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 4		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWBezierMonotonSubdivisions).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWBezierHeightSubdivisions).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWBezierOverflowSubdivisions).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWBezierLineConversions).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:37'!lineEndXOf: line	^objBuffer at: line + GLEndX! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:37'!lineEndXOf: line put: value	^objBuffer at: line + GLEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineEndYOf: line	^objBuffer at: line + GLEndY! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineEndYOf: line put: value	^objBuffer at: line + GLEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjDownOf: line	^objBuffer at: line + GLErrorAdjDown! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjDownOf: line put: value	^objBuffer at: line + GLErrorAdjDown put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjUpOf: line	^objBuffer at: line + GLErrorAdjUp! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjUpOf: line put: value	^objBuffer at: line + GLErrorAdjUp put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorOf: line	^objBuffer at: line + GLError! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorOf: line put: value	^objBuffer at: line + GLError put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXDirectionOf: line	^objBuffer at: line + GLXDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXDirectionOf: line put: value	^objBuffer at: line + GLXDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXIncrementOf: line	^objBuffer at: line + GLXIncrement! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXIncrementOf: line put: value	^objBuffer at: line + GLXIncrement put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineYDirectionOf: line	^objBuffer at: line + GLYDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineYDirectionOf: line put: value	^objBuffer at: line + GLYDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:39'!wideLineEntryOf: line	^objBuffer at: line + GLWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:39'!wideLineEntryOf: line put: value	^objBuffer at: line + GLWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExitOf: line	^objBuffer at: line + GLWideExit! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExitOf: line put: value	^objBuffer at: line + GLWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExtentOf: line	^objBuffer at: line + GLWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExtentOf: line put: value	^objBuffer at: line + GLWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineFillOf: line	^objBuffer at: line + GLWideFill! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineFillOf: line put: value	^objBuffer at: line + GLWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineWidthOf: line	^objBuffer at: line + GLWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineWidthOf: line put: value	^objBuffer at: line + GLWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:34'!bezierEndXOf: bezier	^objBuffer at: bezier + GBEndX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndXOf: bezier put: value	^objBuffer at: bezier + GBEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndYOf: bezier	^objBuffer at: bezier + GBEndY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndYOf: bezier put: value	^objBuffer at: bezier + GBEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierFinalXOf: bezier	^objBuffer at: bezier + GBFinalX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierFinalXOf: bezier put: value	^objBuffer at: bezier + GBFinalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:36'!bezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:36'!bezierViaXOf: bezier	^objBuffer at: bezier + GBViaX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaXOf: bezier put: value	^objBuffer at: bezier + GBViaX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaYOf: bezier	^objBuffer at: bezier + GBViaY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaYOf: bezier put: value	^objBuffer at: bezier + GBViaY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index	^self wbStackValue: self wbStackSize - index + 4! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index put: value	^self wbStackValue: self wbStackSize - index + 4 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index	^self wbStackValue: self wbStackSize - index + 5! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index put: value	^self wbStackValue: self wbStackSize - index + 5 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index	^self wbStackValue: self wbStackSize - index + 0! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index put: value	^self wbStackValue: self wbStackSize - index + 0 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzStartY: index	^self wbStackValue: self wbStackSize - index + 1! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartY: index put: value	^self wbStackValue: self wbStackSize - index + 1 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaX: index	^self wbStackValue: self wbStackSize - index + 2! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaX: index put: value	^self wbStackValue: self wbStackSize - index + 2 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaY: index	^self wbStackValue: self wbStackSize - index + 3! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaY: index put: value	^self wbStackValue: self wbStackSize - index + 3 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierEntryOf: line	^objBuffer at: line + GBWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierEntryOf: line put: value	^objBuffer at: line + GBWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExitOf: line	^objBuffer at: line + GBWideExit! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExitOf: line put: value	^objBuffer at: line + GBWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExtentOf: bezier	^objBuffer at: bezier + GBWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExtentOf: bezier put: value	^objBuffer at: bezier + GBWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierFillOf: bezier	^objBuffer at: bezier + GBWideFill! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierFillOf: bezier put: value	^objBuffer at: bezier + GBWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBWideUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierWidthOf: line	^objBuffer at: line + GBWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierWidthOf: line put: value	^objBuffer at: line + GBWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionXOf: fill	^objBuffer at: fill + GFDirectionX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionXOf: fill put: value	^objBuffer at: fill + GFDirectionX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionYOf: fill	^objBuffer at: fill + GFDirectionY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionYOf: fill put: value	^objBuffer at: fill + GFDirectionY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalXOf: fill	^objBuffer at: fill + GFNormalX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalXOf: fill put: value	^objBuffer at: fill + GFNormalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalYOf: fill	^objBuffer at: fill + GFNormalY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalYOf: fill put: value	^objBuffer at: fill + GFNormalY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginXOf: fill	^objBuffer at: fill + GFOriginX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginXOf: fill put: value	^objBuffer at: fill + GFOriginX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginYOf: fill	^objBuffer at: fill + GFOriginY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginYOf: fill put: value	^objBuffer at: fill + GFOriginY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampLengthOf: fill	^objBuffer at: fill + GFRampLength! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampLengthOf: fill put: value	^objBuffer at: fill + GFRampLength put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampOf: fill	self returnTypeC:'int *'.	^objBuffer + fill + GFRampOffset! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isBezier: bezier	^((self objectTypeOf: bezier) bitAnd: GEPrimitiveWideMask) = GEPrimitiveBezier! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/8/1998 15:14'!isFillOkay: fill	self inline: false.	^(fill = 0 or:[(self isFillColor: fill) or:[((self isObject: fill) and:[self isFill: fill])]]) ! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isLine: line	^((self objectTypeOf: line) bitAnd: GEPrimitiveWideMask) = GEPrimitiveLine! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/6/1998 01:53'!isWideBezier: bezier	^(self isBezier: bezier) and:[self isWide: bezier]! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 22:08'!isWideLine: line	^(self isLine: line) and:[self isWide: line]! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:52'!stepToFirstLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstLineIn: line at: yValue	"Initialize the line at yValue"	| deltaX deltaY xDir widthX error xInc errorAdjUp startY |	self inline: false.	"Do a quick check if there is anything at all to do"	((self isWide: line) not and:[yValue >= (self lineEndYOf: line)])		ifTrue:[^self edgeNumLinesOf: line put: 0].	deltaX _ (self lineEndXOf: line) - (self edgeXValueOf: line).	deltaY _ (self lineEndYOf: line) - (self edgeYValueOf: line).	"Check if edge goes left to right"	deltaX >= 0 		ifTrue:[	xDir _ 1.				widthX _ deltaX.				error _ 0]		ifFalse:[	xDir _ -1.				widthX _ 0 - deltaX.				error _ 1 - deltaY].	"Check if deltaY is zero.	Note: We could actually get out here immediately 	but wide lines rely on an accurate setup in this case"	deltaY = 0		ifTrue:[	error _ 0.			"No error for horizontal edges"				xInc _ deltaX.		"Encodes width and direction"				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"				deltaY > widthX "Note: The '>' instead of '>=' could be important here..."					ifTrue:[	xInc _ 0.							errorAdjUp _ widthX]					ifFalse:[	xInc _ (widthX // deltaY) * xDir.							errorAdjUp _ widthX \\ deltaY]].	"Store the values"	self edgeNumLinesOf: line put: deltaY.	self lineXDirectionOf: line put: xDir.	"self lineYDirectionOf: line put: yDir." "<-- Already set"	self lineXIncrementOf: line put: xInc.	self lineErrorOf: line put: error.	self lineErrorAdjUpOf: line put: errorAdjUp.	self lineErrorAdjDownOf: line put: deltaY.	"And step to the first scan line"	(startY _ self edgeYValueOf: line) = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:53'!stepToNextLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextLineIn: line at: yValue	"Incrementally step to the next scan line in the given line"	| x  err |	self inline: true.	x _ (self edgeXValueOf: line) + (self lineXIncrementOf: line).	err _ (self lineErrorOf: line) + (self lineErrorAdjUpOf: line).	err > 0 ifTrue:[		x _ x + (self lineXDirectionOf: line).		err _ err - (self lineErrorAdjDownOf: line).	].	self lineErrorOf: line put: err.	self edgeXValueOf: line put: x.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/9/1998 15:38'!loadLine: line from: point1 to: point2 offset: yOffset leftFill: leftFill rightFill: rightFill	"Load the line defined by point1 and point2."	| p1 p2 yDir |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(point1 at: 1) <= (point2 at: 1) 		ifTrue:[	p1 _ point1.				p2 _ point2.				yDir _ 1]		ifFalse:[	p1 _ point2.				p2 _ point1.				yDir _ -1].	self edgeXValueOf: line put: (p1 at: 0).	self edgeYValueOf: line put: (p1 at: 1) - yOffset.	self edgeZValueOf: line put: 0.	self edgeLeftFillOf: line put: leftFill.	self edgeRightFillOf: line put: rightFill.	self lineEndXOf: line put: (p2 at: 0).	self lineEndYOf: line put: (p2 at: 1) - yOffset.	self lineYDirectionOf: line put: yDir.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/6/1998 17:07'!loadRectangle: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a rectangle currently defined by point1-point4"	self loadWideLine: lineWidth from: self point1Get to: self point2Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point2Get to: self point3Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point3Get to: self point4Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point4Get to: self point1Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/8/1998 19:24'!loadWideLine: lineWidth from: p1 to: p2 lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a (possibly wide) line defined by the points p1 and p2"	| line offset |	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[	line _ self allocateLine.				offset _ 0]		ifFalse:[	line _ self allocateWideLine.				offset _ self offsetFromWidth: lineWidth].	engineStopped ifTrue:[^0].	self loadLine: line 		from: p1		to: p2		offset: offset 		leftFill: leftFill		rightFill: rightFill.	(self isWide: line) ifTrue:[		self wideLineFillOf: line put: lineFill.		self wideLineWidthOf: line put: lineWidth.		self wideLineExtentOf: line put: lineWidth].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:34'!adjustWideLine: line afterSteppingFrom: lastX to: nextX	"Adjust the wide line after it has been stepped from lastX to nextX.	Special adjustments of line width and start position are made here	to simulate a rectangular brush"	|  yEntry yExit lineWidth lineOffset deltaX xDir baseWidth |	self inline: false.	"Don't inline this"	"Fetch the values the adjustment decisions are based on"	yEntry _ (self wideLineEntryOf: line).	yExit _ (self wideLineExitOf: line).	baseWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: baseWidth.	lineWidth _ self wideLineWidthOf: line.	xDir _ self lineXDirectionOf: line.	deltaX _ nextX - lastX.	"Adjust the start of the line to fill an entire rectangle"	yEntry < baseWidth ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth - deltaX] "effectively adding"			ifFalse:[	lineWidth _ lineWidth + deltaX.					self edgeXValueOf: line put: lastX].	].	"Adjust the end of x-major lines"	((yExit + lineOffset) = 0) ifTrue:[		xDir > 0			ifTrue:[lineWidth _ lineWidth - (self lineXIncrementOf: line)]			ifFalse:[lineWidth _ lineWidth + (self lineXIncrementOf: line).	"effectively subtracting"					self edgeXValueOf: line put: lastX].	].	"Adjust the end of the line to fill an entire rectangle"	(yExit + lineOffset) > 0 ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth + deltaX. "effectively subtracting"					self edgeXValueOf: line put: lastX]			ifFalse:[	lineWidth _ lineWidth - deltaX]	].	"Store the manipulated line width back"	self wideLineWidthOf: line put: lineWidth.! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineFill	"Return the fill of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineWidth	"Return the width of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:54'!stepToFirstWideLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideLineIn: line at: yValue	"Initialize the wide line at yValue."	| startY yEntry yExit lineWidth nLines lineOffset startX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the line"	startX _ self edgeXValueOf: line.	startY _ self edgeYValueOf: line.	self stepToFirstLineIn: line at: startY.	nLines _ (self edgeNumLinesOf: line).	xDir _ self lineXDirectionOf: line.	"Adjust the line to start at the correct X position"	self edgeXValueOf: line put: startX - lineOffset.	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: line put: nLines + lineWidth.	"Adjust the values for x-major lines"	xDir > 0 ifTrue:[		self wideLineWidthOf: line put: (self lineXIncrementOf: line) + lineWidth.	] ifFalse:[		self wideLineWidthOf: line put: lineWidth - (self lineXIncrementOf: line). "adding"		self edgeXValueOf: line put: (self edgeXValueOf: line) + (self lineXIncrementOf: line).	].	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: line]		ifFalse:[self edgeFillsInvalidate: line].	"And step to the first scan line"	startY = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextWideLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: (self edgeNumLinesOf: line) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:55'!stepToNextWideLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextWideLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideLineIn: line at: yValue	"Incrementally step to the next scan line in the given wide line"	|  yEntry yExit lineWidth lineOffset lastX nextX |	self inline: true.	"Adjust entry/exit values"	yEntry _ (self wideLineEntryOf: line) + 1.	yExit _ (self wideLineExitOf: line) + 1.	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn fills on/off"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: line].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: line].	"Step to the next scan line"	lastX _ self edgeXValueOf: line.	self stepToNextLineIn: line at: yValue.	nextX _ self edgeXValueOf: line.	"Check for special start/end adjustments"	(yEntry <= lineWidth or:[yExit+lineOffset >= 0]) ifTrue:[		"Yes, need an update"		self adjustWideLine: line afterSteppingFrom: lastX to: nextX.	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:56'!assureValue: val1 between: val2 and: val3	"Make sure that val1 is between val2 and val3."	self inline: true.	val2 > val3 ifTrue:[		val1 > val2 ifTrue:[^val2].		val1 < val3 ifTrue:[^val3].	] ifFalse:[		val1 < val2 ifTrue:[^val2].		val1 > val3 ifTrue:[^val3].	].	^val1	! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:57'!computeBezier: index splitAt: param	"Split the bezier curve at the given parametric value.	Note: Since this method is only invoked to make non-monoton		beziers monoton we must check for the resulting y values		to be *really* between the start and end value."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	self var: #param declareC:'double param'.	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	sharedX _ leftViaX _ leftViaX + ((viaX - startX) asFloat * param) asInteger.	sharedY _ leftViaY _ leftViaY + ((viaY - startY) asFloat * param) asInteger.	rightViaX _ rightViaX + ((endX - viaX) asFloat * param) asInteger.	rightViaY _ rightViaY + ((endY - viaY) asFloat * param) asInteger.	"Compute new shared point"	sharedX _ sharedX + ((rightViaX - leftViaX) asFloat * param) asInteger.	sharedY _ sharedY + ((rightViaY - leftViaY) asFloat * param) asInteger.	"Check the new via points"	leftViaY _ self assureValue: leftViaY between: startY and: sharedY.	rightViaY _ self assureValue: rightViaY between: sharedY and: endY.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/6/1998 01:26'!computeBezierSplitAtHalf: index	"Split the bezier curve at 0.5."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	leftViaX _ leftViaX + ((viaX - startX) // 2).	leftViaY _ leftViaY + ((viaY - startY) // 2).	sharedX _ rightViaX _ rightViaX + ((endX - viaX) // 2).	sharedY _ rightViaY _ rightViaY + ((endY - viaY) // 2).	"Compute new shared point"	sharedX _ sharedX + ((leftViaX - rightViaX) // 2).	sharedY _ sharedY + ((leftViaY - rightViaY) // 2).	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 20:15'!loadAndSubdivideBezierFrom: point1 via: point2 to: point3 isWide: wideFlag	"Load and subdivide the bezier curve from point1/point2/point3.	If wideFlag is set then make sure the curve is monoton in X."	| bz1 bz2 index2 index1 |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	bz1 _ self allocateBezierStackEntry.		engineStopped ifTrue:[^0].	"Load point1/point2/point3 on the top of the stack"	self bzStartX: bz1 put: (point1 at: 0).	self bzStartY: bz1 put: (point1 at: 1).	self bzViaX: bz1 put: (point2 at: 0).	self bzViaY: bz1 put: (point2 at: 1).	self bzEndX: bz1 put: (point3 at: 0).	self bzEndY: bz1 put: (point3 at: 1).	"Now check if the bezier curve is monoton. If not, subdivide it."	index2 _ bz2 _ self subdivideToBeMonoton: bz1 inX: wideFlag.	bz1 to: bz2 by: 6 do:[:index|		index1 _ self subdivideBezierFrom: index.		index1 > index2 ifTrue:[index2 _ index1].		engineStopped ifTrue:[^0]. "Something went wrong"	].	"Return the number of segments"	^index2 // 6! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:40'!loadBezier: bezier segment: index leftFill: leftFillIndex rightFill: rightFillIndex offset: yOffset	"Initialize the bezier segment stored on the stack"	self inline: false.	(self bzEndY: index) >= (self bzStartY: index) ifTrue:[		"Top to bottom"		self edgeXValueOf: bezier put: (self bzStartX: index).		self edgeYValueOf: bezier put: (self bzStartY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzEndX: index).		self bezierEndYOf: bezier put: (self bzEndY: index) - yOffset.	] ifFalse:[		self edgeXValueOf: bezier put: (self bzEndX: index).		self edgeYValueOf: bezier put: (self bzEndY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzStartX: index).		self bezierEndYOf: bezier put: (self bzStartY: index) - yOffset.	].	self edgeZValueOf: bezier put: 0.	self edgeLeftFillOf: bezier put: leftFillIndex.	self edgeRightFillOf: bezier put: rightFillIndex.	"self debugDrawBezier: bezier."! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!loadOval: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill haveMatrix: haveMatrix	"Load a rectangular oval currently defined by point1/point2"	| w h cx cy nSegments |	self inline: false.	w _ ((self point2Get at: 0) - (self point1Get at: 0)) // 2.	h _ ((self point2Get at: 1) - (self point1Get at: 1)) // 2.	cx _ ((self point2Get at: 0) + (self point1Get at: 0)) // 2.	cy _ ((self point2Get at: 1) + (self point1Get at: 1)) // 2.	0 to: 15 do:[:i|		self loadOvalSegment: i w: w h: h cx: cx cy: cy.		self transformPoints: 3 haveMatrix: haveMatrix.		nSegments _ self loadAndSubdivideBezierFrom: self point1Get 							via: self point2Get to: self point3Get							isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).		engineStopped ifTrue:[^nil].		self loadWideBezier: lineWidth lineFill: lineFill 			leftFill: leftFill rightFill: rightFill n: nSegments.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!loadOvalSegment: seg w: w h: h cx: cx cy: cy	| x0 y0 x2 y2 x1 y1 |	self inline: false.	"Load start point of segment"	x0 _ ((self circleCosTable at: seg * 2 + 0) * w asFloat + cx) asInteger.	y0 _ ((self circleSinTable at: seg * 2 + 0) * h asFloat + cy) asInteger.	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	"Load end point of segment"	x2 _ ((self circleCosTable at: seg * 2 + 2) * w asFloat + cx) asInteger.	y2 _ ((self circleSinTable at: seg * 2 + 2) * h asFloat + cy) asInteger.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	"Load intermediate point of segment"	x1 _ ((self circleCosTable at: seg * 2 + 1) * w asFloat + cx) asInteger.	y1 _ ((self circleSinTable at: seg * 2 + 1) * h asFloat + cy) asInteger.	"NOTE: The intermediate point is the point ON the curve	and not yet the control point (which is OFF the curve)"	x1 _ (x1 * 2) - (x0 + x2 // 2).	y1 _ (y1 * 2) - (y0 + y2 // 2).	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:41'!loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: nSegments	"Load the (possibly wide) bezier from the segments currently on the bezier stack."	| index bezier wide offset |	self inline: false.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[wide _ false.				offset _ 0]		ifFalse:[wide _ true.				offset _ self offsetFromWidth: lineWidth].	index _ nSegments * 6.	[index > 0] whileTrue:[		wide 			ifTrue:[bezier _ self allocateWideBezier]			ifFalse:[bezier _ self allocateBezier].		engineStopped ifTrue:[^0].		self loadBezier: bezier 			segment: index 			leftFill: leftFill 			rightFill: rightFill 			offset: offset.		wide ifTrue:[			self wideBezierFillOf: bezier put: lineFill.			self wideBezierWidthOf: bezier put: lineWidth.			self wideBezierExtentOf: bezier put: lineWidth.		].		index _ index - 6.	].	self wbStackClear.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 14:36'!subdivideBezier: index	"Subdivide the given bezier curve if necessary"	| startX startY endX endY deltaX deltaY |	self inline: false.	startY _ self bzStartY: index.	endY _ self bzEndY: index.	"If the receiver is horizontal, don't do anything"	(endY = startY) ifTrue:[^index].	"TODO: If the curve can be represented as a line, then do so"	"If the height of the curve exceeds 256 pixels, subdivide 	(forward differencing is numerically not very stable)"	deltaY _ endY - startY.	deltaY < 0 ifTrue:[deltaY _ 0 - deltaY].	(deltaY > 255) ifTrue:[		self incrementStat: GWBezierHeightSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	"Check if the incremental values could possibly overflow the scaled integer range"	startX _ self bzStartX: index.	endX _ self bzEndX: index.	deltaX _ endX - startX.	deltaX < 0 ifTrue:[deltaX _ 0 - deltaX].	deltaY * 32 < deltaX ifTrue:[		self incrementStat: GWBezierOverflowSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:43'!subdivideBezierFrom: index	"Recursively subdivide the curve on the bezier stack."	| otherIndex index1 index2 |	self inline: false.	otherIndex _ self subdivideBezier: index.	otherIndex = index ifFalse:[		index1 _ self subdivideBezierFrom: index.		engineStopped ifTrue:[^0].		index2 _ self subdivideBezierFrom: otherIndex.		engineStopped ifTrue:[^0].		index1 >= index2			ifTrue:[^index1]			ifFalse:[^index2]	].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!subdivideToBeMonoton: base inX: doTestX	"Check if the given bezier curve is monoton in Y, and, if desired in X. 	If not, subdivide it"	| index1 index2 base2 |	self inline: false.	base2 _ index1 _ index2 _ self subdivideToBeMonotonInY: base.	doTestX ifTrue:[index1 _ self subdivideToBeMonotonInX: base].	index1 > index2 ifTrue:[index2 _ index1].	(base ~= base2 and:[doTestX]) ifTrue:[index1 _ self subdivideToBeMonotonInX: base2].	index1 > index2 ifTrue:[index2 _ index1].	^index2! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInX: index	"Check if the given bezier curve is monoton in X. If not, subdivide it"	| denom num startX viaX endX dx1 dx2 |	self inline: false.	startX _ self bzStartX: index.	viaX _ self bzViaX: index.	endX _ self bzEndX: index.	dx1 _ viaX - startX.	dx2 _ endX - viaX.	(dx1 * dx2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dx2 - dx1.	num _ dx1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInY: index	"Check if the given bezier curve is monoton in Y. If not, subdivide it"	| startY viaY endY dy1 dy2 denom num |	self inline: false.	startY _ self bzStartY: index.	viaY _ self bzViaY: index.	endY _ self bzEndY: index.	dy1 _ viaY - startY.	dy2 _ endY - viaY.	(dy1 * dy2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dy2 - dy1.	num _ dy1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:07'!stepToFirstBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstBezierIn: bezier at: yValue	"Initialize the bezier at yValue.	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure."	| updateData deltaY maxSteps scaledStepSize squaredStepSize 	startX startY viaX viaY endX endY 	fwX1 fwX2 fwY1 fwY2 	fwDx fwDDx fwDy fwDDy |	self inline: false. "Too many temps for useful inlining"	self var: #updateData declareC:'int *updateData'.	"Do a quick check if there is anything at all to do"	((self isWide: bezier) not and:[yValue >= (self bezierEndYOf: bezier)])		ifTrue:[^self edgeNumLinesOf: bezier put: 0].	"Now really initialize bezier"	startX _ self edgeXValueOf: bezier.	startY _ self edgeYValueOf: bezier.	viaX _ self bezierViaXOf: bezier.	viaY _ self bezierViaYOf: bezier.	endX _ self bezierEndXOf: bezier.	endY _ self bezierEndYOf: bezier.	deltaY _ endY - startY.	"Initialize integer forward differencing"	fwX1 _ (viaX - startX) * 2.	fwX2 _ startX + endX - (viaX * 2).	fwY1 _ (viaY - startY) * 2.	fwY2 _ startY + endY - (viaY * 2).	maxSteps _ deltaY * 2.	maxSteps < 2 ifTrue:[maxSteps _ 2].	scaledStepSize _ 16r1000000 // maxSteps.	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	fwDx _ fwX1 * scaledStepSize.	fwDDx _ fwX2 * squaredStepSize * 2.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwY1 * scaledStepSize.	fwDDy _ fwY2 * squaredStepSize * 2.	fwDy _ fwDy + (fwDDy // 2).	"Store the values"	self edgeNumLinesOf: bezier put: deltaY.	updateData _ self bezierUpdateDataOf: bezier.	updateData at: GBUpdateX put: (startX * 256).	updateData at: GBUpdateY put: (startY * 256).	updateData at: GBUpdateDX put: fwDx.	updateData at: GBUpdateDY put: fwDy.	updateData at: GBUpdateDDX put: fwDDx.	updateData at: GBUpdateDDY put: fwDDy.	"And step to the first scan line"	(startY _ self edgeYValueOf: bezier) = yValue ifFalse:[		self stepToNextBezierIn: bezier at: yValue.		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:08'!stepToNextBezier	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 01:49'!stepToNextBezierForward: updateData at: yValue	"Incrementally step to the next scan line in the given bezier update data.	Note: This method has been written so that inlining works, e.g.,		not declaring updateData as 'int*' but casting it on every use."	| minY lastX lastY fwDx fwDy |	self inline: true.	lastX _ (self cCoerce: updateData to: 'int*') at: GBUpdateX.	lastY _ (self cCoerce: updateData to: 'int*') at: GBUpdateY.	fwDx _ (self cCoerce: updateData to: 'int*') at: GBUpdateDX.	fwDy _ (self cCoerce: updateData to: 'int*') at: GBUpdateDY.	minY _ yValue * 256.	"Step as long as we haven't yet reached minY and also	as long as fwDy is greater than zero thus stepping down.	Note: The test for fwDy should not be necessary in theory		but is a good insurance in practice."	[minY > lastY and:[fwDy >= 0]] whileTrue:[		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDX).		fwDy _ fwDy + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDY).	].	(self cCoerce: updateData to: 'int*') at: GBUpdateX put: lastX.	(self cCoerce: updateData to: 'int*') at: GBUpdateY put: lastY.	(self cCoerce: updateData to: 'int*') at: GBUpdateDX put: fwDx.	(self cCoerce: updateData to: 'int*') at: GBUpdateDY put: fwDy.	^lastX // 256! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given bezier"	|  xValue |	self inline: true.	xValue _ self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	self edgeXValueOf: bezier put: xValue.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx < 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) - (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX + (lineWidth - lineOffset * 256).	"Set lineWidth pixels down"	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx >= 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) + (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	"Set lineWidth-lineOffset pixels left"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX - (lineWidth - lineOffset * 256).	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	"Set lineWidth pixels down"	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset + lineWidth.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 03:44'!computeFinalWideBezierValues: bezier width: lineWidth	"Get both values from the two boundaries of the given bezier 	and compute the actual position/width of the line"	| leftX rightX temp |	leftX _ ((self bezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	rightX _ ((self wideBezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	leftX > rightX ifTrue:[temp _ leftX. leftX _ rightX. rightX _ temp].	self edgeXValueOf: bezier put: leftX.	(rightX - leftX) > lineWidth ifTrue:[		self wideBezierWidthOf: bezier put: (rightX - leftX).	] ifFalse:[		self wideBezierWidthOf: bezier put: lineWidth.	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierFill	^(dispatchReturnValue _ self wideBezierFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierWidth	^(dispatchReturnValue _ self wideBezierWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:00'!stepToFirstWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideBezierIn: bezier at: yValue	"Initialize the bezier at yValue"		| lineWidth startY nLines yEntry yExit lineOffset endX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the bezier"	endX _ self bezierEndXOf: bezier.	startY _ self edgeYValueOf: bezier.	self stepToFirstBezierIn: bezier at: startY.	nLines _ (self edgeNumLinesOf: bezier).	"Copy the incremental update data"	0 to: 5 do:[:i|		(self wideBezierUpdateDataOf: bezier) at: i put:			((self bezierUpdateDataOf: bezier) at: i).	].	"Compute primary x direction of curve (e.g., 1: left to right; -1: right to left)."	xDir _ ((self bezierUpdateDataOf: bezier) at: GBUpdateDX).	xDir = 0 ifTrue:[((self bezierUpdateDataOf: bezier) at: GBUpdateDDX)].	xDir >= 0 ifTrue:[xDir _ 1] ifFalse:[xDir _ -1].	"Adjust the curve to start/end at the right position"	xDir < 0		ifTrue:[self adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX]		ifFalse:[self adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX].	"Adjust the last value for horizontal lines"	nLines = 0 ifTrue:[(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 						(self bezierFinalXOf: bezier) * 256].	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: bezier put: nLines + lineWidth.	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: bezier]		ifFalse:[self edgeFillsInvalidate: bezier].	self computeFinalWideBezierValues: bezier width: lineWidth.	"And step to the first scan line"	startY = yValue ifFalse:[		"Note: Must single step here so that entry/exit works"		startY to: yValue-1 do:[:i| self stepToNextWideBezierIn: bezier at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: (self edgeNumLinesOf: bezier) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:34'!stepToNextWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	self stepToNextWideBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given wide bezier"	|  yEntry yExit lineWidth lineOffset |	self inline: false.	"Don't inline this"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry _ (self wideBezierEntryOf: bezier) + 1.	yExit _ (self wideBezierExitOf: bezier) + 1.	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: bezier].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: bezier].	"Check if we have to step the upper curve"	(yExit + lineOffset < 0) ifTrue:[		self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	] ifFalse:[		"Adjust the last x value to the final x recorded previously"		(self bezierUpdateDataOf: bezier) at: GBUpdateX put: (self bezierFinalXOf: bezier) * 256.	].	"Step the lower curve"	self stepToNextBezierForward: (self wideBezierUpdateDataOf: bezier) at: yValue.	self computeFinalWideBezierValues: bezier width: lineWidth.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedFillIndexList: fillList max: maxIndex segments: nSegs	"Check the fill indexes in the run-length encoded fillList"	| length runLength runValue nFills fillPtr |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	length _ interpreterProxy slotSizeOf: fillList.	fillPtr _ interpreterProxy firstIndexableField: fillList.	nFills _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: fillPtr.		runValue _ self shortRunValueAt: 0 from: fillPtr.		(runValue >= 0 and:[runValue <= maxIndex]) ifFalse:[^false].		nFills _ nFills + runLength.	].	^nFills = nSegs! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 15:19'!checkCompressedFills: indexList	"Check if the indexList (containing fill handles) is okay."	| fillPtr length fillIndex |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	"First check if the oops have the right format"	(interpreterProxy isWords: indexList) ifFalse:[^false].	"Then check the fill entries"	length _ interpreterProxy slotSizeOf: indexList.	fillPtr _ interpreterProxy firstIndexableField: indexList.	1 to: length do:[:i|		fillIndex _ fillPtr at: 0.		"Make sure the fill is okay"		(fillIndex = 0 or:[(self isFillColor: fillIndex) or:[			((self isObject: fillIndex) and:[self isFill: fillIndex])]]) 				ifFalse:[^false].		fillPtr _ fillPtr + 1].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedLineWidths: lineWidthList segments: nSegments	"Check the run-length encoded lineWidthList matches nSegments"	| length runLength nItems ptr |	self inline: false.	self var: #ptr declareC:'int *ptr'.	length _ interpreterProxy slotSizeOf: lineWidthList.	ptr _ interpreterProxy firstIndexableField: lineWidthList.	nItems _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: ptr.		nItems _ nItems + runLength.	].	^nItems = nSegments! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 15:19'!checkCompressedPoints: points segments: nSegments	"Check if the given point array can be handled by the engine."	| pSize |	self inline: false.	(interpreterProxy isWords: points) ifFalse:[^false].	pSize _ interpreterProxy slotSizeOf: points.	"The points must be either in PointArray format or ShortPointArray format.	Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either		pSize = nSegments * 3,		for ShortPointArrays or,		pSize = nSegments * 6,		for PointArrays"	(pSize = (nSegments * 3) or:[pSize = (nSegments * 6)]) 		ifFalse:[^false]. "Can't handle this"	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/12/1998 21:22'!checkCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	"Check if the given shape can be handled by the engine. 	Since there are a number of requirements this is an extra method."	| maxFillIndex |	self inline: false.	(self checkCompressedPoints: points segments: nSegments) 		ifFalse:[^false].	(self checkCompressedFills: fillIndexList)		ifFalse:[^false].	maxFillIndex _ interpreterProxy slotSizeOf: fillIndexList.	(self checkCompressedFillIndexList: leftFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: rightFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: lineFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedLineWidths: lineWidths segments: nSegments)		ifFalse:[^false].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 19:39'!loadCompressedSegment: segmentIndex from: points short: pointsShort leftFill: leftFill rightFill: rightFill lineWidth: lineWidth lineColor: lineFill haveMatrix: haveMatrix	"Load the compressed segment identified by segment index"	| x0 y0 x1 y1 x2 y2 index segs |	self inline: true.	"Check if have anything to do at all"	(leftFill = rightFill and:[lineWidth = 0 or:[lineFill = 0]]) 		ifTrue:[^nil]. "Nothing to do"	index _ segmentIndex * 6. "3 points with x/y each"	pointsShort ifTrue:["Load short points"		x0 _ self loadPointShortAt: (index+0) from: points.		y0 _ self loadPointShortAt: (index+1) from: points.		x1 _ self loadPointShortAt: (index+2) from: points.		y1 _ self loadPointShortAt: (index+3) from: points.		x2 _ self loadPointShortAt: (index+4) from: points.		y2 _ self loadPointShortAt: (index+5) from: points.	] ifFalse:[		x0 _ self loadPointIntAt: (index+0) from: points.		y0 _ self loadPointIntAt: (index+1) from: points.		x1 _ self loadPointIntAt: (index+2) from: points.		y1 _ self loadPointIntAt: (index+3) from: points.		x2 _ self loadPointIntAt: (index+4) from: points.		y2 _ self loadPointIntAt: (index+5) from: points.	].	"Briefly check if can represent the bezier as a line"	((x0 = x1 and:[y0 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[		"We can use a line from x0/y0 to x2/y2"		(x0 = x2 and:[y0 = y2]) ifTrue:[^nil]. "Nothing to do"		"Load and transform points"		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x2.		self point2Get at: 1 put: y2.		self transformPoints: 2 haveMatrix: haveMatrix.		^self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: leftFill 			rightFill: rightFill.	].	"Need bezier curve"	"Load and transform points"	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	self transformPoints: 3 haveMatrix: haveMatrix.	segs _ self loadAndSubdivideBezierFrom: self point1Get 				via: self point2Get 				to: self point3Get 				isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).	engineStopped ifTrue:[^nil].	self loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: segs.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 03:48'!loadCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList haveMatrix: haveMatrix pointShort: pointsShort	"Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!!!!!	"	| leftRun rightRun widthRun lineFillRun	leftLength rightLength widthLength lineFillLength	leftValue rightValue widthValue lineFillValue |	self inline: false. "Don't you!!!!!!!!"	self var: #points declareC:'int *points'.	self var: #leftFills declareC:'int *leftFills'.	self var: #rightFills declareC:'int *rightFills'.	self var: #lineWidths declareC:'int *lineWidths'.	self var: #lineFills declareC:'int *lineFills'.	self var: #fillIndexList declareC:'int *fillIndexList'.	nSegments = 0 ifTrue:[^0].	"Initialize run length encodings"	leftRun _  rightRun _ widthRun _ lineFillRun _ -1.	leftLength _ rightLength _ widthLength _ lineFillLength _ 1.	leftValue _ rightValue _ widthValue _ lineFillValue _ 0.	1 to: nSegments do:[:i|		"Decrement current run length and load new stuff"		(leftLength _ leftLength - 1) <= 0 ifTrue:[			leftRun _ leftRun + 1.			leftLength _ self shortRunLengthAt: leftRun from: leftFills.			leftValue _ self shortRunValueAt: leftRun from: leftFills.			leftValue = 0 ifFalse:[leftValue _ fillIndexList at: leftValue-1]].		(rightLength _ rightLength - 1) <= 0 ifTrue:[			rightRun _ rightRun + 1.			rightLength _ self shortRunLengthAt: rightRun from: rightFills.			rightValue _ self shortRunValueAt: rightRun from: rightFills.			rightValue = 0 ifFalse:[rightValue _ fillIndexList at: rightValue-1]].		(widthLength _ widthLength - 1) <= 0 ifTrue:[			widthRun _ widthRun + 1.			widthLength _ self shortRunLengthAt: widthRun from: lineWidths.			widthValue _ self shortRunValueAt: widthRun from: lineWidths.			widthValue = 0 ifFalse:[				widthValue _ self transformWidth: widthValue haveMatrix: haveMatrix.				"Always require at least one pixel width"				widthValue = 0 ifTrue:[widthValue _ 1]]].		(lineFillLength _ lineFillLength - 1) <= 0 ifTrue:[			lineFillRun _ lineFillRun + 1.			lineFillLength _ self shortRunLengthAt: lineFillRun from: lineFills.			lineFillValue _ self shortRunValueAt: lineFillRun from: lineFills.			lineFillValue = 0 ifFalse:[lineFillValue _ fillIndexList at: lineFillValue-1]].		self loadCompressedSegment: i - 1			from: points 			short: pointsShort 			leftFill: leftValue 			rightFill: rightValue 			lineWidth: widthValue 			lineColor: lineFillValue			haveMatrix: haveMatrix.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/10/1998 18:34'!loadArrayPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill haveMatrix: haveMatrix	| firstX firstY x0 y0 x1 y1 |	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: points).	interpreterProxy failed ifTrue:[^nil].	firstX _ x0 _ self point1Get at: 0.	firstY _ y0 _ self point1Get at: 1.	1 to: nPoints-1 do:[:i|		self loadPoint: self point1Get from: (interpreterProxy fetchPointer: i ofObject: points).		interpreterProxy failed ifTrue:[^nil].		x1 _ self point1Get at: 0.		y1 _ self point1Get at: 1.		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].	(x1 = firstX and:[y1 = firstY]) ifFalse:[		self point1Get at: 0 put: x1.		self point1Get at: 1 put: y1.		self point2Get at: 0 put: firstX.		self point2Get at: 1 put: firstY.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/14/1998 20:44'!loadArrayShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  haveMatrix: haveMatrix	| pointOop x0 y0 x1 y1 x2 y2 segs |	self inline: false.	0 to: nSegments-1 do:[:i|		pointOop _ interpreterProxy fetchPointer: (i * 3) ofObject: points.		self loadPoint: self point1Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 1) ofObject: points.		self loadPoint: self point2Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 2) ofObject: points.		self loadPoint: self point3Get from: pointOop.		interpreterProxy failed ifTrue:[^nil].		self transformPoints: 3 haveMatrix: haveMatrix.		x0 _ self point1Get at: 0.		y0 _ self point1Get at: 1.		x1 _ self point2Get at: 0.		y1 _ self point2Get at: 1.		x2 _ self point3Get at: 0.		y2 _ self point3Get at: 1.		"Check if we can use a line"		((x0 = y0 and:[x1 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[			self loadWideLine: lineWidth				from: self point1Get				to: self point3Get				lineFill: lineFill				leftFill: fillIndex				rightFill: 0.		] ifFalse:["Need bezier"			segs _ self loadAndSubdivideBezierFrom: self point1Get					via: self point2Get					to: self point3Get					isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).			engineStopped ifTrue:[^nil].			self loadWideBezier: lineWidth				lineFill: lineFill				leftFill: fillIndex				rightFill: 0				n: segs.		].		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/10/1998 19:27'!loadPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill pointsShort: isShort haveMatrix: haveMatrix	| firstX firstY x0 y0 x1 y1 |	self var:#points declareC:'int *points'.	isShort ifTrue:[		firstX _ x0 _ self loadPointShortAt: 0 from: points.		firstY _ y0 _ self loadPointShortAt: 1 from: points.	] ifFalse:[		firstX _ x0 _ self loadPointIntAt: 0 from: points.		firstY _ y0 _ self loadPointIntAt: 1 from: points.	].	1 to: nPoints-1 do:[:i|		isShort ifTrue:[			x1 _ self loadPointShortAt: i*2 from: points.			y1 _ self loadPointShortAt: i*2+1 from: points.		] ifFalse:[			x1 _ self loadPointIntAt: i*2 from: points.			y1 _ self loadPointIntAt: i*2+1 from: points.		].		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].	(x1 = firstX and:[y1 = firstY]) ifFalse:[		self point1Get at: 0 put: x1.		self point1Get at: 1 put: y1.		self point2Get at: 0 put: firstX.		self point2Get at: 1 put: firstY.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/14/1998 20:45'!loadShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  pointsShort: pointsShort haveMatrix: haveMatrix	self inline: false.	self var:#points declareC:'int *points'.	1 to: nSegments do:[:i|		self loadCompressedSegment: i-1			from: points			short: pointsShort			leftFill: fillIndex			rightFill: 0			lineWidth: lineWidth			lineColor: lineFill			haveMatrix: haveMatrix.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillLinearGradient	self inline: true.	^self fillLinearGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 17:15'!fillLinearGradient: fill from: leftX to: rightX at: yValue	"Draw a linear gradient fill."	| x0 x1 ramp rampSize dsX ds x rampIndex |	self inline: false.	self var: #ramp declareC:'int *ramp'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	dsX _ self gradientDirectionXOf: fill.	ds _ ((leftX - (self gradientOriginXOf: fill)) * dsX) + 			((yValue - (self gradientOriginYOf: fill)) * (self gradientDirectionYOf: fill)).	x _ x0 _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	[((rampIndex _ ds // 16r10000) < 0 or:[rampIndex > rampSize]) and:[x < x1]] 		whileTrue:[	x _ x + 1.					ds _ ds + dsX].	x > x0 ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: 0)) from: x0 to: x].	"Part two: Fill everything inside the boundaries"	self aaLevelGet = 1 ifTrue:[		"Fast version w/o anti-aliasing"		[((rampIndex _ ds // 16r10000) < rampSize and:[rampIndex >= 0]) and:[x < x1]] whileTrue:[			spanBuffer at: x put: (self makeUnsignedFrom: (ramp at: rampIndex)).			x _ x + 1.			ds _ ds + dsX.		].	] ifFalse:[x _ self fillLinearGradientAA: fill ramp: ramp ds: ds dsX: dsX from: x to: rightX].	"Part three fill everything outside right boundary"	x < x1 ifTrue:[		rampIndex < 0 ifTrue:[rampIndex _ 0].		rampIndex >= rampSize ifTrue:[rampIndex _ rampSize-1].		self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampIndex)) from: x to: x1].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 17:18'!fillLinearGradientAA: fill ramp: ramp ds: deltaS dsX: dsX from: leftX to: rightX	"This is the AA version of linear gradient filling."	| colorMask colorShift baseShift rampIndex ds rampSize x idx rampValue 	 aaLevel firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampSize _ self gradientRampLengthOf: fill.	ds _ deltaS.	x _ leftX.	rampIndex _ ds // 16r10000.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < firstPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < firstPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	"Deal with the full pixels"	colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.	colorShift _ self aaShiftGet.	[x < lastPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < lastPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + aaLevel.			ds _ ds + (dsX << colorShift)].		rampIndex _ ds // 16r10000.	].	"Deal with the last n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < rightX and:[rampIndex < rampSize and:[rampIndex>=0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < rightX and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 22:51'!fillRadialDecreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ rightX.	x1 > (self gradientOriginXOf: fill) ifTrue:[x1 _ self gradientOriginXOf: fill].	[x < x1] whileTrue:[		"Try to copy the current value more than just once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		"Step to next ramp value"		nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[nextLength < length2] whileTrue:[			rampIndex _ rampIndex - 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			length2 _ (rampIndex-1) * (rampIndex-1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 16:09'!fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength x1	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ self gradientOriginXOf: fill.	x1 > rightX ifTrue:[x1 _ rightX].	firstPixel _ self aaFirstPixelFrom: leftX to: x1.	lastPixel _ self aaLastPixelFrom: leftX to: x1.	"Deal with the first n sub-pixels"	(x < firstPixel) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the full pixels"	(x < lastPixel) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the last n sub-pixels"	(x < x1) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < x1] whileTrue:[			"Try to copy the current value more than just once"			[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillRadialGradient	self inline: true.	^self fillRadialGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 18:57'!fillRadialGradient: fill from: leftX to: rightX at: yValue	"Draw a radial gradient fill."	| x x1 ramp rampSize dsX ds dtX dt length2 deltaX deltaY deltaST |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:'int *deltaST'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	deltaX _ leftX - (self gradientOriginXOf: fill).	deltaY _ yValue - (self gradientOriginYOf: fill).	dsX _ self gradientDirectionXOf: fill.	dtX _ self gradientNormalXOf: fill.	ds _ (deltaX * dsX) + (deltaY * (self gradientDirectionYOf: fill)).	dt _ (deltaX * dtX) + (deltaY * (self gradientNormalYOf: fill)).	x _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	[(self squaredLengthOf: ds // 16r10000 with: dt // 16r10000) >= length2 and:[x < x1]]		whileTrue:[	x _ x + 1.	ds _ ds + dsX.	dt _ dt + dtX].	x > leftX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: leftX to: x].	"Part two: Fill everything inside the boundaries"	deltaST _ self point1Get.	deltaST at: 0 put: ds.	deltaST at: 1 put: dt.	(x < (self gradientOriginXOf: fill)) ifTrue:[		"Draw the decreasing part"		self aaLevelGet = 1 			ifTrue:[x _ self fillRadialDecreasing: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1].	].	x < x1 ifTrue:[		"Draw the increasing part"		self aaLevelGet = 1			ifTrue:[x _ self fillRadialIncreasing: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1].	].	"Part three fill everything outside right boundary"	x < rightX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: x to: rightX].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 01:21'!fillRadialIncreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength rampSize lastLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	x1 _ rightX.	[x < x1 and:[lastLength < length2]] whileTrue:[		"Try to copy the current value more than once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[lastLength > nextLength] whileTrue:[			rampIndex _ rampIndex + 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			nextLength _ (rampIndex+1) * (rampIndex+1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 16:09'!fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength rampSize lastLength 	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n subPixels"	(x < firstPixel and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with the full pixels"	(x < lastPixel and:[lastLength < length2]) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with last n sub-pixels"	(x < rightX and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < rightX and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < rightX and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 19:03'!loadGradientFill: rampOop from: point1 along: point2 normal: point3 isRadial: isRadial haveMatrix: haveMatrix	"Load the gradient fill as defined by the color ramp."	| rampWidth fill dirX dirY nrmX nrmY dsLength2 dsX dsY dtLength2 dtX dtY |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	(interpreterProxy fetchClassOf: rampOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	rampWidth _ interpreterProxy slotSizeOf: rampOop.	fill _ self allocateGradientFill: (interpreterProxy firstIndexableField: rampOop)				rampWidth: rampWidth isRadial: isRadial.	engineStopped ifTrue:[^nil].	"Transform the points"	point2 at: 0 put: (point2 at: 0) + (point1 at: 0).	point2 at: 1 put: (point2 at: 1) + (point1 at: 1).	point3 at: 0 put: (point3 at: 0) + (point1 at: 0).	point3 at: 1 put: (point3 at: 1) + (point1 at: 1).	self transformPoint: point1 haveMatrix: haveMatrix.	self transformPoint: point2 haveMatrix: haveMatrix.	self transformPoint: point3 haveMatrix: haveMatrix.	dirX _ (point2 at: 0) - (point1 at: 0).	dirY _ (point2 at: 1) - (point1 at: 1).	nrmX _ (point3 at: 0) - (point1 at: 0).	nrmY _ (point3 at: 1) - (point1 at: 1).	"Compute the scale from direction/normal into ramp size"	dsLength2 _ (dirX * dirX) + (dirY * dirY).	dsLength2 > 0 ifTrue:[		dsX _ (dirX asFloat * rampWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		dsY _ (dirY asFloat * rampWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		"(isRadial not and:[dsX < 0]) ifTrue:[			dsX _ 0 - dsX.			self swapRampEntries: fill]."	] ifFalse:[ dsX _ 0. dsY _ 0].	dtLength2 _ (nrmX * nrmX) + (nrmY * nrmY).	dtLength2 > 0 ifTrue:[		dtX _ (nrmX asFloat * rampWidth asFloat * 65536.0 / dtLength2 asFloat) asInteger.		dtY _ (nrmY asFloat * rampWidth asFloat * 65536.0 / dtLength2 asFloat) asInteger.	] ifFalse:[dtX _ 0. dtY _ 0].	self gradientOriginXOf: fill put: (point1 at: 0).	self gradientOriginYOf: fill put: (point1 at: 1).	self gradientDirectionXOf: fill put: dsX.	self gradientDirectionYOf: fill put: dsY.	self gradientNormalXOf: fill put: dtX.	self gradientNormalYOf: fill put: dtY.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 10/30/1998 21:49'!allocateBezier	| bezier |	(self allocateObjEntry: GBBaseSize) ifFalse:[^0].	bezier _ self objUsedGet.	self objUsedPut: self objUsedGet + GBBaseSize.	self objectTypeOf: bezier put: GEPrimitiveBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBBaseSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 10/30/1998 20:52'!allocateBezierStackEntry	self wbStackPush: 6.	^self wbStackSize! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/8/1998 14:55'!allocateGradientFill: ramp rampWidth: rampWidth isRadial: isRadial	| fill fillSize rampPtr |	self var:#ramp declareC:'int *ramp'.	self var:#rampPtr declareC:'int *rampPtr'.	fillSize _ GGBaseSize + rampWidth.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ self objUsedGet.	self objUsedPut: self objUsedGet + fillSize.	isRadial		ifTrue:[self objectTypeOf: fill put: GEPrimitiveRadialGradientFill]		ifFalse:[self objectTypeOf: fill put: GEPrimitiveLinearGradientFill].	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	rampPtr _ self gradientRampOf: fill.	0 to: rampWidth-1 do:[:i| rampPtr at: i put: (ramp at: i)].	self gradientRampLengthOf: fill put: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/1/1998 02:41'!allocateLine	| line |	(self allocateObjEntry: GLBaseSize) ifFalse:[^0].	line _ self objUsedGet.	self objUsedPut: self objUsedGet + GLBaseSize.	self objectTypeOf: line put: GEPrimitiveLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLBaseSize.	^line! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/6/1998 01:23'!allocateWideBezier	| bezier |	(self allocateObjEntry: GBWideSize) ifFalse:[^0].	bezier _ self objUsedGet.	self objUsedPut: self objUsedGet + GBWideSize.	self objectTypeOf: bezier put: GEPrimitiveWideBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBWideSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/4/1998 22:15'!allocateWideLine	| line |	(self allocateObjEntry: GLWideSize) ifFalse:[^0].	line _ self objUsedGet.	self objUsedPut: self objUsedGet + GLWideSize.	self objectTypeOf: line put: GEPrimitiveWideLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLWideSize.	^line! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddBezierToGET: bezier	"Add the bezier to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: bezier) 		ifTrue:[lineWidth _ (self wideBezierExtentOf: bezier)]		ifFalse:[lineWidth _ 0].	(self bezierEndYOf: bezier) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: bezier) - lineWidth >= self fillMaxXGet and:[		(self bezierEndXOf: bezier) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: bezier.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddEdgeToGET: edge	"Add the edge to the global edge table.	For known edge types, check if the edge intersects the visible region"	self inline: true.	(self isLine: edge) ifTrue:[^self checkedAddLineToGET: edge].	(self isBezier: edge) ifTrue:[^self checkedAddBezierToGET: edge].	self addEdgeToGET: edge.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddLineToGET: line	"Add the line to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: line) 		ifTrue:[lineWidth _ (self wideLineExtentOf: line)]		ifFalse:[lineWidth _ 0].	(self lineEndYOf: line) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: line) - lineWidth >= self fillMaxXGet and:[		(self lineEndXOf: line) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: line.! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 10/30/1998 20:02'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| word1 word2 |	self inline: true.	word1 _ value bitAnd: 16rFFFF.	word2 _ (value bitShift: -16) bitAnd: 255.	^(( (self cCoerce: (word1 * word1) to:'unsigned') bitShift: -16) +		((word1 * word2) * 2) +			((word2 * word2) bitShift: 16)) bitShift: -8! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleCosTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,		1.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleSinTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		 0.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:24'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(self cCoerce: intArray to: 'int *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:23'!loadPointShortAt: index from: shortArray	"Load the short value from the given index in shortArray"	self returnTypeC:'short'.	^(self cCoerce: shortArray to: 'short *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 03:16'!makeRectFromPoints	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/6/1998 17:55'!offsetFromWidth: lineWidth	"Common function so that we don't compute that wrong in any place	and can easily find all the places where we deal with one-pixel offsets."	self inline: true.	^lineWidth // 2! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:55'!shortRunLengthAt: i from: runArray	"Return the run-length value from the given ShortRunArray."	^((self cCoerce: runArray to:'int *') at: i) bitShift: - 16! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:54'!shortRunValueAt: i from: runArray	"Return the run-length value from the given ShortRunArray.	Note: We don't need any coercion to short/int here, since	we deal basically only with unsigned values."	^(((self cCoerce: runArray to:'int *') at: i) bitAnd: 16rFFFF)! !!BalloonEnginePlugin class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:01'!declareCVarsIn: cg	"Nothing to declare"! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 20:46'!assert: bool	bool ifFalse:[^self error:'Assertion failed'].! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleCosTable	^CArrayAccessor on:#(1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 0.1950903220161282 0.38268343236509 0.555570233019602 0.707106781186547 0.831469612302545 0.9238795325112865 0.98078528040323 1.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleSinTable	^CArrayAccessor on:#(0.0 0.1950903220161282 0.3826834323650897 0.555570233019602 0.707106781186547 0.831469612302545 0.923879532511287 0.98078528040323 1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 13:32'!copyBitsFrom: x0 to: x1 at: y	bbObj copyBitsFrom: x0 to: x1 at: y.! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 18:44'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	self perform: (selectorArray at: (anInteger + 1)).! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 19:19'!ioMicroMSecs	^Time millisecondClockValue! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!loadBitBltFrom: oop	bbObj _ oop.	^true! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:05'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:04'!loadPointShortAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!makeUnsignedFrom: integer	integer < 0 		ifTrue:[^(0 - integer - 1) bitInvert32]		ifFalse:[^integer]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:54'!shortRunLengthAt: i from: runArray	^runArray getObject lengthAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:55'!shortRunValueAt: i from: runArray	^runArray getObject valueAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/31/1998 23:07'!showDisplayBits	"Do nothing."! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 19:51'!smallSqrtTable	"Return a lookup table for rounded integer square root values from 0 to 31"	^CArrayAccessor on:#(0 1 1 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6 )! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawBezier: line	| canvas p1 p2 p3 |	self assert:(self isBezier: line).	p1 _ (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet.	p2 _ (self bezierViaXOf: line) @ (self bezierViaYOf: line) // self aaLevelGet.	p3 _ (self bezierEndXOf: line) @ (self bezierEndYOf: line) // self aaLevelGet.	canvas _ FormCanvas on: Display.	canvas		line: p1 to: p2 width: 2 color: Color blue;		line: p2 to: p3 width: 2 color: Color blue.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:16'!debugDrawEdge: edge	self assert: (self isEdge: edge).	(self isLine: edge) ifTrue:[^self debugDrawLine: edge].	(self isBezier: edge) ifTrue:[^self debugDrawBezier: edge].	self halt.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 13:26'!debugDrawHLine: yValue	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: 0 @ (yValue // self aaLevelGet)		to: Display extent x @ (yValue // self aaLevelGet)		width: 2		color: Color green.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawLine: line	| canvas |	self assert: (self isLine: line).	canvas _ FormCanvas on: Display.	canvas		line: (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet		to: (self lineEndXOf: line) @ (self lineEndYOf: line) // self aaLevelGet		width: 2		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 00:17'!debugDrawLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: (pt1 at: 0) @ (pt1 at: 1) // self aaLevelGet		to: (pt2 at: 0) @ (pt2 at: 1) // self aaLevelGet		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:31'!debugDrawPt: pt	| canvas |	canvas _ FormCanvas on: Display.	canvas		fillRectangle:((pt-2) corner: pt+2) color: Color red! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:24'!debugDrawPtLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: pt1		to: pt2		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/6/1998 02:26'!debugPrintObjects	| object end |	self inline: false.	object _ 0.	end _ self objUsedGet.	[object < end] whileTrue:[		Transcript cr; 			nextPut:$#; print: object; space;			print: (self objectHeaderOf: object); space.		(self isEdge: object) 			ifTrue:[Transcript nextPutAll:'(edge) '].		(self isFill:object)			ifTrue:[Transcript nextPutAll:'(fill) '].		Transcript print: (self objectLengthOf: object); space.		Transcript endEntry.		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 17:21'!debugPrintPoints: n	Transcript cr.	n > 0 ifTrue:[		Transcript print: (self point1Get at: 0) @ (self point1Get at: 1); space.	].	n > 1 ifTrue:[		Transcript print: (self point2Get at: 0) @ (self point2Get at: 1); space.	].	n > 2 ifTrue:[		Transcript print: (self point3Get at: 0) @ (self point3Get at: 1); space.	].	n > 3 ifTrue:[		Transcript print: (self point4Get at: 0) @ (self point4Get at: 1); space.	].	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:15'!printAET	| edge |	Transcript cr; show:'************* ActiveEdgeTable **************'.	0 to: self aetUsedGet - 1 do:[:i|		edge _ aetBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:14'!printGET	| edge |	Transcript cr; show:'************* GlobalEdgeTable **************'.	0 to: self getUsedGet - 1 do:[:i|		edge _ getBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 21:57'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:18'!quickPrintBezier: bezier	Transcript cr.	Transcript nextPut:$(;		print: (self edgeXValueOf: bezier)@(self edgeYValueOf: bezier);		space;		print: (self bezierViaXOf: bezier)@(self bezierViaYOf: bezier);		space;		print: (self bezierEndXOf: bezier)@(self bezierEndYOf: bezier);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:00'!quickPrintBezier: index first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: (self bzStartX: index)@(self bzStartY: index);		space;		print: (self bzViaX: index)@(self bzViaY: index);		space;		print: (self bzEndX: index)@(self bzEndY: index);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'initialize' stamp: 'ar 11/8/1998 01:42'!initialize	edgeTransform _ CArrayAccessor on: (FloatArray new: 6).! !!BalloonEngineSimulation class methodsFor: 'instance creation' stamp: 'ar 10/29/1998 19:18'!new	^super new initialize! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm	^destForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm: aForm	destForm _ aForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index	^index! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index: anInteger	index _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX	^maxX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX: anInteger	maxX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX	^minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX: anInteger	minX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source	^source! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source: anObject	source _ anObject! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/28/1998 16:35'!width	^maxX - minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue	^yValue! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue: anInteger	yValue _ anInteger! !!BalloonFillData methodsFor: 'computing' stamp: 'ar 11/14/1998 19:32'!computeFill	(destForm isNil or:[destForm width < self width]) ifTrue:[		destForm _ Form extent: (self width + 10) @ 1 depth: 32.	].	source computeFillFrom: minX to: maxX at: yValue in: destForm! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end	^end! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end: aPoint	end _ aPoint! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialZ	^0 "Assume no depth given"! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start	^start! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start: aPoint	start _ aPoint! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:52'!computeInitialStateFrom: source with: aTransformation	"Compute the initial state in the receiver."	start _ (aTransformation localPointToGlobal: source start) asIntegerPoint.	end _ (aTransformation localPointToGlobal: source end) asIntegerPoint.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:22'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	|  startX endX startY endY yDir deltaY deltaX widthX |	(start y) <= (end y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.		yDir _ 1.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.		yDir _ -1.	].	deltaY _ endY - startY.	deltaX _ endX - startX.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[^edgeTableEntry lines: 0].	"Check if edge goes left to right"	deltaX >= 0 ifTrue:[		xDirection _ 1.		widthX _ deltaX.		error _ 0.	] ifFalse:[		xDirection _ -1.		widthX _ 0 - deltaX.		error _ 1 - deltaY.	].	"Check if edge is horizontal"	deltaY = 0 		ifTrue:[	xIncrement _ 0.				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"			deltaY > widthX 				ifTrue:[	xIncrement _ 0.						errorAdjUp _ widthX]				ifFalse:[	xIncrement _ (widthX // deltaY) * xDirection.						errorAdjUp _ widthX \\ deltaY]].	errorAdjDown _ deltaY.	edgeTableEntry xValue: startX.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		startY to: yValue do:[:y| self stepToNextScanLineAt: y in: edgeTableEntry].		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:39'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	| x |	x _ edgeTableEntry xValue + xIncrement.	error _ error + errorAdjUp.	error > 0 ifTrue:[		x _ x + xDirection.		error _ error - errorAdjDown.	].	edgeTableEntry xValue: x.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 23:42'!subdivide	^nil! !!BalloonLineSimulation methodsFor: 'printing' stamp: 'ar 10/27/1998 23:20'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: end;		nextPut:$)! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:07'!computeFillFrom: minX to: maxX at: yValue in: form	| bb |	color isTransparent ifFalse:[		bb _ BitBlt toForm: form.		bb fillColor: color.		bb destX: 0 destY: 0 width: (maxX - minX) height: 1.		bb combinationRule: Form over.		bb copyBits].! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:08'!computeInitialStateFrom: source with: aColorTransform	color _ source asColor.! !!Canvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^false! !!FormCanvas methodsFor: 'other' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^(BalloonCanvas on: form) setOrigin: origin clipRect: clipRect! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:49'!initialize	transformStack _ OrderedCollection new.	aaLevel _ 1.! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:25'!resetEngine	engine _ nil.! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/13/1998 01:02'!aaLevel	^aaLevel! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/14/1998 00:55'!aaLevel: newLevel	"Only allow changes to aaLevel if we're working on 32 bit forms"	form depth >= 8 ifFalse:[^self].	aaLevel _ newLevel.	engine ifNotNil:[engine aaLevel: aaLevel].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:37'!ensuredEngine	^engine ifNil:[		engine _ BalloonEngine new.		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine].! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^true! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/12/1998 01:07'!isVisible: aRectangle	^transform 		ifNil:[super isVisible: aRectangle]		ifNotNil:[super isVisible: (transform localBoundsToGlobal: aRectangle)]! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/11/1998 19:10'!copy	^super copy resetEngine! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/12/1998 00:31'!copyTransform: aTransform	^self copy transformBy: aTransform! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:20'!fillColor: c	"Note: This always fills, even if the color is transparent."	"Note2: To achieve the above we must make sure that c is NOT transparent"	self frameAndFillRectangle: form boundingBox 		fillColor: (c alpha: 1.0)		borderWidth: 0		borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:45'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	^self drawOval: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:49'!fillRectangle: r color: c	^self frameAndFillRectangle: r			fillColor: c			borderWidth: 0			borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:56'!frameAndFillRectangle: r fillColor: c borderWidth: borderWidth borderColor: borderColor	^self drawRectangle: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| bw |	"Fill rectangle and draw top and left border"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now draw bottom right border.	Note: Must inset this manually!!"	bw _ borderWidth // 2.	self drawPolygon: (Array with: r topRight + (bw negated@bw) 							with: r bottomRight - bw asPoint							with: r bottomLeft + (bw@bw negated))		color: nil		borderWidth: borderWidth		borderColor: bottomRightColor.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:42'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r			fillColor: nil			borderWidth: w			borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!line: pt1 to: pt2 width: w color: c	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:39'!point: pt color: c	"Is there any use for this?"	| myPt |	transform 		ifNil:[myPt _ pt]		ifNotNil:[myPt _ transform localPointToGlobal: pt].	^super point: myPt color: c! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawBezierShape: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a boundary shape that is defined by a list of vertices.	Each three subsequent vertices define a quadratic bezier segment.	For lines, the control point should be set to either the start or the end	of the bezier curve."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawBezierShape: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:54'!drawCompressedShape: compressedShape	"Draw a compressed shape"	self ensuredEngine		drawCompressedShape: compressedShape		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawGeneralBezierShape: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general boundary shape (e.g., possibly containing holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralBezierShape: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:49'!drawGeneralPolygon: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general polygon (e.g., a polygon that can contain holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralPolygon: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw the oval defined by the given rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawOval: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:50'!drawPolygon: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawPolygon: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawRectangle: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawRectangle: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:36'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	^super image: aForm at: aPoint sourceRect: sourceRect rule: rule! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/12/1998 13:33'!line: point1 to: point2 brushForm: brush	| pt1 pt2 |	transform 		ifNil:[pt1 _ point1. pt2 _ point2]		ifNotNil:[pt1 _ transform localPointToGlobal: point1.				pt2 _ transform localPointToGlobal: point2].	^super line: pt1 to: pt2 brushForm: brush! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:38'!paragraph: para bounds: bounds color: c	^super paragraph: para bounds: bounds color: c! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:39'!text: s bounds: boundsRect font: fontOrNil color: c	^super text: s bounds: boundsRect font: fontOrNil color: c! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform	aTransform ifNil:[^self].	transform 		ifNil:[transform _ aTransform]		ifNotNil:[transform _ transform composedWithLocal: aTransform]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform while: aBlock	"Incorporate the local transformation in the receiver while evaluating aBlock"	| result |	aTransform ifNil:[^aBlock value: self].	transformStack addLast: transform.	self transformBy: aTransform.	result _ aBlock value: self.	transform _ transformStack removeLast.	^result! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 11/11/1998 20:12'!drawColor: c	(c isNil or:[c isTransparent]) ifTrue:[^nil].	^shadowDrawing		ifTrue:[Color gray]		ifFalse:[c]! !!BalloonCanvas methodsFor: 'converting' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^self! !BalloonBezierSimulation initialize!BalloonEngine initialize!BalloonEngineBase initialize!"Postscript:Initialize the Balloon engine pool constants"BalloonEngineBase initPool.!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:05:28 am'!RectangleMorph subclass: #BalloonRectangleMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Balloon-Demos'!Morph subclass: #MatrixTransformMorph	instanceVariableNames: 'transform '	classVariableNames: 'IdentityTransform '	poolDictionaries: ''	category: 'Morphic-Balloon-Demos'!!MatrixTransformMorph class methodsFor: 'class initialization' stamp: 'ar 11/15/1998 22:09'!initialize	"MatrixTransformMorph initialize"	IdentityTransform _ MatrixTransform2x3 identity.! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/15/1998 22:19' prior: 34674277!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ self newTransformationMorph asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/15/1998 22:19'!newTransformationMorph	^TransformationMorph new! !!BalloonRectangleMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 22:31'!initialize	super initialize.	color _ GradientFillStyle ramp: {0.0 -> Color green. 0.5 -> Color yellow. 1.0 -> Color red}.	color radial: true.	borderColor _ GradientFillStyle ramp: {0.0 -> Color black. 1.0 -> Color white}.	borderWidth _ 10.	self extent: 100@100.! !!BalloonRectangleMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 22:24'!doesBevels	"To return true means that this object can show bevelled borders, and	therefore can accept, eg, #raised or #inset as valid borderColors.	Must be overridden by subclasses that do not support bevelled borders."	^ false! !!BalloonRectangleMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 22:20'!newTransformationMorph	^MatrixTransformMorph new! !!BalloonRectangleMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:40'!drawOn: aCanvas	(color isKindOf: OrientedFillStyle) ifTrue:[		color origin: bounds center.		color direction: (bounds extent x * 0.7) @ 0.		color normal: 0@(bounds extent y * 0.7).	].	(borderColor isKindOf: OrientedFillStyle) ifTrue:[		borderColor origin: bounds topLeft.		borderColor direction: (bounds extent x) @ 0.		borderColor normal: 0@(bounds extent y).	].	aCanvas asBalloonCanvas		drawRectangle: (bounds insetBy: borderWidth // 2)		color: color		borderWidth: borderWidth		borderColor: borderColor.! !!MatrixTransformMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 22:21'!asFlexOf: aMorph	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	self addMorph: aMorph.	self computeBounds! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:50'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: self referencePosition color: Color lightGray on: #mouseStillDown send: #changeRotationCenter:with: to: self! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:50'!balloonHelpTextForHandle: aHandle	aHandle eventHandler firstMouseSelector == #changeRotationCenter:with:		ifTrue:[^'set center of rotation'].	^super balloonHelpTextForHandle: aHandle! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!transform	^transform ifNil:[IdentityTransform]! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!transform: aMatrixTransform	transform _ aMatrixTransform.	self computeBounds.! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:52'!visible	extension == nil ifTrue:[^true].	^extension visible! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!visible: aBool	extension == nil ifTrue:[		aBool ifTrue:[^self].		self assureExtension].	extension visible: aBool.! !!MatrixTransformMorph methodsFor: 'submorphs accessing' stamp: 'ar 11/15/1998 21:52'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self visible ifFalse:[^mList].	p _ self transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	(self containsPoint: aPoint) 		ifTrue:[mList addLast: self].	^ mList! !!MatrixTransformMorph methodsFor: 'submorphs accessing' stamp: 'ar 11/15/1998 21:52'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue:[^mList].	self visible ifFalse:[^mList].	p _ self transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	(self containsPoint: aPoint) 		ifTrue:[mList addLast: self].	^ mList! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:17'!boundsChangedFrom: oldBounds to: newBounds	transform ifNil:[transform _ MatrixTransform2x3 identity].	oldBounds extent = newBounds extent ifFalse:[		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withOffset: oldBounds origin negated).		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withScale: newBounds extent / oldBounds extent).		transform _ transform composedWithGlobal:			(MatrixTransform2x3 withOffset: newBounds origin).	].	transform offset: transform offset + (newBounds origin - oldBounds origin)! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:01'!computeBounds	| subBounds |	(submorphs isNil or:[submorphs isEmpty]) ifTrue:[^self].	bounds _ nil.	submorphs do:[:m|		subBounds _ self transform localBoundsToGlobal: m bounds.		bounds 			ifNil:[bounds _ subBounds]			ifNotNil:[bounds _ bounds quickMerge: subBounds].	].	bounds ifNil:[bounds _ 0@0 corner: 20@20].	fullBounds _ bounds.! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:57'!containsPoint: aPoint	self visible ifFalse:[^false].	^bounds containsPoint: aPoint! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!extent: extent	self handleBoundsChange:[super extent: extent]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!fullBounds	| subBounds |	fullBounds ifNil:[		fullBounds _ self bounds.		submorphs do:[:m|			subBounds _ (self transform localBoundsToGlobal: m fullBounds).			fullBounds _ fullBounds quickMerge: subBounds.		].	].	^fullBounds! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!fullContainsPoint: aPoint	| p |	self visible ifFalse:[^false].	(self fullBounds containsPoint: aPoint) ifFalse:[^false].	(self containsPoint: aPoint) ifTrue:[^true].	p _ self transform globalPointToLocal: aPoint.	submorphs do:[:m|		(m fullContainsPoint: p) ifTrue:[^true].	].	^false! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!handleBoundsChange: aBlock	| oldBounds newBounds |	oldBounds _ bounds.	aBlock value.	newBounds _ bounds.	self boundsChangedFrom: oldBounds to: newBounds.! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:53'!position: pos	self handleBoundsChange:[super position: pos]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 22:14'!privateFullMoveBy: delta	self handleBoundsChange:[super privateMoveBy: delta]! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:59'!canvasForSubmorphs: canvasForMe	^canvasForMe asBalloonCanvas copyTransform: self transform! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:54'!changed	^super invalidRect: (self fullBounds insetBy: -1)! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:20'!drawOn: aCanvas! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:59'!fullDrawOn: aCanvas	self visible ifFalse:[^self].	^super fullDrawOn: aCanvas! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:54'!invalidRect: rect	owner ifNil:[^self].	^owner invalidRect:(self transform localBoundsToGlobal: rect).! !!MatrixTransformMorph methodsFor: 'events' stamp: 'ar 11/15/1998 21:55'!transformFrom: uberMorph	(owner isNil or:[owner == uberMorph]) ifTrue:[^self transform].	^(owner transformFrom: uberMorph) asMatrixTransform2x3 composedWithLocal: self transform! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:55'!addFlexShell	"No flex shell necessary"	self lastRotationDegrees: 0.0.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:19'!changeRotationCenter: evt with: rotHandle	| pos |	pos _ evt cursorPoint.	rotHandle referencePosition: pos.	self referencePosition: pos.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:55'!hasNoScaleOrRotation	^true! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!isFlexMorph	^false! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!lastRotationDegrees	^(self valueOfProperty: #lastRotationDegrees) ifNil:[0.0].! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!lastRotationDegrees: deg	deg = 0.0 		ifTrue:[self removeProperty: #lastRotationDegrees]		ifFalse:[self setProperty: #lastRotationDegrees toValue: deg]! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:20'!referencePosition	| refPos |	refPos _ self valueOfProperty: #referencePosition.	refPos ifNil:[refPos _ self transform globalPointToLocal: super referencePosition].	^self transformFromWorld localPointToGlobal: refPos! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:18'!referencePosition: pos	self setProperty: #referencePosition toValue: 		(self transformFromWorld globalPointToLocal: pos)! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!removeFlexShell	"Do nothing"! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:14'!rotateBy: delta	| pt m |	delta = 0.0 ifTrue:[^self].	self changed.	pt _ self transformFromWorld globalPointToLocal: self referencePosition.	m _ MatrixTransform2x3 withOffset: pt.	m _ m composedWithLocal: (MatrixTransform2x3 withAngle: delta).	m _ m composedWithLocal: (MatrixTransform2x3 withOffset: pt negated).	transform _ self transform composedWithLocal: m.	self computeBounds.	self changed.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!rotationDegrees: degrees	| last delta |	last _ self lastRotationDegrees.	delta _ degrees - last.	self rotateBy: delta.	self lastRotationDegrees: degrees.! !MatrixTransformMorph initialize!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:05:47 am'!"Change Set:		Balloon-8-TrueTypeDate:			2 November 1998Author:			Andreas RaabThe change set includes a TrueType font reader that generates a geometric description of the glyphs in a TrueType file."!Object subclass: #TTContourConstruction	instanceVariableNames: 'points '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTFontDescription	instanceVariableNames: 'glyphTable glyphs kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascender descender lineGap '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTFontReader	instanceVariableNames: 'charMap glyphs nGlyphs kernPairs infoBar fontDescription '	classVariableNames: 'WinToMacTable '	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTFontTableDirEntry	instanceVariableNames: 'tag fontData offset length checkSum '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTGlyph	instanceVariableNames: 'bounds contours advanceWidth leftSideBearing rightSideBearing glyphIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!TTGlyph subclass: #TTCompositeGlyph	instanceVariableNames: 'glyphs '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTKernPair	instanceVariableNames: 'left right value mask '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTPoint	instanceVariableNames: 'x y type '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!BorderedMorph subclass: #TTSampleFontMorph	instanceVariableNames: 'font transform smoothing '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!TTSampleFontMorph subclass: #TTSampleStringMorph	instanceVariableNames: 'string ttBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!!ByteArray methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:55'!byteAt: index	^self at: index! !!ByteArray methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:55'!byteAt: index put: value	^self at: index put: value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	h _ ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	h = 0 ifFalse:[w _ (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:47'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b0 _ (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort _ self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/3/1998 14:20'!shortAt: index put: value bigEndian: aBool	"Store a 16 bit integer quantity starting from the given byte index"	self unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:51'!unsignedShortAt: index bigEndian: aBool	"Return a 16 bit unsigned integer quantity starting from the given byte index"	^aBool 		ifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]		ifFalse:[((self at: index+1) bitShift: 8) + (self at: index)].! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:53'!unsignedShortAt: index put: value bigEndian: aBool	"Store a 16 bit unsigned integer quantity starting from the given byte index"	aBool ifTrue:[		self at: index put: (value bitShift: -8).		self at: index+1 put: (value bitAnd: 255).	] ifFalse:[		self at: index+1 put: (value bitShift: -8).		self at: index put: (value bitAnd: 255).	].	^value! !!ByteArray methodsFor: 'converting' stamp: 'ar 11/2/1998 00:51'!asByteArray	^self! !!FileList methodsFor: 'file list menu' stamp: 'ar 11/14/1998 23:46'!openAsTTF	(TTFontReader parseFileNamed: self fullName) asMorph open! !!TTContourConstruction commentStamp: '<historical>' prior: 0!This class represents a temporary contour structure during the construction of a TTGlyph from a TrueType file.Instance variables:	points	<Array of: TTPoint>	The points defining this contour!!TTContourConstruction methodsFor: 'accessing'!points	^points! !!TTContourConstruction methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:34'!points: anArray	points _ anArray asArray.! !!TTContourConstruction methodsFor: 'accessing'!segments	| segments |	segments _ OrderedCollection new.	self segmentsDo:[:seg| segments add: seg].	^segments! !!TTContourConstruction methodsFor: 'enumerating' stamp: 'ar 11/3/1998 14:42'!segmentsDo: aBlock	"Evaluate aBlock with the segments of the receiver. This may either be straight line	segments or quadratic bezier curves. The decision is made upon the type flags	in TTPoint as follows:	a) 	To subsequent #OnCurve points define a straight segment	b) 	A #OnCurve point followed by a #OffCurve point followed 		by a #TT_ONCURVE point defines a quadratic bezier segment	c)	Two subsequent #OffCurve points have an implicitely defined 		#OnCurve point at half the distance between them"	| last next mid index |	last _ points first.	"The first point is _always_ on the curve"	(last type == #OnCurve) ifFalse:[		Transcript cr; show:'Bad starting point OffCurve'.		last type: #OnCurve].	index _ 2.	[index <= points size] whileTrue:[		mid _ points at: index.		mid type == #OnCurve ifTrue:[			"Straight segment"			aBlock value: (LineSegment from: last asPoint to: mid asPoint).			last _ mid.		] ifFalse:["Quadratic bezier"			"Read ahead if the next point is on curve"			next _ (index < points size) ifTrue:[points at: (index+1)] ifFalse:[points first].			next type == #OnCurve ifTrue:[				"We'll continue after the end point"				index _ index + 1.			] ifFalse:[ "Calculate center"				next _ (next asPoint + mid asPoint) // 2].			aBlock value:(Bezier2Segment from: last asPoint via: mid asPoint to: next asPoint).			last _ next].		index _ index + 1].	(index = (points size + 1)) ifTrue:[		aBlock value:(LineSegment from: points last asPoint to: points first asPoint)]! !!TTContourConstruction methodsFor: 'converting' stamp: 'ar 11/14/1998 21:17'!asCompressedPoints	"Return the receiver compressed into a PointArray.	All lines will be converted into bezier segments with	the control point set to the start point"	| out minPt maxPt fullRange |	minPt _ -16r7FFF asPoint.	maxPt _ 16r8000 asPoint.	"Check if we need full 32bit range"	fullRange _ points contains:[:any| any asPoint < minPt or:[any asPoint > maxPt]].	fullRange ifTrue:[		out _ WriteStream on: (PointArray new: points size).	] ifFalse:[		out _ WriteStream on: (ShortPointArray new: points size).	].	self segmentsDo:[:segment|		out nextPut: segment start.		segment isBezier2Segment 			ifTrue:[out nextPut: segment via]			ifFalse:[out nextPut: segment start].		out nextPut: segment end.	].	^out contents! !!TTContourConstruction methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: points size;		"space;		print: self type;"		nextPut:$)! !!TTContourConstruction class methodsFor: 'instance creation'!on: points	^self new points: points! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: aCharOrInteger	^glyphTable at: aCharOrInteger asInteger+1! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: index put: value	^self shouldNotImplement! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!ascender	^ascender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!bounds	^bounds! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!descender	^descender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!lineGap	^lineGap! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:49'!unitsPerEm	^unitsPerEm! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!copyright	^copyright! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!familyName	^familyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!fullName	^fullName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!postscriptName	^postscriptName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!subfamilyName	^subfamilyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!trademark	^trademark! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!uniqueName	^uniqueName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:49'!versionName	^versionName! !!TTFontDescription methodsFor: 'converting' stamp: 'ar 11/14/1998 23:47'!asMorph	^TTSampleFontMorph font: self! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/14/1998 20:20'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	glyphs do:[:glyph| glyph flipAroundY]! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setAscender: asc descender: desc lineGap: lgap	ascender _ asc.	descender _ desc.	lineGap _ lgap! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:28'!setBounds: aRect unitsPerEm: aNumber	bounds _ aRect.	unitsPerEm _ aNumber.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setGlyphs: glyphArray mapping: mappingTable	glyphs _ glyphArray.	glyphTable _ mappingTable.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:48'!setKernPairs: array	kernPairs _ array! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:46'!setStrings: anArray	copyright _ anArray at: 1.	familyName _ anArray at: 2.	subfamilyName _ anArray at: 3.	uniqueName _ anArray at: 4.	fullName _ anArray at: 5.	versionName _ anArray at: 6.	postscriptName _ anArray at: 7.	trademark _ anArray at: 8.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'ar 11/2/1998 00:25'!glyphs: glyphArray mapping: glyphTable bounds: aRectangle	^self new setGlyphs: glyphArray mapping: glyphTable bounds: aRectangle! !!TTFontReader methodsFor: 'public' stamp: 'ar 11/2/1998 23:51'!readFrom: aStream	| fontData headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat |	"Read the raw font byte data"	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData _ aStream contents asByteArray.	fontDescription _ TTFontDescription new.	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	charMap _ self processCharMap: cmap.	fontDescription setGlyphs: glyphs mapping: charMap.	fontDescription setKernPairs: kernPairs.	^fontDescription! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:21'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap _ assoc value.	charTable _ Array new: 256.	charTable atAllPut: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue:["Mac encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: i put: glyph]].	assoc key = 3 ifTrue:["Win encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: (WinToMacTable at: i) put: glyph]].	^charTable! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 23:48'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmapFmt tableLength cmap assoc |	initialOffset _ entry offset.	entry skip: 2. "Skip table version"	nSubTables _ entry nextUShort.	1 to: nSubTables do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		offset _ entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy _ entry copy.			copy offset: initialOffset + offset.			cmapFmt _ copy nextUShort.			tableLength _ copy nextUShort.			"We can only read cmaps of type 0 (e.g., byte encoded tables)"			(cmapFmt = 0 "or:[cmapFmt = 4]") ifTrue:[				cmap _ Array new: tableLength.				copy nextBytes: tableLength into: cmap startingAt: initialOffset + offset].			pID = 1 ifTrue:[^pID -> cmap]. "Prefer Macintosh encoding over everything else"			assoc _ pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/15/1998 01:00'!processCompositeGlyph: glyph contours: nContours from: entry	"Read a composite glyph from the font data. The glyph passed into this method contains some state variables that must be copied into the resulting composite glyph."	| flags glyphIndex hasInstr cGlyph ofsX ofsY iLen a11 a12 a21 a22 m |	cGlyph _ TTCompositeGlyph new.	a11 _ a22 _ 16r4000.	"1.0 in F2Dot14"	a21 _ a12 _ 0.		"0.0 in F2Dot14"	"Copy state"	cGlyph bounds: glyph bounds; glyphIndex: glyph glyphIndex.	hasInstr _ false.	[ flags _ entry nextUShort.	glyphIndex _ entry nextUShort + 1.	(flags bitAnd: 1) = 1 ifTrue:[		ofsX _ entry nextShort.		ofsY _ entry nextShort.	] ifFalse:[		(ofsX _ entry nextByte) > 127 ifTrue:[ofsX _ ofsX - 256].		(ofsY _ entry nextByte) > 127 ifTrue:[ofsY _ ofsY - 256]].	((flags bitAnd: 2) = 2) ifFalse:[self halt].	(flags bitAnd: 8) = 8 ifTrue:[		a11 _ a22 _ entry nextShort].	(flags bitAnd: 64) = 64 ifTrue:[		a11 _ entry nextShort.		a22 _ entry nextShort].	(flags bitAnd: 128) = 128 ifTrue:[		"2x2 transformation"		a11 _ entry nextShort.		a21 _ entry nextShort.		a12 _ entry nextShort.		a22 _ entry nextShort].	m _ MatrixTransform2x3 new.	"Convert entries from F2Dot14 to float"	m a11: (a11 asFloat / 16r4000).	m a12: (a12 asFloat / 16r4000).	m a21: (a21 asFloat / 16r4000).	m a22: (a22 asFloat / 16r4000).	m a13: ofsX.	m a23: ofsY.	cGlyph addGlyph: (glyphs at: glyphIndex) transformation: m.	hasInstr _ hasInstr or:[ (flags bitAnd: 256) = 256].	"Continue as long as the MORE_COMPONENTS bit is set"	(flags bitAnd: 32) = 32] whileTrue.	hasInstr ifTrue:[		iLen _ entry nextUShort.		entry skip: iLen].	^cGlyph! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:42'!processFontHeaderTable: entry"Value				Data Type    DescriptionunitsPerEm			USHORT      Granularity of the font's em square.xMax				USHORT      Maximum X-coordinate for the entire font.xMin				USHORT      Minimum X-coordinate for the entire font.yMax				USHORT      Maximum Y-coordinate for the entire font.yMin				USHORT      Minimum Y-coordinate for the entire font.indexToLocFormat	SHORT       Used when processing the Index To Loc Table."	| origin corner units indexToLocFormat |	entry skip: 4. "Skip table version number"	entry skip: 4. "Skip font revision number"	entry skip: 4. "Skip check sum adjustment"	entry skip: 4. "Skip magic number"	entry skip: 2. "Skip flags"	units _ entry nextUShort.	entry skip: 8. "Skip creation date"	entry skip: 8. "Skip modification date"	"Get min/max values of all glyphs"	origin _ entry nextShort @ entry nextShort.	corner _ entry nextShort @ entry nextShort.	entry skip: 2. "Skip mac style"	entry skip: 2. "Skip lowest rec PPEM"	entry skip: 2. "Skip font direction hint"	indexToLocFormat _ entry nextShort.	fontDescription setBounds: (origin corner: corner) unitsPerEm: units.	^indexToLocFormat! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/3/1998 14:43'!processGlyphDataTable: entry offsets: offsetArray	"Read the actual glyph data from the font.	offsetArray contains the start offsets in the data for each glyph."	| initialOffset glyph nextOffset glyphLength glyphOffset nContours origin corner |	initialOffset _ entry offset.	glyphs _ Array new: nGlyphs.	1 to: nGlyphs do:[:i | 		glyphs at: i put: (TTGlyph new glyphIndex: i-1)].	'Reading glyph data' 		displayProgressAt: Sensor cursorPoint		from: 1 to: nGlyphs during:[:bar|	1 to: nGlyphs do:[:glyphIndex |		bar value: glyphIndex.		glyph _ glyphs at: glyphIndex.		glyphOffset _ offsetArray at: glyphIndex.		nextOffset _ offsetArray at: glyphIndex+1.		glyphLength _ nextOffset - glyphOffset.		glyphLength = 0 ifFalse:[			entry offset: initialOffset + glyphOffset.			nContours _ entry nextShort.			origin _ entry nextShort @ entry nextShort.			corner _ entry nextShort @ entry nextShort.			glyph bounds: (origin corner: corner).			nContours >= 0 ifTrue:[				self processSimpleGlyph: glyph contours: nContours from: entry			] ifFalse:[				glyph _ self processCompositeGlyph: glyph contours: nContours from: entry.				glyphs at: glyphIndex put: glyph]]]	].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalHeaderTable: entry"ascender           SHORT          Typographic ascent.descender          SHORT          Typographic descent.lineGap            SHORT          Typographic lineGap.numberOfHMetrics   USHORT         Number hMetric entries in the HTMX                                               Table; may be smaller than the total                                             number of glyphs."	| asc desc lGap numHMetrics |	entry skip: 4. "Skip table version"	asc _ entry nextShort.	desc _ entry nextShort.	lGap _ entry nextShort.	entry skip: 2. "Skip advanceWidthMax"	entry skip: 2. "Skip minLeftSideBearing"	entry skip: 2. "Skip minRightSideBearing"	entry skip: 2. "Skip xMaxExtent"	entry skip: 2. "Skip caretSlopeRise"	entry skip: 2. "Skip caretSlopeRun"	entry skip: 10. "Skip 5 reserved shorts"	entry skip: 2. "Skip metricDataFormat"	numHMetrics _ entry nextUShort.	fontDescription setAscender: asc descender: desc lineGap: lGap.	^numHMetrics! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalMetricsTable: entry length: numHMetrics	"Extract the advance width, left side bearing, and right	side bearing for each glyph from the Horizontal Metrics Table."	|  index lastAW glyph |	index _ 1.	[index <= numHMetrics] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: entry nextUShort.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].	index = (nGlyphs +1) ifTrue:[^true].	lastAW _ (glyphs at: index-1) advanceWidth.	[index <= nGlyphs] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: lastAW.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:43'!processIndexToLocationTable: entry format: indexToLocFormat"glyphOffset    ULONG[numGlyphs]   An array that contains each glyph's                                 offset into the Glyph Data Table."	| glyphOffset offset|	glyphOffset _ Array new: nGlyphs+1.	1 to: nGlyphs+1 do:[:i|		(indexToLocFormat = 0) ifTrue:[ "Format0: offset/2 is stored"			offset _ entry nextUShort * 2.		] ifFalse:["Format1: store actual offset"			offset _ entry nextULong].		glyphOffset at: i put: offset].	^glyphOffset! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 23:21'!processKerningTable: entry	"Extract the kerning information for pairs of glyphs."	| covLow covHigh nKernPairs kp |	entry skip: 2. "Skip table version"	entry skip: 2. "Skip number of sub tables -- we're using the first one only"	entry skip: 2. "Skip current subtable number"	entry skip: 2. "Skip length of subtable"	covHigh _ entry nextByte.	covLow _ entry nextByte.	"Make sure the format is right (kerning table and format type 0)"	((covLow bitAnd: 2) = 2 or:[ covHigh ~= 0]) ifTrue:[^false].	nKernPairs _ entry nextUShort.	entry skip: 2. "Skip search range"	entry skip: 2. "Skip entry selector"	entry skip: 2. "Skip range shift"	kernPairs _ Array new: nKernPairs.	1 to: nKernPairs do:[:i|		kp _ TTKernPair new.		kp left: entry nextUShort.		kp right: entry nextUShort.		kp value: entry nextShort.		kernPairs at: i put: kp].	^true! !!TTFontReader methodsFor: 'processing'!processMaximumProfileTable: entry"numGlyphs         USHORT      The number of glyphs in the font."	entry skip: 4. "Skip Table version number"	nGlyphs _ entry nextUShort.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:38'!processNamingTable: entry"copyright         CHARPTR     The font's copyright notice.familyName        CHARPTR     The font's family name.subfamilyName     CHARPTR     The font's subfamily name.uniqueName        CHARPTR     A unique identifier for this font.fullName          CHARPTR     The font's full name (a combination of                                          familyName and subfamilyName).versionName       CHARPTR     The font's version string."	| nRecords initialOffset storageOffset pID sID lID nID length offset multiBytes string strings |	strings _ Array new: 8.	strings atAllPut:''.	initialOffset _ entry offset.	entry skip: 2. "Skip format selector"	"Get the number of name records"	nRecords _ entry nextUShort.	"Offset from the beginning of this table"	storageOffset _ entry nextUShort + initialOffset.	1 to: nRecords do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		lID _ entry nextUShort.		nID _ entry nextUShort.		length _ entry nextUShort.		offset _ entry nextUShort.		"Read only Macintosh or Microsoft strings"		(pID = 1 or:[pID = 3 and:[sID = 1]]) ifTrue:[			"MS uses Unicode all others single byte"			multiBytes _ pID = 3.			string _ entry stringAt: storageOffset + offset length: length multiByte: multiBytes.			"Put the name at the right location.			Note: We prefer Macintosh strings about everything else."			nID < strings size ifTrue:[				(pID = 1 or:[(strings at: nID+1) = ''])					ifTrue:[strings at: nID+1 put: string].			].		].	].	fontDescription setStrings: strings.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 22:18'!processSimpleGlyph: glyph contours: nContours from: entry	| endPts  nPts iLength flags |	endPts _ Array new: nContours.	1 to: nContours do:[:i| endPts at: i put: entry nextUShort].	glyph initializeContours: nContours with: endPts.	nPts _ endPts last + 1.	iLength _ entry nextUShort. "instruction length"	entry skip: iLength.	flags _ self getGlyphFlagsFrom: entry size: nPts.	self readGlyphXCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	self readGlyphYCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	glyph buildContours.! !!TTFontReader methodsFor: 'displaying' stamp: 'ar 11/1/1998 21:04'!displayKerningString: aString on: aGraphicsContext at: aPoint withSize: scale	| glyph start last kp mask char |	start _ aPoint.	last _ nil.	1 to: aString size do:[:i|		char _ aString at: i.		glyph _ charMap at: char.		last = nil ifFalse:[			mask _ TTKernPair maskFor: last glyphIndex with: glyph glyphIndex.			kp _ kernPairs detect:[:any| any mask = mask] ifNone:[nil].			kp isNil ifFalse:[start x: start x + (kp value * scale x)]].		glyph displayCharOn: aGraphicsContext at: start withSize: scale.		start x: start x + (glyph advanceWidth * scale x).		last _ glyph	].! !!TTFontReader methodsFor: 'displaying'!displayString: aString on: aGraphicsContext at: aPoint withSize: scale	| glyph start char |	start _ aPoint.	1 to: aString size do:[:i|		char _ aString at: i.		glyph _ charMap at: char.		glyph displayCharOn: aGraphicsContext at: start withSize: scale.		start x: start x + (glyph advanceWidth * scale x).	].! !!TTFontReader methodsFor: 'private'!display	| gc delay |	gc _ ScheduledControllers activeController view graphicsContext.	delay _ Delay forMilliseconds: 100.	glyphs do:[:g| 		gc clear.		g displayOn: gc.		delay wait].! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getGlyphFlagsFrom: entry size: nPts	"Read in the flags for this glyph.  The outer loop gathers the flags that	are actually contained in the table.  If the repeat bit is set in a flag	then the next byte is read from the table; this is the number of times	to repeat the last flag.  The inner loop does this, incrementing the	outer loops index each time."	| flags index repCount flagBits |	flags _ ByteArray new: nPts.	index _ 1.	[index <= nPts] whileTrue:[		flagBits _ entry nextByte.		flags at: index put: flagBits.		(flagBits bitAnd: 8) = 8 ifTrue:[			repCount _ entry nextByte.			repCount timesRepeat:[				index _ index + 1.				flags at: index put: flagBits]].		index _ index + 1].	^flags! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getTableDirEntry: tagString from: fontData	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables _ fontData shortAt: 5 bigEndian: true.	tag _ ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag _ tag longAt: 1 bigEndian: true.	pos _ 13.	1 to: nTables do:[:i|		currentTag _ fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos _ pos+16].	^nil! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/1/1998 19:59'!open	"^(ScheduledWindow new)		component: (TTFontView model: self);		openWithExtent: 400@400."! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:36'!readGlyphXCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the x coordinates for the given glyph from the font file."	| startPoint endPoint flagBits xValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"If bit zero in the flag is set then this point is an on-curve			point, if not, then it is an off-curve point."			(flagBits bitAnd: 1) = 1 				ifTrue:[ ttPoint type: #OnCurve]				ifFalse:[ttPoint type: #OffCurve].			"First we check to see if bit one is set.  This would indicate that			the corresponding coordinate data in the table is 1 byte long.			If the bit is not set, then the coordinate data is 2 bytes long."			(flagBits bitAnd: 2) = 2 ifTrue:[ "one byte"				xValue _ entry nextByte.				xValue _ (flagBits bitAnd: 16)=16 ifTrue:[xValue] ifFalse:[xValue negated].				ttPoint x: xValue.			] ifFalse:[ "two byte"				"If bit four is set, then this coordinate is the same as the				last one, so the relative offset (of zero) is stored.  If bit				is not set, then read in two bytes and store it as a signed value."				(flagBits bitAnd: 16) = 16 ifTrue:[ ttPoint x: 0 ]				ifFalse:[					xValue _ entry nextShort.					ttPoint x: xValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:37'!readGlyphYCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the y coordinates for the given glyph from the font file."	| startPoint endPoint flagBits yValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"Check if this value one or two byte encoded"			(flagBits bitAnd: 4) = 4 ifTrue:[ "one byte"				yValue _ entry nextByte.				yValue _ (flagBits bitAnd: 32)=32 ifTrue:[yValue] ifFalse:[yValue negated].				ttPoint y: yValue.			] ifFalse:[ "two byte"				(flagBits bitAnd: 32) = 32 ifTrue:[ ttPoint y: 0 ]				ifFalse:[					yValue _ entry nextShort.					ttPoint y: yValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/1/1998 21:01'!warn: aString	Transcript cr; show: aString; endEntry.! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 11/2/1998 00:16'!initialize	"TTFontReader initialize"	WinToMacTable _ 		#(	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 			16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 			32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 			48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 			64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 			80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 			96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 			112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 			173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183 			184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217 			202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248 			161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 			203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 			245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167 			136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149 			253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216) collect:[:i| i+1].! !!TTFontReader class methodsFor: 'examples'!exampleString: aString	"TTFont exampleString:'Warum?'"	self default 		displayString: aString		on: ScheduledControllers activeController view graphicsContext		at: 100@300		withSize: (0.1 @ -0.1).	self default 		displayKerningString: aString		on: ScheduledControllers activeController view graphicsContext		at: 100@500		withSize: (0.1 @ -0.1).! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:43'!parseFileNamed: aString	"TTFontReader parseFileNamed:'c:\windows\arial.ttf'"	"TTFontReader parseFileNamed:'c:\windows\times.ttf'"	| contents |	contents _ (FileStream readOnlyFileNamed: aString) binary contentsOfEntireFile.	^self readFrom: (ReadStream on: contents)! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 00:53'!readFrom: aStream	^self new readFrom: aStream! !!TTFontTableDirEntry methodsFor: 'initialize-release'!on: fd at: index	fontData _ fd.	tag _ fontData longAt: index bigEndian: true.	checkSum _ fontData longAt: index+4 bigEndian: true.	offset _ (fontData longAt: index+8 bigEndian: true) + 1.	length _ fontData longAt: index+12 bigEndian: true.! !!TTFontTableDirEntry methodsFor: 'accessing'!nextByte	| value |	value _ fontData byteAt: offset.	offset _ offset + 1.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextBytes: numBytes into: array startingAt: byteOffset	1 to: numBytes do:[:i|		array at: i put: (fontData byteAt: byteOffset + i - 1)].! !!TTFontTableDirEntry methodsFor: 'accessing'!nextLong	| value |	value _ fontData longAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextShort	| value |	value _ fontData shortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextULong	| value |	value _ fontData unsignedLongAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextUShort	| value |	value _ fontData unsignedShortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!offset	^offset! !!TTFontTableDirEntry methodsFor: 'accessing'!offset: newOffset	offset _ newOffset! !!TTFontTableDirEntry methodsFor: 'accessing'!skip: n	"Skip n bytes"	offset _ offset + n.! !!TTFontTableDirEntry methodsFor: 'accessing' stamp: 'ar 11/1/1998 23:37'!stringAt: stringOffset length: byteLength multiByte: aBoolean	| string index stringLength |	aBoolean ifFalse:[		stringLength _ byteLength.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + i - 1))].		^string	] ifTrue:[		stringLength _ byteLength // 2.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + 1)).			index _ index + 2].		^string]! !!TTFontTableDirEntry class methodsFor: 'instance creation'!on: fontData at: index	^self new on: fontData at: index! !!TTGlyph commentStamp: '<historical>' prior: 0!This class represents a glyph of a TrueType font.Instance variables:	bounds			<Rectangle>	The receiver's bounds	contours		<Array of: PointArray> The compressed contours in the receiver	advanceWidth	<Integer>	advance width of the glyph	leftSideBearing	<Integer>	left side bearing	rightSideBearing <Integer>	right side bearing	glyphIndex 		<Integer>	the original index of the glyph (used for kerning)!!TTGlyph methodsFor: 'initialize-release' stamp: 'ar 11/1/1998 22:25'!initialize	bounds _ 0@0 corner: 0@0.	contours _ #().	advanceWidth _ 0.	leftSideBearing _ 0.	rightSideBearing _ 0.! !!TTGlyph methodsFor: 'accessing'!advanceWidth	^advanceWidth! !!TTGlyph methodsFor: 'accessing'!advanceWidth: aNumber	advanceWidth _ aNumber.! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds	^bounds! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds: aRectangle	bounds _ aRectangle! !!TTGlyph methodsFor: 'accessing'!contours	^contours! !!TTGlyph methodsFor: 'accessing'!contours: aCollection	contours _ aCollection asArray.! !!TTGlyph methodsFor: 'accessing'!glyphIndex	^glyphIndex! !!TTGlyph methodsFor: 'accessing'!glyphIndex: anInteger	glyphIndex _ anInteger! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:26'!glyphsAndTransformationsDo: aBlock	aBlock value: self value: MatrixTransform2x3 identity! !!TTGlyph methodsFor: 'accessing'!leftSideBearing	^leftSideBearing! !!TTGlyph methodsFor: 'accessing'!leftSideBearing: aNumber	leftSideBearing _ aNumber.! !!TTGlyph methodsFor: 'accessing'!rightSideBearing	^rightSideBearing! !!TTGlyph methodsFor: 'accessing'!rightSideBearing: aNumber	rightSideBearing _ aNumber.! !!TTGlyph methodsFor: 'testing'!isComposite	^false! !!TTGlyph methodsFor: 'printing' stamp: 'ar 11/1/1998 22:03'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: contours size;		nextPut:$).! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:18'!buildContours	"Build the contours in the receiver glyph.	The contour is constructed by converting the points	form each contour into an absolute value and then	compressing the contours into PointArrays."	| tx ty points |	tx _ ty _ 0.	contours _ contours collect:[:contour|		points _ contour points.		points do:[:pt|			pt x: (tx _ tx + pt x).			pt y: (ty _ ty + pt y)].		contour asCompressedPoints].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:42'!initializeContours: numContours with: endPoints	"Initialize the contours for creation of the glyph."	| startPt pts endPt |	contours _ Array new: numContours.	startPt _ -1.	1 to: numContours do:[:i|		endPt _ endPoints at: i.		pts _ Array new: endPt - startPt.		1 to: pts size do:[:j| pts at: j put: TTPoint new].		contours at: i put: (TTContourConstruction on: pts).		startPt _ endPt].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:27'!updateRightSideBearing	"Update the right side bearing value"	"@@: Is the following really correct?!!?!!"	rightSideBearing _ advanceWidth - leftSideBearing - bounds corner x + bounds origin x! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:41'!display	| canvas |	canvas _ FormCanvas on: Display.	self contours do:[:ptArray|		1 to: ptArray size by: 3 do:[:i|			canvas line: (ptArray at: i) // 10					to: (ptArray at: i+2) // 10					width: 1 color: Color black.		].	].! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:22'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ self contours collect:[:contour| contour collect:[:pt| pt x @ pt y negated]].! !!TTCompositeGlyph methodsFor: 'initialize' stamp: 'ar 11/2/1998 01:20'!initialize	glyphs _ #().! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:21'!addGlyph: aGlyph transformation: aMatrix	glyphs _ glyphs copyWith: (aMatrix -> aGlyph)! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:43'!contours	^contours ifNil:[contours _ self computeContours]! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:20'!glyphs	^glyphs collect:[:assoc| assoc value].! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:28'!glyphsAndTransformationsDo: aBlock	glyphs do:[:assoc|		aBlock value: assoc value value: assoc key.	].! !!TTCompositeGlyph methodsFor: 'testing'!isComposite	^true! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:43'!computeContours	| out |	out _ WriteStream on: (Array new: glyphs size * 4).	self glyphsAndTransformationsDo:[:glyph :transform|		glyph contours do:[:ptArray|			out nextPut: (transform localPointsToGlobal: ptArray).		].	].	^out contents! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:27'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ nil.! !!TTGlyph class methodsFor: 'instance creation'!new	^super new initialize! !!TTCompositeGlyph class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 01:20'!new	^super new initialize! !!TTKernPair methodsFor: 'accessing'!left	^left! !!TTKernPair methodsFor: 'accessing'!left: aNumber	left _ aNumber! !!TTKernPair methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:08'!mask	^mask ifNil:[mask _ self class maskFor: left with: right]! !!TTKernPair methodsFor: 'accessing'!right	^right! !!TTKernPair methodsFor: 'accessing'!right: aNumber	right _ aNumber! !!TTKernPair methodsFor: 'accessing'!value	^value! !!TTKernPair methodsFor: 'accessing'!value: aNumber	value _ aNumber! !!TTKernPair class methodsFor: 'accessing'!maskFor: left with: right	^(left bitShift: 12) + right! !!TTPoint methodsFor: 'accessing'!type	^type! !!TTPoint methodsFor: 'accessing'!type: aSymbol	type _ aSymbol! !!TTPoint methodsFor: 'accessing'!x	^x! !!TTPoint methodsFor: 'accessing'!x: aNumber	x _ aNumber! !!TTPoint methodsFor: 'accessing'!y	^y! !!TTPoint methodsFor: 'accessing'!y: aNumber	y _ aNumber! !!TTPoint methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: x;		nextPut:$@;		print: y;		nextPut:$|;		print: type;		nextPut:$)! !!TTPoint methodsFor: 'converting'!asPoint	^x@y! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:26'!initialize	super initialize.	borderWidth _ 1.	borderColor _ Color black.	color _ Color black.	smoothing _ 4.	self extent: 300@300.! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/14/1998 23:50'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 03:16'!openInWorld	Smalltalk isMorphic ifFalse:[^self openInMVC].	World primaryHand attachMorph: self! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:32'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box center color: Color magenta on: #mouseDown send: #createSample to: self.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:39'!balloonHelpTextForHandle: aHandle	aHandle eventHandler firstMouseSelector == #createSample		ifTrue:[^'Create a sample string'].	^super balloonHelpTextForHandle: aHandle! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!doesBevels	^false! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:31'!font: aTTFontDescription	| morph |	font _ aTTFontDescription.	morph _ (TTSampleStringMorph font: font).	morph extent: morph extent * 2.	morph color: Color magenta.	self addMorphCentered: morph.	morph position: morph position x @ (self bounds bottom + 10).	self privateFullMoveBy: self fullBounds origin negated.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 22:42'!newTransformationMorph	^MatrixTransformMorph new! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing	^smoothing ifNil:[1]! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing: aNumber	smoothing _ aNumber! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:53'!transform	^transform ifNil:[self computeTransform].! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!extent: extentPoint	super extent: extentPoint.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!position: pos	super position: pos.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/14/1998 23:12'!areasRemainingToFill: aRectangle	^ Array with: aRectangle! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 00:55'!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do:[:i|		glyph _ font at: i.		origin _ font bounds extent * ((i \\ 16) @ (i // 16)).		r _ origin extent: font bounds extent.		offset _ r center - glyph bounds center.		cy _ glyph bounds center y.		m _ MatrixTransform2x3 withOffset: 0@cy.		m _ m composedWithLocal: (MatrixTransform2x3 withScale: 1@-1).		m _ m composedWithLocal: (MatrixTransform2x3 withOffset: 0@cy negated).		m _ m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas transformBy: m while:[:canvas|			canvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 1					borderColor: Color black.		].	].! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:46'!drawOn: aCanvas	| origin extent offset |	(font isNil) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	origin _ self position asIntegerPoint.	extent _ self extent asIntegerPoint.	0 to: 16 do:[:i|		offset _ (extent x * i // 16) @ (extent y * i // 16).		aCanvas line: origin x @ (origin y + offset y) 				to: (origin x + extent x) @ (origin y + offset y)				width: borderWidth color: borderColor.		aCanvas line: (origin x + offset x) @ origin y 				to: (origin x + offset x) @ (origin y + extent y)				width: borderWidth color: borderColor.	].	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		balloonCanvas aaLevel: self smoothing.		self drawCharactersOn: balloonCanvas.	].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self smoothing = 1 		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self smoothing = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self smoothing = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 23:46'!createSample	self world primaryHand attachMorph: (TTSampleStringMorph font: font)! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingMore	smoothing _ 4.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOff	smoothing _ 1.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOn	smoothing _ 2.	self changed! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 01:06'!changed	self invalidRect: (self fullBounds insetBy: -1@-1)! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 22:48'!computeTransform	| fullExtent scale |	fullExtent _ font bounds extent * 16.	scale _ self extent asFloatPoint / fullExtent asFloatPoint.	transform _ MatrixTransform2x3 withScale: scale.	transform _ transform composedWithGlobal: (MatrixTransform2x3 withOffset: self position).	^transform! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:55'!privateMoveBy: delta	super privateMoveBy: delta.	transform _ nil.! !!TTSampleFontMorph class methodsFor: 'instance creation' stamp: 'ar 11/14/1998 23:06'!font: aTTFontDescription	^self new font: aTTFontDescription! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:27'!initialize	super initialize.	borderWidth _ 0.	borderColor _ Color black.	color _ {Color magenta. Color yellow. Color orange. Color lightGray} atRandom.	smoothing _ 4.! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 00:30'!initializeString	| xStart char glyph |	(font isNil or:[string isNil]) ifTrue:[^self].	xStart _ 0.	ttBounds _ 0@0 corner: 0@0.	1 to: string size do:[:i|		char _ string at: i.		glyph _ (font at: char).		ttBounds _ ttBounds merge: (glyph bounds translateBy: xStart@0).		xStart _ xStart + glyph advanceWidth.	].	self extent: ttBounds extent // 40.	borderWidth _ ttBounds height // 40.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:44'!addOptionalHandlesTo: aHalo box: box! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:10'!font: aTTFontDescription	font _ aTTFontDescription.	self string: aTTFontDescription fullName.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:53'!string: aString	string _ aString.	self initializeString.! !!TTSampleStringMorph methodsFor: 'drawing' stamp: 'ar 11/14/1998 22:12'!drawOn: aCanvas	| xStart glyph |	(font isNil or:[string isNil or:[string isEmpty]]) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	xStart _ 0.	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		balloonCanvas aaLevel: self smoothing.		string do:[:char|			glyph _ font at: char.			balloonCanvas transformBy: (MatrixTransform2x3 withOffset: xStart@0) 				while:[:subCanvas| subCanvas drawGeneralBezierShape: glyph contours					color: color borderWidth: borderWidth borderColor: borderColor].			xStart _ xStart + glyph advanceWidth.		].	].! !!TTSampleStringMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:04'!computeTransform	| cy |	cy _ bounds origin y + bounds corner y * 0.5.	transform _ MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy negated).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0@-1.0).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy).	^transform! !TTFontReader initialize!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:06:19 am'!"Change Set:		Balloon-9-FlashDate:			15 November 1998Author:			Your Name<your descriptive text goes here>"!CompressedBoundaryShape subclass: #FlashBoundaryShape	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashColorTransform	instanceVariableNames: 'rAdd rMul gAdd gMul bAdd bMul aAdd aMul '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!DamageRecorder subclass: #FlashDamageRecorder	instanceVariableNames: 'fullDamageRect '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!Object subclass: #FlashFileReader	instanceVariableNames: 'stream log dataSize nFillBits nLineBits nGlyphBits nAdvanceBits jpegDecoder '	classVariableNames: 'ActionTable IndexTables StepTable TagTable '	poolDictionaries: ''	category: 'MM-Flash-Import'!Stream subclass: #FlashFileStream	instanceVariableNames: 'stream bitBuffer bitPosition hasAlpha '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashFileWriter	instanceVariableNames: 'stream log dataSize nFillBits nLineBits nGlyphBits nAdvanceBits jpegEncoder '	classVariableNames: 'TagTable '	poolDictionaries: ''	category: 'MM-Flash-Import'!JPEGReadWriter subclass: #FlashJPEGDecoder	instanceVariableNames: 'eoiSeen '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashKeyframe	instanceVariableNames: 'start stop data '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashKeyframes	instanceVariableNames: 'kfList lastIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashLineStyle	instanceVariableNames: 'width color '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player stepTime frame activeMorphs passiveMorphs activeFont textOffset textPosition textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashSoundEnvelope	instanceVariableNames: 'mark44 level0 level1 '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashSoundInformation	instanceVariableNames: 'syncFlags inPoint outPoint loopCount envelopes '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!MatrixTransformMorph subclass: #FlashMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashCharacterMorph	instanceVariableNames: 'id stepTime frame renderTime vData mData dData cmData pData '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'menuFlag events default over press sensitive sounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashGlyphMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashPlayerMorph	instanceVariableNames: 'borderWidth borderColor controls frames frameNumber stepTime aaLevel sounds actions labels activationKeys activeMorphs damageRecorder localBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashShapeMorph	instanceVariableNames: 'shape '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!FileList methodsFor: 'file list menu' stamp: 'ar 10/12/1998 23:44'!openAsFlash	"Open a MoviePlayerMorph on the given file (must be in .movie format)."	| f |	Smalltalk at: #Morph ifAbsent: [^ self beep].	f _ (directory readOnlyFileNamed: self fullName) binary.	(FlashMorphReader on: f) processFile.! !!FlashBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 21:54'!remapFills	"Replace the fill style dictionary with an array"	| indexMap newFillStyles index |	(fillStyles isKindOf: Dictionary) ifFalse:[^false].	indexMap _ Dictionary new.	indexMap at: 0 put: 0. "Map zero to zero"	newFillStyles _ Array new: fillStyles size.	index _ 1.	fillStyles associationsDo:[:assoc|		indexMap at: assoc key put: index.		newFillStyles at: index put: assoc value.		index _ index + 1.	].	leftFills _ leftFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	rightFills _ rightFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	lineFills _ lineFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	fillStyles _ newFillStyles! !!FlashBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 02:30'!complexity	^points size // 3! !!FlashColorTransform methodsFor: 'initialize' stamp: 'ar 7/2/1998 23:43'!initialize	rMul _ bMul _ gMul _ aMul _ 256.	rAdd _ bAdd _ gAdd _ aAdd _ 0.! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd	^aAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd: aFixed	aAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!aMul	^aMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aMul: aFixed	aMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd	^bAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd: aFixed	bAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!bMul	^bMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bMul: aFixed	bMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd	^gAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd: aFixed	gAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!gMul	^gMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gMul: aFixed	gMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd	^rAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd: aFixed	rAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!rMul	^rMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rMul: aFixed	rMul _ aFixed! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:39'!= aCT	self class == aCT class ifFalse:[^false].	^rAdd = aCT rAdd and:[rMul = aCT rMul and:[		gAdd = aCT gAdd and:[gMul = aCT gMul and:[			bAdd = aCT bAdd and:[bMul = aCT bMul and:[				aAdd = aCT aAdd and:[aMul = aCT aMul]]]]]]]! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:40'!hash	^rAdd hash + gMul hash + bAdd hash + aMul hash! !!FlashColorTransform class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 23:42'!new	^super new initialize! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:54'!fullDamageRect: maxBounds	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect intersect: maxBounds! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:43'!recordInvalidRect: rect	totalRepaint ifTrue:[^self].	self updateIsNeeded ifTrue:[		fullDamageRect _ fullDamageRect merge: rect.	] ifFalse:[		fullDamageRect _ rect copy.	].	^super recordInvalidRect: rect! !!FlashFileReader methodsFor: 'initialize' stamp: 'ar 7/4/1998 20:14'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.	log _ Transcript.	log _ nil.! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 7/3/1998 18:57'!frameNumber	^0! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 7/3/1998 18:57'!frameNumber: anInteger! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/12/1998 23:46'!processFile	"Read and process the entire file"	self processHeader ifFalse:[^nil].	'Reading file' displayProgressAt: Sensor cursorPoint		from: 1 to: 100		during:[:theBar|	[self processTagFrom: stream] whileTrue:[		theBar value: (stream position * 100 // stream size).		stream atEnd ifTrue:[			log ifNotNil:[				log cr; nextPutAll:'Unexpected end of data (no end tag)'.				self flushLog].			^self]].	].	(stream respondsTo: #close) ifTrue:[stream close].! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/4/1998 16:51'!processHeader	"Read header information from the source stream.	Return true if successful, false otherwise."	| version twipsFrameSize frameRate frameCount |	self processSignature ifFalse:[^false].	version _ stream nextByte.	"Check for the version supported"	version > self maximumSupportedVersion ifTrue:[^false].	dataSize _ stream nextLong.	"Check for the minimal file size"	dataSize < 21 ifTrue:[^false].	twipsFrameSize _ stream nextRect.	self recordGlobalBounds: twipsFrameSize.	frameRate _ stream nextWord / 256.0.	self recordFrameRate: frameRate.	frameCount _ stream nextWord.	log ifNotNil:[		log cr; nextPutAll:'------------- Header information --------------'.		log cr; nextPutAll:'File version		'; print: version.		log cr; nextPutAll:'File size			'; print: dataSize.		log cr; nextPutAll:'Movie width		'; print: twipsFrameSize extent x // 20.		log cr; nextPutAll:'Movie height	'; print: twipsFrameSize extent y // 20.		log cr; nextPutAll:'Frame rate		'; print: frameRate.		log cr; nextPutAll:'Frame count	'; print: frameCount.		log cr; cr.		self flushLog].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 7/4/1998 20:08'!processSignature	"Check the signature of the SWF file"	stream nextByte asCharacter = $F ifFalse:[^false].	stream nextByte asCharacter = $W ifFalse:[^false].	stream nextByte asCharacter = $S ifFalse:[^false].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/12/1998 23:57'!processTagFrom: aStream	"Read and process the next tag from the input stream."	| tag data result |	tag _ aStream nextTag.	log ifNotNil:[		log cr; nextPutAll:'Tag #'; print: tag key.		log nextPutAll:' ('; nextPutAll: (TagTable at: tag key + 1); space; print: tag value size;			nextPutAll:' bytes)'.		self flushLog].	data _ FlashFileStream on: (ReadStream on: tag value).	result _ self dispatch: data on: tag key+1 in: TagTable ifNone:[self processUnknown: data].	(log isNil or:[data atEnd]) ifFalse:[		log 			nextPutAll:'*** ';			print: (data size - data position);			nextPutAll:' bytes skipped ***'.		self flushLog].	^result! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 7/4/1998 20:14'!readFile	| time |	"MessageTally spyOn:[self processFile]."	time _ Time millisecondsToRun:[self processFile].	Transcript crtab; print: time; nextPutAll:' msecs to process file'.	Transcript endEntry.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/13/1998 17:53'!processCurveRecordFrom: data	| nBits cx cy ax ay |	log ifNotNil:[log crtab; nextPutAll:'C: '].	nBits _ (data nextBits: 4) + 2. "Offset by 2"	"Read control point change"	cx _ data nextSignedBits: nBits.	cy _ data nextSignedBits: nBits.	log ifNotNil:[log print: cx@cy].	"Read anchor point change"	ax _ data nextSignedBits: nBits.	ay _ data nextSignedBits: nBits.	log ifNotNil:[log nextPutAll:' -- '; print: ax@ay.				self flushLog].	self recordCurveSegmentTo: ax@ay with: cx@cy! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/13/1998 20:31'!processFillStylesFrom: data	| nFills matrix nColors rampIndex rampColor id color fillStyleType ramp |	nFills _ data nextByte.	nFills = 255 ifTrue:[nFills _ data nextWord].	log ifNotNil:[log crtab; print: nFills; nextPutAll:' New fill styles'].	1 to: nFills do:[:i|		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab].		fillStyleType _ data nextByte.		(fillStyleType = 0) ifTrue:["Solid fill"			color _ data nextColor.			self recordSolidFill: i color: color.			log ifNotNil:[log nextPutAll:'solid color '; print: color].		].		(fillStyleType anyMask: 16) ifTrue:["Gradient fill"			"Read gradient matrix"			matrix _ data nextMatrix.			"Read color ramp data"			nColors _ data nextByte.			ramp _ Array new: nColors.			log ifNotNil:[log nextPutAll:'Gradient fill with '; print: nColors; nextPutAll:' colors'].			1 to: nColors do:[:j|				rampIndex _ data nextByte.				rampColor _ data nextColor.				ramp at: j put: (rampIndex -> rampColor)].			self recordGradientFill: i matrix: matrix ramp: ramp linear: (fillStyleType = 16)].		(fillStyleType anyMask: 16r40) ifTrue:["Bit fill"			"Read bitmap id"			id _ data nextWord.			"Read bitmap matrix"			matrix _ data nextMatrix.			log ifNotNil:[log nextPutAll:'Bitmap fill id='; print: id].			self recordBitmapFill: i matrix: matrix id: id clipped: (fillStyleType anyMask: 1)].		self flushLog.	].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/12/1998 23:35'!processFontShapeFrom: data	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/9/1998 20:43'!processLineRecordFrom: data	| nBits x y |	nBits _ (data nextBits: 4) + 2. "Offset by 2"	data nextBitFlag ifTrue:[		"General line"		x _ data nextSignedBits: nBits.		y _ data nextSignedBits: nBits.		self recordLineSegmentBy: x@y.	] ifFalse:[		data nextBitFlag 			ifTrue:[	"vertical line"					y _ data nextSignedBits: nBits. 					self recordLineSegmentVerticalBy: y]			ifFalse:[	"horizontal line"					x _ data nextSignedBits: nBits.					self recordLineSegmentHorizontalBy: x].	].	log ifNotNil:[log crtab; nextPutAll:'E: ';print: x; nextPut:$@; print: y.				self flushLog].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:04'!processLineStylesFrom: data	| nStyles styles lineWidth lineColor |	nStyles _ data nextByte.	nStyles = 255 ifTrue:[nStyles _ data nextWord].	log ifNotNil:[log crtab; print: nStyles; nextPutAll:' New line styles'].	styles _ Array new: nStyles.	1 to: nStyles do:[:i|		lineWidth _ data nextWord.		lineColor _ data nextColor.		self recordLineStyle: i width: lineWidth color: lineColor.		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab; 						print: lineWidth; tab; print: lineColor]].	self flushLog.	^styles! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 10/14/1998 00:39'!processShapeRecordFrom: data	| flags pt lineInfo fillInfo0 fillInfo1 |	data nextBitFlag ifTrue:["Boundary edge record"		data nextBitFlag			ifTrue:[self processLineRecordFrom: data]			ifFalse:[self processCurveRecordFrom: data].		^true].	flags _ data nextBits: 5.	flags = 0 ifTrue:[^false]. "At end of shape"	(flags anyMask: 1) ifTrue:["move to"		pt _ data nextPoint.		self recordMoveTo: pt.		log ifNotNil:[log crtab; nextPutAll:'MoveTo '; print: pt]].	(flags anyMask: 2) ifTrue:["fill info 0"		fillInfo0 _ data nextBits: nFillBits.		self recordFillStyle0: fillInfo0.		log ifNotNil:[log crtab; nextPutAll:'FillInfo0 '; print: fillInfo0]].	(flags anyMask: 4) ifTrue:["fill info 1"		fillInfo1 _ data nextBits: nFillBits.		self recordFillStyle1: fillInfo1.		log ifNotNil:[log crtab; nextPutAll:'FillInfo1 '; print: fillInfo1]].	(flags anyMask: 8) ifTrue:["line info"		lineInfo _ data nextBits: nLineBits.		self recordLineStyle: lineInfo.		log ifNotNil:[log crtab; nextPutAll:'LineInfo '; print: lineInfo]].	(flags anyMask: 16) ifTrue:["new styles"		log ifNotNil:[log crtab; nextPutAll:'New Set of styles '].		self processShapeStylesFrom: data.		"And reset info"		data initBits.		nFillBits _ data nextBits: 4.		nLineBits _ data nextBits: 4].	flags = 31 ifTrue:[self recordResetSubshape].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:05'!processShapeStylesFrom: data	self processFillStylesFrom: data.	self processLineStylesFrom: data.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 10/14/1998 00:29'!processShapesFrom: data	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/14/1998 23:17'!processGlyphEntries: nGlyphs from: data	| index advance |	data initBits.	1 to: nGlyphs do:[:i|		index _ data nextBits: nGlyphBits.		advance _ data nextSignedBits: nAdvanceBits.		self recordNextChar: index+1 advanceWidth: advance.		log ifNotNil:[			log nextPut:$(;print: index; space; print: advance; nextPut:$).			self flushLog].	].! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/13/1998 01:04'!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	].	^true! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/15/1998 19:45'!processGlyphStateChange: flags from: data	| hasFont hasColor hasXOffset hasYOffset fontId color xOffset yOffset height |	hasFont _ flags anyMask: 8.	hasColor _ flags anyMask: 4.	hasYOffset _ flags anyMask: 2.	hasXOffset _ flags anyMask: 1.	hasFont ifTrue:[fontId _ data nextWord].	hasColor ifTrue:[color _ data nextColor].	hasXOffset ifTrue:[xOffset _ data nextWord].	hasYOffset ifTrue:[yOffset _ data nextWord].	hasFont ifTrue:[height _ data nextWord].	log ifNotNil:[		log nextPutAll:'['.		hasFont ifTrue:[log nextPutAll:' font='; print: fontId].		hasColor ifTrue:[log nextPutAll:' color='; print: color].		hasXOffset ifTrue:[log nextPutAll:' xOfs=';print: xOffset].		hasYOffset ifTrue:[log nextPutAll:' yOfs=';print: yOffset].		hasFont ifTrue:[log nextPutAll:' height='; print: height].		log nextPutAll:' ]'.		self flushLog.	].	self recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 10/15/1998 03:23'!processGlyphsFrom: data	| id bounds matrix |	id _ data nextWord.	bounds _ data nextRect.	matrix _ data nextMatrix.	self recordTextStart: id bounds: bounds matrix: matrix.	nGlyphBits _ data nextByte.	nAdvanceBits _ data nextByte.	log ifNotNil:[		log	nextPutAll:'(nGlyphBits = '; 			print: nGlyphBits; 			nextPutAll:' nAdvanceBits = '; 			print: nAdvanceBits;			nextPutAll:') '.		self flushLog].	[self processGlyphRecordFrom: data] whileTrue.	self recordTextEnd: id.! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 7/15/1998 19:19'!processButtonRecords: id from: data	| flags state characterId layer matrix |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		self recordButton: id character: characterId state: state layer: layer matrix: matrix].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGetURL: data	| length position urlString winString |	length _ data nextWord.	position _ data position.	urlString _ data nextString.	winString _ data nextString.	data position = (position + length) ifFalse:[		self halt.		data position: position.		^self processUnknownAction: data].	log ifNotNil:[		log 			nextPutAll:' url='; print: urlString;			nextPutAll:', win='; print: winString].	^Message selector: #getURL:window: arguments: (Array with: urlString with: winString)! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGotoFrame: data	| length frame |	length _ data nextWord.	length = 2 ifFalse:["There is something wrong here"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	log ifNotNil:[log nextPutAll:' frame = '; print: frame.].	^Message selector: #gotoFrame: argument: frame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGotoLabel: data	| length label |	self halt.	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionNextFrame: data	^Message selector: #gotoNextFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionPlay: data	^Message selector: #play! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionPrevFrame: data	^Message selector: #gotoPrevFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:39'!processActionRecordsFrom: data	| code actionList action |	actionList _ OrderedCollection new.	[code _ data nextByte.	code = 0] whileFalse:[		code _ code bitAnd: 127. "Mask out the length-follow flag"		log ifNotNil:[			log cr; nextPutAll:'	Action #'; print: code.			log nextPutAll:' ('; nextPutAll: (ActionTable at: code); nextPutAll:')'].		action _ self dispatch: data on: code in: ActionTable 					ifNone:[self processUnknownAction: data].		action ifNotNil:[actionList add: action].		log ifNotNil:[self flushLog].	].	^actionList! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionSetTarget: data	| length target |	self halt.	length _ data nextWord.	target _ data nextString.	log ifNotNil:[log nextPutAll:' target = '; print: target].	^Message selector: #actionTarget: argument: target.! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionStop: data	^Message selector: #stop! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionStopSounds: data	^Message selector: #stopSounds! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionToggleQuality: data	^Message selector: #toggleQuality! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionWaitForFrame: data	| length frame skip |	length _ data nextWord.	length = 3 ifFalse:["Something is wrong"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	skip _ data nextByte.	log ifNotNil:[		log nextPutAll:'frame = '; print: frame;			nextPutAll:', skip = '; print: skip].	^Message selector: #isFrameLoaded:elseSkip: arguments: (Array with: frame with: skip).! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:37'!processUnknownAction: data	| code length |	data skip: -1. "For determining the length of the action"	code _ data nextByte.	(code anyMask: 128) ifTrue:["Two byte length following"		length _ data nextWord.		data skip: length].	log ifNotNil:[log nextPutAll:'*** skipped ***'].	^nil! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 10/15/1998 02:17'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| data buffers nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask sound k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) contents samplingRate: samplingRate.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 15:37'!processEnvelopeFrom: data	| env |	env _ FlashSoundEnvelope new.	env mark44: data nextULong.	env level0: data nextWord.	env level1: data nextWord.	^env! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 16:11'!processSoundInfoFrom: data	| flags info nPoints |	flags _ data nextByte.	info _ FlashSoundInformation new.	info syncFlags: (flags bitShift: -4).	(flags anyMask: 1) ifTrue:[info inPoint: data nextULong].	(flags anyMask: 2) ifTrue:[info outPoint: data nextULong].	(flags anyMask: 4) ifTrue:[info loopCount: data nextWord].	(flags anyMask: 8) ifTrue:[		nPoints _ data nextByte.		info envelopes: ((1 to: nPoints) collect:[:i| self processEnvelopeFrom: data]).	].	^info! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 14:02'!processDefineBits2: data	| id |	self halt.	id _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 14:02'!processDefineBits3: data	| id |	self halt.	id _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 16:31'!processDefineBits: data	| id image |	id _ data nextWord.	image _ jpegDecoder decodeNextImageFrom: data.	"image display."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 22:30'!processDefineBitsLossless2: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 22:29'!processDefineBitsLossless: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/14/1998 12:11'!processDefineButton2: data	| id flags actions actionOffset condition |	true ifTrue:[^true].	data hasAlpha: true.	id _ data nextWord.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	self halt. "Hier fehlt die CXFORM[nCharacters in button]"	self processButtonRecords: id from: data.	[actionOffset _ data nextWord.	actionOffset = 0] whileFalse:[		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:40'!processDefineButton: data	| id actions |	id _ data nextWord.	self processButtonRecords: id from: data.	actions _ self processActionRecordsFrom: data.	self recordButton: id actions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 8/10/1998 16:18'!processDefineButtonSound: data	| id soundID soundInfo |	id _ data nextWord.	#(0 1 2 3) do:[:state|		soundID _ data nextWord.		soundID = 0 ifFalse:[			soundInfo _ self processSoundInfoFrom: data.			self recordButton: id sound: soundID info: soundInfo state: state]].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 03:18'!processDefineFont: data	| fontId firstOffset offsets nShapes |	fontId _ data nextWord.	firstOffset _ data nextWord.	nShapes _ firstOffset // 2.	offsets _ Array new: nShapes.	offsets at: 1 put: firstOffset.	2 to: nShapes do:[:i| offsets at: i put: data nextWord].	self recordFontBegin: fontId with: nShapes.	1 to: nShapes do:[:i|		log ifNotNil:[log cr; nextPutAll:'Glyph '; print: i].		self recordFontShapeStart: fontId with: i.		self processFontShapeFrom: data.		self recordFontShapeEnd: fontId with: i].	data atEnd ifFalse:[self halt].	self recordFontEnd: fontId.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:52'!processDefineShape2: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:48'!processDefineShape3: data	data hasAlpha: true.	self processShapesFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:22'!processDefineShape: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 03:04'!processDefineSound: data	| flags sampleCount sampleData id stereo bitsPerSample rate compressed sound |	id _ data nextWord.	flags _ data nextByte.	stereo _ (flags anyMask: 1).	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	rate _ #( 5512 11025 22050 44100 ) at: (flags >> 2 bitAnd: 3)+1.	compressed _ flags anyMask: 16.	sampleCount _ data nextULong.	sampleData _ data upToEnd.	compressed ifTrue:[		Cursor wait showWhile:[			sound _ self decompressSound: sampleData 						stereo: stereo 						samples: sampleCount 						rate: rate.		].	] ifFalse:[		self halt.		sound _ nil.	].	self recordSound: id data: sound.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:47'!processDefineText2: data	data hasAlpha: true.	self processGlyphsFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 23:23'!processDefineText: data	self processGlyphsFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:40'!processDoAction: data	| actions |	actions _ self processActionRecordsFrom: data.	self recordFrameActions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:30'!processEnd: data	"At end of data"	^false! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:31'!processFrameLabel: data	| name |	name _ data nextString.	self recordFrameLabel: name.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 8/10/1998 15:55'!processFreeCharacter: data	| id |	id _ data nextWord.	data atEnd ifFalse:[self halt].	self recordFreeCharacter: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 15:27'!processJPEGTables: data	jpegDecoder _ FlashJPEGDecoder new.	jpegDecoder decodeJPEGTables: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/14/1998 20:18'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move ifTrue:[self recordRemoveObject: nil depth: depth].	self recordPlaceObject: id depth: depth matrix: (matrix ifNil:[MatrixTransform2x3 identity]) colorMatrix: cxForm.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:46'!processPlaceObject: data	| id depth matrix colorMatrix |	id _ data nextWord.	depth _ data nextWord.	matrix _ data nextMatrix.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	data atEnd ifFalse:[colorMatrix _ data nextColorMatrix].	self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: colorMatrix.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:32'!processProtect: data	self recordProtection.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/13/1998 00:20'!processRemoveObject2: data	| depth |	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: nil depth: depth.	data atEnd ifFalse:[self halt].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/13/1998 00:19'!processRemoveObject: data	| id depth |	id _ data nextWord.	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: id depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:33'!processSetBackgroundColor: data	| color |	color _ data nextColor.	self recordBackgroundColor: color.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processShowFrame: data	"Show the current frame"	self recordShowFrame.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 02:28'!processSoundStreamBlock: data	self halt.	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/3/1998 13:43'!processSoundStreamHead2: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 21:23'!processSoundStreamHead: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 02:47'!processStartSound: data	| id info |	id _ data nextWord.	info _ self processSoundInfoFrom: data.	self recordStartSound: id info: info.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processUnknown: data	"An unknown tag has been encountered"	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/3/1998 18:49'!tagPlaceObject2: data	| flags id depth matrix colorMatrix ratio name clipDepth |	flags _ data nextByte.	depth _ data nextWord.	(flags anyMask: 2) 		ifTrue:[id _ data nextWord]		ifFalse:[(flags anyMask:1) "sanity check"					ifFalse:[self error:'Either move or character must be specified']].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[colorMatrix _ data nextColorMatrix: true].	(flags anyMask: 16) ifTrue:[ratio _ stream nextWord].	(flags anyMask: 32) ifTrue:[name _ stream nextString].	(flags anyMask: 64) ifTrue:[clipDepth _ stream nextWord].	(flags anyMask: 128) ifTrue:[self warn:'Unknown tagPlaceObject flag'].	^true! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/3/1998 18:55'!dispatch: argument on: aKey in: aTable ifNone: exceptionBlock	| selector |	(aKey < 1 or:[aKey > aTable size]) ifTrue:[^exceptionBlock value].	selector _ aTable at: aKey.	^(self respondsTo: selector) ifTrue:[		self perform: selector with: argument.	] ifFalse:[exceptionBlock value]! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/5/1998 23:42'!flushLog	(log == Transcript) ifTrue:[		log endEntry.		Sensor leftShiftDown ifTrue:[self halt].	].! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/2/1998 20:37'!maximumSupportedVersion	^3! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/12/1998 23:41'!warn: aString	Transcript cr; show: aString.! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:46'!recordCurveSegmentTo: anchorPoint with: controlPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle0: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle1: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 20:56'!recordLineSegmentBy: deltaPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentHorizontalBy: deltaX	^self recordLineSegmentBy: (deltaX@0)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentVerticalBy: deltaY	^self recordLineSegmentBy: (0@deltaY)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:48'!recordLineStyle: styleIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:47'!recordMoveTo: aPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:19'!recordResetSubshape! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeEnd: shapeId! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeStart: shapeId bounds: shapeBounds! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontBegin: fontId with: nGlyphs! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontEnd: fontId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeEnd: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeStart: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:09'!recordNextChar: glyphIndex advanceWidth: advance! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextEnd: id! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextStart: id bounds: bounds matrix: matrix! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 11/13/1998 20:31'!recordBitmapFill: fillIndex matrix: bmMatrix id: bitmapID clipped: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:52'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:55'!recordLineStyle: styleIndex width: lineWidth color: lineColor! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:48'!recordSolidFill: index color: fillColor! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:22'!recordButton: buttonId actions: actionList	"Associate an action list with the given button"	^self recordButton: buttonId actions: actionList condition: 8. "OverDownToOverUp"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:34'!recordButton: buttonId actions: actionList condition: condition	"Associate an action list with the given button:		buttonId:	global ID of the button		actions:		Collection of MessageSends (e.g., actions)		condition:	bit mask describing when the actions should be applied					General conditions:						1 - IdleToOverUp (Mouse enter up)						2 - OverUpToIdle (Mouse exit up)						4 - OverUpToOverDown (Mouse down)						8 - OverDownToOverUp (Mouse up in)					Push button conditions:						16 - OverDownToOutDown (Mouse exit down)						32 - OutDownToOverDown (Mouse enter down)						64 - OutDownToIdle (Mouse up out)					Menu button conditions:						128 - IdleToOverDown (Mouse enter down)						256 - OverDownToIdle (Mouse exit down)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 19:57'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	"Define the character to use for a button.		buttonId:	global ID used for the button		characterId:	ID of the character defining the shape for the button		state:		bit mask for when to use the character						1 - default (e.g. no other state applies)						2 - display when the mouse is over the button but not pressed						4 - display when the button is pressed						8 - the area in which the mouse is supposed to be 'over' the button		layer:		UNKNOWN.		matrix:		Transformation to apply to the character. (Guess!!)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 8/10/1998 15:51'!recordButton: id sound: soundId info: soundInfo state: state! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:06'!recordButton: id trackAsMenu: aBoolean	"Track the button with the given ID as a menu (in contrast to a push) button. Push buttons capture the mouse until the button is released. Menu buttons don't.	Note: If defined for a button, this method will be called prior to any other #recordButton: methods."! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 10/15/1998 02:36'!recordSound: id data: aSampledSound! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:47'!recordSound: id data: sampleData stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount rate: rate compressed: compressed! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordSoundStreamBlock: compressedData! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:45'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordStartSound: id info: info! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:33'!recordBackgroundColor: aColor! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:27'!recordBitmap: bitmapId data: aForm! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 19:41'!recordFrameActions: actionList	"Record the list of actions executed at the next showFrame"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:31'!recordFrameLabel: aString! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 8/10/1998 18:23'!recordFrameRate: fps! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 20:30'!recordFreeCharacter: id	"Free the character with the given id.	Not documented."! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/10/1998 15:51'!recordGlobalBounds: bounds! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:32'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:32'!recordProtection! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:34'!recordRemoveObject: id depth: depth! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:34'!recordShowFrame! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initialize	"FlashFileReader initialize"	self initializeTagTable.	self initializeActionTable.	self initializeStepTable.	self initializeIndexTables.! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 7/15/1998 18:53'!initializeActionTable	"Create and return a new SWF action table"	"FlashFileReader initializeActionTable"	ActionTable _ Array new: 12.	ActionTable atAllPut: #processUnknownAction:.	#(		(processActionGotoFrame:	1)		(processActionGetURL:		3)		(processActionNextFrame:	4)		(processActionPrevFrame:	5)		(processActionPlay:			6)		(processActionStop:			7)		(processActionToggleQuality:	8)		(processActionStopSounds:	9)		(processActionWaitForFrame:	10)		(processActionSetTarget:		11)		(processActionGotoLabel:		12)	) do:[:spec|			ActionTable at: spec last put: spec first.	].! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initializeIndexTables	IndexTables _ Array new: 4.	IndexTables at: 1 put:		#(-1 2).	IndexTables at: 2 put:		#(-1 -1 2 4).	IndexTables at: 3 put:		#(-1 -1 -1 -1 2 4 6 8).	IndexTables at: 4 put:		#(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:15'!initializeStepTable	StepTable _ #(7 8 9 10 11 12 13 14 16 17					19 21 23 25 28 31 34 37 41 45					50 55 60 66 73 80 88 97 107 118					130 143 157 173 190 209 230 253 279 307					337 371 408 449 494 544 598 658 724 796					876 963 1060 1166 1282 1411 1552 1707 1878 2066					2272 2499 2749 3024 3327 3660 4026 4428 4871 5358					5894 6484 7132 7845 8630 9493 10442 11487 12635 13899					15289 16818 18500 20350 22385 24623 27086 29794 32767).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 8/10/1998 15:53'!initializeTagTable	"Create and return a new SWF tag table"	"FlashFileReader initializeTagTable"	TagTable _ Array new: 50.	TagTable atAllPut: #processUnknown:.	#(	(processEnd:					0)	(processShowFrame:			1)	(processDefineShape:		2)	(processFreeCharacter:		3)	(processPlaceObject:			4)	(processRemoveObject:		5)	(processDefineBits:			6)	(processDefineButton:		7)	(processJPEGTables:			8) "NYI"	(processSetBackgroundColor:	9)	(processDefineFont:			10)	(processDefineText:			11)	(processDoAction:			12)	(processDefineFontInfo:		13) "NYI"	"Event sound tags."	(processDefineSound:		14)	(processStartSound:			15)	(processDefineButtonSound:	17)	(processSoundStreamHead:	18)	(processSoundStreamBlock:	19)	(processDefineBitsLossless:	20)	"A bitmap using lossless zlib compression."	(processDefineBitsJPEG2:		21)	"NYI" "A bitmap using an internal JPEG compression table"	(processDefineShape2:		22)	(processDefineButtonCxform:	23) "NYI"	(processProtect:				24)	"This file should not be importable for editing."	"These are the new tags for Flash 3."	(processPlaceObject2:			26)	"NYI" "The new style place w/ alpha color transform and name."	(processRemoveObject2:		28)	"A more compact remove object that omits the character tag (just depth)."	(processDefineShape3:		32)	"A shape V3 includes alpha values."	(processDefineText2:			33) "A text V2 includes alpha values."	(processDefineButton2:		34)	"A button V2 includes color transform) alpha and multiple actions"	(processDefineBitsJPEG3:		35)	"NYI" "A JPEG bitmap with alpha info."	(processDefineBitsLossless2:	36)	"NYI" "A lossless bitmap with alpha info."	(processDefineSprite:		39) "NYI" "Define a sequence of tags that describe the behavior of a sprite."	(processNameCharacter:		40) "NYI" "Name a character definition, character id and a string, (used for buttons) bitmaps, sprites and sounds)."	(processFrameLabel:			43) "A string label for the current frame."	(processSoundStreamHead2:	45) "For lossless streaming sound, should not have needed this..."	(processDefineMorphShape:	46) "NYI" "A morph shape definition"	(processDefineFont2:			48) "NYI"	) do:[:spec|			TagTable at: spec last+1 put: spec first.	].! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 19:04'!fileNamed: aString	"FlashFileReader fileNamed:'/home/isg/raab/WDI/flash/samples/top.swf'"	^self on: (FileStream readOnlyFileNamed: aString).! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 19:53'!on: aStream	^self new on: aStream! !!FlashFileReader class methodsFor: 'testing' stamp: 'ar 7/2/1998 20:30'!canRead: aStream	"Return true if instances of the receiver know how to handle the data from aStream."	| ok pos |	pos _ aStream position.	ok _ aStream next asCharacter = $F and:[			aStream next asCharacter  = $W and:[				aStream next asCharacter = $S]].	aStream position: pos.	^ok! !!FlashFileReader class methodsFor: 'accessing' stamp: 'ar 10/16/1998 00:29'!tagTable	^TagTable! !!FlashFileStream methodsFor: 'initialize' stamp: 'ar 7/15/1998 20:10'!on: aSourceStream	stream _ aSourceStream.	bitBuffer _ bitPosition _ 0.	hasAlpha _ false. "Turn on if needed"! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!atEnd	^stream atEnd! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:44'!close	self flushBits.	stream close! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha	^hasAlpha! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha: aBoolean	hasAlpha _ aBoolean! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:23'!next	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/13/1998 00:40'!nextByte	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:24'!nextByteForBits	^stream next ifNil:[0]! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:19'!nextByteForBitsPut: aByte	^stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:27'!nextBytePut: aByte	"Make sure the bit buffer is reset"	self flushBits.	stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:50'!nextBytes: n	"Return a ByteArray containing the next n bytes"	^stream next: n! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:43'!peekFor: anObject	^stream peekFor: anObject! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!position	^stream position! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:56'!position: aNumber	stream position: aNumber.! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!size	^stream size! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:01'!skip: nBytes	self initBits.	stream skip: nBytes! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!stream	^stream! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 8/10/1998 14:18'!upToEnd	^self stream upToEnd.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:38'!initBits	"Initialize the bit buffer for future bit reading operations.	Note: We do not fetch the first byte here so we can do multiple #initBits	without harming the position of the input stream."	bitPosition _ bitBuffer _ 0.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 21:39'!nextBitFlag	^(self nextBits: 1) = 1! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:27'!nextBits: n	"Return the next n bits"	| shift value remaining |	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value _ 0.	remaining _ n.	[true] whileTrue:[		shift _ remaining - bitPosition.		value _ value bitOr: (bitBuffer bitShift: shift).		shift > 0 ifTrue:["Consumes entire buffer"			remaining _ remaining - bitPosition.			"And get next byte"			bitBuffer _ self nextByteForBits.			bitPosition _ 8.		] ifFalse:["Consumes a portion of the buffer"			bitPosition _ bitPosition - remaining.			"Mask off the consumed bits"			bitBuffer _ bitBuffer bitAnd: (255 bitShift: (bitPosition - 8)).			^value]].! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/15/1998 19:44'!nextColor	| r g b baseColor |	r _ self nextByte / 255.0.	g _ self nextByte / 255.0.	b _ self nextByte / 255.0.	baseColor _ Color r: r g: g b: b.	^hasAlpha 		ifTrue:[baseColor alpha: self nextByte / 255.0]		ifFalse:[baseColor]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 10/4/1998 18:06'!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits).		transform gMul: (self nextSignedBits: nBits).		transform bMul: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits)]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits).		transform gAdd: (self nextSignedBits: nBits).		transform bAdd: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits)]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 10/16/1998 00:47'!nextLong	| ulong |	ulong _ self nextULong.	^ulong > 16r80000000		ifTrue:[ulong - 16r100000000]		ifFalse:[ulong]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/2/1998 23:00'!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a12: (self nextSignedBits: nBits) / 65536.0.		transform a21: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:42'!nextPoint	"Read a (possibly compressed) point"	| nBits point |	nBits _ self nextBits: 5.	point _ (self nextSignedBits: nBits) @ (self nextSignedBits: nBits).	^point! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:41'!nextRect	"Read a (possibly compressed) rectangle"	| nBits xMin xMax yMin yMax |	self initBits.	nBits _ self nextBits: 5.	xMin _ self nextSignedBits: nBits.	xMax _ self nextSignedBits: nBits.	yMin _ self nextSignedBits: nBits.	yMax _ self nextSignedBits: nBits.	^(xMin@yMin) corner: (xMax@yMax).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 19:11'!nextSignedBits: n	"Return the next n bits as signed integer value"	| value bits signBit |	n = 0 ifTrue:[^0].	value _ self nextBits: n.	"Use a lookup for determining whether or not the value should be sign extended"	bits _ #( 1 2 4 8 16 32 64 128 "1 ... 8"			256 512 1024 2048 4096 8192 16384 32768 "9 ... 16"			65536 131072 262144 524288 1048576 2097152 4194304 8388608 "17 ... 24"			16777216 33554432 67108864 134217728 268435456 536870912 1073741824 2147483648 "25 ... 32"			 4294967296 "33 bit -- for negation only" ).	signBit _ bits at: n.	^(value bitAnd: signBit) = 0		ifTrue:[value]		ifFalse:[value - (bits at: n+1)]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextString	| out byte |	out _ WriteStream on: (String new: 50).	[byte _ self nextByte.	byte = 0] whileFalse:		[out nextPut: (self convertChar2Squeak: byte asCharacter)].	^out contents! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:44'!nextTag	"Read the next tag. Return an association with the key being the tag id and its value the contents of the chunk following."	| word tag length |	word _ self nextWord.	"Extract tag and length from the word"	length _ word bitAnd: 16r3F.	tag _ word bitShift: -6.	"Check if an extra word follows"	length = 16r3F ifTrue:[length _ self nextULong].	^Association key: tag value: (self nextBytes: length).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextULong	^self nextByte + 		(self nextByte bitShift: 8) + 		(self nextByte bitShift: 16) + 		(self nextByte bitShift: 24).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextWord	^self nextByte + (self nextByte bitShift: 8)! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:27'!flushBits	"Flush the bit buffer for future bit writing operations."	bitPosition = 0 ifFalse:[self nextByteForBitsPut: bitBuffer].	bitPosition _ 0.	bitBuffer _ 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:36'!nextBitFlag: aBoolean	^self nextBits: 1 put: (aBoolean ifTrue:[1] ifFalse:[0])! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:41'!nextBits: n put: aNumber	"Write the next n bits"	| value remaining shift |	value _ aNumber. "Do not round - this is a sanity check"	value isInteger ifFalse:[^self error:'Not an integer number'].	value < 0 ifTrue:[^self error:'Not a positive number'].	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value < (1 bitShift: n) ifFalse:[^self error:'Unable to represent number'].	remaining _ n.	[true] whileTrue:[		shift _ 8 - bitPosition - remaining.		bitBuffer _ bitBuffer + (value bitShift: shift).		"Mask out consumed bits"		value _ value bitAnd: (1 bitShift: 0-shift) - 1.		shift < 0 ifTrue:["Buffer overflow"			remaining _ remaining - (8 - bitPosition).			"Store next byte"			self nextByteForBitsPut: bitBuffer.			bitBuffer _ 0.			bitPosition _ 0.		] ifFalse:["Store only portion of the buffer"			bitPosition _ bitPosition + remaining.			^self		].	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:44'!nextColorMatrixPut: cm	"Write a (possibly compressed) color transformation"	self flushBits.	self nextBits: 2 put: 3. "Always write full transform"	self mextBits: 4 put: 15. "Always use full accuracy"	self nextSignedBits: 15 put: cm rMul.	self nextSignedBits: 15 put: cm gMul.	self nextSignedBits: 15 put: cm bMul.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aMul].	self nextSignedBits: 15 put: cm rAdd.	self nextSignedBits: 15 put: cm gAdd.	self nextSignedBits: 15 put: cm bAdd.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aAdd].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:38'!nextColorPut: aColor	self nextBytePut: (aColor red * 255) rounded.	self nextBytePut: (aColor green * 255) rounded.	self nextBytePut: (aColor blue * 255) rounded.	hasAlpha ifTrue:[self nextBytePut: (aColor alpha * 255) rounded].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:46'!nextLongPut: value	value < 0 		ifTrue:[self nextULongPut: 16r100000000 - value]		ifFalse:[self nextULongPut: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 11/2/1998 23:00'!nextMatrixPut: matrix	"write a (possibly compressed) transformation matrix"	self flushBits.	(matrix a11 = 0.0 and:[matrix  a22 = 0.0]) ifFalse:[		"Write a/d"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a11 * 65536.		self nextSignedBits: 31 put: matrix a22 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	((matrix a12) = 0.0 and:[(matrix  a21) = 0.0]) ifFalse:[		"Write b/c"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a12 * 65536.		self nextSignedBits: 31 put: matrix a21 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	"Write tx/ty"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: matrix a13.	self nextSignedBits: 31 put: matrix a23.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:55'!nextPointPut: aPoint	"Write a (possibly compressed) point"	self nextBits: 5 put: 31. "Always write full accuracy"	self nextSignedBits: 31 put: aPoint x.	self nextSignedBits: 31 put: aPoint y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:29'!nextRectPut: aRect	"Write a (possibly compressed) rectangle"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: aRect origin x.	self nextSignedBits: 31 put: aRect corner x.	self nextSignedBits: 31 put: aRect origin y.	self nextSignedBits: 31 put: aRect corner y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:59'!nextSignedBits: n put: someValue	"Write the next n bits as signed integer value"	| value |	value _ someValue rounded. "Do rounding here if not done before"	value < 0		ifTrue:[self nextBits: n put: 16r100000000 - value]		ifFalse:[self nextBits: n put: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:01'!nextStringPut: aString	aString do:[:char| self nextBytePut: (self convertCharFromSqueak: char) asInteger].	self nextBytePut: 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:03'!nextTagPut: tag length: length	"Write the next tag."	length >= 16r3f ifTrue:[		self nextWordPut: (tag bitShift: 6) + 16r3F.		self nextULongPut: length.	] ifFalse:[		self nextWordPut: (tag bitShift: 6) + length.	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:04'!nextULongPut: long	self nextBytePut: (long bitAnd: 255).	self nextBytePut: ((long bitShift: -8) bitAnd: 255).	self nextBytePut: ((long bitShift: -16) bitAnd: 255).	self nextBytePut: ((long bitShift: -24) bitAnd: 255).! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:06'!nextWordPut: value	self nextBytePut: (value bitAnd: 255).	self nextBytePut: ((value bitShift: -8) bitAnd: 255).! !!FlashFileStream methodsFor: 'private' stamp: 'ar 7/3/1998 18:17'!convertChar2Squeak: aCharacter	"Convert aCharacter from SWF char set (whatever this may be) to Squeaks char set"	^aCharacter! !!FlashFileStream methodsFor: 'private' stamp: 'ar 10/16/1998 01:01'!convertCharFromSqueak: aCharacter	"Convert aCharacter to SWF char set (whatever this may be) "	^aCharacter! !!FlashFileStream class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 17:33'!on: aSourceStream	^self basicNew on: aSourceStream! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:23'!close	stream close! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:22'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:26'!writeHeader: bounds rate: frameRate	"Read header information from the source stream.	Return true if successful, false otherwise."	self halt.	self writeSignature.	stream nextBytePut: 3. "Always write flash3"	dataSize _ stream nextLongPut: 0.	"Place holder for data size"	stream nextRectPut: bounds.	stream nextWordPut: (frameRate * 256) truncated.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:20'!writeSignature	stream nextBytePut: $F asInteger.	stream nextBytePut: $W asInteger.	stream nextBytePut: $S asInteger.! !!FlashFileWriter class methodsFor: 'class initialization' stamp: 'ar 10/16/1998 00:31'!initialize	"FlashFileWriter initialize"	TagTable _ Dictionary new.	FlashFileReader tagTable doWithIndex:[:tag :index|		TagTable at: (tag copyWithout: $:) asSymbol put: index	].! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:23'!newFileNamed: aString	"FlashFileWriter newFileNamed:'f:\wdi\GraphicsEngine\flash\test.swf'"	^self on: (FileStream newFileNamed: aString).! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:24'!on: aStream	^self new on: aStream! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!decodeJPEGTables: aStream	self setStream: aStream.	eoiSeen _ false.	self parseFirstMarker.	[eoiSeen] whileFalse:[self parseNextMarker].! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 15:16'!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	image _ Cursor wait showWhile:[self nextImage].	(stream position + 2 < stream size) ifTrue:[self halt].	^image! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!parseEndOfInput	eoiSeen _ true.! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:42'!next	^stream nextByte! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:43'!next: n	^stream nextBytes: n! !!FlashKeyframe methodsFor: 'initialize' stamp: 'ar 11/12/1998 22:55'!from: startValue to: stopValue data: newData	start _ startValue.	stop _ stopValue.	data _ newData.! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data	^data! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data: anObject	data _ anObject! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start	^start! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start: startValue	start _ startValue! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop	^stop! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop: stopValue	stop _ stopValue! !!FlashKeyframe methodsFor: 'testing' stamp: 'ar 11/12/1998 22:56'!contains: aNumber	^aNumber >= start and:[aNumber <= stop]! !!FlashKeyframe methodsFor: 'printing' stamp: 'ar 11/13/1998 14:33'!printOn: aStream	aStream nextPutAll: self class name;		nextPut:$(;		print: start;		nextPut:$-;		print: stop;		nextPutAll:' -> ';		print: data;		nextPut:$)! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:47'!from: startValue to: stopValue	^self new from: startValue to: stopValue! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:54'!from: startValue to: stopValue data: newData	^self new from: startValue to: stopValue data: newData! !!FlashKeyframes methodsFor: 'initialize' stamp: 'ar 8/14/1998 19:32'!initialize	kfList _ OrderedCollection new.! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 23:05'!at: frameNumber	"Return data from the keyframe list at the given frame number"	| lastEntry |	kfList isEmpty ifTrue:[^nil].	lastIndex ifNil:[lastIndex _ self searchFor: frameNumber].	lastEntry _ kfList at: lastIndex.	(lastEntry contains: frameNumber) ifTrue:[^lastEntry data].	"Do a quick check if the frame is out of range"	kfList first stop >= frameNumber 		ifTrue:[	lastIndex _ 1.				^kfList first data].	kfList last start <= frameNumber 		ifTrue:[	lastIndex _ kfList size. 				^kfList last data].	"Search linearly from lastEntry - most times we'll just be one step away"	[lastEntry stop >= frameNumber] whileFalse:[		lastIndex _ lastIndex+1.		lastEntry _ kfList at: lastIndex].	[lastEntry start <= frameNumber] whileFalse:[		lastIndex _ lastIndex-1.		lastEntry _ kfList at: lastIndex].	^lastEntry data! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!at: frameNumber put: newData	"Add newData to the keyframe list at the given frameNumber"	| kf |	kfList ifNil:[kfList _ OrderedCollection new].	kfList isEmpty ifFalse:["Check if we can extend the last interval"		kf _ kfList last.		kf stop < frameNumber 			ifFalse:[^self replaceData: newData at: frameNumber].		kf data = newData "Extend interval to include frameNumber"			ifTrue:[	kf stop: frameNumber.					^newData].		"Extend last interval to just before frameNumer"		kf stop: frameNumber - 1].	kfList add: (FlashKeyframe from: frameNumber to: frameNumber data: newData).	^newData! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!keys	^kfList collect:[:kf| kf start].! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 10/14/1998 20:27'!size	^kfList size! !!FlashKeyframes methodsFor: 'printing' stamp: 'ar 8/14/1998 19:32'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		cr.	kfList do:[:item| aStream print: item; cr].	aStream nextPut:$).! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:51'!replaceData: newData at: frameNumber	(kfList last stop = frameNumber) 		ifTrue:[^self replaceLastData: newData at: frameNumber].	self halt:'Not implemented yet'! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/13/1998 14:36'!replaceLastData: newData at: frameNumber	| kf |	kf _ kfList last.	(kf stop = kf start)		ifTrue:[kfList removeLast]		ifFalse:[kf stop: kf stop-1].	^self at: frameNumber put: newData! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:54'!searchFor: frameNumber	"Return data from the keyframe list at the given frame number"	| low high mid kf |	low _ kfList at: 1.	high _ kfList at: kfList size.	"Check if in or before first keyframe interval"	frameNumber <= low stop ifTrue:[^1].	"Check if in or after last keyframe interval"	frameNumber >= high start ifTrue:[^kfList size].	"Somewhere inbetween 2nd to (n-1)th interval"	low _ 2. high _ kfList size - 1.	[mid _ high + low // 2.	low > high] whileFalse:[		kf _ kfList at: mid.		(kf contains: frameNumber) ifTrue:[^mid].		(kf start < frameNumber)			ifTrue:[low _ mid + 1]			ifFalse:[high _ mid - 1]].	kf _ kfList at: low.	(kf contains: frameNumber) ifFalse:[self error:'No keyframe found'].	^low! !!FlashKeyframes class methodsFor: 'instance creation' stamp: 'ar 8/14/1998 19:32'!new	^super new initialize! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color	^color! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor	color _ aColor! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor width: aNumber	self color: aColor.	self width: aNumber.! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width	^width! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width: aNumber	width _ aNumber! !!FlashLineStyle methodsFor: 'comparing' stamp: 'ar 8/15/1998 00:59'!= aLineStyle	self class = aLineStyle class ifFalse:[^false].	^self color = aLineStyle color and:[self width = aLineStyle width].! !!FlashLineStyle class methodsFor: 'instance creation' stamp: 'ar 7/14/1998 21:19'!color: aColor width: aNumber	^self new color: aColor width: aNumber! !!FlashMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 16:44'!withAll: aCollection	^(self new) 		addAllMorphs: aCollection;		computeBounds;		yourself! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/15/1998 23:45'!doLog	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/14/1998 19:22'!logShapes	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/12/1998 21:15'!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 10/13/1998 00:31'!processFile	"Read and process the entire file"	^self processFile: World.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/16/1998 02:34'!processFile: aMorph	super processFile.	player frames: frame.	player position: player position // 20.	player extent: player extent // 20.	player loadInitialFrame.	player stepForward.	player stepBackward.	aMorph ifNil:[		player play.		^player openInMVC].	aMorph isWorldMorph ifTrue:[		"aMorph world activeHand attachMorph: player."		player openInWorld.	] ifFalse:[		aMorph addMorph: player.	].	^player! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/16/1998 01:23'!recordFontShapeEnd: fontId with: charId	| font shape |	self endShape.	shape _ FlashGlyphMorph withAll: currentShape contents reversed.	shape lockChildren.	currentShape resetToStart.	font _ fonts at: fontId ifAbsentPut:[Dictionary new].	font at: charId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/12/1998 21:39'!recordFontShapeStart: fontId with: charId	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.	self recordSolidFill: 1 color: Color black.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/15/1998 17:17'!recordNextChar: glyphIndex advanceWidth: advance	| shape |	(activeFont includesKey: glyphIndex) ifTrue:[		shape _ (activeFont at: glyphIndex) fullCopy reset.		shape transform: ((MatrixTransform2x3 withOffset: textPosition) 							setScale: (textHeight@textHeight) / 1024.0).		shape color: textMorph color.		textMorph addMorphBack: shape.].	textPosition _ textPosition + (advance@0).! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 10/14/1998 19:23'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height	fontId ifNotNil:[activeFont _ fonts at: fontId].	height ifNotNil:[textHeight _ height].	xOffset ifNotNil:[textPosition _  (textOffset x + xOffset) @ textPosition y].	yOffset ifNotNil:[textPosition _ textPosition x @ (yOffset + textOffset y)].	color ifNotNil:[textMorph color: color].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/12/1998 21:34'!recordTextEnd: id	textMorph submorphs isEmpty ifFalse:[		textMorph allMorphsDo:[:m| m color: textMorph color].		textMorph id: id.		textMorph stepTime: stepTime.		textMorph lockChildren.		shapes at: id put: textMorph].	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/15/1998 18:43'!recordTextStart: id bounds: bounds matrix: matrix	textPosition _ textOffset _ bounds origin.	textMorph _ FlashCharacterMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 16:19'!recordCurveSegmentTo: anchorPoint with: controlPoint	| target midPoint |	midPoint _ location + controlPoint.	target _ midPoint + anchorPoint.	self addLineFrom: location to: target via: midPoint.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle0: fillIndex	fillIndex0 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle1: fillIndex	fillIndex1 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/3/1998 16:09'!recordLineSegmentBy: deltaPoint	| target |	target _ location + deltaPoint.	self addLineFrom: location to: target via: location.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:40'!recordLineStyle: styleIndex	lineStyleIndex _ styleIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:44'!recordMoveTo: aPoint	location _ aPoint.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 21:41'!recordResetSubshape	| fills lines |	fills _ fillStyles.	lines _ lineStyles.	self endShape.	self beginShape.	fillStyles _ fills.	lineStyles _ lines.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/16/1998 01:23'!recordShapeEnd: shapeId	| shape |	self endShape.	shape _ FlashCharacterMorph withAll: (currentShape contents reversed).	shape lockChildren.	currentShape resetToStart.	shape id: shapeId.	shape stepTime: stepTime.	shapes at: shapeId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 23:23'!recordShapeStart: shapeId bounds: bounds	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/3/1998 18:09'!addLineFrom: start to: end via: via	canCompressPoints ifTrue:[		"Check if we can compress the incoming points"		(compressionBounds containsPoint: start) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: via) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: end) ifFalse:[canCompressPoints _ false].	].	pointList nextPut: start.	pointList nextPut: via.	pointList nextPut: end.	leftFillList nextPut: fillIndex0.	rightFillList nextPut: fillIndex1.	lineStyleList nextPut: lineStyleIndex.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:43'!beginShape	canCompressPoints _ true.	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	pointList resetToStart.	leftFillList resetToStart.	rightFillList resetToStart.	lineStyleList resetToStart.	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:24'!computeFillLists	"Compute the fill index lists"	| leftFills rightFills |	leftFills_ leftFillList contents as: ShortRunArray.	rightFills _ rightFillList contents as: ShortRunArray.	^Array with: leftFills with: rightFills! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 20:42'!computeLineStyleLists	"Compute the line style index lists.	Each line style will be splitted into two parts, the width and the fill.	Then, the fills will be added to the fillStyles and the indexes will be adjusted.	Finally, we compute two arrays containing the width of each line and the	fill style of each line"	| widthList fillList indexMap oldIndex newIndex allFillStyles style |	allFillStyles _ Dictionary new.	fillStyles associationsDo:[:assoc| 		allFillStyles at: assoc key put: assoc value].	indexMap _ Dictionary new.	lineStyles associationsDo:[:assoc|		oldIndex _ assoc key.		style _ assoc value.		allFillStyles at: allFillStyles size+1 put: (SolidFillStyle color: style color).		newIndex _ allFillStyles size.		indexMap at: oldIndex put: newIndex.	].	widthList _ OrderedCollection new: lineStyles size.	fillList _ OrderedCollection new: lineStyles size.	lineStyleList contents do:[:index|		index = 0 ifTrue:[			widthList add: 0.			fillList add: 0.		] ifFalse:[			style _ lineStyles at: index.			widthList add: style width.			fillList add: (indexMap at: index).		].	].	widthList _ widthList as: ShortRunArray.	fillList _ fillList as: ShortRunArray.	^Array with: allFillStyles with: fillList with: widthList! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/15/1998 15:32'!endShape	| points shape fillLists lineLists index |	canCompressPoints ifTrue:[		points _ ShortPointArray new: pointList size.	] ifFalse:[		points _ PointArray new: pointList size.	].	index _ 1.	pointList contents do:[:p|		points at: index put: p.		index _ index + 1].	fillLists _ self computeFillLists.	lineLists _ self computeLineStyleLists.	shape _ FlashBoundaryShape 				points: points 				leftFills: fillLists first				rightFills: fillLists last				fillStyles: lineLists first				lineWidths: lineLists last				lineFills: (lineLists at: 2).	shape remapFills.	currentShape nextPut:(FlashShapeMorph shape: shape).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/13/1998 20:34'!recordBitmapFill: index matrix: bmMatrix id: bitmapID clipped: aBoolean	| fillStyle form |	form _ forms at: bitmapID ifAbsent:[^nil].	fillStyle _ BitmapFillStyle form: form.	fillStyle origin: (bmMatrix localPointToGlobal: 0@0).	fillStyle direction: (bmMatrix localPointToGlobal: form extent x @ 0).	fillStyle normal: (bmMatrix localPointToGlobal: 0 @ form extent y).	fillStyles at: index put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/11/1998 22:39'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean	| fillStyle ramp origin direction normal |	ramp _ colorRampArray collect:[:assoc| (assoc key / 255.0) -> assoc value].	origin _ gradientMatrix localPointToGlobal: (aBoolean ifFalse:[0@0] ifTrue:[-16384@0]).	direction _ (gradientMatrix localPointToGlobal: (16384@0)) - origin.	normal _ (gradientMatrix localPointToGlobal: (0@16384)) - origin.	fillStyle _ GradientFillStyle ramp: ramp.	fillStyle origin: origin.	fillStyle direction: direction.	fillStyle normal: normal.	fillStyle radial: aBoolean not.	Cursor wait showWhile:[fillStyle pixelRamp].	fillStyles at: fillIndex put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 8/15/1998 00:58'!recordLineStyle: styleIndex width: lineWidth color: lineColor	lineStyles at: styleIndex put: (FlashLineStyle color: lineColor width: lineWidth).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/11/1998 22:39'!recordSolidFill: index color: fillColor	fillStyles at: index put: (SolidFillStyle color: fillColor)! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:44'!recordBackgroundColor: aColor	player color: aColor! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/12/1998 21:50'!recordBitmap: id data: aForm	aForm ifNil:[^self].	"Record the current form"	forms at: id put: aForm.	"Define a new character"! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 14:39'!recordFrameActions: actionList	player addActions: actionList atFrame: frame-1.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 14:32'!recordFrameLabel: aString	player addLabel: aString atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 02:23'!recordFrameRate: fps	fps > 0.0 ifTrue:[stepTime _ (1000.0 / fps) rounded].	player stepTime: stepTime.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 21:34'!recordGlobalBounds: bounds	player localBounds: bounds.	player bounds: bounds.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 16:04'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorMatrix: colorMatrix atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/3/1998 23:19'!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[^self]) do:[:morph|			((morph depthAtFrame: frame-1) = depth) ifTrue:[self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph depthAtFrame: frame-1) = depth) ifTrue:[self removeActiveMorph: morph]]]! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:44'!recordShowFrame	frame _ frame + 1.	player frames: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/10/1998 23:46'!recordSound: id data: aSampledSound	aSampledSound ifNotNil:[sounds at: id put: aSampledSound]! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:55'!recordStartSound: id info: info	| theSound |	theSound _ self createSound: id info: info.	theSound ifNotNil:[player addSound: theSound at: frame].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/12/1998 20:48'!createSound: id info: info	| theSound |	theSound _ sounds at: id ifAbsent:[^nil].	^RepeatingSound repeat: theSound count: info loopCount! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 10/15/1998 23:15'!newMorphFromShape: objectIndex	"Return a new character morph from the given object index.	If the character morph at objectIndex is already used, then create and return a full copy of it"	| prototype |	prototype _ self oldMorphFromShape: objectIndex.	prototype isNil ifTrue:[^nil].	^((passiveMorphs includesKey: objectIndex) or:[activeMorphs includesKey: objectIndex]) 		ifTrue:[prototype fullCopy]		ifFalse:[prototype].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 10/15/1998 23:15'!oldMorphFromShape: objectIndex	"Return an existing character morph from the given object index."	| prototype |	prototype _ shapes at: objectIndex ifAbsent:[nil].	prototype ifNil:[prototype _ buttons at: objectIndex ifAbsent:[nil]].	^prototype! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:27'!placeGlyph: aMorph at: position	aMorph privateFullMoveBy: position.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/14/1998 19:22'!removeActiveMorph: aMorph	| newActive newPassive |	aMorph visible: false atFrame: frame.	newActive _ (activeMorphs at: aMorph id) copyWithout: aMorph.	newPassive _ (passiveMorphs at: aMorph id ifAbsent:[#()]) copyWith: aMorph.	activeMorphs at: aMorph id put: newActive.	passiveMorphs at: aMorph id put: newPassive.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:28'!resizeGlyph: aMorph to: extent	aMorph extent: 1440@1440.	aMorph extent: extent.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 01:52'!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter send: #executeActions: to: player withValue: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 01:24'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	| button children shape |	button _ buttons at: buttonId ifAbsentPut:[FlashButtonMorph new].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[self halt].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape transform: matrix.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 10/15/1998 20:57'!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self].	theSound _ self createSound: id info: soundInfo.	theSound ifNil:[^self].	self halt.	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 10/15/1998 23:46'!recordButton: id trackAsMenu: aBoolean	| button |	button _ buttons at: id ifAbsentPut:[FlashButtonMorph new].	button id: id.	button trackAsMenu: aBoolean.! !!FlashShapeMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 15:32'!shape: aCompressedFlashGeometry	^self new shape: aCompressedFlashGeometry! !!FlashSoundEnvelope methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:35'!initialize	mark44 _ level0 _ level1 _ 0.! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0	^level0! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0: anInteger	level0 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1	^level1! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1: anInteger	level1 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44	^mark44! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44: anInteger	mark44 _ anInteger! !!FlashSoundEnvelope class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:35'!new	^super new initialize! !!FlashSoundInformation methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:30'!initialize	syncFlags _ 0.	inPoint _ -1.	outPoint _ -1.	loopCount _ 0.	envelopes _ #().! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes	^envelopes! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes: aCollection	envelopes _ aCollection! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint	^inPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint: anInteger	inPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!loopCount	^loopCount! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!loopCount: anInteger	loopCount _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint	^outPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint: anInteger	outPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:30'!syncFlags	^syncFlags! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!syncFlags: anInteger	syncFlags _ anInteger! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:33'!syncNoMultiple	"Don't start the sound if already playing."	^syncFlags anyMask: 1! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:34'!syncStopSound	"Stop the sound."	^syncFlags anyMask: 2! !!FlashSoundInformation class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:29'!new	^super new initialize! !!Morph methodsFor: 'classification' stamp: 'ar 8/10/1998 18:50'!isFlashMorph	^false! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:27'!loadInitialFrame! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 8/15/1998 17:15'!lockChildren	submorphs do:[:m| m lock].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/13/1998 16:10'!reset	submorphs do:[:m| m isFlashMorph ifTrue:[m reset]].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 8/15/1998 17:21'!unlockChildren	submorphs do:[:m| m unlock].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:48'!defaultAALevel	^self valueOfProperty: #aaLevel! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel: aNumber	aNumber isNil 		ifTrue:[self removeProperty: #aaLevel]		ifFalse:[self setProperty: #aaLevel toValue: aNumber]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:14'!depth	^0! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:40'!flashPlayer	| parent |	parent _ owner.	[parent isNil] whileFalse:[		(parent isFlashMorph and:[parent isFlashPlayer]) ifTrue:[^parent].		parent _ parent owner].	^nil! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:12'!isFlashMorph	^true! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:04'!isFlashPlayer	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 02:47'!canvasForSubmorphs: canvasForMe	| canvas aaLevel |	canvas _ (super canvasForSubmorphs: canvasForMe).	aaLevel _ self defaultAALevel.	aaLevel isNil		ifTrue:[^canvas]		ifFalse:[^canvas copy aaLevel: aaLevel]! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:49'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self defaultAALevel = nil		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self defaultAALevel = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self defaultAALevel = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingMore	self defaultAALevel: 4.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOff	self defaultAALevel: nil.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOn	self defaultAALevel: 2.	self changed! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/16/1998 02:56'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player grabbedPoint |	player _ self flashPlayer.	player ifNotNil:[		player noticeRemovalOf: self.		grabbedPoint _ self pointFromWorld: aHand position.		self transform: (self transformFrom: player owner).		self position: grabbedPoint.	].! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/16/1998 02:53'!justDroppedInto: newOwner event: evt	super justDroppedInto: newOwner event: evt.	self computeBounds.! !!FlashMorph methodsFor: 'printing' stamp: 'ar 11/13/1998 20:40'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$[;		print: self depth;		space.	self visible 		ifTrue:[aStream nextPutAll:'visible']		ifFalse:[aStream nextPutAll:'invisible'].	aStream		nextPut:$];		cr.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 15:45'!initialize	super initialize.	vData _ FlashKeyframes new.	mData _ FlashKeyframes new.	dData _ FlashKeyframes new.	cmData _ FlashKeyframes new.	frame _ 1.	self matrix: MatrixTransform2x3 identity atFrame: 0.	self visible: false atFrame: 0.	self depth: 0 atFrame: 0.	self visible: true.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:27'!loadInitialFrame	"Force the transformations taking place in the first frame."	self visible: (self visibleAtFrame: 1).! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:41'!reset	self removeAllKeyFrameData.! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/13/1998 13:40'!activationKeys	"Return the keyframes on which the receiver morph becomes visible"	^self visibleData keys select:[:key| self visibleAtFrame: key]! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 10/3/1998 21:39'!depth	^self depthAtFrame: frame! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id	^id! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id: aNumber	id _ aNumber! !!FlashCharacterMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^true! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:19'!colorMatrix: aMatrixTransform atFrame: frameNumber	self colorMatrixData at: frameNumber put: aMatrixTransform! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!colorMatrixAtFrame: frameNumber	^self colorMatrixData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!colorMatrixData	^cmData	"^self keyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depth: aNumber atFrame: frameNumber	self depthData at: frameNumber put: aNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depthAtFrame: frameNumber	^self depthData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!depthData	^dData	"^self keyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:11'!matrix: aMatrixTransform atFrame: frameNumber	"self position: aMatrixTransform offset atFrame: frameNumber."	self matrixData at: frameNumber put: aMatrixTransform.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!matrixAtFrame: frameNumber	^(self matrixData at: frameNumber) "copy offset: (self positionAtFrame: frameNumber)"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!matrixData	^mData	"^self keyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!removeAllKeyFrameData	"Remove all of the keyframe data associated with this morph"	self removeColorMatrixData.	self removeDepthData.	self removeMatrixData.	self removeVisibleData.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeColorMatrixData	cmData _ FlashKeyframes new.	"^self removeKeyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeDepthData	dData _ FlashKeyframes new.	"^self removeKeyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeMatrixData	mData _ FlashKeyframes new.	"^self removeKeyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeVisibleData	vData _ FlashKeyframes new.	"^self removeKeyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:13'!visible: aBool atFrame: frameNumber	^self visibleData at: frameNumber put: aBool! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:23'!visibleAtFrame: frameNumber	^self visibleData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!visibleData	^vData	"^self keyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:17'!stepTime	^stepTime ifNil:[super stepTime]! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:18'!stepTime: aNumber	stepTime _ aNumber! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/15/1998 16:56'!stepToFrame: frameNumber	| m wasVisible isVisible noTransform |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		noTransform _ m = transform.		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:03'!stepToNextFrame	self stepToFrame: frame + 1.! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/13/1998 14:02'!wantsSteps	^false	"^stepTime notNil"! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 8/14/1998 20:03'!keyframeData: aSymbol	| data |	data _ self valueOfProperty: aSymbol.	data isNil ifFalse:[^data].	data _ FlashKeyframes new.	self setProperty: aSymbol toValue: data.	^data! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 9/20/1998 23:41'!removeKeyframeData: aSymbol	self removeProperty: aSymbol.! !!FlashCharacterMorph methodsFor: 'printing' stamp: 'ar 11/15/1998 15:44'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:'(renderTime = '; print: renderTime;		"nextPutAll:' complexity = '; print: self complexity * bounds area // 1000 / 1000.0;"		"nextPutAll:' size = '; print: bounds area;"	 nextPutAll:')'.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 11/15/1998 17:12'!defaultLook: aMorph	"Assign the default look"	default _ aMorph.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 10/15/1998 21:13'!overLook: aMorph	"Assign the look if the mouse if over"	over _ aMorph.	self addMorph: aMorph.	aMorph visible: false.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 10/15/1998 21:13'!pressLook: aMorph	"Assign the look if the mouse is pressed"	press _ aMorph.	self addMorph: aMorph.	aMorph visible: false.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 11/16/1998 02:08'!sensitiveLook: aMorph	"Assign the look for the sensitive area."	sensitive _ aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 10/15/1998 20:59'!initialize	super initialize.	menuFlag _ false.! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 21:16'!addSound: aSound forState: state	sounds ifNil:[sounds _ Dictionary new].	sounds at: state put: aSound.! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 20:59'!trackAsMenu: aBoolean	menuFlag _ aBoolean.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:06'!handlesMouseDown: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:07'!handlesMouseOver: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:07'!handlesMouseOverDragging: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseDown: evt	self changed.	default visible: false.	over ifNotNil:[over visible: false].	press ifNotNil:[press visible: true].	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseEnter: evt	self changed.	default visible: false.	press ifNotNil:[press visible: false].	over ifNotNil:[over visible: true].	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 01:47'!mouseLeave: evt	self changed.	over ifNotNil:[over visible: false].	press ifNotNil:[press visible: false].	default visible: true.	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:08'!mouseMove: evt! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseUp: evt	| rcvr msg arg |	self changed.	default visible: false.	press ifNotNil:[press visible: false].	over ifNotNil:[over visible: true].	self layoutChanged.	(events at: #mouseUp ifAbsent:[#()]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:05'!on: eventName send: selector to: recipient withValue: value	"Note: We handle more than the standard Morphic events here"	| actionList |	events ifNil:[events _ Dictionary new].	actionList _ events at: eventName ifAbsent:[#()].	actionList _ actionList copyWith: (Array with: recipient with: selector with: value).	events at: eventName put: actionList.! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 02:08'!containsPoint: aPoint	| localPt |	sensitive ifNil:[^super containsPoint: aPoint].	localPt _ self transform globalPointToLocal: aPoint.	^sensitive bounds containsPoint: localPt! !!FlashButtonMorph methodsFor: 'changing' stamp: 'ar 11/16/1998 01:48'!layoutChanged	super layoutChanged.	self computeBounds.	self changed.! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:17'!color: aColor	super color: aColor.	submorphs do:[:m| m color: aColor].! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel	^4! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 02:30'!initialize	super initialize.	color _ Color white.	borderColor _ Color black.	borderWidth _ 2.	frameNumber _ 1.	frames _ 100.	sounds _ Dictionary new.	actions _ Dictionary new.	self syncFrames: false.	self loopFrames: true.	stepTime _ 1.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/13/1998 13:54'!loadInitialFrame	activationKeys _ self collectActivationKeys.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/6/1998 23:55'!makeControls	| b r syncSwitch loopSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2.	r _ AlignmentMorph newRow.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	r addMorphBack: (b fullCopy label: 'Next';			actionSelector: #stepForward).	r addMorphBack: (b fullCopy label: 'Prev';			actionSelector: #stepBackward).	syncSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Sync';		actionSelector: #syncFrames:;		target: self;		setSwitchState: false.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Loop';		actionSelector: #loopFrames:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'cache';		actionSelector: #enableCache:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	r addMorphBack: syncSwitch.	r addMorphBack: (b fullCopy label: 'Fastest'; 	actionSelector: #drawFastest).	r addMorphBack: (b fullCopy label: 'Medium';	actionSelector: #drawMedium).	r addMorphBack: (b fullCopy label: 'Nicest';		actionSelector: #drawNicest).	r addMorphBack: (b fullCopy label: '+10';		actionSelector: #jump10).	b target: self.	^ self world activeHand attachMorph: r! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 01:35'!aaLevel	^aaLevel ifNil:[2]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/14/1998 23:44'!aaLevel: aNumber	aaLevel _ aNumber min: 4 max: 1.	submorphs do:[:m|		m releaseCachedState.	].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:18'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:31'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:42'!addSound: aSound at: frameNr	| oldSound newSound |	oldSound _ sounds at: frameNr ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frameNr put: newSound.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:59'!frames	^frames! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:59'!frames: aNumber	frames _ aNumber! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 00:56'!localBounds	^localBounds ifNil:[localBounds _ self transform globalBoundsToLocal: self bounds]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:33'!localBounds: newBounds	bounds _ (newBounds origin // 20 corner: newBounds corner // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:51'!loopFrames: aBoolean	self setProperty: #loopFrames toValue: aBoolean! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:51'!syncFrames: aBoolean	self setProperty: #syncFrames toValue: aBoolean! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:05'!canvasForSubmorphs: canvasForMe	^(canvasForMe copyClipRect: (self bounds insetBy: borderWidth))		asBalloonCanvas transformBy: self transform; aaLevel: self aaLevel! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawFastest	self aaLevel: 1.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawMedium	self aaLevel: 2.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawNicest	self aaLevel: 4.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:05'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor box |	box _ self bounds.	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: box color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: box			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: box			fillColor: color			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: box		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:10'!fullDrawOn: aCanvas	"Overridden to only the draw the currently active morphs"	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	activeMorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 20:30'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 01:06'!computeBounds	"Do nothing."! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 16:07'!fullBounds	"The player clips its children"	^bounds! !!FlashPlayerMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:05'!isFlashPlayer	^true! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 01:29'!frameNumber: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/6/1998 23:56'!jump10	1 to: 10 do:[:i| self stepForward].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 10/15/1998 02:45'!pause	self stopStepping.	SoundPlayer shutDown.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:54'!rewind	self frameNumber: 1.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:24'!step	self stepForward.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:59'!stepBackward	frameNumber > 1		ifTrue:[self frameNumber: frameNumber - 1]		ifFalse:[self frameNumber: frames].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 10/12/1998 23:54'!stepForward	frameNumber < frames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[(self valueOfProperty:#loopFrames) == true ifTrue:[self frameNumber: 1]].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:25'!stepTime	^stepTime! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:25'!stepTime: delta	stepTime _ delta! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/13/1998 16:31'!stepToFrameForward: frame	| activeRemoved resortNeeded morph |	frameNumber+1 to: frame do:[:f|		activeRemoved _ false.		resortNeeded _ false.		1 to: activeMorphs size do:[:i|			morph _ activeMorphs at: i.			morph stepToFrame: f.			morph visible ifFalse:[activeRemoved _ true].			(i > 1 and:[(activeMorphs at: i-1) depth < morph depth])				ifTrue:[resortNeeded _ true].		].		activeRemoved ifTrue:[			activeMorphs _ activeMorphs select:[:m| m visible].			resortNeeded _ false.		].		resortNeeded ifTrue:[activeMorphs reSort].		(activationKeys at: f) do:[:m|			m stepToFrame: f.			m visible ifTrue:[activeMorphs add: m].		].	].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:17'!wantsSteps	^true! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/13/1998 13:41'!collectActivationKeys	| vis |	vis _ Array new: frames.	vis atAllPut: #().	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m activationKeys do:[:key|				vis at: key put: ((vis at: key) copyWith: m)			].		].	].	^vis! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/16/1998 02:58'!noticeRemovalOf: aFlashMorph	"The flash morph is removed from the player.	Remove it's activation keys so that we don't have any problems."	| morphs |	aFlashMorph activationKeys do:[:key|		morphs _ activationKeys at: key.		activationKeys at: key put: (morphs copyWithout: aFlashMorph).	].	"And remove it from the activeMorphs"	activeMorphs remove: aFlashMorph ifAbsent:[]! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 10/15/1998 23:20'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'make controls' action: #makeControls.	aCustomMenu addLine.	aCustomMenu add: 'Low Quality' action: #drawFastest.	aCustomMenu add: 'Med Quality' action: #drawMedium.	aCustomMenu add: 'High Quality' action: #drawNicest.	"aCustomMenu add: 'make slider' action: #makeSlider."	aCustomMenu addLine.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:29'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	self halt.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/16/1998 01:55'!executeActions: actionList	actionList do:[:msg| msg sentTo: self].! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:24'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:21'!gotoFrame: frame	"Jump to the given frame"		self frameNumber: frame.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:31'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:26'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:26'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:21'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet.	Ignored for the moment."! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/16/1998 02:23'!play	"Start playing from the current frame"	self startStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:27'!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:28'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:27'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:19'!color: aColor	| fillStyle |	color _ aColor.	fillStyle _ SolidFillStyle color: aColor.	shape _ shape copyAndCollectFills:[:fill| fillStyle]! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 15:31'!shape	^shape! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 16:43'!shape: newShape	shape _ newShape.	self computeBounds.! !!FlashShapeMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:30'!drawOn: aCanvas 	"Display the receiver."	shape ifNil:[^aCanvas frameRectangle: self bounds color: Color black.].	aCanvas asBalloonCanvas drawCompressedShape: shape.! !!FlashShapeMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 01:01'!computeBounds	bounds _ shape bounds.	fullBounds _ nil.! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit _ position _ 0.! !FlashFileReader initialize!FlashFileWriter initialize!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:07:30 am'!!DynamicInterpreter class methodsFor: 'translation' stamp: 'ar 11/15/1998 23:58' prior: 35800095!translate: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: false.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: false.		Smalltalk beep]"	self	translate: fileName		doInlining: inlineFlag		doAssertions: assertionFlag		fromClasses: (OrderedCollection new				add: BitBltSimulation;				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;				add: FFTPlugin;				add: FloatArrayPlugin;				add: Matrix2x3Plugin;				add: BalloonEngineBase;				add: BalloonEnginePlugin;			yourself)! !!FileList methodsFor: 'file list menu' stamp: 'ar 11/15/1998 23:57' prior: 33958478!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!Interpreter class methodsFor: 'translation' stamp: 'ar 11/15/1998 23:56' prior: 35820665!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin. Matrix2x3Plugin. 	BalloonEngineBase. BalloonEnginePlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 8:57:32 am'!"Change Set:		MondayMiscellany-swDate:			16 November 1998Author:			Scott Wallace*  Morph methods suspendEventHandler and restoreEventHandler now pass their messages on to their submorphs; this fixes the problem of piano keyboards in a parts bin being reactive to drag-over, and precludes similiar arcane problems arising in future.  These methods are specific to the creation of parts bins.*  If you save a custom parts bin whose window title is still Standard Parts, it's transformed to be Custom Parts.*  If you've never defined a custom parts bin, then the attempt to launch one results in an informative message.*  The bug wherein an extra parts bin is launched the first time you request a custom parts bin is fixed.*  Restore lightOrange as the characteristic color of Morphic Projects.*  The thumbnailing algorithm in MorphThumbnail now enforces a maximum thumbnail width, so that, for example, the piano keyboard's thumbnail won't be unconscionably wide.  Refer to the comment in MorphThumbnail.computeThumbnail, and look at Morph method #representativeNoTallerThan:norWiderThan:thumbnailHeight: and its senders to learn how to set this up -- you can twiddle the parameters relating to thumbnail computation with a bit of effort.*  Removes (for the moment) make-alias from the red-dot halo menu.*  Also removes the open-viewer item from that menu; use the cyan halo for this function.*  Changes the wording of the name-me item in the morph meta-menu to read 'set variable name...', to reduce confusion with the formal-object-naming feature that relates to the name visible and editible in an object's halo which is central to the scripting regime, and which is quite different from the set-variable-name thing used by Components and which results in addition of instance variables to a MorphicModel, etc."!!Morph methodsFor: 'thumbnail' stamp: 'sw 11/13/1998 09:45'!representativeNoTallerThan: maxHeight norWiderThan: maxWidth thumbnailHeight: thumbnailHeight	"Return a morph representing the receiver but which is no taller than aHeight.  If the receiver is already small enough, just return it, else return a MorphThumbnail companioned to the receiver, enforcing the maxWidth"	(self height <= maxHeight and: [self width <= maxWidth]) ifTrue: [^ self].	^ MorphThumbnail new extent: maxWidth @ thumbnailHeight; morphRepresented: self! !!Morph methodsFor: 'event handling' stamp: 'sw 11/16/1998 08:06' prior: 19980329!restoreSuspendedEventHandler	| savedHandler |	(savedHandler _ self valueOfProperty: #suspendedEventHandler) ifNotNil:		[self eventHandler: savedHandler].	submorphs do: [:m | m restoreSuspendedEventHandler]! !!Morph methodsFor: 'event handling' stamp: 'sw 11/16/1998 08:07' prior: 34686625!suspendEventHandler	self eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: self eventHandler.		self eventHandler: nil].	submorphs do: [:m | m suspendEventHandler].  "All those rectangles"! !!Morph methodsFor: 'menus' stamp: 'sw 11/16/1998 08:13' prior: 34691865!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	"aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument]."	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/16/1998 08:22' prior: 35974861!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorph].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 11/13/1998 09:53' prior: 34721373!computeThumbnail	"Assumption on entry:       The receiver's width represents the maximum width allowable.       The receiver's height represents the exact height desired."	| f scaleX scaleY |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scaleY _ self height / f height.  "keep height invariant"	scaleX _ ((morphRepresented width * scaleY) <= self width)		ifTrue:			[scaleY]  "the usual case; same scale factor, to preserve aspect ratio"		ifFalse:			[self width / f width].	self form: (f magnify: f boundingBox by: (scaleX @ scaleY) smoothing: 2).	self extent: originalForm extent! !!MouseDownMorph methodsFor: 'menu' stamp: 'sw 11/16/1998 08:22' prior: 20022393!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph."template..."	aCustomMenu addLine.	aCustomMenu add: 'set variable name...' action: #renameMe.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model slot' action: #plugMouseDownToSlot.	aCustomMenu add: 'plug mouseMove to model slot' action: #plugMouseMoveToSlot.	aCustomMenu add: 'plug all to model slots' action: #plugAllToSlots.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model' action: #plugMouseDownToModel.	aCustomMenu add: 'plug mouseMove to model' action: #plugMouseMoveToModel.	aCustomMenu add: 'plug all to model' action: #plugAllToModel.	aCustomMenu addLine.	aCustomMenu add: 'set target...' action: #setTarget.	aCustomMenu add: 'set mouseDown selector...' action: #setMouseDownSelector.	aCustomMenu add: 'set mouseMove selector...' action: #setMouseMoveSelector.	aCustomMenu add: 'set mouseUp selector...' action: #setMouseUpSelector.! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/12/1998 17:46' prior: 36223400!saveAsCustomPartsBin	| aBin |	self closeEditing.	labelString = 'Standard Parts' ifTrue: [self setLabel: 'Custom Parts'].	aBin _ self veryDeepCopy.	ScriptingSystem setCustomPartsBinFrom: aBin.	self inform: 'Okay; from now on, when you request''custom parts bin'' from the ''authoring tools...''menu, you will obtain a copy of this parts bin'! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 11/13/1998 09:54' prior: 36116250!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing norWiderThan: self maximumThumbnailWidth thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 11/12/1998 18:01' prior: 34811448!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy restoreSuspendedEventHandler ]].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 11/13/1998 09:55' prior: 35875926!replaceTallSubmorphsByThumbnails	|  itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails _ self maximumThumbnailWidth.	self submorphs do:		[:aMorph |			itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[self replaceSubmorph: aMorph by: itsThumbnail]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 11/13/1998 09:56' prior: 35876475!updateSubmorphThumbnails	| thumbsUp itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	thumbsUp _ self alwaysShowThumbnail.	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails _ self maximumThumbnailWidth.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 11/13/1998 10:06'!maximumThumbnailWidth	^ self valueOfProperty: #maximumThumbnailWidth ifAbsent: [200 min: (self width - 10)]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/16/1998 08:49' prior: 36161529!launchCustomPartsBin	| aBin |	(aBin _ ScriptingSystem customPartsBin) ifNotNil:		[associatedMorph primaryHand attachMorph: aBin]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/13/1998 10:03' prior: 36161718!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new extent:  361@175.	aPage color: Color white; padding: 6.	aPage autoLineLayout: true.	aPage isPartsBin: true; openToDragNDrop: false.	aPage setProperty: #alwaysShowThumbnail toValue: true.	^ aPage! !!Project methodsFor: 'initialization' stamp: 'sw 11/12/1998 14:29' prior: 36170286!backgroundColorForMorphicProject	^ Color lightOrange! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 11/16/1998 08:50' prior: 36202391!customPartsBin	CustomPartsBin ifNil:		[self inform: 'There is no custom parts bin yet.To create one, start with a Standard Parts Bin, and modify it as you wish, and then choose''Save as Custom Parts Bin'' from theparts-window-controls menu, whichwill be found in the halo menu ofany parts-bin window'.	^ nil].	^ CustomPartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 11/16/1998 08:47' prior: 36203229!setCustomPartsBinFrom: aMorph	"Establish aMorph as the custom parts bin.  Normally triggered by use menu action, but can also be used to reset the custom parts bin to undefined"	CustomPartsBin _ aMorph	"ScriptingSystem setCustomPartsBinFrom: nil"! !Morph removeSelector: #representativeNoTallerThan:thumbnailHeight:!Morph removeSelector: #representativeNoTallerThan:thumbnailHeight:!MorphThumbnail removeSelector: #thumbnailOfHeight:!MorphThumbnail removeSelector: #thumbnailOfHeight:!StandardScriptingSystem removeSelector: #initializeCustomPartsBin!StandardScriptingSystem removeSelector: #initializeCustomPartsBin!"Postscript:"ScriptingSystem resetStandardPartsBin.ScriptingSystem newStandardPartsBin.!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 10:14:39 pm'!!BookMorph methodsFor: 'navigation' stamp: 'di 11/16/1998 22:14' prior: 36089008!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage fullReleaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 11:31:31 pm'!"Change Set:		StringSearch-diDate:			15 November 1998Author:			Dan IngallsThis changeSet introduces a new primitive...<String> findSubstring: key in: body startingAt: start matchTable: matchTable	<primitive: 246>	Answer the index in the string body at which the substring key first occurs,	at or beyond start.  The match is determined using matchTable, which can be	used to effect, eg, case-insensitive matches.	If no match is found, zero will be returned.In addition, a number of other implementations of the same function are replaced, to wit:<String> findInsensitive: subStringLowercase allUpper:<String> findString: subString startingAt: start, and<String> includesSubstring: aString caseSensitive: caseSensitive.Also, endsWith:, beginsWith:, and match have been rewritten to take advantage of this considerably faster method."!!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 11/16/1998 21:59' prior: 35690927!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 findSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 11/16/1998 22:00' prior: 35700122!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 findSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'di 11/15/1998 16:22' prior: 34308854!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(String findSubstring:in:startingAt:matchTable:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43' prior: 21600776!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^ self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:45'!findString: key startingAt: start caseSensitive: caseSensitive	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."	caseSensitive	ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]	ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:53' prior: 21632009!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'di 11/16/1998 10:00'!indexOf: aCharacter	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: 1! !!String methodsFor: 'accessing' stamp: 'di 11/16/1998 10:00'!indexOf: aCharacter  startingAt: start	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 17:02'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index _ self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25' prior: 21607951!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25' prior: 21611517!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra _ self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'di 11/16/1998 12:23' prior: 21612228!match: text 	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains *, text may contain any sequence of characters.	The most general match supported is 'foo*bar*zort'."	| i1 i2 ii |	self size = 0 ifTrue: [self error: 'invalid pattern'].	"Look for the first * ..."	i1 _ self indexOf: $*.	i1 = 0 ifTrue: [^ self sameAs: text "Simple match of 'foo' (case-insensitive)"].	i1 > 1 ifTrue:		["Pattern begins with 'foo*'"		(text findString: (self copyFrom: 1 to: i1-1)				startingAt: 1 caseSensitive: false) = 1 ifFalse:			[^ false "text does not begin with 'foo'"].		i1 = self size ifTrue:			[^ true "match of 'foo*' successful"]].	"At this point we know that there is a * at i1, and that,		if it was preceded by 'foo', then the text also begins with 'foo'."	"Look for the second * ..."	i1 = self size ifTrue:		[^ true "Trivial match of '*' always succeeds"].	i2 _ self indexOf: $* startingAt: i1+1.	i2 = 0 ifTrue:		["There is no second * -- match any trailing characters"		^ (text findString: (self copyFrom: i1+1 to: self size)				startingAt: text size - (self size-i1) + 1 caseSensitive: false) > 0].	i2 < self size ifTrue:		["If * not at end, then match any trailing characters, 'zort'."		(text findString: (self copyFrom: i2+1 to: self size)				startingAt: text size - (self size-i2) + 1 caseSensitive: false) > 0 ifFalse:			[^ false "Trailing characters did not match"]].	"At this point all leading and trailing character have been matched."	i2 > (i1+1) ifFalse:		[^ true "Case of degenerate 'baz'"].	"Now match '*baz*' -- just a findStr"	ii _ text findString: (self copyFrom: i1+1 to: i2-1)			startingAt: i1 caseSensitive: false.	"But do not count a hit that overlaps zort"	^ ii > 0 and: [ii <= (text size - (self size-i2) + 1 - (i2-i1-1))]" Examples: 	'*'		match: 'zort' true	'*baz'	match: 'mobaz' true	'*baz'	match: 'mobazo' false	'*baz*'	match: 'mobazo' true	'*baz*'	match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'	match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false"! !!String methodsFor: 'system primitives' stamp: 'di 11/15/1998 16:27'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 246>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!Symbol class methodsFor: 'access' stamp: 'di 11/15/1998 16:46' prior: 35260037!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive."	| size table candidate selectorList selectorTable ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^ selectorList].	aString size = 1 ifTrue:		[ascii _ aString first asciiValue.		ascii < 128 ifTrue:			[selectorList add: (SingleCharSymbols at: ascii + 1)]].	aString first isLetter ifFalse: [^ selectorList].	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate findString: aString startingAt: 1 caseSensitive: false) > 0) ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon' "! !String removeSelector: #findInsensitive:allUpper:!String removeSelector: #findInsensitive:allUpper:!'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 8:57:52 pm'!"Change Set:		VMcoercionsDate:			8 November 1998Author:			Dan IngallsThis changeSet introduces internal Integer/Float conversions for common arithmetic operations and comparisons.  In particular, if a Float and SmallInteger are combined with any of #(+ - * / > >= = <= <), the integer will be converted to a float and the result returned without ever causing a primitive failure and thus without triggering any of the external type coercion code.In the process these methods have been refactored so that they are smaller, and so that, except for a couple of utility routines, InterpreterSimulator can inherit code for all these methods, rather than having to override them as before.NOTE:  None of this has yet been proagated to DynamicInterpreter or DynamicInterpreterSimulator."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FloatProto FreeSizeMask GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!Interpreter methodsFor: 'utilities' stamp: 'jm 11/16/1998 17:27'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	self returnTypeC: 'double'.	(self isIntegerObject: floatOrInt) ifTrue:		[^ self cCode: '((double) (floatOrInt >> 1))'].	self assertClassOf: floatOrInt is: (self splObj: ClassFloat).	successFlag ifTrue:		[^ self floatValueOf: floatOrInt].! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/16/1998 20:49' prior: 19216863!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self longAt: (localSP _ localSP - 4)							put: (self integerObjectOf: result).					^ nil "success"].				self externalizeIPandSP.				successFlag _ false]		ifFalse: [self externalizeIPandSP.				self primitiveFloatAdd].	successFlag		ifFalse: [successFlag _ true.				self primitiveAdd].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/16/1998 20:51' prior: 19220551!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue:					[result _ rcvr // arg.  "generates C / operation"					(self isIntegerValue: result) ifTrue:						[self longAt: (localSP _ localSP - 4)								put: (self integerObjectOf: result).						^ nil "success"]].				self externalizeIPandSP.				successFlag _ false]		ifFalse: [self externalizeIPandSP.				successFlag _ true.				self primitiveFloatDivide].	successFlag		ifFalse: [successFlag _ true.				self primitiveDivide].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/16/1998 20:52' prior: 19224066!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				result _ rcvr * arg.				((arg = 0 or: [(result // arg) = rcvr])					and: [self isIntegerValue: result]) ifTrue:					[self longAt: (localSP _ localSP - 4)							put: (self integerObjectOf: result).					^ nil "success"].				self externalizeIPandSP.				successFlag _ false]		ifFalse: [self externalizeIPandSP.				successFlag _ true.				self primitiveFloatMultiply].	successFlag		ifFalse: [successFlag _ true.				self primitiveMultiply].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/16/1998 20:52' prior: 19226513!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self longAt: (localSP _ localSP - 4)							put: (self integerObjectOf: result).					^ nil "success"].				self externalizeIPandSP.				successFlag _ false]		ifFalse: [self externalizeIPandSP.				successFlag _ true.				self primitiveFloatSubtract].	successFlag		ifFalse: [successFlag _ true.				self primitiveSubtract].	self internalizeIPandSP.! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/16/1998 20:55' prior: 19242184!primitiveFloatAdd	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr + arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/16/1998 20:56' prior: 19242816!primitiveFloatDivide	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr // arg)  "generates C / operation"]].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:09' prior: 19243536!primitiveFloatEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr = arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:10' prior: 19243997!primitiveFloatGreaterOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr >= arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:10' prior: 19244468!primitiveFloatGreaterThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr > arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:11' prior: 19244935!primitiveFloatLessOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr <= arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:11' prior: 19245403!primitiveFloatLessThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr < arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/16/1998 20:56' prior: 19245867!primitiveFloatMultiply	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr * arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:12' prior: 19246504!primitiveFloatNotEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushBool: rcvr ~= arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/16/1998 20:56' prior: 19246969!primitiveFloatSubtract	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr - arg)].! !!Interpreter methodsFor: 'plugin support' stamp: 'di 11/16/1998 20:55' prior: 35744124!floatObjectOf: aFloat	| resultOop |	self var: #aFloat declareC: 'double aFloat'.	resultOop _ self clone: (self splObj: FloatProto).	self storeFloatAt: resultOop + BaseHeaderSize from: aFloat.	^ resultOop.! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:46' prior: 19422172!floatValueOf: objectPointer	| float len long0 long1 |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	len = 2		ifFalse: [self success: false.  ^0.0].	"Make up a Float from the bits"	long0 _ self fetchWord: 0 ofObject: objectPointer.	long1 _ self fetchWord: 1 ofObject: objectPointer.	float _ Float new: 2.  "No conversion needed for Squeak"	float at: 1 put: long0.	float at: 2 put: long1.	^ float! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/8/1998 10:47'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	(self isIntegerObject: floatOrInt) ifTrue: [^ (self integerValueOf: floatOrInt) asFloat].	self assertClassOf: floatOrInt is: (self splObj: ClassFloat).	successFlag ifTrue: [^ self floatValueOf: floatOrInt]! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/16/1998 20:56' prior: 19425759!primitiveFloatDivide	"NOTE: This method had to be overridden due to the use of // in super"	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr / arg)  " / overrides // "]].! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 11/8/1998 13:04'!primStringindexOfAsciiinStringstartingAt	^ self primitiveFail! !!ObjectMemory class methodsFor: 'initialization' stamp: 'jm 11/16/1998 18:36' prior: 35620493!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	FloatProto _ 31.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.! !Interpreter removeSelector: #makeFloatWithValue:!Interpreter removeSelector: #assertFloat:and:!Interpreter removeSelector: #assertFloat:and:!InterpreterSimulator removeSelector: #primitiveFloatAdd!InterpreterSimulator removeSelector: #primitiveFloatAdd!InterpreterSimulator removeSelector: #primitiveFloatLessThan!InterpreterSimulator removeSelector: #primitiveFloatLessThan!InterpreterSimulator removeSelector: #primitiveFloatGreaterOrEqual!InterpreterSimulator removeSelector: #primitiveFloatGreaterOrEqual!InterpreterSimulator removeSelector: #primitiveFloatNotEqual!InterpreterSimulator removeSelector: #primitiveFloatNotEqual!InterpreterSimulator removeSelector: #primitiveFloatLessOrEqual!InterpreterSimulator removeSelector: #primitiveFloatLessOrEqual!InterpreterSimulator removeSelector: #primitiveFloatSubtract!InterpreterSimulator removeSelector: #primitiveFloatSubtract!InterpreterSimulator removeSelector: #cloneOf:withFloatValue:!InterpreterSimulator removeSelector: #primitiveFloatMultiply!InterpreterSimulator removeSelector: #primitiveFloatMultiply!InterpreterSimulator removeSelector: #primitiveFloatEqual!InterpreterSimulator removeSelector: #primitiveFloatEqual!InterpreterSimulator removeSelector: #primitiveFloatGreaterThan!InterpreterSimulator removeSelector: #primitiveFloatGreaterThan!'From Squeak 2.2 of Sept 23, 1998 on 17 November 1998 at 7:47:14 pm'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'menuFlag events sounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player spriteOwners stepTime frame activeMorphs passiveMorphs activeFont textOffset textPosition textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Model subclass: #FlashPlayerModel	instanceVariableNames: 'player '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!SystemWindow subclass: #FlashPlayerWindow	instanceVariableNames: 'startButton stopButton '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashSpriteMorph	instanceVariableNames: 'frames frameNumber stepTime damageRecorder sounds actions labels '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/17/1998 18:41'!fullDamageRect	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/17/1998 00:35' prior: 36858993!processShapeRecordFrom: data	| flags pt lineInfo fillInfo0 fillInfo1 |	data nextBitFlag ifTrue:["Boundary edge record"		data nextBitFlag			ifTrue:[self processLineRecordFrom: data]			ifFalse:[self processCurveRecordFrom: data].		^true].	flags _ data nextBits: 5.	flags = 0 ifTrue:[^false]. "At end of shape"	(flags anyMask: 1) ifTrue:["move to"		pt _ data nextPoint.		self recordMoveTo: pt.		log ifNotNil:[log crtab; nextPutAll:'MoveTo '; print: pt]].	(flags anyMask: 2) ifTrue:["fill info 0"		fillInfo0 _ data nextBits: nFillBits.		self recordFillStyle0: fillInfo0.		log ifNotNil:[log crtab; nextPutAll:'FillInfo0 '; print: fillInfo0]].	(flags anyMask: 4) ifTrue:["fill info 1"		fillInfo1 _ data nextBits: nFillBits.		self recordFillStyle1: fillInfo1.		log ifNotNil:[log crtab; nextPutAll:'FillInfo1 '; print: fillInfo1]].	(flags anyMask: 8) ifTrue:["line info"		lineInfo _ data nextBits: nLineBits.		self recordLineStyle: lineInfo.		log ifNotNil:[log crtab; nextPutAll:'LineInfo '; print: lineInfo]].	(flags anyMask: 16) ifTrue:["new styles"		self recordEndSubshape.		log ifNotNil:[log crtab; nextPutAll:'New Set of styles '].		self processShapeStylesFrom: data.		"And reset info"		data initBits.		nFillBits _ data nextBits: 4.		nLineBits _ data nextBits: 4].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/17/1998 00:37' prior: 36860576!processShapesFrom: data	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 11/16/1998 15:30' prior: 36861621!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	"Experimental:It is an error in the spec. There can be up to 255 characters in run. Thehigh bit does not mean anything. The text record type 0 and type 1 is poorlydescribed. The real format is that all of the info in a 'text record type 1'is always followed by the info in a 'text record type 2'. Note the high bitof 'text record type 1' is reserved and should always be zero."	self processGlyphStateChange: flags from: data.	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self processGlyphEntries: flags from: data.	"Old stuff - which is according to the f**cking spec"	"(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	]."	^true! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 11/16/1998 15:33'!processButtonRecords: id from: data cxForm: haveCxForm	| flags state characterId layer matrix cxForm |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		haveCxForm ifTrue:[cxForm _ data nextColorMatrix].		self recordButton: id character: characterId state: state layer: layer matrix: matrix].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/17/1998 13:38' prior: 36864930!processActionGotoLabel: data	| length label |	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/17/1998 13:37' prior: 36866278!processActionSetTarget: data	| length target |	length _ data nextWord.	target _ data nextString.	log ifNotNil:[log nextPutAll:' target = '; print: target].	^Message selector: #actionTarget: argument: target.! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/17/1998 16:49' prior: 36867886!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| data buffers nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask sound k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) contents samplingRate: samplingRate.		sound setLoudness: 1.0.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsJPEG2: data	| id image decoder |	id _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsJPEG3: data	| id image decoder alphaOffset dataOffset |	id _ data nextWord.	"F**cking spec"	alphaOffset _ data nextWord.	dataOffset _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	"Note: We must read the zlib compressed alpha values here."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02' prior: 36871656!processDefineBitsLossless2: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02' prior: 36871931!processDefineBitsLossless: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 21:11' prior: 36872207!processDefineButton2: data	| id flags actions condition actionOffset |	data hasAlpha: true.	id _ data nextWord.	self recordDefineButton: id.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	actionOffset _ data nextWord. "F**cking spec"	self processButtonRecords: id from: data cxForm: true.	[actionOffset = 0] whileFalse:[		actionOffset _ data nextWord.		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 20:47' prior: 36872832!processDefineButton: data	| id actions |	id _ data nextWord.	self recordDefineButton: id.	self processButtonRecords: id from: data cxForm: false.	actions _ self processActionRecordsFrom: data.	self recordButton: id actions: actions.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 19:46'!processDefineMorphShape: data	"self halt."	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 17:18'!processDefineSprite: data	| id frameCount |	id _ data nextWord.	frameCount _ data nextWord. "F**cking spec"	self recordBeginSprite: id frames: frameCount.	[self processTagFrom: data] whileTrue.	self recordEndSprite: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 13:35' prior: 36875998!processFrameLabel: data	| label |	label _ data nextString.	self recordFrameLabel: label.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 19:10' prior: 36876564!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:11' prior: 36879035!processSoundStreamBlock: data	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:47'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:54'!recordBeginSprite: id frames: frameCount! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:55'!recordEndSprite: id! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36' prior: 36888354!recordFrameLabel: label	"Name the current frame with the given label"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 13:13'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/16/1998 15:44' prior: 36897768!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits).		transform gMul: (self nextSignedBits: nBits).		transform bMul: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits)]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits).		transform gAdd: (self nextSignedBits: nBits).		transform bAdd: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits)]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/17/1998 18:19' prior: 36898792!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a12: (self nextSignedBits: nBits) / 65536.0.		transform a21: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/17/1998 13:51' prior: 36909693!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	image _ Cursor wait showWhile:[self nextImage].	"(stream position + 2 < stream size) ifTrue:[self halt]."	^image! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:28' prior: 36937064!loadInitialFrame	self computeBounds.! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:41'!activationKeys	^#()! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:13'!delete	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	^super delete! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00' prior: 36937826!depth	^(self valueOfProperty: #depth) ifNil:[0]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00'!depth: d	d = 0		ifTrue:[self removeProperty: #depth]		ifFalse:[self setProperty: #depth toValue: d]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:40'!id	^-1! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 19:04'!debugDraw	| vis canvas m |	vis _ self visible.	self visible: true.	canvas _ BalloonCanvas on:Display.	m _ MatrixTransform2x3 withScale: 0.05.	m offset: (self fullBounds origin // 20) negated.	canvas transformBy: m.	self fullDrawOn: canvas.	self visible: vis.! !!FlashMorph methodsFor: 'printing' stamp: 'ar 11/16/1998 11:40' prior: 36940155!printOn: aStream	super printOn: aStream.	aStream		nextPut:$[;		print: self depth;		space.	self visible 		ifTrue:[aStream nextPutAll:'visible']		ifFalse:[aStream nextPutAll:'invisible'].	aStream		nextPutAll:' id = ';		print: self id;		nextPut:$];		cr.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 19:25' prior: 36940831!loadInitialFrame	"Force the transformations taking place in the first frame."	super loadInitialFrame.	self stepToFrame: 1.! !!FlashCharacterMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 17:52'!fullDrawOn: canvas	renderTime _ Time millisecondsToRun:[super fullDrawOn: canvas].! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33' prior: 36944917!stepToFrame: frameNumber	| m wasVisible isVisible noTransform |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		noTransform _ m = transform.		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04' prior: 36946691!defaultLook: aMorph	"Assign the default look"	aMorph setProperty: #defaultLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:26'!loadInitialFrame	"Resort our children"	super loadInitialFrame.	submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth].	self lookEnable: #(defaultLook) disable:#(sensitive overLook pressLook)! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25' prior: 36946852!overLook: aMorph	"Assign the look if the mouse if over"	aMorph setProperty: #overLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25' prior: 36947044!pressLook: aMorph	"Assign the look if the mouse is pressed"	aMorph setProperty: #pressLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04' prior: 36947241!sensitiveLook: aMorph	"Assign the look for the sensitive area."	aMorph setProperty: #sensitive toValue: true.	self addMorph: aMorph! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:25' prior: 36947831!handlesMouseDown: evt	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:25' prior: 36947949!handlesMouseOver: evt	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:24' prior: 36948067!handlesMouseOverDragging: evt	^false! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 17:23' prior: 36948193!mouseDown: evt	| rcvr msg arg |	self lookEnable: #(pressLook) disable:#().	events ifNil:[^self].	(events at: #mouseDown ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 18:24' prior: 36948426!mouseEnter: evt	| rcvr msg arg |	self lookEnable: #(overLook defaultLook) disable:#(pressLook).	events ifNil:[^self].	(events at: #mouseEnter ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:49' prior: 36948660!mouseLeave: evt	self lookEnable: #(defaultLook) disable:#(pressLook overLook).! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 17:23' prior: 36948989!mouseUp: evt	| rcvr msg arg |	self lookEnable:#(defaultLook overLook) disable:#(pressLook).	events ifNil:[^self].	(events at: #mouseUp ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:46' prior: 36949821!containsPoint: aPoint	| localPt |	(self bounds containsPoint: aPoint) ifFalse:[^false].	localPt _ self transform globalPointToLocal: aPoint.	submorphs do:[:m| 		((m valueOfProperty: #sensitive) ifNil:[false]) ifTrue:[			(m bounds containsPoint: localPt) ifTrue:[^true].		].	].	^false! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:09'!lookEnable: list1 disable: list2	self changed.	submorphs do:[:m|		list2 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: false].		].		list1 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: true].		].	].	self computeBounds.	self changed.! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^true! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:37' prior: 36916468!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	spriteOwners _ IdentityDictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/17/1998 18:06' prior: 36917506!processFile: aMorph	super processFile.	player loadInitialFrame.	"player stepForward.	player stepBackward."	aMorph ifNil:[		player play.		^player openInMVC].	aMorph isWorldMorph ifTrue:[		"aMorph world activeHand attachMorph: player."		player openInWorld.	] ifFalse:[		aMorph addMorph: player.	].	^player! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/17/1998 19:22' prior: 36919898!recordTextStart: id bounds: bounds matrix: matrix	textPosition _ textOffset _ bounds origin.	textMorph _ FlashTextMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.	"matrix ifNotNil:[textMorph transform: matrix]."! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"	self endShape.	self beginShape.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/16/1998 13:02' prior: 36923316!computeLineStyleLists	"Compute the line style index lists.	Each line style will be splitted into two parts, the width and the fill.	Then, the fills will be added to the fillStyles and the indexes will be adjusted.	Finally, we compute two arrays containing the width of each line and the	fill style of each line"	| widthList fillList indexMap oldIndex newIndex allFillStyles style |	allFillStyles _ Dictionary new.	fillStyles associationsDo:[:assoc| 		allFillStyles at: assoc key put: assoc value].	indexMap _ Dictionary new.	lineStyles associationsDo:[:assoc|		oldIndex _ assoc key.		style _ assoc value.		allFillStyles at: allFillStyles size+1 put: (SolidFillStyle color: style color).		newIndex _ allFillStyles size.		indexMap at: oldIndex put: newIndex.	].	widthList _ OrderedCollection new: lineStyles size.	fillList _ OrderedCollection new: lineStyles size.	lineStyleList contents do:[:index|		index = 0 ifTrue:[			widthList add: 0.			fillList add: 0.		] ifFalse:[			style _ lineStyles at: index ifAbsent:[FlashLineStyle color: Color black width: 20].			widthList add: style width.			fillList add: (indexMap at: index ifAbsent:[1]).		].	].	widthList _ widthList as: ShortRunArray.	fillList _ fillList as: ShortRunArray.	^Array with: allFillStyles with: fillList with: widthList! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 17:42'!recordBeginSprite: id frames: frameCount	| sprite |	sprite _ FlashSpriteMorph new.	sprite frames: frameCount.	sprite stepTime: stepTime.	spriteOwners at: sprite put: (		Array with: player 			with: frame			with: activeMorphs			with: passiveMorphs).	player _ sprite.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 18:36'!recordEndSprite: id	| shape sprite |	sprite _ player.	player _ (spriteOwners at: sprite) at: 1.	frame _ (spriteOwners at: sprite) at: 2.	activeMorphs _ (spriteOwners at: sprite) at: 3.	passiveMorphs _ (spriteOwners at: sprite) at: 4.	spriteOwners removeKey: sprite.	sprite loadInitialFrame.	shape _ FlashCharacterMorph withAll: (Array with: sprite).	shape id: id.	shape stepTime: stepTime.	shapes at: id put: shape.	shape lockChildren.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 22:53' prior: 36927345!recordFrameActions: actionList	player addActions: actionList atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36' prior: 36927495!recordFrameLabel: label	"Name the current frame with the given label"	player addLabel: label atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 18:10'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 22:54' prior: 36927957!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorMatrix: colorMatrix atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 21:54' prior: 36928947!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[#()]) do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	Transcript cr; nextPutAll:'Shape (id = '; print: id; nextPutAll:' depth = '; print: depth; nextPutAll:') not removed in frame '; print: frame; endEntry.	^nil! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 18:06' prior: 36929358!recordShowFrame	player frames: frame.	frame _ frame + 1.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:39'!myActiveMorphs	| out |	out _ WriteStream on: (Array new: 10).	activeMorphs do:[:array| out nextPutAll: array].	^out contents! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:26'!myFlush		Transcript endEntry.		Sensor leftShiftDown ifTrue:[self halt].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 17:45' prior: 36930087!newMorphFromShape: objectIndex	"Return a new character morph from the given object index.	If the character morph at objectIndex is already used, then create and return a full copy of it"	| prototype |	prototype _ self oldMorphFromShape: objectIndex.	prototype isNil ifTrue:[^nil].	^(prototype owner notNil) 		ifTrue:[prototype fullCopy]		ifFalse:[prototype].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 20:24' prior: 36930588!oldMorphFromShape: objectIndex	"Return an existing character morph from the given object index."	| prototype |	prototype _ shapes at: objectIndex ifAbsent:[nil].	"prototype ifNil:[prototype _ buttons at: objectIndex ifAbsent:[nil]]."	prototype ifNil:[Transcript cr; nextPutAll:'No shape for '; print: objectIndex; nextPutAll:' in frame '; print: frame; endEntry].	^prototype! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 21:55' prior: 36931049!removeActiveMorph: aMorph	| newActive newPassive |	aMorph visible: false atFrame: frame.	newActive _ (activeMorphs at: aMorph id) copyWithout: aMorph.	newPassive _ (passiveMorphs at: aMorph id ifAbsent:[#()]) copyWith: aMorph.	activeMorphs at: aMorph id put: newActive.	passiveMorphs at: aMorph id put: newPassive.	^aMorph! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:37' prior: 36931606!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self halt].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter send: #executeActions: to: player withValue: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 21:01' prior: 36932896!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	| button children shape |	button _ buttons at: buttonId ifAbsent:[^self halt].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[^nil].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape depth: layer.	shape transform: matrix.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36' prior: 36933667!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self halt].	theSound _ self createSound: id info: soundInfo.	theSound ifNil:[^self].	self halt.	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:51' prior: 36934032!recordButton: id trackAsMenu: aBoolean	| button |	button _ buttons at: id ifAbsent:[^self halt].	button trackAsMenu: aBoolean.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"	| button |	button _ buttons at: id put: FlashButtonMorph new.	button id: id.	shapes at: id put: button.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 21:11'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:47'!initialExtent	^player bounds extent! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!play	player play! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	player _ flashPlayer! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!stop	player stop! !!FlashPlayerModel class methodsFor: 'instance creation' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	^self new player: flashPlayer! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 19:21' prior: 36950463!initialize	super initialize.	color _ Color white.	borderColor _ Color black.	borderWidth _ 2.	frameNumber _ 1.	frames _ 100.	sounds _ Dictionary new.	actions _ Dictionary new.	self loopFrames: true.	stepTime _ 1.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 16:42' prior: 36950788!loadInitialFrame	super loadInitialFrame.	activationKeys _ self collectActivationKeys.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:39'!openInMVC	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInMVCExtent: extent! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:24'!openInWorld	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInWorldExtent: extent! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 22:53' prior: 36952891!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 20:30' prior: 36953083!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame+1.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 23:48'!addMorph: aMorph	aMorph isFlashMorph ifFalse:[^super addMorph: aMorph].	aMorph isFlashButton		ifTrue:[self addMorphFront: aMorph]		ifFalse:[self addMorphBack: aMorph].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 20:31' prior: 36953272!addSound: aSound at: frame	| oldSound newSound |	oldSound _ sounds at: frame+1 ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frame+1 put: newSound.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:21'!borderWidth	^borderWidth! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:21'!borderWidth: bw	borderWidth _ bw.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:00' prior: 36953960!localBounds: newBounds	localBounds _ newBounds.	bounds _ (newBounds origin // 20 corner: newBounds corner // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 02:38'!debugDraw	self fullDrawOn: (FormCanvas on: Display)! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 19:08' prior: 36956157!fullDrawOn: aCanvas	"Overridden to only the draw the currently active morphs"	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	activeMorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  	"aCanvas frameRectangle: aCanvas clipRect color: Color white."! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 15:32'!boundsChangedFrom: oldBounds to: newBounds	transform _ MatrixTransform2x3					transformFromLocal: localBounds					toGlobal: newBounds.! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 17:20'!fullContainsPoint: pt	(bounds containsPoint: pt) ifFalse:[^false].	^super fullContainsPoint: pt! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 17:21'!unlockedMorphsAt: pt addTo: mList	(bounds containsPoint: pt) ifFalse:[^mList].	^super unlockedMorphsAt: pt addTo: mList! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33' prior: 36957190!frameNumber: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 16:20' prior: 36958830!stepForward	frameNumber < frames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[(self valueOfProperty:#loopFrames) == true 			ifTrue:[self frameNumber: 1]			ifFalse:[self stop]].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33' prior: 36959270!stepToFrameForward: frame	| activeRemoved resortNeeded morph |	frameNumber+1 to: frame do:[:f|		activeRemoved _ false.		resortNeeded _ false.		1 to: activeMorphs size do:[:i|			morph _ activeMorphs at: i.			morph stepToFrame: f.			morph visible ifFalse:[activeRemoved _ true].			(i > 1 and:[(activeMorphs at: i-1) depth < morph depth])				ifTrue:[resortNeeded _ true].		].		activeRemoved ifTrue:[			activeMorphs _ activeMorphs select:[:m| m visible].			resortNeeded _ false.		].		resortNeeded ifTrue:[activeMorphs reSort].		(activationKeys at: f) do:[:m|			m stepToFrame: f.			m visible ifTrue:[activeMorphs add: m].		].	].! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 13:57' prior: 36961370!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 16:01' prior: 36961912!gotoFrame: frame	"Jump to the given frame"	self frameNumber: frame+1.	self stop.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 18:06' prior: 36962785!play	"Start playing from the current frame"	frameNumber >= frames ifTrue:[self frameNumber: 1].	self startStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 17:57' prior: 36962924!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:25'!addMorph: aMorph frame: relFrame	"Do not change the color"	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!adjustBookControls	| inner |	startButton ifNil: [^ self].	startButton align: startButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	stopButton align: stopButton topRight with: inner topRight - (16@4).! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:50'!initialize	| aFont |	super initialize.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (startButton _ SimpleButtonMorph new borderWidth: 0;			label: 'play' font: aFont; color: Color transparent;			actionSelector: #play; target: self).	startButton setBalloonText: 'continue playing'.	self addMorph: (stopButton _ SimpleButtonMorph new borderWidth: 0;			label: 'stop' font: aFont; color: Color transparent;			actionSelector: #stop; target: self).	stopButton setBalloonText: 'stop playing'.	startButton submorphs first color: Color blue.	stopButton submorphs first color: Color red.	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInMVCExtent: extent	Smalltalk isMorphic ifTrue:[^self openInWorldExtent: extent].	super openInMVCExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInWorldExtent: extent	Smalltalk isMorphic ifFalse:[^self openInMVCExtent: extent].	super openInWorldExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!play	model play! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!stop	model stop! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:39'!id	^-1! !!FlashSpriteMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:07'!initialize	super initialize.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.	frameNumber _ 0.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:49'!addSound: aSound at: frameNr	| oldSound newSound |	oldSound _ sounds at: frameNr ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frameNr put: newSound.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:28'!frameNumber	^frameNumber! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:28'!frameNumber: frame	^self stepToFrame: frame! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 17:06'!frames	^frames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 17:06'!frames: aNumber	frames _ aNumber! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 17:05'!step	self visible ifFalse:[frameNumber _ 0. ^self].	self frameNumber: self frameNumber + 1! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 16:27'!stepTime	^stepTime! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 17:07'!stepTime: time	stepTime _ time.! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 19:02'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 16:27'!wantsSteps	^true! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^true! !!FlashSpriteMorph methodsFor: 'change reporting' stamp: 'ar 11/16/1998 16:49'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/17/1998 19:47'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!executeActions: actionList	actionList do:[:msg| msg sentTo: self].! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!gotoFrame: frame	"Jump to the given frame"		self frameNumber: frame.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet.	Ignored for the moment."! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!play	"Start playing from the current frame"	self startStepping.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/16/1998 23:46' prior: 36420075!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a12.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!SolidFillStyle methodsFor: 'printing' stamp: 'ar 11/17/1998 00:29'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: color; nextPut:$).! !!TranslucentColor methodsFor: 'testing' stamp: 'ar 11/17/1998 17:07'!isTransparent	^alpha = 0! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 11/17/1998 17:08' prior: 35349950!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	alpha = 0 ifTrue:[^0].	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !FlashFileReader removeSelector: #recordResetSubshape!FlashFileReader removeSelector: #recordResetSubshape!FlashFileReader removeSelector: #processButtonRecords:from:!FlashFileReader removeSelector: #processButtonRecords:from:!FlashFileReader removeSelector: #processDefineBits2:!FlashFileReader removeSelector: #processDefineBits2:!FlashFileReader removeSelector: #processDefineBits3:!FlashFileReader removeSelector: #processDefineBits3:!FlashButtonMorph removeSelector: #layoutChanged!FlashButtonMorph removeSelector: #layoutChanged!FlashMorphReader removeSelector: #recordResetSubshape!FlashMorphReader removeSelector: #recordResetSubshape!'From Squeak 2.2 of Sept 23, 1998 on 19 November 1998 at 6:35:26 pm'!"Change Set:		Interrupt-FixDate:			19 November 1998Author:			Andreas RaabFix for an interrupt problem occuring if the active controller's process is terminated"!!ControlManager methodsFor: 'scheduling' stamp: 'ar 11/19/1998 18:31' prior: 33838026!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !'From Squeak 2.2 of Sept 23, 1998 on 19 November 1998 at 1:41:15 pm'!"Change Set:		Newmatch-diDate:			19 November 1998Author:			Dan IngallsThis changeSet defines a new version of <string> match: that takes advantage of the new string search primitives.  It retains support for #, and also the ability to backtrack from early false matches."!!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:37' prior: 37007714!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:28'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i _ keyStart.	j _ textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i _ i+1.  j _ j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch _ true.				matchStart _ i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch _ false.				matchStart _ i].	"Now determine the match string"	matchEnd _ self size.	(ii _ self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd _ ii-1].	(ii _ self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd _ matchEnd min: ii-1].	matchStr _ self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj _ text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j _ j+1].	^ false "Failed to find the match string"! !String removeSelector: #xmatch:!'From Squeak 2.0 of May 22, 1998 on 25 May 1998 at 1:01:41 am'!Browser subclass: #FileContentsBrowser	instanceVariableNames: 'packages infoString '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #FilePackage	instanceVariableNames: 'packageName fullName sourceSystem classes doIts classOrder '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #PseudoClass	instanceVariableNames: 'name definition organization source metaClass '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!ClassOrganizer subclass: #PseudoClassOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!PseudoClass subclass: #PseudoMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #TextDiffBuilder	instanceVariableNames: 'realSrc realDst srcMap dstMap srcLines dstLines srcPos dstPos added removed shifted runs matches multipleMatches patchSequence '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!TextDiffBuilder subclass: #ClassDiffBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!!ChangeRecord methodsFor: 'access'!category	^category! !!ChangeRecord methodsFor: 'access'!isMetaClassChange	^meta! !!ChangeRecord methodsFor: 'access'!methodClassName	^class! !!Color class methodsFor: 'named colors' stamp: 'wod 5/24/1998 01:56'!tan	^  Color r: 0.8 g: 0.8 b: 0.5! !!FileContentsBrowser methodsFor: 'accessing'!contents	self updateInfoView.	(editSelection == #newClass and:[self selectedPackage notNil])		ifTrue: [^self selectedPackage packageInfo].	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!FileContentsBrowser methodsFor: 'accessing'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	self inform:'You cannot change the current selection'.	^false! !!FileContentsBrowser methodsFor: 'accessing'!packages	^packages! !!FileContentsBrowser methodsFor: 'accessing'!packages: aDictionary	packages := aDictionary.! !!FileContentsBrowser methodsFor: 'accessing'!selectedPackage	| cat |	cat := self selectedSystemCategoryName.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeClass	| class |	classListIndex = 0 ifTrue: [^ self].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:46'!removeMessage	| messageName |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	(self selectedClassOrMetaClass confirmRemovalOf: messageName) ifFalse:[^false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:51'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:52'!removePackage	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategoryName.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:41'!removeUnmodifiedCategories	| theClass |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass selectors).	].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage isNil						ifTrue:[self packages] 						ifFalse:[Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:44'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	cat := self selectedMessageCategoryName.	cat isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asSortedCollection].! !!FileContentsBrowser methodsFor: 'class list'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'wod 5/24/1998 20:37'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileContentsBrowser methodsFor: 'class list'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	self selectedClassName == nil ifTrue: [^nil].	^self selectedPackage classAt: self selectedClassName! !!FileContentsBrowser methodsFor: 'edit pane'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	^self methodDiffFor: contents class: self selectedClass selector: self selectedMessageName meta: self metaClassIndicated! !!FileContentsBrowser methodsFor: 'diffs'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta	| theClass source diff |	theClass := Smalltalk at: aPseudoClass name ifAbsent:[^aString copy].	meta ifTrue:[theClass := theClass class].	(theClass includesSelector: selector) ifFalse:[^aString copy].	source := theClass sourceCodeAt: selector.	Cursor wait showWhile:[		diff := TextDiffBuilder buildDisplayPatchFrom: source to: aString.	].	^diff! !!FileContentsBrowser methodsFor: 'diffs'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	Cursor wait showWhile:[		diff := ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInClass	Cursor read showWhile:[		self selectedClass fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInMessage	Cursor read showWhile:[		self selectedClass fileInMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInMessageCategories	Cursor read showWhile:[		self selectedClass fileInCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 12:50'!fileInPackage	Cursor read showWhile:[		self selectedPackage fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutClass	Cursor write showWhile:[		self selectedClass fileOut.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutMessage	Cursor write showWhile:[		self selectedClass fileOutMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutMessageCategories	Cursor write showWhile:[		self selectedClass fileOutCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutPackage	Cursor write showWhile:[		self selectedPackage fileOut.	].! !!FileContentsBrowser methodsFor: 'infoView'!infoString	^infoString isNil		ifTrue:[infoString := StringHolder new]		ifFalse:[infoString]! !!FileContentsBrowser methodsFor: 'infoView'!infoViewContents	| theClass |	editSelection == #newClass ifTrue:[^self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue:[^''].	theClass := Smalltalk at: (self selectedClass name asSymbol) ifAbsent:[nil].	editSelection == #editClass ifTrue:[		^(theClass notNil)			ifTrue:['Class exists already in the system']			ifFalse:['New class']].	(editSelection == #editMessage) ifFalse:[^''].	(theClass notNil and:[self metaClassIndicated]) ifTrue:[theClass := theClass class].	^(theClass notNil and:[theClass includesSelector: self selectedMessageName])		ifTrue:['Method already exists in the system']		ifFalse:['New method']! !!FileContentsBrowser methodsFor: 'infoView'!packageInfo: p	| nClasses newClasses oldClasses |	p isNil ifTrue:[^''].	nClasses := newClasses := oldClasses := 0.	p classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue:[oldClasses := oldClasses + 1]			ifFalse:[newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'wod 5/19/1998 17:34'!updateInfoView	Smalltalk isMorphic 		ifTrue: [self changed: #infoViewContents]		ifFalse: [			self infoString contents: self infoViewContents.			self infoString changed].! !!FileContentsBrowser methodsFor: 'metaclass'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass metaClass]		ifFalse: [^ self selectedClass]! !!FileContentsBrowser methodsFor: 'metaclass'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'wod 5/25/1998 00:46'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	messageListIndex ~= 0 		ifTrue: [Smalltalk browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/19/1998 18:24'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/24/1998 01:56'!defaultBackgroundColor	^ #tan! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/19/1998 19:04'!openAsMorph	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window aListExtent next |	window _ (SystemWindow labelled: 'later') model: self.	self packages size = 1		ifTrue: [			aListExtent _ 0.333333 @ 0.34.			self systemCategoryListIndex: 1.			window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton					selected: #indexIsOne changeSelected: #indexIsOne:					menu: #packageListMenu:)				frame: (0@0 extent: 1.0@0.06).			next := 0@0.06]		ifFalse: [			aListExtent _ 0.25 @ 0.4.			window addMorph: (PluggableListMorph on: self list: #systemCategoryList					selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:					menu: #packageListMenu:)				frame: (0@0 extent: aListExtent).			next := aListExtent x @ 0].	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (next extent: aListExtent - (0.0 @ 0.05)).	window addMorph: self buildMorphicSwitches		frame: (next + (0 @ (aListExtent y - 0.05)) extent: aListExtent x @ 0.05).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (next extent: aListExtent).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:)		frame: (next extent: aListExtent).	window addMorph: (PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@0.94).	window addMorph: (PluggableTextMorph on: self text: #infoViewContents accept: nil			readSelection: nil menu: nil)		frame: (0@0.94 corner: 1@1).	^ window! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:18'!classListMenu: aMenu	^ aMenu 		labels:'definitioncommentclass refsfileInfileOutrename...removeremove existing'		lines: #(2 3 5 7)		selections: #(editClass editComment browseClassRefs fileInClass fileOutClass renameClass removeClass removeUnmodifiedCategories) ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 17:39'!messageCategoryMenu: aMenu	^ aMenu 		labels:'fileInfileOutreorganizeadd item...rename...removeremove existing'		lines: #(2 3 6)		selections: #(fileInMessageCategories fileOutMessageCategories editMessageCategories addCategory renameCategory removeMessageCategory removeUnmodifiedMethods)! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 14:37'!messageListMenu: aMenu	^ aMenu 		labels:'fileInfileOutsendersimplementorsremove'		lines: #(2 4)		selections: #(fileInMessage fileOutMessage browseSenders browseImplementors removeMessage).! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:09'!packageListMenu: aMenu	^ aMenu 		labels:'find class...fileInfileOutremoveremove existing'		lines: #(1 3 4)		selections: #(findClass fileInPackage fileOutPackage removePackage removeUnmodifiedClasses)! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/13/1998 18:17'!browseFile: aFilename	self browseFiles: (Array with: aFilename).! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/14/1998 23:40'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package _ FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'Package Browser'.! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/13/1998 14:50' prior: 33957204!fileSelectedMenu: aMenu	^ aMenu		labels:'fileInfile into new change setbrowse changesbrowse codespawn this filecopy name to clipboardopen image in a windowread image into GIFImportsplay midi filesort by namesort by sizesort by daterenamedeleteadd new filebroadcast as update'		lines: # (2 6 8 9 12)		selections: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile editFile copyName openImageInWindow importImage playMidiFile sortByName sortBySize sortByDate renameFile deleteFile addNewFile putUpdate)! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/13/1998 04:12' prior: 33960050!noFileSelectedMenu: aMenu	^ aMenu		labels:'sort by namesort by sizesort by datebrowse code filesadd new file'		lines: # (3 4)		selections: #(sortByName sortBySize sortByDate browseFiles addNewFile)! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFile	FileContentsBrowser browseFile: self fullName.! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFiles	| selectionPattern fileList |	selectionPattern := FillInTheBlank request:'What files?' initialAnswer: self pattern.	fileList _ (directory fileNamesMatching: selectionPattern) 		collect: [:each | directory fullNameFor: each].	FileContentsBrowser browseFiles: fileList.! !!FilePackage methodsFor: 'accessing'!classAt: className	^self classes at: className! !!FilePackage methodsFor: 'accessing'!classes	^classes! !!FilePackage methodsFor: 'accessing'!fullPackageName	^fullName! !!FilePackage methodsFor: 'accessing'!packageInfo	^String streamContents:[:s|		s nextPutAll:'Package: '.		s nextPutAll: self fullPackageName; cr; cr.		sourceSystem isEmpty ifFalse:[			s nextPutAll: sourceSystem; cr; cr].		doIts isEmpty ifFalse:[			s nextPutAll:'Unresolvable doIts:'; cr; cr.			doIts do:[:chgRec|				s nextPut:$!!; nextPutAll: chgRec string; nextPut: $!!; cr]]].! !!FilePackage methodsFor: 'accessing'!packageName	^packageName! !!FilePackage methodsFor: 'accessing'!removeClass: aPseudoClass	(self classes removeKey: aPseudoClass name).	classOrder copy do:[:cls|		cls name = aPseudoClass name ifTrue:[ classOrder remove: cls].	].! !!FilePackage methodsFor: 'accessing'!renameClass: aPseudoClass to: newName	| oldName |	oldName := aPseudoClass name.	self classes removeKey: oldName.	self classes at: newName put: aPseudoClass.	aPseudoClass renameTo: newName.! !!FilePackage methodsFor: 'initialize'!fromFileNamed: aName	| stream |	fullName := aName.	packageName := FileDirectory localNameFor: fullName.	stream := FileStream readOnlyFileNamed: aName.	doIts := OrderedCollection new.	classOrder := OrderedCollection new.	sourceSystem := ''.	self fileInFrom: stream.! !!FilePackage methodsFor: 'private'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	tokens size = 11 ifFalse:[^doIts add: chgRec].	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: 'private'!getClass: className	| pseudoClass |	(classes includesKey: className) ifTrue:[		^classes at: className.	].	pseudoClass := PseudoClass new.	pseudoClass name: className.	classes at: className put: pseudoClass.	^pseudoClass.! !!FilePackage methodsFor: 'private'!metaClassDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	theClass := self getClass: (tokens at: 1).	theClass metaClass definition: string.	classOrder add: theClass metaClass.! !!FilePackage methodsFor: 'private'!msgClassComment: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 3) class == String]) ifTrue:[		theClass := self getClass: tokens first.		^theClass commentString: tokens last].	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) class == String]]) ifTrue:[		theClass := self getClass: tokens first.		theClass metaClass commentString: tokens last].! !!FilePackage methodsFor: 'private'!possibleSystemSource: chgRec	| tokens |	sourceSystem isEmpty ifTrue:[		tokens := Scanner new scanTokens: chgRec string.		(tokens size = 1 and:[tokens first class == String]) ifTrue:[			sourceSystem := tokens first.			^self]].	doIts add: chgRec.! !!FilePackage methodsFor: 'private'!removedMethod: string with: chgRec	| class tokens |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 2) == #removeSelector: ]) ifTrue:[		class := self getClass: (tokens at: 1).		^class removeSelector: (tokens at: 3).	].	(tokens size = 4 and:[(tokens at: 2) == #class and:[(tokens at: 3) == #removeSelector:]]) ifTrue:[		class := self getClass: (tokens at: 1).		^class metaClass removeSelector: (tokens at: 4).	].	doIts add: chgRec! !!FilePackage methodsFor: 'private'!sampleMethod"	In an existing method there are always a number of changes.	Other stuff		will be deleted	Or even better,		some things may be just modified."! !!FilePackage methodsFor: 'change record types'!classComment: chgRec	(self getClass: chgRec methodClassName) classComment: chgRec! !!FilePackage methodsFor: 'change record types'!doIt: chgRec	| string |	string := chgRec string.	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'		match: string) ifTrue:[^self classDefinition: string with: chgRec].	('* class*instanceVariableNames:*'		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].	('* removeSelector: *'		match: string) ifTrue:[^self removedMethod: string with: chgRec].	('* comment:*'		match: string) ifTrue:[^self msgClassComment: string with: chgRec].	('* initialize'		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"	('''From *'		match: string) ifTrue:[^self possibleSystemSource: chgRec].	doIts add: chgRec.! !!FilePackage methodsFor: 'change record types'!method: chgRec	(self getClass: chgRec methodClassName) methodChange: chgRec! !!FilePackage methodsFor: 'change record types'!preamble: chgRec	self doIt: chgRec! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu _ SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice _ menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 16:00'!fileIn	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileInDoits].	classOrder do:[:cls|		cls fileInDefinition.	].	classes do:[:cls|		Transcript cr; show:'Filing in ', cls name.		cls fileInMethods.		cls hasMetaclass ifTrue:[cls metaClass fileInMethods].	].	doitsMark = 3 ifTrue:[self fileInDoits].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileInDoits	doIts do:[:chgRec| chgRec fileIn].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOutDoits: aStream	doIts do:[:chgRec| chgRec fileOutOn: aStream].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:59'!fileOutOn: aStream	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileOutDoits: aStream].	classOrder do:[:cls|		cls fileOutDefinitionOn: aStream.	].	classes do:[:cls|		cls fileOutMethodsOn: aStream.		cls hasMetaclass ifTrue:[cls metaClass fileOutMethodsOn: aStream].	].	doitsMark = 3 ifTrue:[self fileOutDoits: aStream].! !!FilePackage methodsFor: 'reading'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	aStream close.	classes := Dictionary new.	('Processing ', self packageName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbol with: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation'!fromFileNamed: aName	^self new fromFileNamed: aName! !!OrderedCollection methodsFor: 'adding'!add: newObject beforeIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding index. Answer newObject."	self insert: newObject before: firstIndex + index.	^newObject! !!PseudoClass methodsFor: 'class'!classComment: aChangeRecord	self organization classComment: aChangeRecord! !!PseudoClass methodsFor: 'class'!comment	| rStr |	rStr := self organization commentRemoteStr.	^rStr isNil		ifTrue:[self name,' has not been commented']		ifFalse:[rStr string]! !!PseudoClass methodsFor: 'class'!comment: aString	self commentString: aString.! !!PseudoClass methodsFor: 'class' stamp: 'wod 4/15/98 17:21'!commentString	^self organization classComment asString! !!PseudoClass methodsFor: 'class'!commentString: aString	self classComment: aString asText. "Just wrap it"! !!PseudoClass methodsFor: 'class'!definition	^definition ifNil:['There is no class definition for this class'].! !!PseudoClass methodsFor: 'class'!definition: aString	definition := aString! !!PseudoClass methodsFor: 'class'!metaClass	^metaClass ifNil:[metaClass := PseudoMetaclass new name: (self name)].! !!PseudoClass methodsFor: 'class'!renameTo: aString	self hasDefinition ifTrue:[		self isMetaClass ifTrue:[			self definition: (self definition				copyReplaceAll: name,' class'				with: aString, ' class').		] ifFalse:[			self definition: (self definition 					copyReplaceAll:'ubclass: #',name					with:'ubclass: #', aString)]].	name := aString.	metaClass ifNotNil:[metaClass renameTo: aString].! !!PseudoClass methodsFor: 'accessing'!fullName	^self name! !!PseudoClass methodsFor: 'accessing'!name	^name! !!PseudoClass methodsFor: 'accessing'!name: anObject	name _ anObject! !!PseudoClass methodsFor: 'accessing'!organization	^organization ifNil:[organization := PseudoClassOrganizer defaultList: SortedCollection new].! !!PseudoClass methodsFor: 'accessing'!realClass	^Smalltalk at: self name asSymbol! !!PseudoClass methodsFor: 'accessing' stamp: 'wod 5/19/1998 17:42'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!PseudoClass methodsFor: 'removing'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass isNil ifFalse:[metaClass removeAllUnmodified].! !!PseudoClass methodsFor: 'removing'!removeUnmodifiedMethods: aCollection	| stClass |	self exists ifFalse:[^self].	stClass := self realClass.	aCollection do:[:sel|		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asString ifTrue:[			self removeMethod: sel.		].	].	self organization removeEmptyCategories.! !!PseudoClass methodsFor: 'private'!confirmRemovalOf: aString	^self confirm:'Remove ',aString,' ?'! !!PseudoClass methodsFor: 'private'!evaluate: aString	^Compiler evaluate: aString for: nil logged: true! !!PseudoClass methodsFor: 'private'!makeSureClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!makeSureSuperClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: 'The super class ',aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!parserClass	^Parser! !!PseudoClass methodsFor: 'testing'!exists	^(Smalltalk at: self name asSymbol ifAbsent:[^false]) isKindOf: Behavior! !!PseudoClass methodsFor: 'testing'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition isNil ifFalse:[^true].	metaClass isNil ifFalse:[^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'testing'!hasComment	^self organization commentRemoteStr notNil! !!PseudoClass methodsFor: 'testing'!hasDefinition	^definition notNil! !!PseudoClass methodsFor: 'testing'!hasMetaclass	^metaClass notNil! !!PseudoClass methodsFor: 'testing'!isMetaClass	^false! !!PseudoClass methodsFor: 'testing'!nameExists	^Smalltalk includesKey: self name asSymbol! !!PseudoClass methodsFor: 'testing'!needsInitialize	^self hasMetaclass and:[		self metaClass selectors includes: #initialize]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileIn	"FileIn the receiver"	self hasDefinition ifTrue:[self fileInDefinition].	self fileInMethods: self selectors.	metaClass ifNotNil:[metaClass fileIn].	self needsInitialize ifTrue:[		self evaluate: self name,' initialize'.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInCategory: aCategory	^self fileInMethods: (self organization listAtCategoryNamed: aCategory)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInDefinition	(self makeSureSuperClassExists: (definition copyUpTo: Character space)) ifFalse:[^self].	self hasDefinition ifTrue:[		Transcript cr; show:'Defining ', self name.		self evaluate: self definition].	self exists ifFalse:[^self].	self hasComment ifTrue:[self realClass classComment: self comment].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethod: selector	^self fileInMethods: (Array with: selector)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods	^self fileInMethods: self selectors! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods: aCollection	"FileIn all methods with selectors taken from aCollection"	| theClass cat |	self exists ifFalse:[^self classNotDefined].	theClass := self realClass.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			theClass 				compile: (self sourceCodeAt: sel) 				classified: cat				withStamp: (self stampAt: sel)				notifying: nil.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOut	| f |	f := (FileStream newFileNamed: self name,'.st').	self fileOutOn: f.	self needsInitialize ifTrue:[		f cr; nextChunkPut: self name,' initialize'.	].	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutCategory: categoryName	| f |	f := (FileStream newFileNamed: self name,'-',categoryName,'.st').	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment ifTrue:[		aStream cr; nextPut: $!!; nextChunkPut: self name,' comment: '; cr.		aStream nextChunkPut: self commentString printString.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethod: selector	| f |	f := (FileStream newFileNamed: self name,'-', selector, '.st').	self fileOutMethods: (Array with: selector)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethods: aCollection on: aStream	"FileOut all methods with selectors taken from aCollection"	| cat categories |	categories := Dictionary new.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			(categories includesKey: cat) 				ifFalse:[categories at: cat put: Set new].			(categories at: cat) add: sel].	].	categories associationsDo:[:assoc|		cat := assoc key.		aStream cr; cr; nextPut:$!!; nextChunkPut:(String streamContents:[:s|			s nextPutAll: self fullName; nextPutAll:' methodsFor: '; print: cat asString]).		assoc value do:[:sel|			aStream cr.			aStream nextChunkPut: (self sourceCodeAt: sel).		].		aStream space; nextPut:$!!.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethodsOn: aStream	^self fileOutMethods: self selectors on: aStream.! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutOn: aStream	"FileOut the receiver"	self fileOutDefinitionOn: aStream.	metaClass ifNotNil:[metaClass fileOutDefinitionOn: aStream].	self fileOutMethods: self selectors on: aStream.	metaClass ifNotNil:[metaClass fileOutMethods: metaClass selectors on: aStream].! !!PseudoClass methodsFor: 'errors'!classNotDefined	^self inform: self name,' is not defined in the system.You have to define this class first.'.! !!PseudoClass methodsFor: 'categories'!removeCategory: selector	(self organization listAtCategoryNamed: selector) do:[:sel|		self organization removeElement: sel.		self sourceCode removeKey: sel.	].	self organization removeCategory: selector.! !!PseudoClass methodsFor: 'categories'!removedCategoryName	^'*** removed methods ***' asSymbol! !!PseudoClass methodsFor: 'categories'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	^ self organization categoryOfElement: aSelector! !!PseudoClass methodsFor: 'methods'!addMethodChange: aChangeRecord	| selector |	selector := Parser new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'methods'!methodChange: aChangeRecord	aChangeRecord isMetaClassChange ifTrue:[		^self metaClass addMethodChange: aChangeRecord.	] ifFalse:[		^self addMethodChange: aChangeRecord.	].! !!PseudoClass methodsFor: 'methods'!removeMethod: selector	self organization removeElement: selector.	self sourceCode removeKey: selector.! !!PseudoClass methodsFor: 'methods'!removeSelector: aSelector	| catName |	catName := self removedCategoryName.	self organization addCategory: catName before: self organization categories first.	self organization classify: aSelector under: catName.	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !!PseudoClass methodsFor: 'methods'!selectors	^self sourceCode keys! !!PseudoClass methodsFor: 'methods'!sourceCode	^source ifNil:[source := Dictionary new]! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel	^(self sourceCode at: sel) string! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel put: object	self sourceCode at: sel put: object! !!PseudoClass methodsFor: 'methods'!sourceCodeTemplate	^''! !!PseudoClass methodsFor: 'methods'!stampAt: selector	^(self sourceCode at: selector) stamp! !!PseudoClassOrganizer methodsFor: 'all' stamp: 'wod 4/15/98 17:08'!classComment	"Answer the comment associated with the object that refers to the receiver."	globalComment == nil ifTrue: [^''].	^globalComment! !!PseudoClassOrganizer methodsFor: 'all'!classComment: aChangeRecord	globalComment := aChangeRecord! !!PseudoClassOrganizer methodsFor: 'all'!setDefaultList: aCollection	super setDefaultList: aCollection.	self classComment: nil.! !!PseudoMetaclass methodsFor: 'accessing'!fullName	^self name,' class'! !!PseudoMetaclass methodsFor: 'accessing'!realClass	^super realClass class! !!PseudoMetaclass methodsFor: 'testing'!isMetaClass	^true! !!TextDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line; cr].	].	! !!TextDiffBuilder methodsFor: 'initialize'!destString: aString	realDst := self split: aString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := Dictionary new: dstLines size.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!from: sourceString to: destString	self sourceString: sourceString.	self destString: destString.! !!TextDiffBuilder methodsFor: 'initialize'!sourceString: aString	realSrc := self split: aString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := Dictionary new: srcLines size.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!split: aString	^self split: aString by: self splitCharacter! !!TextDiffBuilder methodsFor: 'testing'!hasMultipleMatches	^multipleMatches == true! !!TextDiffBuilder methodsFor: 'creating patches'!buildDisplayPatch	^Text streamContents:[:stream|		self printPatchSequence: self buildPatchSequence on: stream.	]! !!TextDiffBuilder methodsFor: 'creating patches'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht fr n-m matches"	matches := Dictionary new.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos includesKey: line) 			ifTrue:[(srcPos at: line) do:[:index2|						matches at: index@index2 put: line]]	].	srcLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) do:[:index2|						matches at: index2@index put: line]]	].! !!TextDiffBuilder methodsFor: 'creating patches'!collectRunFrom: todo startingWith: startIndex into: run	| next start |	start := startIndex.	self remove: start from: todo.	run add: (matches at: start).	"Search downwards"	next := start.	[next := next + (1@1).	todo includes: next] whileTrue:[		run addLast: (matches at: next).		self remove: next from: todo].	"Search upwards"	next := start.	[next := next - (1@1).	todo includes: next] whileTrue:[		run addFirst: (matches at: next).		self remove: next from: todo.		start := next. "To use the first index"	].	^start! !!TextDiffBuilder methodsFor: 'creating patches'!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns _ OrderedCollection new.	sortedRuns _ SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY _ sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run _ sortedRuns at: i.		run key y > lastY			ifTrue: [lastY _ run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!TextDiffBuilder methodsFor: 'creating patches'!generatePatchSequence	| ps |	ps := OrderedCollection new: srcLines size.	srcLines size timesRepeat:[ps add: nil].	self incorporateMatchesInto: ps.	self incorporateRemovalsInto: ps.	self incorporateAddsInto: ps.	^ps! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value beforeIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateMatchesInto: aPatchSequence	"Incorporate matches"	| index |	runs associationsDo:[:assoc|		index := assoc key y.		assoc value do:[:line|			self assert:[(aPatchSequence at: index) isNil].			aPatchSequence at: index put: (#match -> line).			index := index + 1.		].	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateRemovalsInto: aPatchSequence	"Incorporate removals"	| index |	removed ifNil:[^self].	removed do:[:assoc|		index := assoc key.		self assert:[(aPatchSequence at: index) isNil].		aPatchSequence at: index put: #remove -> assoc value.	].! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonals	^self processDiagonalsFrom: matches keys asSet! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := Dictionary new.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches'!processShiftedRuns	| key |	shifted isNil ifTrue:[^self].	shifted do:[:assoc|		key := assoc key.		assoc value doWithIndex:[:line :idx|			removed add: (key y + idx - 1) -> line.			added add: (key x + idx - 1) -> line].		runs removeKey: assoc key.	].! !!TextDiffBuilder methodsFor: 'creating patches'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy := Dictionary new: srcPos size.	srcPos associationsDo:[:assoc| srcPosCopy at: assoc key put: assoc value asSet].	dstPosCopy := Dictionary new: dstPos size.	dstPos associationsDo:[:assoc| dstPosCopy at: assoc key put: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private'!assert: aBlock	aBlock value ifFalse:[self error: 'Assertion failed']! !!TextDiffBuilder methodsFor: 'private'!remove: pointKey from: aSet	| sArray obj |	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	sArray := aSet asArray.	1 to: sArray size do:[:i|		obj := sArray at: i.		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private'!split: aString by: splitChar	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) = splitChar ifTrue:[			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!TextDiffBuilder methodsFor: 'private'!splitCharacter	^Character cr! !!ClassDiffBuilder methodsFor: 'initialize'!split: aString	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) isSeparator ifTrue:[			out nextPut: c.			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!ClassDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line].	].! !!TextDiffBuilder class methodsFor: 'instance creation'!buildDisplayPatchFrom: srcString to: dstString	^(self from: srcString to: dstString) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation'!from: srcString to: dstString	^self new from: srcString to: dstString! !'From Squeak 2.2 of Sept 23, 1998 on 19 November 1998 at 2:33:14 pm'!"Change Set:		FileBrowserMenuFixDate:			19 November 1998Author:			Dan IngallsRestores some menus that got clobbered by the FileBrowser filein"!!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:06' prior: 37105213!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList methodsFor: 'file list menu' stamp: 'di 11/19/1998 14:27' prior: 36965565!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 11/19/1998 14:25' prior: 33959795!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'browse code files'		'add new file' 'add new directory')		(3 4)		(sortByName sortBySize sortByDate		browseFiles		addNewFile addNewDirectory)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:34' prior: 37105837!noFileSelectedMenu: aMenu	| items |	items _ self itemsForNoFile.	^ aMenu		labels: items first		lines: items second		selections: items third! !'From Squeak 2.2 of Sept 23, 1998 on 19 November 1998 at 3:41:34 pm'!"Change Set:		colorOfSwitches-swDate:			19 November 1998Author:			Scott WallaceEnsures that the instance/comment/class switches in any browser are of the appropriate color; prompted by the fact that the file-contents browser had greenish switches."!!Browser methodsFor: 'initialize-release' stamp: 'sw 11/19/1998 15:38' prior: 36215584!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row aColor |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #editComment.	commentSwitch		label: '?' asText allBold asParagraph;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	aColor _ Color colorFrom: self defaultBackgroundColor.	row submorphs do:		[:m | m color: aColor.		m onColor: aColor darker offColor: aColor].	^ row! !'From Squeak 2.2 of Sept 23, 1998 on 20 November 1998 at 5:27:08 pm'!!Set methodsFor: 'converting' stamp: 'ar 11/20/1998 16:34'!asSet	^self! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/20/1998 16:24'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	aSet equalBlock: self equalBlock fixTemps.	aSet hashBlock: self hashBlock fixTemps.	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/20/1998 16:08' prior: 36347091!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 16:08' prior: 37125672!destString: aString	realDst := self split: aString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 16:08' prior: 37126392!sourceString: aString	realSrc := self split: aString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:35' prior: 37127340!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht fr n-m matches"	matches := PluggableDictionary new.	matches hashBlock: self pointHashBlock.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:57' prior: 37127805!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index@index2 put: line]	].	srcLines doWithIndex:[:line :index|		(dstPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index2@index put: line]	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:34' prior: 37130917!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := PluggableDictionary new.	runList hashBlock: self pointHashBlock.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26' prior: 37132240!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy _ srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy _ dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:35'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:31' prior: 37133387!remove: pointKey from: aSet	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	aSet copy do:[:obj|		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26' prior: 37133741!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index _ 1.	[index <= aString size] whileTrue:[		nextIndex _ aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index _ nextIndex+1].	^lines! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:06'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[(string at: 1) asInteger +					((string at: stringSize // 3) asInteger bitShift: 4) +					((string at: stringSize // 2) asInteger bitShift: 8) +					((string at: stringSize * 2 // 3) asInteger bitShift: 12) +					((string at: stringSize) asInteger bitShift: 16)]] fixTemps! !'From Squeak 2.2 of Sept 23, 1998 on 20 November 1998 at 6:17:43 pm'!!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17' prior: 37141251!destString: aString	realDst := self split: aString asString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17' prior: 37141922!sourceString: aString	realSrc := self split: aString asString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !'From Squeak 2.2 of Sept 23, 1998 on 23 November 1998 at 9:39:45 am'!"Change Set:		anonymousDrop-swDate:			23 November 1998Author:			Scott WallaceFixes a bug (when running a morphic world in an mvc project) and amends a related 'feature' (when running in a morphic project) wherein if you dropped a phrase tile from a viewer that was open for a non-flagship instance of a uniclass, you would get a puzzling error message, which, in the morphic-project case, could be irrecoverable.  The fix is just to drop the naked phrase onto the receptor rather than engage in any confusing dialogue."!!Player methodsFor: 'scripts-kernel' stamp: 'sw 11/19/1998 12:33' prior: 20645658!anonymousScriptEditorFor: aPhraseTileMorph	| aScriptEditor aUserScript |	self isFlagshipForClass ifFalse:		[^ aPhraseTileMorph].	aUserScript _ self class anonymousUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph		ifNotNil:			[aScriptEditor scriptName: aUserScript selector phrase: aPhraseTileMorph]		ifNil:			[aScriptEditor startOutEmptyForScriptName: aUserScript selector].	^ aScriptEditor! !'From Squeak 2.2 of Sept 23, 1998 on 23 November 1998 at 9:57:51 am'!"Change Set:		progressTitlesDate:			23 November 1998Author:			Scott WallaceGives meaningful and useful titles (rather than the former 'reading a stream') to the progress bars that accompany updating code from the server, formulating change-list browsers & file-contents browsers, and filing in code from disk."!!ChangeList methodsFor: 'scanning' stamp: 'sw 11/19/1998 16:00' prior: 17275328!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[prevChar = Character cr ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 11/22/1998 23:57' prior: 17334884!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a new change set whose name is a function of the filename.  Show the new set and leave the current changeSet unaltered."	| aFileName  aNewChangeSet |	self okToChange ifFalse: [^ self].	aFileName _ FillInTheBlank request: 'Name of file to be imported: '.	aFileName size == 0 ifTrue: [^ self].	(FileDirectory default fileExists: aFileName) ifFalse:		[^ self inform: 'Sorry -- cannot find that file'].	aNewChangeSet _ self class 			newChangesFromStream: (FileStream readOnlyFileNamed: aFileName) 			named: aFileName.	aNewChangeSet ifNotNil: [self showChangeSet: aNewChangeSet]! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 11/22/1998 23:59' prior: 17352976!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose name is derived from aName.  Leave the 'current change set' unchanged.   Returns the new change set;  Returns nil on failure."	|  newName aNewChangeSet existingChanges |	existingChanges _ Smalltalk changes.	newName _ aName sansPeriodSuffix.	(self changeSetNamed: newName) ~~ nil		ifTrue:			[self inform: 'Sorry -- "', newName, '" is already used as a change-set name'.			aStream close.			^ nil].	aNewChangeSet _ ChangeSet new initialize.	aNewChangeSet name: newName.	AllChangeSets add: aNewChangeSet.	Smalltalk newChanges: aNewChangeSet.	aStream fileInAnnouncing: 'Loading ', newName, '...'.	Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName.	Smalltalk newChanges: existingChanges.	^ aNewChangeSet! !!FileList methodsFor: 'file list menu' stamp: 'sw 11/22/1998 23:57' prior: 18659975!fileIntoNewChangeSet	"File in all of the contents of the currently selected file, if any, into a new change set."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ChangeSorter newChangesFromStream: ff named: fileName.! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:31' prior: 34969242!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	^ self fileInAnnouncing: 'Reading ' , self name! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:29'!fileInAnnouncing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !!FileStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:42' prior: 18684574!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	self fileInAnnouncing: 'Loading ', self localName! !'From Squeak 2.2 of Sept 23, 1998 on 23 November 1998 at 4:06:44 pm'!"Change Set:		StringSearchTweaks-diDate:			23 November 1998Author:			Dan IngallsThe 'method strings with it' command and the 'method source with it' command now search without regard to upper/lower case differences.  Use the shift key to force a case-sensitive search.The 'compare to clipboard' command in the editor's special menu now spawns a window containing the diff text with insertions and deletions properly highlighted.Similarly, the ChangeList and Versions browsers now offer a command, 'compare to current version', that will spawn a window with the diff text, if the selected method exists in the system."!!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21' prior: 20386548!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents _ aStringOrText! !!ChangeList methodsFor: 'menu actions' stamp: 'di 11/23/1998 15:44' prior: 17279743!changeListMenu: aMenu^ aMenu labels:'fileIn selectionsfileOut selections...compare to currentselect conflictsselect conflicts withselect unchanged methodsselect alldeselect allremove doItsremove older versionsremove selections'	lines: #(2 8)	selections: #(fileInSelections fileOutSelectionscompareToCurrentVersion selectConflicts selectConflictsWith selectUnchangedMethods selectAll deselectAllremoveDoIts removeOlderMethodVersions removeSelections)! !!ChangeList methodsFor: 'menu actions' stamp: 'di 11/23/1998 15:51'!compareToCurrentVersion	"If the current selection corresponds to a method in the system,	then spawn a window showing the diffs as text"	| change class s1 s2 |	listIndex = 0 ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])	ifTrue:		[s1 _ (class sourceCodeAt: change methodSelector) asString.		s2 _ change string.		s1 = s2 ifTrue: [^ self inform: 'Exact Match'].		(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))			openLabel: 'Comparison to Current Version']	ifFalse:		[self flash].! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05' prior: 21726913!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	^ self browseMessageList: (self allMethodsWithSourceString: aString									matchCase: caseSensitive)		name: 'Methods containing ' , aString printString , suffix autoSelect: aString! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05' prior: 35262807!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-insensitive, unless the shift key is pressed, in which case the search is case-sensitive."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: aString caseSensitive: caseSensitive]]]		name:  'Methods with string ', aString printString, suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 11/23/1998 12:02'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  The search is case-insensitive."	| list classCount |	list _ Set new.'Searching all source code...'displayProgressAt: Sensor cursorPointfrom: 0 to: Smalltalk classNames sizeduring:	[:bar | classCount _ 0.	Smalltalk allClassesDo:		[:class | bar value: (classCount _ classCount + 1).		(Array with: class with: class class) do:			[:cl | cl selectorsDo:				[:sel | 				((cl sourceCodeAt: sel) findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0					ifTrue:					[sel == #DoIt ifFalse: [list add: cl name , ' ' , sel]]]]]].	^ list asSortedCollection! !!Text methodsFor: 'accessing' stamp: 'di 11/23/1998 11:53'!findString: aString startingAt: start caseSensitive: caseSensitive	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start caseSensitive: caseSensitive! !SystemDictionary removeSelector: #allMethodsWithSourceString:!SystemDictionary removeSelector: #allMethodsWithSourceString:!'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 2:23:54 pm'!nil subclass: #ObjectOut	instanceVariableNames: 'url page recursionFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!ObjectOut subclass: #MorphObjectOut	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!Object subclass: #SqueakPage	instanceVariableNames: 'url title comment thumbnail contentsMorph creationTime creationAuthor lastChangeTime lastChangeAuthor policy dirty '	classVariableNames: 'MaxThumbnailWidthOrHeight RecentMaxNum RecentStem '	poolDictionaries: ''	category: 'Morphic-WebBooks'!Object subclass: #SqueakPageCache	instanceVariableNames: ''	classVariableNames: 'GlobalPolicy NextURL PageCache '	poolDictionaries: ''	category: 'Morphic-WebBooks'!!Object methodsFor: 'testing' stamp: 'tk 10/30/1998 15:10'!isInMemory	"All normal objects are."	^ true! !!Object methodsFor: 'class membership' stamp: 'tk 10/21/1998 12:38'!xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/3/1998 20:56'!saveOnURL	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| um pg |	pg _ self saveOnURLbasic.	um _ URLMorph newForURL: pg url.	um setURL: pg url page: pg.	um isBookmark: true.	self primaryHand attachMorph: um.! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47'!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [url _ pg urlNoOverwrite: suggestedUrlString].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 10:27'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [		url _ 'ftp://server/books/myBook/page1.sp'.	"do better?"		url _ FillInTheBlank 				request: 'url of a place to store this object.Must begin with file:// or ftp://' 				initialAnswer: url.		url size == 0 ifTrue: [^ self beep]].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!BookMorph methodsFor: 'accessing' stamp: 'tk 11/3/1998 21:17'!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in."	| ii pp |	ii _ 0.	1 to: pages size do: [:jj |		(pp _ pages at: jj) isInMemory ifTrue: [			pp = aMorph ifTrue: [ii _ jj]]].	ii = 0 ifTrue: [ii _ pages indexOf: aMorph].	"bring in every page"	^ ii! !!BookMorph methodsFor: 'accessing' stamp: 'tk 10/22/1998 15:47' prior: 17081353!pages: aMorphList	pages _ aMorphList asOrderedCollection.	"It is tempting to force the first page to be the current page.  But then, two pages might be shown at once!!  Just trust the copying mechanism and let currentPage be copied correctly. --Ted."! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 14:49' prior: 36983848!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ self pageNumberOf: currentPage.	oldPageNumber = 0 ifTrue: [oldPageNumber _ nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage fullReleaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/3/1998 21:18' prior: 17093677!goToPageMorph: aMorph	| ii |	ii _ self pageNumberOf: aMorph.	ii = 0 ifFalse: [self goToPage: ii].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/5/1998 00:05' prior: 17090526!nextPage	| i |	currentPage == nil ifTrue: [^ self goToPage: 1].	i _ (self pageNumberOf: currentPage) + 1.	self goToPage: i.! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/5/1998 00:06' prior: 33664749!pageNumber.	^ self pageNumberOf: currentPage! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 15:01' prior: 17091189!previousPage	| ii |	ii _ (self pageNumberOf: currentPage) - 1.	ii = 0 ifTrue: [ii _ pages size].	self goToPage: ii.! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 15:03' prior: 36288314!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:24'!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ 'ftp://server/books/myBook/page1.sp'].url _ FillInTheBlank 		request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' 		initialAnswer: initial.ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"^ (url splitInteger) at: 1		"remove trailing number"! !!BookMorph methodsFor: 'menu' stamp: 'tk 10/30/1998 14:38' prior: 33666070!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'send other pages to server' action: #savePagesOnURL.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:22'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| pg stem |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		pg _ aPage saveOnURL: stem,(ind printString),'.sp'.		]].pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(currentPage == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 16:31'!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'other' stamp: 'tk 10/22/1998 15:42' prior: 17099183!releaseCachedState	"Release the cached state of all my pages."	super releaseCachedState.	pages do: [:page | page fullReleaseCachedState].! !!ObjectOut commentStamp: '<historical>' prior: 0!I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]Note that my selectors and all my subclasses' selectors are not searched in Senders and Implementors.  Remember that!!!!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue realObject |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	"fetch the object"	realObject _ self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	returnValue _ aMessage sentTo: realObject.	^ returnValue! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57'!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing _ SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page _ truePage _ existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage _ SqueakPageCache atURL: url oldPage: page].	object _ truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag _ false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page _ truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/15/1998 19:59'!xxxFixup	"There is already an object in memory for my url.  All pointers to me need to be pointers to him.  Can't use become, because other pointers to him must stay valid."	| real temp list |	real _ page contentsMorph.	real == self ifTrue: [page error: 'should be converted by now'].	temp _ self.	list _ (Smalltalk pointersTo: temp) asOrderedCollection.	list add: thisContext.  list add: thisContext sender.	list do: [:holder |		1 to: holder class instSize do:			[:i | (holder instVarAt: i) == temp ifTrue: [holder instVarAt: i put: real]].		1 to: holder basicSize do:			[:i | (holder basicAt: i) == temp ifTrue: [holder basicAt: i put: real]].		].	^ real! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 10/21/1998 13:01'!xxxSetUrl: aString page: aSqkPage	url _ aString.	page _ aSqkPage.! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store"	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!objectToStoreOnDataStream    "Return an object to store on a data stream (externalize myself)."    ^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:37'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method. Return self."	| cntInstVars |	cntInstVars _ self xxxClass instSize.	self xxxClass isVariable		ifTrue: [self xxxClass error: 'needs updating']	"assume no variable subclasses"		ifFalse: [cntInstVars _ varsOnDisk].	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self xxxInstVarAt: i put: aDataStream next]."	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next]."	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:18'!storeDataOn: aDataStream	"Store myself on a DataStream. See also objectToStoreOnDataStream.	must send 'aDataStream beginInstance:size:'"	| cntInstVars |	cntInstVars _ self class instSize.	"cntIndexedVars _ self basicSize."	aDataStream		beginInstance: self xxxClass		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self xxxInstVarAt: i)]."	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]"! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:29'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self xxxClass.	class isMeta ifTrue: [^ self].		"a class"	new _ self xxxClone.	"not a uniClass"	deepCopier references at: self put: new.	"remember"	"class is not variable"	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self xxxInstVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new xxxInstVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new xxxInstVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/20/1998 15:30'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	"This is just a comment, since this message is never looked up"	<primitive: 110>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/30/1998 15:11'!isInMemory	"We are a place holder for an object that is out."	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:15'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:40'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/21/1998 12:28'!xxxClass	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:31'!xxxClone	<primitive: 148>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:19'!xxxInstVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	self primitiveFailed ! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:39'!xxxInstVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	self primitiveFailed ! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue aMorph myUrl |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	returnValue _ aMessage sentTo: aMorph.		"self == aMorph"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ returnValue! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 10/22/1998 15:43'!fullReleaseCachedState	"do nothing, especially don't bring in my object!!"! !!PasteUpMorph methodsFor: 'layout' stamp: 'tk 10/22/1998 13:55'!layoutChanged	super layoutChanged.	(self valueOfProperty: #SqueakPage) ifNotNil: [		self setProperty: #pageDirty toValue: true].		"I am the morph of a SqueakPage, I have changed and 		need to be written out again"! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tk 11/23/1998 15:09' prior: 36334043!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 10/1/1998 11:54'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 10/2/1998 07:46'!asStream	"Return a RemoteFileStream (subclass of RWBinaryOrTextStream) on the contents of the remote file I represent.  For reading only."	^ self oldFileNamed: self fileName! !!SqueakPage commentStamp: '<historical>' prior: 0!A SqueakPage is holder for a page of morphs that live on the disk or on a server.A URLMorph is a thumbnail sized stand-in for the page.  Clicking on it gets the page.An ObjectOut is a fake object that stands for an object that is out on the disk.  (Like ObjectTracer or ObjectViewer.)A MorphObjectOut is a subclass that stands for a Morph that is out on the disk.To find out how to make the pages of any BookMorph go out to the disk (or a server), see 	http://minnow.cc.gatech.edu/SqueakDoc.1 then go to 'SqueakPages'.A SqueakPage is always in-memory.  Its contentsMorph will be 'become-ed' to a MorphObjectOut tombstone when it goes out.  (A page may or may not be in the cache.  First put it in, then ask it for the data.)  Sending any message to the contentsMorph triggers the fetch.  Many URLMorphs may hold onto one page.  A page has a thumbnail.  A URLMorph points at its page object.States of a SqueakPage, and the transitions to another state:1) have a url as a string.  Then: (URLMorph grabURL: 'file://Ted''s/books/tryThis/p1').  	Drop it into any morph.2) have a URLMorph, with page==nil.     Click it.  (makes an empty page, installs 	it in the global page cache)3) have a URLMorph with a SqueakPage, with contentsMorph==nil, 	but page is not in the cache (this is a rare case).  ask page contentsMorph.4) OUT: have a URLMorph with a SqueakPage, with contentsMorph being a MorphObjectOut, 	and its page is in the cache.  Sending the contentsMorph any message brings it in and	becomes it to the morph.  (fix up morph's pointer to the page.)5) Totally IN:  a morph, owned by a SqueakPage, has a page in the cache.  	The morph is clean.   	Whenever someone triggers a purge (when?), contentsMorph is becomed	to a MorphObjectOut. (go to 4)	Causing the morph to execute layoutChanged marks the morph as dirty.	(morph's property #pageDirty is set to true) (go to 6)6) Totally IN and dirty.  	Whenever any other page is fetched from the disk or the net, all other 	dirty pages are written and marked clean.  (go to 5)Note that the entire tree of submorphs goes out -- hundreds of objects.  Bringing the object back in brings in the SqueakPage, installs it in the cache.  Classes other than PasteUpMorph can easily be made to send their contents out if there is any need.Note that every book is now automatically a WebBook.  We simply give a page a url and tell it to purge.url		a stringtitle		comment		thumbnail		contentsMorph		(1) a pasteUpMorph with other morphs in it.					(2) a MorphObjectOut.  Sending any message brings it in. 					(3) nil if the page has never been in this image.creationTime		creationAuthor		lastChangeTime		lastChangeAuthor policy		#alwaysWrite, #neverWrite, #ask.  (cache can override with a global policy)			(Explicit writing by user has policy #neverWrite)dirty 		(Morph>>layoutChanged sends changed: #SqueakPage. If policy==#check, 				then the page sets dirty_true.)			(If policy==#alwaysWrite, then set dirty when the page is retrieved from the cache.)Class MorphObjectOut has an instance variable called page.All messages to an MorphObjectOut cause it to be brought in.  Except the messages needed to write the MorphObjectOut on the disk as part of a parent's being sent out.  (size, class, instSize, instVar:at:.  Can rename these and call from its own version of the writing routine.)	To purge, go through the clean pages, and any that have world not equal to this world, entomb them.  	(If an object in the subtree is held by an object outside the tree, it will remain,  And will be duplicated when the tree comes back in.  This is a problem already in normal uses of SmartRefStream.)!]style[(458 39 3184)f1,f1Rhttp://minnow.cc.gatech.edu/SqueakDoc.1;,f1!!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:27' prior: 35178155!contentsMorph	"Return what it is now.  If the morph is out on the disk, return nil.  Use fetchContents to get the data for sure."	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!fetchContents	"Make every effort to get contentsMorph."	self isContentsInMemory ifTrue: [^ contentsMorph].	^ self fetchInformIfError! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:48'!fetchContentsIfAbsent: failBlock	"Make every effort to get contentsMorph.  Assume I am in the cache already."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [^ failBlock value].			page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	url _ temp.	"don't care what it says"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/20/1998 10:47'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"		page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	"including contentsMorph"	url _ temp.	"I know best!!"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!isContentsInMemory	"Is my contentsMorph in memory, or is it an ObjectOut tombstone?  Be careful not to send it any message."	^ (contentsMorph xxxClass inheritsFrom: Object) and: [(contentsMorph == nil) not]! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/4/1998 20:34' prior: 35179284!url	^ url! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:40'!dirty: aBool	dirty _ aBool! !!SqueakPage methodsFor: 'saving' stamp: 'tk 10/8/1998 13:18'!policy	^ policy! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:39'!policy: aSymbol	policy _ aSymbol! !!SqueakPage methodsFor: 'saving' stamp: 'tk 10/30/1998 15:08'!purge	"Replace my morph with a tombstone, if I am not in a world that is being shown."	| keep |	self isContentsInMemory ifFalse: [^ self].	contentsMorph ifNil: [^ self].  "out already"	url ifNil: [^ self].	"just to be safe"	keep _ World ~~ nil and: [contentsMorph world == World].	keep ifFalse: [		contentsMorph become: (MorphObjectOut new xxxSetUrl: url page: self)].		"Simple, isn't it!!"! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/23/1998 16:51'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		Cursor wait showWhile: [			remoteFile _ sf newFileNamed: url.			remoteFile fileOutClass: nil andObject: self.			remoteFile close].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPageCache commentStamp: '<historical>' prior: 35181002!A global cache of web pages known to this Squeak image.  Since there is a single, global page cache, it is implemented entirely as class methods.Once a page has an entry, keep it.  (url string -> A SqueakPage)  The SqueakPage has a thumbnail and other info, but may not have the contentsMorph.  The morph is purged when space is needed, and fetched from the server as needed.See SqueakPage's comment for the stages of in/out.!]style[(383 10 36)f1,f1LSqueakPage Comment;,f1!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'tk 11/24/1998 14:22' prior: 35181356!initialize	"SqueakPageCache initialize"	GlobalPolicy _ #neverWrite.	NextURL _ 1.	PageCache _ Dictionary new: 100.		"forgets urls of pages, but ObjectOuts still remember them"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:07' prior: 35181857!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	| pg |	^ PageCache at: aURLString ifAbsent: [		pg _ SqueakPage new.		"stamp _ Utilities authorInitialsPerSe ifNil: ['*']."		"pg author: stamp."		"Need to deal with inst vars if we turn out to be new!!"		"pg url: aURLString. 	done by atURL:put:"		self atURL: aURLString put: pg.		pg]! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:06' prior: 35182167!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	self halt.  "use atURL:"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:51'!atURL: aURLString oldPage: aPage	"Bring in page and return the object.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| myPage |	(myPage _ PageCache at: aURLString ifAbsent: [nil]) ifNotNil: [		^ myPage].	aPage url: aURLString.	"for consistancy"	PageCache at: aPage url put: aPage.	^ aPage! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/19/1998 17:24' prior: 35182449!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	aSqueakPage contentsMorph ifNotNil: [		aSqueakPage contentsMorph setProperty: #SqueakPage toValue: aSqueakPage].	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/30/1998 15:08'!doPagesInMemory: aBlock	"Evaluate aBlock for each page whose contentsMorph is in-memory.  Don't add or remove pages while in this loop."	PageCache do: [:sqkPage |		sqkPage isContentsInMemory ifTrue: [aBlock value: sqkPage]].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:02'!includesMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ true]].	^ false! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:11'!pageCache	^ PageCache! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:04'!pageForMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ squeakPage]].	^ nil! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 12:48'!purge	"Replace morphs with tombstones in all pages that are clean and not being shown.  Write any dirty ones first, if allowed to."	GlobalPolicy == #neverWrite 		ifTrue: [PageCache doPagesInMemory: [:aPage | aPage purge]]			"Writing only done by user's command"		ifFalse: [			PageCache doPagesInMemory: [:aPage | aPage write; purge]].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 13:28'!purge: megs	"Replace morphs with tombstones in all pages that are clean and not being shown.  Do this until megs of new memory have been recovered.  Write any dirty ones first, if allowed to."	| goal |	goal _ Smalltalk garbageCollect + (megs * 1000000) asInteger.	PageCache doPagesInMemory: [:aPage | 		GlobalPolicy == #neverWrite ifFalse: [aPage write].		aPage purge.		Smalltalk garbageCollect > goal ifTrue: [^ true]].	"got enough"	^ false	"caller may want to tell the user to write out more pages"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/22/1998 11:07'!write	"Write out all dirty pages"	GlobalPolicy == #neverWrite ifTrue: [^ self].	self doPagesInMemory: [:aPage | aPage write].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 9/29/1998 15:23' prior: 21729678!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList |	#(23 48 'fred' (new open:label:)) size.		"Example above should find #open:label:, though it is deeply embedded here."	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: special byte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte: byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemTracer methodsFor: 'initialization' stamp: 'tk 10/20/1998 16:03' prior: 21824782!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				].	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectTracer withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectOut withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!URLMorph commentStamp: '<historical>' prior: 35353573!This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it is a bookmorph, it can act on a particular book or it can act on whatever book it happens to be in at the time. The former is primarily used for making a graphical page index allowing random access to any page in the book.How to start.  Make a PasteUpMorph with any morphs in it.Decide where it should live, make a url string, and copy it.	'file://HardDisk/books/book1/myPage.morph'	'file://Ted''s/books/tryThis/p1.morph'	'ftp://doltest1.disney.com/squeak/test/p1.morph'	(ServerDirectory serverNamed: 'UpdatesAtDOL') pathNameChoose 'Save as Web Morph'Paste in the url.Drop the resulting thumbnail into some morph.See SqueakPage's comment for the stages of in/out.!]style[(988 10 36)f1,f1LSqueakPage Comment;,f1!!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:58' prior: 35355691!handlesMouseDown: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:55'!handlesMouseUp: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:58' prior: 35355801!mouseDown: evt	"do nothing"! !!URLMorph methodsFor: 'event handling' stamp: 'tk 11/23/1998 17:36'!mouseUp: evt	| pg ow newPage mm |	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15' prior: 35355991!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'tk 10/1/1998 13:05'!enclosingPage	"Answer the inner-most SqueakPage contents that contains this morph, or nil if there isn't one."	| m pg |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: PasteUpMorph) ifTrue: [			(pg _ SqueakPageCache pageForMorph: m) ifNotNil: [^ pg]].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 08:20' prior: 35356645!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	page ifNotNil: [self pageHasChanged: page].! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 12:07' prior: 35356872!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [page _ SqueakPageCache atURL: url].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 08:22'!grabURL: aURLString	"Create a URLMorph for this url.  Drop it and click it to get the SqueakPage."	World primaryHand attachMorph: ((self new) isBookmark: true; setURL: aURLString page: nil)! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 12:08' prior: 35357278!newForURL: aURLString	| pg |	pg _ SqueakPageCache atURL: aURLString.	^ self new setURL: aURLString page: pg! !SqueakPageCache initialize!'From Squeak 2.2 of Sept 23, 1998 on 20 November 1998 at 1:41:27 pm'!Object subclass: #SqueakPage	instanceVariableNames: 'url title comment thumbnail contentsMorph creationTime creationAuthor lastChangeTime lastChangeAuthor policy dirty '	classVariableNames: 'MaxThumbnailWidthOrHeight RecentMaxNum RecentStem '	poolDictionaries: ''	category: 'Morphic-WebBooks'!!FileUrl methodsFor: 'access' stamp: 'tk 11/20/1998 13:19'!pathForDirectory	"Path using local file system's delimiter.  $\ or $:"	| first pp |	^String streamContents: [ :s |		first _ true.		1 to: self path size - 1 do: [ :ii |			pp _ path at: ii.			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: pp ] ]! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47' prior: 37161403!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [url _ pg urlNoOverwrite: suggestedUrlString].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 10:27' prior: 37162287!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [		url _ 'ftp://server/books/myBook/page1.sp'.	"do better?"		url _ FillInTheBlank 				request: 'url of a place to store this object.Must begin with file:// or ftp://' 				initialAnswer: url.		url size == 0 ifTrue: [^ self beep]].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:16'!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:24' prior: 37167189!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ 'ftp://server/books/myBook/page1.sp'].url _ FillInTheBlank 		request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' 		initialAnswer: initial.ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"^ (url splitInteger) at: 1		"remove trailing number"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:22' prior: 37169089!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| pg stem |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		pg _ aPage saveOnURL: stem,(ind printString),'.sp'.		]].pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(currentPage == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:17' prior: 37169902!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!ObjectOut commentStamp: '<historical>' prior: 37171453!I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]Note that my selectors and all my subclasses' selectors are not searched in Senders and Implementors.  Remember that!!!!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/20/1998 12:20' prior: 37172994!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue realObject |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	"fetch the object"	realObject _ self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	returnValue _ aMessage sentTo: realObject.	^ returnValue! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57' prior: 37173690!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing _ SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page _ truePage _ existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage _ SqueakPageCache atURL: url oldPage: page].	object _ truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag _ false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page _ truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/15/1998 19:59' prior: 37174730!xxxFixup	"There is already an object in memory for my url.  All pointers to me need to be pointers to him.  Can't use become, because other pointers to him must stay valid."	| real temp list |	real _ page contentsMorph.	real == self ifTrue: [page error: 'should be converted by now'].	temp _ self.	list _ (Smalltalk pointersTo: temp) asOrderedCollection.	list add: thisContext.  list add: thisContext sender.	list do: [:holder |		1 to: holder class instSize do:			[:i | (holder instVarAt: i) == temp ifTrue: [holder instVarAt: i put: real]].		1 to: holder basicSize do:			[:i | (holder basicAt: i) == temp ifTrue: [holder basicAt: i put: real]].		].	^ real! !!ObjectOut methodsFor: 'access' stamp: 'tk 11/11/1998 11:11'!xxxUrl	^ url! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/15/1998 18:11'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/20/1998 10:45'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 12:20' prior: 37181310!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue aMorph myUrl |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	returnValue _ aMessage sentTo: aMorph.		"self == aMorph"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ returnValue! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/20/1998 13:10' prior: 35110976!directory	"urlObject ifNotNil: [^ urlObject directory].  Fix this"	^ directory! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 13:21' prior: 35115949!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry first]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	^ self fileAndDirectoryNames includes: localName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 13:10' prior: 21248410!fileName	urlObject ifNotNil: [^ urlObject path last].	^ fileName! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/11/1998 12:54'!contentsMorph: aPasteUpMorph	contentsMorph _ aPasteUpMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/20/1998 10:47' prior: 37190241!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"		page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	"including contentsMorph"	url _ temp.	"I know best!!"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/20/1998 13:29'!urlNoOverwrite: suggested	"Look in the directory.  If there is a file of this name, create a new name.  Keep track of highest numbers used as a hint."	| dir ll stem num local trial |	dir _ ServerFile new fullPath: suggested.	(dir includesKey: dir fileName) ifFalse: [^ url _ suggested].	"File already exists!!  Create a new name"	"Find the stem file name"	ll _ suggested findLast: [:char | char == $.].	ll = 0 ifFalse: [stem _ suggested copyFrom: 1 to: ll-1].	"remove .sp"	stem _ (stem splitInteger) at: 1.		"remove trailing number"	stem last == $x ifTrue: [stem _ stem allButLast].	num _ stem = RecentStem ifTrue: [RecentMaxNum+1] ifFalse: [1].	local _ dir fileName.	"ugh, take stem again..."	ll _ local findLast: [:char | char == $.].	ll = 0 ifFalse: [local _ local copyFrom: 1 to: ll-1].	"remove .sp"	local _ (local splitInteger) at: 1.		"remove trailing number"	local last == $x ifFalse: [local _ local , 'x'].	[trial _ local, num printString, '.sp'.		dir includesKey: trial] whileTrue: [num _ num + 1].	RecentStem _ stem.  RecentMaxNum _ num.	^ url _ stem, 'x', num printString, '.sp'! !'From Squeak 2.2 of Sept 23, 1998 on 23 November 1998 at 5:38:15 pm'!!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 14:49' prior: 37164053!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ self pageNumberOf: currentPage.	oldPageNumber = 0 ifTrue: [oldPageNumber _ nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage fullReleaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 15:01' prior: 37165912!previousPage	| ii |	ii _ (self pageNumberOf: currentPage) - 1.	ii = 0 ifTrue: [ii _ pages size].	self goToPage: ii.! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 15:03' prior: 37166113!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 16:31' prior: 37208878!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!FileUrl methodsFor: 'access' stamp: 'tk 11/23/1998 17:17' prior: 37204345!pathForDirectory	"Path using local file system's delimiter.  $\ or $:"	^ String streamContents: [ :s |		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: FileDirectory default pathNameDelimiter			 ] ]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tk 11/23/1998 15:09' prior: 37182608!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/23/1998 17:24' prior: 35127210!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForDirectory, self fileName! !!SqueakPage methodsFor: 'private' stamp: 'tk 11/23/1998 17:31' prior: 35179546!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/23/1998 16:51' prior: 37192226!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		Cursor wait showWhile: [			remoteFile _ sf newFileNamed: url.			remoteFile fileOutClass: nil andObject: self.			remoteFile close].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'tk 11/23/1998 17:34' prior: 35183343!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish xxxUrl ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!URLMorph methodsFor: 'event handling' stamp: 'tk 11/23/1998 17:36' prior: 37201551!mouseUp: evt	| pg ow newPage mm |	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !!URLMorph methodsFor: 'private' stamp: 'tk 11/23/1998 17:37' prior: 35356369!enclosingBook	"rethink this since class WebBookMorph is gone"! !Smalltalk removeClassNamed: #WebBookMorph!Smalltalk removeClassNamed: #WebBookMorph!'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 2:02:58 pm'!!ServerDirectory methodsFor: 'do ftp' stamp: 'ar 11/24/1998 14:02'!putFile: fileStream named: fileNameOnServer retry: aBool	"ar 11/24/1998 Do the usual putFile:named: operation but retry if some error occurs and aBool is set. Added due to having severe transmission problems on shell.webpage.com."	| resp |	[[resp _ self putFile: fileStream named: fileNameOnServer] 		ifError:[:err :rcvr| resp _ '5xx ',err]. "Report as error"	aBool and:[resp size > 0 and:[resp first ~= $2]]] whileTrue:[		(self confirm:('Error storing ',fileNameOnServer,' on the server.\(',resp,',)\Retry operation?') withCRs) ifFalse:[^resp].	].	^resp! !!ServerDirectory methodsFor: 'updates' stamp: 'ar 11/24/1998 13:52' prior: 35105631!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2075)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'ar 11/24/1998 13:53' prior: 35108119!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!StandardFileStream methodsFor: 'access' stamp: 'ar 11/24/1998 14:00'!localName	^ name ifNotNil: [(name findTokens: FileDirectory pathNameDelimiter asString) last]! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/24/1998 13:41' prior: 37146530!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]] fixTemps! !'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 3:32:58 pm'!FormCanvas subclass: #BalloonCanvas	instanceVariableNames: 'transform colorTransform transformStack engine aaLevel '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonEngine	instanceVariableNames: 'workBuffer span bitBlt clipRect destOffset externals aaLevel colorTransform '	classVariableNames: 'BezierStats BufferCache CacheProtect Counts Debug Times '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!JPEGReadWriter subclass: #FlashJPEGDecoder	instanceVariableNames: 'eoiSeen streaming '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player spriteOwners stepTime frameRate frame activeMorphs passiveMorphs activeFont textOffset textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList streamingSound '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashStreamingSound	instanceVariableNames: 'mixFmt stereo samplingRate bitsPerSample sampleCount compressed firstFrame frameNumber buffers '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!MatrixTransformMorph subclass: #FlashMorph	instanceVariableNames: 'colorTransform '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashCharacterMorph	instanceVariableNames: 'id stepTime frame renderTime vData mData dData cmData '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'events sounds '	classVariableNames: 'ActionHelpText '	poolDictionaries: ''	category: 'MM-Flash-Morphs'!SystemWindow subclass: #FlashPlayerWindow	instanceVariableNames: 'startButton stopButton progress '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!BorderedMorph subclass: #FlashProgressMorph	instanceVariableNames: 'value progressColor lastValue '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashSpriteMorph	instanceVariableNames: 'playing maxFrames loadedFrames frameNumber stepTime damageRecorder sounds actions labels '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashSpriteMorph subclass: #FlashPlayerMorph	instanceVariableNames: 'activationKeys activeMorphs localBounds sourceUrl progressValue '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:28'!flush	"Force all pending primitives onscreen"	engine ifNotNil:[engine flush].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:05' prior: 36773419!ensuredEngine	^engine ifNil:[		engine _ BalloonEngine new.		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine colorTransform: colorTransform.		engine].! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 15:28' prior: 36773979!copy	self flush.	^super copy resetEngine! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 14:47'!copyAALevel: newAALevel	(newAALevel = self aaLevel) ifTrue:[^self].	^self copy aaLevel: newAALevel! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 14:49'!copyColorTransform: aColorTransform	^self copy colorTransformBy: aColorTransform! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/24/1998 15:16' prior: 36777180!drawCompressedShape: compressedShape	"Draw a compressed shape"	self ensuredEngine		drawCompressedShape: compressedShape		transform: transform.! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform	aColorTransform ifNil:[^self].	colorTransform 		ifNil:[colorTransform _ aColorTransform]		ifNotNil:[colorTransform _ colorTransform composedWithLocal: aColorTransform]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform while: aBlock	"Incorporate the local transformation in the receiver while evaluating aBlock"	| result |	aColorTransform ifNil:[^aBlock value: self].	transformStack addLast: colorTransform.	self colorTransformBy: aColorTransform.	result _ aBlock value: self.	colorTransform _ transformStack removeLast.	^result! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:27'!flush	"Force all pending primitives onscreen"! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:22' prior: 36495156!reset	workBuffer ifNil:[workBuffer _ self class allocateOrRecycleBuffer: 10000].	self primInitializeBuffer: workBuffer.	self primSetAALevel: self aaLevel.	self primSetOffset: destOffset.	self primSetClipRect: clipRect.	self primSetColorTransform: colorTransform.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/24/1998 15:23' prior: 36498872!registerFill: aFillStyle transform: aTransform	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle pixelValue32].	aFillStyle isGradientFill ifTrue:[		^self doAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill			matrix: aTransform.		].	^0! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform	^colorTransform! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 15:23'!primSetColorTransform: cTransform	<primitive: 'gePrimitiveSetColorTransform'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetColorTransform'].	^nil "If not supported"! !!Cursor class methodsFor: 'constants' stamp: 'ar 11/18/1998 15:33'!webLink	"Return a cursor that can be used for emphasizing web links"	"Cursor webLink showWhile: [Sensor waitButton]"	^ (CursorWithMask extent: 16@16			fromArray: #(3072 4608 4608 4608 4608 5046 4681 29257 37449 37449 32769 32769 49155 16386 24582 16380 )			offset: -5@0) setMaskForm:		(Form extent: 16@16 			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])			offset: 0@0).! !!FlashButtonMorph class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:58'!initialize	"FlashButtonMorph initialize"	ActionHelpText _ Dictionary new.	#(	(getURL:window: 'Jump to URL')		(gotoFrame: 'Continue playing')		(gotoLabel: 'Continue playing')		(gotoNextFrame 'Continue playing')		(gotoPrevFrame 'Continue playing')		(actionPlay 'Continue playing')		(actionStop 'Stop playing')		(stopSounds 'Stop all sounds')		(toggleQuality 'Toggle display quality')	) do:[:spec| ActionHelpText at: spec first put: spec last].! !!FlashColorTransform methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:01' prior: 36849353!initialize	rMul _ bMul _ gMul _ aMul _ 1.0.	rAdd _ bAdd _ gAdd _ aAdd _ 0.0.! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 14:54'!composedWithGlobal: aColorTransform	^aColorTransform composedWithLocal: self.! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 14:57'!composedWithLocal: aColorTransform	| cm |	cm _ self clone.	cm rAdd: self rAdd + (aColorTransform rAdd * self rMul).	cm rMul: self rMul * aColorTransform rMul.	cm gAdd: self gAdd + (aColorTransform gAdd * self gMul).	cm gMul: self gMul * aColorTransform gMul.	cm bAdd: self bAdd + (aColorTransform bAdd * self bMul).	cm bMul: self bMul * aColorTransform bMul.	cm aAdd: self aAdd + (aColorTransform aAdd * self aMul).	cm aMul: self aMul * aColorTransform aMul.	^cm! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 15:06'!localColorToGlobal: aColor	^Color		r: (aColor red * self rMul + self rAdd)		g: (aColor green * self gMul + self gAdd)		b: (aColor blue * self bMul + self bAdd)		alpha: (aColor alpha * self aMul + self aAdd)! !!FlashColorTransform methodsFor: 'printing' stamp: 'ar 11/24/1998 14:40'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		cr; nextPutAll:' r * '; print: rMul; nextPutAll:' + '; print: rAdd;		cr; nextPutAll:' g * '; print: gMul; nextPutAll:' + '; print: gAdd;		cr; nextPutAll:' b * '; print: bMul; nextPutAll:' + '; print: bAdd;		cr; nextPutAll:' a * '; print: aMul; nextPutAll:' + '; print: aAdd;		nextPut:$).! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 11/18/1998 21:25'!isStreaming	"Subclasses may override this"	^false! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:41' prior: 36852429!processFile	"Read and process the entire file"	self processHeader ifFalse:[^nil].	self processFileContents.! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/19/1998 00:29'!processFileContents	"Process the contents of the flash file.	Assume that the header has been read before."	| time |	time _ Time millisecondsToRun:[	self isStreaming ifTrue:[		"Don't show progress for a streaming connection.		Note: Yielding is done someplace else."		[self processTagFrom: stream] whileTrue.	] ifFalse:[		'Reading file' displayProgressAt: Sensor cursorPoint			from: 1 to: 100			during:[:theBar|		[self processTagFrom: stream] whileTrue:[			theBar value: (stream position * 100 // stream size).			stream atEnd ifTrue:[				log ifNotNil:[					log cr; nextPutAll:'Unexpected end of data (no end tag)'.					self flushLog].				^self]].		].	].	(stream respondsTo: #close) ifTrue:[stream close].	].	Transcript cr; print: time / 1000.0; show:' secs to read file'! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 21:59' prior: 36852967!processHeader	"Read header information from the source stream.	Return true if successful, false otherwise."	| version twipsFrameSize frameRate frameCount |	self processSignature ifFalse:[^false].	version _ stream nextByte.	"Check for the version supported"	version > self maximumSupportedVersion ifTrue:[^false].	dataSize _ stream nextLong.	"Check for the minimal file size"	dataSize < 21 ifTrue:[^false].	twipsFrameSize _ stream nextRect.	self recordGlobalBounds: twipsFrameSize.	frameRate _ stream nextWord / 256.0.	self recordFrameRate: frameRate.	frameCount _ stream nextWord.	self recordFrameCount: frameCount.	log ifNotNil:[		log cr; nextPutAll:'------------- Header information --------------'.		log cr; nextPutAll:'File version		'; print: version.		log cr; nextPutAll:'File size			'; print: dataSize.		log cr; nextPutAll:'Movie width		'; print: twipsFrameSize extent x // 20.		log cr; nextPutAll:'Movie height	'; print: twipsFrameSize extent y // 20.		log cr; nextPutAll:'Frame rate		'; print: frameRate.		log cr; nextPutAll:'Frame count	'; print: frameCount.		log cr; cr.		self flushLog].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/20/1998 00:24' prior: 37030994!processShapesFrom: data	"Process a new shape"	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 11/20/1998 02:47' prior: 37031632!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self flag: #wrongSpec.	"From news://forums.macromedia.com/macromedia.open-swfIt is an error in the spec. There can be up to 255 characters in run. Thehigh bit does not mean anything. The text record type 0 and type 1 is poorlydescribed. The real format is that all of the info in a 'text record type 1'is always followed by the info in a 'text record type 2'. Note the high bitof 'text record type 1' is reserved and should always be zero."	self processGlyphStateChange: flags from: data.	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self processGlyphEntries: flags from: data.	"Old stuff - which is according to the f**cking spec"	"(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	]."	^true! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 11/24/1998 14:22' prior: 37032546!processButtonRecords: id from: data cxForm: haveCxForm	| flags state characterId layer matrix cxForm |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		haveCxForm ifTrue:[cxForm _ data nextColorMatrix].		self recordButton: id 			character: characterId 			state: state 			layer: layer 			matrix: matrix			colorTransform: cxForm].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:32' prior: 36863946!processActionGetURL: data	| length position urlString winString |	length _ data nextWord.	position _ data position.	urlString _ data nextString.	winString _ data nextString.	data position = (position + length) ifFalse:[		self halt.		data position: position.		^self processUnknownAction: data].	log ifNotNil:[		log 			nextPutAll:' url='; print: urlString;			nextPutAll:', win='; print: winString].	^Message selector: #getURL:window: arguments: (Array with: urlString with: winString)! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:31' prior: 37033054!processActionGotoLabel: data	| length label |	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39' prior: 36865374!processActionPlay: data	^Message selector: #actionPlay! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39' prior: 36866585!processActionStop: data	^Message selector: #actionStop! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:46'!createSoundBuffersOfSize: numSamples stereo: stereo	| channels buffers |	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	^buffers! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:55'!createSoundFrom: soundStreams stereo: stereo samplingRate: samplingRate	| sound channels buffers |	buffers _ soundStreams collect:[:s| s contents].	channels _ stereo ifTrue:[2] ifFalse:[1].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) samplingRate: samplingRate.		sound setLoudness: 1.0.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:47' prior: 37033668!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| buffers |	buffers _ self createSoundBuffersOfSize: numSamples stereo: stereo.	self decompressSound: aByteArray 		stereo: stereo 		samples: numSamples 		rate: samplingRate 		into: buffers.	^self createSoundFrom: buffers stereo: stereo samplingRate: samplingRate! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:41'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate into: buffers	| data nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/20/1998 22:37'!processSoundStreamHeadFrom: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	self flag: #wrongSpec.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32' prior: 37036051!processDefineBitsJPEG2: data	| id image decoder |	id _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:11' prior: 37036356!processDefineBitsJPEG3: data	"TODO: Read zlib compressed alpha."	| id image decoder alphaOffset dataOffset |	id _ data nextWord.	self flag: #wrongSpec.	alphaOffset _ data nextWord.	dataOffset _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	"Note: We must read the zlib compressed alpha values here."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12' prior: 37036837!processDefineBitsLossless2: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12' prior: 37037130!processDefineBitsLossless: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:41' prior: 37037422!processDefineButton2: data	| id flags actions condition actionOffset |	data hasAlpha: true.	id _ data nextWord.	self recordDefineButton: id.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	self flag: #wrongSpec.	actionOffset _ data nextWord.	self processButtonRecords: id from: data cxForm: true.	[actionOffset = 0] whileFalse:[		actionOffset _ data nextWord.		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processDefineButtonCxform: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/21/1998 13:56' prior: 36873113!processDefineButtonSound: data	| id soundID soundInfo |	id _ data nextWord.	#(0 mouseEnter mouseDown 3) do:[:state|		soundID _ data nextWord.		soundID = 0 ifFalse:[			soundInfo _ self processSoundInfoFrom: data.			self recordButton: id sound: soundID info: soundInfo state: state]].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31'!processDefineFont2: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:34'!processDefineFontInfo: data	| id nameLength fontName flags charMap |	id _ data nextWord.	nameLength _ data nextByte.	fontName _ (data nextBytes: nameLength) asString.	flags _ data nextByte.	charMap _ data upToEnd.	self recordFont: id name: fontName charMap: charMap wide: (flags anyMask: 1).	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:29' prior: 36874615!processDefineSound: data	| flags sampleCount sampleData id stereo bitsPerSample rate compressed sound |	id _ data nextWord.	flags _ data nextByte.	stereo _ (flags anyMask: 1).	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	rate _ #( 5512 11025 22050 44100 ) at: (flags >> 2 bitAnd: 3)+1.	compressed _ flags anyMask: 16.	sampleCount _ data nextULong.	sampleData _ data upToEnd.	compressed ifTrue:[		self isStreaming ifFalse:[Cursor wait show].		sound _ self decompressSound: sampleData 						stereo: stereo 						samples: sampleCount 						rate: rate.		self isStreaming ifFalse:[Cursor normal show].	] ifFalse:[		self halt.		sound _ nil.	].	self recordSound: id data: sound.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:42' prior: 37038585!processDefineSprite: data	| id frameCount |	id _ data nextWord.	self flag: #wrongSpec.	frameCount _ data nextWord.	self recordBeginSprite: id frames: frameCount.	[self processTagFrom: data] whileTrue.	self recordEndSprite: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 22:57' prior: 36875674!processDoAction: data	| actions |	actions _ self processActionRecordsFrom: data.	self recordFrameActions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31' prior: 36876173!processFreeCharacter: data	| id |	id _ data nextWord.	data atEnd ifFalse:[self halt].	self recordFreeCharacter: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32' prior: 36876379!processJPEGTables: data	jpegDecoder _ FlashJPEGDecoder new.	jpegDecoder isStreaming: self isStreaming.	jpegDecoder decodeJPEGTables: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processNameCharacter: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43' prior: 37039109!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	self flag: #checkThis.	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43' prior: 36878046!processRemoveObject2: data	| depth |	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: nil depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:37' prior: 37040015!processSoundStreamBlock: data	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:21' prior: 36879207!processSoundStreamHead2: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:22' prior: 36879723!processSoundStreamHead: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/20/1998 22:11' prior: 36881349!dispatch: argument on: aKey in: aTable ifNone: exceptionBlock	| selector |	(aKey < 1 or:[aKey > aTable size]) ifTrue:[^exceptionBlock value].	selector _ aTable at: aKey.	^self perform: selector with: argument! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 22:35'!recordFont: id name: fontName charMap: charMap wide: isWide	"Record the name and character mapping of the font for the given id.	If isWide is set then the font is a 16bit Unicode font."! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:23'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	"Define the character to use for a button.		buttonId:	global ID used for the button		characterId:	ID of the character defining the shape for the button		state:		bit mask for when to use the character						1 - default (e.g. no other state applies)						2 - display when the mouse is over the button but not pressed						4 - display when the button is pressed						8 - the area in which the mouse is supposed to be 'over' the button		layer:		UNKNOWN.		matrix:		Transformation to apply to the character. (Guess!!)"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:10' prior: 36891029!initializeTagTable	"Create and return a new SWF tag table"	"FlashFileReader initializeTagTable"	TagTable _ Array new: 50.	TagTable atAllPut: #processUnknown:.	#(	(processEnd:					0)	(processShowFrame:			1)	(processDefineShape:		2)	(processFreeCharacter:		3)	(processPlaceObject:			4)	(processRemoveObject:		5)	(processDefineBits:			6)	(processDefineButton:		7)	(processJPEGTables:			8)	(processSetBackgroundColor:	9)	(processDefineFont:			10)	(processDefineText:			11)	(processDoAction:			12)	(processDefineFontInfo:		13)	"Event sound tags."	(processDefineSound:		14)	(processStartSound:			15)	(processDefineButtonSound:	17)	(processSoundStreamHead:	18)	(processSoundStreamBlock:	19)	(processDefineBitsLossless:	20)	"A bitmap using lossless zlib compression."	(processDefineBitsJPEG2:		21)	"A bitmap using an internal JPEG compression table"	(processDefineShape2:		22)	(processDefineButtonCxform:	23)	(processProtect:				24)	"This file should not be importable for editing."	"These are the new tags for Flash 3."	(processPlaceObject2:			26)	"The new style place w/ alpha color transform and name."	(processRemoveObject2:		28)	"A more compact remove object that omits the character tag (just depth)."	(processDefineShape3:		32)	"A shape V3 includes alpha values."	(processDefineText2:			33) "A text V2 includes alpha values."	(processDefineButton2:		34)	"A button V2 includes color transform) alpha and multiple actions"	(processDefineBitsJPEG3:		35)	"A JPEG bitmap with alpha info."	(processDefineBitsLossless2:	36)	"A lossless bitmap with alpha info."	(processDefineSprite:		39) "Define a sequence of tags that describe the behavior of a sprite."	(processNameCharacter:		40) "Name a character definition, character id and a string, (used for buttons) bitmaps, sprites and sounds)."	(processFrameLabel:			43) "A string label for the current frame."	(processSoundStreamHead2:	45) "For lossless streaming sound, should not have needed this..."	(processDefineMorphShape:	46) "A morph shape definition"	(processDefineFont2:			48)	) do:[:spec|			TagTable at: spec last+1 put: spec first.	].! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/24/1998 15:01' prior: 37041184!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits) / 256.0.		transform gMul: (self nextSignedBits: nBits) / 256.0.		transform bMul: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits) / 256.0]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits) / 256.0.		transform gAdd: (self nextSignedBits: nBits) / 256.0.		transform bAdd: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits) / 256.0]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/20/1998 00:29' prior: 37042031!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a21: (self nextSignedBits: nBits) / 65536.0.		transform a12: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 21:33' prior: 37042895!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	self isStreaming ifFalse:[Cursor wait show].	image _ self nextImage.	self isStreaming ifFalse:[Cursor normal show].	^image! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 23:25'!nextImageDitheredToDepth: depth	"Overwritten to yield every now and then."	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		"self isStreaming ifTrue:[Processor yield]."		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:32'!isStreaming	^streaming! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:31'!isStreaming: aBool	streaming _ aBool! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/18/1998 23:29' prior: 36914057!replaceLastData: newData at: frameNumber	| kf |	lastIndex _ nil.	kf _ kfList last.	(kf stop = kf start)		ifTrue:[kfList removeLast]		ifFalse:[kf stop: kf stop-1].	^self at: frameNumber put: newData! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/21/1998 00:30' prior: 37049724!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	spriteOwners _ IdentityDictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.	streamingSound _ FlashStreamingSound new.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 20:45' prior: 36917358!processFile	"Read and process the entire file"	super processFile.	player loadInitialFrame.	player startPlaying.	player open.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 21:54'!processFileAsync	"Read and process the entire file"	self processHeader ifFalse:[^nil].	player sourceUrl:'dummy'.	[self processFileContents] fork.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:44'!processFileAsync: aPlayer	"Read and process the entire file"	player _ aPlayer.	super processFile.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/21/1998 00:50'!processFileContents	super processFileContents.	self flushStreamingSound.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41' prior: 36918630!recordNextChar: glyphIndex advanceWidth: advance	| shape transform |	(activeFont includesKey: glyphIndex) ifTrue:[		shape _ (activeFont at: glyphIndex) fullCopy reset.		"Must include the textMorph's transform here - it might be animated"		transform _  ((MatrixTransform2x3 withOffset: textOffset) 							setScale: (textHeight@textHeight) / 1024.0).		transform _ transform composedWithGlobal: textMorph transform.		shape transform: transform.		shape color: textMorph color.		textMorph addMorphBack: shape.].	textOffset _ textOffset + (advance@0).! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:46' prior: 36919100!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height	fontId ifNotNil:[activeFont _ fonts at: fontId].	height ifNotNil:[textHeight _ height].	xOffset ifNotNil:[textOffset _ xOffset @ textOffset x].	yOffset ifNotNil:[textOffset _ textOffset x @ yOffset].	color ifNotNil:[textMorph color: color].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 00:50' prior: 36919556!recordTextEnd: id	textMorph submorphs isEmpty ifFalse:[		textMorph allMorphsDo:[:m| m color: textMorph color].		textMorph transform: nil.		textMorph id: id.		textMorph stepTime: stepTime.		textMorph lockChildren.		shapes at: id put: textMorph].	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41' prior: 37051084!recordTextStart: id bounds: bounds matrix: matrix	textOffset _ 0@0.	textMorph _ FlashTextMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.	matrix ifNotNil:[textMorph transform: matrix].! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/18/1998 21:36' prior: 36925855!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean	| fillStyle ramp origin direction normal |	ramp _ colorRampArray collect:[:assoc| (assoc key / 255.0) -> assoc value].	origin _ gradientMatrix localPointToGlobal: (aBoolean ifFalse:[0@0] ifTrue:[-16384@0]).	direction _ (gradientMatrix localPointToGlobal: (16384@0)) - origin.	normal _ (gradientMatrix localPointToGlobal: (0@16384)) - origin.	fillStyle _ GradientFillStyle ramp: ramp.	fillStyle origin: origin.	fillStyle direction: direction.	fillStyle normal: normal.	fillStyle radial: aBoolean not.	fillStyle pixelRamp. "Force creation beforehand"	fillStyles at: fillIndex put: fillStyle.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30' prior: 37053009!recordBeginSprite: id frames: frameCount	| sprite |	sprite _ FlashSpriteMorph new.	sprite maxFrames: frameCount.	sprite stepTime: stepTime.	spriteOwners at: sprite put: (		Array with: player 			with: frame			with: activeMorphs			with: passiveMorphs).	player _ sprite.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:35' prior: 37053442!recordEndSprite: id	| shape sprite |	sprite _ player.	player _ (spriteOwners at: sprite) at: 1.	frame _ (spriteOwners at: sprite) at: 2.	activeMorphs _ (spriteOwners at: sprite) at: 3.	passiveMorphs _ (spriteOwners at: sprite) at: 4.	spriteOwners removeKey: sprite.	sprite loadInitialFrame.	shape _ FlashCharacterMorph withAll: (Array with: sprite).	shape id: id.	shape isSpriteHolder: true.	shape stepTime: stepTime.	shapes at: id put: shape.	shape lockChildren.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames	player maxFrames: maxFrames! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 00:32' prior: 36927633!recordFrameRate: fps	frameRate _ fps.	fps > 0.0 ifTrue:[stepTime _ (1000.0 / fps) rounded].	player stepTime: stepTime.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 20:42' prior: 36927807!recordGlobalBounds: bounds	player localBounds: bounds.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 02:11' prior: 37054323!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:51' prior: 37054995!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorTransform	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorTransform: colorTransform atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 01:57' prior: 37056002!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[#()]) do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	Transcript cr; nextPutAll:'Shape (id = '; print: id; nextPutAll:' depth = '; print: depth; nextPutAll:') not removed in frame '; print: frame; endEntry.	^nil! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30' prior: 37056687!recordShowFrame	player loadedFrames: frame.	frame _ frame + 1.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/20/1998 01:04' prior: 36929874!createSound: id info: info	| theSound loops |	theSound _ sounds at: id ifAbsent:[^nil].	loops _ info loopCount.	loops <= 1 ifTrue:[^theSound].	^RepeatingSound repeat: theSound count: loops! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/20/1998 01:59' prior: 37058538!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self halt].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter sendAll: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave sendAll: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown sendAll: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp sendAll: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut sendAll: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:24'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	| button children shape |	button _ buttons at: buttonId ifAbsent:[^self halt].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[^nil].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape depth: layer.	shape transform: matrix.	shape colorTransform: cxForm.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/21/1998 02:20' prior: 37060639!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self halt].	theSound _ self createSound: soundId info: soundInfo.	theSound ifNil:[^self].	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'testing' stamp: 'ar 11/18/1998 21:37'!isStreaming	^player isStreaming! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 14:08'!flushStreamingSound	| sound |	streamingSound buffers ifNil:[^self].	streamingSound buffers first position = 0 ifFalse:[		sound _ self createSoundFrom: streamingSound buffers					stereo: streamingSound stereo					samplingRate: streamingSound samplingRate.		player addSound: sound at: streamingSound firstFrame].	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.	streamingSound buffers do:[:s| s reset].! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38' prior: 36929487!recordSound: id data: aSampledSound	aSampledSound ifNotNil:[sounds at: id put: aSampledSound]! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:47'!recordSoundStreamBlock: data	streamingSound frameNumber + 1 = frame 		ifFalse:[self flushStreamingSound].	self decompressSound: data					stereo: streamingSound stereo 					samples: streamingSound sampleCount 					rate: streamingSound samplingRate					into: streamingSound buffers.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:53'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed	streamingSound buffers isNil ifFalse:[self flushStreamingSound].	streamingSound mixFmt: mixFmt.	streamingSound stereo: stereo.	streamingSound bitsPerSample: bitsPerSample.	streamingSound sampleCount: sampleCount.	streamingSound compressed: compressed.	streamingSound samplingRate: (frameRate * sampleCount) truncated.	streamingSound buffers: (self createSoundBuffersOfSize: sampleCount stereo: stereo).	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38' prior: 36929652!recordStartSound: id info: info	| theSound |	theSound _ self createSound: id info: info.	theSound ifNotNil:[player addSound: theSound at: frame].! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!isStreaming	^player isStreaming! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:33'!loadedFrames	^player loadedFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!maxFrames	^player maxFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!progressValue	^player progressValue! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:45'!startPlaying	player startPlaying! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	player stopPlaying! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!bitsPerSample	^bitsPerSample! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!bitsPerSample: aNumber	bitsPerSample _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers	^buffers! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers: anArray	buffers _ anArray! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed	^compressed! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed: aBool	compressed _ aBool! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame	^firstFrame! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame: frame	firstFrame _ frame.! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber	^frameNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber: aNumber	frameNumber _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt	^mixFmt! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt: aNumber	mixFmt _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount	^sampleCount! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount: aNumber	sampleCount _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate	^samplingRate! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate: aNumber	samplingRate _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo	^stereo! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo: aBool	stereo _ aBool! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/18/1998 14:03' prior: 36415137!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r3.	r2 _ (self invertPoint: 0@1) - r3.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^false! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 11/18/1998 21:53'!isStepping	"Return true if the receiver is currently stepping in its world"	| world |	world _ self world.	^world isNil		ifTrue:[false]		ifFalse:[world isStepping: self]! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:23' prior: 36937151!lockChildren	submorphs do:[:m| 		m isMouseSensitive ifFalse:[m lock]].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform	^colorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^true! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/24/1998 14:49' prior: 36938430!canvasForSubmorphs: canvasForMe	| canvas aaLevel |	canvas _ (super canvasForSubmorphs: canvasForMe).	colorTransform ifNotNil:[canvas _ canvas copyColorTransform: colorTransform].	aaLevel _ self defaultAALevel.	aaLevel isNil		ifTrue:[^canvas]		ifFalse:[^canvas copyAALevel: aaLevel]! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/24/1998 14:20' prior: 36939518!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	self transform: (self transformFrom: self world).! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/18/1998 14:04' prior: 36939984!justDroppedInto: newOwner event: evt	| ownerTransform |	ownerTransform _ (newOwner transformFrom: newOwner world).	ownerTransform isIdentity ifFalse:[		ownerTransform _ ownerTransform asMatrixTransform2x3 inverseTransformation.		self transform: (self transform composedWithGlobal: ownerTransform).	].	super justDroppedInto: newOwner event: evt.! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder	^self hasProperty: #spriteHolder! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder: aBoolean	aBoolean		ifTrue:[self setProperty: #spriteHolder toValue: true]		ifFalse:[self removeProperty: #spriteHolder]! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:50'!colorTransform: aColorTransform atFrame: frameNumber	self colorTransformData at: frameNumber put: aColorTransform! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformAtFrame: frameNumber	^self colorTransformData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformData	^cmData	"^self keyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/24/1998 14:52' prior: 37045203!stepToFrame: frameNumber	| m wasVisible isVisible noTransform cm |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		cm _ self colorTransformAtFrame: frame.		noTransform _ (m = transform) and:[colorTransform = cm].		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		self colorTransform: cm.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].	(isVisible ~~ wasVisible and:[self isSpriteHolder])		ifTrue:[self activateSprites: isVisible].! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 11/24/1998 14:34'!activateSprites: aBool	submorphs do:[:m|		(m isFlashMorph and:[m isFlashSprite]) ifTrue:[			aBool 				ifTrue:[m startPlaying]				ifFalse:[m stopPlaying].		].	].! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:02'!ownerSprite	"Return the sprite owning the receiver.	The owning sprite is responsible for executing	the actions associated with the button."	| sprite |	sprite _ self.	[sprite isNil] whileFalse:[		(sprite isFlashMorph and:[sprite isFlashSprite]) ifTrue:[^sprite].		sprite _ sprite owner].	^nil! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:03' prior: 36947707!trackAsMenu: aBoolean	"Currently unused"	aBoolean 		ifTrue:[self setProperty: #trackAsMenu toValue: true]		ifFalse:[self removeProperty: #trackAsMenu].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 15:32'!executeActions: type	| rcvr |	(events isNil or:[events isEmpty]) ifTrue:[^self].	rcvr _ self ownerSprite.	Sensor leftShiftDown ifTrue:[self inspect].	rcvr isNil ifTrue:[^self].	(events at: type ifAbsent:[^self]) do:[:action|		action sentTo: rcvr.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:32'!executeSounds: type	| sound |	(sounds isNil or:[sounds isEmpty]) ifTrue:[^self].	sound _ sounds at: type ifAbsent:[^self].	sound isPlaying ifFalse:[sound play].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/19/1998 20:32' prior: 37047337!handlesMouseOver: evt	"Handle mouse events only if I am visible,"	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30' prior: 37047604!mouseDown: evt	self lookEnable: #(pressLook) disable:#().	self executeSounds: #mouseDown.	self executeActions: #mouseDown.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30' prior: 37047957!mouseEnter: evt	self lookEnable: #(overLook) disable:#(pressLook defaultLook).	evt hand needsToBeDrawn ifFalse:[Cursor webLink show].	self executeSounds: #mouseEnter.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseEnterDown]		ifFalse:[self executeActions: #mouseEnter].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30' prior: 37048332!mouseLeave: evt	self lookEnable: #(defaultLook) disable:#(pressLook overLook).	evt hand needsToBeDrawn ifFalse:[Cursor normal show].	self executeSounds: #mouseLeave.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseLeaveDown]		ifFalse:[self executeActions: #mouseLeave].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30' prior: 37048508!mouseUp: evt	self lookEnable:#(defaultLook overLook) disable:#(pressLook).	self executeSounds: #mouseUp.	self executeActions: #mouseUp.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 02:09'!on: eventName sendAll: actions	"Note: We handle more than the standard Morphic events here"	| actionList |	events ifNil:[events _ Dictionary new].	self analyzeActionsForBalloonHelp: actions.	actionList _ events at: eventName ifAbsent:[#()].	actionList _ actionList, actions.	events at: eventName put: actionList.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/24/1998 15:14'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^true! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^true! !!FlashButtonMorph methodsFor: 'balloon help' stamp: 'ar 11/20/1998 15:15'!analyzeActionsForBalloonHelp: actionList	| helpText |	actionList do:[:msg|		helpText _ ActionHelpText at: msg selector ifAbsent:[nil].		helpText ifNotNil:[self setBalloonText: helpText].	].! !!FlashButtonMorph methodsFor: 'printing' stamp: 'ar 11/21/1998 01:36'!printOn: aStream	super printOn: aStream.	events ifNil:[^self].	aStream nextPut:$[.	events keys do:[:k| aStream print: k; space].	aStream nextPut: $].! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34'!addProgressIndicator	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!addProgressIndicator: aValueHolder	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress value: aValueHolder.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34' prior: 37069609!adjustBookControls	| inner |	startButton ifNil: [^ self].	startButton align: startButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	progress ifNotNil:[		progress align: progress topLeft with: (startButton right @ inner top) + (10@0)].	stopButton align: stopButton topRight with: inner topRight - (16@4).! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:40'!collapseOrExpand	super collapseOrExpand.	isCollapsed ifTrue:[		startButton delete.		stopButton delete.		progress ifNotNil:[progress delete].	] ifFalse:[		self addMorph: startButton.		self addMorph: stopButton.		progress ifNotNil:[self addMorph: progress].		self adjustBookControls.	].! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:45' prior: 37070056!initialize	| aFont |	super initialize.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (startButton _ SimpleButtonMorph new borderWidth: 0;			label: 'play' font: aFont; color: Color transparent;			actionSelector: #startPlaying; target: self).	startButton setBalloonText: 'continue playing'.	self addMorph: (stopButton _ SimpleButtonMorph new borderWidth: 0;			label: 'stop' font: aFont; color: Color transparent;			actionSelector: #stopPlaying; target: self).	stopButton setBalloonText: 'stop playing'.	startButton submorphs first color: Color blue.	stopButton submorphs first color: Color red.	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 21:10'!model: aFlashPlayerModel	aFlashPlayerModel isStreaming		ifTrue:[self addProgressIndicator: aFlashPlayerModel progressValue].	^super model: aFlashPlayerModel! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:46'!startPlaying	model startPlaying! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	model stopPlaying! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor	^progressColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor: aColor	progressColor _ aColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:09'!value	^value! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!value: aModel	value removeDependent: self.	value _ aModel.	value addDependent: self.! !!FlashProgressMorph methodsFor: 'drawing' stamp: 'ar 11/18/1998 22:58'!drawOn: aCanvas	| width inner |	super drawOn: aCanvas.	inner _ self innerBounds.	width _ (inner extent x * lastValue) truncated min: inner extent x.	aCanvas fillRectangle: (inner origin extent: width @ inner extent y) color: progressColor.! !!FlashProgressMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 22:59'!initialize	super initialize.	progressColor _ Color green.	value _ ValueHolder new.	value contents: 0.0.	value addDependent: self.	lastValue _ 0.0.! !!FlashProgressMorph methodsFor: 'updating' stamp: 'ar 11/18/1998 23:04'!update: aSymbol	aSymbol == #contents ifTrue:[		lastValue _ value contents.		self changed]! !!FlashShapeMorph methodsFor: 'drawing' stamp: 'ar 11/18/1998 14:11' prior: 36963800!drawOn: aCanvas 	"Display the receiver."	| aaLevel |	shape ifNil:[^aCanvas frameRectangle: self bounds color: Color black.].	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		aaLevel _ self defaultAALevel.		aaLevel ifNotNil:[balloonCanvas aaLevel: aaLevel].		balloonCanvas drawCompressedShape: shape.	].! !!FlashShapeMorph methodsFor: 'geometry' stamp: 'ar 11/18/1998 13:59' prior: 36964041!computeBounds	bounds _ self transform localBoundsToGlobal: (shape bounds).	fullBounds _ nil.! !!FlashSpriteMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:07' prior: 37071476!initialize	super initialize.	playing _ false.	loadedFrames _ 0.	maxFrames _ 1.	frameNumber _ 1.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09' prior: 37072393!frameNumber	^frameNumber! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09' prior: 37072494!frameNumber: frame	^self stepToFrame: frame! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames	^loadedFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames: n	loadedFrames _ n.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames	^false! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames: aBool! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames	^maxFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames: n	maxFrames _ n! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!startPlaying	"Start playing from the current frame"	playing _ true.	loadedFrames = 0 ifTrue:[^nil].	frameNumber >= maxFrames ifTrue:[self frameNumber: 1].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:19' prior: 37072813!step	playing ifFalse:[^self].	self stepForward.	damageRecorder _ nil. "Insurance"! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!stepBackward	frameNumber > 1		ifTrue:[self frameNumber: frameNumber - 1]		ifFalse:[self frameNumber: loadedFrames].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:17'!stepForward	frameNumber < maxFrames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[self loopFrames			ifTrue:[self frameNumber: 1]			ifFalse:[self stopPlaying]].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09' prior: 37073181!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:10'!stopPlaying	"Stop playing at the current frame."	playing _ false.! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true - my children may be sensitive"	^true! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionPlay	self startPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionStop	"Stop playing at the current frame."	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10' prior: 37074838!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!executeActionsAt: frame	| actionList index msg result |	actionList _ actions at: frame ifAbsent:[^self].	index _ 1.	[index <= actionList size] whileTrue:[		msg _ actionList at: index.		result _ msg sentTo: self.		result ifNotNil:[index _ index + result].		index _ index + 1].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/20/1998 02:36' prior: 37075224!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."	| browser |	browser _ self getWebBrowser.	browser ifNotNil:[		browser jumpToUrl: urlString.		^nil].	"(self confirm: ('open a browser to view\',urlString,' ?') withCRs) ifTrue: [		browser _ Scamper new.		browser jumpToUrl: urlString.		browser openAsMorph	]."	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37075433!gotoFrame: frame	"Jump to the given frame"	self frameNumber: frame+1.	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37075579!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37075813!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37075965!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37076121!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet."	^loadedFrames >= frameNumber 		ifTrue:[nil]		ifFalse:[nActions].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37076595!stopSounds	"Stop all sounds"	SoundPlayer shutDown.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11' prior: 37076723!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."	^nil! !!FlashSpriteMorph methodsFor: 'private' stamp: 'ar 11/19/1998 22:37'!getWebBrowser	"Return a web browser if we're running in one"	| morph |	morph _ self. "I can't really be a web browser, can I?!!"	[morph isNil] whileFalse:[		morph isWebBrowser ifTrue:[^morph].		(morph hasProperty: #webBrowserView) ifTrue:[^morph model].		morph _ morph owner].	"Not in a browser"	^nil! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:53'!downloadState	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 23:09'!downloadStateIn: aScamper	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	"Wait until the first frame is there"	[loadedFrames = 0] whileTrue:[(Delay forMilliseconds: 100) wait].	aScamper invalidateLayout.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/20/1998 22:56' prior: 37062213!initialize	super initialize.	color _ Color white.	self loopFrames: false.	localBounds _ bounds.	activationKeys _ #().	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	progressValue _ ValueHolder new.	progressValue contents: 0.0.	self defaultAALevel: 2.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 20:31' prior: 37062529!loadInitialFrame	"Note: Must only be sent to a player if not in streaming mode"	self isStreaming ifTrue:[^self].	super loadInitialFrame.	activationKeys _ self collectActivationKeys: maxFrames.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 20:48' prior: 36951068!makeControls	| b r loopSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2.	r _ AlignmentMorph newRow.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #startPlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #stopPlaying).	r addMorphBack: (b fullCopy label: 'Next';			actionSelector: #stepForward).	r addMorphBack: (b fullCopy label: 'Prev';			actionSelector: #stepBackward).	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Loop';		actionSelector: #loopFrames:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'cache';		actionSelector: #enableCache:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	r addMorphBack: (b fullCopy label: 'Fastest'; 	actionSelector: #drawFastest).	r addMorphBack: (b fullCopy label: 'Medium';	actionSelector: #drawMedium).	r addMorphBack: (b fullCopy label: 'Nicest';		actionSelector: #drawNicest).	r addMorphBack: (b fullCopy label: '+10';		actionSelector: #jump10).	b target: self.	^ self world activeHand attachMorph: r! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 21:40'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 19:21'!sourceUrl: urlString	sourceUrl _ urlString! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:27' prior: 37063939!addMorph: aMorph	aMorph isFlashMorph ifFalse:[^super addMorph: aMorph].	aMorph isMouseSensitive		ifTrue:[self addMorphFront: aMorph]		ifFalse:[self addMorphBack: aMorph].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52' prior: 37064519!borderWidth	"Ignored here - only for keeping the window happy"	^0! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52' prior: 37064620!borderWidth: bw	"Ignored here - only for keeping the window happy"! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:46'!isStreaming	"Return true if we're in streaming mode"	^sourceUrl notNil! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:59'!loadedFrames: aNumber	self isStreaming ifTrue:[		activationKeys _ self collectActivationKeys: aNumber.		aNumber = 1 ifTrue:[			activeMorphs addAll: activationKeys first.			self changed].		progressValue contents: (aNumber asFloat / maxFrames).		"Give others a chance"		World == nil			ifTrue:[Processor yield]			ifFalse:[World doOneCycle].	].	loadedFrames _ aNumber.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 20:43' prior: 37064746!localBounds: newBounds	localBounds _ newBounds.	bounds _ (self position extent: newBounds extent // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:17'!loopFrames	^(self valueOfProperty: #loopFrames) ifNil:[false]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue	^progressValue! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue: aValueHolder	progressValue _ aValueHolder! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:17' prior: 36952615!aaLevel	^self defaultAALevel ifNil:[1]! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 20:27' prior: 36954504!canvasForSubmorphs: canvasForMe	^(canvasForMe copyClipRect: self bounds)		asBalloonCanvas transformBy: self transform; aaLevel: self aaLevel! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15' prior: 36954743!drawFastest	self defaultAALevel: 1.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15' prior: 36954861!drawMedium	self defaultAALevel: 2.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15' prior: 36954978!drawNicest	self defaultAALevel: 4.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 20:28' prior: 36955095!drawOn: aCanvas 	"Draw the background of the player"	| box |	box _ self bounds.	aCanvas fillRectangle: box color: color! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48' prior: 37065938!fullContainsPoint: pt	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^false].	^super fullContainsPoint: pt! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48' prior: 37066110!unlockedMorphsAt: pt addTo: mList	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^mList].	^super unlockedMorphsAt: pt addTo: mList! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 23:01'!stepToFrame: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	self executeActionsAt: frame.	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/18/1998 23:21'!collectActivationKeys: frame	"Note: Must only be called after a frame has been completed"	| vis lastKey |	vis _ Array new: frame.	vis atAllPut: #().	lastKey _ activationKeys size.	vis replaceFrom: 1 to: lastKey with: activationKeys startingAt: 1.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m activationKeys do:[:key|				key > lastKey ifTrue:[					vis at: key put: ((vis at: key) copyWith: m)				].			].		].	].	^vis! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/24/1998 14:18' prior: 35495318!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m pointFromWorld: self position].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !FlashButtonMorph initialize!FlashFileReader removeSelector: #readFile!FlashFileReader removeSelector: #readFile!FlashFileReader removeSelector: #recordSound:data:stereo:bitsPerSample:sampleCount:rate:compressed:!FlashFileReader removeSelector: #recordSound:data:stereo:bitsPerSample:sampleCount:rate:compressed:!FlashFileReader removeSelector: #recordFontName:id:!FlashFileReader removeSelector: #tagPlaceObject2:!FlashFileReader removeSelector: #tagPlaceObject2:!FlashFileReader removeSelector: #frameNumber!FlashFileReader removeSelector: #frameNumber!FlashFileReader removeSelector: #frameNumber:!FlashFileReader removeSelector: #frameNumber:!FlashFileReader removeSelector: #recordButton:character:state:layer:matrix:!FlashFileReader removeSelector: #recordButton:character:state:layer:matrix:!FlashMorphReader removeSelector: #recordButton:character:state:layer:matrix:!FlashMorphReader removeSelector: #recordButton:character:state:layer:matrix:!FlashMorphReader removeSelector: #processFile:!FlashMorphReader removeSelector: #processFile:!FlashPlayerModel removeSelector: #play!FlashPlayerModel removeSelector: #play!FlashPlayerModel removeSelector: #stop!FlashPlayerModel removeSelector: #stop!FlashPlayerModel removeSelector: #frames!FlashStreamingSound removeSelector: #data!FlashStreamingSound removeSelector: #leftBuffer:!FlashStreamingSound removeSelector: #leftBuffer!FlashStreamingSound removeSelector: #data:!FlashStreamingSound removeSelector: #rightBuffer:!FlashStreamingSound removeSelector: #rightBuffer!FlashCharacterMorph removeSelector: #colorMatrixData!FlashCharacterMorph removeSelector: #colorMatrixData!FlashCharacterMorph removeSelector: #colorMatrix:atFrame:!FlashCharacterMorph removeSelector: #colorMatrix:atFrame:!FlashCharacterMorph removeSelector: #colorMatrixAtFrame:!FlashCharacterMorph removeSelector: #colorMatrixAtFrame:!FlashButtonMorph removeSelector: #initialize!FlashButtonMorph removeSelector: #initialize!FlashButtonMorph removeSelector: #on:sendAll:to:!FlashButtonMorph removeSelector: #balloonText!FlashButtonMorph removeSelector: #checkJumpsIn:!FlashButtonMorph removeSelector: #on:send:to:withValue:!FlashButtonMorph removeSelector: #on:send:to:withValue:!FlashPlayerWindow removeSelector: #stop!FlashPlayerWindow removeSelector: #stop!FlashPlayerWindow removeSelector: #play!FlashPlayerWindow removeSelector: #play!FlashProgressMorph removeSelector: #changed:!FlashShapeMorph removeSelector: #containsPoint:!FlashSpriteMorph removeSelector: #executeActions:!FlashSpriteMorph removeSelector: #executeActions:!FlashSpriteMorph removeSelector: #frames!FlashSpriteMorph removeSelector: #frames!FlashSpriteMorph removeSelector: #stop!FlashSpriteMorph removeSelector: #stop!FlashSpriteMorph removeSelector: #frames:!FlashSpriteMorph removeSelector: #frames:!FlashSpriteMorph removeSelector: #play!FlashSpriteMorph removeSelector: #play!FlashPlayerMorph removeSelector: #actionPlay!FlashPlayerMorph removeSelector: #pause!FlashPlayerMorph removeSelector: #pause!FlashPlayerMorph removeSelector: #addActions:atFrame:!FlashPlayerMorph removeSelector: #addActions:atFrame:!FlashPlayerMorph removeSelector: #actionStop!FlashPlayerMorph removeSelector: #syncFrames:!FlashPlayerMorph removeSelector: #syncFrames:!FlashPlayerMorph removeSelector: #addSound:at:!FlashPlayerMorph removeSelector: #addSound:at:!FlashPlayerMorph removeSelector: #gotoLabel:!FlashPlayerMorph removeSelector: #gotoLabel:!FlashPlayerMorph removeSelector: #startPlaying!FlashPlayerMorph removeSelector: #wantsSteps!FlashPlayerMorph removeSelector: #wantsSteps!FlashPlayerMorph removeSelector: #isFrameLoaded:elseSkip:!FlashPlayerMorph removeSelector: #isFrameLoaded:elseSkip:!FlashPlayerMorph removeSelector: #actionTarget:!FlashPlayerMorph removeSelector: #actionTarget:!FlashPlayerMorph removeSelector: #loadedFrames!FlashPlayerMorph removeSelector: #gotoNextFrame!FlashPlayerMorph removeSelector: #gotoNextFrame!FlashPlayerMorph removeSelector: #play!FlashPlayerMorph removeSelector: #play!FlashPlayerMorph removeSelector: #collectActivationKeys!FlashPlayerMorph removeSelector: #collectActivationKeys!FlashPlayerMorph removeSelector: #addLabel:atFrame:!FlashPlayerMorph removeSelector: #addLabel:atFrame:!FlashPlayerMorph removeSelector: #stopPlaying!FlashPlayerMorph removeSelector: #toggleQuality!FlashPlayerMorph removeSelector: #toggleQuality!FlashPlayerMorph removeSelector: #stepForward!FlashPlayerMorph removeSelector: #stepForward!FlashPlayerMorph removeSelector: #stopSounds!FlashPlayerMorph removeSelector: #stopSounds!FlashPlayerMorph removeSelector: #frameNumber:!FlashPlayerMorph removeSelector: #frameNumber:!FlashPlayerMorph removeSelector: #maxFrames:!FlashPlayerMorph removeSelector: #frames!FlashPlayerMorph removeSelector: #frames!FlashPlayerMorph removeSelector: #maxFrames!FlashPlayerMorph removeSelector: #stepBackward!FlashPlayerMorph removeSelector: #stepBackward!FlashPlayerMorph removeSelector: #stop!FlashPlayerMorph removeSelector: #stop!FlashPlayerMorph removeSelector: #aaLevel:!FlashPlayerMorph removeSelector: #aaLevel:!FlashPlayerMorph removeSelector: #step!FlashPlayerMorph removeSelector: #step!FlashPlayerMorph removeSelector: #gotoFrame:!FlashPlayerMorph removeSelector: #gotoFrame:!FlashPlayerMorph removeSelector: #frames:!FlashPlayerMorph removeSelector: #frames:!FlashPlayerMorph removeSelector: #gotoPrevFrame!FlashPlayerMorph removeSelector: #gotoPrevFrame!FlashPlayerMorph removeSelector: #getURL:window:!FlashPlayerMorph removeSelector: #getURL:window:!FlashPlayerMorph removeSelector: #stepTime!FlashPlayerMorph removeSelector: #stepTime!FlashPlayerMorph removeSelector: #stepTime:!FlashPlayerMorph removeSelector: #stepTime:!FlashPlayerMorph removeSelector: #executeActions:!FlashPlayerMorph removeSelector: #executeActions:!'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 10:44:59 pm'!!BookMorph methodsFor: 'menu' stamp: 'tk 11/24/1998 22:35' prior: 37207087!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ 'ftp://server/books/myBook/page1.sp'].url _ FillInTheBlank 		request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' 		initialAnswer: initial.ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"^ (url stemAndNumericSuffix) at: 1		"remove trailing number"! !!FileUrl methodsFor: 'access' stamp: 'tk 11/24/1998 14:59'!pathDirString	"Path to directory as url, using slash as delimiter"	^ String streamContents: [ :s |		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: $/			 ] ]! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 22:43'!padToEndWith: aChar	"On the Mac, files do not truncate, so pad it with a harmless character.  But Remote FTP files always replace, so no need to pad."	self atEnd ifFalse: [self inform: 'Why is this stream not at its end?'].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 15:00' prior: 37215988!directory	"String of part of url that is the directory. Has slashes as separators"	urlObject ifNotNil: [^ urlObject pathDirString].	^ directory! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 22:20' prior: 35111073!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash score match best sd |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].	"If this server is already known, copy in its userName and password"	type == #ftp ifFalse: [^ self].	score _ -1.	ServerDirectory serverNames do: [:name |		sd _ ServerDirectory serverNamed: name.		server = sd server ifTrue: [			match _ directory asLowercase charactersExactlyMatching: sd directory asLowercase.			match > score ifTrue: [score _ match.  best _ sd]]].	best ifNotNil: [		user _ best user.  self password: best password].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 18:18'!server	^ server! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/24/1998 22:16'!user	^ user! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 15:01' prior: 37218593!fileName	"should this be local or as in a url?"	urlObject ifNotNil: [^ urlObject path last].	"path last encodeForHTTP ?"	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 14:45' prior: 21248510!fileName: aStringurlObject ~~ nil  "type == #file" 	ifTrue: [urlObject path at: urlObject path size put: aString]	ifFalse: [fileName _ aString]! !!SqueakPageCache class methodsFor: 'class initialization' stamp: 'tk 11/24/1998 14:53' prior: 37193622!initialize	"SqueakPageCache initialize"	GlobalPolicy _ #neverWrite.	PageCache _ Dictionary new: 100.		"forgets urls of pages, but ObjectOuts still remember them"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 11/24/1998 14:52' prior: 35182705!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| sd |	sd _ ServerFile new on: 'file:./'.	sd fileName: 'page1.sp'.	^ SqueakPage new urlNoOverwrite: sd pathForFile! !Object subclass: #SqueakPageCache	instanceVariableNames: ''	classVariableNames: 'GlobalPolicy PageCache '	poolDictionaries: ''	category: 'Morphic-WebBooks'!SqueakPageCache initialize!----QUIT----(25 November 1998 11:05:57 am ) priorSource: 1894937!----SNAPSHOT----(25 November 1998 11:21:47 am ) priorSource: 3771183!	Utilities broadcastUpdatesFrom: 681 to: 999 except: #().!----QUIT----(25 November 1998 11:34:53 am ) priorSource: 3771250!!ScreenController methodsFor: 'menu messages' stamp: 'di 11/25/1998 12:21' prior: 36171503!durableOpenMenu 	| colorPattern |	colorPattern _ #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'nested menus' stamp: 'di 11/25/1998 12:23' prior: 36173110!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 6)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowseropenProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!HandMorph methodsFor: 'world menu' stamp: 'di 11/25/1998 12:24' prior: 36095833!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	^ menu! !----SNAPSHOT----(25 November 1998 1:10:34 pm ) priorSource: 3771382!----QUIT----(25 November 1998 1:10:56 pm ) priorSource: 3773428!!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 11/25/1998 14:10' prior: 35278607!version	"Answer the version of this release."	^ 'Squeak 2.2 beta of Nov 25, 1998'! !----QUIT----(25 November 1998 2:10:47 pm ) priorSource: 3773498!!SequenceableCollection methodsFor: 'converting' stamp: 'djm 11/20/1998 05:44' prior: 21206654!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: String)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !----SNAPSHOT----(25 November 1998 2:12:26 pm ) priorSource: 3773750!!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 11/25/1998 14:20' prior: 37328095!version	"Answer the version of this release."	^ 'Squeak 2.3 beta of Nov 25, 1998'! !----QUIT----(25 November 1998 2:20:34 pm ) priorSource: 3774335!'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:40:16 pm'!!ParagraphEditor methodsFor: 'private' stamp: 'di 11/25/1998 14:40' prior: 20469274!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: stopBlock stringIndex				caseSensitive: ChangeText ~~ FindText.	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 3:16:56 pm'!!SystemWindow methodsFor: 'top window' stamp: 'di 11/25/1998 15:15' prior: 35996454!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	outerMorph _ self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !----SNAPSHOT----(25 November 1998 3:18:59 pm ) priorSource: 3774591!'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:35 pm'!"Change Set:		jhmVMDisplayTweaksDate:			25 November 1998Author:			John MaloneyMinor tweaks to the the display code to ensure that updates getforced to the screen on demand even on VM's that defer updating.Suggested by Tim Rowledge."!!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:19' prior: 18083655!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.		self ioForceDisplayUpdate].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:20' prior: 18091968!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left displayObj dispBits w h d dispBitsPtr |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj].	left < 0 ifTrue: [left _ 0].	right > w ifTrue: [right _ w].	top < 0 ifTrue: [top _ 0].	bottom > h ifTrue: [bottom _ h].	self success: ((left <= right) and: [top <= bottom]).	successFlag ifTrue: [		dispBitsPtr _ dispBits + BaseHeaderSize.		self cCode: 'ioShowDisplay(dispBitsPtr, w, h, d, left, right, top, bottom)'.		self ioForceDisplayUpdate].	successFlag ifTrue: [self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:14' prior: 35731128!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.		self ioForceDisplayUpdate.	].! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 11/23/1998 21:44' prior: 36986094!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:11' prior: 19287118!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.		self ioForceDisplayUpdate].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:10' prior: 19295739!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left displayObj dispBits w h d dispBitsPtr |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj].	left < 0 ifTrue: [left _ 0].	right > w ifTrue: [right _ w].	top < 0 ifTrue: [top _ 0].	bottom > h ifTrue: [bottom _ h].	self success: ((left <= right) and: [top <= bottom]).	successFlag ifTrue: [		dispBitsPtr _ dispBits + BaseHeaderSize.		self cCode: 'ioShowDisplay(dispBitsPtr, w, h, d, left, right, top, bottom)'.		self ioForceDisplayUpdate].	successFlag ifTrue: [self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:14' prior: 35738790!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.		self ioForceDisplayUpdate.	].! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 11/23/1998 21:44' prior: 36995333!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:31 pm'!"Change Set:		jhmExportMacrosDate:			25 November 1998Author:			John MaloneyMinor changes to the way exports are handled for pluggableprimitives. (Needed for the Mac CodeWarrior environment.)"!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'jm 11/24/1998 16:06' prior: 16981516!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	self export: true.	interpreterProxy _ anInterpreter.! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 09:09' prior: 17231156!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	| exporting |	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	exporting _ false.	methods do: [:m |		m export			ifTrue: [				exporting ifFalse: [					aStream nextPutAll: '#pragma export on'; cr.					exporting _ true]]			ifFalse: [				exporting ifTrue: [					aStream nextPutAll: '#pragma export off'; cr.					exporting _ false]].		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr].		exporting ifTrue: [			aStream nextPutAll: '#pragma export off'; cr].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 11/25/1998 13:39' prior: 34309485!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 16:00' prior: 35746725!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define successFlag (!!interpreterProxy->failed())#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayValueOf(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value)#pragma export onEXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter);#pragma export off/*** Variables ***/struct VirtualMachine *interpreterProxy;EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == false) {		return false;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 08:27' prior: 35749161!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */';cr.	aStream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)'.	aStream cr.! !!TMethod methodsFor: 'accessing' stamp: 'jm 11/24/1998 09:03'!export	^ export! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:28 pm'!"Change Set:		ObjectMemTweaksDate:			23 November 1998Author:			John MaloneySome VM improvements from Georg Gollmann:  - fixed a bug that limited image size to about 512 MB  - fixed a bug that limited object size to below 256 MB  - changed some literal constants to symbolic onesModified by John Maloney to:  - merge with WeakArray support  - omitted the change allowing use of the upper half of the    address space since it made incremental GC slightly slower (1-2%)    and does not seem likely to be needed soon (few machines have    over 2 gigabytes of memory!!!!)"!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ObjectMemory methodsFor: 'interpreter access' stamp: 'jm 11/24/1998 00:13' prior: 35589622!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: ((hash << HashBitsOffset) bitAnd: HashBits).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize _ (header1 bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: AllButTypeMask. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'go 11/18/1998 11:03' prior: 20170252!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/18/1998 11:04' prior: 20177954!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: SizeMask) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: CompactClassMask) = 0				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04' prior: 20178541!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57' prior: 20178788!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57' prior: 20179251!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04' prior: 20179753!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: AllButTypeMask! !!ObjectMemory methodsFor: 'allocation' stamp: 'go 11/18/1998 11:04' prior: 20189342!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader ccField isMethodCntx |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		ccField _ cntxHeader bitAnd: CompactClassMask.		ccField = 0 ifTrue: [			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.		] ifFalse: [			"compare ccField with compact class bits from format word of methodCntxClass"			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: CompactClassMask).		].		isMethodCntx ifTrue: [			"Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: SizeMask) = SmallContextSize ifTrue: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.				freeSmallContexts _ cntxOop.				] ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'go 11/17/1998 15:56' prior: 20196472!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: SizeMask ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'go 11/18/1998 11:04' prior: 20202124!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: CompactClassMask) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'jm 11/23/1998 23:01' prior: 35594514!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: SizeMask.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: SizeMask.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: AllButTypeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/24/1998 00:07' prior: 20211029!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"(use quadword alignment for better cache performance)"	fwdTableNext _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/24/1998 00:03' prior: 35598612!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/23/1998 23:12' prior: 20219470!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ realHeader bitAnd: SizeMask ].	^ self oopFromChunk: (oop + sz)! !!DynamicContextCache methodsFor: 'utilities' stamp: 'go 11/18/1998 13:00' prior: 17963188!changeClassOf: anObject to: aClass	"Used to mutate a PseudoContext to/from a stable Method/BlockContext.	Notes:	Tacitly assumes that the type bits are the SAME for the source and destination!!			This method should be in ObjectMemory."	| ccClass hdrObject ccObject |	self inline: false.	hdrObject _ self baseHeader: anObject.	ccObject _ hdrObject bitAnd: CompactClassMask.	ccObject = 0 ifTrue: [		"object has uncompact class"		self classHeader: anObject put: aClass.	] ifFalse: [		"object has compact class"		ccClass _ (self formatOfClass: aClass) bitAnd: CompactClassMask.		ccClass ~= 0 ifTrue: [			"object has compact class; class is compact"			hdrObject _ (hdrObject bitXor: ccObject) bitOr: ccClass.			self baseHeader: anObject put: hdrObject.		] ifFalse: [			"object has compact class; class is uncompact"			self error: 'cannot mutate header from compact to uncompact'.		]	]! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'go 11/18/1998 10:51' prior: 18308058!compactSend: tMeth type: type	| nArgs rcvr rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: CompactClassMask) + 1].	self checkSend: tMeth to: rcvr data: rcvrClass nArgs: nArgs type: type! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'go 11/18/1998 10:51' prior: 18311073!linkSendOpcode: ip type: type receiver: rcvr class: rcvrClass method: tMeth	"Rewrite the send opcode at ip.	ip:		the address of the linked extension word.	type:	0=short, 1=extended, 2=double-extended.	class:	the receiver class for which the inline cache hits."	"Note: the opcode itself is located at (ip - 4 - (type * 8))."	| op addr sendType linkData ccIndex currentMethod |	self assertAny: (addr _ 0).	self assertAny: (sendType _ 0).	(self isIntegerObject: rcvr)		ifTrue: [sendType _ ImmediateSendType.  linkData _ ConstZero]		ifFalse:			[ccIndex _ ((self formatOfClass: rcvrClass) bitAnd: CompactClassMask).			 ccIndex > 0				ifTrue: [sendType _ CompactSendType.  linkData _ ccIndex + 1]				ifFalse: [sendType _ NormalSendType.  linkData _ rcvrClass]].	self assert: (sendType ~= 0).	type = ShortSendType	 		ifTrue:	[addr _ ip - 4.	op _ shortSendTable at: sendType]			ifFalse: [	type = ExtendedSendType			ifTrue:	[addr _ ip - 12.	op _ extendedSendTable at: sendType]		ifFalse: [	type = DoubleExtendedSendType	ifTrue:	[addr _ ip - 20.	op _ doubleExtendedSendTable at: sendType]	]].	self assert: (addr ~= 0).	self longAt: addr put: op.	self longAt: ip put: tMeth.	self storePointer: MethodLinkageIndex ofObject: tMeth withValue: linkData.	tMeth >= youngStart ifTrue:		"store of young object into old object"		[currentMethod _ self translatedMethod.		 currentMethod < youngStart			ifTrue: [self addMethodRoot: currentMethod]].! !!DynamicTranslator methodsFor: 'obsolete' stamp: 'go 11/18/1998 10:51' prior: 18396268!oldCompactSend: tMeth type: type	| nArgs rcvr prevClass rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	prevClass _ (self fetchPointer: MethodLinkageIndex ofObject: tMeth) - 1.	self assert: prevClass ~= 0.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: CompactClassMask)].	(rcvrClass = prevClass) ifTrue: [		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18041166!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18043532!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18044288!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: SizeMask ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreterSimulator methodsFor: 'testing' stamp: 'go 11/18/1998 10:50' prior: 18222723!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		self validOop: former].! !!DynamicInterpreterSimulator methodsFor: 'debug support' stamp: 'jm 11/23/1998 22:44' prior: 18225727!dumpHeader: hdr	| cc |	^ String streamContents: [:strm |		cc _ (hdr bitAnd: CompactClassMask) >> 12.		strm nextPutAll: '<cc=', cc hex.		cc > 0 ifTrue:			[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].		strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: SizeMask) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>']! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19250171!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19252446!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19253195!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: SizeMask ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!InterpreterSimulator methodsFor: 'testing' stamp: 'go 11/18/1998 10:51' prior: 19400478!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		self validOop: former].! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'jm 11/23/1998 22:44' prior: 19403281!dumpHeader: hdr	| cc |	^ String streamContents: [:strm |		cc _ (hdr bitAnd: CompactClassMask) >> 12.		strm nextPutAll: '<cc=', cc hex.		cc > 0 ifTrue:			[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].		strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: SizeMask) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>']! !!ObjectMemory class methodsFor: 'initialization' stamp: 'go 11/18/1998 10:42' prior: 20229088!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	SizeMask _ 16rFC.	CompactClassMask _ 16r1F000.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:23 pm'!"Change Set:		jhmVMSupportCodeDate:			25 November 1998Author:			John MaloneyChanges the the C support code for Squeak 2.3. Includessupport for pluggable primitives."!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 11/25/1998 13:39' prior: 37357309!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 14:17' prior: 34315814!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ #(83 73 84 33 0 3 0 0 49 96 114 76 97 117 2 66 0 0 0 22 7 147 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 186 147 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 180 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 178 129 191 175 0 0 40 235 0 0 37 50 0 0 8 193 0 0 9 109 153 1 222 33 0 0 0 0 0 0 174 78 13 192 248 163 239 117 178 149 249 29 97 132 37 161 156 94 135 223 198 138 30 225 118 43 151 108 35 116 211 77 201 179 91 47 153 151 157 135 39 84 66 159 211 75 158 246 248 94 218 42 211 243 218 248 143 157 21 217 199 214 142 91 39 25 240 8 37 191 201 38 236 229 73 216 38 155 145 125 236 54 217 100 31 35 156 220 62 178 143 17 78 54 225 73 40 161 132 21 97 132 19 70 246 217 155 177 109 140 108 194 200 115 194 179 35 183 37 183 143 108 175 35 124 5 190 186 146 211 231 231 145 45 221 210 162 39 95 217 102 132 235 17 182 201 241 147 240 200 115 114 251 200 38 155 225 201 6 232 4 2 208 79 0 3 224 0 224 198 103 0 214 226 191 104 153 96 238 214 132 152 44 69 13 33 33 75 170 96 198 36 83 48 180 132 172 169 178 32 199 141 242 174 79 165 100 105 160 190 161 205 151 212 181 157 109 60 86 23 197 80 103 176 119 75 51 7 91 215 78 163 127 196 211 175 175 111 222 117 135 10 80 243 34 178 30 151 133 112 92 138 12 8 90 202 140 43 72 144 40 27 22 103 51 166 24 2 254 204 152 44 68 229 126 41 21 55 113 111 12 152 90 82 72 234 138 106 202 186 111 75 55 59 60 117 72 136 72 170 170 153 66 24 217 104 187 228 168 160 245 247 219 36 172 58 97 57 34 165 12 89 80 76 162 135 130 240 224 194 221 90 102 132 127 44 23 240 88 168 8 145 17 220 93 174 57 183 120 100 225 113 0 96 145 93 91 73 145 74 81 138 8 29 93 66 125 195 128 16 188 53 184 110 157 239 59 211 85 252 180 41 182 55 246 254 118 110 132 43 227 63 61 85 199 7 165 54 178 168 179 247 181 74 62 40 225 32 147 201 194 153 12 71 139 160 213 214 150 214 129 3 0 27 51 244 217 10 150 185 68 77 149 34 218 28 211 98 168 3 15 247 56 159 158 216 191 182 24 61 106 79 0 43 128 227 6 120 157 63 93 244 8 196 1 2 143 161 5 150 226 185 42 242 241 94 166 206 249 93 209 10 102 13 14 253 238 193 250 141 208 135 248 246 87 30 134 190 155 158 179 48 0 36 210 231 79 255 242 21 252 255 222 159 246 167 127 245 244 141 219 81 237 10 120 10 43 15 227 30 122 136 66 187 127 232 203 39 161 239 150 86 216 254 167 123 32 253 236 41 72 223 63 232 79 31 244 176 51 233 125 59 45 38 22 63 161 210 63 68 245 252 67 15 61 11 119 254 226 129 105 46 136 164 63 127 196 150 56 171 121 26 206 218 158 32 126 147 70 31 58 182 218 63 244 109 60 109 243 131 229 119 193 83 248 159 226 115 255 89 232 219 120 6 247 223 101 92 78 48 206 47 194 1 166 244 114 172 138 140 185 223 0 95 211 40 202 166 174 237 150 245 1 67 232 50 37 53 42 233 81 161 93 9 235 146 190 167 81 236 106 23 130 141 0 238 209 163 30 24 117 255 238 215 251 144 141 199 218 215 33 84 135 39 143 252 53 51 86 253 136 133 225 145 209 90 170 86 157 25 219 112 239 76 189 163 55 79 215 59 148 198 51 173 153 177 143 153 36 157 123 244 209 19 238 234 251 54 177 255 215 110 30 1 238 182 83 153 177 235 62 7 21 74 123 230 39 131 35 180 119 215 156 124 30 107 30 203 140 103 50 84 7 171 86 195 71 122 126 0 215 29 31 201 140 15 223 147 25 223 71 156 30 67 119 244 189 124 8 145 47 16 47 102 30 143 187 6 255 86 181 59 88 71 89 14 124 69 35 54 87 236 173 93 169 100 82 211 205 198 251 192 189 122 243 126 198 158 42 142 30 189 9 134 108 15 28 124 199 3 7 127 190 254 93 15 132 142 157 247 192 222 35 236 63 235 129 31 146 50 182 7 246 98 247 248 183 7 176 153 158 6 23 37 12 22 48 218 208 254 234 128 172 159 235 206 118 133 80 40 248 247 10 176 106 131 123 244 240 211 248 175 28 6 190 37 243 179 63 179 236 80 12 135 215 3 255 219 58 168 10 132 66 237 215 226 16 53 195 64 50 137 61 223 9 128 135 40 182 55 21 234 148 99 51 20 182 36 168 51 144 244 111 212 16 67 237 45 14 1 60 122 131 216 205 156 0 116 237 236 234 156 33 248 30 143 238 230 109 221 69 190 112 44 130 142 102 14 102 221 233 240 42 247 232 87 79 81 167 129 186 170 184 183 73 138 199 53 77 21 90 229 120 210 110 39 88 3 232 188 187 236 121 150 103 136 7 239 139 204 243 245 138 189 86 178 157 117 135 197 163 216 23 89 183 206 17 128 71 145 47 50 47 200 63 121 216 178 59 0 232 154 156 35 114 133 135 60 56 47 200 165 101 249 53 246 95 191 86 78 240 200 171 177 20 121 132 36 35 34 197 47 8 107 233 154 148 12 167 0 30 145 57 101 11 186 82 67 35 30 46 226 241 86 39 90 228 193 251 206 231 168 201 85 212 41 223 123 217 175 198 124 159 118 161 12 1 35 193 250 180 93 246 92 159 222 22 236 184 152 99 42 169 72 75 62 201 68 181 72 234 127 45 136 229 15 221 208 243 161 97 129 135 17 139 135 11 117 202 67 205 111 171 138 60 204 148 67 0 15 90 197 62 116 201 127 116 13 145 23 11 153 221 1 37 145 163 244 111 212 184 154 200 103 121 56 6 36 242 142 166 173 116 47 157 215 67 12 245 22 244 112 250 72 246 111 170 122 53 217 231 121 92 73 246 23 121 44 36 251 139 186 46 36 251 2 15 231 133 100 63 163 199 191 146 253 172 176 239 37 251 2 143 133 100 63 67 227 253 100 159 231 225 28 144 236 139 125 134 188 227 173 62 13 205 32 34 126 198 194 215 224 188 206 100 159 126 137 13 131 56 127 36 242 55 141 127 53 145 95 232 176 142 1 137 188 87 81 111 251 168 48 216 80 255 65 34 247 188 155 168 144 232 124 231 88 76 84 121 30 87 146 208 69 61 22 146 80 129 199 98 167 159 225 241 126 167 207 243 40 242 229 187 98 41 242 192 198 112 49 186 95 235 64 57 30 113 101 174 45 78 222 124 92 112 26 241 208 194 56 200 116 129 71 71 120 103 129 71 153 56 59 46 114 185 35 150 138 98 176 213 17 192 20 239 220 85 148 162 90 204 241 111 243 192 78 22 159 203 172 203 136 71 92 50 12 33 168 37 146 74 252 117 245 179 157 3 29 47 247 59 2 232 122 173 115 228 50 125 254 110 96 145 71 161 67 23 124 150 235 172 230 156 205 22 151 11 167 253 24 192 239 186 52 247 88 178 83 139 169 9 41 33 127 192 22 25 114 180 225 113 194 208 225 101 145 17 156 95 60 48 177 86 66 9 142 25 179 62 196 230 101 17 180 39 90 105 22 149 14 89 104 57 184 167 28 4 48 78 39 150 90 83 218 66 143 56 127 137 49 187 90 2 93 221 214 109 127 227 254 74 28 29 189 182 54 226 154 0 255 54 105 12 21 135 206 21 109 128 178 108 255 197 209 133 86 156 73 151 117 99 33 114 120 217 132 118 206 25 207 96 68 156 58 97 185 165 202 246 73 83 74 137 155 183 40 170 16 210 149 132 98 42 187 100 103 128 32 225 132 178 238 190 219 48 37 157 13 162 58 55 44 178 241 10 242 54 107 139 211 103 169 87 230 154 229 24 184 156 0 90 217 70 7 8 197 185 149 236 189 2 103 154 117 156 38 220 11 175 31 80 22 177 178 13 135 23 7 244 167 247 16 182 57 2 164 156 130 113 95 77 65 51 175 45 208 107 5 188 253 102 193 165 197 123 177 86 136 93 31 216 113 208 217 101 173 168 13 118 108 106 174 21 106 55 5 186 3 184 13 109 9 118 215 58 173 88 192 75 175 109 228 214 244 203 46 37 169 135 234 86 142 227 145 106 238 27 192 39 123 216 45 99 85 82 199 43 69 156 239 239 234 238 252 48 86 28 158 164 163 191 192 174 232 88 218 232 124 2 214 224 214 71 216 230 7 129 174 226 26 8 107 13 1 93 229 158 36 44 249 99 192 121 60 174 138 176 196 94 232 68 140 205 11 126 252 73 192 11 102 238 78 194 42 30 6 5 49 124 97 0 224 179 159 4 124 9 6 95 150 192 213 118 24 62 131 216 203 140 235 215 225 65 236 110 171 8 171 55 224 32 94 178 173 39 108 205 30 248 10 74 70 154 192 173 127 128 111 33 198 184 222 254 37 248 30 202 250 69 194 250 119 97 206 131 106 60 139 183 201 10 252 20 177 71 9 107 122 2 206 32 246 36 97 171 174 135 23 240 5 154 253 132 149 12 195 95 16 163 55 54 32 252 125 124 233 3 106 216 91 26 218 114 110 25 50 126 156 176 210 151 184 26 196 208 69 152 30 142 114 232 129 53 207 17 166 212 115 159 0 16 142 17 38 109 224 2 0 31 250 17 227 116 150 19 1 110 120 128 176 193 1 14 223 77 184 225 56 51 212 9 122 9 101 45 171 113 125 154 48 238 52 243 68 8 95 210 145 35 166 128 158 52 20 77 45 103 215 255 19 151 193 75 104 64 36 168 69 229 205 178 234 201 13 139 176 99 118 229 10 123 228 41 91 50 139 247 74 186 170 168 59 12 87 115 84 49 53 189 184 69 83 205 242 44 219 230 65 83 151 140 138 96 202 48 181 132 208 38 239 217 173 233 81 195 27 136 68 100 188 138 14 73 102 204 112 117 75 250 14 217 244 210 253 72 212 46 88 214 19 196 231 47 100 51 149 92 66 179 164 182 48 149 132 109 82 12 188 197 150 19 97 148 192 147 27 52 101 117 108 214 229 214 136 68 86 40 27 158 208 41 216 34 98 177 37 244 108 68 150 24 97 83 196 114 111 74 184 9 194 129 29 86 207 38 232 181 70 151 81 63 85 142 123 113 106 106 130 235 255 1 0 0 13 0 107 153 246 249 57 233 173 115 96 121 251 164 245 244 235 61 57 229 3 55 243 90 243 26 180 94 39 211 99 3 139 28 119 227 249 122 50 15 191 217 26 254 10 255 245 109 123 38 39 251 36 131 205 114 19 78 120 71 70 156 140 248 117 146 77 182 81 153 173 228 121 146 227 100 178 143 108 178 201 38 155 76 246 145 219 3 114 251 36 156 108 194 201 38 60 221 44 235 200 38 207 46 114 251 200 166 192 189 173 219 83 252 209 6 154 207 60 142 39 252 200 38 180 232 38 131 77 70 155 12 55 37 27 79 86 224 11 40 7 221 26 209 180 24 33 196 5 191 155 8 217 241 19 248 125 11 122 65 248 45 132 223 33 82 64 118 193 111 131 59 164 37 244 136 108 16 215 175 127 73 158 34 222 161 233 43 109 196 13 8 244 43 198 154 126 136 87 30 144 34 245 126 229 73 93 210 21 64 237 100 120 69 136 33 112 57 30 253 109 168 104 239 13 117 255 19 240 180 131 71 200 238 41 82 250 68 37 113 253 238 91 132 156 158 118 61 94 245 14 217 67 130 80 127 247 3 52 82 64 103 96 120 248 81 254 88 221 124 166 160 130 20 186 34 181 71 63 196 99 152 123 11 246 157 158 38 23 201 42 66 42 127 74 106 201 59 240 104 29 211 8 67 166 20 0 233 138 106 202 122 188 41 98 195 219 223 0 214 157 201 11 147 95 131 41 202 147 47 157 105 135 250 0 246 87 99 93 147 124 195 44 128 186 2 106 55 212 221 248 174 11 234 103 160 46 194 218 141 117 49 214 37 88 151 37 191 240 219 31 66 221 131 125 63 214 133 169 167 207 189 15 245 99 169 158 85 3 80 31 59 63 246 120 33 212 123 83 19 155 7 161 14 192 251 247 160 126 147 252 30 88 170 77 243 204 164 70 72 185 49 226 83 98 114 80 87 134 141 5 178 183 175 56 193 179 205 239 63 24 177 117 54 191 235 140 17 240 170 118 227 148 26 89 228 217 251 17 191 235 38 183 254 149 246 107 191 191 109 130 242 227 240 93 141 60 58 188 63 132 243 252 143 255 203 228 125 96 111 131 205 127 37 227 191 67 209 229 136 169 233 167 114 18 7 55 92 224 127 229 10 222 109 221 163 127 215 50 222 189 227 96 226 170 20 203 219 219 17 139 247 131 200 203 202 25 252 191 109 229 23 212 253 90 198 127 143 118 202 48 149 200 201 188 179 11 92 91 247 107 144 159 21 35 252 221 85 228 162 57 116 163 173 243 10 198 115 175 108 142 105 250 45 154 201 103 45 158 239 70 63 23 252 174 157 156 186 66 251 165 147 47 157 187 2 245 225 228 187 103 170 174 243 46 248 110 64 125 220 230 253 14 196 179 121 175 123 229 245 63 239 130 122 253 185 55 191 151 248 68 7 95 113 77 0 139 13 182 222 235 152 14 66 178 174 72 177 118 53 26 232 238 232 14 106 186 121 77 17 109 25 191 219 111 249 222 253 147 169 46 218 247 224 59 161 151 7 241 157 157 139 132 126 132 79 246 226 187 190 140 111 62 128 115 8 31 9 34 158 237 163 149 136 83 133 115 180 39 47 252 232 235 255 246 215 221 75 62 187 11 231 252 175 254 202 184 254 180 132 26 93 220 25 236 176 244 119 31 242 179 1 235 123 38 127 241 238 13 29 218 186 107 68 189 205 235 207 209 91 51 226 216 122 107 194 119 194 223 108 253 9 221 237 68 158 238 197 122 94 135 43 15 232 239 9 215 231 153 138 172 28 0 123 12 208 223 17 69 141 106 99 11 2 252 76 70 127 243 254 38 244 212 138 245 157 147 231 190 67 235 14 196 113 242 130 208 157 173 179 135 113 222 150 228 91 219 95 252 64 103 143 44 229 10 59 63 238 193 254 230 76 206 88 210 87 126 79 20 80 140 200 199 123 162 207 173 120 177 39 202 240 91 101 140 244 197 162 204 191 23 57 126 116 165 14 126 33 39 127 66 46 124 251 86 188 224 247 101 66 55 192 229 182 255 87 27 35 135 21 221 76 72 49 136 1 67 138 42 207 115 44 246 193 130 95 155 215 255 240 104 243 247 209 62 114 117 84 213 63 94 42 167 225 96 163 103 229 242 249 188 183 13 235 77 86 78 185 11 251 245 88 219 186 157 207 217 27 177 222 138 245 22 43 95 136 125 134 208 177 189 199 240 145 174 85 127 132 90 240 136 141 186 128 100 14 193 33 64 75 235 129 122 159 212 176 91 105 110 141 238 108 130 7 54 255 190 116 61 51 7 234 125 125 80 215 78 192 66 87 111 105 61 217 224 151 244 65 249 230 20 132 244 47 206 81 2 118 209 23 106 138 221 128 190 250 29 90 156 163 58 16 242 215 247 39 84 83 25 150 129 146 57 46 232 23 90 156 163 142 206 225 105 226 242 208 243 250 8 95 221 225 1 120 91 185 179 243 75 254 234 231 95 117 77 132 189 71 195 180 3 152 128 90 181 195 113 164 169 47 23 252 152 163 210 14 236 137 217 172 206 94 121 234 75 127 59 143 168 208 129 107 19 134 90 104 140 52 13 229 69 70 189 159 163 178 20 176 186 13 80 123 90 138 134 193 51 242 184 204 177 57 175 180 83 196 81 221 134 25 85 180 28 44 243 107 129 250 12 113 115 212 98 64 5 51 200 194 90 168 197 105 84 93 81 7 111 163 150 32 175 212 44 22 121 253 16 181 180 13 118 244 93 53 101 160 187 46 89 138 202 186 113 19 155 237 35 24 42 235 172 161 168 157 173 37 29 178 113 114 127 98 14 18 62 230 230 12 149 117 202 56 170 59 124 42 46 103 49 129 33 234 253 156 33 218 41 231 168 53 30 77 141 42 166 162 193 230 29 200 210 53 107 2 150 100 56 42 237 84 112 212 53 1 101 92 142 6 180 104 70 18 44 175 112 84 218 89 203 81 139 189 163 178 106 230 40 98 41 137 171 129 118 42 113 214 131 9 112 200 168 46 141 205 1 179 44 196 81 105 167 138 163 174 77 163 134 229 113 243 26 178 165 161 106 84 94 95 232 144 169 196 178 20 89 26 170 65 94 3 242 48 245 213 172 163 208 20 39 212 80 64 106 81 175 244 198 37 175 87 139 161 117 66 67 186 174 101 220 132 169 129 38 78 174 6 218 89 207 115 67 49 72 59 236 9 102 81 105 14 228 94 206 18 225 6 84 94 123 60 30 147 195 82 236 228 28 176 197 80 29 159 181 178 61 26 213 101 195 56 234 151 168 173 204 66 211 236 201 103 101 41 116 35 206 218 47 27 252 174 237 95 179 222 33 60 79 151 226 203 26 186 19 85 222 41 27 166 20 187 238 10 168 33 154 198 185 134 104 103 19 162 250 180 88 214 200 175 205 186 25 121 13 195 89 95 222 83 44 212 45 2 21 76 107 25 117 43 122 67 40 162 43 241 44 173 54 106 61 58 101 183 106 198 242 234 179 80 183 9 53 40 227 116 61 176 164 134 187 80 175 221 17 77 93 214 235 118 158 68 157 187 183 41 247 128 31 243 43 116 96 223 204 80 157 45 127 170 241 155 251 48 191 66 7 118 205 98 214 133 221 116 234 169 111 252 9 81 161 3 151 42 12 213 185 108 57 223 56 112 137 163 210 14 185 59 157 243 70 149 172 227 205 122 121 3 122 3 108 83 0 212 88 114 202 157 168 60 46 132 172 242 216 101 0 159 149 118 238 225 168 101 30 109 56 174 169 217 212 102 161 222 139 168 108 214 110 53 158 152 243 34 11 245 62 142 90 206 210 70 46 34 90 188 54 114 212 34 111 48 232 201 231 114 43 83 54 33 67 0 74 141 249 73 109 252 38 182 53 107 51 71 173 232 213 76 229 132 18 153 203 53 179 168 187 80 229 220 76 114 42 159 201 175 247 115 212 82 200 229 166 174 101 163 168 133 250 0 170 60 32 171 185 189 193 44 234 131 194 135 224 16 73 27 188 205 208 110 100 136 102 20 47 236 14 50 176 150 26 246 136 196 6 123 20 253 211 4 208 66 81 125 63 43 141 227 6 49 3 204 238 50 120 194 166 157 135 144 215 16 219 244 220 78 108 173 34 151 131 242 150 51 202 195 136 26 212 198 110 241 106 121 249 35 194 149 35 16 96 63 157 245 81 158 54 156 251 135 169 223 252 225 101 204 67 208 33 143 113 212 82 99 4 60 229 132 50 191 249 162 59 124 76 54 208 33 123 57 42 220 102 6 99 146 121 66 211 135 67 113 57 66 237 239 42 62 221 248 35 42 116 224 162 36 157 162 110 93 160 164 70 15 165 16 21 58 112 199 32 82 212 194 221 67 170 241 217 179 34 177 61 123 22 174 227 24 170 115 77 119 254 245 55 38 49 123 65 135 180 139 172 204 0 243 91 64 184 92 195 125 30 116 246 99 86 134 60 52 188 156 149 61 28 181 218 211 31 224 227 206 5 62 11 181 3 25 242 107 99 176 88 202 109 122 102 92 217 203 213 224 220 80 167 26 159 247 9 13 61 239 35 62 58 171 231 219 206 166 63 121 225 7 113 215 68 32 232 247 209 14 233 228 59 209 50 73 53 148 227 113 73 135 17 111 176 100 237 122 187 196 254 85 249 162 124 60 183 165 176 54 169 221 28 181 72 77 196 114 106 157 157 181 135 163 150 140 74 199 99 138 145 29 214 154 245 0 71 117 71 149 209 60 65 246 172 126 156 117 44 50 36 233 57 92 107 214 0 215 235 181 91 152 25 120 122 161 146 222 178 191 71 122 209 27 14 192 169 180 156 211 131 149 54 250 56 106 13 142 232 29 143 200 113 154 97 45 217 90 62 20 20 169 87 26 150 251 229 65 144 209 205 29 167 53 235 193 180 83 70 101 159 46 13 14 207 229 121 107 214 126 230 67 27 157 75 17 72 119 175 160 15 65 135 132 40 106 199 62 231 158 35 121 233 69 216 110 50 84 232 144 48 213 171 167 217 185 222 72 94 122 225 162 64 125 225 34 57 196 24 170 112 110 80 146 23 94 189 44 156 242 213 203 228 48 191 3 160 255 193 129 119 0 48 239 117 84 122 143 56 17 8 120 186 88 231 72 58 123 45 220 197 167 158 126 237 57 225 13 175 61 7 215 82 25 71 153 73 82 150 163 12 112 84 231 63 52 82 19 103 91 69 206 59 219 74 142 209 91 169 182 242 53 140 161 161 14 57 147 97 233 255 91 96 246 130 14 127 227 130 127 55 33 5 193 144 60 56 61 157 6 130 55 112 86 12 111 232 92 171 19 199 224 78 222 181 133 254 231 71 208 111 152 20 0 222 252 5 182 203 111 195 245 206 223 131 190 152 65 223 252 31 0 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 98 187 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 38 62 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 129 191 243 0 0 41 201 0 0 38 200 0 0 9 141 0 0 9 141 243 46 72 29 0 0 0 0 0 0 205 45 13 192 213 101 121 173 204 147 221 94 217 32 163 61 158 109 54 234 188 86 118 100 27 225 81 66 201 109 93 59 251 77 147 83 153 114 250 121 201 47 118 137 167 134 103 158 199 214 9 195 95 199 162 229 149 107 17 86 172 39 191 153 91 194 201 38 155 69 246 25 37 207 59 178 89 132 109 79 178 9 207 200 102 228 247 81 178 143 17 74 216 62 143 108 37 199 110 179 205 182 29 229 79 158 147 237 145 205 242 246 75 24 225 49 194 9 63 241 192 87 87 114 154 229 229 185 165 69 63 143 48 178 153 17 182 201 109 221 108 147 223 228 55 217 100 51 60 217 192 248 211 116 80 30 0 3 128 185 43 0 230 224 223 178 46 162 29 251 252 38 6 218 219 49 184 197 173 29 199 255 187 245 219 22 185 180 55 245 211 178 156 234 117 9 89 90 235 243 121 92 49 37 26 4 1 171 123 189 190 42 79 221 210 18 6 229 217 189 217 99 173 120 253 84 236 92 213 52 19 50 3 47 1 220 28 158 181 196 165 253 126 199 227 229 37 107 108 203 183 237 120 166 96 6 102 166 150 69 180 246 69 46 112 224 223 142 255 49 203 118 191 103 171 252 35 56 86 219 151 111 163 187 49 219 83 85 53 149 139 51 42 142 230 29 215 98 203 86 45 75 44 6 200 224 216 50 248 103 77 131 37 114 123 195 154 129 1 203 106 1 202 94 103 83 230 226 13 1 108 116 143 83 73 103 139 243 135 120 214 169 165 16 50 99 146 127 173 212 36 159 225 82 143 177 198 125 151 186 33 124 246 254 184 234 13 106 92 14 123 66 146 170 202 234 57 8 179 63 100 234 108 216 64 192 66 22 204 180 225 233 82 205 129 16 16 5 106 214 52 32 202 137 17 135 87 242 139 149 213 34 90 132 232 89 228 89 176 192 245 131 222 42 110 93 102 250 193 56 47 103 109 44 75 216 120 178 14 74 191 95 197 125 97 63 85 201 5 25 104 101 90 42 173 105 140 130 82 211 245 35 197 246 237 0 75 52 250 12 6 179 108 222 104 68 242 71 7 144 90 97 62 100 179 159 10 201 238 243 169 224 240 116 7 113 2 99 235 132 103 133 95 89 94 129 16 64 97 7 74 96 28 222 155 74 58 126 128 179 115 230 100 113 114 105 48 212 123 54 214 47 128 122 204 175 60 241 4 212 223 252 134 158 3 64 32 245 238 228 111 79 224 255 168 59 233 78 118 29 154 179 18 217 206 133 3 88 121 51 158 1 93 14 88 133 187 245 155 47 64 253 45 101 176 242 237 213 144 124 121 31 36 31 108 113 39 31 207 230 119 146 91 130 58 18 29 159 232 112 183 82 61 119 235 55 94 134 47 254 230 161 94 44 152 73 110 253 174 65 113 138 243 36 188 102 104 130 240 245 8 189 117 215 116 119 235 51 120 219 192 7 19 86 193 1 252 159 196 243 224 107 80 191 228 85 60 63 199 177 236 229 152 223 130 237 156 233 9 88 21 17 163 154 132 220 2 52 22 244 149 234 68 44 22 85 226 5 164 107 55 176 224 155 251 192 153 179 23 198 63 57 63 45 190 133 58 35 88 149 5 143 44 6 231 242 87 241 127 160 89 251 139 27 243 55 145 21 128 115 226 66 204 29 199 191 3 38 180 214 96 253 142 217 96 181 98 94 124 191 62 226 59 226 211 243 11 227 108 193 243 237 170 95 9 192 228 98 84 245 196 133 220 81 130 71 81 7 200 15 175 63 6 235 19 31 83 210 126 48 235 173 205 238 199 158 141 99 6 69 64 120 142 62 13 206 25 59 89 177 221 135 185 131 136 175 141 235 124 252 147 155 244 250 200 7 213 119 206 140 25 8 166 192 76 114 10 86 5 194 180 2 175 28 87 162 247 202 202 90 85 172 142 75 145 70 73 105 20 43 2 13 138 164 108 40 240 86 87 136 158 2 172 244 226 161 108 120 36 243 200 43 91 176 122 182 126 38 113 204 199 155 191 126 87 219 147 247 125 61 135 87 30 9 198 176 90 158 182 231 246 251 250 234 29 90 216 91 207 230 192 59 101 218 158 207 18 163 120 231 240 94 230 123 167 131 254 153 237 254 213 192 110 221 167 237 153 252 101 200 13 84 104 251 91 218 232 204 238 156 18 196 154 187 180 78 84 11 214 193 170 62 152 91 251 99 152 188 187 77 235 220 188 90 235 220 146 196 251 29 232 16 245 239 180 99 230 43 132 139 51 159 141 149 232 79 213 238 210 197 224 252 29 216 168 195 48 26 140 138 64 100 173 172 156 118 231 145 10 48 169 147 189 184 255 16 254 29 155 65 40 213 14 30 231 189 131 245 133 253 139 65 56 60 31 166 22 250 124 21 215 219 33 50 195 194 88 12 61 223 12 0 135 215 91 81 52 92 39 7 141 64 92 26 38 119 36 234 207 213 240 250 42 74 77 2 112 212 121 208 4 205 0 120 173 170 174 234 3 248 9 142 154 146 21 53 22 87 67 179 191 171 171 11 88 231 99 252 226 225 71 185 75 185 183 6 209 191 45 197 246 34 41 20 138 70 35 98 153 28 226 230 250 169 124 1 14 111 219 5 237 243 242 97 71 193 62 186 66 56 4 151 127 16 175 221 91 167 119 182 253 234 208 113 88 93 254 5 11 76 1 112 88 92 254 65 66 254 142 35 213 83 92 231 53 54 0 228 10 14 185 101 144 144 139 161 235 181 249 191 122 117 116 227 24 98 99 28 226 240 73 170 95 10 157 39 86 231 53 38 245 61 243 252 19 135 127 128 217 97 94 169 9 37 28 54 194 241 177 19 93 198 33 184 206 244 81 61 97 169 146 239 187 164 87 117 208 167 109 72 67 161 26 230 62 205 239 127 232 211 43 60 149 35 125 140 131 138 148 14 117 50 141 81 127 226 127 22 196 251 15 69 85 134 154 134 81 28 106 115 168 97 184 78 142 175 228 2 171 136 35 158 48 9 192 65 97 117 161 74 254 195 171 143 180 168 119 228 183 229 223 97 222 210 145 35 245 231 106 92 237 200 251 113 152 6 116 228 149 69 229 226 8 31 94 95 221 48 31 102 31 157 253 71 172 94 237 236 135 112 92 233 236 71 112 140 118 246 35 188 142 118 246 195 56 204 23 58 251 62 62 254 213 217 247 19 251 73 103 63 140 99 180 179 239 131 113 173 179 31 194 97 30 208 217 91 93 170 220 244 177 79 3 180 223 116 2 167 34 230 67 209 108 244 231 142 94 159 46 229 62 109 254 209 145 127 36 252 171 29 249 121 135 53 13 232 200 235 2 145 91 63 35 182 228 223 246 239 142 60 251 31 29 21 2 29 116 142 203 29 213 16 142 43 157 208 8 31 163 157 208 48 142 203 78 223 135 227 154 211 15 225 176 184 134 92 113 12 226 64 99 24 105 221 175 59 80 26 71 40 48 96 139 61 47 31 231 149 70 56 162 13 56 200 116 30 71 101 67 112 24 71 150 183 127 92 228 146 35 142 241 122 61 101 166 0 162 248 219 91 197 24 100 139 43 254 2 14 116 178 208 64 207 58 158 112 208 104 162 232 137 134 99 129 208 7 236 167 156 3 21 47 175 49 5 224 245 186 115 164 123 250 161 183 129 203 56 134 29 122 88 103 105 103 141 15 200 236 114 216 112 218 143 39 132 245 23 231 30 51 130 209 230 72 88 10 247 207 166 94 8 68 200 232 32 224 132 161 201 75 144 16 204 95 52 208 29 147 104 110 182 91 23 61 25 154 69 37 165 232 217 28 200 196 12 255 25 247 59 33 243 226 4 240 133 88 130 161 191 246 179 228 138 211 147 181 215 130 240 116 39 207 78 26 35 206 211 69 243 33 43 69 62 210 89 38 75 141 178 162 142 182 28 118 176 240 65 99 238 174 248 127 169 103 36 253 3 93 153 249 196 61 247 168 113 73 225 15 140 230 13 65 50 118 130 69 48 108 145 165 118 6 80 144 87 146 7 232 82 223 3 54 62 248 110 250 193 56 155 132 29 42 237 31 56 21 227 244 189 16 181 94 159 18 8 171 129 136 72 231 64 60 176 254 175 11 15 76 73 98 55 185 188 161 3 177 214 75 237 15 237 201 160 45 25 233 40 45 172 174 209 123 155 130 175 3 228 182 227 21 252 59 248 108 184 217 129 112 223 239 130 250 182 45 144 119 9 221 91 47 70 66 176 99 45 156 141 55 62 211 151 112 206 243 84 22 151 204 19 231 21 23 214 20 226 209 183 212 83 51 207 108 69 2 118 99 9 139 17 189 123 101 50 18 223 218 121 3 109 120 200 99 191 4 33 86 203 95 25 167 198 20 124 82 156 1 115 171 107 170 102 97 197 239 244 212 207 42 228 79 116 180 155 5 238 250 25 208 214 134 28 202 221 185 17 232 157 102 18 229 202 31 6 154 9 164 189 5 144 184 1 238 198 227 78 202 141 171 129 38 60 18 94 152 57 7 16 43 43 167 92 230 159 224 75 152 67 231 5 184 191 11 104 211 192 47 40 39 253 25 158 224 125 58 70 112 61 124 155 187 27 70 120 11 60 133 57 190 213 226 246 22 248 17 230 90 40 183 252 123 240 115 204 125 141 114 37 95 133 131 248 16 247 52 199 221 6 93 72 43 226 2 88 245 58 252 1 115 28 235 250 231 225 24 192 180 9 148 139 63 68 202 152 134 219 35 112 214 238 13 54 30 115 252 221 105 211 86 150 135 57 62 227 184 241 39 12 23 48 76 231 28 87 191 199 62 135 185 42 202 221 237 96 56 43 56 157 63 152 207 58 194 188 0 34 111 42 55 61 192 234 49 135 74 3 144 31 101 216 112 136 252 169 118 142 198 112 150 102 166 139 114 85 107 216 253 0 159 230 239 211 202 115 236 97 68 192 181 53 209 202 144 199 89 249 92 116 123 105 171 198 28 94 227 198 36 229 4 190 119 33 215 135 93 140 236 143 139 168 91 53 16 141 76 241 74 77 1 191 232 145 98 167 158 142 241 233 39 117 81 127 73 31 159 190 96 96 200 225 227 5 221 21 199 210 0 138 39 218 40 127 65 142 100 167 135 81 248 53 163 98 174 49 82 149 42 153 202 215 73 74 36 16 105 82 109 37 141 129 120 84 177 150 70 35 241 156 20 83 37 45 113 69 82 115 61 9 53 30 13 139 119 200 27 238 141 42 141 170 189 208 239 151 145 47 159 20 111 86 109 53 146 210 36 199 237 69 137 64 168 209 40 152 85 235 193 21 35 114 60 17 27 75 179 170 6 49 14 202 21 7 84 164 90 14 55 32 5 217 233 65 86 94 39 197 173 62 130 145 34 202 72 119 243 228 41 245 98 177 177 252 93 204 0 70 185 147 192 210 59 43 50 41 133 3 65 188 158 1 208 174 143 70 35 127 17 57 100 199 169 172 110 172 255 7 0 0 13 0 107 249 150 57 201 203 6 249 155 89 94 158 220 142 94 151 189 155 110 223 244 248 218 201 28 120 236 86 230 201 188 228 215 233 198 179 245 164 143 223 212 180 240 95 131 61 162 17 158 100 176 245 200 49 194 54 217 100 31 185 77 6 155 108 70 54 35 155 236 167 118 173 100 147 77 24 57 30 217 146 45 217 228 55 217 228 55 217 145 223 100 147 227 132 19 78 54 217 100 147 253 140 240 65 228 54 249 173 228 56 185 205 128 123 91 185 23 5 136 114 83 243 57 125 60 225 71 158 182 233 66 6 60 130 132 77 201 94 195 3 95 64 57 232 104 72 215 35 132 16 23 124 183 17 178 231 179 240 29 131 94 0 190 249 240 253 14 89 67 14 144 60 120 107 14 214 48 140 169 173 127 132 154 144 196 245 110 86 219 191 60 134 87 251 31 188 84 255 245 218 130 120 239 207 239 96 113 60 250 173 37 63 115 143 239 123 89 255 18 197 35 196 61 14 175 54 194 31 241 20 145 14 178 233 38 222 46 196 219 152 255 107 214 119 189 19 76 189 125 150 60 151 247 185 61 3 239 205 231 6 184 195 121 71 190 118 131 188 14 220 147 202 90 82 77 254 6 239 170 153 70 216 4 148 2 66 138 180 168 165 26 177 250 80 134 42 252 245 98 221 154 184 54 249 117 152 194 157 184 244 66 19 212 62 236 215 96 93 154 120 213 202 131 186 8 106 55 212 237 248 174 13 234 231 161 222 137 245 189 88 239 194 122 55 214 133 137 47 188 242 75 168 59 176 239 199 122 71 242 236 212 117 168 15 37 219 215 244 66 253 244 149 209 103 242 161 110 72 78 108 239 135 186 5 222 191 5 245 107 132 42 117 67 138 103 38 53 66 74 205 97 175 22 81 3 134 54 100 46 144 125 100 213 9 158 109 126 255 197 136 221 108 243 91 109 14 251 149 80 147 57 30 13 45 242 220 184 196 111 249 228 142 127 208 126 217 79 118 78 80 126 28 190 75 144 71 135 247 71 113 158 255 242 255 79 114 29 216 219 100 243 95 193 248 111 214 12 53 100 233 198 120 86 226 219 151 248 95 189 130 119 91 247 232 223 27 24 239 45 99 96 226 81 37 146 179 183 102 201 187 23 121 89 61 131 255 191 200 252 130 186 47 103 252 183 235 227 166 165 133 6 115 206 254 153 180 238 31 67 126 86 141 240 119 87 161 171 8 88 218 98 243 92 198 120 62 166 90 163 186 241 33 205 228 168 228 121 47 250 185 224 119 237 228 244 219 180 127 223 228 165 169 183 161 222 147 120 227 133 189 183 121 23 124 215 162 62 238 242 190 1 241 108 222 43 127 252 226 223 15 64 93 49 245 218 143 226 31 235 224 171 174 9 96 177 214 246 187 205 76 7 93 170 161 41 145 166 104 216 223 214 220 22 208 13 235 125 69 60 158 246 187 195 210 247 30 154 76 182 210 254 147 248 78 232 229 97 124 103 231 34 161 31 225 147 199 240 221 241 180 111 30 196 57 132 143 4 16 207 246 209 98 196 89 135 115 60 145 184 246 242 55 254 223 95 31 89 246 217 3 56 231 39 250 67 31 42 225 250 211 227 209 240 226 206 224 83 82 127 15 34 63 235 177 222 55 249 127 111 124 160 67 91 119 117 168 183 121 253 57 122 219 143 56 182 222 234 241 157 240 55 91 127 66 119 247 35 79 15 96 61 175 195 213 7 244 247 172 235 243 160 158 221 182 255 193 30 3 244 215 163 69 195 250 232 130 0 59 211 250 155 247 55 161 167 46 172 171 39 167 126 64 235 32 226 56 121 65 232 206 214 217 73 156 247 84 226 79 187 190 127 83 103 221 203 185 194 206 143 61 216 223 148 206 25 203 250 154 221 19 221 212 151 102 134 62 218 19 53 173 122 177 39 74 239 193 214 155 195 199 35 97 230 223 139 28 127 122 181 14 126 33 39 127 76 46 252 158 90 245 130 223 203 228 135 212 142 108 127 170 52 135 187 53 195 138 43 17 136 1 3 90 84 157 231 216 35 249 181 121 253 132 71 155 191 165 189 84 65 56 106 124 180 84 166 64 88 139 92 40 116 56 159 247 182 98 189 81 230 148 109 216 191 7 107 91 183 243 57 187 10 235 45 88 111 150 249 66 236 51 132 142 237 61 134 151 180 174 249 43 212 156 118 234 67 76 9 101 254 30 79 103 60 106 105 67 106 189 79 59 147 229 31 182 243 236 103 207 33 242 136 191 203 87 227 169 15 4 60 139 99 144 19 233 57 144 15 183 95 177 6 22 39 184 101 163 153 57 74 218 232 189 64 159 18 82 151 134 17 126 144 158 163 60 102 232 125 176 168 54 40 179 145 220 40 244 126 131 142 3 121 152 205 33 244 34 244 209 53 28 87 149 193 154 110 127 205 161 134 142 28 31 207 136 198 187 121 184 32 254 45 126 213 65 92 21 5 241 111 127 239 86 30 46 232 185 92 177 202 74 30 102 50 104 4 81 121 170 28 141 39 78 252 182 209 53 97 90 241 51 180 67 242 56 170 227 48 18 117 13 69 109 62 231 248 100 226 218 213 139 174 9 127 192 231 165 29 146 207 102 221 226 184 7 104 235 167 136 10 29 200 24 128 186 126 183 147 73 166 191 146 247 43 215 68 176 229 84 144 118 72 33 157 245 104 131 59 56 30 83 205 250 153 251 154 91 179 82 93 51 84 214 113 115 212 42 143 30 13 107 150 166 195 86 30 146 154 161 203 9 88 202 225 168 180 83 196 81 215 249 181 49 53 236 215 195 234 220 188 44 203 112 84 218 89 203 81 139 90 70 212 168 149 165 136 37 40 134 202 58 197 56 235 137 56 108 204 195 134 50 58 7 204 124 131 163 210 206 58 142 90 158 66 13 170 99 214 251 200 204 133 24 42 235 148 112 212 181 199 187 78 90 90 36 67 145 212 80 41 242 234 87 135 232 45 199 60 175 204 105 133 26 242 72 25 234 149 222 191 228 244 42 25 42 23 26 50 12 221 200 105 136 186 54 87 3 237 84 112 71 41 2 105 7 61 129 12 42 205 136 220 81 88 90 92 143 202 107 138 197 34 106 80 137 12 206 1 75 134 42 249 172 21 77 225 176 161 154 230 41 159 66 109 101 22 154 230 82 62 43 75 168 85 56 107 167 106 234 113 35 52 175 8 57 235 6 225 121 134 18 91 209 80 53 170 252 168 106 90 74 228 182 43 160 134 104 130 226 26 162 157 141 136 234 213 35 97 53 43 61 57 235 38 228 53 8 39 127 57 79 145 168 155 5 42 152 214 10 234 22 244 134 174 144 161 197 50 180 218 168 247 160 83 66 138 138 228 212 39 81 183 10 53 104 99 52 72 45 171 97 27 234 181 45 164 71 87 244 186 157 58 74 99 169 115 51 53 253 229 119 174 96 30 130 14 108 244 25 170 115 1 144 172 251 230 17 142 74 59 100 7 71 205 55 135 179 244 80 84 72 167 136 74 115 106 77 35 228 252 246 67 133 67 57 41 208 4 64 179 53 79 0 180 179 147 163 186 77 43 172 233 185 196 70 147 177 64 125 158 220 203 81 139 0 21 162 100 54 109 204 160 238 74 161 26 90 180 255 46 234 110 228 149 229 221 5 94 111 161 222 71 85 222 90 85 2 186 107 85 149 140 89 178 141 4 247 87 218 217 195 81 75 223 69 133 180 124 123 86 186 191 152 240 251 61 173 172 179 23 125 168 89 29 209 50 169 97 54 15 213 162 191 6 12 29 64 205 229 180 113 63 186 23 55 147 140 28 216 229 5 159 149 118 246 113 212 18 143 62 20 211 163 153 228 43 81 31 64 84 54 107 91 52 22 159 243 115 137 250 32 71 45 101 137 45 27 179 37 175 117 28 181 176 133 174 39 178 42 151 185 188 30 25 2 80 26 110 206 232 99 119 176 229 172 251 57 106 217 49 221 210 250 180 208 92 54 156 69 61 128 42 231 135 36 89 149 207 236 0 30 226 168 197 176 219 176 12 61 19 231 37 234 65 84 185 95 141 198 115 25 69 162 62 44 124 8 14 189 244 254 187 12 61 130 12 209 156 215 2 251 151 52 172 84 195 163 56 107 23 243 242 187 73 244 16 79 54 197 230 48 232 161 79 155 207 0 116 223 134 201 6 58 112 87 193 80 157 59 140 233 63 252 249 50 102 47 232 144 6 142 10 215 158 129 136 98 245 233 198 80 87 76 13 81 193 191 55 53 221 233 225 172 208 129 155 71 134 234 220 72 38 126 255 187 231 56 42 237 144 199 82 9 192 28 124 42 171 88 169 134 199 249 172 206 125 222 149 23 95 157 228 179 210 14 121 66 36 108 6 152 75 81 112 11 135 121 8 58 135 49 97 67 2 24 90 73 216 79 114 212 74 79 167 159 143 59 23 113 36 234 17 206 171 115 63 62 237 238 245 161 94 161 3 87 214 12 213 185 202 78 214 93 244 138 172 124 209 11 55 69 98 214 133 27 164 228 200 201 36 162 66 7 46 89 24 170 115 249 146 172 59 119 94 204 122 238 60 220 135 48 84 231 158 132 110 135 83 185 252 45 184 34 22 62 180 112 117 156 60 123 245 130 64 189 122 129 180 204 207 58 163 60 57 171 55 165 242 176 234 53 148 254 161 185 244 37 245 122 52 165 134 133 123 217 43 117 189 111 162 15 65 135 180 242 92 94 162 68 77 237 116 76 49 128 207 15 188 72 238 27 218 196 14 64 251 162 122 58 187 31 146 105 190 157 163 22 70 227 145 172 227 205 206 218 193 81 215 142 40 167 35 154 153 25 86 206 234 227 168 238 176 54 146 35 200 158 213 143 179 142 134 6 20 35 139 43 103 61 134 94 222 1 166 160 102 153 149 155 131 227 28 181 10 45 161 101 44 164 198 104 134 149 2 148 42 15 136 212 171 12 169 157 106 63 8 226 206 158 88 206 122 130 242 234 217 239 220 212 36 222 252 110 16 175 7 160 3 151 148 41 87 254 240 242 50 121 246 37 183 112 175 151 220 164 75 108 163 33 43 175 108 230 130 168 33 159 62 10 203 239 172 134 102 82 239 73 156 53 160 143 170 70 46 97 207 168 161 27 81 97 187 169 196 254 205 80 15 162 6 97 131 149 155 85 162 158 162 168 222 223 20 139 187 141 52 48 187 137 225 142 66 59 189 92 121 206 255 40 73 78 156 111 16 169 247 124 3 121 154 94 179 52 150 174 99 122 29 104 86 211 220 210 255 31 130 9 0 58 112 31 196 85 190 116 79 148 60 251 139 87 92 19 77 129 128 143 118 248 27 23 252 207 25 146 23 232 82 251 111 220 72 1 193 27 56 246 134 55 148 141 130 248 165 11 208 135 155 232 202 218 128 207 180 40 64 65 252 50 220 54 85 121 225 123 48 224 141 152 244 205 255 0 0 13 13 19 83 113 117 101 97 107 80 114 105 109 115 80 80 67 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 75 202 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 180 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 129 192 215 0 0 41 201 0 0 2 240 0 0 9 117 0 0 1 61 97 47 37 171 0 0 0 0 0 0 139 188 13 192 85 103 121 173 204 147 221 94 185 159 155 13 240 44 39 242 83 190 178 219 94 132 31 37 148 220 62 182 214 218 111 154 124 61 166 204 239 76 222 177 75 60 53 60 167 231 229 132 225 175 99 209 26 116 107 17 86 230 145 223 76 178 79 178 201 102 183 95 66 201 243 142 108 22 97 132 159 100 147 61 32 155 145 219 71 40 239 40 161 132 213 73 182 146 205 46 115 219 81 158 228 57 217 79 54 203 219 231 17 70 120 140 112 194 99 120 224 171 43 57 205 242 242 220 210 162 217 26 97 251 152 17 182 201 109 221 108 147 223 228 55 217 100 51 60 217 192 248 211 116 80 30 0 3 128 249 171 1 230 225 223 178 62 162 29 249 216 253 12 180 55 98 112 179 75 59 138 255 183 26 182 44 114 106 175 234 167 229 249 181 235 19 178 212 234 243 185 157 49 37 26 4 1 171 123 189 190 26 119 253 178 114 6 85 121 3 217 35 237 120 253 68 236 88 219 60 27 114 2 47 2 220 20 158 179 196 169 253 102 251 182 170 242 187 173 43 183 108 127 170 100 22 102 166 85 70 180 206 69 78 176 227 223 134 255 113 203 119 253 217 90 253 7 176 175 179 173 220 66 119 99 214 39 106 234 170 23 103 123 14 79 63 170 197 150 175 93 158 88 12 144 205 177 101 243 47 43 13 150 200 29 136 172 108 12 88 190 10 160 242 183 108 234 124 188 33 128 149 238 113 42 233 108 113 124 15 207 58 181 20 66 78 76 242 183 74 205 242 41 46 245 24 111 220 119 170 27 195 167 239 79 168 221 168 198 229 176 59 36 169 170 172 158 129 48 247 93 166 78 135 21 4 44 100 193 76 7 158 46 214 28 14 1 81 160 102 77 3 162 138 24 177 123 37 191 88 93 43 162 69 136 238 69 238 133 11 157 223 25 168 226 210 101 166 31 140 243 74 214 193 114 133 251 142 215 65 233 15 169 120 48 108 39 42 57 33 27 173 76 75 165 53 141 81 80 106 166 126 164 216 186 21 96 137 70 159 193 96 174 213 27 141 72 254 232 48 210 44 40 132 60 246 35 33 217 119 62 17 28 158 238 32 14 96 108 141 80 40 60 109 241 64 28 160 180 11 37 48 1 239 77 35 29 127 134 179 115 234 100 113 112 105 48 212 123 30 214 47 129 6 204 175 57 246 24 52 220 244 59 61 7 128 64 26 92 201 95 30 195 255 97 87 210 149 236 61 48 111 13 178 93 0 251 176 242 38 60 3 186 28 48 143 171 253 107 207 66 195 205 149 176 230 141 117 144 124 105 15 36 31 108 115 37 183 229 241 59 201 205 65 29 137 142 79 180 187 218 169 158 171 253 171 47 193 167 126 241 185 1 44 152 73 62 244 77 131 226 20 231 73 120 197 208 4 225 235 23 122 251 206 153 174 246 167 240 182 129 15 38 173 133 125 248 63 142 231 193 87 160 97 201 203 120 254 46 199 178 155 99 126 29 182 114 166 39 97 85 68 140 106 18 10 74 208 88 208 87 106 19 177 88 84 137 151 144 174 93 192 130 175 238 1 71 254 110 152 248 120 97 90 124 69 58 35 88 149 5 15 45 6 199 202 151 241 191 175 69 251 147 11 243 55 146 21 128 227 186 34 204 29 197 191 29 38 181 215 97 253 174 185 144 149 133 121 241 237 250 136 239 144 79 207 23 197 217 194 159 118 170 126 37 0 83 202 80 213 215 21 113 71 9 30 70 29 32 63 188 254 56 172 79 124 76 77 251 193 156 215 55 185 30 253 54 234 158 68 64 120 14 63 9 142 89 59 88 153 205 135 185 253 136 175 131 235 124 226 227 247 235 245 145 15 170 239 152 29 51 16 76 133 217 228 20 172 6 132 25 37 94 57 174 68 239 145 149 86 85 172 141 75 145 38 73 105 18 61 129 70 69 82 54 150 120 107 61 162 187 4 43 61 119 32 15 30 201 57 244 235 205 88 61 79 63 147 56 10 241 230 11 111 105 221 211 191 165 231 240 202 35 193 24 86 155 174 117 127 252 222 193 122 7 138 6 234 89 237 120 167 82 235 254 40 49 138 119 14 238 102 190 55 187 232 159 211 233 95 7 236 214 61 90 247 148 207 66 65 192 163 237 109 235 160 51 91 49 53 136 53 119 106 61 168 22 172 131 85 125 48 127 213 15 97 202 174 14 173 103 211 58 173 103 115 18 239 119 161 67 52 188 217 137 153 207 19 46 206 124 30 86 162 63 85 187 83 23 131 227 87 96 165 14 195 104 48 60 129 72 171 172 156 116 231 209 10 48 185 135 61 183 247 0 254 237 155 64 168 208 246 31 229 189 67 214 179 123 23 131 112 176 16 166 149 250 124 158 107 237 16 153 97 105 44 22 50 7 192 225 245 122 150 102 234 228 163 17 136 203 194 228 142 68 253 153 26 94 159 167 194 36 0 71 189 27 77 208 12 128 215 154 218 154 65 128 31 224 168 43 95 93 103 113 54 182 248 123 123 123 129 245 60 202 47 30 252 2 119 41 215 67 65 244 111 75 153 109 169 20 10 69 163 17 177 82 14 113 115 253 80 177 0 7 183 236 132 206 5 197 176 189 100 15 93 33 28 130 211 127 14 175 205 91 175 119 182 67 234 208 113 100 57 253 11 23 154 2 224 176 56 253 231 8 249 59 142 84 79 113 141 215 216 48 144 203 56 228 182 115 132 92 8 93 175 45 255 213 171 189 15 199 8 27 19 16 135 79 82 253 82 232 44 177 58 175 49 105 240 153 231 159 56 252 195 204 102 120 165 38 148 112 88 9 199 251 78 116 9 135 224 60 213 71 245 135 165 70 190 247 162 94 213 115 62 109 69 26 74 213 48 247 105 126 255 93 159 94 237 174 30 237 99 236 84 164 98 164 147 105 138 250 19 255 179 32 222 127 40 170 50 210 52 140 225 80 91 66 141 153 58 249 190 242 243 172 34 142 120 194 36 0 7 69 150 19 85 242 31 94 125 164 69 189 35 191 173 248 14 243 150 142 28 169 63 83 227 74 71 62 132 195 52 160 35 175 94 90 37 142 242 225 245 213 103 248 48 251 232 236 223 99 245 74 103 63 130 227 114 103 63 138 99 172 179 31 229 117 172 179 207 224 48 95 232 236 7 249 248 87 103 63 68 236 7 157 125 6 199 88 103 63 8 227 106 103 63 130 195 60 160 179 207 114 170 114 243 251 62 13 208 121 227 49 156 138 40 132 165 115 209 159 187 6 124 186 130 251 180 249 71 71 254 158 240 175 116 228 103 29 214 52 160 35 175 15 68 110 189 69 108 43 190 237 223 29 121 222 63 58 42 4 122 206 57 46 117 84 35 56 46 119 66 163 124 140 117 66 25 28 151 156 126 16 199 85 167 31 193 97 113 142 184 226 56 196 129 198 48 218 186 95 115 160 52 142 80 96 216 22 251 95 62 206 42 141 112 68 27 113 144 233 44 142 234 198 96 6 71 174 119 104 92 228 162 35 142 243 122 221 149 166 0 162 248 219 91 197 56 100 139 43 254 60 14 116 178 208 112 207 58 145 112 208 104 162 232 142 134 99 129 208 59 236 167 156 3 21 47 223 109 10 192 235 53 231 72 247 244 35 111 3 151 112 100 28 58 163 179 180 179 198 135 101 118 41 172 56 237 199 19 194 134 11 115 143 217 193 104 75 36 44 133 135 102 83 207 7 34 100 116 16 112 194 208 228 37 72 8 230 47 26 232 139 201 52 55 219 167 139 254 12 205 162 146 82 244 108 62 228 96 134 255 140 251 61 144 115 97 2 248 124 44 193 208 95 251 89 114 245 201 201 218 171 65 120 250 146 167 39 141 17 231 201 162 197 144 155 34 31 233 172 148 165 38 89 81 199 90 14 27 88 248 160 177 81 159 189 216 63 146 254 142 174 204 124 226 174 187 212 184 164 240 7 70 243 134 32 25 59 192 34 24 182 200 82 59 3 40 200 43 211 102 217 205 183 12 152 0 80 110 254 192 56 155 140 60 210 254 129 19 49 222 216 11 161 4 194 106 32 226 83 68 202 4 226 129 13 127 89 120 96 74 18 187 208 229 89 191 14 78 143 84 169 235 91 197 191 190 40 155 17 8 247 237 46 104 112 219 2 121 151 208 183 245 98 52 4 27 214 194 217 120 227 51 125 9 199 2 119 117 89 249 2 113 65 89 105 93 41 30 125 203 220 117 11 204 86 36 96 51 150 176 24 49 176 87 38 59 241 149 61 215 211 134 135 233 236 103 32 196 86 241 87 198 105 49 5 159 20 103 193 252 218 186 154 57 88 241 27 253 245 115 75 249 19 29 239 154 238 252 49 208 214 134 124 202 173 184 15 232 157 102 50 229 170 30 6 154 9 164 189 5 144 184 30 62 137 199 29 148 155 80 7 205 120 36 188 48 123 30 32 86 86 69 185 156 63 194 167 49 247 101 202 61 208 11 180 105 224 39 148 147 94 131 199 120 159 142 17 220 0 95 231 238 134 209 90 15 79 96 142 111 181 184 125 30 124 31 115 109 148 187 229 121 120 6 115 95 162 220 13 219 96 63 62 196 61 73 185 143 88 160 23 105 69 92 200 77 7 252 30 115 28 107 206 23 225 8 192 140 73 148 139 254 128 148 49 3 183 71 224 14 140 73 108 34 230 248 187 83 240 25 54 29 115 124 198 177 241 105 134 11 24 102 114 142 87 188 198 110 199 92 13 231 169 147 225 172 224 76 222 61 172 13 51 47 128 200 183 169 44 251 57 107 192 28 42 13 160 228 121 134 15 225 34 127 170 157 223 197 112 150 102 182 147 114 139 28 236 1 100 139 191 79 183 84 178 135 113 53 5 215 86 209 11 12 121 156 83 204 69 183 155 182 106 204 227 53 62 156 164 156 192 247 46 20 248 112 215 143 236 143 139 168 91 53 16 141 76 245 74 205 1 191 232 150 98 39 158 142 241 233 39 117 81 127 73 159 152 190 96 96 200 231 227 5 125 21 199 211 0 138 59 218 36 127 66 142 228 165 135 81 248 53 163 98 129 49 82 149 42 153 202 215 75 74 36 16 105 86 173 229 77 129 120 84 201 170 136 70 226 249 41 166 202 219 226 138 164 22 184 19 106 60 26 22 239 144 55 222 19 85 154 84 91 169 223 47 35 95 62 41 222 162 90 235 36 165 89 142 219 150 38 2 161 38 163 96 238 42 55 174 24 145 227 137 216 120 154 85 53 136 177 83 174 44 160 34 213 114 184 17 41 200 75 15 178 242 58 41 110 245 17 140 20 81 70 186 143 39 119 133 23 139 141 231 239 98 6 48 202 29 7 150 222 89 145 67 41 28 8 226 245 12 128 54 125 52 26 249 139 200 33 27 78 101 245 97 253 63 0 65 109 177 88 4 208 212 91 0 250 233 234 221 163 88 189 122 21 245 86 41 103 5 58 51 73 108 54 156 140 247 31 254 184 154 129 155 14 180 56 115 74 180 9 205 179 37 61 59 51 251 176 143 220 111 35 239 69 95 216 253 151 60 41 147 247 175 253 236 188 253 217 219 103 221 29 251 144 221 15 155 245 40 87 174 250 160 210 203 177 140 63 152 55 54 147 151 235 190 55 189 159 103 154 135 188 231 115 154 254 193 233 93 127 234 231 85 113 103 235 43 118 90 60 139 75 241 135 213 20 117 246 74 55 203 26 208 21 0 133 203 183 199 122 227 70 79 60 220 29 78 134 183 152 70 71 56 98 38 142 41 110 251 243 198 104 11 170 185 4 92 79 191 213 131 143 122 77 52 105 198 59 66 109 102 109 120 211 95 87 126 60 239 197 30 153 117 107 43 27 123 163 201 112 183 89 252 159 155 240 245 89 217 17 69 103 143 253 175 59 184 245 184 31 248 180 84 34 217 187 201 38 160 219 169 181 231 252 215 198 183 254 246 182 243 181 84 93 67 237 74 155 224 29 96 106 100 228 191 220 13 73 53 87 175 27 190 83 208 212 191 9 244 134 38 179 211 178 134 76 232 33 216 30 122 1 106 239 101 234 63 64 38 217 23 91 95 155 72 218 1 106 239 241 237 202 115 76 161 119 54 172 140 36 108 143 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 13:41' prior: 35763398!macExternalPrimsFile	^ '#include <CodeFragments.h>#include <Strings.h>#include "sq.h"/*** Variables ***/CFragConnectionID squeakVMLib = nil;  /* connection to the VM itself as a shared library *//*** Function Type Declaration ***/typedef int (*RecordVMProxyProc)(struct VirtualMachine *interpreterProxy);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag) {	CFragLoadOptions action;	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg;	OSErr err;	action = loadFlag ? kLoadCFrag : kFindCFrag;	err = GetSharedLibrary(		c2pstr(libName), kCurrentCFragArch, action, &libHandle, &mainAddr, errorMsg);	p2cstr((unsigned char *) libName);  /* undo C to Pascal conversion */	if (err) {		return null;	}	return libHandle;}int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength, int moduleNameIndex, int moduleNameLength){	Str255 functionName, moduleName;	CFragConnectionID libHandle;	CFragSymbolClass ignored;	Ptr functionPtr;	OSErr err;	int i;	/* copy function and module names into C strings */	for (i = 0; i < functionNameLength; i++) {		functionName[i] = ((char *) functionNameIndex)[i];	}	functionName[functionNameLength] = 0;	for (i = 0; i < moduleNameLength; i++) {		moduleName[i] = ((char *) moduleNameIndex)[i];	}	moduleName[moduleNameLength] = 0;	/* find the library */	if (moduleNameLength > 0) {		/* look for the primitive in named library */		/* first try to find it */		libHandle = FindOrLoadLib((char *) moduleName, false);		if (!!libHandle) {			/* then try to load it */			libHandle = FindOrLoadLib((char *) moduleName, true);		}	} else {		/* look for the primitive in the Squeak VM itself */		if (!!squeakVMLib) {			/* try to get a handle on the Squeak VM itself, viewed as a library */			squeakVMLib = FindOrLoadLib("SqueakVMPrims", false);		}		libHandle = squeakVMLib;	}	if (!!libHandle) return success(false);  /* could not open the library */	/* if library is external, initialize its VMProxy pointer */	if (libHandle !!= squeakVMLib) {		/* get the setInterpreter() function */		err = FindSymbol(libHandle, "\psetInterpreter", &functionPtr, &ignored);		if (err) return success(false);		/* call setInterpreter() */		((RecordVMProxyProc) functionPtr)(sqGetInterpreterProxy());	}	/* get the address of the desired primitive function */	c2pstr((char *) functionName);	err = FindSymbol(libHandle, functionName, &functionPtr, &ignored);	if (err) return success(false);	return (int) functionPtr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 14:16' prior: 34433642!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 12:57' prior: 35771559!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** pluggable primitive support ***/int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 12:55' prior: 35794352!squeakVirtualMachineHeaderFile^ '#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0struct VirtualMachine* sqGetInterpreterProxy(void);typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);	/* InterpreterProxy methodsFor: ''stack access'' */	int (*pop)(int nItems);	int (*popthenPush)(int nItems, int oop);	int (*push)(int object);	int (*pushBool)(int trueOrFalse);	int (*pushFloat)(double f);	int (*pushInteger)(int integerValue);	double (*stackFloatValue)(int offset);	int (*stackIntegerValue)(int offset);	int (*stackObjectValue)(int offset);	int (*stackValue)(int offset);		/* InterpreterProxy methodsFor: ''object access'' */	int (*argumentCountOf)(int methodPointer);	void * (*arrayValueOf)(int oop);	int (*byteSizeOf)(int oop);	void * (*fetchArrayofObject)(int fieldIndex, int objectPointer);	int (*fetchClassOf)(int oop);	double (*fetchFloatofObject)(int fieldIndex, int objectPointer);	int (*fetchIntegerofObject)(int fieldIndex, int objectPointer);	int (*fetchPointerofObject)(int index, int oop);	int (*fetchWordofObject)(int fieldIndex, int oop);	void * (*firstFixedField)(int oop);	void * (*firstIndexableField)(int oop);	int (*literalofMethod)(int offset, int methodPointer);	int (*literalCountOf)(int methodPointer);	int (*methodArgumentCount)(void);	int (*methodPrimitiveIndex)(void);	int (*primitiveIndexOf)(int methodPointer);	int (*sizeOfSTArrayFromCPrimitive)(void *cPtr);	int (*slotSizeOf)(int oop);	int (*stObjectat)(int array, int index);	int (*stObjectatput)(int array, int index, int value);	int (*stSizeOf)(int oop);	int (*storeIntegerofObjectwithValue)(int index, int oop, int integer);	int (*storePointerofObjectwithValue)(int index, int oop, int valuePointer);		/* InterpreterProxy methodsFor: ''testing'' */	int (*isKindOf)(int oop, char *aString);	int (*isMemberOf)(int oop, char *aString);	int (*isBytes)(int oop);	int (*isFloatObject)(int oop);	int (*isIndexable)(int oop);	int (*isIntegerObject)(int objectPointer);	int (*isIntegerValue)(int intValue);	int (*isPointers)(int oop);	int (*isWeak)(int oop);	int (*isWords)(int oop);	int (*isWordsOrBytes)(int oop);		/* InterpreterProxy methodsFor: ''converting'' */	int (*booleanValueOf)(int obj);	int (*checkedIntegerValueOf)(int intOop);	int (*floatObjectOf)(double aFloat);	double (*floatValueOf)(int oop);	int (*integerObjectOf)(int value);	int (*integerValueOf)(int oop);	int (*positive32BitIntegerFor)(int integerValue);	int (*positive32BitValueOf)(int oop);		/* InterpreterProxy methodsFor: ''special objects'' */	int (*characterTable)(void);	int (*displayObject)(void);	int (*falseObject)(void);	int (*nilObject)(void);	int (*trueObject)(void);		/* InterpreterProxy methodsFor: ''special classes'' */	int (*classArray)(void);	int (*classBitmap)(void);	int (*classByteArray)(void);	int (*classCharacter)(void);	int (*classFloat)(void);	int (*classLargePositiveInteger)(void);	int (*classPoint)(void);	int (*classSemaphore)(void);	int (*classSmallInteger)(void);	int (*classString)(void);		/* InterpreterProxy methodsFor: ''instance creation'' */	int (*clone)(int oop);	int (*instantiateClassindexableSize)(int classPointer, int size);	int (*makePointwithxValueyValue)(int xValue, int yValue);	int (*popRemappableOop)(void);	int (*pushRemappableOop)(int oop);		/* InterpreterProxy methodsFor: ''other'' */	int (*becomewith)(int array1, int array2);	int (*byteSwapped)(int w);	int (*failed)(void);	int (*fullDisplayUpdate)(void);	int (*fullGC)(void);	int (*incrementalGC)(void);	int (*primitiveFail)(void);	int (*showDisplayBitsLeftTopRightBottom)(int aForm, int l, int t, int r, int b);	int (*signalSemaphoreWithIndex)(int semaIndex);	int (*success)(int aBoolean);	int (*superclassOf)(int classPointer);	} VirtualMachine;#endif /* _SqueakVM_H */'! !InterpreterSupportCode class removeSelector: #macExternalPrims!'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:40:16 pm'!!ParagraphEditor methodsFor: 'private' stamp: 'di 11/25/1998 14:40' prior: 37329246!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: stopBlock stringIndex				caseSensitive: ChangeText ~~ FindText.	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 3:16:56 pm'!!SystemWindow methodsFor: 'top window' stamp: 'di 11/25/1998 15:15' prior: 37330076!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	outerMorph _ self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !----SNAPSHOT----(25 November 1998 3:29:55 pm ) priorSource: 3776263!'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:35 pm'!"Change Set:		jhmVMDisplayTweaksDate:			25 November 1998Author:			John MaloneyMinor tweaks to the the display code to ensure that updates getforced to the screen on demand even on VM's that defer updating.Suggested by Tim Rowledge."!!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:19' prior: 18083655!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.		self ioForceDisplayUpdate].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:20' prior: 18091968!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left displayObj dispBits w h d dispBitsPtr |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj].	left < 0 ifTrue: [left _ 0].	right > w ifTrue: [right _ w].	top < 0 ifTrue: [top _ 0].	bottom > h ifTrue: [bottom _ h].	self success: ((left <= right) and: [top <= bottom]).	successFlag ifTrue: [		dispBitsPtr _ dispBits + BaseHeaderSize.		self cCode: 'ioShowDisplay(dispBitsPtr, w, h, d, left, right, top, bottom)'.		self ioForceDisplayUpdate].	successFlag ifTrue: [self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:14' prior: 35731128!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.		self ioForceDisplayUpdate.	].! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 11/23/1998 21:44' prior: 36986094!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:11' prior: 19287118!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.		self ioForceDisplayUpdate].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:10' prior: 19295739!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left displayObj dispBits w h d dispBitsPtr |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj].	left < 0 ifTrue: [left _ 0].	right > w ifTrue: [right _ w].	top < 0 ifTrue: [top _ 0].	bottom > h ifTrue: [bottom _ h].	self success: ((left <= right) and: [top <= bottom]).	successFlag ifTrue: [		dispBitsPtr _ dispBits + BaseHeaderSize.		self cCode: 'ioShowDisplay(dispBitsPtr, w, h, d, left, right, top, bottom)'.		self ioForceDisplayUpdate].	successFlag ifTrue: [self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 11/25/1998 12:14' prior: 35738790!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.		self ioForceDisplayUpdate.	].! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 11/23/1998 21:44' prior: 36995333!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:31 pm'!"Change Set:		jhmExportMacrosDate:			25 November 1998Author:			John MaloneyMinor changes to the way exports are handled for pluggableprimitives. (Needed for the Mac CodeWarrior environment.)"!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'jm 11/24/1998 16:06' prior: 16981516!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	self export: true.	interpreterProxy _ anInterpreter.! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 09:09' prior: 17231156!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	| exporting |	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	exporting _ false.	methods do: [:m |		m export			ifTrue: [				exporting ifFalse: [					aStream nextPutAll: '#pragma export on'; cr.					exporting _ true]]			ifFalse: [				exporting ifTrue: [					aStream nextPutAll: '#pragma export off'; cr.					exporting _ false]].		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr].		exporting ifTrue: [			aStream nextPutAll: '#pragma export off'; cr].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 11/25/1998 13:39' prior: 34309485!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 16:00' prior: 35746725!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define successFlag (!!interpreterProxy->failed())#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayValueOf(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value)#pragma export onEXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter);#pragma export off/*** Variables ***/struct VirtualMachine *interpreterProxy;EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == false) {		return false;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'jm 11/24/1998 08:27' prior: 35749161!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */';cr.	aStream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)'.	aStream cr.! !!TMethod methodsFor: 'accessing' stamp: 'jm 11/24/1998 09:03'!export	^ export! !'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:28 pm'!"Change Set:		ObjectMemTweaksDate:			23 November 1998Author:			John MaloneySome VM improvements from Georg Gollmann:  - fixed a bug that limited image size to about 512 MB  - fixed a bug that limited object size to below 256 MB  - changed some literal constants to symbolic onesModified by John Maloney to:  - merge with WeakArray support  - omitted the change allowing use of the upper half of the    address space since it made incremental GC slightly slower (1-2%)    and does not seem likely to be needed soon (few machines have    over 2 gigabytes of memory!!!!)"!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FloatProto FreeSizeMask GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ObjectMemory methodsFor: 'interpreter access' stamp: 'jm 11/24/1998 00:13' prior: 35589622!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: ((hash << HashBitsOffset) bitAnd: HashBits).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize _ (header1 bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: AllButTypeMask. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'go 11/18/1998 11:03' prior: 20170252!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/18/1998 11:04' prior: 20177954!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: SizeMask) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: CompactClassMask) = 0				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04' prior: 20178541!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57' prior: 20178788!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/17/1998 15:57' prior: 20179251!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: SizeMask ].! !!ObjectMemory methodsFor: 'header access' stamp: 'go 11/13/1998 17:04' prior: 20179753!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: AllButTypeMask! !!ObjectMemory methodsFor: 'allocation' stamp: 'go 11/18/1998 11:04' prior: 20189342!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader ccField isMethodCntx |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		ccField _ cntxHeader bitAnd: CompactClassMask.		ccField = 0 ifTrue: [			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.		] ifFalse: [			"compare ccField with compact class bits from format word of methodCntxClass"			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: CompactClassMask).		].		isMethodCntx ifTrue: [			"Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: SizeMask) = SmallContextSize ifTrue: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.				freeSmallContexts _ cntxOop.				] ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'go 11/17/1998 15:56' prior: 20196472!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: SizeMask ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'go 11/18/1998 11:04' prior: 20202124!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: CompactClassMask) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'jm 11/23/1998 23:01' prior: 35594514!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: SizeMask.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: SizeMask.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: AllButTypeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/24/1998 00:07' prior: 20211029!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"(use quadword alignment for better cache performance)"	fwdTableNext _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/24/1998 00:03' prior: 35598612!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/23/1998 23:12' prior: 20219470!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ realHeader bitAnd: SizeMask ].	^ self oopFromChunk: (oop + sz)! !!DynamicContextCache methodsFor: 'utilities' stamp: 'go 11/18/1998 13:00' prior: 17963188!changeClassOf: anObject to: aClass	"Used to mutate a PseudoContext to/from a stable Method/BlockContext.	Notes:	Tacitly assumes that the type bits are the SAME for the source and destination!!			This method should be in ObjectMemory."	| ccClass hdrObject ccObject |	self inline: false.	hdrObject _ self baseHeader: anObject.	ccObject _ hdrObject bitAnd: CompactClassMask.	ccObject = 0 ifTrue: [		"object has uncompact class"		self classHeader: anObject put: aClass.	] ifFalse: [		"object has compact class"		ccClass _ (self formatOfClass: aClass) bitAnd: CompactClassMask.		ccClass ~= 0 ifTrue: [			"object has compact class; class is compact"			hdrObject _ (hdrObject bitXor: ccObject) bitOr: ccClass.			self baseHeader: anObject put: hdrObject.		] ifFalse: [			"object has compact class; class is uncompact"			self error: 'cannot mutate header from compact to uncompact'.		]	]! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'go 11/18/1998 10:51' prior: 18308058!compactSend: tMeth type: type	| nArgs rcvr rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: CompactClassMask) + 1].	self checkSend: tMeth to: rcvr data: rcvrClass nArgs: nArgs type: type! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'go 11/18/1998 10:51' prior: 18311073!linkSendOpcode: ip type: type receiver: rcvr class: rcvrClass method: tMeth	"Rewrite the send opcode at ip.	ip:		the address of the linked extension word.	type:	0=short, 1=extended, 2=double-extended.	class:	the receiver class for which the inline cache hits."	"Note: the opcode itself is located at (ip - 4 - (type * 8))."	| op addr sendType linkData ccIndex currentMethod |	self assertAny: (addr _ 0).	self assertAny: (sendType _ 0).	(self isIntegerObject: rcvr)		ifTrue: [sendType _ ImmediateSendType.  linkData _ ConstZero]		ifFalse:			[ccIndex _ ((self formatOfClass: rcvrClass) bitAnd: CompactClassMask).			 ccIndex > 0				ifTrue: [sendType _ CompactSendType.  linkData _ ccIndex + 1]				ifFalse: [sendType _ NormalSendType.  linkData _ rcvrClass]].	self assert: (sendType ~= 0).	type = ShortSendType	 		ifTrue:	[addr _ ip - 4.	op _ shortSendTable at: sendType]			ifFalse: [	type = ExtendedSendType			ifTrue:	[addr _ ip - 12.	op _ extendedSendTable at: sendType]		ifFalse: [	type = DoubleExtendedSendType	ifTrue:	[addr _ ip - 20.	op _ doubleExtendedSendTable at: sendType]	]].	self assert: (addr ~= 0).	self longAt: addr put: op.	self longAt: ip put: tMeth.	self storePointer: MethodLinkageIndex ofObject: tMeth withValue: linkData.	tMeth >= youngStart ifTrue:		"store of young object into old object"		[currentMethod _ self translatedMethod.		 currentMethod < youngStart			ifTrue: [self addMethodRoot: currentMethod]].! !!DynamicTranslator methodsFor: 'obsolete' stamp: 'go 11/18/1998 10:51' prior: 18396268!oldCompactSend: tMeth type: type	| nArgs rcvr prevClass rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	prevClass _ (self fetchPointer: MethodLinkageIndex ofObject: tMeth) - 1.	self assert: prevClass ~= 0.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: CompactClassMask)].	(rcvrClass = prevClass) ifTrue: [		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18041166!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18043532!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:54' prior: 18044288!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: SizeMask ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreterSimulator methodsFor: 'testing' stamp: 'go 11/18/1998 10:50' prior: 18222723!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		self validOop: former].! !!DynamicInterpreterSimulator methodsFor: 'debug support' stamp: 'jm 11/23/1998 22:44' prior: 18225727!dumpHeader: hdr	| cc |	^ String streamContents: [:strm |		cc _ (hdr bitAnd: CompactClassMask) >> 12.		strm nextPutAll: '<cc=', cc hex.		cc > 0 ifTrue:			[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].		strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: SizeMask) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>']! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19250171!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19252446!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: SizeMask ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'go 11/17/1998 15:55' prior: 19253195!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: SizeMask ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!InterpreterSimulator methodsFor: 'testing' stamp: 'go 11/18/1998 10:51' prior: 19400478!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		self validOop: former].! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'jm 11/23/1998 22:44' prior: 19403281!dumpHeader: hdr	| cc |	^ String streamContents: [:strm |		cc _ (hdr bitAnd: CompactClassMask) >> 12.		strm nextPutAll: '<cc=', cc hex.		cc > 0 ifTrue:			[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].		strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: SizeMask) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>']! !!ObjectMemory class methodsFor: 'initialization' stamp: 'go 11/18/1998 10:42' prior: 20229088!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	SizeMask _ 16rFC.	CompactClassMask _ 16r1F000.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.! !Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!'From Squeak 2.2 of Sept 23, 1998 on 25 November 1998 at 2:44:23 pm'!"Change Set:		jhmVMSupportCodeDate:			25 November 1998Author:			John MaloneyChanges the the C support code for Squeak 2.3. Includessupport for pluggable primitives."!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 11/25/1998 13:39' prior: 37529949!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 14:17' prior: 34315814!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ #(83 73 84 33 0 3 0 0 49 96 114 76 97 117 2 66 0 0 0 22 7 147 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 186 147 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 180 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 178 129 191 175 0 0 40 235 0 0 37 50 0 0 8 193 0 0 9 109 153 1 222 33 0 0 0 0 0 0 174 78 13 192 248 163 239 117 178 149 249 29 97 132 37 161 156 94 135 223 198 138 30 225 118 43 151 108 35 116 211 77 201 179 91 47 153 151 157 135 39 84 66 159 211 75 158 246 248 94 218 42 211 243 218 248 143 157 21 217 199 214 142 91 39 25 240 8 37 191 201 38 236 229 73 216 38 155 145 125 236 54 217 100 31 35 156 220 62 178 143 17 78 54 225 73 40 161 132 21 97 132 19 70 246 217 155 177 109 140 108 194 200 115 194 179 35 183 37 183 143 108 175 35 124 5 190 186 146 211 231 231 145 45 221 210 162 39 95 217 102 132 235 17 182 201 241 147 240 200 115 114 251 200 38 155 225 201 6 232 4 2 208 79 0 3 224 0 224 198 103 0 214 226 191 104 153 96 238 214 132 152 44 69 13 33 33 75 170 96 198 36 83 48 180 132 172 169 178 32 199 141 242 174 79 165 100 105 160 190 161 205 151 212 181 157 109 60 86 23 197 80 103 176 119 75 51 7 91 215 78 163 127 196 211 175 175 111 222 117 135 10 80 243 34 178 30 151 133 112 92 138 12 8 90 202 140 43 72 144 40 27 22 103 51 166 24 2 254 204 152 44 68 229 126 41 21 55 113 111 12 152 90 82 72 234 138 106 202 186 111 75 55 59 60 117 72 136 72 170 170 153 66 24 217 104 187 228 168 160 245 247 219 36 172 58 97 57 34 165 12 89 80 76 162 135 130 240 224 194 221 90 102 132 127 44 23 240 88 168 8 145 17 220 93 174 57 183 120 100 225 113 0 96 145 93 91 73 145 74 81 138 8 29 93 66 125 195 128 16 188 53 184 110 157 239 59 211 85 252 180 41 182 55 246 254 118 110 132 43 227 63 61 85 199 7 165 54 178 168 179 247 181 74 62 40 225 32 147 201 194 153 12 71 139 160 213 214 150 214 129 3 0 27 51 244 217 10 150 185 68 77 149 34 218 28 211 98 168 3 15 247 56 159 158 216 191 182 24 61 106 79 0 43 128 227 6 120 157 63 93 244 8 196 1 2 143 161 5 150 226 185 42 242 241 94 166 206 249 93 209 10 102 13 14 253 238 193 250 141 208 135 248 246 87 30 134 190 155 158 179 48 0 36 210 231 79 255 242 21 252 255 222 159 246 167 127 245 244 141 219 81 237 10 120 10 43 15 227 30 122 136 66 187 127 232 203 39 161 239 150 86 216 254 167 123 32 253 236 41 72 223 63 232 79 31 244 176 51 233 125 59 45 38 22 63 161 210 63 68 245 252 67 15 61 11 119 254 226 129 105 46 136 164 63 127 196 150 56 171 121 26 206 218 158 32 126 147 70 31 58 182 218 63 244 109 60 109 243 131 229 119 193 83 248 159 226 115 255 89 232 219 120 6 247 223 101 92 78 48 206 47 194 1 166 244 114 172 138 140 185 223 0 95 211 40 202 166 174 237 150 245 1 67 232 50 37 53 42 233 81 161 93 9 235 146 190 167 81 236 106 23 130 141 0 238 209 163 30 24 117 255 238 215 251 144 141 199 218 215 33 84 135 39 143 252 53 51 86 253 136 133 225 145 209 90 170 86 157 25 219 112 239 76 189 163 55 79 215 59 148 198 51 173 153 177 143 153 36 157 123 244 209 19 238 234 251 54 177 255 215 110 30 1 238 182 83 153 177 235 62 7 21 74 123 230 39 131 35 180 119 215 156 124 30 107 30 203 140 103 50 84 7 171 86 195 71 122 126 0 215 29 31 201 140 15 223 147 25 223 71 156 30 67 119 244 189 124 8 145 47 16 47 102 30 143 187 6 255 86 181 59 88 71 89 14 124 69 35 54 87 236 173 93 169 100 82 211 205 198 251 192 189 122 243 126 198 158 42 142 30 189 9 134 108 15 28 124 199 3 7 127 190 254 93 15 132 142 157 247 192 222 35 236 63 235 129 31 146 50 182 7 246 98 247 248 183 7 176 153 158 6 23 37 12 22 48 218 208 254 234 128 172 159 235 206 118 133 80 40 248 247 10 176 106 131 123 244 240 211 248 175 28 6 190 37 243 179 63 179 236 80 12 135 215 3 255 219 58 168 10 132 66 237 215 226 16 53 195 64 50 137 61 223 9 128 135 40 182 55 21 234 148 99 51 20 182 36 168 51 144 244 111 212 16 67 237 45 14 1 60 122 131 216 205 156 0 116 237 236 234 156 33 248 30 143 238 230 109 221 69 190 112 44 130 142 102 14 102 221 233 240 42 247 232 87 79 81 167 129 186 170 184 183 73 138 199 53 77 21 90 229 120 210 110 39 88 3 232 188 187 236 121 150 103 136 7 239 139 204 243 245 138 189 86 178 157 117 135 197 163 216 23 89 183 206 17 128 71 145 47 50 47 200 63 121 216 178 59 0 232 154 156 35 114 133 135 60 56 47 200 165 101 249 53 246 95 191 86 78 240 200 171 177 20 121 132 36 35 34 197 47 8 107 233 154 148 12 167 0 30 145 57 101 11 186 82 67 35 30 46 226 241 86 39 90 228 193 251 206 231 168 201 85 212 41 223 123 217 175 198 124 159 118 161 12 1 35 193 250 180 93 246 92 159 222 22 236 184 152 99 42 169 72 75 62 201 68 181 72 234 127 45 136 229 15 221 208 243 161 97 129 135 17 139 135 11 117 202 67 205 111 171 138 60 204 148 67 0 15 90 197 62 116 201 127 116 13 145 23 11 153 221 1 37 145 163 244 111 212 184 154 200 103 121 56 6 36 242 142 166 173 116 47 157 215 67 12 245 22 244 112 250 72 246 111 170 122 53 217 231 121 92 73 246 23 121 44 36 251 139 186 46 36 251 2 15 231 133 100 63 163 199 191 146 253 172 176 239 37 251 2 143 133 100 63 67 227 253 100 159 231 225 28 144 236 139 125 134 188 227 173 62 13 205 32 34 126 198 194 215 224 188 206 100 159 126 137 13 131 56 127 36 242 55 141 127 53 145 95 232 176 142 1 137 188 87 81 111 251 168 48 216 80 255 65 34 247 188 155 168 144 232 124 231 88 76 84 121 30 87 146 208 69 61 22 146 80 129 199 98 167 159 225 241 126 167 207 243 40 242 229 187 98 41 242 192 198 112 49 186 95 235 64 57 30 113 101 174 45 78 222 124 92 112 26 241 208 194 56 200 116 129 71 71 120 103 129 71 153 56 59 46 114 185 35 150 138 98 176 213 17 192 20 239 220 85 148 162 90 204 241 111 243 192 78 22 159 203 172 203 136 71 92 50 12 33 168 37 146 74 252 117 245 179 157 3 29 47 247 59 2 232 122 173 115 228 50 125 254 110 96 145 71 161 67 23 124 150 235 172 230 156 205 22 151 11 167 253 24 192 239 186 52 247 88 178 83 139 169 9 41 33 127 192 22 25 114 180 225 113 194 208 225 101 145 17 156 95 60 48 177 86 66 9 142 25 179 62 196 230 101 17 180 39 90 105 22 149 14 89 104 57 184 167 28 4 48 78 39 150 90 83 218 66 143 56 127 137 49 187 90 2 93 221 214 109 127 227 254 74 28 29 189 182 54 226 154 0 255 54 105 12 21 135 206 21 109 128 178 108 255 197 209 133 86 156 73 151 117 99 33 114 120 217 132 118 206 25 207 96 68 156 58 97 185 165 202 246 73 83 74 137 155 183 40 170 16 210 149 132 98 42 187 100 103 128 32 225 132 178 238 190 219 48 37 157 13 162 58 55 44 178 241 10 242 54 107 139 211 103 169 87 230 154 229 24 184 156 0 90 217 70 7 8 197 185 149 236 189 2 103 154 117 156 38 220 11 175 31 80 22 177 178 13 135 23 7 244 167 247 16 182 57 2 164 156 130 113 95 77 65 51 175 45 208 107 5 188 253 102 193 165 197 123 177 86 136 93 31 216 113 208 217 101 173 168 13 118 108 106 174 21 106 55 5 186 3 184 13 109 9 118 215 58 173 88 192 75 175 109 228 214 244 203 46 37 169 135 234 86 142 227 145 106 238 27 192 39 123 216 45 99 85 82 199 43 69 156 239 239 234 238 252 48 86 28 158 164 163 191 192 174 232 88 218 232 124 2 214 224 214 71 216 230 7 129 174 226 26 8 107 13 1 93 229 158 36 44 249 99 192 121 60 174 138 176 196 94 232 68 140 205 11 126 252 73 192 11 102 238 78 194 42 30 6 5 49 124 97 0 224 179 159 4 124 9 6 95 150 192 213 118 24 62 131 216 203 140 235 215 225 65 236 110 171 8 171 55 224 32 94 178 173 39 108 205 30 248 10 74 70 154 192 173 127 128 111 33 198 184 222 254 37 248 30 202 250 69 194 250 119 97 206 131 106 60 139 183 201 10 252 20 177 71 9 107 122 2 206 32 246 36 97 171 174 135 23 240 5 154 253 132 149 12 195 95 16 163 55 54 32 252 125 124 233 3 106 216 91 26 218 114 110 25 50 126 156 176 210 151 184 26 196 208 69 152 30 142 114 232 129 53 207 17 166 212 115 159 0 16 142 17 38 109 224 2 0 31 250 17 227 116 150 19 1 110 120 128 176 193 1 14 223 77 184 225 56 51 212 9 122 9 101 45 171 113 125 154 48 238 52 243 68 8 95 210 145 35 166 128 158 52 20 77 45 103 215 255 19 151 193 75 104 64 36 168 69 229 205 178 234 201 13 139 176 99 118 229 10 123 228 41 91 50 139 247 74 186 170 168 59 12 87 115 84 49 53 189 184 69 83 205 242 44 219 230 65 83 151 140 138 96 202 48 181 132 208 38 239 217 173 233 81 195 27 136 68 100 188 138 14 73 102 204 112 117 75 250 14 217 244 210 253 72 212 46 88 214 19 196 231 47 100 51 149 92 66 179 164 182 48 149 132 109 82 12 188 197 150 19 97 148 192 147 27 52 101 117 108 214 229 214 136 68 86 40 27 158 208 41 216 34 98 177 37 244 108 68 150 24 97 83 196 114 111 74 184 9 194 129 29 86 207 38 232 181 70 151 81 63 85 142 123 113 106 106 130 235 255 1 0 0 13 0 107 153 246 249 57 233 173 115 96 121 251 164 245 244 235 61 57 229 3 55 243 90 243 26 180 94 39 211 99 3 139 28 119 227 249 122 50 15 191 217 26 254 10 255 245 109 123 38 39 251 36 131 205 114 19 78 120 71 70 156 140 248 117 146 77 182 81 153 173 228 121 146 227 100 178 143 108 178 201 38 155 76 246 145 219 3 114 251 36 156 108 194 201 38 60 221 44 235 200 38 207 46 114 251 200 166 192 189 173 219 83 252 209 6 154 207 60 142 39 252 200 38 180 232 38 131 77 70 155 12 55 37 27 79 86 224 11 40 7 221 26 209 180 24 33 196 5 191 155 8 217 241 19 248 125 11 122 65 248 45 132 223 33 82 64 118 193 111 131 59 164 37 244 136 108 16 215 175 127 73 158 34 222 161 233 43 109 196 13 8 244 43 198 154 126 136 87 30 144 34 245 126 229 73 93 210 21 64 237 100 120 69 136 33 112 57 30 253 109 168 104 239 13 117 255 19 240 180 131 71 200 238 41 82 250 68 37 113 253 238 91 132 156 158 118 61 94 245 14 217 67 130 80 127 247 3 52 82 64 103 96 120 248 81 254 88 221 124 166 160 130 20 186 34 181 71 63 196 99 152 123 11 246 157 158 38 23 201 42 66 42 127 74 106 201 59 240 104 29 211 8 67 166 20 0 233 138 106 202 122 188 41 98 195 219 223 0 214 157 201 11 147 95 131 41 202 147 47 157 105 135 250 0 246 87 99 93 147 124 195 44 128 186 2 106 55 212 221 248 174 11 234 103 160 46 194 218 141 117 49 214 37 88 151 37 191 240 219 31 66 221 131 125 63 214 133 169 167 207 189 15 245 99 169 158 85 3 80 31 59 63 246 120 33 212 123 83 19 155 7 161 14 192 251 247 160 126 147 252 30 88 170 77 243 204 164 70 72 185 49 226 83 98 114 80 87 134 141 5 178 183 175 56 193 179 205 239 63 24 177 117 54 191 235 140 17 240 170 118 227 148 26 89 228 217 251 17 191 235 38 183 254 149 246 107 191 191 109 130 242 227 240 93 141 60 58 188 63 132 243 252 143 255 203 228 125 96 111 131 205 127 37 227 191 67 209 229 136 169 233 167 114 18 7 55 92 224 127 229 10 222 109 221 163 127 215 50 222 189 227 96 226 170 20 203 219 219 17 139 247 131 200 203 202 25 252 191 109 229 23 212 253 90 198 127 143 118 202 48 149 200 201 188 179 11 92 91 247 107 144 159 21 35 252 221 85 228 162 57 116 163 173 243 10 198 115 175 108 142 105 250 45 154 201 103 45 158 239 70 63 23 252 174 157 156 186 66 251 165 147 47 157 187 2 245 225 228 187 103 170 174 243 46 248 110 64 125 220 230 253 14 196 179 121 175 123 229 245 63 239 130 122 253 185 55 191 151 248 68 7 95 113 77 0 139 13 182 222 235 152 14 66 178 174 72 177 118 53 26 232 238 232 14 106 186 121 77 17 109 25 191 219 111 249 222 253 147 169 46 218 247 224 59 161 151 7 241 157 157 139 132 126 132 79 246 226 187 190 140 111 62 128 115 8 31 9 34 158 237 163 149 136 83 133 115 180 39 47 252 232 235 255 246 215 221 75 62 187 11 231 252 175 254 202 184 254 180 132 26 93 220 25 236 176 244 119 31 242 179 1 235 123 38 127 241 238 13 29 218 186 107 68 189 205 235 207 209 91 51 226 216 122 107 194 119 194 223 108 253 9 221 237 68 158 238 197 122 94 135 43 15 232 239 9 215 231 153 138 172 28 0 123 12 208 223 17 69 141 106 99 11 2 252 76 70 127 243 254 38 244 212 138 245 157 147 231 190 67 235 14 196 113 242 130 208 157 173 179 135 113 222 150 228 91 219 95 252 64 103 143 44 229 10 59 63 238 193 254 230 76 206 88 210 87 126 79 20 80 140 200 199 123 162 207 173 120 177 39 202 240 91 101 140 244 197 162 204 191 23 57 126 116 165 14 126 33 39 127 66 46 124 251 86 188 224 247 101 66 55 192 229 182 255 87 27 35 135 21 221 76 72 49 136 1 67 138 42 207 115 44 246 193 130 95 155 215 255 240 104 243 247 209 62 114 117 84 213 63 94 42 167 225 96 163 103 229 242 249 188 183 13 235 77 86 78 185 11 251 245 88 219 186 157 207 217 27 177 222 138 245 22 43 95 136 125 134 208 177 189 199 240 145 174 85 127 132 90 240 136 141 186 128 100 14 193 33 64 75 235 129 122 159 212 176 91 105 110 141 238 108 130 7 54 255 190 116 61 51 7 234 125 125 80 215 78 192 66 87 111 105 61 217 224 151 244 65 249 230 20 132 244 47 206 81 2 118 209 23 106 138 221 128 190 250 29 90 156 163 58 16 242 215 247 39 84 83 25 150 129 146 57 46 232 23 90 156 163 142 206 225 105 226 242 208 243 250 8 95 221 225 1 120 91 185 179 243 75 254 234 231 95 117 77 132 189 71 195 180 3 152 128 90 181 195 113 164 169 47 23 252 152 163 210 14 236 137 217 172 206 94 121 234 75 127 59 143 168 208 129 107 19 134 90 104 140 52 13 229 69 70 189 159 163 178 20 176 186 13 80 123 90 138 134 193 51 242 184 204 177 57 175 180 83 196 81 221 134 25 85 180 28 44 243 107 129 250 12 113 115 212 98 64 5 51 200 194 90 168 197 105 84 93 81 7 111 163 150 32 175 212 44 22 121 253 16 181 180 13 118 244 93 53 101 160 187 46 89 138 202 186 113 19 155 237 35 24 42 235 172 161 168 157 173 37 29 178 113 114 127 98 14 18 62 230 230 12 149 117 202 56 170 59 124 42 46 103 49 129 33 234 253 156 33 218 41 231 168 53 30 77 141 42 166 162 193 230 29 200 210 53 107 2 150 100 56 42 237 84 112 212 53 1 101 92 142 6 180 104 70 18 44 175 112 84 218 89 203 81 139 189 163 178 106 230 40 98 41 137 171 129 118 42 113 214 131 9 112 200 168 46 141 205 1 179 44 196 81 105 167 138 163 174 77 163 134 229 113 243 26 178 165 161 106 84 94 95 232 144 169 196 178 20 89 26 170 65 94 3 242 48 245 213 172 163 208 20 39 212 80 64 106 81 175 244 198 37 175 87 139 161 117 66 67 186 174 101 220 132 169 129 38 78 174 6 218 89 207 115 67 49 72 59 236 9 102 81 105 14 228 94 206 18 225 6 84 94 123 60 30 147 195 82 236 228 28 176 197 80 29 159 181 178 61 26 213 101 195 56 234 151 168 173 204 66 211 236 201 103 101 41 116 35 206 218 47 27 252 174 237 95 179 222 33 60 79 151 226 203 26 186 19 85 222 41 27 166 20 187 238 10 168 33 154 198 185 134 104 103 19 162 250 180 88 214 200 175 205 186 25 121 13 195 89 95 222 83 44 212 45 2 21 76 107 25 117 43 122 67 40 162 43 241 44 173 54 106 61 58 101 183 106 198 242 234 179 80 183 9 53 40 227 116 61 176 164 134 187 80 175 221 17 77 93 214 235 118 158 68 157 187 183 41 247 128 31 243 43 116 96 223 204 80 157 45 127 170 241 155 251 48 191 66 7 118 205 98 214 133 221 116 234 169 111 252 9 81 161 3 151 42 12 213 185 108 57 223 56 112 137 163 210 14 185 59 157 243 70 149 172 227 205 122 121 3 122 3 108 83 0 212 88 114 202 157 168 60 46 132 172 242 216 101 0 159 149 118 238 225 168 101 30 109 56 174 169 217 212 102 161 222 139 168 108 214 110 53 158 152 243 34 11 245 62 142 90 206 210 70 46 34 90 188 54 114 212 34 111 48 232 201 231 114 43 83 54 33 67 0 74 141 249 73 109 252 38 182 53 107 51 71 173 232 213 76 229 132 18 153 203 53 179 168 187 80 229 220 76 114 42 159 201 175 247 115 212 82 200 229 166 174 101 163 168 133 250 0 170 60 32 171 185 189 193 44 234 131 194 135 224 16 73 27 188 205 208 110 100 136 102 20 47 236 14 50 176 150 26 246 136 196 6 123 20 253 211 4 208 66 81 125 63 43 141 227 6 49 3 204 238 50 120 194 166 157 135 144 215 16 219 244 220 78 108 173 34 151 131 242 150 51 202 195 136 26 212 198 110 241 106 121 249 35 194 149 35 16 96 63 157 245 81 158 54 156 251 135 169 223 252 225 101 204 67 208 33 143 113 212 82 99 4 60 229 132 50 191 249 162 59 124 76 54 208 33 123 57 42 220 102 6 99 146 121 66 211 135 67 113 57 66 237 239 42 62 221 248 35 42 116 224 162 36 157 162 110 93 160 164 70 15 165 16 21 58 112 199 32 82 212 194 221 67 170 241 217 179 34 177 61 123 22 174 227 24 170 115 77 119 254 245 55 38 49 123 65 135 180 139 172 204 0 243 91 64 184 92 195 125 30 116 246 99 86 134 60 52 188 156 149 61 28 181 218 211 31 224 227 206 5 62 11 181 3 25 242 107 99 176 88 202 109 122 102 92 217 203 213 224 220 80 167 26 159 247 9 13 61 239 35 62 58 171 231 219 206 166 63 121 225 7 113 215 68 32 232 247 209 14 233 228 59 209 50 73 53 148 227 113 73 135 17 111 176 100 237 122 187 196 254 85 249 162 124 60 183 165 176 54 169 221 28 181 72 77 196 114 106 157 157 181 135 163 150 140 74 199 99 138 145 29 214 154 245 0 71 117 71 149 209 60 65 246 172 126 156 117 44 50 36 233 57 92 107 214 0 215 235 181 91 152 25 120 122 161 146 222 178 191 71 122 209 27 14 192 169 180 156 211 131 149 54 250 56 106 13 142 232 29 143 200 113 154 97 45 217 90 62 20 20 169 87 26 150 251 229 65 144 209 205 29 167 53 235 193 180 83 70 101 159 46 13 14 207 229 121 107 214 126 230 67 27 157 75 17 72 119 175 160 15 65 135 132 40 106 199 62 231 158 35 121 233 69 216 110 50 84 232 144 48 213 171 167 217 185 222 72 94 122 225 162 64 125 225 34 57 196 24 170 112 110 80 146 23 94 189 44 156 242 213 203 228 48 191 3 160 255 193 129 119 0 48 239 117 84 122 143 56 17 8 120 186 88 231 72 58 123 45 220 197 167 158 126 237 57 225 13 175 61 7 215 82 25 71 153 73 82 150 163 12 112 84 231 63 52 82 19 103 91 69 206 59 219 74 142 209 91 169 182 242 53 140 161 161 14 57 147 97 233 255 91 96 246 130 14 127 227 130 127 55 33 5 193 144 60 56 61 157 6 130 55 112 86 12 111 232 92 171 19 199 224 78 222 181 133 254 231 71 208 111 152 20 0 222 252 5 182 203 111 195 245 206 223 131 190 152 65 223 252 31 0 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 98 187 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 38 62 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 129 191 243 0 0 41 201 0 0 38 200 0 0 9 141 0 0 9 141 243 46 72 29 0 0 0 0 0 0 205 45 13 192 213 101 121 173 204 147 221 94 217 32 163 61 158 109 54 234 188 86 118 100 27 225 81 66 201 109 93 59 251 77 147 83 153 114 250 121 201 47 118 137 167 134 103 158 199 214 9 195 95 199 162 229 149 107 17 86 172 39 191 153 91 194 201 38 155 69 246 25 37 207 59 178 89 132 109 79 178 9 207 200 102 228 247 81 178 143 17 74 216 62 143 108 37 199 110 179 205 182 29 229 79 158 147 237 145 205 242 246 75 24 225 49 194 9 63 241 192 87 87 114 154 229 229 185 165 69 63 143 48 178 153 17 182 201 109 221 108 147 223 228 55 217 100 51 60 217 192 248 211 116 80 30 0 3 128 185 43 0 230 224 223 178 46 162 29 251 252 38 6 218 219 49 184 197 173 29 199 255 187 245 219 22 185 180 55 245 211 178 156 234 117 9 89 90 235 243 121 92 49 37 26 4 1 171 123 189 190 42 79 221 210 18 6 229 217 189 217 99 173 120 253 84 236 92 213 52 19 50 3 47 1 220 28 158 181 196 165 253 126 199 227 229 37 107 108 203 183 237 120 166 96 6 102 166 150 69 180 246 69 46 112 224 223 142 255 49 203 118 191 103 171 252 35 56 86 219 151 111 163 187 49 219 83 85 53 149 139 51 42 142 230 29 215 98 203 86 45 75 44 6 200 224 216 50 248 103 77 131 37 114 123 195 154 129 1 203 106 1 202 94 103 83 230 226 13 1 108 116 143 83 73 103 139 243 135 120 214 169 165 16 50 99 146 127 173 212 36 159 225 82 143 177 198 125 151 186 33 124 246 254 184 234 13 106 92 14 123 66 146 170 202 234 57 8 179 63 100 234 108 216 64 192 66 22 204 180 225 233 82 205 129 16 16 5 106 214 52 32 202 137 17 135 87 242 139 149 213 34 90 132 232 89 228 89 176 192 245 131 222 42 110 93 102 250 193 56 47 103 109 44 75 216 120 178 14 74 191 95 197 125 97 63 85 201 5 25 104 101 90 42 173 105 140 130 82 211 245 35 197 246 237 0 75 52 250 12 6 179 108 222 104 68 242 71 7 144 90 97 62 100 179 159 10 201 238 243 169 224 240 116 7 113 2 99 235 132 103 133 95 89 94 129 16 64 97 7 74 96 28 222 155 74 58 126 128 179 115 230 100 113 114 105 48 212 123 54 214 47 128 122 204 175 60 241 4 212 223 252 134 158 3 64 32 245 238 228 111 79 224 255 168 59 233 78 118 29 154 179 18 217 206 133 3 88 121 51 158 1 93 14 88 133 187 245 155 47 64 253 45 101 176 242 237 213 144 124 121 31 36 31 108 113 39 31 207 230 119 146 91 130 58 18 29 159 232 112 183 82 61 119 235 55 94 134 47 254 230 161 94 44 152 73 110 253 174 65 113 138 243 36 188 102 104 130 240 245 8 189 117 215 116 119 235 51 120 219 192 7 19 86 193 1 252 159 196 243 224 107 80 191 228 85 60 63 199 177 236 229 152 223 130 237 156 233 9 88 21 17 163 154 132 220 2 52 22 244 149 234 68 44 22 85 226 5 164 107 55 176 224 155 251 192 153 179 23 198 63 57 63 45 190 133 58 35 88 149 5 143 44 6 231 242 87 241 127 160 89 251 139 27 243 55 145 21 128 115 226 66 204 29 199 191 3 38 180 214 96 253 142 217 96 181 98 94 124 191 62 226 59 226 211 243 11 227 108 193 243 237 170 95 9 192 228 98 84 245 196 133 220 81 130 71 81 7 200 15 175 63 6 235 19 31 83 210 126 48 235 173 205 238 199 158 141 99 6 69 64 120 142 62 13 206 25 59 89 177 221 135 185 131 136 175 141 235 124 252 147 155 244 250 200 7 213 119 206 140 25 8 166 192 76 114 10 86 5 194 180 2 175 28 87 162 247 202 202 90 85 172 142 75 145 70 73 105 20 43 2 13 138 164 108 40 240 86 87 136 158 2 172 244 226 161 108 120 36 243 200 43 91 176 122 182 126 38 113 204 199 155 191 126 87 219 147 247 125 61 135 87 30 9 198 176 90 158 182 231 246 251 250 234 29 90 216 91 207 230 192 59 101 218 158 207 18 163 120 231 240 94 230 123 167 131 254 153 237 254 213 192 110 221 167 237 153 252 101 200 13 84 104 251 91 218 232 204 238 156 18 196 154 187 180 78 84 11 214 193 170 62 152 91 251 99 152 188 187 77 235 220 188 90 235 220 146 196 251 29 232 16 245 239 180 99 230 43 132 139 51 159 141 149 232 79 213 238 210 197 224 252 29 216 168 195 48 26 140 138 64 100 173 172 156 118 231 145 10 48 169 147 189 184 255 16 254 29 155 65 40 213 14 30 231 189 131 245 133 253 139 65 56 60 31 166 22 250 124 21 215 219 33 50 195 194 88 12 61 223 12 0 135 215 91 81 52 92 39 7 141 64 92 26 38 119 36 234 207 213 240 250 42 74 77 2 112 212 121 208 4 205 0 120 173 170 174 234 3 248 9 142 154 146 21 53 22 87 67 179 191 171 171 11 88 231 99 252 226 225 71 185 75 185 183 6 209 191 45 197 246 34 41 20 138 70 35 98 153 28 226 230 250 169 124 1 14 111 219 5 237 243 242 97 71 193 62 186 66 56 4 151 127 16 175 221 91 167 119 182 253 234 208 113 88 93 254 5 11 76 1 112 88 92 254 65 66 254 142 35 213 83 92 231 53 54 0 228 10 14 185 101 144 144 139 161 235 181 249 191 122 117 116 227 24 98 99 28 226 240 73 170 95 10 157 39 86 231 53 38 245 61 243 252 19 135 127 128 217 97 94 169 9 37 28 54 194 241 177 19 93 198 33 184 206 244 81 61 97 169 146 239 187 164 87 117 208 167 109 72 67 161 26 230 62 205 239 127 232 211 43 60 149 35 125 140 131 138 148 14 117 50 141 81 127 226 127 22 196 251 15 69 85 134 154 134 81 28 106 115 168 97 184 78 142 175 228 2 171 136 35 158 48 9 192 65 97 117 161 74 254 195 171 143 180 168 119 228 183 229 223 97 222 210 145 35 245 231 106 92 237 200 251 113 152 6 116 228 149 69 229 226 8 31 94 95 221 48 31 102 31 157 253 71 172 94 237 236 135 112 92 233 236 71 112 140 118 246 35 188 142 118 246 195 56 204 23 58 251 62 62 254 213 217 247 19 251 73 103 63 140 99 180 179 239 131 113 173 179 31 194 97 30 208 217 91 93 170 220 244 177 79 3 180 223 116 2 167 34 230 67 209 108 244 231 142 94 159 46 229 62 109 254 209 145 127 36 252 171 29 249 121 135 53 13 232 200 235 2 145 91 63 35 182 228 223 246 239 142 60 251 31 29 21 2 29 116 142 203 29 213 16 142 43 157 208 8 31 163 157 208 48 142 203 78 223 135 227 154 211 15 225 176 184 134 92 113 12 226 64 99 24 105 221 175 59 80 26 71 40 48 96 139 61 47 31 231 149 70 56 162 13 56 200 116 30 71 101 67 112 24 71 150 183 127 92 228 146 35 142 241 122 61 101 166 0 162 248 219 91 197 24 100 139 43 254 2 14 116 178 208 64 207 58 158 112 208 104 162 232 137 134 99 129 208 7 236 167 156 3 21 47 175 49 5 224 245 186 115 164 123 250 161 183 129 203 56 134 29 122 88 103 105 103 141 15 200 236 114 216 112 218 143 39 132 245 23 231 30 51 130 209 230 72 88 10 247 207 166 94 8 68 200 232 32 224 132 161 201 75 144 16 204 95 52 208 29 147 104 110 182 91 23 61 25 154 69 37 165 232 217 28 200 196 12 255 25 247 59 33 243 226 4 240 133 88 130 161 191 246 179 228 138 211 147 181 215 130 240 116 39 207 78 26 35 206 211 69 243 33 43 69 62 210 89 38 75 141 178 162 142 182 28 118 176 240 65 99 238 174 248 127 169 103 36 253 3 93 153 249 196 61 247 168 113 73 225 15 140 230 13 65 50 118 130 69 48 108 145 165 118 6 80 144 87 146 7 232 82 223 3 54 62 248 110 250 193 56 155 132 29 42 237 31 56 21 227 244 189 16 181 94 159 18 8 171 129 136 72 231 64 60 176 254 175 11 15 76 73 98 55 185 188 161 3 177 214 75 237 15 237 201 160 45 25 233 40 45 172 174 209 123 155 130 175 3 228 182 227 21 252 59 248 108 184 217 129 112 223 239 130 250 182 45 144 119 9 221 91 47 70 66 176 99 45 156 141 55 62 211 151 112 206 243 84 22 151 204 19 231 21 23 214 20 226 209 183 212 83 51 207 108 69 2 118 99 9 139 17 189 123 101 50 18 223 218 121 3 109 120 200 99 191 4 33 86 203 95 25 167 198 20 124 82 156 1 115 171 107 170 102 97 197 239 244 212 207 42 228 79 116 180 155 5 238 250 25 208 214 134 28 202 221 185 17 232 157 102 18 229 202 31 6 154 9 164 189 5 144 184 1 238 198 227 78 202 141 171 129 38 60 18 94 152 57 7 16 43 43 167 92 230 159 224 75 152 67 231 5 184 191 11 104 211 192 47 40 39 253 25 158 224 125 58 70 112 61 124 155 187 27 70 120 11 60 133 57 190 213 226 246 22 248 17 230 90 40 183 252 123 240 115 204 125 141 114 37 95 133 131 248 16 247 52 199 221 6 93 72 43 226 2 88 245 58 252 1 115 28 235 250 231 225 24 192 180 9 148 139 63 68 202 152 134 219 35 112 214 238 13 54 30 115 252 221 105 211 86 150 135 57 62 227 184 241 39 12 23 48 76 231 28 87 191 199 62 135 185 42 202 221 237 96 56 43 56 157 63 152 207 58 194 188 0 34 111 42 55 61 192 234 49 135 74 3 144 31 101 216 112 136 252 169 118 142 198 112 150 102 166 139 114 85 107 216 253 0 159 230 239 211 202 115 236 97 68 192 181 53 209 202 144 199 89 249 92 116 123 105 171 198 28 94 227 198 36 229 4 190 119 33 215 135 93 140 236 143 139 168 91 53 16 141 76 241 74 77 1 191 232 145 98 167 158 142 241 233 39 117 81 127 73 31 159 190 96 96 200 225 227 5 221 21 199 210 0 138 39 218 40 127 65 142 100 167 135 81 248 53 163 98 174 49 82 149 42 153 202 215 73 74 36 16 105 82 109 37 141 129 120 84 177 150 70 35 241 156 20 83 37 45 113 69 82 115 61 9 53 30 13 139 119 200 27 238 141 42 141 170 189 208 239 151 145 47 159 20 111 86 109 53 146 210 36 199 237 69 137 64 168 209 40 152 85 235 193 21 35 114 60 17 27 75 179 170 6 49 14 202 21 7 84 164 90 14 55 32 5 217 233 65 86 94 39 197 173 62 130 145 34 202 72 119 243 228 41 245 98 177 177 252 93 204 0 70 185 147 192 210 59 43 50 41 133 3 65 188 158 1 208 174 143 70 35 127 17 57 100 199 169 172 110 172 255 7 0 0 13 0 107 249 150 57 201 203 6 249 155 89 94 158 220 142 94 151 189 155 110 223 244 248 218 201 28 120 236 86 230 201 188 228 215 233 198 179 245 164 143 223 212 180 240 95 131 61 162 17 158 100 176 245 200 49 194 54 217 100 31 185 77 6 155 108 70 54 35 155 236 167 118 173 100 147 77 24 57 30 217 146 45 217 228 55 217 228 55 217 145 223 100 147 227 132 19 78 54 217 100 147 253 140 240 65 228 54 249 173 228 56 185 205 128 123 91 185 23 5 136 114 83 243 57 125 60 225 71 158 182 233 66 6 60 130 132 77 201 94 195 3 95 64 57 232 104 72 215 35 132 16 23 124 183 17 178 231 179 240 29 131 94 0 190 249 240 253 14 89 67 14 144 60 120 107 14 214 48 140 169 173 127 132 154 144 196 245 110 86 219 191 60 134 87 251 31 188 84 255 245 218 130 120 239 207 239 96 113 60 250 173 37 63 115 143 239 123 89 255 18 197 35 196 61 14 175 54 194 31 241 20 145 14 178 233 38 222 46 196 219 152 255 107 214 119 189 19 76 189 125 150 60 151 247 185 61 3 239 205 231 6 184 195 121 71 190 118 131 188 14 220 147 202 90 82 77 254 6 239 170 153 70 216 4 148 2 66 138 180 168 165 26 177 250 80 134 42 252 245 98 221 154 184 54 249 117 152 194 157 184 244 66 19 212 62 236 215 96 93 154 120 213 202 131 186 8 106 55 212 237 248 174 13 234 231 161 222 137 245 189 88 239 194 122 55 214 133 137 47 188 242 75 168 59 176 239 199 122 71 242 236 212 117 168 15 37 219 215 244 66 253 244 149 209 103 242 161 110 72 78 108 239 135 186 5 222 191 5 245 107 132 42 117 67 138 103 38 53 66 74 205 97 175 22 81 3 134 54 100 46 144 125 100 213 9 158 109 126 255 197 136 221 108 243 91 109 14 251 149 80 147 57 30 13 45 242 220 184 196 111 249 228 142 127 208 126 217 79 118 78 80 126 28 190 75 144 71 135 247 71 113 158 255 242 255 79 114 29 216 219 100 243 95 193 248 111 214 12 53 100 233 198 120 86 226 219 151 248 95 189 130 119 91 247 232 223 27 24 239 45 99 96 226 81 37 146 179 183 102 201 187 23 121 89 61 131 255 191 200 252 130 186 47 103 252 183 235 227 166 165 133 6 115 206 254 153 180 238 31 67 126 86 141 240 119 87 161 171 8 88 218 98 243 92 198 120 62 166 90 163 186 241 33 205 228 168 228 121 47 250 185 224 119 237 228 244 219 180 127 223 228 165 169 183 161 222 147 120 227 133 189 183 121 23 124 215 162 62 238 242 190 1 241 108 222 43 127 252 226 223 15 64 93 49 245 218 143 226 31 235 224 171 174 9 96 177 214 246 187 205 76 7 93 170 161 41 145 166 104 216 223 214 220 22 208 13 235 125 69 60 158 246 187 195 210 247 30 154 76 182 210 254 147 248 78 232 229 97 124 103 231 34 161 31 225 147 199 240 221 241 180 111 30 196 57 132 143 4 16 207 246 209 98 196 89 135 115 60 145 184 246 242 55 254 223 95 31 89 246 217 3 56 231 39 250 67 31 42 225 250 211 227 209 240 226 206 224 83 82 127 15 34 63 235 177 222 55 249 127 111 124 160 67 91 119 117 168 183 121 253 57 122 219 143 56 182 222 234 241 157 240 55 91 127 66 119 247 35 79 15 96 61 175 195 213 7 244 247 172 235 243 160 158 221 182 255 193 30 3 244 215 163 69 195 250 232 130 0 59 211 250 155 247 55 161 167 46 172 171 39 167 126 64 235 32 226 56 121 65 232 206 214 217 73 156 247 84 226 79 187 190 127 83 103 221 203 185 194 206 143 61 216 223 148 206 25 203 250 154 221 19 221 212 151 102 134 62 218 19 53 173 122 177 39 74 239 193 214 155 195 199 35 97 230 223 139 28 127 122 181 14 126 33 39 127 76 46 252 158 90 245 130 223 203 228 135 212 142 108 127 170 52 135 187 53 195 138 43 17 136 1 3 90 84 157 231 216 35 249 181 121 253 132 71 155 191 165 189 84 65 56 106 124 180 84 166 64 88 139 92 40 116 56 159 247 182 98 189 81 230 148 109 216 191 7 107 91 183 243 57 187 10 235 45 88 111 150 249 66 236 51 132 142 237 61 134 151 180 174 249 43 212 156 118 234 67 76 9 101 254 30 79 103 60 106 105 67 106 189 79 59 147 229 31 182 243 236 103 207 33 242 136 191 203 87 227 169 15 4 60 139 99 144 19 233 57 144 15 183 95 177 6 22 39 184 101 163 153 57 74 218 232 189 64 159 18 82 151 134 17 126 144 158 163 60 102 232 125 176 168 54 40 179 145 220 40 244 126 131 142 3 121 152 205 33 244 34 244 209 53 28 87 149 193 154 110 127 205 161 134 142 28 31 207 136 198 187 121 184 32 254 45 126 213 65 92 21 5 241 111 127 239 86 30 46 232 185 92 177 202 74 30 102 50 104 4 81 121 170 28 141 39 78 252 182 209 53 97 90 241 51 180 67 242 56 170 227 48 18 117 13 69 109 62 231 248 100 226 218 213 139 174 9 127 192 231 165 29 146 207 102 221 226 184 7 104 235 167 136 10 29 200 24 128 186 126 183 147 73 166 191 146 247 43 215 68 176 229 84 144 118 72 33 157 245 104 131 59 56 30 83 205 250 153 251 154 91 179 82 93 51 84 214 113 115 212 42 143 30 13 107 150 166 195 86 30 146 154 161 203 9 88 202 225 168 180 83 196 81 215 249 181 49 53 236 215 195 234 220 188 44 203 112 84 218 89 203 81 139 90 70 212 168 149 165 136 37 40 134 202 58 197 56 235 137 56 108 204 195 134 50 58 7 204 124 131 163 210 206 58 142 90 158 66 13 170 99 214 251 200 204 133 24 42 235 148 112 212 181 199 187 78 90 90 36 67 145 212 80 41 242 234 87 135 232 45 199 60 175 204 105 133 26 242 72 25 234 149 222 191 228 244 42 25 42 23 26 50 12 221 200 105 136 186 54 87 3 237 84 112 71 41 2 105 7 61 129 12 42 205 136 220 81 88 90 92 143 202 107 138 197 34 106 80 137 12 206 1 75 134 42 249 172 21 77 225 176 161 154 230 41 159 66 109 101 22 154 230 82 62 43 75 168 85 56 107 167 106 234 113 35 52 175 8 57 235 6 225 121 134 18 91 209 80 53 170 252 168 106 90 74 228 182 43 160 134 104 130 226 26 162 157 141 136 234 213 35 97 53 43 61 57 235 38 228 53 8 39 127 57 79 145 168 155 5 42 152 214 10 234 22 244 134 174 144 161 197 50 180 218 168 247 160 83 66 138 138 228 212 39 81 183 10 53 104 99 52 72 45 171 97 27 234 181 45 164 71 87 244 186 157 58 74 99 169 115 51 53 253 229 119 174 96 30 130 14 108 244 25 170 115 1 144 172 251 230 17 142 74 59 100 7 71 205 55 135 179 244 80 84 72 167 136 74 115 106 77 35 228 252 246 67 133 67 57 41 208 4 64 179 53 79 0 180 179 147 163 186 77 43 172 233 185 196 70 147 177 64 125 158 220 203 81 139 0 21 162 100 54 109 204 160 238 74 161 26 90 180 255 46 234 110 228 149 229 221 5 94 111 161 222 71 85 222 90 85 2 186 107 85 149 140 89 178 141 4 247 87 218 217 195 81 75 223 69 133 180 124 123 86 186 191 152 240 251 61 173 172 179 23 125 168 89 29 209 50 169 97 54 15 213 162 191 6 12 29 64 205 229 180 113 63 186 23 55 147 140 28 216 229 5 159 149 118 246 113 212 18 143 62 20 211 163 153 228 43 81 31 64 84 54 107 91 52 22 159 243 115 137 250 32 71 45 101 137 45 27 179 37 175 117 28 181 176 133 174 39 178 42 151 185 188 30 25 2 80 26 110 206 232 99 119 176 229 172 251 57 106 217 49 221 210 250 180 208 92 54 156 69 61 128 42 231 135 36 89 149 207 236 0 30 226 168 197 176 219 176 12 61 19 231 37 234 65 84 185 95 141 198 115 25 69 162 62 44 124 8 14 189 244 254 187 12 61 130 12 209 156 215 2 251 151 52 172 84 195 163 56 107 23 243 242 187 73 244 16 79 54 197 230 48 232 161 79 155 207 0 116 223 134 201 6 58 112 87 193 80 157 59 140 233 63 252 249 50 102 47 232 144 6 142 10 215 158 129 136 98 245 233 198 80 87 76 13 81 193 191 55 53 221 233 225 172 208 129 155 71 134 234 220 72 38 126 255 187 231 56 42 237 144 199 82 9 192 28 124 42 171 88 169 134 199 249 172 206 125 222 149 23 95 157 228 179 210 14 121 66 36 108 6 152 75 81 112 11 135 121 8 58 135 49 97 67 2 24 90 73 216 79 114 212 74 79 167 159 143 59 23 113 36 234 17 206 171 115 63 62 237 238 245 161 94 161 3 87 214 12 213 185 202 78 214 93 244 138 172 124 209 11 55 69 98 214 133 27 164 228 200 201 36 162 66 7 46 89 24 170 115 249 146 172 59 119 94 204 122 238 60 220 135 48 84 231 158 132 110 135 83 185 252 45 184 34 22 62 180 112 117 156 60 123 245 130 64 189 122 129 180 204 207 58 163 60 57 171 55 165 242 176 234 53 148 254 161 185 244 37 245 122 52 165 134 133 123 217 43 117 189 111 162 15 65 135 180 242 92 94 162 68 77 237 116 76 49 128 207 15 188 72 238 27 218 196 14 64 251 162 122 58 187 31 146 105 190 157 163 22 70 227 145 172 227 205 206 218 193 81 215 142 40 167 35 154 153 25 86 206 234 227 168 238 176 54 146 35 200 158 213 143 179 142 134 6 20 35 139 43 103 61 134 94 222 1 166 160 102 153 149 155 131 227 28 181 10 45 161 101 44 164 198 104 134 149 2 148 42 15 136 212 171 12 169 157 106 63 8 226 206 158 88 206 122 130 242 234 217 239 220 212 36 222 252 110 16 175 7 160 3 151 148 41 87 254 240 242 50 121 246 37 183 112 175 151 220 164 75 108 163 33 43 175 108 230 130 168 33 159 62 10 203 239 172 134 102 82 239 73 156 53 160 143 170 70 46 97 207 168 161 27 81 97 187 169 196 254 205 80 15 162 6 97 131 149 155 85 162 158 162 168 222 223 20 139 187 141 52 48 187 137 225 142 66 59 189 92 121 206 255 40 73 78 156 111 16 169 247 124 3 121 154 94 179 52 150 174 99 122 29 104 86 211 220 210 255 31 130 9 0 58 112 31 196 85 190 116 79 148 60 251 139 87 92 19 77 129 128 143 118 248 27 23 252 207 25 146 23 232 82 251 111 220 72 1 193 27 56 246 134 55 148 141 130 248 165 11 208 135 155 232 202 218 128 207 180 40 64 65 252 50 220 54 85 121 225 123 48 224 141 152 244 205 255 0 0 13 13 19 83 113 117 101 97 107 80 114 105 109 115 80 80 67 46 112 114 111 106 0 0 0 0 0 0 0 0 0 0 0 0 75 202 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 180 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 178 129 192 215 0 0 41 201 0 0 2 240 0 0 9 117 0 0 1 61 97 47 37 171 0 0 0 0 0 0 139 188 13 192 85 103 121 173 204 147 221 94 185 159 155 13 240 44 39 242 83 190 178 219 94 132 31 37 148 220 62 182 214 218 111 154 124 61 166 204 239 76 222 177 75 60 53 60 167 231 229 132 225 175 99 209 26 116 107 17 86 230 145 223 76 178 79 178 201 102 183 95 66 201 243 142 108 22 97 132 159 100 147 61 32 155 145 219 71 40 239 40 161 132 213 73 182 146 205 46 115 219 81 158 228 57 217 79 54 203 219 231 17 70 120 140 112 194 99 120 224 171 43 57 205 242 242 220 210 162 217 26 97 251 152 17 182 201 109 221 108 147 223 228 55 217 100 51 60 217 192 248 211 116 80 30 0 3 128 249 171 1 230 225 223 178 62 162 29 249 216 253 12 180 55 98 112 179 75 59 138 255 183 26 182 44 114 106 175 234 167 229 249 181 235 19 178 212 234 243 185 157 49 37 26 4 1 171 123 189 190 26 119 253 178 114 6 85 121 3 217 35 237 120 253 68 236 88 219 60 27 114 2 47 2 220 20 158 179 196 169 253 102 251 182 170 242 187 173 43 183 108 127 170 100 22 102 166 85 70 180 206 69 78 176 227 223 134 255 113 203 119 253 217 90 253 7 176 175 179 173 220 66 119 99 214 39 106 234 170 23 103 123 14 79 63 170 197 150 175 93 158 88 12 144 205 177 101 243 47 43 13 150 200 29 136 172 108 12 88 190 10 160 242 183 108 234 124 188 33 128 149 238 113 42 233 108 113 124 15 207 58 181 20 66 78 76 242 183 74 205 242 41 46 245 24 111 220 119 170 27 195 167 239 79 168 221 168 198 229 176 59 36 169 170 172 158 129 48 247 93 166 78 135 21 4 44 100 193 76 7 158 46 214 28 14 1 81 160 102 77 3 162 138 24 177 123 37 191 88 93 43 162 69 136 238 69 238 133 11 157 223 25 168 226 210 101 166 31 140 243 74 214 193 114 133 251 142 215 65 233 15 169 120 48 108 39 42 57 33 27 173 76 75 165 53 141 81 80 106 166 126 164 216 186 21 96 137 70 159 193 96 174 213 27 141 72 254 232 48 210 44 40 132 60 246 35 33 217 119 62 17 28 158 238 32 14 96 108 141 80 40 60 109 241 64 28 160 180 11 37 48 1 239 77 35 29 127 134 179 115 234 100 113 112 105 48 212 123 30 214 47 129 6 204 175 57 246 24 52 220 244 59 61 7 128 64 26 92 201 95 30 195 255 97 87 210 149 236 61 48 111 13 178 93 0 251 176 242 38 60 3 186 28 48 143 171 253 107 207 66 195 205 149 176 230 141 117 144 124 105 15 36 31 108 115 37 183 229 241 59 201 205 65 29 137 142 79 180 187 218 169 158 171 253 171 47 193 167 126 241 185 1 44 152 73 62 244 77 131 226 20 231 73 120 197 208 4 225 235 23 122 251 206 153 174 246 167 240 182 129 15 38 173 133 125 248 63 142 231 193 87 160 97 201 203 120 254 46 199 178 155 99 126 29 182 114 166 39 97 85 68 140 106 18 10 74 208 88 208 87 106 19 177 88 84 137 151 144 174 93 192 130 175 238 1 71 254 110 152 248 120 97 90 124 69 58 35 88 149 5 15 45 6 199 202 151 241 191 175 69 251 147 11 243 55 146 21 128 227 186 34 204 29 197 191 29 38 181 215 97 253 174 185 144 149 133 121 241 237 250 136 239 144 79 207 23 197 217 194 159 118 170 126 37 0 83 202 80 213 215 21 113 71 9 30 70 29 32 63 188 254 56 172 79 124 76 77 251 193 156 215 55 185 30 253 54 234 158 68 64 120 14 63 9 142 89 59 88 153 205 135 185 253 136 175 131 235 124 226 227 247 235 245 145 15 170 239 152 29 51 16 76 133 217 228 20 172 6 132 25 37 94 57 174 68 239 145 149 86 85 172 141 75 145 38 73 105 18 61 129 70 69 82 54 150 120 107 61 162 187 4 43 61 119 32 15 30 201 57 244 235 205 88 61 79 63 147 56 10 241 230 11 111 105 221 211 191 165 231 240 202 35 193 24 86 155 174 117 127 252 222 193 122 7 138 6 234 89 237 120 167 82 235 254 40 49 138 119 14 238 102 190 55 187 232 159 211 233 95 7 236 214 61 90 247 148 207 66 65 192 163 237 109 235 160 51 91 49 53 136 53 119 106 61 168 22 172 131 85 125 48 127 213 15 97 202 174 14 173 103 211 58 173 103 115 18 239 119 161 67 52 188 217 137 153 207 19 46 206 124 30 86 162 63 85 187 83 23 131 227 87 96 165 14 195 104 48 60 129 72 171 172 156 116 231 209 10 48 185 135 61 183 247 0 254 237 155 64 168 208 246 31 229 189 67 214 179 123 23 131 112 176 16 166 149 250 124 158 107 237 16 153 97 105 44 22 50 7 192 225 245 122 150 102 234 228 163 17 136 203 194 228 142 68 253 153 26 94 159 167 194 36 0 71 189 27 77 208 12 128 215 154 218 154 65 128 31 224 168 43 95 93 103 113 54 182 248 123 123 123 129 245 60 202 47 30 252 2 119 41 215 67 65 244 111 75 153 109 169 20 10 69 163 17 177 82 14 113 115 253 80 177 0 7 183 236 132 206 5 197 176 189 100 15 93 33 28 130 211 127 14 175 205 91 175 119 182 67 234 208 113 100 57 253 11 23 154 2 224 176 56 253 231 8 249 59 142 84 79 113 141 215 216 48 144 203 56 228 182 115 132 92 8 93 175 45 255 213 171 189 15 199 8 27 19 16 135 79 82 253 82 232 44 177 58 175 49 105 240 153 231 159 56 252 195 204 102 120 165 38 148 112 88 9 199 251 78 116 9 135 224 60 213 71 245 135 165 70 190 247 162 94 213 115 62 109 69 26 74 213 48 247 105 126 255 93 159 94 237 174 30 237 99 236 84 164 98 164 147 105 138 250 19 255 179 32 222 127 40 170 50 210 52 140 225 80 91 66 141 153 58 249 190 242 243 172 34 142 120 194 36 0 7 69 150 19 85 242 31 94 125 164 69 189 35 191 173 248 14 243 150 142 28 169 63 83 227 74 71 62 132 195 52 160 35 175 94 90 37 142 242 225 245 213 103 248 48 251 232 236 223 99 245 74 103 63 130 227 114 103 63 138 99 172 179 31 229 117 172 179 207 224 48 95 232 236 7 249 248 87 103 63 68 236 7 157 125 6 199 88 103 63 8 227 106 103 63 130 195 60 160 179 207 114 170 114 243 251 62 13 208 121 227 49 156 138 40 132 165 115 209 159 187 6 124 186 130 251 180 249 71 71 254 158 240 175 116 228 103 29 214 52 160 35 175 15 68 110 189 69 108 43 190 237 223 29 121 222 63 58 42 4 122 206 57 46 117 84 35 56 46 119 66 163 124 140 117 66 25 28 151 156 126 16 199 85 167 31 193 97 113 142 184 226 56 196 129 198 48 218 186 95 115 160 52 142 80 96 216 22 251 95 62 206 42 141 112 68 27 113 144 233 44 142 234 198 96 6 71 174 119 104 92 228 162 35 142 243 122 221 149 166 0 162 248 219 91 197 56 100 139 43 254 60 14 116 178 208 112 207 58 145 112 208 104 162 232 142 134 99 129 208 59 236 167 156 3 21 47 223 109 10 192 235 53 231 72 247 244 35 111 3 151 112 100 28 58 163 179 180 179 198 135 101 118 41 172 56 237 199 19 194 134 11 115 143 217 193 104 75 36 44 133 135 102 83 207 7 34 100 116 16 112 194 208 228 37 72 8 230 47 26 232 139 201 52 55 219 167 139 254 12 205 162 146 82 244 108 62 228 96 134 255 140 251 61 144 115 97 2 248 124 44 193 208 95 251 89 114 245 201 201 218 171 65 120 250 146 167 39 141 17 231 201 162 197 144 155 34 31 233 172 148 165 38 89 81 199 90 14 27 88 248 160 177 81 159 189 216 63 146 254 142 174 204 124 226 174 187 212 184 164 240 7 70 243 134 32 25 59 192 34 24 182 200 82 59 3 40 200 43 211 102 217 205 183 12 152 0 80 110 254 192 56 155 140 60 210 254 129 19 49 222 216 11 161 4 194 106 32 226 83 68 202 4 226 129 13 127 89 120 96 74 18 187 208 229 89 191 14 78 143 84 169 235 91 197 191 190 40 155 17 8 247 237 46 104 112 219 2 121 151 208 183 245 98 52 4 27 214 194 217 120 227 51 125 9 199 2 119 117 89 249 2 113 65 89 105 93 41 30 125 203 220 117 11 204 86 36 96 51 150 176 24 49 176 87 38 59 241 149 61 215 211 134 135 233 236 103 32 196 86 241 87 198 105 49 5 159 20 103 193 252 218 186 154 57 88 241 27 253 245 115 75 249 19 29 239 154 238 252 49 208 214 134 124 202 173 184 15 232 157 102 50 229 170 30 6 154 9 164 189 5 144 184 30 62 137 199 29 148 155 80 7 205 120 36 188 48 123 30 32 86 86 69 185 156 63 194 167 49 247 101 202 61 208 11 180 105 224 39 148 147 94 131 199 120 159 142 17 220 0 95 231 238 134 209 90 15 79 96 142 111 181 184 125 30 124 31 115 109 148 187 229 121 120 6 115 95 162 220 13 219 96 63 62 196 61 73 185 143 88 160 23 105 69 92 200 77 7 252 30 115 28 107 206 23 225 8 192 140 73 148 139 254 128 148 49 3 183 71 224 14 140 73 108 34 230 248 187 83 240 25 54 29 115 124 198 177 241 105 134 11 24 102 114 142 87 188 198 110 199 92 13 231 169 147 225 172 224 76 222 61 172 13 51 47 128 200 183 169 44 251 57 107 192 28 42 13 160 228 121 134 15 225 34 127 170 157 223 197 112 150 102 182 147 114 139 28 236 1 100 139 191 79 183 84 178 135 113 53 5 215 86 209 11 12 121 156 83 204 69 183 155 182 106 204 227 53 62 156 164 156 192 247 46 20 248 112 215 143 236 143 139 168 91 53 16 141 76 245 74 205 1 191 232 150 98 39 158 142 241 233 39 117 81 127 73 159 152 190 96 96 200 231 227 5 125 21 199 211 0 138 59 218 36 127 66 142 228 165 135 81 248 53 163 98 129 49 82 149 42 153 202 215 75 74 36 16 105 86 173 229 77 129 120 84 201 170 136 70 226 249 41 166 202 219 226 138 164 22 184 19 106 60 26 22 239 144 55 222 19 85 154 84 91 169 223 47 35 95 62 41 222 162 90 235 36 165 89 142 219 150 38 2 161 38 163 96 238 42 55 174 24 145 227 137 216 120 154 85 53 136 177 83 174 44 160 34 213 114 184 17 41 200 75 15 178 242 58 41 110 245 17 140 20 81 70 186 143 39 119 133 23 139 141 231 239 98 6 48 202 29 7 150 222 89 145 67 41 28 8 226 245 12 128 54 125 52 26 249 139 200 33 27 78 101 245 97 253 63 0 65 109 177 88 4 208 212 91 0 250 233 234 221 163 88 189 122 21 245 86 41 103 5 58 51 73 108 54 156 140 247 31 254 184 154 129 155 14 180 56 115 74 180 9 205 179 37 61 59 51 251 176 143 220 111 35 239 69 95 216 253 151 60 41 147 247 175 253 236 188 253 217 219 103 221 29 251 144 221 15 155 245 40 87 174 250 160 210 203 177 140 63 152 55 54 147 151 235 190 55 189 159 103 154 135 188 231 115 154 254 193 233 93 127 234 231 85 113 103 235 43 118 90 60 139 75 241 135 213 20 117 246 74 55 203 26 208 21 0 133 203 183 199 122 227 70 79 60 220 29 78 134 183 152 70 71 56 98 38 142 41 110 251 243 198 104 11 170 185 4 92 79 191 213 131 143 122 77 52 105 198 59 66 109 102 109 120 211 95 87 126 60 239 197 30 153 117 107 43 27 123 163 201 112 183 89 252 159 155 240 245 89 217 17 69 103 143 253 175 59 184 245 184 31 248 180 84 34 217 187 201 38 160 219 169 181 231 252 215 198 183 254 246 182 243 181 84 93 67 237 74 155 224 29 96 106 100 228 191 220 13 73 53 87 175 27 190 83 208 212 191 9 244 134 38 179 211 178 134 76 232 33 216 30 122 1 106 239 101 234 63 64 38 217 23 91 95 155 72 218 1 106 239 241 237 202 115 76 161 119 54 172 140 36 108 143 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 13:41' prior: 35763398!macExternalPrimsFile	^ '#include <CodeFragments.h>#include <Strings.h>#include "sq.h"/*** Variables ***/CFragConnectionID squeakVMLib = nil;  /* connection to the VM itself as a shared library *//*** Function Type Declaration ***/typedef int (*RecordVMProxyProc)(struct VirtualMachine *interpreterProxy);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag) {	CFragLoadOptions action;	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg;	OSErr err;	action = loadFlag ? kLoadCFrag : kFindCFrag;	err = GetSharedLibrary(		c2pstr(libName), kCurrentCFragArch, action, &libHandle, &mainAddr, errorMsg);	p2cstr((unsigned char *) libName);  /* undo C to Pascal conversion */	if (err) {		return null;	}	return libHandle;}int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength, int moduleNameIndex, int moduleNameLength){	Str255 functionName, moduleName;	CFragConnectionID libHandle;	CFragSymbolClass ignored;	Ptr functionPtr;	OSErr err;	int i;	/* copy function and module names into C strings */	for (i = 0; i < functionNameLength; i++) {		functionName[i] = ((char *) functionNameIndex)[i];	}	functionName[functionNameLength] = 0;	for (i = 0; i < moduleNameLength; i++) {		moduleName[i] = ((char *) moduleNameIndex)[i];	}	moduleName[moduleNameLength] = 0;	/* find the library */	if (moduleNameLength > 0) {		/* look for the primitive in named library */		/* first try to find it */		libHandle = FindOrLoadLib((char *) moduleName, false);		if (!!libHandle) {			/* then try to load it */			libHandle = FindOrLoadLib((char *) moduleName, true);		}	} else {		/* look for the primitive in the Squeak VM itself */		if (!!squeakVMLib) {			/* try to get a handle on the Squeak VM itself, viewed as a library */			squeakVMLib = FindOrLoadLib("SqueakVMPrims", false);		}		libHandle = squeakVMLib;	}	if (!!libHandle) return success(false);  /* could not open the library */	/* if library is external, initialize its VMProxy pointer */	if (libHandle !!= squeakVMLib) {		/* get the setInterpreter() function */		err = FindSymbol(libHandle, "\psetInterpreter", &functionPtr, &ignored);		if (err) return success(false);		/* call setInterpreter() */		((RecordVMProxyProc) functionPtr)(sqGetInterpreterProxy());	}	/* get the address of the desired primitive function */	c2pstr((char *) functionName);	err = FindSymbol(libHandle, functionName, &functionPtr, &ignored);	if (err) return success(false);	return (int) functionPtr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 14:16' prior: 34433642!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 12:57' prior: 35771559!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** pluggable primitive support ***/int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 11/25/1998 12:55' prior: 35794352!squeakVirtualMachineHeaderFile^ '#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0struct VirtualMachine* sqGetInterpreterProxy(void);typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);	/* InterpreterProxy methodsFor: ''stack access'' */	int (*pop)(int nItems);	int (*popthenPush)(int nItems, int oop);	int (*push)(int object);	int (*pushBool)(int trueOrFalse);	int (*pushFloat)(double f);	int (*pushInteger)(int integerValue);	double (*stackFloatValue)(int offset);	int (*stackIntegerValue)(int offset);	int (*stackObjectValue)(int offset);	int (*stackValue)(int offset);		/* InterpreterProxy methodsFor: ''object access'' */	int (*argumentCountOf)(int methodPointer);	void * (*arrayValueOf)(int oop);	int (*byteSizeOf)(int oop);	void * (*fetchArrayofObject)(int fieldIndex, int objectPointer);	int (*fetchClassOf)(int oop);	double (*fetchFloatofObject)(int fieldIndex, int objectPointer);	int (*fetchIntegerofObject)(int fieldIndex, int objectPointer);	int (*fetchPointerofObject)(int index, int oop);	int (*fetchWordofObject)(int fieldIndex, int oop);	void * (*firstFixedField)(int oop);	void * (*firstIndexableField)(int oop);	int (*literalofMethod)(int offset, int methodPointer);	int (*literalCountOf)(int methodPointer);	int (*methodArgumentCount)(void);	int (*methodPrimitiveIndex)(void);	int (*primitiveIndexOf)(int methodPointer);	int (*sizeOfSTArrayFromCPrimitive)(void *cPtr);	int (*slotSizeOf)(int oop);	int (*stObjectat)(int array, int index);	int (*stObjectatput)(int array, int index, int value);	int (*stSizeOf)(int oop);	int (*storeIntegerofObjectwithValue)(int index, int oop, int integer);	int (*storePointerofObjectwithValue)(int index, int oop, int valuePointer);		/* InterpreterProxy methodsFor: ''testing'' */	int (*isKindOf)(int oop, char *aString);	int (*isMemberOf)(int oop, char *aString);	int (*isBytes)(int oop);	int (*isFloatObject)(int oop);	int (*isIndexable)(int oop);	int (*isIntegerObject)(int objectPointer);	int (*isIntegerValue)(int intValue);	int (*isPointers)(int oop);	int (*isWeak)(int oop);	int (*isWords)(int oop);	int (*isWordsOrBytes)(int oop);		/* InterpreterProxy methodsFor: ''converting'' */	int (*booleanValueOf)(int obj);	int (*checkedIntegerValueOf)(int intOop);	int (*floatObjectOf)(double aFloat);	double (*floatValueOf)(int oop);	int (*integerObjectOf)(int value);	int (*integerValueOf)(int oop);	int (*positive32BitIntegerFor)(int integerValue);	int (*positive32BitValueOf)(int oop);		/* InterpreterProxy methodsFor: ''special objects'' */	int (*characterTable)(void);	int (*displayObject)(void);	int (*falseObject)(void);	int (*nilObject)(void);	int (*trueObject)(void);		/* InterpreterProxy methodsFor: ''special classes'' */	int (*classArray)(void);	int (*classBitmap)(void);	int (*classByteArray)(void);	int (*classCharacter)(void);	int (*classFloat)(void);	int (*classLargePositiveInteger)(void);	int (*classPoint)(void);	int (*classSemaphore)(void);	int (*classSmallInteger)(void);	int (*classString)(void);		/* InterpreterProxy methodsFor: ''instance creation'' */	int (*clone)(int oop);	int (*instantiateClassindexableSize)(int classPointer, int size);	int (*makePointwithxValueyValue)(int xValue, int yValue);	int (*popRemappableOop)(void);	int (*pushRemappableOop)(int oop);		/* InterpreterProxy methodsFor: ''other'' */	int (*becomewith)(int array1, int array2);	int (*byteSwapped)(int w);	int (*failed)(void);	int (*fullDisplayUpdate)(void);	int (*fullGC)(void);	int (*incrementalGC)(void);	int (*primitiveFail)(void);	int (*showDisplayBitsLeftTopRightBottom)(int aForm, int l, int t, int r, int b);	int (*signalSemaphoreWithIndex)(int semaIndex);	int (*success)(int aBoolean);	int (*superclassOf)(int classPointer);	} VirtualMachine;#endif /* _SqueakVM_H */'! !InterpreterSupportCode class removeSelector: #macExternalPrims!----SNAPSHOT----(25 November 1998 3:34:32 pm ) priorSource: 3948903!Object classPool at: #DependentsFields!----SNAPSHOT----(25 November 1998 3:46:42 pm ) priorSource: 4121651!Smalltalk reclaimDependents!Object classPool at: #DependentsFields!Object classPool at: #DependentsFields!Smalltalk reclaimDependents!Object classPool at: #DependentsFields!Smalltalk obsoleteClasses!----QUIT----(25 November 1998 3:50:27 pm ) priorSource: 4121762!----SNAPSHOT----(25 November 1998 4:06:31 pm ) priorSource: 4122043!	Display newDepth: 8.	Project allInstancesDo: [:p | p displayDepth: 8].!	Utilities removeDisney.!!EToySystem class methodsFor: 'stripped' stamp: 'di 11/25/1998 16:10' prior: 18509082!serverUrls	self codeStrippedOut: '2.3External'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 11/25/1998 16:10' prior: 35850991!prepareRelease	self codeStrippedOut: '2.3External'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 11/25/1998 16:10' prior: 18508240! previewEToysOn: arg1	self codeStrippedOut: '2.3External'! !!StandardScriptingSystem methodsFor: 'stripped' stamp: 'di 11/25/1998 16:10' prior: 35198466!guessDOLProxy	"deleted for external release"! !	ScriptingSystem prepareForExternalReleaseNamed: 'Squeak2.3beta'.!StandardScriptingSystem removeSelector: #serverUrls!EToySystem class removeSelector: #serverUrls!	StandardScriptingSystem removeSelector: #serverUrls.	EToySystem class removeSelector: #serverUrls.	ServerDirectory removeServerNamed: 'UpdatesAtDOL'.	ServerDirectory removeServerNamed: 'UpdatesAtWebPage'.!	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).!SystemDictionary removeSelector: #makeExternalRelease!	SystemDictionary removeSelector: #makeExternalRelease.	Symbol rehash.!Browser initialize!----QUIT----(25 November 1998 4:23:17 pm ) priorSource: 4122109!Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]!InterpreterSupportCode writeMacSourceFiles!