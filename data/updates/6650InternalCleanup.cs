'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6643] on 10 April 2005 at 8:55:47 pm'!"Change Set:		InternalCleanupDate:			10 April 2005Author:			Andreas RaabInternal cleanup for AbstractString, String, and MultiString. Things done:* Remove all #subclassResponsibilities and instead provide (unoptimized) implementations. The responsibilities clearly *do* lie with the common superclass - [Byte]String and MultiString may contain optimizations but that's about it.* Push everything up as far as possible and unify some of the idiosyncratic differences.Statistics:- 13 methods NEW- 39 methods MODIFIED- 71 methods REMOVED"!!AbstractString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:12'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min _ self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim isCharacter 			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind _ self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min _ min min: ind].	^ min! !!AbstractString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens _ OrderedCollection new.	separators _ delimiters isCharacter 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: separators startingAt: keyStop.		keyStop _ self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!AbstractString methodsFor: 'accessing' stamp: 'ar 4/10/2005 16:22'!indexOf: aCharacter  startingAt: start	(aCharacter class == Character) ifFalse: [^ 0].	^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!AbstractString methodsFor: 'accessing' stamp: 'ar 4/10/2005 16:22'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter class == Character) ifFalse: [ ^ aBlock value ].	ans _ self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!AbstractString methodsFor: 'accessing' stamp: 'ar 4/10/2005 16:22'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ self class findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:47'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^(self compare: aString caseSensitive: true) = 1! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:47'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."	^(self compare: aString caseSensitive: true) <= 2! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:48'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString isString ifFalse:[^false].	^(self compare: aString caseSensitive: true) = 2! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:48'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^(self compare: aString caseSensitive: true) = 3! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:48'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^(self compare: aString caseSensitive: true) >= 2! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	^(self compare: aString caseSensitive: false) <= 2! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^(self compare: aString caseSensitive: true) <= 2! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:38'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^self compare: aString caseSensitive: false! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:42'!compare: aString caseSensitive: aBool	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	"	| map |	map := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].	^self compare: self with: aString collated: map! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:44'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 _ string1 size.		len2 _ string2 size.		1 to: (len1 min: len2) do:[:i |			c1 _ (string1 at: i) asInteger.			c2 _ (string2 at: i) asInteger.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 _ string1 size.	len2 _ string2 size.	1 to: (len1 min: len2) do:[:i |		c1 _ (string1 at: i) asInteger.		c2 _ (string2 at: i) asInteger.		c1 < 256 ifTrue: [c1 _ order at: c1 + 1].		c2 < 256 ifTrue: [c2 _ order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 17:27'!crc16	"Compute a 16 bit cyclic redundancy check."	| crc |	crc := 0.	1 to: self byteSize do: [:i |		crc := (crc bitShift: -8) bitXor: (		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)			 at: ((crc bitXor: (self byteAt: i)) bitAnd: 16rFF) + 1) ].	^crc! !!AbstractString methodsFor: 'comparing' stamp: 'ar 4/10/2005 17:35'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^(self compare: aString caseSensitive: false) = 2! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 17:18'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b _ ByteArray new: self byteSize.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i).	].	^ b.! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 16:22'!asByteString	"Convert the receiver into a ByteString"	^self asOctetString! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 17:03'!asCharacter	"Answer the receiver's first character, or '*' if none.  Idiosyncratic, provisional."	^ self size > 0 ifTrue: [self first] ifFalse:[$·]! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 17:04'!asMultiString 	^ MultiString from: self.! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 20:55'!asOctetString	"Convert the receiver into an octet string"	| string |	string _ String new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 19:24'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^Symbol intern: self! !!AbstractString methodsFor: 'converting' stamp: 'ar 4/10/2005 17:05'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in _ ReadStream on: self.	out _ WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char _ in next) = $&						ifTrue: [rest _ in upTo: $;.								did _ out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $°].								rest = 'quot' ifTrue: [out nextPut: $"].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!AbstractString methodsFor: 'system primitives' stamp: 'ar 4/10/2005 16:55'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index _ 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index _ index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.		[c1 _ body at: startIndex+index-1.		c2 _ key at: index.		((c1 leadingChar = 0) ifTrue: [(matchTable at: c1 asciiValue + 1)]						ifFalse: [c1 asciiValue + 1])			= ((c2 leadingChar = 0) ifTrue: [(matchTable at: c2 asciiValue + 1)]								ifFalse: [c2 asciiValue + 1])]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0! !!AbstractString methodsFor: 'testing' stamp: 'ar 4/10/2005 16:49'!includesUnifiedCharacter	^false! !!AbstractString methodsFor: 'testing' stamp: 'ar 4/10/2005 16:23'!isByteString	"Answer whether the receiver is a ByteString"	^false! !!AbstractString methodsFor: 'testing' stamp: 'ar 4/10/2005 16:23'!isMultiByteString	"Answer whether the receiver is a MultiByteString"	^false! !!AbstractString methodsFor: 'testing' stamp: 'ar 4/10/2005 16:23'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	^false! !!AbstractString methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:16'!getInteger32: location	| integer |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	"^IntegerPokerPlugin doPrimitive: #getInteger"	"the following is about 7x faster than interpreting the plugin if not compiled"	integer := 		((self at: location) asInteger bitShift: 24) +		((self at: location+1) asInteger bitShift: 16) +		((self at: location+2) asInteger bitShift: 8) +		(self at: location+3) asInteger.	integer > 1073741824 ifTrue: [^1073741824 - integer ].	^integer! !!AbstractString methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:17'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER _ PUTCOUNTER + 1."	integer _ anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self at: location+3 put: (Character value: (integer \\ 256)).	self at: location+2 put: (Character value: (integer bitShift: -8) \\ 256).	self at: location+1 put: (Character value: (integer bitShift: -16) \\ 256).	self at: location put: (Character value: (integer bitShift: -24) \\ 256)."Smalltalk at: #PUTCOUNTER put: 0"! !!AbstractString methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:18'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength _ OrderedCollection new.	runValues _ OrderedCollection new.	runStart _ 1.	leadingChar _ (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar _ (self at: index) leadingChar.			runStart _ index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!AbstractString methodsFor: '*Morphic' stamp: 'ar 4/10/2005 17:07'!asMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asMorph openInHand"! !!AbstractString methodsFor: '*Morphic' stamp: 'ar 4/10/2005 17:07'!asStringMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asStringMorph openInHand"! !!AbstractString methodsFor: '*Morphic' stamp: 'ar 4/10/2005 17:06'!newTileMorphRepresentative	^ TileMorph new setLiteral: self;addSuffixIfCan! !!AbstractString class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 16:24'!fromByteArray: aByteArray	^ aByteArray asString! !!AbstractString class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 16:26'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	^String new: sizeRequested! !!AbstractString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"	| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize _ aString size.	more _ true.	i _ start - 1.	[more and: [i + 1 <= stringSize]] whileTrue: [		i _ i + 1.		ascii _ (aString at: i) asciiValue.		more _ ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i + 1 > stringSize ifTrue: [^ 0].	^ i! !!AbstractString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	| stringSize |	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asInteger = anInteger ifTrue: [^ pos]].	^ 0! !!AbstractString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:29'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize _ aString size.	hash _ speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash _ hash + (aString at: pos) asInteger.		"Begin hashMultiply"		low _ hash bitAnd: 16383.		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!AbstractString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	| char |	start to: stop do: [:i |		char _ (aString at: i) asInteger.		char < 256 ifTrue: [aString at: i put: (table at: char+1)].	].! !!AbstractString class methodsFor: 'plugin generation' stamp: 'ar 4/10/2005 16:24'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !!AbstractString class methodsFor: 'plugin generation' stamp: 'ar 4/10/2005 16:24'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!MultiString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:14'!at: index 	"Answer the Character stored in the field of the receiver indexed by the argument."	^ Character value: (self wordAt: index).! !!MultiString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:14'!at: index put: aCharacter 	"Store the Character in the field of the receiver indicated by the index."	aCharacter isCharacter ifFalse:[self errorImproperStore].	self wordAt: index put: aCharacter asInteger.! !!MultiString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:28'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	replacement class == String ifTrue: [		^ self replaceFrom: start to: stop with: (replacement asMultiString) startingAt: repStart.	]. 	^ super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!MultiString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:14'!wordAt: index	<primitive: 60>	^ (self basicAt: index).! !!MultiString methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:14'!wordAt: index put: anInteger	<primitive: 61>	self basicAt: index put: anInteger.! !!MultiString methodsFor: 'testing' stamp: 'ar 4/10/2005 17:28'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	1 to: self size do: [:pos |		(self basicAt: pos) >= 256 ifTrue: [^ false].	].	^ true.! !!MultiString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:32'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize ascii more |		self var: #aString declareC: 'unsigned int *aString'.	self var: #inclusionMap declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize _ aString size.	more _ true.	i _ start - 1.	[more and: [i + 1 <= stringSize]] whileTrue: [		i _ i + 1.		ascii _ (aString at: i) asciiValue.		more _ ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i + 1 > stringSize ifTrue: [^ 0].	^ i.! !!MultiString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:32'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned int *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!MultiString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:34'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned int *aString'.	stringSize _ aString size.	hash _ speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash _ hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low _ hash bitAnd: 16383.		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!MultiString class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:34'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	| char |	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned int *aString'.	start to: stop do: [:i |		char _ aString basicAt: i.		char < 256 ifTrue: [			aString basicAt: i put: (table at: char+1) asciiValue		].	].! !!MultiString class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 20:51'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested.		This is a shortcut (direct call of primitive, no #initialize, for performance"	<primitive: 71>  "This method runs primitively if successful"	^ self basicNew: sizeRequested  "Exceptional conditions will be handled in basicNew:"! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:08'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	replacement class == MultiString ifTrue: [		self becomeForward: (MultiString from: self).	]. 	super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 17:20'!asByteArray	| ba sz |	sz := self byteSize.	ba := ByteArray new: sz.	ba replaceFrom: 1 to: sz with: self startingAt: 1.	^ba! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 18:04'!isByteString	"Answer whether the receiver is a ByteString"	^true! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 17:28'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	^ true.! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 19:24'!intern: aStringOrSymbol 	aStringOrSymbol isOctetString 		ifFalse:[^MultiSymbol intern: aStringOrSymbol].	^ (self lookup: aStringOrSymbol)		ifNil: [NewSymbols				add: ((aStringOrSymbol isKindOf: Symbol)						ifTrue: [aStringOrSymbol]						ifFalse: [(self new: aStringOrSymbol size)								string: aStringOrSymbol])].! !String class removeSelector: #ccgDeclareCForVar:!String class removeSelector: #ccg:prolog:expr:index:!String class removeSelector: #conv!String class removeSelector: #conv0!String class removeSelector: #correspondingSymbolClass!String class removeSelector: #fromByteArray:!String class removeSelector: #getDelimited:from:in:!String class removeSelector: #getDelimited:in:!String class removeSelector: #getTempMethodStringFrom:replaceVars:withVars:!String class removeSelector: #pushUpMethods!!String class reorganize!('instance creation' new:)('primitives' findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: stringHash:initialHash: translate:from:to:table:)('m17n' multiClasses)!String removeSelector: #asCharacter!String removeSelector: #asMultiString!String removeSelector: #asStringMorph!String removeSelector: #asUnHtml!String removeSelector: #caseInsensitiveLessOrEqual:!String removeSelector: #caseSensitiveLessOrEqual:!String removeSelector: #compare:!String removeSelector: #includesUnifiedCharacter!String removeSelector: #newTileMorphRepresentative!String removeSelector: #sameAs:!String removeSelector: #<!String removeSelector: #'<='!String removeSelector: #=!String removeSelector: #>!String removeSelector: #'>='!!String reorganize!('accessing' at: at:put: byteAt: byteAt:put: byteSize replaceFrom:to:with:startingAt:)('converting' asByteArray asOctetString convertFromCompoundText convertFromSuperSwikiServerString convertFromSystemString convertToSuperSwikiServerString convertToSystemString)('comparing' compare:with:collated: findSubstring:in:startingAt:matchTable:)('testing' isByteString isOctetString)!MultiString class removeSelector: #ccgDeclareCForVar:!MultiString class removeSelector: #ccg:prolog:expr:index:!MultiString class removeSelector: #correspondingSymbolClass!MultiString class removeSelector: #findFirstInMultiString:inSet:startingAt:!MultiString class removeSelector: #indexOfAscii:inMultiString:startingAt:!MultiString class removeSelector: #multiStringHash:initialHash:!MultiString class removeSelector: #string:hasEncoding:!MultiString class removeSelector: #translateMultiString:from:to:table:!MultiString class removeSelector: #value:!!MultiString class reorganize!('enumeration' allMethodsWithEncodingTag: allMultiStringMethods allNonAsciiMethods)('primitives' findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: stringHash:initialHash: translate:from:to:table:)('instance creation' fromByteArray: fromISO2022JPString: fromPacked: fromString: from: new:)!MultiString removeSelector: #asByteArray!MultiString removeSelector: #asHtml!MultiString removeSelector: #asOctetString!MultiString removeSelector: #asUnHtml!MultiString removeSelector: #beginsWith:!MultiString removeSelector: #capitalized!MultiString removeSelector: #caseInsensitiveLessOrEqual:!MultiString removeSelector: #caseSensitiveLessOrEqual:!MultiString removeSelector: #compare:!MultiString removeSelector: #compare:with:collated:!MultiString removeSelector: #crc16!MultiString removeSelector: #decodeQuotedPrintable!MultiString removeSelector: #encodeForHTTP!MultiString removeSelector: #findAnySubStr:startingAt:!MultiString removeSelector: #findMultiSubstring:in:startingAt:matchTable:!MultiString removeSelector: #findString:startingAt:caseSensitive:!MultiString removeSelector: #findSubstring:in:startingAt:matchTable:!MultiString removeSelector: #findTokens:!MultiString removeSelector: #getInteger32:!MultiString removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!MultiString removeSelector: #indexOf:!MultiString removeSelector: #indexOf:startingAt:!MultiString removeSelector: #indexOf:startingAt:ifAbsent:!MultiString removeSelector: #multiStringCompare:with:collated:!MultiString removeSelector: #putInteger32:at:!MultiString removeSelector: #sameAs:!MultiString removeSelector: #substrings!MultiString removeSelector: #translateFrom:to:table:!MultiString removeSelector: #unescapePercents!MultiString removeSelector: #unzipped!MultiString removeSelector: #writeLeadingCharRunsOn:!MultiString removeSelector: #<!MultiString removeSelector: #'<='!MultiString removeSelector: #=!MultiString removeSelector: #>!MultiString removeSelector: #'>='!!MultiString reorganize!('accessing' at: at:put: byteAt: byteAt:put: byteSize replaceFrom:to:with:startingAt: wordAt: wordAt:put:)('converting' asFileName asFourCode asMultiString asMultiSymbol asPacked convertFromSuperSwikiServerString convertToSuperSwikiServerString convertToSystemString copyFrom:to:)('testing' includesUnifiedCharacter isOctetString isUnicodeString isUnicodeStringWithCJK)('private' mutateJISX0208StringToUnicode)!AbstractString class removeSelector: #correspondingSymbolClass!!AbstractString class reorganize!('instance creation' cr crlf crlfcrlf fromByteArray: fromPacked: fromString: lf new: readFrom: tab value:)('initialization' initialize initializeHtmlEntities)('examples' example)('utilities')('primitives' findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: stringHash:initialHash: translate:from:to:table:)('plugin generation' ccgDeclareCForVar: ccg:prolog:expr:index:)('porting')!