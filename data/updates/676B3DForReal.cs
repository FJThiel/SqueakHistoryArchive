'From Squeak 2.3 of January 14, 1999 on 16 February 1999 at 7:22:20 pm'!"Change Set:		B3DForRealDate:			16 February 1999Author:			Andreas RaabThis change set defines the first fully working versionof the Balloon 3D engine. Note that for speed considerationsyou should translate both, the engine plugins (e.g., seeB3DEnginePlugin>>translateB3D) as well as the OSMesa mesa plugin(requires Mesa 3.0)."Smalltalk renameClassNamed: #B3DClipper as: #B3DVertexClipper.Smalltalk renameClassNamed: #B3DRasterizer as: #B3DVertexRasterizer.B3DPrimitiveVertexArray removeSelector: #at:.B3DPrimitiveVertexArray removeSelector: #at:put:.B3DPrimitiveVertexArray removeSelector: #size.B3DPrimitiveVertexArray class removeSelector: #initialize.B3DPrimitiveVertexArray class removeSelector: #new:.!Object subclass: #B3DEnginePart	instanceVariableNames: 'engine '	classVariableNames: 'PrimitiveActions '	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!InterpreterPlugin subclass: #B3DEnginePlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Plugins'!B3DFloatArray variableWordSubclass: #B3DExponentTable	instanceVariableNames: ''	classVariableNames: 'DefaultExponents '	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DGeometry subclass: #B3DIndexedMesh	instanceVariableNames: 'vertices vtxNormals vtxColors vtxTexCoords faces faceNormals bBox '	classVariableNames: 'FlagFanStart FlagStripStart '	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DGeometry variableWordSubclass: #B3DIndexedQuad	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DIndexedMesh subclass: #B3DIndexedQuadMesh	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DGeometry variableWordSubclass: #B3DIndexedTriangle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DIndexedMesh subclass: #B3DIndexedTriangleMesh	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DFloatArray variableWordSubclass: #B3DInplaceArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Arrays'!B3DInplaceArray variableWordSubclass: #B3DColor4Array	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Arrays'!B3DInplaceArray variableWordSubclass: #B3DIndexedQuadArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DInplaceArray variableWordSubclass: #B3DIndexedTriangleArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!B3DFloatArray variableWordSubclass: #B3DLightAttenuation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!Object subclass: #B3DLightSource	instanceVariableNames: 'lightColor '	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Lights'!B3DLightSource subclass: #B3DAmbientLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DLightSource subclass: #B3DDirectionalLight	instanceVariableNames: 'direction '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DFloatArray variableWordSubclass: #B3DMaterialColor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DMaterialColor variableWordSubclass: #B3DMaterial	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!Morph subclass: #B3DMorph	instanceVariableNames: 'camera geometry angle texture '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Balloon-Demos'!B3DLightSource subclass: #B3DPositionalLight	instanceVariableNames: 'position attenuation '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DMaterialColor variableWordSubclass: #B3DPrimitiveLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!Object variableWordSubclass: #B3DPrimitiveVertex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!ArrayedCollection variableWordSubclass: #B3DPrimitiveVertexArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!B3DIndexedTriangleMesh subclass: #B3DSTriangleMesh	instanceVariableNames: 'edgeFlags smoothFlags '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!Object subclass: #B3DScene	instanceVariableNames: 'box objects cameras lights materials defaultCamera '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Objects'!Object subclass: #B3DSceneObject	instanceVariableNames: 'name matrix material texture geometry children '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Objects'!B3DEnginePlugin subclass: #B3DShaderPlugin	instanceVariableNames: 'litVertex pLight pMaterial pDirection pDistance pSpecDir lightFlags vbFlags pScale pInColor pOutColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!B3DPositionalLight subclass: #B3DSpotLight	instanceVariableNames: 'target minCos maxCos deltaCos direction '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!Form subclass: #B3DTexture	instanceVariableNames: 'wrap interpolate envMode '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Lights'!B3DInplaceArray variableWordSubclass: #B3DTexture2Array	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Arrays'!B3DEnginePlugin subclass: #B3DTransformerPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!B3DFloatArray variableWordSubclass: #B3DVector2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Vectors'!B3DInplaceArray variableWordSubclass: #B3DVector3Array	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Arrays'!Object subclass: #B3DVertexBuffer	instanceVariableNames: 'current vertexArray vertexCount indexArray indexCount primitive clipFlags flags '	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!B3DEnginePlugin subclass: #B3DVertexBufferPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!B3DEnginePart subclass: #B3DVertexClipper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-Engine'!B3DEnginePart subclass: #B3DVertexRasterizer	instanceVariableNames: 'viewport dirtyRect texture textureStack '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DVertexRasterizer subclass: #B3DNullRasterizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DEnginePart subclass: #B3DVertexShader	instanceVariableNames: 'lights primitiveLights material materialStack '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!ByteArray variableByteSubclass: #OSMesaHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-OSMesa'!B3DEnginePlugin subclass: #OSMesaPlugin	instanceVariableNames: 'osMesaTimeStamp hasTexture '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-OSMesa'!B3DVertexRasterizer subclass: #OSMesaRasterizer	instanceVariableNames: 'handle canvas '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'Balloon-3D-OSMesa'!B3DRenderEngine subclass: #OSMesaRenderEngine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-OSMesa'!!B3DBox methodsFor: 'displaying' stamp: 'ar 2/16/1999 17:25'!renderOn: aRenderer	"Note: The use of BoxColors is an example for pre-lighting."	1 to: 6 do:[:i|		"Enable simple additive computation of box colors.		Note: This must be turned on on per-primitive basis."		aRenderer			trackEmissionColor: true;		"Turn on pre-lit colors"			normal: (BoxNormals at: i);			color: (BoxColors at: i);		"Set pre-lit color per polygon"			drawPolygonAfter:[				aRenderer					texCoords: (vertices at: ((BoxFaceIndexes at: i) at: 1));					vertex: (vertices at: ((BoxFaceIndexes at: i) at: 1));					texCoords: (vertices at: ((BoxFaceIndexes at: i) at: 2));					vertex: (vertices at: ((BoxFaceIndexes at: i) at: 2));					texCoords: (vertices at: ((BoxFaceIndexes at: i) at: 3));					vertex: (vertices at: ((BoxFaceIndexes at: i) at: 3));					texCoords: (vertices at: ((BoxFaceIndexes at: i) at: 4));					vertex: (vertices at: ((BoxFaceIndexes at: i) at: 4)).			].	].! !!B3DBox class methodsFor: 'examples' stamp: 'ar 2/14/1999 22:13'!example1	"B3DBox example1"	"Simple rotating box drawn without perspective"	| box b3d p r m1 time f |	p _ 0.1@0.1@0.1.	box _ B3DBox from: p negated to: p.	b3d _ OSMesaRenderEngine new.	b3d viewport: (0@0 corner: 800@600).	b3d rotateBy: (B3DRotation x: 1 y: 0 z: 0 a: 45).	r _ 312@241 corner: 480@355.	f _ Form fromDisplay: r.	m1 _ (B3DRotation x: 0 y: 1 z: 0 a: 5) asMatrix4x4.	Display deferUpdates: true.	[Sensor anyButtonPressed] whileFalse:[		time _ Time millisecondsToRun:[			b3d transformBy: m1.			"Display fill: r fillColor: Color white."			f displayAt: r origin.			box renderOn: b3d].		time printString displayAt: r origin.		Display forceToScreen: r.		"(Delay forMilliseconds: 100) wait"].	Display deferUpdates: false.	f displayAt: r origin.	! !!B3DBox class methodsFor: 'examples' stamp: 'ar 2/14/1999 22:26'!example3	"MessageTally spyOn:[B3DBox example3]"	"Simple rotating box drawn with perspective"	| box b3d p r m1 c time f max |	p _ 0.1@0.1@0.1.	box _ B3DBox from: p negated to: p.	b3d _ OSMesaRenderEngine new.	b3d viewport: (0@0 corner: 800@600).	c _ B3DCamera new.	c renderOn: b3d.	"b3d rotateBy: (B3DRotation x: 1 y: 0 z: 0 a: 45)."	r _ 312@241 corner: 480@355.	f _ Form fromDisplay: r.	m1 _ (B3DRotation x: 0 y: 1 z: 0 a: 5) asMatrix4x4.	Display deferUpdates: true.	max _ 0.	[Sensor anyButtonPressed] whileFalse:[		time _ Time millisecondsToRun:[			b3d transformBy: m1.			b3d clearDepthBuffer.			f displayAt: r origin.			box renderOn: b3d].		max _ max max: time.		time printString,'/',max printString displayAt: r origin.		Display forceToScreen: r.		"(Delay forMilliseconds: 100) wait"].	Display deferUpdates: false.	f displayAt: r origin.! !!B3DBox class methodsFor: 'examples' stamp: 'ar 2/14/1999 22:30'!example4	"MessageTally spyOn:[B3DBox example4]"	"A test of clipping planes"	| box b3d p r m1 c time f max |	p _ 0.1@0.1@0.1.	box _ B3DBox from: p negated to: p.	b3d _ OSMesaRenderEngine new.	b3d viewport: (0@0 corner: 800@600).	c _ B3DCamera new.	c position: 0@0@-1.	c nearDistance: 0.8.	c farDistance: 1.2.	"c nearDistance: 0.92.	c farDistance: 1.08."	c renderOn: b3d.	"b3d rotateBy: (B3DRotation x: 1 y: 0 z: 0 a: 45)."	r _ 312@241 corner: 480@355.	f _ Form fromDisplay: r.	m1 _ (B3DRotation x: 0 y: 1 z: 0 a: 5) asMatrix4x4.	Display deferUpdates: true.	max _ 0.	[Sensor anyButtonPressed] whileFalse:[		time _ Time millisecondsToRun:[			b3d clearDepthBuffer.			b3d transformBy: m1.			f displayAt: r origin.			box renderOn: b3d].		max _ max max: time.		time printString,'/',max printString displayAt: r origin.		Display forceToScreen: r.		"(Delay forMilliseconds: 100) wait"].	Display deferUpdates: false.	f displayAt: r origin.! !!B3DCamera commentStamp: 'ar 2/13/1999 20:10' prior: 0!I represent a simple perspective camera.Instance variables:	position		<B3DVector3>		where the camera is located	target 		<B3DVector3>		where the camera is aiming at	up 			<B3DVector3>		what is considered to be 'up' on screen	perspective	<B3DCameraPerspective>	the actual camera perspective!!B3DCamera methodsFor: 'accessing' stamp: 'ar 2/15/1999 02:09'!changeDistanceBy: delta	position _ target + (position - target * delta)! !!B3DCamera methodsFor: 'accessing' stamp: 'ar 2/8/1999 16:48'!direction	^target - position! !!B3DCamera methodsFor: 'accessing' stamp: 'ar 2/8/1999 16:48'!direction: aVector	target _ position + aVector.! !!B3DCamera methodsFor: 'initialize' stamp: 'ar 2/7/1999 01:45'!from3DS: aDictionary	"Initialize the receiver from a 3DS camera.	Note: #near and #far are NOT clipping planes in 3DS!!"	self position: (aDictionary at: #position).	self target: (aDictionary at: #target).	self up: (0@0@1).	self flag: #TODO. "Include #roll value for upDirection"	self fieldOfView: 2400.0 / (aDictionary at: #focal).! !!B3DCamera methodsFor: 'initialize' stamp: 'ar 2/5/1999 21:22'!initialize	position := B3DVector3 x: 0.0 y: 0.0 z: 1.0.	target := B3DVector3 x: 0.0 y: 0.0 z: 0.0.	up := B3DVector3 x: 0.0 y: 1.0 z: 0.0.	perspective := B3DCameraPerspective new.	self fov: 45.0.	self aspectRatio: 1.0.	self nearDistance: 0.0001.	self farDistance: 10000.0.! !!B3DCamera methodsFor: 'initialize' stamp: 'ar 2/14/1999 22:44'!setClippingPlanesFrom: anObject	"Set the clipping planes from the given object"	| box center radius avgDist |	box _ anObject boundingBox.	center _ (box origin + box corner) * 0.5.	radius _ (center - box origin) length.	avgDist _ (position - center) length.	self farDistance: avgDist + radius.	avgDist > radius 		ifTrue:[self nearDistance: avgDist - radius]		ifFalse:[self nearDistance: (self farDistance * 0.00001)].! !!B3DCamera methodsFor: 'initialize' stamp: 'ar 2/15/1999 01:04'!setTargetFrom: anObject	"Make the camera point at the given object"	| box |	box _ anObject boundingBox.	self target: (box origin + box corner) * 0.5.! !!B3DCamera methodsFor: 'experimental' stamp: 'ar 2/15/1999 23:47'!rotateBy: angle	"Experimental -- rotate around the current up vector by angle degrees.	Center at the target point."	position _ (B3DMatrix4x4 rotatedBy: angle around: up centeredAt: target) localPointToGlobal: position.! !!B3DCamera class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 23:37'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DCameraPerspective commentStamp: 'ar 2/13/1999 20:09' prior: 0!I represent a perspective projection.Instance variables:	nearDistance 	<Float>	Near clipping plane distance	farDistance 		<Float>	Far clipping plane distance	fieldOfView 	<Float>	The field of view covered by the perspective	aspectRatio		<Float> 	The aspect ratio to be included !!B3DColor4 class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 16:21'!r: rValue g: gValue b: bValue a: aValue	^self new r: rValue g: gValue b: bValue a: aValue! !!B3DEnginePart commentStamp: 'ar 2/13/1999 20:14' prior: 0!I am the superclass for all separate parts of the Balloon 3D engine. I define the basic interface each part of the engine must respond to.Instance variables:	engine	<B3DRenderEngine>	The 3D engine I am associated with!!B3DEnginePart methodsFor: 'initialize' stamp: 'ar 2/16/1999 01:47'!destroy	"Destroy all resources temporarily assigned to the receiver"! !!B3DEnginePart methodsFor: 'initialize' stamp: 'ar 2/5/1999 21:34'!flush	"Flush all pending operations"! !!B3DEnginePart methodsFor: 'processing' stamp: 'ar 2/7/1999 03:39'!processIndexedLines: vb	"Process an indexed line set"! !!B3DEnginePart methodsFor: 'processing' stamp: 'ar 2/8/1999 15:36'!processIndexedQuads: vb	"Process an indexed quad set"! !!B3DEnginePart methodsFor: 'processing' stamp: 'ar 2/7/1999 03:39'!processIndexedTriangles: vb	"Process an indexed triangle set"! !!B3DEnginePart methodsFor: 'processing' stamp: 'ar 2/8/1999 15:35'!processVertexBuffer: vb	"Process the given vertex buffer in this part of the engine."	^self perform: (PrimitiveActions at: vb primitive) with: vb! !!B3DEnginePart class methodsFor: 'class initialization' stamp: 'ar 2/7/1999 19:52'!initialize	"B3DEnginePart initialize"	PrimitiveActions _ 		#(	processPoints:			processLines:			processPolygon:			processIndexedLines:			processIndexedTriangles:			processIndexedQuads:		).! !!B3DEnginePart class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:39'!isAvailable	"Return true if this part of the engine is available"	^self subclassResponsibility! !!B3DEnginePart class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:34'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available for the given output medium"	^self subclassResponsibility! !!B3DEnginePlugin commentStamp: 'ar 2/14/1999 01:05' prior: 0!I am a generic superclass for all Balloon 3D plugins.!!B3DEnginePlugin methodsFor: 'primitive support' stamp: 'ar 2/14/1999 00:01'!stackMatrix: index	"Load a 4x4 transformation matrix from the interpreter stack.	Return a pointer to the matrix data if successful, nil otherwise."	| oop |	self inline: false.	self returnTypeC:'void*'.	oop _ interpreterProxy stackObjectValue: index.	oop = nil ifTrue:[^nil].	((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = 16])		ifTrue:[^interpreterProxy firstIndexableField: oop].	^nil! !!B3DEnginePlugin methodsFor: 'primitive support' stamp: 'ar 2/14/1999 00:01'!stackPrimitiveIndexArray: stackIndex ofSize: nItems validate: aBool forVertexSize: maxIndex	"Load a primitive index array from the interpreter stack.	If aBool is true then check that all the indexes are in the range (1,maxIndex).	Return a pointer to the index data if successful, nil otherwise."	| oop oopSize idxPtr index |	self inline: false.	self returnTypeC:'void*'.	self var: #idxPtr declareC:'int *idxPtr'.	oop _ interpreterProxy stackObjectValue: stackIndex.	oop = nil ifTrue:[^nil].	(interpreterProxy isWords: oop) ifFalse:[^nil]. 	oopSize _ interpreterProxy slotSizeOf: oop.	oopSize < nItems ifTrue:[^nil].	idxPtr _ self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int *'.	aBool ifTrue:[		0 to: nItems-1 do:[:i|			index _ idxPtr at: i.			(index < 1 or:[index > maxIndex]) ifTrue:[^nil]]].	^idxPtr! !!B3DEnginePlugin methodsFor: 'primitive support' stamp: 'ar 2/14/1999 00:00'!stackPrimitiveVertex: index	"Load a primitive vertex from the interpreter stack.	Return a pointer to the vertex data if successful, nil otherwise."	| oop |	self inline: false.	self returnTypeC:'void*'.	oop _ interpreterProxy stackObjectValue: index.	oop = nil ifTrue:[^nil].	((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = PrimVertexSize])		ifTrue:[^interpreterProxy firstIndexableField: oop].	^nil! !!B3DEnginePlugin methodsFor: 'primitive support' stamp: 'ar 2/14/1999 00:00'!stackPrimitiveVertexArray: index ofSize: nItems	"Load a primitive vertex array from the interpreter stack.	Return a pointer to the vertex data if successful, nil otherwise."	| oop oopSize |	self inline: false.	self returnTypeC:'void*'.	oop _ interpreterProxy stackObjectValue: index.	oop = nil ifTrue:[^nil].	(interpreterProxy isWords: oop) ifTrue:[ 		oopSize _ interpreterProxy slotSizeOf: oop.		(oopSize >= nItems * PrimVertexSize and:[oopSize \\ PrimVertexSize = 0])			ifTrue:[^interpreterProxy firstIndexableField: oop]].	^nil! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 2/14/1999 01:14'!declareCVarsIn: cg	"Nothing to declare..."! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 2/8/1999 20:48'!moduleName	^'Squeak3D'! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 2/15/1999 23:33'!translateB3D		"B3DEnginePlugin translateB3D"	"Translate all the basic plugins into one support module."	| cg |	cg _ PluggableCodeGenerator new initialize.	{	InterpreterPlugin. 		B3DEnginePlugin.		B3DTransformerPlugin. 		B3DVertexBufferPlugin.		B3DShaderPlugin	} do:[:theClass|		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: self moduleName,'.c' doInlining: true.! !!B3DExponentTable class methodsFor: 'class initialization' stamp: 'ar 2/8/1999 00:02'!initialize	"B3DExponentTable initialize"	DefaultExponents _ Dictionary new.	0 to: 2 do:[:i|		DefaultExponents at: i put: (self using:[:value| value raisedTo: i]).	].! !!B3DExponentTable class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 23:56'!new	^self using:[:value| value]! !!B3DExponentTable class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 23:55'!numElements	^128! !!B3DExponentTable class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 23:59'!using: aBlock	"Create a new exponent table using aBlock as initialization"	^super new initializeFrom: aBlock! !!B3DFloatArray commentStamp: 'ar 2/13/1999 20:05' prior: 0!I am the superclass for all Balloon 3D vector objects.!!B3DFloatArray methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:10'!wordAt: index	<primitive: 60>	^self primitiveFailed! !!B3DFloatArray methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:10'!wordAt: index put: value	<primitive: 61>	^self primitiveFailed! !!B3DColor4 methodsFor: 'initialize' stamp: 'ar 2/7/1999 16:21'!r: rValue g: gValue b: bValue a: aValue	self red: rValue.	self green: gValue.	self blue: bValue.	self alpha: aValue.! !!B3DColor4 methodsFor: 'testing' stamp: 'ar 2/15/1999 22:12'!isZero	^self alpha isZero! !!B3DExponentTable commentStamp: 'ar 2/7/1999 23:39' prior: 0!I represent a lookup table for several exponents during lighting. Values are computed based on linear interpolation between the stored elements. New tables are created by providing a one argument initialization block from  which I am created.!!B3DExponentTable methodsFor: 'initialize' stamp: 'ar 2/8/1999 00:08'!initializeFrom: aBlock	| last next |	last _ nil.	1 to: self size // 2 do:[:i|		next _ aBlock value: (i-1) / (self size // 2 - 1) asFloat.		(next isInfinite or:[next isNaN]) ifTrue:[next _ 0.0].		self at: i*2-1 put: next.		i > 1 ifTrue:[self at: i-1*2 put: next - last].		last _ next.	].! !!B3DExponentTable methodsFor: 'accessing' stamp: 'ar 2/8/1999 00:10'!valueAt: aFloat	"Return the table approximation for the given float value"	| index max |	aFloat < 0.0 ifTrue:[^self error:'Cannot use negative numbers in table lookup'].	max _ self size // 2.	index _ (max * aFloat) asInteger + 1.	index >= max ifTrue:[^self at: self size-1].	"Linear interpolation inbetween"	^(self at: index) + (aFloat - (index-1) * (self at: index+1))! !!B3DIndexedMesh commentStamp: 'ar 2/15/1999 16:20' prior: 0!I represent a generic indexed face mesh. My subclasses define what kind of primitive objects I can represent. !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!boundingBox	^bBox ifNil:[bBox _ self computeBoundingBox]! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!faceNormals	^faceNormals ifNil:[faceNormals _ self computeFaceNormals]! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!faces	^faces! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!texCoords	^vtxTexCoords! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!vertexNormals	^vtxNormals ifNil:[vtxNormals _ self computeVertexNormals].! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 2/16/1999 19:08'!vertices	^vertices! !!B3DIndexedMesh methodsFor: 'modifying' stamp: 'ar 2/16/1999 19:08'!centerAtZero	self translateBy: (self boundingBox origin + self boundingBox corner * -0.5).! !!B3DIndexedMesh methodsFor: 'modifying' stamp: 'ar 2/16/1999 19:08'!translateBy: amount	vertices do:[:vtx| vtx += amount].	bBox ifNotNil:[bBox _ bBox translateBy: amount].! !!B3DIndexedMesh methodsFor: 'displaying' stamp: 'ar 2/16/1999 19:08'!renderOn: aRenderer	^self subclassResponsibility! !!B3DIndexedMesh methodsFor: 'private' stamp: 'ar 2/16/1999 19:08'!computeBoundingBox	| min max |	min _ max _ nil.	vertices do:[:vtx|		min ifNil:[min _ vtx] ifNotNil:[min _ min min: vtx].		max ifNil:[max _ vtx] ifNotNil:[max _ max max: vtx].	].	^Rectangle origin: min corner: max! !!B3DIndexedMesh methodsFor: 'private' stamp: 'ar 2/16/1999 19:09'!computeFaceNormals	| out face v1 v2 v3 d1 d2 normal |	out _ B3DVector3Array new: faces size.	1 to: faces size do:[:i|		face _ faces at: i.		v1 _ vertices at: face p1Index.		v2 _ vertices at: face p2Index.		v3 _ vertices at: face p3Index.		d1 _ v3 - v1.		d2 _ v2 - v1.		d1 safelyNormalize.		d2 safelyNormalize.		normal _ d1 cross: d2.		out at: i put: normal safelyNormalize.	].	^out! !!B3DIndexedMesh methodsFor: 'private' stamp: 'ar 2/16/1999 19:09'!computeVertexNormals	| temp normals face normal v1 v2 v3 out |	temp _ Array new: vertices size.	1 to: temp size do:[:i| temp at: i put: B3DVector4 new].	normals _ self faceNormals. "Forces computation if necessary"	1 to: faces size do:[:i|		face _ faces at: i.		normal _ (normals at: i) asB3DVector4.		v1 _ face p1Index.		v2 _ face p2Index.		v3 _ face p3Index.		(temp at: v1) += normal.		(temp at: v2) += normal.		(temp at: v3) += normal.	].	out _ B3DVector3Array new: vertices size.	1 to: out size do:[:i|		out at: i put: (temp at: i) asB3DVector3 safelyNormalize.	].	^out! !!B3DIndexedMesh methodsFor: 'optimizations' stamp: 'ar 2/8/1999 06:52'!optimizeMeshLayout	"Optimize the layout of the indexed mesh for primitive operations.	Optimzed layouts include triangle/quad strips and fans and 	will result in MUCH better performance during rendering.	However, optimizations are generally time-consuming so	you better don't call this method too often."	^self "Must be implemented in my subclasses"! !!B3DIndexedMesh class methodsFor: 'class initialization' stamp: 'ar 2/8/1999 06:55'!initialize	"B3DIndexedMesh initialize"	"Optimization flags: These flags are *hints* and may be ignored by the renderer."	FlagStripStart _ 1.	FlagFanStart _ 2.! !!B3DIndexedMesh class methodsFor: 'examples' stamp: 'ar 2/8/1999 21:18'!sampleRect	^self sampleRect: 10! !!B3DIndexedMesh class methodsFor: 'examples' stamp: 'ar 2/8/1999 16:58'!sampleRect: n	^self new sampleRect: n! !!B3DIndexedQuad methodsFor: 'initialize' stamp: 'ar 2/7/1999 20:00'!with: i1 with: i2 with: i3 with: i4	self at: 1 put: i1.	self at: 2 put: i2.	self at: 3 put: i3.	self at: 4 put: i4.! !!B3DIndexedQuad methodsFor: 'accessing' stamp: 'ar 2/8/1999 16:39'!flags	^0! !!B3DIndexedQuad methodsFor: 'private' stamp: 'ar 2/7/1999 20:02'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	^self primitiveFailed! !!B3DIndexedQuad methodsFor: 'printing' stamp: 'ar 2/8/1999 16:39'!printOn: aStream	aStream nextPutAll:'IQuad(';		print: (self at: 1);		nextPutAll:', ';		print: (self at: 2);		nextPutAll:', ';		print: (self at: 3);		nextPutAll:', ';		print: (self at: 4);		nextPutAll:', ';		print: (self flags);		nextPutAll:')'.! !!B3DIndexedQuad class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 19:59'!new	^self new: 4! !!B3DIndexedQuad class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 20:03'!numElements	^4! !!B3DIndexedQuad class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 19:59'!with: i1 with: i2 with: i3 with: i4	^self new with: i1 with: i2 with: i3 with: i4! !!B3DIndexedQuadMesh methodsFor: 'displaying' stamp: 'ar 2/8/1999 02:56'!renderOn: aRenderer	aRenderer		drawIndexedQuads: faces			vertices: vertices			normals: vtxNormals			colors: vtxColors			texCoords: vtxTexCoords.! !!B3DIndexedQuadMesh methodsFor: 'private' stamp: 'ar 2/8/1999 02:15'!sampleRect: n	"B3DIndexedQuadMesh new sampleRect"	| vtx face |	vtx _ WriteStream on: (B3DVector3Array new).	n negated to: n do:[:x|		n negated to: n do:[:y|			vtx nextPut: (B3DVector3 x: x y: y z: 0) /= n asFloat.		].	].	vertices _ vtx contents.	vtxNormals _ B3DVector3Array new: (2*n+1) squared.	1 to: vtxNormals size do:[:i| vtxNormals at: i put: (0@0@-1)].	faces _ B3DIndexedQuadArray new: (2*n) squared.	0 to: 2*n-1 do:[:i|		1 to: 2*n do:[:j|			face _ B3DIndexedQuad 						with: (i*(2*n+1)+j)						with: (i*(2*n+1)+j+1)						with: (i+1*(2*n+1)+j+1)						with: (i+1*(2*n+1)+j).			faces at: i*2*n+j put: face.		]].! !!B3DIndexedTriangle methodsFor: 'initialize' stamp: 'ar 2/16/1999 19:09'!with: index1 with: index2 with: index3	self p1Index: index1.	self p2Index: index2.	self p3Index: index3.! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/8/1999 05:15'!flags	^0 "May be used later"! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/8/1999 05:16'!flags: aNumber	^self "Maybe used later"! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:54'!p1Index	^self at: 1! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:55'!p1Index: aNumber	self at: 1 put: aNumber! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:55'!p2Index	^self at: 2! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:55'!p2Index: aNumber	self at: 2 put: aNumber! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:55'!p3Index	^self at: 3! !!B3DIndexedTriangle methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:55'!p3Index: aNumber	self at: 3 put: aNumber! !!B3DIndexedTriangle methodsFor: 'testing' stamp: 'ar 2/8/1999 06:15'!includesIndex: idx	^(self at: 1) = idx or:[(self at: 2) = idx or:[(self at: 3) = idx]]! !!B3DIndexedTriangle methodsFor: 'private' stamp: 'ar 2/5/1999 23:19'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	^self primitiveFailed! !!B3DIndexedTriangle methodsFor: 'printing' stamp: 'ar 2/8/1999 05:14'!printOn: aStream	aStream nextPutAll:'IFace(';		print: self p1Index;		nextPutAll:', ';		print: self p2Index;		nextPutAll:', ';		print: self p3Index;		nextPutAll:', ';		print: self flags;		nextPutAll:')'.! !!B3DIndexedTriangle class methodsFor: 'instance creation' stamp: 'ar 2/8/1999 05:14'!new	^self new: self numElements! !!B3DIndexedTriangle class methodsFor: 'instance creation' stamp: 'ar 2/8/1999 05:15'!numElements	^3! !!B3DIndexedTriangle class methodsFor: 'instance creation' stamp: 'ar 2/16/1999 19:09'!with: index1 with: index2 with: index3	^self new with: index1 with: index2 with: index3! !!B3DIndexedTriangleMesh methodsFor: 'displaying' stamp: 'ar 2/8/1999 02:56'!renderOn: aRenderer	aRenderer		drawIndexedTriangles: faces			vertices: vertices			normals: vtxNormals			colors: vtxColors			texCoords: vtxTexCoords.! !!B3DIndexedTriangleMesh methodsFor: 'private' stamp: 'ar 2/8/1999 02:15'!sampleRect: n	"B3DIndexedQuadMesh new sampleRect"	| vtx face |	vtx _ WriteStream on: (B3DVector3Array new).	n negated to: n do:[:x|		n negated to: n do:[:y|			vtx nextPut: (B3DVector3 x: x y: y z: 0) /= n asFloat.		].	].	vertices _ vtx contents.	vtxNormals _ B3DVector3Array new: (2*n+1) squared.	1 to: vtxNormals size do:[:i| vtxNormals at: i put: (0@0@-1)].	faces _ B3DIndexedTriangleArray new: (2*n) squared.	0 to: 2*n-1 do:[:i|		1 to: 2*n do:[:j|			face _ B3DIndexedTriangle 						with: (i*(2*n+1)+j)						with: (i*(2*n+1)+j+1)						with: (i+1*(2*n+1)+j+1)						"with: (i+1*(2*n+1)+j)".			faces at: i*2*n+j put: face.			"face _ B3DIndexedTriangle 						with: (i*(2*n+1)+j)						with: (i*(2*n+1)+j+1)						with: (i+1*(2*n+1)+j+1)						with: (i+1*(2*n+1)+j).			"		]].! !!B3DIndexedTriangleMesh methodsFor: 'fan creation' stamp: 'ar 2/8/1999 06:42'!makeTriangleFans	"Re-arrange the triangles so that they represent triangle fans."	| vtxDict avgFacesPerVertex todo done maxShared maxSharedIndex newOrder sharedAssoc |	"Compute the average size of faces per vertex (strange measure isn't it ;-)"	avgFacesPerVertex _ faces size // vertices size + 3. "So we cover 99% of all cases"	"vtxDict contains vertexIndex->(OrderedCollection of: IndexedFace)"	vtxDict _ OrderedCollection new: vertices size.	"Add all the vertex indexes. The set is larger than necessary to avoid collisions."	1 to: vertices size do:[:i| vtxDict add: i -> (IdentitySet new: avgFacesPerVertex * 3)].	"Go over all faces and add the face to all its vertices. Also store the faces in the toGo list."	todo _ IdentitySet new: faces size * 3.	done _ IdentitySet new: faces size * 3.	faces do:[:iFace| 		todo add: iFace.		(vtxDict at: iFace p1Index) value add: iFace.		(vtxDict at: iFace p2Index) value add: iFace.		(vtxDict at: iFace p3Index) value add: iFace].	"Now start creating the fans"	[todo isEmpty] whileFalse:[		"Let's assume that this method is not called in real-time 		and spend some time to find the vertex with most shared faces"		maxShared _ 0.		maxSharedIndex _ nil.		vtxDict doWithIndex:[:assoc :index| assoc value size > maxShared			ifTrue:[maxShared _ assoc value size.					maxSharedIndex _ index]].		maxSharedIndex = nil ifTrue:[^self error:'No shared vertices found'].		"Now re-arrange the faces around the shared vertex"		sharedAssoc _ vtxDict at: maxSharedIndex.		newOrder _ self reArrangeFanFaces: sharedAssoc value around: sharedAssoc key from: todo into: done.		"Remove re-arranged faces"		newOrder do:[:iFace|			(done includes: iFace) ifTrue:[self halt].			todo remove: iFace.			done add: iFace.			(vtxDict at: iFace p1Index) value remove: iFace ifAbsent:[].			(vtxDict at: iFace p2Index) value remove: iFace ifAbsent:[].			(vtxDict at: iFace p3Index) value remove: iFace ifAbsent:[]].		false ifTrue:[		"Remove the shared index if no more faces left."		sharedAssoc value isEmpty ifTrue:[			vtxDict swap: maxSharedIndex with: vtxDict size.	"Optimized removal ;-)"			vtxDict removeLast].		].	].! !!B3DIndexedTriangleMesh methodsFor: 'fan creation' stamp: 'ar 2/8/1999 06:38'!reArrangeFanFaces: sharedFaces around: maxSharedIndex from: todo into: done	"Re-arrange the faces in sharedFaces to form a triangle fan.	Avoid inplace-reversal of the triangles in doneList -- they have been arranged already"	| out next nextIndex prevIndex index |	out _ OrderedCollection new: sharedFaces size * 2.	next _ sharedFaces detect:[:any| true].	sharedFaces remove: next.	out addLast: next.	nextIndex _ next p1Index.	nextIndex = maxSharedIndex ifTrue:[nextIndex _ next p2Index].	prevIndex _ next p3Index.	(prevIndex = maxSharedIndex) ifTrue:[prevIndex _ next p2Index].	"Search forward"	[next _ sharedFaces detect:[:iFace| iFace includesIndex: nextIndex] ifNone:[nil].	next notNil] whileTrue:[		sharedFaces remove: next.		out addLast: next.		index _ next p1Index.		(index = maxSharedIndex or:[index = nextIndex]) ifTrue:[			index _ next p2Index.			(index = maxSharedIndex or:[index = nextIndex]) 				ifTrue:[index _ next p3Index]].		nextIndex _ index].	"Search backwards"	nextIndex _ prevIndex.	[next _ sharedFaces detect:[:iFace| iFace includesIndex: nextIndex] ifNone:[nil].	next notNil] whileTrue:[		sharedFaces remove: next.		out addFirst: next.		index _ next p1Index.		(index = maxSharedIndex or:[index = nextIndex]) ifTrue:[			index _ next p2Index.			(index = maxSharedIndex or:[index = nextIndex]) 				ifTrue:[index _ next p3Index]].		nextIndex _ index].	^out! !!B3DInplaceArray methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:49'!at: index	"Return the primitive vertex at the given index"	| vtx |	(index < 1 or:[index > self size]) ifTrue:[^self errorSubscriptBounds: index].	vtx _ self contentsClass new.	vtx replaceFrom: 1 to: vtx size with: self startingAt: index - 1 * self contentsSize + 1.	^vtx! !!B3DInplaceArray methodsFor: 'accessing' stamp: 'ar 2/6/1999 00:12'!at: index put: anObject	"Store the object at the given index in the receiver"	| idx |	(index < 1 or:[index > self size]) ifTrue:[^self errorSubscriptBounds: index].	idx _ index - 1 * self contentsSize.	self privateReplaceFrom: idx+1 to: idx + self contentsSize with: anObject startingAt: 1.	^anObject! !!B3DInplaceArray methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:48'!contentsClass	^self class contentsClass! !!B3DInplaceArray methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:48'!contentsSize	^self contentsClass numElements! !!B3DInplaceArray methodsFor: 'accessing' stamp: 'ar 2/5/1999 22:49'!size	"Return the number of primitive vertices that can be stored in the receiver"	^self basicSize // self contentsSize! !!B3DInplaceArray methodsFor: 'copying' stamp: 'ar 2/7/1999 19:48'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize _ stop - start + 1.	^(self species new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!B3DInplaceArray methodsFor: 'private' stamp: 'ar 2/6/1999 00:39'!privateReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	start to: stop do:[:i|		self basicAt: i put: (replacement at: i - start + repStart).	].! !!B3DInplaceArray methodsFor: 'private' stamp: 'ar 2/7/1999 19:46'!replaceFrom: start to: stop with: replacement startingAt: repStart	| max |	max _ (replacement size - repStart) min: stop-start.	start to: start+max do:[:i|		self at: i put: (replacement at: i - start + repStart).	].! !!B3DInplaceArray methodsFor: 'enumerating' stamp: 'ar 2/6/1999 00:37'!do: aBlock	"Overridden to store the (possibly) modified argument back"	| obj |	1 to: self size do:[:index|		obj _ self at: index.		aBlock value: obj.		self at: index put: obj].! !!B3DInplaceArray methodsFor: 'enumerating' stamp: 'ar 2/6/1999 00:37'!readOnlyDo: aBlock	^super do: aBlock! !!B3DColor4Array methodsFor: 'special ops' stamp: 'ar 2/7/1999 16:44'!add: aB3dColor4 at: index	| baseIdx |	baseIdx _ index-1*4.	self floatAt: baseIdx+1 put: (self floatAt: baseIdx+1) + aB3dColor4 red.	self floatAt: baseIdx+2 put: (self floatAt: baseIdx+2) + aB3dColor4 green.	self floatAt: baseIdx+3 put: (self floatAt: baseIdx+3) + aB3dColor4 blue.	self floatAt: baseIdx+4 put: (self floatAt: baseIdx+4) + aB3dColor4 alpha.! !!B3DInplaceArray class methodsFor: 'instance creation' stamp: 'ar 2/5/1999 22:48'!contentsClass	^self subclassResponsibility! !!B3DInplaceArray class methodsFor: 'instance creation' stamp: 'ar 2/5/1999 22:49'!contentsSize	^self contentsClass numElements! !!B3DInplaceArray class methodsFor: 'instance creation' stamp: 'ar 2/5/1999 22:49'!new: n	^super new: self contentsSize*n! !!B3DColor4Array class methodsFor: 'instance creation' stamp: 'ar 2/5/1999 22:50'!contentsClass	^B3DColor4! !!B3DIndexedQuadArray class methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:58'!contentsClass	^B3DIndexedQuad! !!B3DIndexedTriangleArray class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 20:56'!contentsClass	^B3DIndexedTriangle! !!B3DLightAttenuation commentStamp: 'ar 2/6/1999 18:48' prior: 0!I represent the attenuation for any given light source, e.g., how the intensity of the light is reduced with increasing distance from the object. I consist of three parts, a constant part, a linear part and a squared part. The resulting intensity for any given distance d is computed by:	intensity _ 1.0 / (constantPart + (distance * linearPart) + (distance^2 * squaredPart)).!!B3DLightAttenuation reorganize!('initialize' constant:linear:squared:)('accessing' constantPart constantPart: linearPart linearPart: squaredPart squaredPart:)('lighting' computeAttenuationFor:)('testing' isIdentity)!!B3DLightAttenuation methodsFor: 'initialize' stamp: 'ar 2/7/1999 19:02'!constant: constantFactor linear: linearFactor squared: squaredFactor	self constantPart: constantFactor.	self linearPart: linearFactor.	self squaredPart: squaredFactor.! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:44'!constantPart	^self floatAt: 1! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:45'!constantPart: aNumber	self floatAt: 1 put: aNumber! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:45'!linearPart	^self floatAt: 2! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:45'!linearPart: aNumber	self floatAt: 2 put: aNumber! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:45'!squaredPart	^self floatAt: 3! !!B3DLightAttenuation methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:45'!squaredPart: aNumber	self floatAt: 3 put: aNumber! !!B3DLightAttenuation methodsFor: 'lighting' stamp: 'ar 2/6/1999 18:44'!computeAttenuationFor: distance	"Compute the light attenuation for the given distance"	^1.0 / (self constantPart + 			(distance * (self linearPart + 				(distance * self squaredPart))))! !!B3DLightAttenuation methodsFor: 'testing' stamp: 'ar 2/15/1999 21:58'!isIdentity	"Return true if the attenuation results in a constant lighting"	^self constantPart = 1.0		and:[self linearPart = 0.0			and:[self squaredPart = 0.0]]! !!B3DLightAttenuation class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 19:01'!constant: constantFactor linear: linearFactor squared: squaredFactor	^self new constant: constantFactor linear: linearFactor squared: squaredFactor! !!B3DLightAttenuation class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 18:46'!numElements	^3! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:17'!direction	"If the light is directional, return the NORMALIZED direction of the light"	^B3DVector3 zero! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:28'!hotSpotDeltaCosine	"Return the cosine value of the delta radius of a spot light (the fall off region)"	^self hotSpotMaxCosine - self hotSpotMinCosine! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:27'!hotSpotMaxCosine	"Return the cosine value of the outer radius of a spot light (the unlit region)"	^0.0! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:26'!hotSpotMinCosine	"Return the cosine value of the inner radius of a spot light (the fully lit region)"	^0.0! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/8/1999 16:53'!lightColor	^lightColor! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/8/1999 16:53'!lightColor: aMaterialColor	lightColor _ aMaterialColor! !!B3DLightSource methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:42'!spotExponent	"Return the exponent to be used for the spot fall off computation"	^1! !!B3DLightSource methodsFor: 'testing' stamp: 'ar 2/7/1999 17:22'!hasAmbientPart	"Return true if the receiver contains an ambient part in its color"	^true! !!B3DLightSource methodsFor: 'testing' stamp: 'ar 2/15/1999 23:07'!hasDiffusePart	"Return true if the receiver contains a diffuse part in its color"	^true! !!B3DLightSource methodsFor: 'testing' stamp: 'ar 2/15/1999 23:07'!hasSpecularPart	"Return true if the receiver contains a specular part in its color"	^true! !!B3DLightSource methodsFor: 'testing' stamp: 'ar 2/7/1999 18:52'!hasSpot	"Return true if the receiver has a hot spot."	^false! !!B3DLightSource methodsFor: 'testing' stamp: 'ar 2/7/1999 17:27'!isAttenuated	"Return true if the receiver contains an attenuation.	If so, #computeAttenuationFor: must return the attenuation for the given distance."	^true! !!B3DLightSource methodsFor: 'shading' stamp: 'ar 2/7/1999 16:51'!computeAttenuationFor: distance	^self subclassResponsibility! !!B3DLightSource methodsFor: 'shading' stamp: 'ar 2/7/1999 16:51'!computeDirectionTo: aB3DPrimitiveVertex	^self subclassResponsibility! !!B3DLightSource methodsFor: 'shading' stamp: 'ar 2/15/1999 02:26'!computeSpotFactor: light2Vertex	"Compute the spot factor for a spot light"	| lightDirection cosAngle minCos deltaCos maxCos |	lightDirection _ self direction.	cosAngle _ (lightDirection dot: light2Vertex) negated.	(cosAngle < (minCos _ self hotSpotMinCosine)) ifTrue:[^0.0].	maxCos _ self hotSpotMaxCosine."	maxCos = 1.0 ifFalse:["		deltaCos _ self hotSpotDeltaCosine.		deltaCos <= 0.00001 ifTrue:[			"No delta -- a sharp boundary between on and off.			Since off has already been determined above, we are on"			^1.0].		"Scale the angle to 0/1 range"		cosAngle _ (cosAngle - minCos) / deltaCos.		self flag: #TODO. "Don't scale by (maxCos - minCos)""	]."	self flag: #TODO. "Use table lookup for spot exponent"	^cosAngle raisedTo: self spotExponent! !!B3DLightSource methodsFor: 'shading' stamp: 'ar 2/15/1999 03:55'!shadeVertexBuffer: vb with: aMaterial into: colorArray	"This is the generic shading function similar to the primitive.	Subclasses may implement optimized versions but should evaluate	exactly to the same value as in here if they are to be converted into	B3DPrimitiveLights."	| color vtxArray ambientColor vtx direction distance scale cosAngle diffusePart specularPart specDir specularFactor |	self flag: #b3dPrimitive.	vtxArray _ vb vertexArray.	(self hasAmbientPart and:[vb trackAmbientColor not])		ifTrue:[ambientColor _ aMaterial ambientPart * lightColor ambientPart].	(self hasDiffusePart and:[vb trackDiffuseColor not])		ifTrue:[diffusePart _ aMaterial diffusePart].	(self hasSpecularPart and:[vb trackSpecularColor not])		ifTrue:[specularPart _ aMaterial specularPart].	1 to: vb vertexCount do:[:i|		vtx _ vtxArray at: i.		color _ colorArray at: i.		"Compute the direction and distance of light source from vertex"		direction _ self computeDirectionTo: vtx.		distance _ direction length.		(distance = 0.0 or:[distance = 1.0]) ifFalse:[direction /= distance negated].		"Compute the attenuation for the given distance"		self isAttenuated			ifTrue:[scale _ self computeAttenuationFor: distance]			ifFalse:[scale _ 1.0].		"Compute spot light factor"		self hasSpot			ifTrue:[scale _ scale * (self computeSpotFactor: direction)].		"Compute ambient part"		self hasAmbientPart ifTrue:[			vb trackAmbientColor 				ifTrue:[ambientColor _ vtx b3dColor * lightColor ambientPart].			color += (ambientColor * scale).		].		"Compute the diffuse part of the light"		self hasDiffusePart ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ vtx normal dot: direction.			"For one-sided lighting negate cosAngle if necessary"			(vb twoSidedLighting not and:[cosAngle < 0.0]) 				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				vb trackDiffuseColor ifTrue:[diffusePart _ vtx b3dColor].				color += (diffusePart * lightColor diffusePart * (cosAngle * scale)).			].		].		"Compute specular part of the light"		(self hasSpecularPart and:[aMaterial shininess > 0.0]) ifTrue:[			vb useLocalViewer 				ifTrue:[specDir _ direction - vtx position safelyNormalized]				ifFalse:[specDir _ direction - (0@0@1.0)].			cosAngle _ vtx normal dot: specDir.			cosAngle > 0.0 ifTrue:[				"Normalize the angle"				cosAngle _ cosAngle / specDir length.				"cosAngle should be somewhere between 0 and 1.				If not, then the vertex normal was not normalized"				cosAngle > 1.0 ifTrue:[					specularFactor _ cosAngle raisedTo: aMaterial shininess.				] ifFalse:[					self flag: #TODO. "Use table lookup later"					specularFactor _ cosAngle raisedTo: self shininess.				].				color += (specularPart * lightColor specularPart * specularFactor).			].		].		self flag: #TODO. "Check specular part"		colorArray at: i put: color.	].! !!B3DLightSource methodsFor: 'converting' stamp: 'ar 2/7/1999 06:45'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight that can be handled by the shader primitive directly. Light sources that cannot be represented as primitive should return nil. This will result in the callback of #shadeVertexBuffer from the shader."	^nil! !!B3DLightSource methodsFor: 'converting' stamp: 'ar 2/8/1999 01:29'!transformedBy: aTransformer	^self clone! !!B3DLightSource methodsFor: 'private' stamp: 'ar 2/7/1999 16:37'!setColor: aColor	lightColor _ B3DMaterialColor new.	lightColor ambientPart: aColor.	lightColor diffusePart: aColor.	lightColor specularPart: aColor.! !!B3DAmbientLight methodsFor: 'testing' stamp: 'ar 2/8/1999 00:33'!hasDiffusePart	^false! !!B3DAmbientLight methodsFor: 'testing' stamp: 'ar 2/8/1999 00:33'!hasSpecularPart	^false! !!B3DAmbientLight methodsFor: 'shading' stamp: 'ar 2/7/1999 17:16'!computeAttenuationFor: distance	^1.0! !!B3DAmbientLight methodsFor: 'shading' stamp: 'ar 2/7/1999 16:56'!computeDirectionTo: aB3DPrimitiveVertex	^B3DVector3 zero! !!B3DAmbientLight methodsFor: 'shading' stamp: 'ar 2/8/1999 00:33'!shadeVertexBuffer: vb with: aMaterial into: colorArray	"Overridden for simplicity and speed"	| color |	false ifTrue:[^super shadeVertexBuffer: vb with: aMaterial into: colorArray].	self flag: #b3dPrimitive.	vb trackAmbientColor ifTrue:[		1 to: vb vertexCount do:[:i|			color _ (vb primitiveB3dColorAt: i) * lightColor ambientPart.			colorArray add: color at: i.		].	] ifFalse:[		color _ aMaterial ambientPart * lightColor ambientPart.		colorArray += color.	].! !!B3DAmbientLight methodsFor: 'converting' stamp: 'ar 2/15/1999 21:52'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight |	primLight _ B3DPrimitiveLight new.	primLight ambientPart: lightColor ambientPart.	primLight flags: FlagAmbientPart.	^primLight! !!B3DAmbientLight methodsFor: 'converting' stamp: 'ar 2/8/1999 01:29'!transformedBy: aTransformer	^self! !!B3DDirectionalLight methodsFor: 'shading' stamp: 'ar 2/7/1999 16:54'!computeAttenuationFor: distance	"Since a directional light is positioned at virtual infinity, it cannot have any attenuation"	^1.0! !!B3DDirectionalLight methodsFor: 'shading' stamp: 'ar 2/7/1999 16:53'!computeDirectionTo: aB3DPrimitiveVertex	"A directional light has an explicit direction regardless of the vertex position"	^direction! !!B3DDirectionalLight methodsFor: 'converting' stamp: 'ar 2/15/1999 21:55'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight flags |	primLight _ B3DPrimitiveLight new.	primLight direction: direction.	flags _ FlagDirectional.	lightColor ambientPart isZero ifFalse:[		primLight ambientPart: lightColor ambientPart.		flags _ flags bitOr: FlagAmbientPart].	lightColor diffusePart isZero ifFalse:[		primLight diffusePart: lightColor diffusePart.		flags _ flags bitOr: FlagDiffusePart].	lightColor specularPart isZero ifFalse:[		primLight specularPart: lightColor specularPart.		flags _ flags bitOr: FlagSpecularPart].	primLight flags: flags.	^primLight! !!B3DDirectionalLight methodsFor: 'converting' stamp: 'ar 2/8/1999 01:28'!transformedBy: aTransformer	^(super transformedBy: aTransformer) direction: (aTransformer transformDirection: direction)! !!B3DLightSource class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 16:09'!color: aColor	^self new setColor: aColor.! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:58'!ambientPart	^B3DColor4		r: self ambientRed		g: self ambientGreen		b: self ambientBlue		a: self ambientAlpha! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 19:00'!ambientPart: aColor	self ambientRed: aColor red.	self ambientGreen: aColor green.	self ambientBlue: aColor blue.	self ambientAlpha: aColor alpha.! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:58'!diffusePart	^B3DColor4		r: self diffuseRed		g: self diffuseGreen		b: self diffuseBlue		a: self diffuseAlpha! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 19:00'!diffusePart: aColor	self diffuseRed: aColor red.	self diffuseGreen: aColor green.	self diffuseBlue: aColor blue.	self diffuseAlpha: aColor alpha.! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 18:59'!specularPart	^B3DColor4		r: self specularRed		g: self specularGreen		b: self specularBlue		a: self specularAlpha! !!B3DMaterialColor methodsFor: 'accessing' stamp: 'ar 2/6/1999 19:01'!specularPart: aColor	self specularRed: aColor red.	self specularGreen: aColor green.	self specularBlue: aColor blue.	self specularAlpha: aColor alpha.! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!ambientAlpha	^self floatAt: 4! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!ambientAlpha: aFloat	^self floatAt: 4 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!ambientBlue	^self floatAt: 3! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!ambientBlue: aFloat	^self floatAt: 3 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!ambientGreen	^self floatAt: 2! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!ambientGreen: aFloat	^self floatAt: 2 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!ambientRed	^self floatAt: 1! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!ambientRed: aFloat	^self floatAt: 1 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!diffuseAlpha	^self floatAt: 8! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!diffuseAlpha: aFloat	^self floatAt: 8 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!diffuseBlue	^self floatAt: 7! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!diffuseBlue: aFloat	^self floatAt: 7 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!diffuseGreen	^self floatAt: 6! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!diffuseGreen: aFloat	^self floatAt: 6 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:01'!diffuseRed	^self floatAt: 5! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!diffuseRed: aFloat	^self floatAt: 5 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!specularAlpha	^self floatAt: 12! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!specularAlpha: aFloat	^self floatAt: 12 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!specularBlue	^self floatAt: 11! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:03'!specularBlue: aFloat	^self floatAt: 11 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!specularGreen	^self floatAt: 10! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:04'!specularGreen: aFloat	^self floatAt: 10 put: aFloat! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:02'!specularRed	^self floatAt: 9! !!B3DMaterialColor methodsFor: 'element access' stamp: 'ar 2/6/1999 19:04'!specularRed: aFloat	^self floatAt: 9 put: aFloat! !!B3DMaterialColor methodsFor: 'private' stamp: 'ar 2/7/1999 18:41'!setColor: aColor	self ambientPart: aColor.	self diffusePart: aColor.	self specularPart: aColor.! !!B3DMaterial methodsFor: 'initialize' stamp: 'ar 2/16/1999 03:05'!from3DS: aDictionary	self ambientPart: (aDictionary at: #ambient ifAbsent:[B3DColor4 r: 0.0 g: 0.0 b: 0.0 a: 1.0]).	self diffusePart: (aDictionary at: #diffuse ifAbsent:[B3DColor4 r: 0.0 g: 0.0 b: 0.0 a: 1.0]).	self specularPart: (aDictionary at: #specular ifAbsent:[B3DColor4 r: 0.0 g: 0.0 b: 0.0 a: 1.0]).	(aDictionary includesKey: #textureName) 		ifTrue:[^(aDictionary at: #textureName) -> self].! !!B3DMaterial methodsFor: 'accessing' stamp: 'ar 2/8/1999 00:54'!emission	^B3DColor4		r: self emissionRed		g: self emissionGreen		b: self emissionBlue		a: self emissionAlpha! !!B3DMaterial methodsFor: 'accessing' stamp: 'ar 2/8/1999 00:53'!emission: aColor	self emissionRed: aColor red.	self emissionGreen: aColor green.	self emissionBlue: aColor blue.	self emissionAlpha: aColor alpha.! !!B3DMaterial methodsFor: 'accessing' stamp: 'ar 2/8/1999 00:58'!shininess	^self floatAt: 17! !!B3DMaterial methodsFor: 'accessing' stamp: 'ar 2/8/1999 00:59'!shininess: aFloat	^self floatAt: 17 put: (aFloat max: 0.0).! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:58'!emissionAlpha	^self floatAt: 16! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:59'!emissionAlpha: aFloat	self floatAt: 16 put: aFloat! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:58'!emissionBlue	^self floatAt: 15! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:59'!emissionBlue: aFloat	self floatAt: 15 put: aFloat! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:58'!emissionGreen	^self floatAt: 14! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:59'!emissionGreen: aFloat	self floatAt: 14 put: aFloat! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:58'!emissionRed	^self floatAt: 13! !!B3DMaterial methodsFor: 'element access' stamp: 'ar 2/8/1999 00:59'!emissionRed: aFloat	self floatAt: 13 put: aFloat! !!B3DMaterialColor class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 18:41'!color: aColor	^self new setColor: aColor! !!B3DMaterialColor class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 19:04'!numElements	^12! !!B3DMaterial class methodsFor: 'instance creation' stamp: 'ar 2/8/1999 01:01'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DMaterial class methodsFor: 'instance creation' stamp: 'ar 2/8/1999 01:00'!numElements	^17! !!B3DMatrix4x4 methodsFor: 'initialize' stamp: 'ar 2/15/1999 02:55'!setScale: aVector	self 		a11: aVector x;		a22: aVector y;		a33: aVector z! !!B3DMatrix4x4 methodsFor: 'transforming' stamp: 'ar 2/15/1999 23:56'!composedWithGlobal: aB3DMatrix4x4	| result |	result _ self class new.	self privateTransformMatrix: aB3DMatrix4x4 with: self into: result.	^result! !!B3DMatrix4x4 methodsFor: 'transforming' stamp: 'ar 2/15/1999 23:57'!composedWithLocal: aB3DMatrix4x4	| result |	result _ self class new.	self privateTransformMatrix: self with: aB3DMatrix4x4 into: result.	^result! !!B3DMatrix4x4 methodsFor: 'transforming' stamp: 'ar 2/15/1999 23:50'!localPointToGlobal: aVector	"Multiply aVector (temporarily converted to 4D) with the receiver"	| x y z rx ry rz rw |	x := aVector x.	y := aVector y.	z := aVector z.	rx := (x * self a11) + (y * self a12) + (z * self a13) + self a14.	ry := (x * self a21) + (y * self a22) + (z * self a23) + self a24.	rz := (x * self a31) + (y * self a32) + (z * self a33) + self a34.	rw := (x * self a41) + (y * self a42) + (z * self a43) + self a44.	^B3DVector3 x:(rx/rw) y: (ry/rw) z: (rz/rw)! !!B3DMatrix4x4 methodsFor: 'transforming' stamp: 'ar 2/7/1999 06:32'!quickTransformV3ArrayFrom: srcArray to: dstArray	"Transform the 3 element vertices from srcArray to dstArray.	ASSUMPTION: a41 = a42 = a43 = 0.0 and a44 = 1.0"	| a11 a12 a13 a14 a21 a22 a23 a24 a31 a32 a33 a34 x y z index |	self flag: #b3dPrimitive.	a11 _ self a11.	a12 _ self a12.	a13 _ self a13.	a14 _ self a14.	a21 _ self a21.	a22 _ self a22.	a23 _ self a23.	a24 _ self a24.	a31 _ self a31.	a32 _ self a32.	a33 _ self a33.	a34 _ self a34.	1 to: srcArray size do:[:i|		index _ i-1*3.		x _ srcArray floatAt: index+1.		y _ srcArray floatAt: index+2.		z _ srcArray floatAt: index+3.		dstArray floatAt: index+1 put: (a11*x) + (a12*y) + (a13*z) + a14.		dstArray floatAt: index+2 put: (a21*x) + (a22*y) + (a23*z) + a24.		dstArray floatAt: index+3 put: (a31*x) + (a32*y) + (a33*z) + a34.	].	^dstArray! !!B3DMatrix4x4 methodsFor: 'double dispatching' stamp: 'ar 2/8/1999 20:11'!productFromMatrix4x4: matrix	"Multiply a 4x4 matrix with the receiver."	| result |	result := self class new.	result a11: ((matrix a11 * self a11) + (matrix a12 * self a21) + 				(matrix a13 * self a31) + (matrix a14 * self a41)).	result a12: ((matrix a11 * self a12) + (matrix a12 * self a22) + 				(matrix a13 * self a32) + (matrix a14 * self a42)).	result a13: ((matrix a11 * self a13) + (matrix a12 * self a23) + 				(matrix a13 * self a33) + (matrix a14 * self a43)).	result a14: ((matrix a11 * self a14) + (matrix a12 * self a24) + 				(matrix a13 * self a34) + (matrix a14 * self a44)).	result a21: ((matrix a21 * self a11) + (matrix a22 * self a21) + 				(matrix a23 * self a31) + (matrix a24 * self a41)).	result a22: ((matrix a21 * self a12) + (matrix a22 * self a22) + 				(matrix a23 * self a32) + (matrix a24 * self a42)).	result a23: ((matrix a21 * self a13) + (matrix a22 * self a23) + 				(matrix a23 * self a33) + (matrix a24 * self a43)).	result a24: ((matrix a21 * self a14) + (matrix a22 * self a24) + 				(matrix a23 * self a34) + (matrix a24 * self a44)).	result a31: ((matrix a31 * self a11) + (matrix a32 * self a21) + 				(matrix a33 * self a31) + (matrix a34 * self a41)).	result a32: ((matrix a31 * self a12) + (matrix a32 * self a22) + 				(matrix a33 * self a32) + (matrix a34 * self a42)).	result a33: ((matrix a31 * self a13) + (matrix a32 * self a23) + 				(matrix a33 * self a33) + (matrix a34 * self a43)).	result a34: ((matrix a31 * self a14) + (matrix a32 * self a24) + 				(matrix a33 * self a34) + (matrix a34 * self a44)).	result a41: ((matrix a41 * self a11) + (matrix a42 * self a21) + 				(matrix a43 * self a31) + (matrix a44 * self a41)).	result a42: ((matrix a41 * self a12) + (matrix a42 * self a22) + 				(matrix a43 * self a32) + (matrix a44 * self a42)).	result a43: ((matrix a41 * self a13) + (matrix a42 * self a23) + 				(matrix a43 * self a33) + (matrix a44 * self a43)).	result a44: ((matrix a41 * self a14) + (matrix a42 * self a24) + 				(matrix a43 * self a34) + (matrix a44 * self a44)).	^result! !!B3DMatrix4x4 methodsFor: 'private' stamp: 'ar 2/15/1999 23:58'!privateTransformMatrix: m1 with: m2 into: m3	"Perform a 4x4 matrix multiplication		m2 * m1 = m3	being equal to first transforming points by m2 and then by m1.	Note that m1 may be identical to m3.	NOTE: The primitive implementation does NOT return m3 - and so don't we!!"	| c1 c2 c3 c4 |	<primitive: 'b3dTransformMatrixWithInto' module:'Squeak3D'>	m2 == m3 ifTrue:[^self error:'Argument and result matrix identical'].	c1 _ ((m1 a11 * m2 a11) + (m1 a12 * m2 a21) + 				(m1 a13 * m2 a31) + (m1 a14 * m2 a41)).	c2 _ ((m1 a11 * m2 a12) + (m1 a12 * m2 a22) + 				(m1 a13 * m2 a32) + (m1 a14 * m2 a42)).	c3 _ ((m1 a11 * m2 a13) + (m1 a12 * m2 a23) + 				(m1 a13 * m2 a33) + (m1 a14 * m2 a43)).	c4 _ ((m1 a11 * m2 a14) + (m1 a12 * m2 a24) + 				(m1 a13 * m2 a34) + (m1 a14 * m2 a44)).	m3 a11: c1; a12: c2; a13: c3; a14: c4.	c1 _ ((m1 a21 * m2 a11) + (m1 a22 * m2 a21) + 				(m1 a23 * m2 a31) + (m1 a24 * m2 a41)).	c2 _ ((m1 a21 * m2 a12) + (m1 a22 * m2 a22) + 				(m1 a23 * m2 a32) + (m1 a24 * m2 a42)).	c3 _ ((m1 a21 * m2 a13) + (m1 a22 * m2 a23) + 				(m1 a23 * m2 a33) + (m1 a24 * m2 a43)).	c4 _ ((m1 a21 * m2 a14) + (m1 a22 * m2 a24) + 				(m1 a23 * m2 a34) + (m1 a24 * m2 a44)).	m3 a21: c1; a22: c2; a23: c3; a24: c4.	c1 _ ((m1 a31 * m2 a11) + (m1 a32 * m2 a21) + 				(m1 a33 * m2 a31) + (m1 a34 * m2 a41)).	c2 _ ((m1 a31 * m2 a12) + (m1 a32 * m2 a22) + 				(m1 a33 * m2 a32) + (m1 a34 * m2 a42)).	c3 _ ((m1 a31 * m2 a13) + (m1 a32 * m2 a23) + 				(m1 a33 * m2 a33) + (m1 a34 * m2 a43)).	c4 _ ((m1 a31 * m2 a14) + (m1 a32 * m2 a24) + 				(m1 a33 * m2 a34) + (m1 a34 * m2 a44)).	m3 a31: c1; a32: c2; a33: c3; a34: c4.	c1 _ ((m1 a41 * m2 a11) + (m1 a42 * m2 a21) + 				(m1 a43 * m2 a31) + (m1 a44 * m2 a41)).	c2 _ ((m1 a41 * m2 a12) + (m1 a42 * m2 a22) + 				(m1 a43 * m2 a32) + (m1 a44 * m2 a42)).	c3 _ ((m1 a41 * m2 a13) + (m1 a42 * m2 a23) + 				(m1 a43 * m2 a33) + (m1 a44 * m2 a43)).	c4 _ ((m1 a41 * m2 a14) + (m1 a42 * m2 a24) + 				(m1 a43 * m2 a34) + (m1 a44 * m2 a44)).	m3 a41: c1; a42: c2; a43: c3; a44: c4.! !!B3DMatrix4x4 class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 23:58'!rotatedBy: angle around: axis centeredAt: origin	"Create a matrix rotating points around the given origin using the angle/axis pair"	| xform |	xform _ self withOffset: origin negated.	xform _ xform composedWithGlobal:(B3DRotation angle: angle axis: axis) asMatrix4x4.	xform _ xform composedWithGlobal: (self withOffset: origin).	^xform! !!B3DMatrix4x4 class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 23:48'!withOffset: amount	^self identity setTranslation: amount! !!B3DMorph methodsFor: 'initialize' stamp: 'ar 2/16/1999 17:20'!initialize	super initialize.	geometry _ B3DBox from: (-0.7@-0.7@-0.7) to: (0.7@0.7@0.7).	camera _ B3DCamera new.	(self confirm:'Put me into a clipping frame?') 		ifTrue:[camera position: 0@0@1.5]		ifFalse:[camera position: 0@0@2. color _ nil].	camera nearDistance: 0.1.	camera farDistance: 5.0.	self extent: 100@100.	angle _ 0.! !!B3DMorph methodsFor: 'drawing' stamp: 'ar 2/8/1999 02:48'!drawOn: aCanvas	color ifNotNil:["aCanvas frameAndFillRectangle: self bounds fillColor: color borderWidth: 1 borderColor: Color black."		aCanvas frameRectangle: self bounds color: self color].	aCanvas asBalloonCanvas render: self.! !!B3DMorph methodsFor: 'drawing' stamp: 'ar 2/16/1999 17:26'!renderOn: aRenderer	camera ifNotNil:[		aRenderer viewport: (self bounds insetBy: 1@1).		aRenderer clearDepthBuffer.		aRenderer loadIdentity.		camera renderOn: aRenderer].	aRenderer texture: texture.	aRenderer transformBy: (B3DRotation angle: angle axis: 0@1@0).	geometry ifNotNil:[geometry renderOn: aRenderer].! !!B3DMorph methodsFor: 'menu' stamp: 'ar 2/16/1999 17:22'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add:'set texture' action: #setTexture.! !!B3DMorph methodsFor: 'menu' stamp: 'ar 2/16/1999 17:28'!setTexture	| tex |	tex _ B3DTexture fromDisplay:(Rectangle originFromUser: 128@128).	tex wrap: true.	tex interpolate: false.	tex envMode: 0.	texture _ tex.	self changed! !!B3DPositionalLight methodsFor: 'initialize' stamp: 'ar 2/7/1999 19:14'!from3DS: aDictionary	"Initialize the receiver from a 3DS point light"	| color |	position _ aDictionary at: #position.	color _ aDictionary at: #color.	lightColor _ B3DMaterialColor color: color.	attenuation _ B3DLightAttenuation constant: 1.0 linear: 0.0 squared: 0.0.! !!B3DPositionalLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:05'!attenuation	^attenuation! !!B3DPositionalLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:05'!attenuation: aLightAttenuation	attenuation _ aLightAttenuation! !!B3DPositionalLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:04'!position	^position! !!B3DPositionalLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:04'!position: aVector	position _ aVector! !!B3DPositionalLight methodsFor: 'shading' stamp: 'ar 2/7/1999 16:54'!computeAttenuationFor: distance	"Compute the attenuation for the given distance"	^attenuation computeAttenuationFor: distance! !!B3DPositionalLight methodsFor: 'shading' stamp: 'ar 2/8/1999 02:01'!computeDirectionTo: aB3DPrimitiveVertex	"Compute the lights direction to the given vertex"	^aB3DPrimitiveVertex position - position! !!B3DPositionalLight methodsFor: 'converting' stamp: 'ar 2/15/1999 21:58'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight flags |	primLight _ B3DPrimitiveLight new.	primLight position: position.	flags _ FlagPositional.	self attenuation isIdentity not ifTrue:[		primLight attenuation: self attenuation.		flags _ flags bitOr: FlagAttenuated].	lightColor ambientPart isZero ifFalse:[		primLight ambientPart: lightColor ambientPart.		flags _ flags bitOr: FlagAmbientPart].	lightColor diffusePart isZero ifFalse:[		primLight diffusePart: lightColor diffusePart.		flags _ flags bitOr: FlagDiffusePart].	lightColor specularPart isZero ifFalse:[		primLight specularPart: lightColor specularPart.		flags _ flags bitOr: FlagSpecularPart].	primLight flags: flags.	^primLight! !!B3DPositionalLight methodsFor: 'converting' stamp: 'ar 2/8/1999 01:29'!transformedBy: aTransformer	^(super transformedBy: aTransformer) position: (aTransformer transformPosition: position)! !!B3DPositionalLight class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 23:42'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:51'!attenuation	"Return the light attenuation.	This member is only valid if the light is attenuated."	^B3DLightAttenuation		constant: self constantAttenuation		linear: self linearAttenuation		squared: self squaredAttenuation! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:52'!attenuation: aLightAttenuation	"Set the light attenuation.	This member is only valid if the light is attenuated."	self constantAttenuation: aLightAttenuation constantPart.	self linearAttenuation: aLightAttenuation linearPart.	self squaredAttenuation: aLightAttenuation squaredPart.! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:47'!direction	"Return the direction of the light.	This member is valid only if the light is not positional 	(e.g., the direction must be computed for every vertex)"	^B3DVector3		x: self directionX		y: self directionY		z: self directionZ! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:49'!direction: aB3DVector	"Set the direction of the light.	This member is valid only if the light is positional 	(e.g., the direction must be computed for every vertex)"	self directionX: aB3DVector x.	self directionY: aB3DVector y.	self directionZ: aB3DVector z.! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!flags	^self wordAt: PrimLightFlags+1! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!flags: aValue	^self wordAt: PrimLightFlags+1 put: aValue! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:49'!position	"Return the position of the light.	This member is valid only if the light is not positional 	(e.g., the direction must be computed for every vertex)"	^B3DVector3		x: self positionX		y: self positionY		z: self positionZ! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 03:48'!position: aB3DVector	"Set the position of the light.	This member is valid only if the light is positional 	(e.g., the direction must be computed for every vertex)"	self positionX: aB3DVector x.	self positionY: aB3DVector y.	self positionZ: aB3DVector z.! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!spotDeltaCos	^self floatAt: SpotLightDeltaCos+1! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!spotDeltaCos: aFloat	^self floatAt: SpotLightDeltaCos+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!spotExponent	^self floatAt: SpotLightExponent+1! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:17'!spotExponent: aFloat	^self floatAt: SpotLightExponent+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:18'!spotMaxCos	^self floatAt: SpotLightMaxCos+1! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:18'!spotMaxCos: aFloat	^self floatAt: SpotLightMaxCos+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:18'!spotMinCos	^self floatAt: SpotLightMinCos+1! !!B3DPrimitiveLight methodsFor: 'accessing' stamp: 'ar 2/15/1999 22:18'!spotMinCos: aFloat	^self floatAt: SpotLightMinCos+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:14'!constantAttenuation	^self floatAt: PrimLightAttenuationConstant+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:14'!constantAttenuation: aFloat	^self floatAt: PrimLightAttenuationConstant+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:14'!directionX	^self floatAt: PrimLightDirectionX+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:14'!directionX: aFloat	^self floatAt: PrimLightDirectionX+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:14'!directionY	^self floatAt: PrimLightDirectionY+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!directionY: aFloat	^self floatAt: PrimLightDirectionY+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!directionZ	^self floatAt: PrimLightDirectionZ+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!directionZ: aFloat	^self floatAt: PrimLightDirectionZ+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!linearAttenuation	^self floatAt: PrimLightAttenuationLinear+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!linearAttenuation: aFloat	^self floatAt: PrimLightAttenuationLinear+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionX	^self floatAt: PrimLightPositionX+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionX: aFloat	^self floatAt: PrimLightPositionX+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionY	^self floatAt: PrimLightPositionY+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionY: aFloat	^self floatAt: PrimLightPositionY+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionZ	^self floatAt: PrimLightPositionZ+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!positionZ: aFloat	^self floatAt: PrimLightPositionZ+1 put: aFloat! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!squaredAttenuation	^self floatAt: PrimLightAttenuationSquared+1! !!B3DPrimitiveLight methodsFor: 'element access' stamp: 'ar 2/15/1999 22:15'!squaredAttenuation: aFloat	^self floatAt: PrimLightAttenuationSquared+1 put: aFloat! !!B3DPrimitiveLight class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 22:11'!numElements	^PrimLightSize! !!B3DPrimitiveVertex commentStamp: 'ar 2/14/1999 01:27' prior: 0!I represent all per vertex information used in Balloon 3D primitive operations. I store either 32bit floats or integers depending on what is requested.C representation:	typedef struct B3DPrimitiveVertex {		float position[3];		float normal[3];		float texCoord[2];		float rasterPos[4];		int pixelValue32;		int clipFlags;		/* two more for getting a power of 2 */		int unused1;		int unused2;	} B3DPrimitiveVertex;!!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/5/1999 19:27'!b3dColor	^self color asB3DColor! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/5/1999 19:28'!b3dColor: aB3DColor4	self color: aB3DColor4 asColor! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/4/1999 23:53'!clipFlags	^self wordAt: 14! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/4/1999 23:53'!clipFlags: aNumber	self wordAt: 14 put: aNumber! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/5/1999 19:20'!floatAt: index	<primitive:'primitiveFloatArrayAt'>	^Float fromIEEE32Bit: (self basicAt: index)! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/5/1999 19:21'!floatAt: index put: value	<primitive:'primitiveFloatArrayAtPut'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/5/1999 19:30'!texCoords: aVector	self floatAt: 7 put: aVector x.	self floatAt: 8 put: aVector y.! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:48'!normalX	^self floatAt: 4! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:50'!normalX: aFloat	self floatAt: 4 put: aFloat! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:48'!normalY	^self floatAt: 5! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:50'!normalY: aFloat	self floatAt: 5 put: aFloat! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:48'!normalZ	^self floatAt: 6! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 2/8/1999 17:50'!normalZ: aFloat	self floatAt: 6 put: aFloat! !!B3DPrimitiveVertex class methodsFor: 'instance creation' stamp: 'ar 2/14/1999 01:23'!new	^self new: PrimVertexSize! !!B3DPrimitiveVertexArray commentStamp: 'ar 2/13/1999 20:15' prior: 0!I store Balloon 3D primitive vertices in place. I am used to pass data efficiently to the primitive level during high-bandwidth operations.!!B3DPrimitiveVertexArray methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:24'!at: index	"Return the primitive vertex at the given index"	| vtx |	(index < 1 or:[index > self size]) ifTrue:[^self errorSubscriptBounds: index].	vtx _ B3DPrimitiveVertex new.	vtx privateReplaceFrom: 1 to: vtx size with: self startingAt: index-1*PrimVertexSize+1.	^vtx! !!B3DPrimitiveVertexArray methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:24'!at: index put: aB3DPrimitiveVertex	"Store the primitive vertex at the given index in the receiver"	| idx |	(index < 1 or:[index > self size]) ifTrue:[^self errorSubscriptBounds: index].	idx _ index-1*PrimVertexSize.	self privateReplaceFrom: idx+1 to: idx+PrimVertexSize with: aB3DPrimitiveVertex startingAt: 1.	^aB3DPrimitiveVertex! !!B3DPrimitiveVertexArray methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:24'!size	"Return the number of primitive vertices that can be stored in the receiver"	^self basicSize // PrimVertexSize! !!B3DPrimitiveVertexArray methodsFor: 'enumerating' stamp: 'ar 2/4/1999 23:57'!upTo: max do: aBlock	"Special enumeration message so the client can modify the vertices"	| vtx |	1 to: max do:[:i|		vtx _ self at: i.		aBlock value: vtx.		self at: i put: vtx].! !!B3DPrimitiveVertexArray methodsFor: 'enumerating' stamp: 'ar 2/4/1999 23:59'!upTo: max doWithIndex: aBlock	"Special enumeration message so the client can modify the vertices"	| vtx |	1 to: max do:[:i|		vtx _ self at: i.		aBlock value: vtx value: i.		self at: i put: vtx].! !!B3DPrimitiveVertexArray methodsFor: 'private' stamp: 'ar 2/15/1999 00:42'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	^super replaceFrom: start to: stop with: replacement startingAt: repStart ! !!B3DPrimitiveVertexArray class methodsFor: 'instance creation' stamp: 'ar 2/14/1999 01:24'!new: n	^super new: (n * PrimVertexSize)! !!B3DRenderEngine commentStamp: 'ar 2/13/1999 20:20' prior: 0!I represent a facade for all Balloon 3D operations. Clients should only interact with me, not with any of the parts of the engine directly. However, clients may configure me to use certain parts in the 3D rendering pipeline.Instance variables: 	vertexBuffer 	<B3DVertexBuffer>	The vertex buffer passed on through the entire pipeline	transformer 	<B3DEnginePart>		The part performing transform operations	shader 			<B3DEnginePart>		The part performing vertex shading operations	clipper 			<B3DEnginePart>		The part performing view frustum clipping	rasterizer		<B3DEnginePart>		The part performing final pixel rasterization!!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/14/1999 22:22'!clearDepthBuffer	^rasterizer clearDepthBuffer! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/16/1999 02:17'!clearViewport: aColor	^rasterizer clearViewport: aColor! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 19:34'!material	^shader material! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 19:34'!material: aMaterial	^shader material: aMaterial! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 16:19'!materialColor	^shader materialColor! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 16:19'!materialColor: aColor	^shader materialColor: aColor! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 19:35'!popMaterial	^shader popMaterial.! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/16/1999 03:14'!popTexture	^rasterizer popTexture! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/7/1999 19:34'!pushMaterial	^shader pushMaterial.! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/16/1999 03:14'!pushTexture	^rasterizer pushTexture! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/16/1999 03:14'!texture	^rasterizer texture! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 2/16/1999 03:14'!texture: aForm	^rasterizer texture: aForm! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/15/1999 20:24'!addLight: aLightSource	"Add the given light source to the engine.	Return a handle that can be used to modify the light source later on"	^shader addLight: (aLightSource transformedBy: transformer)! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/15/1999 20:25'!removeLight: lightHandle	"Remove the light with the given handle from the engine."	^shader removeLight: lightHandle! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:30'!trackAmbientColor	^vertexBuffer trackAmbientColor! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:30'!trackAmbientColor: aBoolean	^vertexBuffer trackAmbientColor: aBoolean! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:31'!trackDiffuseColor	^vertexBuffer trackDiffuseColor! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:30'!trackDiffuseColor: aBoolean	^vertexBuffer trackDiffuseColor: aBoolean! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:31'!trackEmissionColor	^vertexBuffer trackEmissionColor! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:30'!trackEmissionColor: aBoolean	^vertexBuffer trackEmissionColor: aBoolean! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:31'!trackSpecularColor	^vertexBuffer trackSpecularColor! !!B3DRenderEngine methodsFor: 'shading' stamp: 'ar 2/8/1999 02:30'!trackSpecularColor: aBoolean	^vertexBuffer trackSpecularColor: aBoolean! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 2/7/1999 19:52'!drawIndexedLines: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 4.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	self renderPrimitive.! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 2/7/1999 19:52'!drawIndexedQuads: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 6.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	self renderPrimitive.! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 2/7/1999 19:52'!drawIndexedTriangles: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 5.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	self renderPrimitive.! !!B3DRenderEngine methodsFor: 'draw primitives' stamp: 'ar 2/5/1999 18:50'!drawPolygonAfter: aBlock	vertexBuffer reset.	vertexBuffer primitive: 3.	aBlock value.	self renderPrimitive.! !!B3DRenderEngine methodsFor: 'private-rendering' stamp: 'ar 2/8/1999 15:37'!privateClipVB: vb	"Clip the objects in the vertex buffer."	^clipper processVertexBuffer: vb! !!B3DRenderEngine methodsFor: 'private-rendering' stamp: 'ar 2/8/1999 21:18'!privateTransformVB: vb	"Transform the contents of the vertex buffer.	Transforming may include normals (if lighting enabled) and textures (if textures enabled)."	^transformer processVertexBuffer: vb! !!B3DRenderEngine methodsFor: 'transforming' stamp: 'ar 2/5/1999 23:27'!popMatrix	^transformer popMatrix! !!B3DRenderEngine methodsFor: 'transforming' stamp: 'ar 2/5/1999 23:27'!pushMatrix	^transformer pushMatrix! !!B3DRenderEngine methodsFor: 'transforming' stamp: 'ar 2/15/1999 02:54'!scaleBy: value	^transformer scaleBy: value! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 2/16/1999 01:46'!destroy	"Utility - destroy all resources associated with any part of the engine"	transformer destroy.	shader destroy.	clipper destroy.	rasterizer destroy.! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 2/16/1999 01:45'!finish	"Flush the pipeline and force changes to the output medium"	self flush.	rasterizer finish.! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 2/5/1999 21:34'!flush	"Flush the entire pipeline"	transformer flush.	shader flush.	clipper flush.	rasterizer flush.! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 2/14/1999 01:43'!initialize	vertexBuffer _ B3DVertexBuffer new.	transformer _ self class transformer engine: self.	shader _ self class shader engine: self.	clipper _ self class clipper engine: self.	rasterizer _ self class rasterizer engine: self.	self materialColor: Color white.! !!B3DRenderEngine class methodsFor: 'instance creation' stamp: 'ar 2/16/1999 17:33'!defaultForPlatformOn: aForm	"Return the render engine that is most appropriate for the current host platform.	If aForm is nil, then the engine may render directly onto the host window.	For now, we only have the choice between OSMesa (preferred) or Balloon2D"	^(OSMesaRenderEngine isAvailableFor: aForm)		ifTrue:[OSMesaRenderEngine]		ifFalse:[B3DRenderEngine]! !!B3DRenderEngine class methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:37'!clipper	"Return the transformer to use with this engine"	^B3DVertexClipper! !!B3DRenderEngine class methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:36'!rasterizer	"Return the rasterizer to use with this engine"	^B3DSqueakFormRasterizer! !!B3DRenderEngine class methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:37'!shader	"Return the shader to use with this engine"	^B3DVertexShader! !!B3DRenderEngine class methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:37'!transformer	"Return the transformer to use with this engine"	^B3DVertexTransformer! !!B3DRenderEngine class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:39'!isAvailable	"Return true if this engine is available (e.g., all of its parts are avaiable)"	^(self transformer isAvailable and:[		self shader isAvailable and:[			self clipper isAvailable and:[				self rasterizer isAvailable]]])! !!B3DRenderEngine class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:34'!isAvailableFor: anOutputMedium	"Return true if this engine is available for the given output medium"	^(self transformer isAvailableFor: anOutputMedium)  and:[		(self shader isAvailableFor: anOutputMedium) and:[			(self clipper isAvailableFor: anOutputMedium) and:[				(self rasterizer isAvailableFor: anOutputMedium)]]]! !!B3DSTriangleMesh commentStamp: 'ar 2/15/1999 06:59' prior: 0!I represent a mesh from Autodesk 3D Studio.!!B3DSTriangleMesh methodsFor: 'initialize' stamp: 'ar 2/7/1999 20:57'!from3DS: aDictionary	| triList triSpec triSize tri flags |	aDictionary isEmpty ifTrue:[^nil].	vertices _ aDictionary at: #vertexList.	"matrix _ aDictionary at: #matrix ifAbsent:[nil].	matrix ifNotNil:[matrix quickTransformV3ArrayFrom: vertices to: vertices]."	vtxTexCoords _ aDictionary at: #textureVertices ifAbsent:[nil].	triList _ aDictionary at: #triList.	triSpec _ triList first.	triSize _ triSpec size.	faces _ B3DIndexedTriangleArray new: triSize.	edgeFlags _ ByteArray new: triSize.	1 to: triSize do:[:i|		tri _ (triSpec at: i) key.		flags _ (triSpec at: i) value.		faces at: i put: (B3DIndexedTriangle with: tri first with: tri second with: tri third).		edgeFlags at: i put: flags].	triList second ifNotNil:[		smoothFlags _ WordArray new: triSize.		triList second doWithIndex:[:smoothFlag :index| smoothFlags at: index put: smoothFlag]].! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/15/1999 06:44'!collectSplitVertices: aSet	"Collect the non smooth vertices into a Dictionary		vertex index -> Dictionary							smoothing group -> list of face indexes.	"	| face flag vtxIndex groups groupDict |	groupDict _ Dictionary new: aSet size * 2.	1 to: faces size do:[:faceIndex|		face _ faces at: faceIndex.		flag _ smoothFlags at: faceIndex.		1 to: 3 do:[:j|			vtxIndex _ face at: j.			(aSet includes: vtxIndex) ifTrue:[ 				groups _ groupDict at: vtxIndex ifAbsentPut:[Dictionary new].				(groups at: flag ifAbsentPut:[OrderedCollection new]) add: faceIndex.			].		].	].	^groupDict! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/16/1999 06:06'!computeVertexNormals	"Compute the vertex normals for the receiver.	Note: This is a multi pass process here - we may have to split up vertices"	| set dict |true ifTrue:[^super computeVertexNormals].	set _ self detectNonSmoothVertices.	set isEmpty ifFalse:[		"Collect the dictionary of vertices to split"		dict _ self collectSplitVertices: set.		"And actually split them"		self splitVerticesFrom: dict.	].	"Now do the actual computation"	^super computeVertexNormals! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/15/1999 06:54'!detectNonSmoothVertices	"Detect all the vertices in the receiver that cannot be easily smoothed"	| mask face flag vtxIndex out newMask |	smoothFlags ifNil:[^#()].	mask _ WordArray new: vertices size.	mask atAllPut: 16rFFFFFFFF.	out _ Set new: 1000. "Leave us enough space to avoid collisions"	1 to: faces size do:[:i|		face _ faces at: i.		flag _ smoothFlags at: i.		1 to: 3 do:[:j|			vtxIndex _ face at: j.			newMask _ ((mask at: vtxIndex) bitAnd: flag).			newMask = 0 ifTrue:[out add: vtxIndex].			mask at: vtxIndex put: newMask.		].	].	^out! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/15/1999 06:49'!splitVerticesFrom: aDictionary	"Split the non smooth vertices from the Dictionary		vertex index -> Dictionary							smoothing group -> list of face indexes.	"	| newVertices newColors newTexCoords nextIndex vtxIndex nValues skipAssoc faceList iFace |	newVertices _ WriteStream with: vertices.	vtxColors ifNotNil:[newColors _ WriteStream with: vtxColors].	vtxTexCoords ifNotNil:[newTexCoords _ WriteStream with: vtxTexCoords].	nextIndex _ vertices size.	aDictionary associationsDo:[:vertexAssoc|		vtxIndex _ vertexAssoc key.		nValues _ vertexAssoc value size - 1.		"We have to copy n values"		newVertices next: nValues put: (vertices at: vtxIndex).		newColors ifNotNil:[newColors next: nValues put: (vtxColors at: vtxIndex)].		newTexCoords ifNotNil:[newTexCoords next: nValues put: (vtxTexCoords at: vtxIndex)].		skipAssoc _ true. "Skip the first association - we can reuse the original vertex"		vertexAssoc value associationsDo:[:smoothAssoc|			skipAssoc ifFalse:[				faceList _ smoothAssoc value.				nextIndex _ nextIndex + 1.				faceList do:[:faceIndex|					iFace _ faces at: faceIndex.					1 to: 3 do:[:i| (iFace at: i) = vtxIndex ifTrue:[iFace at: i put: nextIndex]].					faces at: faceIndex put: iFace.				].			].			skipAssoc _ false.		].	].	"Cleanup"	vtxNormals _ nil. "Must be recomputed"	vertices _ newVertices contents.	newColors ifNotNil:[vtxColors _ newColors contents].	newTexCoords ifNotNil:[vtxTexCoords _ newTexCoords contents].! !!B3DSTriangleMesh class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 21:26'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DScene methodsFor: 'initialize' stamp: 'ar 2/16/1999 04:25'!from3DS: aDictionary	| globals constants ambient texture |	"Remove the globals from the scene - the remaining objects are name->sceneObject"	globals _ aDictionary at: #globals.	constants _ globals at: #constants ifAbsent:[Dictionary new].	aDictionary removeKey: #globals.	"Collect the scene objects and assign the names"	objects _ OrderedCollection new.	aDictionary associationsDo:[:assoc| objects add: (assoc value name: assoc key)].	"Fetch the cameras and set a default camera"	cameras _ globals at: #cameras.	cameras isEmpty ifFalse:[defaultCamera _ cameras at: cameras keys asSortedCollection first].	"Fetch the lights"	lights _ globals at: #lights.	"Add the ambient light if possible.	Note: The name $AMBIENT$ is used in the keyframe section of the 3DS file."	ambient _ constants at: 'ambientColor' ifAbsent:[nil].	ambient ifNotNil:[lights at: '$AMBIENT$' put: (B3DAmbientLight color: ambient)].	"Fetch the materials and replace names in sceneObjects by actual materials"	materials _ globals at: #materials.	"Compute the per vertex normals"	'Computing vertex normals' displayProgressAt: Sensor cursorPoint		from: 0 to: objects size during:[:bar|			objects doWithIndex:[:obj :index|				bar value: index.				obj material ifNotNil:[obj material: (materials at: obj material ifAbsent:[nil])].				obj geometry vertexNormals]].	objects do:[:obj|		obj texture ifNotNil:[			texture _ B3DTexture fromDisplay: (Rectangle originFromUser: 128@128).			texture wrap: true.			texture interpolate: false.			texture envMode: 0.			obj texture: texture]].! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/15/1999 01:01'!boundingBox	|bBox|	box ifNotNil:[^box].	bBox _ nil.	objects do:[:obj|		bBox _ bBox ifNil:[obj boundingBox] ifNotNil:[bBox merge: obj boundingBox]	].	^box _ bBox! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/15/1999 05:29'!defaultCamera	^defaultCamera! !!B3DScene methodsFor: 'displaying' stamp: 'ar 2/16/1999 19:20'!render	| b3d |	b3d _ (B3DRenderEngine defaultForPlatformOn: Display) new.	b3d viewport: (0@0 extent: 600@600).	b3d clearViewport: Color white.	b3d clearDepthBuffer.	"b3d addLight: (B3DAmbientLight color: Color white)."	self renderOn: b3d.	b3d finish.	b3d destroy.! !!B3DScene methodsFor: 'displaying' stamp: 'ar 2/16/1999 05:58'!renderOn: aRenderer	defaultCamera ifNotNil:[		defaultCamera setClippingPlanesFrom: self.		defaultCamera aspectRatio: aRenderer viewport aspectRatio.		defaultCamera renderOn: aRenderer].	lights do:[:light| aRenderer addLight: light].	objects do:[:obj| obj renderOn: aRenderer].! !!B3DScene class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 23:59'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DSceneObject methodsFor: 'initialize' stamp: 'ar 2/16/1999 03:09'!from3DS: aDictionary	aDictionary isEmpty ifTrue:[^nil].	geometry _ B3DSTriangleMesh from3DS: aDictionary.	material _ (aDictionary at: #triList) last.! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/14/1999 22:37'!boundingBox	| bBox |	bBox _ geometry ifNotNil:[geometry boundingBox].	children ifNil:[^bBox].	children do:[:obj|		bBox _ bBox ifNil:[obj boundingBox] ifNotNil:[bBox merge: obj boundingBox]	].	^bBox! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:29'!geometry	^geometry! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:30'!geometry: aGeometry	geometry _ aGeometry.! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:30'!material	^material! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:10'!material: aMaterial	material _ aMaterial.	material class == Association ifTrue:[		texture _ material key.		material _ material value.	].! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:30'!matrix	^matrix! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:30'!matrix: aMatrix	matrix _ aMatrix! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:06'!name	^name! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:06'!name: aString	name _ aString.! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:01'!texture	^texture! !!B3DSceneObject methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:01'!texture: aTexture	texture _ aTexture! !!B3DSceneObject methodsFor: 'displaying' stamp: 'ar 2/16/1999 03:13'!renderOn: aRenderer	material ifNotNil:[		aRenderer pushMaterial.		aRenderer material: material].	texture ifNotNil:[		aRenderer pushTexture.		aRenderer texture: texture].	matrix ifNotNil:[		aRenderer pushMatrix.		aRenderer transformBy: matrix].	geometry ifNotNil:[geometry renderOn: aRenderer].	children ifNotNil:[children do:[:child| child renderOn: aRenderer]].	matrix ifNotNil:[aRenderer popMatrix].	texture ifNotNil:[aRenderer popTexture].	material ifNotNil:[aRenderer popMaterial].! !!B3DSceneObject methodsFor: 'printing' stamp: 'ar 2/8/1999 01:15'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$(;		print: self name;		nextPut: $).! !!B3DSceneObject class methodsFor: 'instance creation' stamp: 'ar 2/8/1999 01:06'!from3DS: aDictionary	^self new from3DS: aDictionary! !!B3DSceneObject class methodsFor: 'instance creation' stamp: 'ar 2/7/1999 20:06'!named: aString	^self new name: aString! !!B3DShaderPlugin methodsFor: 'primitives' stamp: 'ar 2/15/1999 22:30'!b3dShadeVertexBuffer	"Primitive. Shade all the vertices in the vertex buffer using the given array of primitive light sources."	| lightArray vtxCount vtxArray lightCount |	self export: true.	self inline: false.	self var: #vtxArray declareC:'float *vtxArray'.	vbFlags _ interpreterProxy stackIntegerValue: 0.	pMaterial _ self stackMaterialValue: 1.	lightArray _ self stackLightArrayValue: 2.	vtxCount _ interpreterProxy stackIntegerValue: 3.	vtxArray _ self stackPrimitiveVertexArray: 4 ofSize: vtxCount.	(vtxArray = nil or:[pMaterial = nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	"Setup"	litVertex _ vtxArray.	lightCount _ interpreterProxy slotSizeOf: lightArray.	"Go over all vertices"	1 to: vtxCount do:[:i|		"Load the primitive vertex"		self loadPrimitiveVertex.		"Load initial color (e.g., emissive part of vertex and/or material)"		(vbFlags anyMask: VBTrackEmission) ifTrue:[			"Load color from vertex"			pOutColor at: 0 put: (pInColor at: 0) + (pMaterial at: EmissionRed).			pOutColor at: 1 put: (pInColor at: 1) + (pMaterial at: EmissionGreen).			pOutColor at: 2 put: (pInColor at: 2) + (pMaterial at: EmissionBlue).			pOutColor at: 3 put: (pInColor at: 3) + (pMaterial at: EmissionAlpha).		] ifFalse:[			pOutColor at: 0 put: (pMaterial at: EmissionRed).			pOutColor at: 1 put: (pMaterial at: EmissionGreen).			pOutColor at: 2 put: (pMaterial at: EmissionBlue).			pOutColor at: 3 put: (pMaterial at: EmissionAlpha).		].		"For each enabled light source"		0 to: lightCount-1 do:[:j|			"Fetch the light source"			pLight _ self fetchLightSource: j ofObject: lightArray.			"Setup values"			self loadPrimitiveLightSource.			"Compute the color from the light source"			self shadeVertex.		].		"Store the computed color back"		self storePrimitiveVertex.		"And step on to the next vertex"		litVertex _ litVertex + PrimVertexSize.	].	"Clean up stack"	interpreterProxy pop: 5. "Leaves rcvr on stack"! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 22:59'!addPart: lightPart from: materialPart trackFlag: vbTrackFlag scale: scale	"Add the given light part to the output color, scaled by the given scale factor.	If the given flag is set in vbFlags then load the part from the primitive vertex"	| rPart gPart bPart aPart |	self var: #lightPart declareC:'float *lightPart'.	self var: #materialPart declareC:'float *materialPart'.	self var: #scale declareC:'double scale'.	self var: #rPart declareC:'double rPart'.	self var: #gPart declareC:'double gPart'.	self var: #bPart declareC:'double bPart'.	self var: #aPart declareC:'double aPart'.	self inline: true.	(vbFlags anyMask: vbTrackFlag) ifTrue:[		rPart _ (pInColor at: 0) * (lightPart at: 0) * scale.		gPart _ (pInColor at: 1) * (lightPart at: 1) * scale.		bPart _ (pInColor at: 2) * (lightPart at: 2) * scale.		aPart _ (pInColor at: 3) * (lightPart at: 3) * scale.	] ifFalse:[		"Note: This should be pre-computed."		rPart _ (materialPart at: 0) * (lightPart at: 0) * scale.		gPart _ (materialPart at: 1) * (lightPart at: 1) * scale.		bPart _ (materialPart at: 2) * (lightPart at: 2) * scale.		aPart _ (materialPart at: 3) * (lightPart at: 3) * scale.	].	pOutColor at: 0 put: (pOutColor at: 0) + rPart.	pOutColor at: 1 put: (pOutColor at: 1) + gPart.	pOutColor at: 2 put: (pOutColor at: 2) + bPart.	pOutColor at: 3 put: (pOutColor at: 3) + aPart.! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 04:33'!computeAttenuation	"Compute the attenuation for the current light and vertex"	pScale _ 1.0.	(lightFlags anyMask: FlagAttenuated) ifTrue:[		pScale _ 1.0 / ((pLight at: PrimLightAttenuationConstant) + 			(pDistance * ((pLight at: PrimLightAttenuationLinear) + 				(pDistance * (pLight at: PrimLightAttenuationSquared)))))].! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 23:32'!computeDirection	"Compute the direction for the current light and vertex"	| scale |	self inline: true.	self var: #scale declareC:'double scale'.	(lightFlags anyMask: FlagPositional) ifTrue:[		"Must compute the direction for this vertex"		pDirection at: 0 put: (litVertex at: PrimVtxPositionX) - (pLight at: PrimLightPositionX).		pDirection at: 1 put: (litVertex at: PrimVtxPositionY) - (pLight at: PrimLightPositionY).		pDirection at: 2 put: (litVertex at: PrimVtxPositionZ) - (pLight at: PrimLightPositionZ).		pDistance _ self dotProductOf: pDirection with: pDirection.		(pDistance = 0.0 or:[pDistance = 1.0]) 			ifFalse:[	pDistance _ pDistance sqrt.					scale _ -1.0/pDistance].		pDirection at: 0 put: (pDirection at: 0) * scale.		pDirection at: 1 put: (pDirection at: 1) * scale.		pDirection at: 2 put: (pDirection at: 2) * scale.	] ifFalse:[		(lightFlags anyMask: FlagDirectional) ifTrue:[			pDirection at: 0 put: (pLight at: PrimLightDirectionX).			pDirection at: 1 put: (pLight at: PrimLightDirectionY).			pDirection at: 2 put: (pLight at: PrimLightDirectionZ).		].	].! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 21:10'!computeSpecularDirection	"Computes		pSpecDir _ pSpecDir - vtx position safelyNormalized.	"	| scale |	self var: #scale declareC:'double scale'.	scale _ self inverseLengthOf: litVertex + PrimVtxPosition.	pSpecDir at: 0 put: (pSpecDir at: 0) - ((litVertex at: PrimVtxPositionX) * scale).	pSpecDir at: 1 put: (pSpecDir at: 1) - ((litVertex at: PrimVtxPositionY) * scale).	pSpecDir at: 2 put: (pSpecDir at: 2) - ((litVertex at: PrimVtxPositionZ) * scale).! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 21:38'!computeSpotFactor	"Compute the spot factor for a spot light"	| cosAngle minCos deltaCos |	self returnTypeC:'double'.	self var: #cosAngle declareC:'double cosAngle'.	self var: #minCos declareC:'double minCos'.	self var: #deltaCos declareC:'double deltaCos'.	"Compute cos angle between direction of the spot light and direction to vertex"	cosAngle _ self dotProductOf: pLight + PrimLightDirection with: pDirection.	cosAngle _ 0.0 - cosAngle.	minCos _ pLight at: SpotLightMinCos.	cosAngle < minCos ifTrue:[^0.0].	deltaCos _ pLight at: SpotLightDeltaCos.	deltaCos <= 0.00001 ifTrue:[		"No delta -- a sharp boundary between on and off.		Since off has already been determined above, we are on"		^1.0].	"Scale the angle to 0/1 range"	cosAngle _ (cosAngle - minCos) / deltaCos.	^cosAngle raisedTo: (pLight at: SpotLightExponent)! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 21:18'!dotProductOf: v1 with: v2	self var: #v1 declareC:'float * v1'.	self var: #v2 declareC:'float *v2'.	self returnTypeC:'double'.	^((v1 at: 0) * (v2 at: 0)) +		((v1 at: 1) * (v2 at: 1)) +			((v1 at: 2) * (v2 at: 2)).! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/15/1999 21:08'!inverseLengthOf: aVector	| scale |	self returnTypeC:'double'.	self var: #aVector declareC:'float * aVector'.	self var: #scale declareC:'double scale'.	scale _ self dotProductOf: aVector with: aVector.	(scale = 0.0 or:[scale = 1.0]) ifTrue:[^scale].	^1.0 / scale sqrt! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/16/1999 01:28'!shadeVertex	| cosAngle specularFactor |	self var: #cosAngle declareC:'double cosAngle'.	self var: #specularFactor declareC:'double specularFactor'.	self computeDirection.	self computeAttenuation.	(lightFlags anyMask: FlagHasSpot) ifTrue:[		pScale _ pScale * self computeSpotFactor.	].	"Compute ambient and diffuse part only if pScale is non-zero."	(pScale > 0.001) ifTrue:[		"Compute the ambient part"		(lightFlags anyMask: FlagAmbientPart) ifTrue:[			self addPart: (pLight + AmbientPart) 				from: pMaterial + AmbientPart 				trackFlag: VBTrackAmbient 				scale: pScale.		].		"Compute the diffuse part"		(lightFlags anyMask: FlagDiffusePart) ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ self dotProductOf: (litVertex + PrimVtxNormal) with: pDirection.			"For one-sided lighting negate cosAngle if necessary"			((vbFlags bitAnd: VBTwoSidedLighting) = 0 and:[cosAngle < 0.0])				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				self addPart: pLight + DiffusePart 					from: pMaterial + DiffusePart 					trackFlag: VBTrackDiffuse 					scale: pScale * cosAngle.			].		].	]. "pScale > 0.001"	"Compute the specular part"	((lightFlags anyMask: FlagSpecularPart) and:[		(pMaterial at: MaterialShininess) > 0.0]) ifTrue:[		"Compute specular part"		pSpecDir at: 0 put: (pDirection at: 0).		pSpecDir at: 1 put: (pDirection at: 1).		pSpecDir at: 2 put: (pDirection at: 2).		(vbFlags anyMask: VBUseLocalViewer) 			ifTrue:[self computeSpecularDirection]			ifFalse:[pSpecDir at: 2 put: (pSpecDir at: 2) - 1.0].		cosAngle _ self dotProductOf: (litVertex + PrimVtxNormal) with: pSpecDir.		cosAngle > 0.0 ifTrue:[			"Normalize the angle"			cosAngle _ cosAngle * (self inverseLengthOf: pSpecDir).			"cosAngle should be somewhere between 0 and 1.			If not, then the vertex normal was not normalized"			cosAngle > 1.0 ifTrue:[				specularFactor _ cosAngle raisedTo: (pMaterial at: MaterialShininess).			] ifFalse:[				cosAngle = 0.0 					ifTrue:[specularFactor _ 1.0]					ifFalse:[specularFactor _ cosAngle raisedTo: (pMaterial at: MaterialShininess)].			].			self addPart: pLight + SpecularPart 				from: pMaterial + SpecularPart 				trackFlag: VBTrackSpecular 				scale: specularFactor.		].	].! !!B3DShaderPlugin methodsFor: 'primitive support' stamp: 'ar 2/15/1999 22:33'!fetchLightSource: index ofObject: anArray	"Fetch the primitive light source from the given array.	Note: No checks are done within here - that happened in stackLightArrayValue:"	| lightOop |	self inline: true.	self returnTypeC:'void*'.	lightOop _ interpreterProxy fetchPointer: index ofObject: anArray.	^interpreterProxy firstIndexableField: lightOop! !!B3DShaderPlugin methodsFor: 'primitive support' stamp: 'ar 2/15/1999 22:29'!stackLightArrayValue: stackIndex	"Load an Array of B3DPrimitiveLights from the given stack index"	| oop array arraySize |	self inline: false.	array _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: array) = interpreterProxy classArray		ifFalse:[^interpreterProxy primitiveFail].	arraySize _ interpreterProxy slotSizeOf: array.	0 to: arraySize-1 do:[:i|		oop _ interpreterProxy fetchPointer: i ofObject: array.		(interpreterProxy isIntegerObject: oop)			ifTrue:[^interpreterProxy primitiveFail].		((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = PrimLightSize])			ifFalse:[^interpreterProxy primitiveFail].	].	^array! !!B3DShaderPlugin methodsFor: 'primitive support' stamp: 'ar 2/15/1999 19:22'!stackMaterialValue: stackIndex	"Load a B3DMaterial from the given stack index"	| oop |	self inline: false.	self returnTypeC:'void *'.	oop _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = MaterialSize])		ifTrue:[^interpreterProxy firstIndexableField: oop].	^nil! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/15/1999 21:07'!loadPrimitiveLightSource	self inline: true.	lightFlags _ (self cCoerce: pLight to: 'int*') at: PrimLightFlags.! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/15/1999 21:33'!loadPrimitiveVertex	"Load the necessary values from the current primitive vertex"	| rgba |	self inline: true.	rgba _ (self cCoerce: litVertex to:'int*') at: PrimVtxColor32.	pInColor at: 2 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	pInColor at: 1 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	pInColor at: 0 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	pInColor at: 3 put: (rgba bitAnd: 255) * (1.0 / 255.0).! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/15/1999 23:03'!storePrimitiveVertex	"Store the computed output color back into the current primitive vertex.	Clamp the r,g,b,a part to be in the range 0-255."	| r g b a |	self inline: true.	r _ ((pOutColor at: 0) * 255) asInteger.	r _ (r min: 255) max: 0.	g _ ((pOutColor at: 1) * 255) asInteger.	g _ (g min: 255) max: 0.	b _ ((pOutColor at: 2) * 255) asInteger.	b _ (b min: 255) max: 0.	a _ ((pOutColor at: 3) * 255) asInteger.	a _ (a min: 255) max: 0.	"The following is equal to b + (g << 8) + (r << 16) + (a << 24)"	(self cCoerce: litVertex to:'int*') 		at: PrimVtxColor32 put: b + (g + (r + (a << 8) << 8) << 8). ! !!B3DShaderPlugin class methodsFor: 'translation' stamp: 'ar 2/15/1999 22:38'!declareCVarsIn: cg	cg var: 'litVertex' declareC:'float *litVertex'.	cg var: 'pLight' declareC:'float *pLight'.	cg var: 'pMaterial' declareC:'float *pMaterial'.	cg var: 'pDirection' declareC:'float pDirection[3]'.	cg var: 'pSpecDir' declareC:'float pSpecDir[3]'.	cg var: 'pInColor' declareC:'float pInColor[4]'.	cg var: 'pOutColor' declareC:'float pOutColor[4]'.	cg var: 'pDistance' declareC:'double pDistance'.	cg var: 'pScale' declareC:'double pScale'.! !!B3DSpotLight methodsFor: 'initialize' stamp: 'ar 2/7/1999 18:44'!from3DS: aDictionary	"Initialize the receiver from a 3DS point light"	| spotValues hotSpot fallOff |	super from3DS: aDictionary.	spotValues _ aDictionary at: #spot.	target _ spotValues at: #target.	hotSpot _ spotValues at: #hotspotAngle.	self minAngle: hotSpot.	fallOff _ spotValues at: #falloffAngle.	self maxAngle: hotSpot + fallOff.! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:18'!direction	^direction ifNil:[direction _ (target - position) safelyNormalize].! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/8/1999 01:40'!direction: aVector	direction _ aVector! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:47'!hotSpotDeltaCosine	^deltaCos! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:45'!hotSpotMaxCosine	^maxCos! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:45'!hotSpotMinCosine	^minCos! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:46'!maxAngle	^maxCos arcCos radiansToDegrees! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:25'!maxAngle: angle	minCos _ angle degreesToRadians cos.	maxCos ifNotNil:[deltaCos _ maxCos - minCos].! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 18:46'!minAngle	^minCos arcCos radiansToDegrees! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:25'!minAngle: angle	maxCos _ angle degreesToRadians cos.	minCos ifNotNil:[deltaCos _ maxCos - minCos].! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:16'!target	^target! !!B3DSpotLight methodsFor: 'accessing' stamp: 'ar 2/7/1999 20:16'!target: aVector	target _ aVector! !!B3DSpotLight methodsFor: 'testing' stamp: 'ar 2/15/1999 02:18'!hasSpot	^true! !!B3DSpotLight methodsFor: 'converting' stamp: 'ar 2/15/1999 22:01'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight |	primLight _ super asPrimitiveLight.	primLight flags: (primLight flags bitOr: FlagHasSpot).	primLight spotMinCos: minCos.	primLight spotMaxCos: maxCos.	primLight spotDeltaCos: deltaCos.	primLight spotExponent: self spotExponent.	primLight direction: (target - position) safelyNormalize.	^primLight! !!B3DSpotLight methodsFor: 'converting' stamp: 'ar 2/8/1999 01:39'!transformedBy: aTransformer	^(super transformedBy: aTransformer) 		target: (aTransformer transformPosition: target);		direction: nil! !!B3DTexture commentStamp: 'ar 2/16/1999 03:46' prior: 0!I represent a simple 2D texture.Instance variables:	wrap		<Boolean>	If true, wrap the texture - otherwise clamp it.	interpolate	<Boolean>	If true, interpolate the pixels of the texture.	envMode	<Integer>	How we combine colors with the texture.		Possible values:			0 - OpenGL style modulate texture			1 - OpenGL style decal texture!!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:36'!envMode	^envMode! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:36'!envMode: aNumber	envMode _ aNumber.! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:33'!interpolate	^interpolate! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:34'!interpolate: aBool	interpolate _ aBool! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:34'!wrap	^wrap! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:33'!wrap: aBool	wrap _ aBool! !!B3DTexture2Array methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:30'!at: index put: value	value isPoint		ifTrue:[super at: index put: (B3DVector2 u: value x v: value y)]		ifFalse:[super at: index put: value].	^value! !!B3DTexture2Array class methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:31'!contentsClass	^B3DVector2! !!B3DTransformerPlugin reorganize!('primitives' b3dTransformMatrixWithInto b3dTransformPrimitiveNormal b3dTransformPrimitivePosition b3dTransformPrimitiveRasterPosition b3dTransformVertexBuffer)('transforming' analyzeMatrix3x3Length: analyzeMatrix: transformMatrix:with:into: transformPrimitiveNormal:by:rescale: transformPrimitivePosition:by: transformPrimitivePositionFast:by: transformPrimitivePositionFaster:by: transformPrimitiveRasterPosition:by: transformVB:count:by:and:flags:)!!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 00:02'!b3dTransformMatrixWithInto	"Transform two matrices into the third"	| m1 m2 m3 |	self export: true.	self inline: false.	self var: #m1 declareC:'float *m1'.	self var: #m2 declareC:'float *m2'.	self var: #m3 declareC:'float *m3'.	m3 _ self stackMatrix: 0.	m2 _ self stackMatrix: 1.	m1 _ self stackMatrix: 2.	(m1 = nil) | (m2 = nil) | (m3 = nil) 		ifTrue:[^interpreterProxy primitiveFail].	m2 == m3 ifTrue:[^interpreterProxy primitiveFail].	self transformMatrix: m1 with: m2 into: m3.	interpreterProxy pop: 3. "Leave rcvr on stack"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 00:03'!b3dTransformPrimitiveNormal	"Transform the normal of the given primitive vertex using the argument matrix and rescale the normal if necessary."	| pVertex matrix rescale |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #pVertex declareC:'float *pVertex'.	rescale _ interpreterProxy stackValue: 0.	rescale == interpreterProxy nilObject 		ifFalse:[rescale _ interpreterProxy booleanValueOf: rescale].	matrix _ self stackMatrix: 1.	pVertex _ self stackPrimitiveVertex: 2.	(matrix = nil) | (pVertex = nil) 		ifTrue:[^interpreterProxy primitiveFail].	(rescale ~~ true and:[rescale ~~ false])		ifTrue:[rescale _ self analyzeMatrix3x3Length: matrix].	self transformPrimitiveNormal: pVertex by: matrix rescale: rescale.	interpreterProxy pop: 3. "Leave rcvr on stack"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 00:03'!b3dTransformPrimitivePosition	"Transform the position of the given primitive vertex the given matrix	and store the result back inplace."	| pVertex matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #pVertex declareC:'float *pVertex'.	matrix _ self stackMatrix: 0.	pVertex _ self stackPrimitiveVertex: 1.	(matrix = nil) | (pVertex = nil) 		ifTrue:[^interpreterProxy primitiveFail].	self transformPrimitivePosition: pVertex by: matrix.	interpreterProxy pop: 2. "Leave rcvr on stack"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 00:03'!b3dTransformPrimitiveRasterPosition	"Transform the position of the given primitive vertex the given matrix	and store the result in homogenous coordinates at rasterPos."	| pVertex matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #pVertex declareC:'float *pVertex'.	matrix _ self stackMatrix: 0.	pVertex _ self stackPrimitiveVertex: 1.	(matrix = nil) | (pVertex = nil) 		ifTrue:[^interpreterProxy primitiveFail].	self transformPrimitiveRasterPosition: pVertex by: matrix.	interpreterProxy pop: 2. "Leave rcvr on stack"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 00:05'!b3dTransformVertexBuffer	"Transform an entire vertex buffer using the supplied modelview and projection matrix."	| flags projectionMatrix modelViewMatrix vtxCount vtxArray |	self export: true.	self inline: false.	self var: #projectionMatrix declareC:'float *projectionMatrix'.	self var: #modelViewMatrix declareC:'float *modelViewMatrix'.	self var: #vtxArray declareC:'float *vtxArray'.	flags _ interpreterProxy stackIntegerValue: 0.	projectionMatrix _ self stackMatrix: 1.	modelViewMatrix _ self stackMatrix: 2.	vtxCount _ interpreterProxy stackIntegerValue: 3.	vtxArray _ self stackPrimitiveVertexArray: 4 ofSize: vtxCount.	(projectionMatrix = nil) | (modelViewMatrix = nil) | (vtxArray = nil)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self transformVB: vtxArray 		count: vtxCount 		by: modelViewMatrix 		and: projectionMatrix 		flags: flags.	interpreterProxy pop: 5. "Leave rcvr on stack"! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:45'!analyzeMatrix3x3Length: m	"Check if the matrix scales normals to non-unit length."	| det |	self var: #m declareC:'float *m'.	self var: #det declareC:'double det'.	det _ 	((m at: 0) * (m at: 5) * (m at: 10)) -			((m at: 2) * (m at: 5) * (m at: 8)) + 			((m at: 4) * (m at: 9) * (m at: 2)) - 			((m at: 6) * (m at: 9) * (m at: 0)) +			((m at: 8) * (m at: 1) * (m at: 6)) -			((m at: 10) * (m at: 1) * (m at: 4)).	^det < 0.99 or:[det > 1.01]! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:45'!analyzeMatrix: m	"Analyze the matrix and return the appropriate flags"	| flags |	self var: #m declareC:'float *m'.	"Check the perspective"	flags _ 0.	((m at: 12) = 0.0 and:[(m at: 13) = 0.0 and:[(m at: 14) = 0.0 and:[(m at: 15) = 1.0]]]) ifTrue:[		flags _ flags bitOr: FlagM44NoPerspective.		"Check translation"		((m at: 3) = 0.0 and:[(m at: 7) = 0.0 and:[(m at: 11) = 0.0]]) ifTrue:[			flags _ flags bitOr: FlagM44NoTranslation.			"Check for identity"			((m at: 0) = 1.0 and:[(m at: 5) = 1.0 and:[(m at: 10) = 1.0 and:[				(m at: 1) = 0.0 and:[(m at: 2) = 0.0 and:[				(m at: 4) = 0.0 and:[(m at: 6) = 0.0 and:[				(m at: 8) = 0.0 and:[(m at: 9) = 0.0]]]]]]]]) ifTrue:[					flags _ flags bitOr: FlagM44Identity.			].		].	].	^flags! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:45'!transformMatrix: src with: arg into: dst	"Transform src with arg into dst.	It is allowed that src == dst but not arg == dst"	| m1 m2 m3 c1 c2 c3 c4 |	self var: #src declareC:'float *src'.	self var: #arg declareC:'float *arg'.	self var: #dst declareC:'float *dst'.	self var: #m1 declareC:'float *m1'.	self var: #m2 declareC:'float *m2'.	self var: #m3 declareC:'float *m3'.	self var: #c1 declareC:'float c1'.	self var: #c2 declareC:'float c2'.	self var: #c3 declareC:'float c3'.	self var: #c4 declareC:'float c4'.	m1 _ self cCoerce: src to:'float *'.	m2 _ self cCoerce: arg to: 'float *'.	m3 _ self cCoerce: dst to: 'float *'.	0 to: 3 do:[:i|		"Compute next row"		c1 _ ((m1 at: 0) * (m2 at: 0)) + ((m1 at: 1) * (m2 at: 4)) +				((m1 at: 2) * (m2 at: 8)) + ((m1 at: 3) * (m2 at: 12)).		c2 _ ((m1 at: 0) * (m2 at: 1)) + ((m1 at: 1) * (m2 at: 5)) +				((m1 at: 2) * (m2 at: 9)) + ((m1 at: 3) * (m2 at: 13)).		c3 _ ((m1 at: 0) * (m2 at: 2)) + ((m1 at: 1) * (m2 at: 6)) +				((m1 at: 2) * (m2 at: 10)) + ((m1 at: 3) * (m2 at: 14)).		c4 _ ((m1 at: 0) * (m2 at: 3)) + ((m1 at: 1) * (m2 at: 7)) +				((m1 at: 2) * (m2 at: 11)) + ((m1 at: 3) * (m2 at: 15)).		"Store result"		m3 at: 0 put: c1.		m3 at: 1 put: c2.		m3 at: 2 put: c3.		m3 at: 3 put: c4.		"Skip src and dst to next row"		m1 _ m1 + 4.		m3 _ m3 + 4.	].! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:45'!transformPrimitiveNormal: pVertex by: matrix rescale: rescale	"Transform the normal of the given primitive vertex"	| x y z rx ry rz dot |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'float x'.	self var: #y declareC:'float y'.	self var: #z declareC:'float z'.	self var: #rx declareC:'float rx'.	self var: #ry declareC:'float ry'.	self var: #rz declareC:'float rz'.	self var: #dot declareC:'double dot'.	x _ pVertex at: PrimVtxNormalX.	y _ pVertex at: PrimVtxNormalY.	z _ pVertex at: PrimVtxNormalZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)).	rescale ifTrue:[		dot _ (rx * rx) + (ry * ry) + (rz * rz).		dot < 1.0e-20 			ifTrue:[rx _ ry _ rz _ 0.0]			ifFalse:[dot = 1.0 ifFalse:[dot _ 1.0 / dot sqrt.									rx _ rx * dot. ry _ ry * dot. rz _ rz * dot]]].	pVertex at: PrimVtxNormalX put: rx.	pVertex at: PrimVtxNormalY put: ry.	pVertex at: PrimVtxNormalZ put: rz.! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:46'!transformPrimitivePosition: pVertex by: matrix	"Transform the normal of the given primitive vertex"	| x y z rx ry rz rw |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'float x'.	self var: #y declareC:'float y'.	self var: #z declareC:'float z'.	self var: #rx declareC:'float rx'.	self var: #ry declareC:'float ry'.	self var: #rz declareC:'float rz'.	self var: #rw declareC:'double rw'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	rw _ (x * (matrix at: 12)) + (y * (matrix at: 13)) + (z * (matrix at: 14)) + (matrix at: 15).	rw = 1.0 ifTrue:[		pVertex at: PrimVtxPositionX put: rx.		pVertex at: PrimVtxPositionY put: ry.		pVertex at: PrimVtxPositionZ put: rz.	] ifFalse:[		rw = 0.0 			ifTrue:[rw _ 0.0]			ifFalse:[rw _ 1.0 / rw].		pVertex at: PrimVtxPositionX put: rx*rw.		pVertex at: PrimVtxPositionY put: ry*rw.		pVertex at: PrimVtxPositionZ put: rz*rw.	].! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:46'!transformPrimitivePositionFast: pVertex by: matrix	"Transform the position of the given primitive vertex assuming that 	matrix a41 = a42 = a43 = 0.0 and a44 = 1.0"	| x y z rx ry rz |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'float x'.	self var: #y declareC:'float y'.	self var: #z declareC:'float z'.	self var: #rx declareC:'float rx'.	self var: #ry declareC:'float ry'.	self var: #rz declareC:'float rz'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	pVertex at: PrimVtxPositionX put: rx.	pVertex at: PrimVtxPositionY put: ry.	pVertex at: PrimVtxPositionZ put: rz.! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:46'!transformPrimitivePositionFaster: pVertex by: matrix	"Transform the position of the given primitive vertex assuming that 	matrix a14 = a24 = a34 = a41 = a42 = a43 = 0.0 and a44 = 1.0"	| x y z rx ry rz |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'float x'.	self var: #y declareC:'float y'.	self var: #z declareC:'float z'.	self var: #rx declareC:'float rx'.	self var: #ry declareC:'float ry'.	self var: #rz declareC:'float rz'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)).	pVertex at: PrimVtxPositionX put: rx.	pVertex at: PrimVtxPositionY put: ry.	pVertex at: PrimVtxPositionZ put: rz.! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:46'!transformPrimitiveRasterPosition: pVertex by: matrix	"Transform the normal of the given primitive vertex"	| x y z rx ry rz rw |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'float x'.	self var: #y declareC:'float y'.	self var: #z declareC:'float z'.	self var: #rx declareC:'float rx'.	self var: #ry declareC:'float ry'.	self var: #rz declareC:'float rz'.	self var: #rw declareC:'float rw'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	rw _ (x * (matrix at: 12)) + (y * (matrix at: 13)) + (z * (matrix at: 14)) + (matrix at: 15).	pVertex at: PrimVtxRasterPosX put: rx.	pVertex at: PrimVtxRasterPosY put: ry.	pVertex at: PrimVtxRasterPosZ put: rz.	pVertex at: PrimVtxRasterPosW put: rw.! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 2/13/1999 23:47'!transformVB: vtxArray count: vtxCount by: modelViewMatrix and: projectionMatrix flags: flags	"Transform the entire vertex array by the given matrices"	"TODO: Check the actual trade-offs between vtxCount and analyzing"	| mvFlags prFlags pVertex hasNormals rescale |	self var: #projectionMatrix declareC:'float *projectionMatrix'.	self var: #modelViewMatrix declareC:'float *modelViewMatrix'.	self var: #vtxArray declareC:'float *vtxArray'.	self var: #pVertex declareC:'float *pVertex'.	"Analyze the matrices for better performance"	mvFlags _ self analyzeMatrix: modelViewMatrix.	prFlags _ self analyzeMatrix: projectionMatrix.	pVertex _ self cCoerce: vtxArray to: 'float *'.	hasNormals _ flags anyMask: VBVtxHasNormals.	"Check if we have to rescale the normals"	hasNormals ifTrue:[		(mvFlags anyMask: FlagM44Identity)			ifTrue:[rescale _ false]			ifFalse:[rescale _ self analyzeMatrix3x3Length: modelViewMatrix]].	"<---- NOTE: The most likely case goes first ---->"	((mvFlags anyMask: FlagM44NoPerspective) and:[prFlags = 0]) ifTrue:[		"Modelview matrix has no perspective part and projection is not optimized"		(mvFlags = FlagM44NoTranslation) = 0 ifTrue:[			"Modelview matrix with translation"			1 to: vtxCount do:[:i|				hasNormals ifTrue:[self transformPrimitiveNormal: pVertex by: modelViewMatrix rescale: rescale].				self transformPrimitivePositionFast: pVertex by: modelViewMatrix.				self transformPrimitiveRasterPosition: pVertex by: projectionMatrix.				pVertex _ pVertex + PrimVertexSize].		] ifFalse:[			"Modelview matrix without translation"			1 to: vtxCount do:[:i|				hasNormals ifTrue:[self transformPrimitiveNormal: pVertex by: modelViewMatrix rescale: rescale].				self transformPrimitivePositionFaster: pVertex by: modelViewMatrix.				self transformPrimitiveRasterPosition: pVertex by: projectionMatrix.				pVertex _ pVertex + PrimVertexSize].		].		^nil]. "done"	"<---- End of most likely case ---->"	((mvFlags bitAnd: prFlags) anyMask: FlagM44Identity) ifTrue:[		"If both are identity matrices just copy entries"		1 to: vtxCount do:[:i|			pVertex at: PrimVtxRasterPosX put: (pVertex at: PrimVtxPositionX).			pVertex at: PrimVtxRasterPosY put: (pVertex at: PrimVtxPositionY).			pVertex at: PrimVtxRasterPosZ put: (pVertex at: PrimVtxPositionZ).			pVertex at: PrimVtxRasterPosW put: 1.0.			pVertex _ pVertex + PrimVertexSize].		^nil]."done"	(mvFlags anyMask: FlagM44Identity) ifTrue:[		"If model view matrix is identity just perform projection"		1 to: vtxCount do:[:i|			self transformPrimitiveRasterPosition: pVertex by: projectionMatrix.			pVertex _ pVertex + PrimVertexSize].		^nil]. "done"	"<--- modelview matrix not identity --->"	(prFlags anyMask: FlagM44Identity) ifTrue:[		"If projection matrix is identity just transform and copy.		Note: This case is not very likely so it's not been unrolled."		1 to: vtxCount do:[:i|			hasNormals ifTrue:[self transformPrimitiveNormal: pVertex by: modelViewMatrix rescale: rescale].			mvFlags = (FlagM44NoPerspective + FlagM44NoPerspective) ifTrue:[				self transformPrimitivePositionFaster: pVertex by: modelViewMatrix.			] ifFalse:[mvFlags = FlagM44NoPerspective ifTrue:[				self transformPrimitivePositionFast: pVertex by: modelViewMatrix.			] ifFalse:[				self transformPrimitivePosition: pVertex by: modelViewMatrix.			]].			pVertex at: PrimVtxRasterPosX put: (pVertex at: PrimVtxPositionX).			pVertex at: PrimVtxRasterPosY put: (pVertex at: PrimVtxPositionY).			pVertex at: PrimVtxRasterPosZ put: (pVertex at: PrimVtxPositionZ).			pVertex at: PrimVtxRasterPosW put: 1.0.			pVertex _ pVertex + PrimVertexSize].		^nil]. "done"	"<----- None of the matrices is identity ---->"	"Generic transformation"	1 to: vtxCount do:[:i|		hasNormals ifTrue:[self transformPrimitiveNormal: pVertex by: modelViewMatrix rescale: rescale].		self transformPrimitivePosition: pVertex by: modelViewMatrix.		self transformPrimitiveRasterPosition: pVertex by: projectionMatrix.		pVertex _ pVertex + PrimVertexSize].! !!B3DVector2 commentStamp: 'ar 2/13/1999 20:03' prior: 0!I represent simple 2D coordinates in the Balloon 3D framework. I may be used to represent both, 2D points and 2D texture coordinates. !!B3DVector2 methodsFor: 'initialize' stamp: 'ar 2/6/1999 23:30'!u: uValue v: vValue	self u: uValue.	self v: vValue.! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:26'!u	^self floatAt: 1! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:27'!u: aFloat	self floatAt: 1 put: aFloat! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:27'!v	^self floatAt: 2! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/6/1999 23:27'!v: aFloat	self floatAt: 2 put: aFloat! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:58'!x	^self at: 1! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:58'!y	^self at: 2! !!B3DVector2 methodsFor: 'converting' stamp: 'ar 2/13/1999 20:03'!asPoint	^self x @ self y! !!B3DVector2 class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 23:31'!numElements	^2! !!B3DVector2 class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 23:31'!u: uValue v: vValue	^self new u: uValue v: vValue! !!B3DVector3 commentStamp: 'ar 2/13/1999 20:04' prior: 0!I represent simple 3D coordinates, used throughout the entire Balloon 3D engine.!!B3DVector3 methodsFor: 'vector functions' stamp: 'ar 2/6/1999 00:32'!max: aVector	^B3DVector3 		x: (self x max: aVector x)		y: (self y max: aVector y)		z: (self z max: aVector z)! !!B3DVector3 methodsFor: 'vector functions' stamp: 'ar 2/6/1999 00:31'!min: aVector	^B3DVector3 		x: (self x min: aVector x)		y: (self y min: aVector y)		z: (self z min: aVector z)! !!B3DVector3 methodsFor: 'vector functions' stamp: 'ar 2/7/1999 00:43'!safelyNormalize	"Safely normalize the receiver, e.g. check if the length is non-zero"	| length |	length _ self length.	length = 1.0 ifTrue:[^self].	length = 0.0 ifFalse:[self /= length].! !!B3DVector3 methodsFor: 'converting' stamp: 'ar 2/6/1999 00:06'!asB3DVector3	^self! !!B3DVector3 methodsFor: 'converting' stamp: 'ar 2/6/1999 00:07'!asB3DVector4	^B3DVector4 x: self x y: self y z: self z w: 1.0! !!B3DVector3 class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 02:56'!value: aFloat	^self x: aFloat y: aFloat z: aFloat! !!B3DVector3Array class methodsFor: 'instance creation' stamp: 'ar 2/5/1999 22:51'!contentsClass	^B3DVector3! !!B3DVector4 commentStamp: 'ar 2/13/1999 20:05' prior: 0!I represent 3D points in homogenous coordinates.!!B3DVector4 methodsFor: 'converting' stamp: 'ar 2/6/1999 00:08'!asB3DVector3	| wValue |	wValue _ self w.	wValue = 0.0 ifTrue:[^B3DVector3 zero].	^B3DVector3 x: self x / wValue y: self y / wValue z: self z / wValue! !!B3DVector4 methodsFor: 'converting' stamp: 'ar 2/6/1999 00:07'!asB3DVector4	^self! !!B3DVertexBuffer commentStamp: 'ar 2/13/1999 20:26' prior: 0!I represent the vertex buffer passed on throughout the entire Balloon 3D rendering pipeline. I store all information that may be needed by either part of the pipeline.Instance variables:	current 		<B3DPrimitiveVertex>	Tracking the current attributes of vertices	vertexArray 	<B3DPrimitiveVertexArray>	Container for all primitive vertices	vertexCount 	<Integer>	The number of vertices in the vertex array	indexArray 		<WordArray>	Stores the indexes for indexed primitives	indexCount 		<Integer>	Number of indexes in the index array	primitive 		<Integer>	The type of primitive currently in the buffer	clipFlags 		<Integer>	The clip mask of the vertices in the buffer	flags			<Integer>	Various state flags !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:44'!clipFlags	^clipFlags! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:44'!clipFlags: aNumber	clipFlags _ aNumber! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/8/1999 17:39'!flags	^flags! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/8/1999 17:40'!flags: newFlags	"Note: should be used with CARE!!"	flags _ newFlags! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:13'!indexArray	^indexArray! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:13'!indexArray: aWordArray	indexArray _ aWordArray! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:13'!indexCount	^indexCount! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/7/1999 02:14'!indexCount: aNumber	indexCount _ aNumber! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:48'!primitive	^primitive! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:49'!primitive: aNumber	primitive _ aNumber.! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:44'!vertexArray: aB3DVertexArray	vertexArray _ aB3DVertexArray! !!B3DVertexBuffer methodsFor: 'accessing' stamp: 'ar 2/5/1999 18:44'!vertexCount: aNumber	vertexCount _ aNumber! !!B3DVertexBuffer methodsFor: 'initialize' stamp: 'ar 2/13/1999 20:24'!initialize	vertexArray _ B3DPrimitiveVertexArray new: 100.	vertexCount _ 0.	indexArray _ WordArray new: 100.	indexCount _ 0.	current _ B3DPrimitiveVertex new.	flags _ 0.	primitive _ nil.! !!B3DVertexBuffer methodsFor: 'initialize' stamp: 'ar 2/13/1999 20:24'!reset	vertexCount _ 0.	indexCount _ 0.! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:32'!hasVertexNormals	^flags anyMask: VBVtxHasNormals! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:32'!hasVertexTexCoords	^flags anyMask: VBVtxHasTexCoords! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:32'!trackAmbientColor	"Return true if the vertex colors override the ambient part of material entries."	^flags anyMask: VBTrackAmbient! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:32'!trackDiffuseColor	"Return true if the vertex colors override the diffuse part of material entries."	^flags anyMask: VBTrackDiffuse! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:32'!trackEmissionColor	"Return true if the vertex colors override the emissive part of material entries."	^flags anyMask: VBTrackEmission! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:33'!trackSpecularColor	"Return true if the vertex colors override the specular part of material entries."	^flags anyMask: VBTrackSpecular! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:35'!twoSidedLighting	"Return true if we shade front and back facing polygons differently"	^flags anyMask: VBTwoSidedLighting! !!B3DVertexBuffer methodsFor: 'testing' stamp: 'ar 2/8/1999 17:35'!useLocalViewer	^flags anyMask: VBUseLocalViewer! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/15/1999 00:09'!loadIndexed: idxArray vertices: vertices normals: normals colors: colors texCoords: texCoords	| vtxSize idxSize maxVtx maxIdx |	"Check the size of the vertex array"	vtxSize _ vertices size.		vertexCount + vtxSize >= vertexArray size ifTrue:[		self growVertexArray: (vtxSize + vertexArray size + 100).	].	"Check the size of the index array"	idxSize _ idxArray basicSize.	indexCount + idxSize >= indexArray size ifTrue:[		self growIndexArray: (idxSize + indexArray size + 100).	].	"Check the sizes of normals, colors, and texCoords"	(normals notNil and:[vtxSize ~= normals size]) ifTrue:[^self errorSizeMismatch].	(colors notNil and:[vtxSize ~= colors size]) ifTrue:[^self errorSizeMismatch].	(texCoords notNil and:[vtxSize ~= texCoords size]) ifTrue:[^self errorSizeMismatch].	"Turn off the appropriate flags if no attributes are given.	Default to having vertex normals and texture coords."	flags _ flags bitOr: (VBVtxHasNormals + VBVtxHasTexCoords).	"Turn off tracking flags if no colors are given"	colors ifNil:[flags _ flags bitAnd: VBNoTrackMask].	normals ifNil:[flags _ flags bitAnd: VBVtxHasNormals bitInvert32].	texCoords ifNil:[flags _ flags bitAnd: VBVtxHasTexCoords bitInvert32].	"Load the vertices"	maxVtx _ self primLoadVB: vertexArray					startingAt: vertexCount					vertices: vertices 					normals: normals 					colors: colors 					texCoords: texCoords 					count: vtxSize					default: current.	"Load the indexes"	maxIdx _ self 				primLoadIndexArrayInto: indexArray 				startingAt: indexCount 				from: idxArray 				count: idxSize 				max: maxVtx 				offset: vertexCount.	"Adjust the size of the vertex array and the index array"	vertexCount _ vertexCount + maxVtx.	indexCount _ indexCount + maxIdx.! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/8/1999 17:37'!trackAmbientColor: aBool	aBool		ifTrue:[flags _ flags bitOr: VBTrackAmbient]		ifFalse:[flags _ flags bitAnd: VBTrackAmbient bitInvert32]! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/8/1999 17:37'!trackDiffuseColor: aBool	aBool		ifTrue:[flags _ flags bitOr: VBTrackDiffuse]		ifFalse:[flags _ flags bitAnd: VBTrackDiffuse bitInvert32]! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/8/1999 17:37'!trackEmissionColor: aBool	aBool		ifTrue:[flags _ flags bitOr: VBTrackEmission]		ifFalse:[flags _ flags bitAnd: VBTrackEmission bitInvert32]! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/8/1999 17:37'!trackSpecularColor: aBool	aBool		ifTrue:[flags _ flags bitOr: VBTrackSpecular]		ifFalse:[flags _ flags bitAnd: VBTrackSpecular bitInvert32]! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 2/7/1999 04:05'!vertex: aVector	current position: aVector.	self addPrimitiveVertex: current.! !!B3DVertexBuffer methodsFor: 'private' stamp: 'ar 2/7/1999 02:31'!errorSizeMismatch	^self error:'Vertex size mismatch'! !!B3DVertexBuffer methodsFor: 'private' stamp: 'ar 2/7/1999 02:41'!growIndexArray: newSize	| newIdxArray |	newIdxArray _ indexArray species new: newSize.	newIdxArray replaceFrom: 1 to: indexArray size with: indexArray startingAt: 1.	indexArray _ newIdxArray.! !!B3DVertexBuffer methodsFor: 'private' stamp: 'ar 2/7/1999 02:26'!growVertexArray: newSize	| newVtxArray |	newVtxArray _ vertexArray species new: newSize.	newVtxArray replaceFrom: 1 to: vertexArray size with: vertexArray startingAt: 1.	vertexArray _ newVtxArray.! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 23:12'!addClipIndex: index	"Add a primitive index to the list of indexes."	indexCount >= indexArray size 		ifTrue:[^self halt:'No more index space'].	indexArray at: (indexCount _ indexCount + 1) put: index.! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 23:11'!addClipVertex: pVtx	"Add a primitive vertex to the list of vertices processed.	Return the index of the vertex."	vertexCount >= vertexArray size 		ifTrue:[self halt:'No more vertex space'.				^vertexCount].	vertexArray at: (vertexCount _ vertexCount + 1) put: pVtx.	^vertexCount! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 23:13'!addPrimitiveIndex: index	"Add a primitive index to the list of indexes."	indexCount >= indexArray size 		ifTrue:[self growIndexArray: indexCount * 3 // 2 + 100].	indexArray at: (indexCount _ indexCount + 1) put: index.! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 04:02'!addPrimitiveVertex: pVtx	"Add a primitive vertex to the list of vertices processed.	Return the index of the vertex."	vertexCount >= vertexArray size 		ifTrue:[self growVertexArray: vertexCount * 3 // 2 + 100].	vertexArray at: (vertexCount _ vertexCount + 1) put: pVtx.	^vertexCount! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 23:16'!growForClip	vertexCount*2+100 > vertexArray size ifTrue:[self growVertexArray: vertexCount*2+100].	indexCount*2+100 > indexArray size ifTrue:[self growIndexArray: indexCount*2+100].! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 16:07'!primitiveColorAt: index	^(vertexArray at: index) color! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 04:04'!primitiveIndexAt: index	^indexArray at: index! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 04:05'!primitiveIndexAt: index put: value	^indexArray at: index put: value! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 04:04'!primitiveVertexAt: index	^vertexArray at: index! !!B3DVertexBuffer methodsFor: 'protected' stamp: 'ar 2/7/1999 04:04'!primitiveVertexAt: index put: aPrimitiveVertex	^vertexArray at: index put: aPrimitiveVertex! !!B3DVertexBuffer methodsFor: 'primitives' stamp: 'ar 2/14/1999 23:31'!primLoadIndexArrayInto: dstArray startingAt: dstStart from: idxArray count: count max: maxValue offset: vtxOffset	"Primitive. Load the given index array into the receiver.	NOTE: dstStart is a zero-based index."	| idx |	<primitive:'b3dLoadIndexArray' module:'Squeak3D'>	self flag: #b3dDebug.	self primitiveFailed.	1 to: count do:[:i|		idx _ idxArray basicAt: i.		(idx < 1 or:[idx > maxValue]) ifTrue:[^self error:'Index out of range'].		dstArray at: dstStart + i put: idx + vtxOffset.	].	^count! !!B3DVertexBuffer methodsFor: 'primitives' stamp: 'ar 2/15/1999 00:09'!primLoadVB: dstArray startingAt: dstStart vertices: vertices normals: normals colors: colors texCoords: texCoords count: count default: defaultValues	| hasNormals hasColors hasTexCoords pVtx defaultNormal defaultColor defaultTexCoords |	<primitive:'b3dLoadVertexBuffer' module:'Squeak3D'>	self flag: #b3dDebug.	self primitiveFailed.	defaultNormal _ defaultValues normal.	defaultColor _ defaultValues color.	defaultTexCoords _ defaultValues texCoords.	hasNormals _ normals notNil.	hasColors _ colors notNil.	hasTexCoords _ texCoords notNil.	1 to: count do:[:i|		pVtx _ dstArray at: dstStart + i.		pVtx position: (vertices at: i).		pVtx normal: (hasNormals ifTrue:[normals at: i] ifFalse:[defaultNormal]).		pVtx color: (hasColors ifTrue:[colors at: i] ifFalse:[defaultColor]).		pVtx texCoords: (hasTexCoords ifTrue:[texCoords at: i] ifFalse:[defaultTexCoords]).		dstArray at: dstStart + i put: pVtx.	].	^count! !!B3DVertexBufferPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 23:32'!b3dLoadIndexArray	"Primitive. Load the given index array into the receiver.	NOTE: dstStart is a zero-based index."	| vtxOffset maxValue count srcArray srcPtr idx dstStart dstArray dstSize dstPtr |	self export: true.	self inline: false.	self var: #dstPtr declareC:'int *dstPtr'.	self var: #srcPtr declareC:'int *srcPtr'.	"Load the arguments"	vtxOffset _ interpreterProxy stackIntegerValue: 0.	maxValue _ interpreterProxy stackIntegerValue: 1.	count _ interpreterProxy stackIntegerValue: 2.	srcArray _ interpreterProxy stackObjectValue: 3.	dstStart _ interpreterProxy stackIntegerValue: 4.	dstArray _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil]. "Will cover all possible problems above"	"Check srcArray"	(interpreterProxy isWords: srcArray)		ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy slotSizeOf: srcArray) < count)		ifTrue:[^interpreterProxy primitiveFail].	srcPtr _ self cCoerce: (interpreterProxy firstIndexableField: srcArray) to:'int*'.	"Check dstArray" 	dstSize _ interpreterProxy slotSizeOf: dstArray.	"Check if there is enough room left in dstArray"	dstStart + count > dstSize		ifTrue:[^interpreterProxy primitiveFail].	dstPtr _ self cCoerce: (interpreterProxy firstIndexableField: dstArray) to:'int *'.	"Do the actual work"	0 to: count-1 do:[:i|		idx _ srcPtr at: i.		(idx < 1 or:[idx > maxValue]) 			ifTrue:[^interpreterProxy primitiveFail].		dstPtr at: dstStart + i put: idx + vtxOffset.	].	"Clean up the stack"	interpreterProxy pop: 7. "Pop args+rcvr"	interpreterProxy pushInteger: count.! !!B3DVertexBufferPlugin methodsFor: 'primitives' stamp: 'ar 2/15/1999 00:05'!b3dLoadVertexBuffer	| defaultVtx defaultNormal defaultTexCoords defaultColor count texPtr colorPtr normalPtr vtxPtr dstStart dstPtr pVtx |	self export: true.	self inline: false.	self var: #defaultVtx declareC:'int *defaultVtx'.	self var: #defaultNormal declareC:'int *defaultNormal'.	self var: #defaultTexCoords declareC:'int *defaultTexCoords'.	self var: #defaultColor declareC:'int *defaultColor'.	self var: #texPtr declareC:'int *texPtr'.	self var: #colorPtr declareC:'int *colorPtr'.	self var: #normalPtr declareC:'int *normalPtr'.	self var: #vtxPtr declareC:'int *vtxPtr'.	self var: #dstPtr declareC:'int *dstPtr'.	self var: #pVtx declareC:'int *pVtx'.	defaultVtx _ self stackPrimitiveVertex: 0.	count _ interpreterProxy stackIntegerValue: 1.	texPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 2) 				size: 2*count.	colorPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 3) 				size: count.	normalPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 4) 				size: 3*count.	vtxPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 5) 				size: 3*count.	dstStart _ interpreterProxy stackIntegerValue: 6.	dstPtr _ self stackPrimitiveVertexArray: 7 ofSize: dstStart + count.	"Check for all problems above"	(dstPtr = nil or:[defaultVtx == nil or:[interpreterProxy failed]]) 		ifTrue:[^interpreterProxy primitiveFail].	"Install default values"	normalPtr = nil		ifTrue:[defaultNormal _ defaultVtx + PrimVtxNormal]		ifFalse:[defaultNormal _ normalPtr].	texPtr = nil		ifTrue:[defaultTexCoords _ defaultVtx + PrimVtxTexCoords]		ifFalse:[defaultTexCoords _ texPtr].	colorPtr = nil		ifTrue:[defaultColor _ defaultVtx + PrimVtxColor32]		ifFalse:[defaultColor _ colorPtr].	"Do the actual stuff"	pVtx _ dstPtr + (dstStart * PrimVertexSize).	0 to: count-1 do:[:i|		pVtx at: PrimVtxPositionX put: (vtxPtr at: 0).		pVtx at: PrimVtxPositionY put: (vtxPtr at: 1).		pVtx at: PrimVtxPositionZ put: (vtxPtr at: 2).		pVtx at: PrimVtxNormalX put: (defaultNormal at: 0).		pVtx at: PrimVtxNormalY put: (defaultNormal at: 1).		pVtx at: PrimVtxNormalZ put: (defaultNormal at: 2).		pVtx at: PrimVtxColor32 put: (defaultColor at: 0).		pVtx at: PrimVtxTexCoordU put: (defaultTexCoords at: 0).		pVtx at: PrimVtxTexCoordV put: (defaultTexCoords at: 1).		"And go to the next vertex"		pVtx _ pVtx + PrimVertexSize.		vtxPtr _ vtxPtr + 3.		normalPtr = nil ifFalse:[defaultNormal _ defaultNormal + 3].		colorPtr = nil ifFalse:[defaultColor _ defaultColor + 1].		texPtr = nil ifFalse:[defaultTexCoords _ defaultTexCoords + 2].	].	"Clean up stack"	interpreterProxy pop: 8. "Pop args+rcvr"	interpreterProxy pushInteger: count.! !!B3DVertexBufferPlugin methodsFor: 'private' stamp: 'ar 2/14/1999 23:50'!vbLoadArray: oop size: count	"Load the word based array of size count from the given oop"	self returnTypeC: 'void*'.	self inline: false.	oop == nil ifTrue:[^interpreterProxy primitiveFail].	oop == interpreterProxy nilObject ifTrue:[^nil].	(interpreterProxy isWords: oop) 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: oop) = count		ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy firstIndexableField: oop! !!B3DVertexClipper commentStamp: 'ar 2/8/1999 03:02' prior: 0!I provide clipping capabilities for rasterizers needing explicit clipping.!!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 2/16/1999 19:20'!processIndexedQuads: vb	"Clip an indexed quad set"	| vtxArray idxArray tempVB idx1 idx2 idx3 maxVtx maxIdx index lastIndex clipFlags vtx |	self flag: #b3dPrimitive.	tempVB _ B3DVertexBuffer new.	vtxArray _ vb vertexArray.	idxArray _ vb indexArray.	maxVtx _ vb indexCount.	maxIdx _ vb indexCount.	lastIndex _ -3. "Hack the lastIndex ;-)"	[index _ self primNextClippedQuadAfter: lastIndex + 4					vertices: vtxArray count: maxVtx					indexes: idxArray count: maxIdx.	index = 0] whileFalse:[		"Need a partial clip here, storing the triangulated polygon at the end"		tempVB reset.		clipFlags _ InAllMask + OutAllMask.		"Copy the poly into tempVB"		0 to: 3 do:[:i|			vtx _ vtxArray at: (idxArray at: index+i).			idxArray at: index+i put: 0.			tempVB addClipVertex: vtx.			clipFlags _ clipFlags bitAnd: vtx clipFlags].		tempVB clipFlags: clipFlags.		self processPolygon: tempVB.		tempVB vertexCount > 2 ifTrue:[			idx1 _ vb addClipVertex: (tempVB vertexArray at: 1).			3 to: tempVB vertexCount do:[:j|				idx2 _ vb addClipVertex: (tempVB vertexArray at: j-1).				idx3 _ vb addClipVertex: (tempVB vertexArray at: j).				vb addClipIndex: idx1.				vb addClipIndex: idx2.				vb addClipIndex: idx3.				vb addClipIndex: idx3.			].		].		lastIndex _ index.	].! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 2/16/1999 19:20'!processIndexedTriangles: vb	"Clip an indexed triangle set"	| vtxArray idxArray tempVB idx1 idx2 idx3 maxVtx maxIdx index lastIndex clipFlags vtx |	self flag: #b3dPrimitive.	tempVB _ B3DVertexBuffer new.	vtxArray _ vb vertexArray.	idxArray _ vb indexArray.	maxVtx _ vb indexCount.	maxIdx _ vb indexCount.	lastIndex _ -2. "Hack the lastIndex ;-)"	[index _ self primNextClippedTriangleAfter: lastIndex + 3					vertices: vtxArray count: maxVtx					indexes: idxArray count: maxIdx.	index = 0] whileFalse:[		"Need a partial clip here, storing the triangulated polygon at the end"		tempVB reset.		clipFlags _ InAllMask + OutAllMask.		"Copy the poly into tempVB"		0 to: 2 do:[:i|			vtx _ vtxArray at: (idxArray at: index+i).			idxArray at: index+i put: 0.			tempVB addClipVertex: vtx.			clipFlags _ clipFlags bitAnd: vtx clipFlags].		tempVB clipFlags: clipFlags.		self processPolygon: tempVB.		tempVB vertexCount > 2 ifTrue:[			idx1 _ vb addClipVertex: (tempVB vertexArray at: 1).			3 to: tempVB vertexCount do:[:j|				idx2 _ vb addClipVertex: (tempVB vertexArray at: j-1).				idx3 _ vb addClipVertex: (tempVB vertexArray at: j).				vb addClipIndex: idx1.				vb addClipIndex: idx2.				vb addClipIndex: idx3.			].		].		lastIndex _ index.	].! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 2/16/1999 19:20'!processPolygon: vb	"Process a polygon from the vertex buffer that requires partial clipping"	| outMask vtxArray tempVtxArray count |	outMask := vb clipFlags bitAnd: OutAllMask.	vtxArray _ vb vertexArray.	tempVtxArray _ vtxArray clone.	"Note: tempVtxArray has the SAME contents as vtxArray since the data is stored inplace.	Thus we can decide from which buffer to start the clipping operation later on."	count _ self clipPolygon: vtxArray count: vb vertexCount with: tempVtxArray mask: outMask.	vb vertexCount: count.! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 2/16/1999 19:20'!processVertexBuffer: vb	"Clip the elements in the vertex buffer. Return true if all vertices are inside.	Return false if all vertices are outside. If partial clipping occurs, return nil."	| fullMask |	fullMask _ self determineClipFlags: vb vertexArray count: vb vertexCount.	vb clipFlags: fullMask.	"Check if all vertices are inside, so no clipping is necessary"	(fullMask allMask: InAllMask) ifTrue:[^true].	"Check if all vertices are outside, so we can get rid of the entire buffer"	(fullMask anyMask: OutAllMask) ifTrue:[		"Reset the number of vertices in the vertex buffer to zero to indicate all outside"		vb reset.		^false].	"Must clip individual items depending on the primitive type"	vb growForClip. "Make sure we have enough space during primitive operation"	super processVertexBuffer: vb.	^nil! !!B3DVertexClipper methodsFor: 'clip flags' stamp: 'ar 2/16/1999 19:20'!clipFlagsX: x y: y z: z w: w	"Determine the clip flags for the given vector.	The clip flags are a combination of inside and outside flags that can be used to easily reject an entire buffer if it is completely inside or outside and can also be used to detect the most commen cases in clipping (e.g., intersection with one boundary only)."	| w2 flags |	w2 _ w negated.	flags _ 0.	flags _ flags bitOr:(x >= w2 ifTrue:[InLeftBit] ifFalse:[OutLeftBit]).	flags _ flags bitOr:(x <= w ifTrue:[InRightBit] ifFalse:[OutRightBit]).	flags _ flags bitOr:(y >= w2 ifTrue:[InBottomBit] ifFalse:[OutBottomBit]).	flags _ flags bitOr:(y <= w ifTrue:[InTopBit] ifFalse:[OutTopBit]).	flags _ flags bitOr:(z >= w2 ifTrue:[InFrontBit] ifFalse:[OutFrontBit]).	flags _ flags bitOr:(z <= w ifTrue:[InBackBit] ifFalse:[OutBackBit]).	^flags! !!B3DVertexClipper methodsFor: 'clip flags' stamp: 'ar 2/16/1999 19:20'!determineClipFlags: vtxArray count: vtxCount	"Determine the clip flags for all the vertices in the vertex array"	| fullMask flags |	self flag: #b3dPrimitive.	fullMask _ InAllMask + OutAllMask.	vtxArray upTo: vtxCount do:[:vtx|		flags _ (self clipFlagsX: vtx rasterPosX 							y: vtx rasterPosY 							z: vtx rasterPosZ 							w: vtx rasterPosW).		vtx clipFlags: flags.		fullMask _ fullMask bitAnd: flags.	].	^fullMask! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygon: vtxArray count: vtxCount with: tempVtxArray mask: outMask	"Clip the polygon defined by vtxCount vertices in vtxArray. tempVtxArray is a temporary storage area used for copying the vertices back and forth during clipping operation. outMask is the full clip mask of the vertex buffer, allowing some optimizations of the clipping code.	NOTE: It is significant here that the contents of vtxArray and tempVtxArray are equal."	| count |	self flag: #b3dPrimitive.	"Check if the polygon is outside one boundary only.	If so, just do this single clipping operation avoiding multiple enumeration."	outMask = OutLeftBit 		ifTrue:[^self clipPolygonLeftFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutRightBit 		ifTrue:[^self clipPolygonRightFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutTopBit 		ifTrue:[^self clipPolygonTopFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutBottomBit 		ifTrue:[^self clipPolygonBottomFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutFrontBit 		ifTrue:[^self clipPolygonFrontFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutBackBit 		ifTrue:[^self clipPolygonBackFrom: tempVtxArray to: vtxArray count: vtxCount].	"Just do each of the clipping operations"	count _ vtxCount.	count _ self clipPolygonLeftFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonRightFrom: tempVtxArray to: vtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonTopFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonBottomFrom: tempVtxArray to: vtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonFrontFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonBackFrom: tempVtxArray to: vtxArray count: count.	^count! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonBackFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InBackBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InBackBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self backClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonBottomFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InBottomBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InBottomBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self bottomClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonFrontFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InFrontBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InFrontBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self frontClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonLeftFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InLeftBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InLeftBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self leftClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonRightFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InRightBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InRightBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self rightClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 2/16/1999 19:21'!clipPolygonTopFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InTopBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InTopBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self topClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!backClipValueFrom: last to: next	^(last rasterPosZ - last rasterPosW) /		((next rasterPosW - last rasterPosW) - (next rasterPosZ - last rasterPosZ)).! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!bottomClipValueFrom: last to: next	^(last rasterPosY + last rasterPosW) negated /		((next rasterPosW - last rasterPosW) + (next rasterPosY - last rasterPosY)).! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!frontClipValueFrom: last to: next	^(last rasterPosZ + last rasterPosW) negated /		((next rasterPosW - last rasterPosW) + (next rasterPosZ - last rasterPosZ)).! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!interpolateFrom: last to: next at: t	"Interpolate the primitive vertices last/next at the parameter t"	| out |	out _ next clone.	"Interpolate raster position"	out rasterPos: ((next rasterPos - last rasterPos) * t) + last rasterPos.	out clipFlags: (self clipFlagsX: out rasterPosX y: out rasterPosY z: out rasterPosZ w: out rasterPosW).	"Interpolate color"	out b3dColor: ((next b3dColor - last b3dColor) * t) + last b3dColor.	"Interpolate texture coordinates"	out texCoords: ((next texCoords - last texCoords) * t) + last texCoords.	^out! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!leftClipValueFrom: last to: next	^(last rasterPosX + last rasterPosW) negated /		((next rasterPosW - last rasterPosW) + (next rasterPosX - last rasterPosX)).! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!rightClipValueFrom: last to: next	^(last rasterPosX - last rasterPosW) /		((next rasterPosW - last rasterPosW) - (next rasterPosX - last rasterPosX)).! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 2/16/1999 19:21'!topClipValueFrom: last to: next	^(last rasterPosY - last rasterPosW) /		((next rasterPosW - last rasterPosW) - (next rasterPosY - last rasterPosY)).! !!B3DVertexClipper methodsFor: 'private' stamp: 'ar 2/16/1999 19:21'!primNextClippedQuadAfter: firstIndex vertices: vtxArray count: vtxCount indexes: idxArray count: idxCount	"Find the next partially clipped quad from the vertex buffer and return its index.	If there are no more partially clipped quads return zero."	| quadMask |	self flag: #b3dPrimitive.	firstIndex to: idxCount by: 4 do:[:i|		quadMask _			((vtxArray at: (idxArray at: i)) clipFlags bitAnd:				(vtxArray at: (idxArray at: i+1)) clipFlags) bitAnd:					((vtxArray at: (idxArray at: i+2)) clipFlags bitAnd:						(vtxArray at: (idxArray at: i+3)) clipFlags).		"Check if quad is completely inside"		(quadMask allMask: InAllMask) ifFalse:[			"Quad is not completely inside -> needs clipping."			(quadMask anyMask: OutAllMask) ifTrue:[				"quad is completely outside. Store all zeros"				idxArray at: i put: 0.				idxArray at: i+1 put: 0.				idxArray at: i+2 put: 0.				idxArray at: i+3 put: 0.			] ifFalse:[				"quad must be partially clipped."				^i			].		].	].	^0 "No more entries"! !!B3DVertexClipper methodsFor: 'private' stamp: 'ar 2/16/1999 19:22'!primNextClippedTriangleAfter: firstIndex vertices: vtxArray count: vtxCount indexes: idxArray count: idxCount	"Find the next partially clipped triangle from the vertex buffer and return its index.	If there are no more partially clipped triangles return zero."	| triMask |	self flag: #b3dPrimitive.	firstIndex to: idxCount by: 3 do:[:i|		triMask _			((vtxArray at: (idxArray at: i)) clipFlags bitAnd:				(vtxArray at: (idxArray at: i+1)) clipFlags) bitAnd:					(vtxArray at: (idxArray at: i+2)) clipFlags.		"Check if tri is completely inside"		(triMask allMask: InAllMask) ifFalse:[			"Tri is not completely inside -> needs clipping."			(triMask anyMask: OutAllMask) ifTrue:[				"tri is completely outside. Store all zeros"				idxArray at: i put: 0.				idxArray at: i+1 put: 0.				idxArray at: i+2 put: 0.			] ifFalse:[				"tri must be partially clipped."				^i			].		].	].	^0 "No more entries"! !!B3DVertexClipper class methodsFor: 'class initialization' stamp: 'ar 2/13/1999 20:31'!initialize	"B3DClipper initialize"	"InLeftBit _ 16r01.	OutLeftBit _ 16r02.	InRightBit _ 16r04.	OutRightBit _ 16r08.	InTopBit _ 16r10.		OutTopBit _ 16r20.	InBottomBit _ 16r40.	OutBottomBit _ 16r80.	InFrontBit _ 16r100.	OutFrontBit _ 16r200.	InBackBit _ 16r400.	OutBackBit _ 16r800.	InAllMask  _ 16r555. 1365	OutAllMask  _ 16rAAA 2730."! !!B3DVertexClipper class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:40'!isAvailable	"Return true if this part of the engine is available"	^true! !!B3DVertexClipper class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:34'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^true! !!B3DVertexRasterizer commentStamp: '<historical>' prior: 0!I am the superclass for all rasterizers in the Balloon 3D engine. Rasterizers perform the final pixel generation of the primitives and are the most time-critical part of the engine. Rasterizers keep a viewport, defining the destination rectangle and a dirtyRect, defining the actual affected 2D region of the rasterization process.Instance variables:	viewport	<B3DViewport>	the destination rectangle	dirtyRect	<Rectangle>		the affected region of all rasterization operations performed!!B3DVertexRasterizer methodsFor: 'initialize' stamp: 'ar 2/16/1999 04:30'!finish	"Force everything on the output device"! !!B3DVertexRasterizer methodsFor: 'initialize' stamp: 'ar 2/16/1999 03:15'!initialize	super initialize.	textureStack _ OrderedCollection new.! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/7/1999 03:38'!dirtyRect	"If the dirtyRect is not known (e.g., not implemented by a particular rasterizer) return the full viewport"	^dirtyRect ifNil:[viewport]! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/7/1999 03:35'!dirtyRect: aRectangle	dirtyRect _ aRectangle! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:16'!popTexture	texture _ textureStack removeLast.! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:15'!pushTexture	textureStack addLast: texture! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:15'!texture	^texture! !!B3DVertexRasterizer methodsFor: 'accessing' stamp: 'ar 2/16/1999 03:15'!texture: aForm	texture _ aForm! !!B3DVertexRasterizer methodsFor: 'processing' stamp: 'ar 2/16/1999 02:02'!clearDepthBuffer	"If the rasterizer uses a depth buffer, clear it."! !!B3DVertexRasterizer methodsFor: 'processing' stamp: 'ar 2/16/1999 02:03'!clearViewport: aColor	"Clear the current viewport using the given color"! !!B3DNullRasterizer commentStamp: 'ar 2/16/1999 02:31' prior: 0!The only purpose of this rasterizer is to measure the actual transform/lighting/clipping speed of an engine.!!B3DNullRasterizer methodsFor: 'testing' stamp: 'ar 2/16/1999 02:31'!needsClip	"Yepp. We want to see how well our clipper performs."	^true! !!B3DSqueakFormRasterizer methodsFor: 'initialize' stamp: 'ar 2/7/1999 01:43'!viewport: vp	super viewport: vp.	viewport toggleYScale.! !!B3DSqueakFormRasterizer methodsFor: 'testing' stamp: 'ar 2/7/1999 22:54'!needsClip	^true "Maybe we'll change this later on"! !!B3DSqueakFormRasterizer methodsFor: 'processing' stamp: 'ar 2/15/1999 03:35'!processIndexed: vb size: n	| out vtxArray idxArray black color idx1 obj |	vb vertexCount = 0 ifTrue:[^self].	canvas ifNil:[		canvas _ BalloonCanvas on: bb destForm.		canvas aaLevel: 1].	vtxArray _ vb vertexArray.	idxArray _ vb indexArray.	black _ SolidFillStyle color: Color black.	out _ Array new: vb vertexCount.	1 to: vb vertexCount do:[:i|		out at: i put: (viewport mapVertex4: (vtxArray at: i) rasterPos).	].	obj _ Array new: n+1.	canvas deferred: true.	1 to: vb indexCount by: n do:[:index|		idx1 _ idxArray at: index.		"index = 0 marks an invalidated primitive object"		idx1 = 0 ifFalse:[			color _ (vtxArray at: idx1) b3dColor. 			1 to: n-1 do:[:i| color += (vtxArray at: idx1+i) b3dColor].			color /= n asFloat.			obj at: 1 put: (obj at: n+1 put: (out at: idx1)).			1 to: n-1 do:[:i| obj at: i+1 put: (out at: (idxArray at: index+i))].			canvas drawPolygon: obj color: color asColor borderWidth: 0 borderColor: black.		].	].	canvas flush.! !!B3DSqueakFormRasterizer methodsFor: 'processing' stamp: 'ar 2/8/1999 02:19'!processIndexedQuads: vb	^self processIndexed: vb size: 4! !!B3DSqueakFormRasterizer methodsFor: 'processing' stamp: 'ar 2/8/1999 02:19'!processIndexedTriangles: vb	^self processIndexed: vb size: 3! !!B3DSqueakFormRasterizer methodsFor: 'processing' stamp: 'ar 2/5/1999 00:17'!processPolygon: vb	| out vtxArray |	vb vertexCount = 0 ifTrue:[^self].	canvas ifNil:[		canvas _ BalloonCanvas on: bb destForm.		canvas aaLevel: 1].	vtxArray _ vb vertexArray.	out _ Array new: vb vertexCount+1.	1 to: vb vertexCount do:[:i|		out at: i put: (viewport mapVertex4: (vtxArray at: i) rasterPos).	].	out at: vb vertexCount+1 put: out first.	canvas drawPolygon: out color: vtxArray first color borderWidth: 1 borderColor: Color black.! !!B3DNullRasterizer class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:37'!isAvailable	"Return true if this part of the engine is available"	^true! !!B3DNullRasterizer class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:35'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^true! !!B3DSqueakFormRasterizer class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:40'!isAvailable	"Return true if this part of the engine is available"	^true! !!B3DSqueakFormRasterizer class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:35'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^anOutputMedium isKindOf: Form! !!B3DVertexShader methodsFor: 'initialize' stamp: 'ar 2/15/1999 20:29'!initialize	super initialize.	lights _ OrderedCollection new.	primitiveLights _ #().	material _ B3DMaterial new.	materialStack _ OrderedCollection new: 10.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/15/1999 20:27'!addLight: aLightSource	| primLight |	primLight _ aLightSource asPrimitiveLight.	primLight ifNotNil:[primitiveLights _ primitiveLights copyWith: primLight].	lights add: aLightSource -> primLight.	^lights size! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:36'!material	^material! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:36'!material: aMaterial	material _ aMaterial.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/7/1999 16:19'!materialColor: aColor	material ambientPart: aColor.	material diffusePart: aColor.	material specularPart: aColor.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:35'!popMaterial	material _ materialStack removeLast.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/7/1999 19:35'!pushMaterial	materialStack addLast: material.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/15/1999 20:28'!removeLight: lightIndex	| lightAssoc |	(lightIndex < 1 or:[lightIndex > lights size]) ifTrue:[^nil].	lightAssoc _ lights at: lightIndex.	lights at: lightIndex put: nil. "So we don't change the indexes"	lightAssoc value ifNotNil:[primitiveLights _ primitiveLights copyWithout: lightAssoc value].! !!B3DVertexShader methodsFor: 'shading' stamp: 'ar 2/15/1999 22:20'!primShadeVB: vertexArray count: vtxCount lights: lightArray material: aMaterial vbFlags: vbFlags	"Primitive. Shade all the vertices in the vertex buffer using the given array of primitive light sources."	<primitive: 'b3dShadeVertexBuffer' module:'Squeak3D'>	self flag: #b3dDebug. self primitiveFailed.	^nil "Return nil to indicate failure - so we can run ST code instead"! !!B3DVertexShader methodsFor: 'shading' stamp: 'ar 2/16/1999 01:18'!processVertexBuffer: vb	| colors emissionPart |	"Do the primitive operation"	true ifTrue:[		^self primShadeVB: vb vertexArray 			count: vb vertexCount 			lights: primitiveLights 			material: material 			vbFlags: vb flags].	false ifTrue:[^self]. "Currently no shading available"	colors _ B3DColor4Array new: vb vertexCount.	"Load initial colors (e.g., emission part)"	vb trackEmissionColor ifFalse:[		emissionPart _ material emission.		1 to: vb vertexCount do:[:i| colors at: i put: emissionPart].	] ifTrue:[		1 to: vb vertexCount do:[:i| colors at: i put: (vb primitiveVertexAt: i) b3dColor].	].self halt.	lights do:[:light|		light key shadeVertexBuffer: vb with: material into: colors.	].	colors clampAllFrom: 0.0 to: 1.0.	vb vertexArray upTo: vb vertexCount doWithIndex:[:vtx :i| vtx color: (colors at: i)].! !!B3DVertexShader class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:41'!isAvailable	"Return true if this part of the engine is available"	^true! !!B3DVertexShader class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:36'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^true! !!B3DVertexTransformer reorganize!('initialize' initialize)('public' transformDirection: transformPosition:)('accessing' currentMatrix matrixMode matrixMode: modelViewMatrix popMatrix projectionMatrix pushMatrix)('modifying' loadIdentity loadMatrix: lookFrom:to:up: multiplyMatrix: rotateBy: scaleBy: scaleByX:y:z: transformBy: translateBy: translateByX:y:z:)('processing' processVertexBuffer:)('view transformation' ortho: perspective:)('private-transforming' privateTransformMatrix:with:into: privateTransformPrimitiveNormal:byMatrix:rescale: privateTransformPrimitiveVertex:byModelView: privateTransformPrimitiveVertex:byModelViewWithoutW: privateTransformPrimitiveVertex:byProjection: privateTransformVB:count:modelViewMatrix:projectionMatrix:flags:)!!B3DVertexTransformer methodsFor: 'public' stamp: 'ar 2/8/1999 01:33'!transformDirection: aVector3	self error:'Not implemented'! !!B3DVertexTransformer methodsFor: 'public' stamp: 'ar 2/8/1999 01:33'!transformPosition: aVector3	| pVtx |	pVtx _ B3DPrimitiveVertex new.	pVtx position: aVector3.	self privateTransformPrimitiveVertex: pVtx byModelView: self modelViewMatrix.	^pVtx position! !!B3DVertexTransformer methodsFor: 'modifying' stamp: 'ar 2/7/1999 01:39'!lookFrom: position to: target up: upDirection	"create a matrix such that we look from eyePoint to centerPoint using upDirection"	| xDir yDir zDir m |	"calculate z vector"	zDir _ target - position.	zDir safelyNormalize.	"calculate x vector"	xDir _ upDirection cross: zDir.	xDir safelyNormalize.	"recalc y vector"	yDir _ zDir cross: xDir.	yDir safelyNormalize.	m := B3DMatrix4x4 new.	m	a11: xDir x;		a12: xDir y;		a13: xDir z;		a14: 0.0;		a21: yDir x;		a22: yDir y;		a23: yDir z;		a24: 0.0;		a31: zDir x;		a32: zDir y;		a33: zDir z;		a34: 0.0;		a41: 0.0;			a42: 0.0;		a43: 0.0;		a44: 1.0.	self transformBy: m.	self translateBy: position negated.! !!B3DVertexTransformer methodsFor: 'processing' stamp: 'ar 2/8/1999 17:54'!processVertexBuffer: vb	self privateTransformVB: vb vertexArray 			count: vb vertexCount			modelViewMatrix: self modelViewMatrix			projectionMatrix: self projectionMatrix			flags: vb flags! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:16'!privateTransformMatrix: m1 with: m2 into: m3	"Perform a 4x4 matrix multiplication		m2 * m1 = m3	being equal to first transforming points by m2 and then by m1.	Note that m1 may be identical to m3."	| c1 c2 c3 c4 |	<primitive: 'b3dTransformMatrixWithInto' module:'Squeak3D'>	m2 == m3 ifTrue:[^self error:'Argument and result matrix identical'].	c1 _ ((m1 a11 * m2 a11) + (m1 a12 * m2 a21) + 				(m1 a13 * m2 a31) + (m1 a14 * m2 a41)).	c2 _ ((m1 a11 * m2 a12) + (m1 a12 * m2 a22) + 				(m1 a13 * m2 a32) + (m1 a14 * m2 a42)).	c3 _ ((m1 a11 * m2 a13) + (m1 a12 * m2 a23) + 				(m1 a13 * m2 a33) + (m1 a14 * m2 a43)).	c4 _ ((m1 a11 * m2 a14) + (m1 a12 * m2 a24) + 				(m1 a13 * m2 a34) + (m1 a14 * m2 a44)).	m3 a11: c1; a12: c2; a13: c3; a14: c4.	c1 _ ((m1 a21 * m2 a11) + (m1 a22 * m2 a21) + 				(m1 a23 * m2 a31) + (m1 a24 * m2 a41)).	c2 _ ((m1 a21 * m2 a12) + (m1 a22 * m2 a22) + 				(m1 a23 * m2 a32) + (m1 a24 * m2 a42)).	c3 _ ((m1 a21 * m2 a13) + (m1 a22 * m2 a23) + 				(m1 a23 * m2 a33) + (m1 a24 * m2 a43)).	c4 _ ((m1 a21 * m2 a14) + (m1 a22 * m2 a24) + 				(m1 a23 * m2 a34) + (m1 a24 * m2 a44)).	m3 a21: c1; a22: c2; a23: c3; a24: c4.	c1 _ ((m1 a31 * m2 a11) + (m1 a32 * m2 a21) + 				(m1 a33 * m2 a31) + (m1 a34 * m2 a41)).	c2 _ ((m1 a31 * m2 a12) + (m1 a32 * m2 a22) + 				(m1 a33 * m2 a32) + (m1 a34 * m2 a42)).	c3 _ ((m1 a31 * m2 a13) + (m1 a32 * m2 a23) + 				(m1 a33 * m2 a33) + (m1 a34 * m2 a43)).	c4 _ ((m1 a31 * m2 a14) + (m1 a32 * m2 a24) + 				(m1 a33 * m2 a34) + (m1 a34 * m2 a44)).	m3 a31: c1; a32: c2; a33: c3; a34: c4.	c1 _ ((m1 a41 * m2 a11) + (m1 a42 * m2 a21) + 				(m1 a43 * m2 a31) + (m1 a44 * m2 a41)).	c2 _ ((m1 a41 * m2 a12) + (m1 a42 * m2 a22) + 				(m1 a43 * m2 a32) + (m1 a44 * m2 a42)).	c3 _ ((m1 a41 * m2 a13) + (m1 a42 * m2 a23) + 				(m1 a43 * m2 a33) + (m1 a44 * m2 a43)).	c4 _ ((m1 a41 * m2 a14) + (m1 a42 * m2 a24) + 				(m1 a43 * m2 a34) + (m1 a44 * m2 a44)).	m3 a41: c1; a42: c2; a43: c3; a44: c4.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:17'!privateTransformPrimitiveNormal: primitiveVertex byMatrix: aMatrix rescale: scaleNeeded	| x y z rx ry rz dot |	<primitive: 'b3dTransformPrimitiveNormal' module:'Squeak3D'>	x _ primitiveVertex normalX.	y _ primitiveVertex normalY.	z _ primitiveVertex normalZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13).	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23).	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33).	scaleNeeded ifTrue:[		dot _ (rx * rx) + (ry * ry) + (rz * rz).		dot < 1.0e-20 ifTrue:[			rx _ ry _ rz _ 0.0.		] ifFalse:[			dot = 1.0 ifFalse:[				dot _ 1.0 / dot sqrt.				rx _ rx * dot.				ry _ ry * dot.				rz _ rz * dot.			].		].	].	primitiveVertex normalX: rx.	primitiveVertex normalY: ry.	primitiveVertex normalZ: rz.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:18'!privateTransformPrimitiveVertex: primitiveVertex byModelView: aMatrix	| x y z rx ry rz rw oneOverW |	<primitive: 'b3dTransformPrimitivePosition' module:'Squeak3D'>	x _ primitiveVertex positionX.	y _ primitiveVertex positionY.	z _ primitiveVertex positionZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13) + aMatrix a14.	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23) + aMatrix a24.	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33) + aMatrix a34.	rw := (x * aMatrix a41) + (y * aMatrix a42) + (z * aMatrix a43) + aMatrix a44.	rw = 1.0 ifTrue:[		primitiveVertex positionX: rx.		primitiveVertex positionY: ry.		primitiveVertex positionZ: rz.	] ifFalse:[		rw = 0.0 			ifTrue:[oneOverW _ 0.0]			ifFalse:[oneOverW _ 1.0 / rw].		primitiveVertex positionX: rx * oneOverW.		primitiveVertex positionY: ry * oneOverW.		primitiveVertex positionZ: rz * oneOverW.	].! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:19'!privateTransformPrimitiveVertex: primitiveVertex byModelViewWithoutW: aMatrix	"Special case of aMatrix a41 = a42 = a43 = 0.0 and a44 = 1.0"	| x y z rx ry rz |	"Note: This is not supported by primitive level operations."	self flag: #b3dPrimitive.	x _ primitiveVertex positionX.	y _ primitiveVertex positionY.	z _ primitiveVertex positionZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13) + aMatrix a14.	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23) + aMatrix a24.	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33) + aMatrix a34.	primitiveVertex positionX: rx.	primitiveVertex positionY: ry.	primitiveVertex positionZ: rz.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:18'!privateTransformPrimitiveVertex: primitiveVertex byProjection: aMatrix	| x y z rx ry rz rw |	<primitive: 'b3dTransformPrimitiveRasterPosition' module:'Squeak3D'>	x _ primitiveVertex positionX.	y _ primitiveVertex positionY.	z _ primitiveVertex positionZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13) + aMatrix a14.	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23) + aMatrix a24.	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33) + aMatrix a34.	rw := (x * aMatrix a41) + (y * aMatrix a42) + (z * aMatrix a43) + aMatrix a44.	primitiveVertex rasterPosX: rx.	primitiveVertex rasterPosY: ry.	primitiveVertex rasterPosZ: rz.	primitiveVertex rasterPosW: rw.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/8/1999 18:20'!privateTransformVB: vertexArray count: vertexCount modelViewMatrix: modelViewMatrix projectionMatrix: projectionMatrix flags: flags	| noW |	<primitive: 'b3dTransformVertexBuffer' module:'Squeak3D'>	(modelViewMatrix a41 = 0.0 and:[		modelViewMatrix a42 = 0.0 and:[			modelViewMatrix a43 = 0.0 and:[				modelViewMatrix a44 = 1.0]]]) ifTrue:[noW _ true].	noW ifTrue:[		vertexArray upTo: vertexCount do:[:primitiveVertex|			self privateTransformPrimitiveVertex: primitiveVertex				byModelViewWithoutW: modelViewMatrix.			self privateTransformPrimitiveVertex: primitiveVertex				byProjection: projectionMatrix.			(flags anyMask: VBVtxHasNormals)				ifTrue:[self privateTransformPrimitiveNormal: primitiveVertex							byMatrix: modelViewMatrix							rescale: true].		].	] ifFalse:[		vertexArray upTo: vertexCount do:[:primitiveVertex|			self privateTransformPrimitiveVertex: primitiveVertex				byModelView: modelViewMatrix.			self privateTransformPrimitiveVertex: primitiveVertex				byProjection: projectionMatrix.			(flags anyMask: VBVtxHasNormals)				ifTrue:[self privateTransformPrimitiveNormal: primitiveVertex							byMatrix: modelViewMatrix							rescale: true].		].	].! !!B3DVertexTransformer class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:41'!isAvailable	"Return true if this part of the engine is available"	^true! !!B3DVertexTransformer class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:36'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^true! !!B3DViewingFrustum methodsFor: 'private' stamp: 'ar 2/7/1999 01:30'!asPerspectiveMatrixInto: aB3DMatrix4x4	| x y a b c d dx dy dz z2 |	(self near <= 0.0 or:[self far <= 0.0 or:[self near >= self far]]) 		ifTrue: [^self error:'Clipping plane error'].	dx := self right - self left.	dy := self top - self bottom.	dz := self far - self near.	z2 := 2.0 * self near.	x := z2 / dx.	y := z2 / dy.	a := (self left + self right) / dx.	b := (self top + self bottom) / dy.	c := (self near + self far) "*negated*" / dz.	d := (-2.0 * self near * self far) / dz.	aB3DMatrix4x4		a11: x;		a12: 0.0;		a13: a;		a14: 0.0;		a21: 0.0;		a22: y;		a23: b;		a24: 0.0;		a31: 0.0;		a32: 0.0;	a33: c;		a34: d;		a41: 0.0;		a42: 0.0;	a43: "*-1*"1;		a44: 0.0.	^aB3DMatrix4x4! !!B3DViewport commentStamp: 'ar 2/13/1999 20:13' prior: 0!I represent a viewport for the Ballon 3D graphics engine. Since all positions are computed in the unit-coordinate system (-1,-1,-1) (1,1,1) after the render pipeline has completed, I am used to map these positions into the physical (pixel) coordinates of the output device before rasterization takes place.Instance variables:	center 	<Point>	The center of the viewport	scale 	<Point>	The scale for points!!B3DViewport methodsFor: 'accessing' stamp: 'ar 2/15/1999 02:53'!aspectRatio	^self width asFloat / self height asFloat! !!B3DViewport methodsFor: 'private' stamp: 'ar 2/8/1999 21:45'!setOrigin: topLeft corner: bottomRight	super setOrigin: topLeft corner: bottomRight.	center _ (self origin + self corner) / 2.0.	scale _ corner - center + (0.5@-0.5). "Rasterizer offset"! !!B3DViewport methodsFor: 'private' stamp: 'ar 2/7/1999 01:42'!toggleYScale	scale _ scale x @ scale y negated.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/16/1999 17:39'!render: anObject	| b3d |	b3d _ (B3DRenderEngine defaultForPlatformOn: form) new.	b3d canvas: self.	anObject renderOn: b3d.	b3d flush.! !!Color methodsFor: 'conversions' stamp: 'ar 2/5/1999 19:30'!asB3DColor	"Convert the receiver into a color"	^B3DColor4 new loadFrom: self! !!OSMesaHandle commentStamp: 'ar 2/15/1999 07:34' prior: 0!I am a handle to an OSMesaContext.!!OSMesaHandle methodsFor: 'finalization' stamp: 'ar 2/13/1999 22:38'!finalize	"Release the resource associated with the receiver"	<primitive:'b3dReleaseHandle' module:'sqMesa'>! !!OSMesaPlugin commentStamp: 'ar 2/15/1999 07:35' prior: 0!This plugin defines the interface to the Offscreen (OS) Mesa interface. Mesa is a free (GPL-licensed) 3D library that provides a complete set of OpenGL commands.!!OSMesaPlugin reorganize!('primitives' b3dClearDepthBuffer b3dClearViewport b3dCreateHandle b3dGetVersion b3dRasterizeVertexBuffer b3dReleaseHandle)('rasterization' transmitIndexedLines:size:idxData:size: transmitIndexedQuads:size:idxData:size: transmitIndexedTriangles:size:idxData:size: transmitLines:size:idxData:size: transmitPoints:size:idxData:size: transmitPolygon:size:idxData:size: transmitVB:size:idxData:size:type: transmitVertex:)('support' flushContext: loadTexture:fromForm: makeCurrent:forFormAt: setViewport:fromStackAt:)('private' fetchOSMesaContextFrom: newSessionTimeStamp version)!!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/16/1999 02:06'!b3dClearDepthBuffer	"Primitive. Clear the depth buffer."	| context |	self export: true.	self inline: false.	self var: #context declareC:'OSMesaContext context'.	"Fetch and validate context"	context _ self fetchOSMesaContextFrom: 1.	context = (self cCoerce: 0 to:'OSMesaContext')		ifTrue:[^interpreterProxy primitiveFail].	"Do the actual work"	"STEP 1: Make the context current and give it the destination buffer"	self makeCurrent: context forFormAt: 0.	interpreterProxy failed ifTrue:[^nil].	"STEP 2: Clear the depth buffer"	self cCode:'glClear(GL_DEPTH_BUFFER_BIT)'.	"STEP 3: Actually enable depth tests"	self cCode:'glEnable(GL_DEPTH_TEST)'.	"And clean up the stack"	interpreterProxy failed 		ifFalse:[interpreterProxy pop: 2]. "Leaves rcvr on stack"	^0! !!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/16/1999 04:50'!b3dClearViewport	| context pv32 |	self export: true.	self inline: false.	self var: #context declareC:'OSMesaContext context'.	"Fetch the pixel value"	pv32 _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	interpreterProxy failed ifTrue:[^nil].	"Fetch and validate context"	context _ self fetchOSMesaContextFrom: 3.	context = (self cCoerce: 0 to:'OSMesaContext')		ifTrue:[^interpreterProxy primitiveFail].	"Do the actual work"	"STEP 1: Make the context current and give it the destination buffer"	self makeCurrent: context forFormAt: 1.	interpreterProxy failed ifTrue:[^nil].	"STEP 2: Set the viewport"	self setViewport: context fromStackAt: 0.	"STEP 3: Disable the depth buffer"	self cCode:'glPushAttrib(GL_DEPTH_BUFFER_BIT)'.	"So we can restore the original state"	self cCode:'glDisable(GL_DEPTH_TEST)'.	"STEP 4: Set the clear color.			Note that we must use glColor4ubv to avoid byte-order problems."	self cCode: 'glColor4ubv((GLubyte*) &pv32)'.	"STEP 5: Fill a rectangle from -1,-1 to 1,1			So we cover the actual viewport, not the physical extent of the form."	self cCode:'glRectf(-1.0,-1.0,1.0,1.0)'.	"STEP 6: Restore the depth buffer bit"	self cCode:'glPopAttrib()'.	"And clean up the stack"	interpreterProxy failed 		ifFalse:[interpreterProxy pop: 3]. "Leaves rcvr on stack"	^0! !!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 20:35'!b3dCreateHandle	"Primitive. Create a new OSMesaContext."	| context handle handleSize handlePtr |	self export: true.	self inline: false.	self var: #context declareC:'OSMesaContext context'.	"Check if we have a valid time stamp for this session"	osMesaTimeStamp = 0 ifTrue:[osMesaTimeStamp _ self newSessionTimeStamp].	context _ self cCode:'OSMesaCreateContext(OSMESA_RGBA, NULL)'.	context = 0 ifTrue:[^interpreterProxy primitiveFail].	handleSize _ self sizeof: context. "Note: This is C sizeOf(context) - it should be 4".	"NOTE: The following may cause GC"	handle _ interpreterProxy				instantiateClass: interpreterProxy classByteArray				indexableSize: handleSize + 4. "Including time stamp"	handle = interpreterProxy nilObject ifTrue:[^interpreterProxy primitiveFail].	handlePtr _ self cCoerce: (interpreterProxy firstIndexableField: handle) to: 'int'.	"Store time stamp"	self cCode:'*(int*) handlePtr = osMesaTimeStamp'.	"Store OSMesaContext"	self cCode:'*(OSMesaContext*) (handlePtr+4) = context'.	"And get out of here"	interpreterProxy pop: 1. "Pop receiver"	interpreterProxy push: handle. "Return the actual handle"	^0! !!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 20:35'!b3dGetVersion	"Primitive. Return the version of this rasterizer."	self export: true.	self inline: false.	interpreterProxy pop: 1. "Pop receiver"	interpreterProxy pushInteger: self version.	^0! !!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/16/1999 04:11'!b3dRasterizeVertexBuffer	"Primitive. Rasterize the vertex buffer."	| nArgs context vtxSize vtxArray idxSize idxArray primitive textureOop |	self export: true.	self inline: false.	self var: #context declareC:'OSMesaContext context'.	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	nArgs _ 9.	"Check argument count"	interpreterProxy methodArgumentCount = nArgs		ifFalse:[^interpreterProxy primitiveFail].	"Fetch and validate context"	context _ self fetchOSMesaContextFrom: nArgs-1.	context = (self cCoerce: 0 to:'OSMesaContext')		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the primitive vertex array"	vtxSize _ interpreterProxy stackIntegerValue: nArgs-3.	vtxArray _ self stackPrimitiveVertexArray: nArgs-2 ofSize: vtxSize.	vtxArray = nil		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the primitive index array"	idxSize _ interpreterProxy stackIntegerValue: nArgs-5.	idxArray _ self stackPrimitiveIndexArray: nArgs-4 ofSize: idxSize validate: true forVertexSize: vtxSize.	idxArray = nil		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the primitive type"	primitive _ interpreterProxy stackIntegerValue: nArgs-6.	(primitive < 1 or:[primitive > PrimTypeMax]) 		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the texture form"	textureOop _ interpreterProxy stackObjectValue: nArgs-7.	hasTexture _ textureOop ~~ interpreterProxy nilObject.	"Note: This final test also covers a couple of possible failures above"	interpreterProxy failed ifTrue:[^nil].	"Do the actual work"	"STEP 1: Make the context current and give it the destination buffer"	self makeCurrent: context forFormAt: nArgs-8.	interpreterProxy failed ifTrue:[^nil].	"STEP 2: Set the actual viewport"	self setViewport: context fromStackAt: nArgs-9.	interpreterProxy failed ifTrue:[^nil].	"STEP 3: Set the current texture and associated parameters"	hasTexture		ifTrue:[self loadTexture: context fromForm: textureOop].	interpreterProxy failed ifTrue:[^nil].	"STEP 4: Blast out vertex data"	self 		transmitVB: vtxArray size: vtxSize 		idxData: idxArray size: idxSize 		type: primitive.	"STEP 5: Flush the pipeline."	self flushContext: context.	"And clean up the stack"	interpreterProxy failed 		ifFalse:[interpreterProxy pop: nArgs]. "Leaves rcvr on stack"	^0! !!OSMesaPlugin methodsFor: 'primitives' stamp: 'ar 2/14/1999 20:35'!b3dReleaseHandle	"Primitive. Release the allocated OSMesaContext."	| context handlePtr |	self inline: false.	self export: true.	self var: #context declareC:'OSMesaContext context'.	context _ self fetchOSMesaContextFrom: 0.	context = (self cCoerce: 0 to:'OSMesaContext') 		ifTrue:[^interpreterProxy primitiveFail].	"Destroy the context."	self cCode:'OSMesaDestroyContext(context)'.	"Zero out the handle, so it is definitely invalid"	"Note: We don't check anything here - everything has been validated	in #fetchOSMesaContextFrom: so we can safely assume that the handle has	the right size/type."	handlePtr _ self cCoerce:(interpreterProxy firstIndexableField: (interpreterProxy stackValue: 0)) to: 'int'.	"Zero out time stamp"	self cCode:'*(int*) handlePtr = 0'.	"Zero out handle"	self cCode:'*(OSMesaContext*)(handlePtr+4) = (OSMesaContext) 0'.	"Get out of here"	interpreterProxy pop: 1. "Leave rcvr on stack"	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:15'!transmitIndexedLines: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex vtxPtr |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var: #vtxPtr declareC:'int *vtxPtr'.	self var:#pVertex declareC:'int *pVertex'.	max _ idxSize-1.	index _ 0.	vtxPtr _ vtxArray-PrimVertexSize. "For one-based indexing"	self cCode:'glBegin(GL_LINES)'.	[index < max] whileTrue:[		0 to: 1 do:[:i|			pVertex _ vtxPtr + ((idxArray at: index+i) * PrimVertexSize).			self transmitVertex: pVertex.		].		index _ index+2.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:15'!transmitIndexedQuads: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex vtxPtr |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var: #vtxPtr declareC:'int *vtxPtr'.	self var:#pVertex declareC:'int *pVertex'.	max _ idxSize-1.	index _ 0.	vtxPtr _ vtxArray-PrimVertexSize. "For one-based indexing"	self cCode:'glBegin(GL_QUADS)'.	[index < max] whileTrue:[		0 to: 3 do:[:i|			pVertex _ vtxPtr + ((idxArray at: index+i) * PrimVertexSize).			self transmitVertex: pVertex.		].				index _ index+4.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:16'!transmitIndexedTriangles: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex vtxPtr |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var: #vtxPtr declareC:'int *vtxPtr'.	self var:#pVertex declareC:'int *pVertex'.	max _ idxSize-1.	index _ 0.	vtxPtr _ vtxArray-PrimVertexSize. "For one-based indexing"	self cCode:'glBegin(GL_TRIANGLES)'.	[index < max] whileTrue:[		0 to: 2 do:[:i|			pVertex _ vtxPtr + ((idxArray at: index+i) * PrimVertexSize).			self transmitVertex: pVertex.		].				index _ index+3.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:16'!transmitLines: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var:#pVertex declareC:'int *pVertex'.	max _ vtxSize.	index _ 0.	pVertex _ vtxArray.	self cCode:'glBegin(GL_LINES)'.	[index < max] whileTrue:[		0 to: 1 do:[:i|			self transmitVertex: pVertex.			pVertex _ pVertex + PrimVertexSize.		].				index _ index+2.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:16'!transmitPoints: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var:#pVertex declareC:'int *pVertex'.	max _ vtxSize.	index _ 0.	pVertex _ vtxArray.	self cCode:'glBegin(GL_POINTS)'.	[index < max] whileTrue:[		self transmitVertex: pVertex.		pVertex _ pVertex + PrimVertexSize.		index _ index+1.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:17'!transmitPolygon: vtxArray size: vtxSize idxData: idxArray size: idxSize	"Transmit the vertex data for the given primitive type"	| max index pVertex |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var:#pVertex declareC:'int *pVertex'.	max _ vtxSize.	index _ 0.	pVertex _ vtxArray.	self cCode:'glBegin(GL_POLYGON)'.	[index < max] whileTrue:[		self transmitVertex: pVertex.		pVertex _ pVertex + PrimVertexSize.		index _ index+1.	].	self cCode:'glEnd()'.	^0! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/14/1999 20:34'!transmitVB: vtxArray size: vtxSize idxData: idxArray size: idxSize type: primitive	"Transmit the actual data from the vertex buffer, depending on the primitive"	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	primitive = PrimTypeIndexedTriangles		ifTrue:[^self transmitIndexedTriangles: vtxArray size: vtxSize idxData: idxArray size: idxSize].	primitive = PrimTypeIndexedQuads		ifTrue:[^self transmitIndexedQuads: vtxArray size: vtxSize idxData: idxArray size: idxSize].	primitive = PrimTypePolygon		ifTrue:[^self transmitPolygon: vtxArray size: vtxSize idxData: idxArray size: idxSize].	primitive = PrimTypePoints		ifTrue:[^self transmitPoints: vtxArray size: vtxSize idxData: idxArray size: idxSize].	primitive = PrimTypeLines		ifTrue:[^self transmitLines: vtxArray size: vtxSize idxData: idxArray size: idxSize].	primitive = PrimTypeIndexedLines		ifTrue:[^self transmitIndexedLines: vtxArray size: vtxSize idxData: idxArray size: idxSize].	^interpreterProxy primitiveFail! !!OSMesaPlugin methodsFor: 'rasterization' stamp: 'ar 2/16/1999 04:20'!transmitVertex: pVertex	self inline: true.	"Set vertex color"	self glColor4ubv: (self cCoerce: ((self cCoerce: pVertex to:'int*')+PrimVtxColor32) to:'GLubyte*').	"Set vertex tex coords"	hasTexture ifTrue:[self glTexCoord2fv: (self cCoerce: ((self cCoerce: pVertex to:'int*')+PrimVtxTexCoords) to:'GLfloat*')].	"Set vertex data"	self glVertex4fv: (self cCoerce: ((self cCoerce: pVertex to:'int*')+PrimVtxRasterPos) to: 'GLfloat*').	^0! !!OSMesaPlugin methodsFor: 'support' stamp: 'ar 2/16/1999 04:02'!flushContext: context	"Flush the given OSMesaContext.	NOTE: Due to possible GC in Squeak we must use glFinish; glFlush is NOT enough.	NOTE: Disabling textures prevents us from GL using an outdated texture pointer."	self var: #context declareC:'OSMesaContext context'.	self cCode:'glDisable(GL_TEXTURE_2D)'.	self cCode:'glFlush()'.	self cCode:'glFinish()'.	^0! !!OSMesaPlugin methodsFor: 'support' stamp: 'ar 2/16/1999 04:06'!loadTexture: context fromForm: textureOop	| form formWidth formHeight formDepth formBits bitsPtr texWrap texInterpolate texEnvMode |	self var: #context declareC:'OSMesaContext context'.	self var: #bitsPtr declareC:'void *bitsPtr'.	"Fetch and validate the form"	form _ textureOop.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isPointers: form)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: form) < 8		ifTrue:[^interpreterProxy primitiveFail].	formBits _ interpreterProxy fetchPointer: 0 ofObject: form.	formWidth _ interpreterProxy fetchInteger: 1 ofObject: form.	formHeight _ interpreterProxy fetchInteger: 2 ofObject: form.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	texWrap _ interpreterProxy booleanValueOf: 		(interpreterProxy fetchPointer: 5 ofObject: form).	texInterpolate _ interpreterProxy booleanValueOf: 		(interpreterProxy fetchPointer: 6 ofObject: form).	texEnvMode _ interpreterProxy fetchInteger: 7 ofObject: form.	interpreterProxy failed ifTrue:[^nil].	(formWidth < 1 or:[formHeight < 1 or:[formDepth ~= 32]])		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: formBits) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy byteSizeOf: formBits) = (formWidth * formHeight * 4)		ifFalse:[^interpreterProxy primitiveFail].	(texEnvMode < 0 or:[texEnvMode > 1])		ifTrue:[^interpreterProxy primitiveFail].	"Now fetch the bits"	bitsPtr _ interpreterProxy firstIndexableField: formBits.	"Set the texture parameters"	texWrap ifTrue:[		self cCode: 'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_REPEAT)'.		self cCode: 'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_REPEAT)'.	] ifFalse:[		self cCode: 'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP)'.		self cCode: 'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP)'.	].	texInterpolate ifTrue:[		self cCode:'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR)'.		self cCode:'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR)'.	] ifFalse:[		self cCode:'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST)'.		self cCode:'glTexParameteri( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST)'.	].	texEnvMode = 0 ifTrue:[		self cCode:'glTexEnvi(GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_MODULATE)'.	] ifFalse:[		self cCode:'glTexEnvi(GL_TEXTURE_ENV , GL_TEXTURE_ENV_MODE , GL_DECAL)'.	].	"Blast out the actual texture"	self cCode:'glHint( GL_PERSPECTIVE_CORRECTION_HINT , GL_NICEST)'.	self cCode:'glPixelStorei( GL_UNPACK_ALIGNMENT , 4)'.	self cCode:'glTexImage2D(GL_TEXTURE_2D, 0, 4, formWidth, formHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, (const GLvoid *) formBits)'.	"And enable texturing"	self cCode:'glEnable(GL_TEXTURE_2D)'.	^0! !!OSMesaPlugin methodsFor: 'support' stamp: 'ar 2/16/1999 06:26'!makeCurrent: context forFormAt: stackIndex	"Make the OSMesaContext current and assign it to the designated form."	| form formWidth formHeight formDepth formBits bitsPtr okay |	self var: #context declareC:'OSMesaContext context'.	self var: #bitsPtr declareC:'void *bitsPtr'.	"Fetch and validate the form"	form _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isPointers: form)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: form) < 4		ifTrue:[^interpreterProxy primitiveFail].	formBits _ interpreterProxy fetchPointer: 0 ofObject: form.	formWidth _ interpreterProxy fetchInteger: 1 ofObject: form.	formHeight _ interpreterProxy fetchInteger: 2 ofObject: form.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	(formWidth < 1 or:[formHeight < 1 or:[formDepth ~= 32]])		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: formBits) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy byteSizeOf: formBits) = (formWidth * formHeight * 4)		ifFalse:[^interpreterProxy primitiveFail].	"Now fetch the bits and make the buffer current"	bitsPtr _ interpreterProxy firstIndexableField: formBits.	okay _ self cCode:'OSMesaMakeCurrent(context, bitsPtr, GL_UNSIGNED_BYTE, formWidth, formHeight)'.	okay ifFalse:[interpreterProxy primitiveFail].	"Finally, set the y-direction to down"	"self cCode:'OSMesaPixelStore(OSMESA_Y_UP, GL_FALSE)'."	self cCode:'glLoadIdentity()'.	self cCode:'glScalef(1.0,-1.0,1.0)'.	self cCode:'glDisable(GL_LIGHTING)'.	^0! !!OSMesaPlugin methodsFor: 'support' stamp: 'ar 2/16/1999 04:28'!setViewport: context fromStackAt: stackIndex	"Set the viewport for the OSMesaContext from the given stack index"	| oop p1 p2 x y w h |	self var: #context declareC: 'OSMesaContext context'.	oop _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isPointers: oop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: oop) < 2		ifTrue:[^interpreterProxy primitiveFail].	p1 _ interpreterProxy fetchPointer: 0 ofObject: oop.	p2 _ interpreterProxy fetchPointer: 1 ofObject: oop.	(interpreterProxy fetchClassOf: p1) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: p2) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	x _ interpreterProxy fetchInteger: 0 ofObject: p1.	y _ interpreterProxy fetchInteger: 1 ofObject: p1.	w _ (interpreterProxy fetchInteger: 0 ofObject: p2) - x.	h _ (interpreterProxy fetchInteger: 1 ofObject: p2) - y.	interpreterProxy failed ifTrue:[^nil].	self cCode:'glViewport(x,y,w,h)'.	^0! !!OSMesaPlugin methodsFor: 'private' stamp: 'ar 2/14/1999 21:54'!fetchOSMesaContextFrom: stackIndex	"Fetch the OSMesaContext from the given stack index.	Validate the time stamp and return the actual context.	If something goes wrong return 0."	| handle handlePtr stamp |	self returnTypeC:'OSMesaContext'.	"Check if we have a valid time stamp for this session"	osMesaTimeStamp = 0 		ifTrue:[^self cCoerce: 0 to:'OSMesaContext'].	"Check if we have a valid handle"	handle _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed 		ifTrue:[^self cCoerce: 0 to:'OSMesaContext'].	(interpreterProxy isBytes: handle)		ifFalse:[^self cCoerce: 0 to:'OSMesaContext'].	(interpreterProxy slotSizeOf: handle) = ((self cCode:'sizeof(OSMesaContext)') + 4)		ifFalse:[^self cCoerce: 0 to:'OSMesaContext'].	handlePtr _ self cCoerce: (interpreterProxy firstIndexableField: handle) to:'int'.	stamp _ self cCode: '*(int*) handlePtr'.	stamp = osMesaTimeStamp		ifFalse:[^self cCoerce: 0 to:'OSMesaContext'].	"Everything looks fine. Return the OSMesaContext."	^self cCode:'*(OSMesaContext*) (handlePtr+4)'.! !!OSMesaPlugin methodsFor: 'private' stamp: 'ar 2/14/1999 20:41'!newSessionTimeStamp	"Create a new time stamp for this session"	| stamp |	stamp _ self cCode:'time(NULL)'.	stamp = 0 ifTrue:[stamp _ 1].	^stamp! !!OSMesaPlugin methodsFor: 'private' stamp: 'ar 2/13/1999 22:49'!version	"Return the version of this interface"	^1! !!OSMesaPlugin class methodsFor: 'translation' stamp: 'ar 2/14/1999 01:16'!declareCVarsIn: cg	"Add the necessary header files"	cg addHeaderFile:'<GL/gl.h>'.	cg addHeaderFile:'<GL/OSMesa.h>'.! !!OSMesaPlugin class methodsFor: 'translation' stamp: 'ar 2/14/1999 01:16'!moduleName	^'sqMesa'! !!OSMesaRasterizer commentStamp: 'ar 2/15/1999 07:36' prior: 0!I am a rasterizer using the Mesa library.!!OSMesaRasterizer methodsFor: 'initialize' stamp: 'ar 2/14/1999 01:49'!canvas: aCanvas	canvas _ aCanvas.! !!OSMesaRasterizer methodsFor: 'initialize' stamp: 'ar 2/13/1999 22:46'!destroy	"Destroy the receiver and all associated resources"	handle finalize.	self unregister.! !!OSMesaRasterizer methodsFor: 'initialize' stamp: 'ar 2/16/1999 02:33'!finish	self form == Display ifTrue:[self form forceToScreen: viewport].! !!OSMesaRasterizer methodsFor: 'initialize' stamp: 'ar 2/13/1999 22:44'!initialize	super initialize.	handle _ self privateCreateHandle.	self register.! !!OSMesaRasterizer methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:50'!form	| f |	canvas ifNotNil:[f _ canvas form].	^f ifNil:[Display]! !!OSMesaRasterizer methodsFor: 'accessing' stamp: 'ar 2/16/1999 17:27'!texture: aForm	"Check if the form is a power of two and 32bit deep"	aForm ifNil:[^texture _ nil].	aForm depth = 32 		ifFalse:[^self error:'OSMesa needs 32bit deep textures'].	(aForm width isPowerOfTwo and:[aForm height isPowerOfTwo])		ifFalse:[^self error:'OSMesa needs powers of two texture size'].	super texture: aForm.! !!OSMesaRasterizer methodsFor: 'processing' stamp: 'ar 2/14/1999 22:23'!clearDepthBuffer	"Clear the OSMesa depth buffer"	self primClearDepthBuffer: handle form: self form.! !!OSMesaRasterizer methodsFor: 'processing' stamp: 'ar 2/16/1999 04:49'!clearViewport: aColor	self primClearViewport: handle 		color: (aColor asColor pixelValueForDepth: 32) 		form: self form		viewport: viewport.! !!OSMesaRasterizer methodsFor: 'processing' stamp: 'ar 2/16/1999 06:36'!processVertexBuffer: vb	"Do the rasterization in one BIG primitive"	self primRasterizeVB: handle 			vertexArray: vb vertexArray 			size: vb vertexCount 			indexArray: vb indexArray 			size: vb indexCount 			primitive: vb primitive 			texture: texture			destination: self form			viewport: viewport.	"self flag: #b3dDebug. self flush."! !!OSMesaRasterizer methodsFor: 'testing' stamp: 'ar 2/14/1999 01:44'!needsClip	"Return true if we need to clip polygons before rasterization.	Mesa can clip for us."	^false! !!OSMesaRasterizer methodsFor: 'registry' stamp: 'ar 2/13/1999 22:44'!register	^self class register: self! !!OSMesaRasterizer methodsFor: 'registry' stamp: 'ar 2/13/1999 22:44'!unregister	^self class unregister: self! !!OSMesaRasterizer methodsFor: 'finalization' stamp: 'ar 2/13/1999 22:45'!executor	"My handle knows how to finalize me"	^handle! !!OSMesaRasterizer methodsFor: 'private' stamp: 'ar 2/13/1999 22:41'!privateCreateHandle	"Create a new OSMesaHandle.	Note: The actual primitive will create a ByteArray.		For finalization we copy this ByteArray into an OSMesaHandle."	| byteHandle osMesaHandle |	byteHandle _ self primCreateHandle.	osMesaHandle _ OSMesaHandle new: byteHandle size.	osMesaHandle replaceFrom: 1 to: byteHandle size with: byteHandle startingAt: 1.	^osMesaHandle! !!OSMesaRasterizer methodsFor: 'primitives' stamp: 'ar 2/14/1999 22:24'!primClearDepthBuffer: aHandle form: aForm	<primitive:'b3dClearDepthBuffer' module:'sqMesa'>	^self primitiveFailed! !!OSMesaRasterizer methodsFor: 'primitives' stamp: 'ar 2/16/1999 04:49'!primClearViewport: aHandle color: pixelValue32 form: aForm viewport: aViewport	<primitive: 'b3dClearViewport' module:'sqMesa'>	^self primitiveFailed! !!OSMesaRasterizer methodsFor: 'primitives' stamp: 'ar 2/13/1999 22:42'!primCreateHandle	"Primitive. Create a new OSMesa handle"	<primitive:'b3dCreateHandle' module:'sqMesa'>	^self primitiveFailed! !!OSMesaRasterizer methodsFor: 'primitives' stamp: 'ar 2/16/1999 03:20'!primRasterizeVB: aHandle vertexArray: vertexArray size: vertexCount indexArray: indexArray size: indexCount primitive: primitiveType texture: textureForm destination: aForm viewport: vp 	<primitive:'b3dRasterizeVertexBuffer' module:'sqMesa'>	aForm depth = 32 ifFalse:[^self error:'OSMesa does only work in 32bit depth'].	^self primitiveFailed! !!OSMesaRasterizer class methodsFor: 'accessing' stamp: 'ar 2/13/1999 22:43'!version	"Return the version of this rasterizer"	<primitive:'b3dGetVersion' module:'sqMesa'>	^0! !!OSMesaRasterizer class methodsFor: 'testing' stamp: 'ar 2/14/1999 01:41'!isAvailable	"Return true if we can actually use an OSMesaRasterizer"	^self version > 0! !!OSMesaRasterizer class methodsFor: 'testing' stamp: 'ar 2/16/1999 17:36'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available"	^self isAvailable and:[(anOutputMedium isKindOf: Form) and:[anOutputMedium depth = 32]]! !!OSMesaRasterizer class methodsFor: 'registry' stamp: 'ar 2/13/1999 22:44'!register: anObject	self registry add: anObject! !!OSMesaRasterizer class methodsFor: 'registry' stamp: 'ar 2/13/1999 22:44'!registry	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!OSMesaRasterizer class methodsFor: 'registry' stamp: 'ar 2/13/1999 22:45'!unregister: anObject	self registry remove: anObject ifAbsent:[]! !!OSMesaRenderEngine commentStamp: 'ar 2/15/1999 07:40' prior: 0!This render engine uses the OSMesaRasterizer for the purpose of rasterization. Besides that it is just a regular Balloon 3D render engine. Note that we could actually use more of the Mesa interface - our transform, lighting, and clipping modules are pretty compatible with the OpenGL definitions. I'm just not interested in doing this, but if anyone is, then here is the place to work on: Simply replace the transformer, shader, and clipper with appropriate OSMesa objects (using one and the same handle - e.g., the OSMesaContext should probably be stored in the engine directly) and pass the data immediately down to the primitive level. !!OSMesaRenderEngine class methodsFor: 'accessing' stamp: 'ar 2/14/1999 01:42'!rasterizer	^OSMesaRasterizer! !B3DEnginePart removeSelector: #primProcessVB:count:type:!B3DEnginePart initialize!B3DEnginePlugin removeSelector: #b3dTransformVertexBuffer!B3DEnginePlugin removeSelector: #b3dTransformPrimitiveNormal!B3DEnginePlugin removeSelector: #transformPrimitiveNormal:by:rescale:!B3DEnginePlugin removeSelector: #b3dTransformPrimitivePosition!B3DEnginePlugin removeSelector: #b3dTransformPrimitiveRasterPosition!B3DEnginePlugin removeSelector: #b3dTransformPrimitiveVertex3!B3DEnginePlugin removeSelector: #transformMatrix:with:into:!B3DEnginePlugin removeSelector: #transformPrimitivePosition:by:!B3DEnginePlugin removeSelector: #b3dTransformPrimitiveVertex4!B3DEnginePlugin removeSelector: #transformPrimitivePositionFast:by:!B3DEnginePlugin removeSelector: #transformPrimitiveRasterPosition:by:!B3DEnginePlugin removeSelector: #transformVB:count:by:and:flags:!B3DEnginePlugin removeSelector: #transformPrimitiveNormal:by:!B3DEnginePlugin removeSelector: #b3dTransformPrimitiveVertex!B3DEnginePlugin removeSelector: #analyzeMatrix3x3Length:!B3DEnginePlugin removeSelector: #transformPrimitivePosition:by:rescale:!B3DEnginePlugin removeSelector: #analyzeMatrix:!B3DEnginePlugin removeSelector: #b3dTransformMatrixWithInto!B3DEnginePlugin removeSelector: #transformPrimitivePositionFaster:by:!B3DExponentTable class removeSelector: #new:!B3DExponentTable class removeSelector: #new:using:!B3DExponentTable initialize!B3DExponentTable class removeSelector: #elementSize!B3DExponentTable removeSelector: #at:!B3DIndexedMesh removeSelector: #oldRenderOn:!B3DIndexedMesh removeSelector: #sampleRect!B3DIndexedMesh initialize!B3DIndexedQuadMesh removeSelector: #sampleRect!B3DIndexedTriangleMesh removeSelector: #reArrangeFanFaces:around:excluding:!B3DIndexedTriangleMesh removeSelector: #reArrangeFanFaces:around:!B3DIndexedTriangleMesh removeSelector: #sampleRect!B3DColor4Array removeSelector: #at:!B3DColor4Array removeSelector: #at:put:!B3DColor4Array removeSelector: #size!B3DIndexedTriangleArray removeSelector: #asB3DIndexArray!B3DColor4Array class removeSelector: #new:!B3DLightAttenuation class removeSelector: #ambientPart!B3DLightSource removeSelector: #shininess!B3DPositionalLight removeSelector: #shadeVertexBuffer:with:into:!B3DPrimitiveLight removeSelector: #ambientPart!B3DPrimitiveVertexArray class removeSelector: #initialize!B3DRenderEngine removeSelector: #indexedTriangleMesh:vertices:!B3DRenderEngine removeSelector: #indexedTriangleMesh:vertices:texCoords:!B3DRenderEngine removeSelector: #indexedTriangleMesh:vertices:colors:!B3DRenderEngine removeSelector: #indexedLines:vertices:normals:colors:texCoords:!B3DRenderEngine removeSelector: #indexedTriangles:vertices:normals:colors:texCoords:!B3DRenderEngine removeSelector: #indexedTriangleMesh:vertices:normals:colors:texCoords:!B3DRenderEngine removeSelector: #indexedTriangleMesh:vertices:normals:!B3DSTriangleMesh removeSelector: #separateVerticesFrom3DS:!B3DSTriangleMesh removeSelector: #computeVertexSmoothMasks!B3DSTriangleMesh removeSelector: #splitNonSmoothVertices:!B3DShaderPlugin removeSelector: #addPart:trackFlag:from:scale:!B3DShaderPlugin removeSelector: #computeAmbientPart!B3DShaderPlugin removeSelector: #computeSpecularPart!B3DShaderPlugin removeSelector: #computeDiffusePart!B3DShaderPlugin removeSelector: #shadeVertex:with:from:into:!B3DShaderPlugin removeSelector: #addPart:trackFlag:scale:!B3DSpotLight removeSelector: #spotExponent!B3DTransformerPlugin removeSelector: #stackMatrix:!B3DTransformerPlugin removeSelector: #stackPrimitiveVertex:!B3DTransformerPlugin removeSelector: #stackPrimitiveVertexArray:ofSize:!B3DVector2 removeSelector: #u:w:!B3DVector2 class removeSelector: #u:w:!B3DVector3Array removeSelector: #at:!B3DVertexBuffer removeSelector: #loadIndexes:!B3DVertexBuffer removeSelector: #privateLoadVertices:normals:colors:texCoords:!B3DVertexBuffer removeSelector: #trackVertexColors!B3DVertexBuffer removeSelector: #privateAddVertex!B3DVertexBuffer removeSelector: #loadVertices:!B3DVertexBuffer removeSelector: #privateLoadIndexArray:count:!B3DVertexBuffer removeSelector: #loadVertices:normals:colors:texCoords:!B3DVertexBuffer removeSelector: #privateLoadVertices:normals:colors:texCoords:count:default:!B3DVertexBuffer removeSelector: #privateLoadIndexArray:count:max:offset:!B3DVertexBuffer removeSelector: #privateLoadVertices:normals:colors:texCoords:count:!B3DVertexBuffer class removeSelector: #initialize!B3DVertexClipper removeSelector: #oldprocessIndexedTriangles:!B3DVertexClipper removeSelector: #oldprocessIndexedQuads:!B3DVertexClipper removeSelector: #xb!B3DVertexClipper initialize!B3DSqueakFormRasterizer removeSelector: #clearViewport:!B3DSqueakFormRasterizer removeSelector: #processVertexBuffer:!B3DVertexRasterizer class removeSelector: #isAvailableFor:!B3DVertexRasterizer class removeSelector: #isAvailable!B3DVertexShader removeSelector: #primShadeVertices:with:into:!B3DVertexTransformer removeSelector: #privateTransformVB:count:modelViewMatrix:projectionMatrix:!B3DViewport removeSelector: #toggleScale!OSMesaPlugin removeSelector: #transmit:size:idxData:size:!OSMesaPlugin removeSelector: #transmitIndexedTriangle:size:idxData:size:!OSMesaRasterizer removeSelector: #primProcessVB:vtxArray:size:idxArray:size:primitive:flags:destForm:viewport:!OSMesaRasterizer removeSelector: #primRasterizeVB:vertexArray:size:indexArray:size:primitive:flags:destination:viewport:!OSMesaRasterizer removeSelector: #primClearViewport:color:form:!OSMesaRasterizer removeSelector: #flush!OSMesaRasterizer removeSelector: #primRasterizeVB:vertexArray:size:indexArray:size:primitive:flags:viewport:destination:!OSMesaRasterizer removeSelector: #primClearViewport:color:!