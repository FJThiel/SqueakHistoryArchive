'From Squeak3.1alpha of 28 February 2001 [latest update: #4079] on 28 May 2001 at 3:11:59 pm'!"Change Set:		StackSummary-tkDate:			28 May 2001Author:			Ted KaehlerAdds menu item to StackMorphs: 'Find via this Template'.  The current card is taken to have search keys in each field.  All cards that match all keys in the corresponding fields are displayed in a list.  Click on any item to see that card in the stack.  (In homage to Steve Weyer's FindIt information retrieval system from the mid-1970s."!Player subclass: #CardPlayer	instanceVariableNames: 'privateMorphs properties '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Stacks'!!CardPlayer commentStamp: 'tk 5/26/2001 10:10' prior: 0!CardPlayer	Instance variables of the Uniclass represent the data in the "fields" of each card in the stack.	Each Instance variable is some kind of value holder.	The code for the *buttons* on the background resides in the CardPlayer uniclass.privateMorphs -- OrderedCollection of objects specific to this card.properties -- Dictionary of extra things 			like matches when this card used as a search template.!!CardPlayer methodsFor: 'card data' stamp: 'tk 5/28/2001 14:54'!allStringsAfter: aText	| list ok instVarValue string |	"return an OrderedCollection of strings of text in my instance vars.  If aText is non-nil, begin with that object."	list _ OrderedCollection new.	ok _ aText == nil.	self class variableDocks do: [:vdock |		instVarValue _ self perform: vdock playerGetSelector.		ok ifFalse: [ok _ instVarValue == aText].		"and do this one too"		ok ifTrue: [string _ nil.			instVarValue isString ifTrue: [string _ instVarValue].			instVarValue isText ifTrue: [string _ instVarValue string].			instVarValue isNumber ifTrue: [string _ instVarValue printString].			instVarValue isMorph ifTrue: [string _ instVarValue userString].	"not used"			string ifNotNil: [string isString 					ifTrue: [list add: string]					ifFalse: [list addAll: string]]]].	privateMorphs ifNotNil: [		privateMorphs do: [:mm | list addAll: (mm allStringsAfter: nil)]].	^ list! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:42'!asKeys	| keys kk vd gotData |	"Take my fields, tokenize the text, and return as an array in the same order as variableDocks.  Simple background fields on the top level.  If no data, return nil."	keys _ self class variableDocks copy.	gotData _ false.	1 to: keys size do: [:ind |		kk _ nil.		vd _ self class variableDocks at: ind.		vd type == #text ifTrue: [			kk _ (self perform: vd playerGetSelector) string					findTokens: Character separators.			kk isEmpty ifTrue: [kk _ nil] ifFalse: [gotData _ true]].		keys at: ind put: kk].	^ gotData ifTrue: [keys] ifFalse: [nil]! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:02'!match: keys fields: docks	| longString |	"see if each key occurs in my corresponding text instance."	keys withIndexDo: [:kk :ind |		kk ifNotNil: [			longString _ (self perform: (docks at: ind) playerGetSelector) string.			kk do: [:aKey |				((longString findString: aKey startingAt: 1 caseSensitive: false) > 0)					ifFalse: [^ false]]]]. 	"all keys must match"	^ true! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/28/2001 14:44'!matchNames	| list str ll |	"List of names of cards that matched the last template search."	properties ifNil: [^ #()].	list _ properties at: #matchList ifAbsent: [^ #()].	^ list collect: [:cd | 		str _ ''.		(ll _ cd allStringsAfter: nil) ifNotNil: [			str _ ll inject: '' into: [:strr :this | strr, this]]. 		(str copyFrom: 1 to: (30 min: str size)), ' (' , cd hash printString, ')'].		"Maybe include a card title?"! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/26/2001 10:30'!matchIndex	| |	"One we are looking at, in cards that matched the last template search."	properties ifNil: [^ 0].	^ properties at: #matchIndex ifAbsent: [0].! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/26/2001 10:55'!matchIndex: newPlace	"One we are looking at, in cards that matched the last template search."	properties ifNil: [properties _ IdentityDictionary new].	properties at: #matchIndex put: newPlace.	newPlace = 0 ifTrue: [^ self].	(costume valueOfProperty: #myStack ifAbsent: [^ self]) goToCard: 		((properties at: #matchList ifAbsent: [^ self]) at: newPlace).	self changed: #matchIndex.	"update my selection"! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/26/2001 10:42'!properties	^ properties! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/28/2001 14:51'!findText: keys inStrings: rawStrings	startAt: startIndex container: oldContainer cardNum: cardNum	"Call once to search a card of the stack.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start strings old |	good _ true.	start _ startIndex.	strings _ oldContainer 			ifNil: [rawStrings]	"normal case"			ifNotNil: [self currentPage allStringsAfter: oldContainer text].	keys do: [:searchString | "each key"		good ifTrue: [thisWord _ false.			strings do: [:longString |				(index _ longString findString: searchString startingAt: start 					caseSensitive: false) > 0 ifTrue: [						thisWord not & (searchString == (keys at: 1)) ifTrue: [							insideOf _ longString. place _ index].						thisWord _ true].				start _ 1].	"only first key on first container"			good _ thisWord]].	good ifTrue: ["all are on this page"		"wasIn _ (pages at: pageNum) isInMemory."		self goToCardNumber: cardNum.		"wasIn ifFalse: ['search again, on the real current text.  Know page is in.'.			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil)         recompute it					startAt: startIndex container: oldContainer 				pageNum: pageNum]" 			].	(old _ self valueOfProperty: #searchContainer) ifNotNil: [		(old respondsTo: #editor) ifTrue: [			old editor selectFrom: 1 to: 0. 	"trying to remove the previous selection!!"			old changed]].	good ifTrue: ["have the exact string object"		(container _ oldContainer)			ifNil: [container _ self highlightText: (keys at: 1) at: place in: insideOf]			ifNotNil: [				container userString == insideOf 					ifFalse: [						container _ self highlightText: (keys at: 1) at: place 							in: insideOf]					ifTrue: [(container isKindOf: TextMorph) ifTrue: [						container editor selectFrom: place to: 								(keys at: 1) size - 1 + place.						container changed].						]].		self setProperty: #searchContainer toValue: container.		self setProperty: #searchOffset toValue: place.		self setProperty: #searchKey toValue: keys.		"override later"		ActiveHand newKeyboardFocus: container.		^ true].	^ false! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/28/2001 15:07'!findViaTemplate	| list pl dd |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	list _ self templateMatches.	"put up a PluggableListMorph"	dd _ (self currentCard properties) ifNil: [		self currentCard matchIndex: 1.	"to create the properties dictionary"		self currentCard properties].	dd at: #matchList put: list.	self currentPage setProperty: #myStack toValue: self.	"way to get back"	pl _ PluggableListMorph new			on: self currentCard list: #matchNames			selected: #matchIndex changeSelected: #matchIndex:			menu: nil "#matchMenu:shifted:" keystroke: nil.	pl color: (Color blue mixed: 0.17 with: Color white).	pl toggleCornerRounding; width: 232; retractableOrNot.	ActiveHand attachMorph: pl.! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/28/2001 14:59'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack'.	aMenu addStayUpItem.	aMenu addList: #(		('find...'								textSearch)		('find via this template'					findViaTemplate)		('show designations' 					showDesignationsOfObjects)		('explain designations'					explainDesignations)		"('look inside'							openInsideLook)"		-		('previous card' 						goToPreviousCardInStack)		('next card' 							goToNextCardInStack)		('first card' 							goToFirstCardOfStack)		('last card' 								goToLastCardOfStack)		('go to card...' 							goToCard)		-		('add a card of this background' 		insertCard)		('add a card of background...'		 	insertCardOfBackground)		('make a new background...' 			makeNewBackground)		-		('delete this card' 						deleteCard)		-		('move card to front of stack'			makeCurrentCardFirstInStack)		('move card to back of stack'			makeCurrentCardLastInStack)		('move card one position earlier'			moveCardOnePositionEarlier)		('move card one position later'			moveCardOnePositionLater)		-		('scripts for this background'			browseCardClass)		-		('debug...'								offerStackDebugMenu)		('bookish items...' 						offerBookishMenu)).	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/25/2001 17:18'!templateMatches	| template docks keys bkg |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	template _ self currentCard.	template commitCardPlayerData.	docks _ template class variableDocks.	(keys _ template asKeys) ifNil: [^ #()]. "nothing to match against"	bkg _ self currentPage.	^ cards select: [:cardPlayer | 		(((cardPlayer == template) not) and: [cardPlayer costume == bkg]) 			and: [cardPlayer match: keys fields: docks]].! !!VariableDock methodsFor: 'accessing' stamp: 'tk 5/25/2001 17:43'!playerGetSelector	^playerGetSelector! !!VariableDock methodsFor: 'accessing' stamp: 'tk 5/25/2001 17:43'!type	^type! !