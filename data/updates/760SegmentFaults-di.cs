'From Squeak 2.3 of January 14, 1999 on 28 March 1999 at 10:24:03 am'!"Change Set:		SegmentFaultsDate:			26 March 1999Author:			Dan IngallsThis changeSet finally assembles the ability to save and load image segments with the ability to detect message faults and methodDict faults.  It also defines two formats for segments on disk, one that is very fast, and one that would save more space in the host image, but that requires rehashing because Symbols could get new oops.Various informal tests in ImageSegment include	Discovering inactive classes by inducing them to fault on null methodDicts.	Computing a deepCopy of every class in the system.	Writing all inactive classes out to disk in segments by category.	Writing all projects other than the current one out to disk in segments."!nil subclass: #ImageSegmentRootStub	instanceVariableNames: 'shadowSuper shadowMethodDict shadowFormat imageSegment '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state fileName '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!!ImageSegmentRootStub commentStamp: 'di 3/26/1999 21:47' prior: 0!An ImageSegmentRootStub is a stub that replaces one of the root of an ImageSegment that has been extracted from the Squeak ObjectMemory.  It has two very simple roles:1.  If any message is sent to one of these objects, it will be caught by doesNotUnderstand:, and bring about a reinstallation of the missing segment.  This exception is caused by the fact that no other messages are defined in this class, and neither does it inherit any from above, since its superclass is nil.  When the reinstallation has been accomplished, the message will be resent as though nothing was amiss.2.  If one of these objects is a class, and a message is sent to one of its instances, it will cause a similar fault which will be caught by cannotInterpret:.  This exception is caused by a somewhat more subtle condition:  the primitive operations of the virtual machine do not have time to check whether classes are resident or not -- they assume that all classes are resident.  However every non-cached message lookup does test for a nil in the methodDictionary slot.  If a rootStub replaces a class (or any behavior), it masquerades as the class, but it will have a nil in the slot where the method Dictionary is expected.  This will cause the VM to send cannotInterpret:, eventually leading to the same process for reinstalling the missing segment and resending the message as above.Just to be on the safe side, a rootStub that replaces a Behavior also carries a copy of both the superclass and format fields from the original class.  This insures that, even if some operations of the VM require these values, things will continue to operate properly when the segment is absent.!!ImageSegmentRootStub methodsFor: 'as yet unclassified' stamp: 'di 3/27/1999 22:34'!doesNotUnderstand: aMessage 	 "Any normal message sent to this object is really intended for another object that is in a non-resident imageSegment.  Reinstall the segment and resend the message."	imageSegment install.	^ self perform: aMessage selector withArguments: aMessage arguments! !!ImageSegmentRootStub methodsFor: 'as yet unclassified' stamp: 'di 3/27/1999 12:19'!xxSuperclass: superclass format: format segment: segment	"Set up fields like a class but with null methodDict"	shadowSuper _ superclass.	shadowMethodDict _ nil.	shadowFormat _ format.	imageSegment _ segment.! !!Object methodsFor: 'system primitives' stamp: 'di 3/27/1999 12:21'!rootStubInImageSegment: imageSegment	^ ImageSegmentRootStub new		xxSuperclass: nil		format: nil		segment: imageSegment! !!Array methodsFor: 'converting' stamp: 'di 3/28/1999 10:22'!elementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	self primitiveFailed! !!Array methodsFor: 'converting' stamp: 'di 3/28/1999 10:23'!elementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Behavior methodsFor: 'accessing' stamp: 'di 3/27/1999 23:19'!methodDict	methodDict == nil ifTrue: [self recoverFromMDFault].	^ methodDict! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 3/27/1999 13:02'!rootStubInImageSegment: imageSegment 	^ ImageSegmentRootStub new		xxSuperclass: superclass		format: format		segment: imageSegment! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 3/27/1999 23:21'!selectorAtMethod: method setClass: classResultBlock 	"Answer both the message selector associated with the compiled method 	and the class in which that selector is defined."	| sel |	sel _ self methodDict keyAtIdentityValue: method				ifAbsent: 					[superclass == nil						ifTrue: 							[classResultBlock value: self.							^self defaultSelectorForMethod: method].					sel _ superclass selectorAtMethod: method setClass: classResultBlock.					"Set class to be self, rather than that returned from 					superclass. "					sel == (self defaultSelectorForMethod: method) ifTrue: [classResultBlock value: self].					^sel].	classResultBlock value: self.	^sel! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 3/27/1999 23:20'!includesSelector: aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^ self methodDict includesKey: aSymbol! !!Behavior methodsFor: 'private' stamp: 'di 3/27/1999 23:26'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ self methodDict at: selector ifAbsent: [^ self].	methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/27/1999 23:54'!induceMDFault	"Stache a copy of the methodDict in the organization slot (hack!!),	and set the methodDict to nil.  This will induce an MD fault on any message send.	See: ImageSegment discoverActiveClasses."	organization _ Array with: methodDict with: organization.	methodDict _ nil.	self flushCache! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/27/1999 23:53'!recoverFromMDFault	(organization isMemberOf: Array) ifFalse: [^ self error: 'oops'].	methodDict _ organization first.	organization _ organization second.! !!ImageSegment commentStamp: 'di 3/27/1999 22:30' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  Within my segment are indices into my table of outPointers.I may exist in several states...#activeCopyarrayOfRoots segment outPointers are all as created by the copyFromRoots: initialization message.  Nothing else has changed about the Squeak system.#activeEach of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only the array of outPointers remains in the image.NOTE: All IdentitySets or dictionaries with internal keys (not in outPointers) must be rehashed when being read back from this format.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.NOTE: All IdentitySets or dictionaries with internal keys (not in outPointers) must be rehashed when being read back from this format.  This will be almost all (including MethodDictionaries), since symbols are effectively internal.#onFileExternalIn this state, the entire outPointers array is on lie as well as the segment.  The table of outPointers has been enternalized in such a manner that it can be exported to a foreign image (with its segment file).  In this form the segment can be read from, eg, a URL, and installed with the resulting value being the original array of root objects, with former outPointers bound in some appropriate manner to existing objects in the host system.  More complex processing is required to read such a file and internalize the outPointers.#inactiveIn this state, the rootsArray is set, but the segment is invalid.!!ImageSegment reorganize!('initialization' copyFromRoots:)('changing state' extract extractThenInstall install readFromFile segmentCopy writeToFile: writeToFileWithSymbols:)('primitives' loadSegmentFrom:withOutPointers: storeSegmentFor:into:withOutPointers:)('testing' deepCopyTest: errorWrongState verify:matches:knowing: verifyCopy)!!ImageSegment methodsFor: 'initialization' stamp: 'di 3/26/1999 23:11'!copyFromRoots: aRootArray 	| segmentWordArray outPointerArray segSize |	aRootArray ifNil: [self errorWrongState].	arrayOfRoots _ aRootArray.	segSize _ 50000.		["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	outPointerArray _ Array new: segSize // 20.	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					withOutPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/27/1999 22:24'!extract	"This operation replaces (using become:) all the original roots of a segment with segmentRootStubs.  Thus the original objects will be reclaimed, and the root stubs will remain to bring the segment back in if it is needed."	state = #inactive ifTrue: [self copyFromRoots: arrayOfRoots].	state = #activeCopy ifFalse: [self errorWrongState].	arrayOfRoots elementsForwardIdentityTo:		(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).	state _ #active! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/27/1999 22:22'!extractThenInstall	"For testing only"	| newRoots |	state = #activeCopy ifFalse: [self errorWrongState].	arrayOfRoots elementsForwardIdentityTo:		(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).	state _ #active.	newRoots _ self loadSegmentFrom: segment withOutPointers: outPointers.	state _ #inactive.	arrayOfRoots elementsForwardIdentityTo: newRoots.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/27/1999 22:15'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	state = #active ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment withOutPointers: outPointers.	state _ #inactive.	arrayOfRoots elementsForwardIdentityTo: newRoots.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/28/1999 00:42'!readFromFile	| f |	f _ FileStream oldFileNamed: fileName.	segment _ f nextInto: (WordArray new: f size//4).	f close.	state _ #active! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/27/1999 08:30'!segmentCopy	"This operation will install a copy of the segment in memory, and return a copy of the array of roots.  The effect is to perform a deep copy of the original structure.  Note that installation destroys the segment, so it must be copied before doing the operation."	state = #activeCopy ifFalse: [self errorWrongState].	^ self loadSegmentFrom: segment copy withOutPointers: outPointers! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/28/1999 00:36'!writeToFile: shortName	state = #active ifFalse: [self error: 'wrong state'].	(shortName endsWith: '.seg')		ifTrue: [fileName _ shortName]		ifFalse: [fileName _ shortName , '.seg'].	(FileStream newFileNamed: fileName) nextPutAll: segment; close.	segment _ nil.	state _ #onFile! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/26/1999 16:41'!writeToFileWithSymbols: shortName	| symbols nonSymbols pound |	state = #extracted ifFalse: [self error: 'wrong state'].	(shortName endsWith: '.seg')		ifTrue: [fileName _ shortName]		ifFalse: [fileName _ shortName , '.seg'].	symbols _ OrderedCollection new.	nonSymbols _ OrderedCollection new.	pound _ '#' asSymbol.	outPointers do:		[:s | 		((s isMemberOf: Symbol) and: [s isLiteral and: [s ~~ pound]])			ifTrue: [symbols addLast: s]			ifFalse: [symbols addLast: pound.  nonSymbols addLast: s]].	(FileStream newFileNamed: fileName)		store: symbols asArray; cr;		nextPutAll: segment; close.	outPointers _ nonSymbols asArray.	state _ #onFileWithSymbols! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/28/1999 09:43'!deepCopyTest: aRootArray	"ImageSegment new deepCopyTest: Morph withAllSubclasses asArray"	"Project allInstances do:		[:p | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			ImageSegment new deepCopyTest: (Array with: p)]]."	| t1 t2 copy |	t1 _ Time millisecondsToRun: [self copyFromRoots: aRootArray].	t2 _ Time millisecondsToRun: [copy _ self segmentCopy].	Transcript cr; print: segment size * 4; nextPutAll: ' bytes stored with ';		print: outPointers size; show: ' outpointers in '; print: t1; show: 'ms.'.	Transcript cr; nextPutAll: 'Reconstructed in '; print: t2; show: 'ms.'.	^ copy"Smalltalk allClasses do:	[:m | ImageSegment new deepCopyTest: (Array with: m)]"! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/26/1999 22:51'!errorWrongState	^ self error: 'wrong state'! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/27/1999 22:04'!verify: ob1 matches: ob2 knowing: matchDict	| priorMatch first |	ob1 == ob2 ifTrue:		["If two pointers are same, they must be ints or in outPointers"		((ob1 isMemberOf: SmallInteger) and: [ob1 = ob2]) ifTrue: [^ self].		((ob1 isKindOf: Behavior) and: [ob1 indexIfCompact = ob2 indexIfCompact]) ifTrue: [^ self].		(outPointers includes: ob1) ifTrue: [^ self].		self halt].	priorMatch _ matchDict at: ob1 ifAbsent: [nil].	priorMatch == nil		ifTrue: [matchDict at: ob1 put: ob2]		ifFalse: [priorMatch == ob2					ifTrue: [^ self]					ifFalse: [self halt]].	self verify: ob1 class matches: ob2 class knowing: matchDict.	ob1 class isVariable ifTrue: 		[ob1 basicSize = ob2 basicSize ifFalse: [self halt].		first _ 1.		(ob1 isMemberOf: CompiledMethod) ifTrue: [first _ ob1 initialPC].		first to: ob1 basicSize do:			[:i | self verify: (ob1 basicAt: i) matches: (ob2 basicAt: i) knowing: matchDict]].	ob1 class instSize = ob2 class instSize ifFalse: [self halt].	1 to: ob1 class instSize do:		[:i | self verify: (ob1 instVarAt: i) matches: (ob2 instVarAt: i) knowing: matchDict].	(ob1 isMemberOf: CompiledMethod) ifTrue:		[ob1 header = ob2 header ifFalse: [self halt].		ob1 numLiterals = ob2 numLiterals ifFalse: [self halt].		1 to: ob1 numLiterals do:			[:i | self verify: (ob1 literalAt: i) matches: (ob2 literalAt: i) knowing: matchDict]]! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/27/1999 21:36'!verifyCopy	| copyOfRoots matchDict |	copyOfRoots _ self segmentCopy.	matchDict _ IdentityDictionary new.	arrayOfRoots with: copyOfRoots do:		[:r :c | self verify: r matches: c knowing: matchDict]! !!ImageSegment class reorganize!('testing' discoverActiveClasses restoreMDFaults swapOutInactiveClasses swapOutProjects testClassFaultOn:)!!ImageSegment class methodsFor: 'testing' stamp: 'di 3/28/1999 10:16'!discoverActiveClasses   "ImageSegment discoverActiveClasses" 	"Run this method, do a few things, save and resume the image.	This will leave unused classes with MDFaults.	You MUST follow this soon by restoreMDFaults, or by swapOutInactiveClasses."	| ok |	Smalltalk allClasses do:		[:c | ok _ true.		#(Array Object Class Message MethodDictionary) do:			[:n | ((Smalltalk at: n) == c or:				[(Smalltalk at: n) inheritsFrom: c]) ifTrue: [ok _ false]].		ok ifTrue: [c induceMDFault]].! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/27/1999 23:56'!restoreMDFaults   "ImageSegment restoreMDFaults"	"Restore all remaining MD faults and report the number of unused classes"	| unused |	unused _ Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil].	unused do: [:c | c recoverFromMDFault].	PopUpMenu notify: unused size printString , ' out of ' ,			Smalltalk allClasses size printString , 'classeshave not been used.'.! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/28/1999 10:15'!swapOutInactiveClasses  "ImageSegment swapOutInactiveClasses"  	"Make up segments by grouping unused classes by system category.	Read about, and execute discoverActiveClasses, and THEN execute this one."	| unused groups i roots |	ImageSegment recoverFromMDFault.	ImageSegmentRootStub recoverFromMDFault.	unused _ Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil].	unused do: [:c | c recoverFromMDFault].	groups _ Dictionary new.	SystemOrganization categories do:		[:cat |		i _ (cat findLast: [:c | c = $-]) - 1.		i <= 0 ifTrue: [i _ cat size].		groups at: (cat copyFrom: 1 to: i)			put: (groups at: (cat copyFrom: 1 to: i) ifAbsent: [Array new]) ,			((SystemOrganization superclassOrder: cat) select: [:c | unused includes: c]) asArray].	groups keys do:		[:cat | roots _ groups at: cat.		Transcript cr; cr; show: cat; cr; print: roots; endEntry.		roots _ roots , (roots collect: [:c | c class]).		(cat beginsWith: 'Sys' "something here breaks") ifFalse:			[(ImageSegment new copyFromRoots: roots) extract; writeToFile: cat].		Transcript cr; print: Smalltalk garbageCollect; endEntry]! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/28/1999 09:53'!swapOutProjects  "ImageSegment swapOutProjects"  	"Swap out segments for all projects other than the current one."	| spaceLeft newSpaceLeft |	spaceLeft _ Smalltalk garbageCollect.	Project allInstances doWithIndex:		[:p :i | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			(ImageSegment new copyFromRoots: (Array with: p))				extract; writeToFile: 'project' , i printString.			newSpaceLeft _ Smalltalk garbageCollect.			Transcript cr; print: newSpaceLeft - spaceLeft; endEntry.			spaceLeft _ newSpaceLeft]].! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/28/1999 10:05'!testClassFaultOn: someClass  "ImageSegment testClassFaultOn: FileList"  	"Swap out a class with an existing instance.  Then send a message to the inst.	This will cause the VM to choke down deep and resend #cannotInterpret:.	This in turn will send a message to the stubbed class which will choke	and resend: #doesNotUnderstand:.  Then, if we're lucky, things will start working."	(ImageSegment new copyFromRoots: (Array with: someClass with: someClass class))				extract; writeToFile: 'test'.! !!ObjectMemory methodsFor: 'become' stamp: 'di 3/28/1999 08:03'!restoreHeadersAfterBecoming: list1 with: list2	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."	| fieldOffset oop1 oop2 hdr1 hdr2 |	fieldOffset _ self lastPointerOf: list1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: list1 + fieldOffset.		oop2 _ self longAt: list2 + fieldOffset.		self restoreHeaderOf: oop1.		self restoreHeaderOf: oop2.		"Exchange has bits of the two objects."		hdr1 _ self longAt: oop1.		hdr2 _ self longAt: oop2.		self longAt: oop1 put:			((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).		self longAt: oop2 put:			((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).		fieldOffset _ fieldOffset - 4.	].! !!ObjectMemory methodsFor: 'become' stamp: 'di 3/28/1999 08:23'!restoreHeadersAfterForwardBecome	"Forward become leaves us with no original oops in the mutated object list,	so we must enumerate the (four-word) forwarding blocks	where we have stored backpointers."	| oop1 fwdBlock oop2 hdr1 hdr2 |	"This loop start is copied from fwdBlockGet:"	fwdBlock _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdBlock _ fwdBlock + 16.  "fwdBlockGet: did a pre-increment"	[fwdBlock <= fwdTableNext]  "fwdTableNext points to the last active block"		whileTrue:		[oop1 _ self longAt: fwdBlock + 8.  "Backpointer to mutated object."		oop2 _ self longAt: fwdBlock.		self restoreHeaderOf: oop1.		"Change the hash of the new oop (oop2) to be that of the old (oop1)		so mutated objects in hash structures will be happy after the change."		hdr1 _ self longAt: oop1.		hdr2 _ self longAt: oop2.		self longAt: oop2 put:			((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).		fwdBlock _ fwdBlock + 16].! !!Interpreter methodsFor: 'control primitives' stamp: 'di 3/28/1999 08:33'!primitivePerformInSuperclass	| lookupClass rcvr currentClass |	lookupClass _ self stackTop.	rcvr _ self stackValue: 3.	currentClass _ self fetchClassOf: rcvr.	[currentClass ~= lookupClass]		whileTrue:		[currentClass _ self superclassOf: currentClass.		currentClass = nilObj ifTrue: [^ self primitiveFail]].	self popStack.	self primitivePerformAt: lookupClass.	successFlag ifFalse: [self push: lookupClass]! !Array removeSelector: #loadImageSegmentFrom:withOutPointers:!Array removeSelector: #storeImageSegmentInto:withOutPointers:!ClassDescription removeSelector: #includesSelector:!ImageSegment removeSelector: #roots:!ImageSegment removeSelector: #verify:matches:!ImageSegment class removeSelector: #swapOutUnusedClasses!ImageSegment class removeSelector: #discoverClassesInUse!ObjectMemory removeSelector: #exchangeHashBits:with:!Interpreter removeSelector: #primitivePerformWithArgsFromClass!