'From Squeak 2.0 BETA of May 8, 1998 on 20 May 1998 at 12:54:07 pm'!RWBinaryOrTextStream subclass: #RemoteFileStream	instanceVariableNames: 'remoteFile '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!ServerDirectory subclass: #ServerFile	instanceVariableNames: 'fileName rwmode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!ChangeList class methodsFor: 'public access' stamp: 'tk 5/19/1998 14:24'!browseStream: changesFile	"Opens a changeList on a fileStream"	| changeList |	changesFile readOnly.	Cursor read showWhile:		[changeList _ self new			scanFile: changesFile from: 0 to: changesFile size].	changesFile close.	self open: changeList name: changesFile localName , ' log' multiSelect: true! !!ChangeSorter methodsFor: 'class list' stamp: 'tk 5/20/1998 11:38'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: self selectedClassOrMetaClass.		self showChangeSet: myChangeSet].! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:40'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 5/20/1998 11:06'!lookFor: beginning	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	resp size > 0 		ifTrue: [			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning].	"is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].	"exactly what we wanted"			"((resp at: 1) isDigit) & ((resp at: 1) digitValue < 4) ifTrue: [^ self lookFor: beginning]."				"the way I used to detect comments"			]		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FileDirectory methodsFor: 'path access' stamp: 'tk 5/18/1998 22:29'!on: fullPath	"Return another instance"	^ self class on: fullPath! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!fileNamed: localFileName	"Open the file with the given name in this directory for writing."	^ FileStream concreteStream fileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!newFileNamed: localFileName	"Create a new file with the given name in this directory."	^ FileStream concreteStream newFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!oldFileNamed: localFileName	"Open the existing file with the given name in this directory."	^ FileStream concreteStream oldFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/18/1998 16:19'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	| fullName |	fullName _ FileStream fullName: fileName.	(FileStream concreteStream isAFileNamed: fullName)		ifTrue: [^ FileStream concreteStream readOnlyFileNamed: fullName]		ifFalse: [^ nil].! !!FileDirectory methodsFor: 'file stream creation' stamp: 'tk 5/19/1998 09:03'!readOnlyFileNamed: localFileName	"Open the existing file with the given name in this directory for read-only access."	^ FileStream concreteStream readOnlyFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'tk 5/18/1998 15:44'!fileNameFormattedFrom: entry sizePad: sizePad sortMode: sortMode	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromDays: (entry at: 3) // 86400)					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileDirectory methodsFor: 'enumeration' stamp: 'tk 5/18/1998 15:49'!folderString	^ ' [...]'! !!FileDirectory methodsFor: 'enumeration' stamp: 'tk 5/18/1998 15:44'!listForPattern: pat sortMode: sortMode	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries _ self entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ sortMode == #name  "case-insensitive compare"		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) <= 2]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) >= 2]].	allFiles _ pat = '*'.	entries do:		[:entry | "<name><creationTime><modificationTime><dirFlag><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: (self fileNameFormattedFrom: entry 						sizePad: sizePad sortMode: sortMode)]].	^ newList! !!FileList commentStamp: 'tk 5/20/1998 12:54' prior: 0!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Deleting a remote file.  See (ServerDirectory deleteFileNamed:).[ ] Renaming a remote file.  See (ServerDirectory rename:toBe:).!!FileList reorganize!('initialization' defaultBackgroundColor directory: labelString setFileStream:)('volume list and pattern' askServerInfo openServer pattern pattern: showLocalDir volumeList volumeListIndex volumeListIndex: volumeMenu:)('file list' fileList fileListIndex fileListIndex:)('file list menu' addNewFile browseChanges copyName deleteFile editFile fileAllIn fileContentsMenu:shifted: fileInSelection fileIntoNewChangeSet fileListMenu: fileNameSuffix fileSelectedMenu: get getHex importImage noFileSelectedMenu: openImageInWindow perform:orSendTo: playMidiFile putUpdate renameFile sortByDate sortByName sortBySize)('private' contents defaultContents fileNameFormattedFrom:sizePad: fileNameFromFormattedItem: folderString fullName listForPattern: put: readContentsBrief: readContentsHex: resort: updateFileList)!!FileList methodsFor: 'initialization' stamp: 'tk 5/20/1998 11:33'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern.	self changed: #contents.! !!FileList methodsFor: 'initialization' stamp: 'tk 5/18/1998 17:22'!labelString	^ directory pathName contractTo: 50! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 5/20/1998 11:31'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '		"Please fill in the info.  Then select all text and choose DoIt."| aa | aa _ ServerDirectory new.Smalltalk at: #UIUCArchive "<- shortcut" put: aa.aa server: ''st.cs.uiuc.edu''. 		"host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.	 "<- this is optional.  Only used when *writing* update files." '.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 5/18/1998 15:13'!openServer	"make me show a directory on some remote FTP server.  directory will be a ServerDirectory, file will be a ServerFile.  stream will be a RWBinaryOrTextStream"	| selectors reply |	list _ ServerDirectory servers.	selectors _ (list collect: [:assoc | assoc key]) asSortedArray.	reply _ (SelectionMenu labelList: selectors selections: selectors) startUp.	reply == nil ifTrue: [^ self].	self directory: (list detect: [:assoc | assoc key == reply]) value.! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 5/18/1998 14:58'!showLocalDir	"Now show the current local directory and folder"	self directory: FileDirectory default! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 5/18/1998 22:30'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	delim _ directory pathNameDelimiter.	path _ String streamContents: [:strm |		2 to: index do: [:i |			strm nextPutAll: (volList at: i) withBlanksTrimmed.			i < index ifTrue: [strm nextPut: delim]]].	self directory: (directory on: path).	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 5/20/1998 12:38'!volumeMenu: aMenu	^ aMenu		labels:'fill in server info...open server...local disk'		lines: # ()		selections: #(askServerInfo openServer showLocalDir)! !!FileList methodsFor: 'file list' stamp: 'tk 5/18/1998 22:56'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - directory folderString size.					listIndex _ 0.					self changed: #closeScrollBar.  "will write in pane to left (MVC)"					self directory: (directory directoryNamed: name).					brevityState _ #FileList.					^ self changed: #contents]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 13:51'!addNewFile	"Add a new file and update the list"	| newName index ending |	self okToChange ifFalse: [^ self].	newName _ (FillInTheBlank request: 'New File Name?' 					initialAnswer: 'FileName') asFileName.	Cursor wait showWhile: [		(directory newFileNamed: newName) close].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 14:26'!browseChanges	"Browse the selected file in fileIn format."	ChangeList browseStream: (directory oldFileNamed: fileName).! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 13:44'!fileAllIn	"File in all of the currently selected file, if any."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory oldFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 09:16'!fileIntoNewChangeSet	"File in all of the contents of the currently selected file, if any, into a new change set."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory oldFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ChangeSorter newChangesFromStream: ff named: fileName.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 21:20'!importImage	"Import the selected file and store the resulting Form or ColorForm in the global dictionary GIFImports, at a key consisting of the short filename up to the first period."	| ff |	ff _ Form fromFile: (directory oldFileNamed: fileName).	Smalltalk gifImports at: (fileName sansPeriodSuffix) put: ff.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/19/1998 21:20'!openImageInWindow	"Handle three file formats: GIF, Form stoteOn: (run coded), and BMP. Fail if file format is not recognized." 	| ff |	ff _ Form fromFile: (directory oldFileNamed: fileName).	FormView open: ff named: fileName.! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/20/1998 11:22'!playMidiFile	"Play a midi file." 	Smalltalk at: #MIDIFileReader ifPresent: [:midiReaderClass |		midiReaderClass playMidiStream: (directory oldFileNamed: self fullName) 				title: fileName].! !!FileList methodsFor: 'file list menu' stamp: 'tk 5/20/1998 11:56'!putUpdate	"Put this file out as an Update on the servers."	| serverGroups index names |	self canDiscardEdits ifFalse: [^ self changed: #flash].	serverGroups _ ServerDirectory serverGroups.	"OC of associations"	names _ serverGroups collect: [:each | each key].	index _ (PopUpMenu labelArray: names lines: #()) 		startUpWithCaption: 'Choose a group of servers to write on.'.	index > 0 ifTrue: [		(serverGroups at: index) value putUpdate: 				(directory oldFileNamed: self fullName)].! !!FileList methodsFor: 'private' stamp: 'tk 5/19/1998 14:08'!put: aText	| ff |	listIndex = 0 ifTrue: [^ self].	((aText size >= 5) and:	 [#('File ' '16r0 ') includes: (aText copyFrom: 1 to: 5)])		ifTrue: [			(self confirm:'Abbreviated and hexadecimal file viewscannot be meaningfully saved at present.Is this REALLY what you want to do?') ifFalse: [^ false]].	ff _ directory newFileNamed: self fullName.	Cursor write showWhile: [ff nextPutAll: aText asString; close].	fileName = ff localName ifFalse: ["got renamed"		self updateFileList].	^ true  "accepted"! !!FileList methodsFor: 'private' stamp: 'tk 5/18/1998 16:28'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first and last 1000 characters. Don't create a file if it doesn't already exist."	| f fileSize first1000 last1000 |	listIndex = 0 ifTrue: [^ self defaultContents].	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000])		ifTrue: [^ f contentsOfEntireFile].	"if brevityFlag is true, don't display long files when first selected"	first1000 _ f next: 1000.	f position: fileSize - 1000.	last1000 _ f next: 1000.	f close.	^ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 1000 characters:--------------------------------', first1000, '... and here are the last 1000 characters:--------------------------------------', last1000! !!FileList methodsFor: 'private' stamp: 'tk 5/18/1998 16:28'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	(size _ f size) > 5000 & (brevity)		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	size > 5000 & (brevity)		ifTrue: [^ 'First 5k bytes:------------------' , hexData]		ifFalse: [^ hexData].! !!FileList methodsFor: 'private' stamp: 'tk 5/18/1998 15:52'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [directory listForPattern: pattern sortMode: sortMode]			ifFalse: [				pattern isEmpty					ifTrue: [directory listForPattern: '*' sortMode: sortMode]					ifFalse: [directory listForPattern: '*', pattern, '*' sortMode: sortMode]].		listIndex _ 0.		volListIndex _ volList size.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList class methodsFor: 'instance creation' stamp: 'tk 5/18/1998 14:55'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!Form class methodsFor: 'instance creation' stamp: 'tk 5/19/1998 21:16'!fromFile: fileStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. If the desired depth is not nil, convert the resulting Form to the given depth. Currently handles four file formats: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats. Return nil if the file could not be read or was of an unknown format."	| f firstByte result gifReader |	f _ fileStream readOnly; binary.	firstByte _ f next.	firstByte = 1		ifTrue: [result _ self new readFromOldFormat: f].	firstByte = 2		ifTrue: [result _ self new readFrom: f].	firstByte = $B asciiValue		ifTrue: [f skip: - 1. result _ self fromBMPFile: f].	firstByte = $G asciiValue		ifTrue: [			gifReader _ Smalltalk gifReaderClass.			gifReader ifNil: [				f close.				self inform:					'Sorry, there is no GIF reader available in the current system'.				^ nil].			f position: 0.			^ gifReader formFromFile: f].	f close.	result ifNil: [self error: 'unrecognized image file format'].	^ result! !!Form class methodsFor: 'instance creation' stamp: 'tk 5/19/1998 21:34'!fromFileNamed: fileName	"Read a Form or ColorForm from given file in any of four formats."	^ self fromFile: (FileStream readOnlyFileNamed: fileName).! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk 5/19/1998 21:31'!formFromFile: fileStream	"Answer a ColorForm stored on the file."	| reader form |	reader _ self on: fileStream.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk 5/19/1998 21:30'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	^ self formFromFile: (FileStream oldFileNamed: fileName)! !!MIDIFileReader class methodsFor: 'all' stamp: 'tk 5/20/1998 11:21'!playMidiStream: aStream title: titleString	"The stream can be either a FileStream or a RemoteFileStream."	aStream binary.	ScorePlayerMorph		openOn: (self new readMIDIFrom: aStream) asScore		title: titleString.! !!MIDIFileReader class methodsFor: 'all' stamp: 'tk 5/19/1998 21:43'!scoreFromStream: aStream	aStream binary.	^ (self new readMIDIFrom: aStream) asScore.! !!MIDIFileReader class methodsFor: 'all' stamp: 'tk 5/19/1998 21:48'!scoreFromURL: urlString	| data |	data _ HTTPSocket httpGet: urlString accept: 'audio/midi'.	data binary.	^ (self new readMIDIFrom: data) asScore.! !!RWBinaryOrTextStream commentStamp: 'tk 5/20/1998 12:54' prior: 0!A simulation of a FileStream, but living totally in memory.  Hold the contents of a file or web page from the network.  Can then fileIn like a normal FileStream.Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert to binary upon input and output.  Always keep as text internally.!!RemoteFileStream commentStamp: 'tk 5/20/1998 12:54' prior: 0!An in-memory stream that can be used to fileIn code from the network.  Knows its ServerFile, and thus its name, path, etc.!!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:50'!close	"Write if we have data to write.  FTP files are always binary to preserve the data exactly.  The binary/text (ascii) flag is just for tell how the bits are delivered from a read."	remoteFile writable ifTrue: [			remoteFile putFile: self named: remoteFile fileName]! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:57'!contentsOfEntireFile	"Fetch the data off the server and store it in me.  But not if I already have it."	readLimit _ readLimit max: position.	readLimit > 0 ifTrue: [^ super contentsOfEntireFile].	collection size = 0 ifTrue: [self on: (String new: 2000)].	remoteFile getFileNamed: remoteFile fileName into: self.	^ super contentsOfEntireFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:19'!directory	^ remoteFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:30'!localName	^ remoteFile fileName! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:38'!openReadOnly	"If we have data, don't reread.  Is this OK????"	self readOnly.	readLimit _ readLimit max: position.	readLimit > 0 ifFalse: [remoteFile getFileNamed: remoteFile fileName into: self]. ! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:32'!readOnly	^ remoteFile readOnly! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:18'!remoteFile	^ remoteFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:18'!remoteFile: aServerFile	remoteFile _ aServerFile! !!ServerDirectory reorganize!('do ftp' fileExists: getDirectory getFileList getFileNamed: getFileNamed:into: openFTP putFile:named:)('updates' checkServers outOfDate: putUpdate:)('accessing' directory: fullPath: group group: groupName moniker moniker: password password: server: url url: user:)('file directory' deleteFileNamed: directoryNamed: entries fileNameFormattedFrom:sizePad:sortMode: folderString fullNameFor: listForPattern:sortMode: newFileNamed: oldFileNamed: oldFileOrNoneNamed: on: pathName pathNameDelimiter pathParts rename:toBe:)!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/20/1998 11:01'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; space;		show: fileNameOnServer; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/19/1998 09:38'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/20/1998 10:55'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 ') == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	Transcript show: resp; cr.	(resp beginsWith: '227 Entering Passive Mode (') ifFalse: [		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/20/1998 12:22'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (url size > 0) ifTrue: [			strm _ HTTPSocket httpGet: url accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile.			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: this.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/20/1998 11:59'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(local count: [:char | char == $.]) > 1 ifTrue: [		^ self inform: 'File name cannot have more than one period'].	(local at: 1) isDigit ifTrue: [		^ self inform: 'File name cannot begin with a number'].		"later offer to strip it off and put on new number"	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		^ self inform: 'File name cannot contain % / * or space'].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2363)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/20/1998 12:19'!fullPath: serverAndDirectory	"Parse and save a full path"	| start bare |	start _ (serverAndDirectory copyFrom: 1 to: 8) asLowercase.	bare _ (start beginsWith: 'ftp://') 		ifTrue: [type _ #ftp.			serverAndDirectory copyFrom: 7 to: serverAndDirectory size]		ifFalse: [serverAndDirectory].	bare _ (start beginsWith: 'http://') 		ifTrue: [type _ #http.			bare copyFrom: 8 to: serverAndDirectory size]		ifFalse: [bare].	server _ bare copyUpTo: self pathNameDelimiter.	directory _ bare copyFrom: server size + 1 to: bare size.! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/20/1998 12:26'!moniker: nickName	"a plain language name for this directory"	moniker _ nickName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 11:41'!deleteFileNamed: fileName	self inform: 'Sorry, not implemented yet.'.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 08:56'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:42'!entries	"Return a list of the files here.  Later use the whole directory info with dates, sizes, times, etc."	^ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:53'!fileNameFormattedFrom: entry sizePad: sizePad sortMode: sortMode	"Parse one ftp directory entryd---------   1 owner    group               0 Apr 27 22:01 blasttest
----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM"	^ (entry at: 1) == $d 		ifTrue: [(entry findTokens: ' ') last , self folderString, '    ()']		ifFalse: [(entry findTokens: ' ') last , '    ()']	"get fancier later"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:51'!folderString	^ ' [...]'! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 14:15'!fullNameFor: aFileName	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	^ server, self pathNameDelimiter asString, directory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:50'!listForPattern: pat sortMode: sortMode	"Make the list be those file names which match the pattern.  SortMode of #name ONLY for now."	| entries newList allFiles |	entries _ self entries.	newList _ true "sortMode == #name"  "case-insensitive compare"		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) <= 2]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) >= 2]].	allFiles _ pat = '*'.	entries do:		[:entry | "<name>"		(allFiles or: [pat match: entry]) ifTrue:			[newList add: (self fileNameFormattedFrom: entry 						sizePad: 8 sortMode: sortMode)]].	^ newList! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 13:33'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readWrite.	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 14:20'!oldFileNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| file remoteStrm |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readOnly.	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 12:18'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readOnly.	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:27'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 17:54'!pathName	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 15:21'!pathNameDelimiter	"separator on that remote server.  How tell??"	type == #ftp ifTrue: [^ $/].	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 17:48'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 11:42'!rename: fileName toBe: newName	self inform: 'Sorry, not implemented yet.'.! !!ServerDirectory class methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 15:06'!servers	"Return all registered servers.  Each is an association (name -> server)"	| all |	all _ OrderedCollection new.	Smalltalk associationsDo: [:assoc |		(assoc value isKindOf: self) ifTrue: [all add: assoc copy]].	^ all! !!ServerFile commentStamp: 'tk 5/20/1998 12:54' prior: 0!Represents the non-data part of a file on a server on the internet.  I am owned by a RemoteFileStream, who has the data.!!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:12'!exists	"Return true if the file exists on the server already"	^ self fileExists: fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 14:42'!fileName	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 14:43'!fileName: aString	fileName _ aString! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:32'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:08'!localName	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 16:42'!readOnly	"Set the receiver to be read-only"	rwmode _ false! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:35'!readWrite	"Set the receiver to be writable"	rwmode _ true! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:35'!writable	^ rwmode! !