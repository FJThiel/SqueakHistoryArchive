'From Squeak2.9alpha of 12 June 2000 [latest update: #2551] on 3 September 2000 at 5:26:00 pm'!"Change Set:		BetterItalicsDate:			1 September 2000Author:			Dan IngallsThis changeSet computes non-overlapping synthetic italics, and uses negative kern to keep the original width in the displayed text.  In morphic this is straightforward, but in MVC, the display rule had to be changed to 'paint' to prevent kerned characters from obliterating characters overlapping to their left.  This in turn led to a simplification of the background fill operation to a single per-line blt."!!CharacterScanner methodsFor: 'private' stamp: 'di 9/3/2000 13:47'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont _ font.	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	priorFont ifNotNil: [destX _ destX + priorFont descentKern].	destX _ destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX _ destX max: leftMargin].	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions.! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 13:09'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	textStyle alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab _ true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab _ false]].	(textStyle alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!CharacterBlockScanner methodsFor: 'private' stamp: 'di 9/3/2000 15:44'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop _ line last  "characterBlockAtPoint"]		ifFalse:	[lineStop _ characterIndex  "characterBlockForIndex"].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'di 9/3/2000 11:39'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	rightMargin _ line rightMargin.	destX _ leftMargin _ line leftMarginForAlignment: textStyle alignment.	destY _ line top.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex == nil				ifTrue: ["Result for characterBlockAtPoint: "						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifFalse: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 9/3/2000 16:21'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	leftMargin _ (line leftMarginForAlignment: textStyle alignment) + offset x.	destX _ runX _ leftMargin.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 9/3/2000 16:18'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine [MVC only]. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		destX _ (runX _ leftMargin).		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: visibleRectangle width height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		string _ text string.		[done] whileFalse:[			startIndex _ lastIndex.			lastPos _ destX@destY.			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.			lastIndex >= startIndex ifTrue:[				font displayString: string on: bitBlt 					from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'private' stamp: 'di 9/3/2000 16:03'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (aParagraph foregroundColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: clippingRectangle.! !!DisplayScanner methodsFor: 'private' stamp: 'di 9/3/2000 16:13'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[destY _ lineY + line baseline - font ascent]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:24'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	^ true ! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:24'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:20'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount _ spaceCount + 1.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:19'!tab	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex _ lastIndex + 1.	^ false! !!StrikeFont methodsFor: 'accessing' stamp: 'di 9/2/2000 13:06'!ascentKern	"Return the kern delta for ascenders."	(emphasis noMask: 2) ifTrue: [^ 0].	^ (self ascent-5+4)//4 max: 0  "See makeItalicGlyphs"! !!StrikeFont methodsFor: 'accessing' stamp: 'di 9/1/2000 17:17'!baseKern	"Return the base kern value to be used for all characters."	(emphasis noMask: 2) ifTrue: [^ 0].	^ ((self height-1-self ascent+4)//4 max: 0)  "See makeItalicGlyphs"		+ (((self ascent-5+4)//4 max: 0))! !!StrikeFont methodsFor: 'accessing' stamp: 'di 9/2/2000 13:06'!descentKern	"Return the kern delta for descenders."	(emphasis noMask: 2) ifTrue: [^ 0].	^ (self height-1-self ascent+4)//4 max: 0  "See makeItalicGlyphs"! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 9/3/2000 13:22'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy ensureCleanBold name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 9/1/2000 17:12'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right.	In the process, characters would overlap, so we widen them all first.	"	| extraWidth newGlyphs newXTable x newX w extraOnLeft |	extraOnLeft _ (self height-1-self ascent+4)//4 max: 0.	extraWidth _ ((self ascent-5+4)//4 max: 0) + extraOnLeft.	newGlyphs _ Form extent: (glyphs width + extraWidth) @ glyphs height.	newXTable _ xTable copy.	"Copy glyphs into newGlyphs with room on left and right for overlap."	minAscii to: maxAscii+1 do:		[:ascii | x _ xTable at: ascii+1.  w _ (xTable at: ascii+2) - x.		newX _ newXTable at: ascii+1.		newGlyphs copy: ((newX + extraOnLeft) @ 0 extent: w @ glyphs height)			from: x @ 0 in: glyphs rule: Form over.		newXTable at: ascii+2 put: newX + w + extraWidth].			glyphs _ newGlyphs. 	xTable _ newXTable.	"Slide the bitmaps left and right for synthetic italic effect."	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		glyphs copy: (1@0 extent: glyphs width @ (self ascent - y))			from: 0@0 in: glyphs rule: Form over].	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		glyphs copy: (0@y extent: glyphs width @ glyphs height)			from: 1@y in: glyphs rule: Form over].! !StrikeFont removeSelector: #baselineKern!DisplayScanner removeSelector: #fillLeading!