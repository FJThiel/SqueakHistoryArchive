'From Squeak 2.2beta of Sept 11, 1998 on 14 September 1998 at 8:51:59 am'!"Change Set:		ScriptingChgs-swDate:			14 September 1998Author:			Scott WallaceSundry scripting-related changes, including:*  Many small changes in aid of being able to construct complex morphs programatically (changes consisting primarily of checking for the existence of a world or presenter in advance of sending a message to it.)*  Add 'is over color' to the user's repertory of booleans; this is similar to color:sees:, but this one returns true if any portion of the receiver is over the given color, whereas color:sees: demands that a particular *color* in the receiver be over the given color.  Arguably, this new function is much more likely to be the thing that users want most of the time, and it takes less breath to explain.*  In the wearCostume: command, ('look like'), retain the rotation style currently prevailing when switching from one sketch-morph costume to another."!!Morph methodsFor: 'initialization' stamp: 'sw 9/11/1998 11:13'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	(aPresenter _ self presenter) ifNil: [^ nil].	^ (pal _ aPresenter ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner _ aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'structure' stamp: 'sw 8/30/1998 09:47'!topPasteUp	"If the receiver is in a world, return that; otherwise return the outermost pasteup morph"	^ self outermostMorphThat: [:m | m isKindOf: PasteUpMorph]! !!Morph methodsFor: 'drawing' stamp: 'di 9/10/1998 12:29'!shadowForm	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fullDrawOn: canvas.	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/10/1998 12:41'!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm |	shadowForm _ self shadowForm.	patchBelowMe _ self world patchAt: self fullBounds belowMorph: self.	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'naming' stamp: 'sw 8/30/1998 09:48'!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds _ bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld _ self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/30/1998 09:41'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do: [:i |		gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.		gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm.	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 9/10/1998 14:45'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 9/10/1998 14:46'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	self presenter coloredTilesEnabled ifFalse:		[m makeAllTilesGreen].	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/10/1998 14:32'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(TilePadMorph colorForType: #color)).	^ outerPhrase! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 9/9/1998 13:21'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ super debuggingMenuFor: aHandMorph.	aMenu add:  'abandon costume history' target: self action: #abandonCostumeHistory.	^ aMenu! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 8/30/1998 09:44'!allTileScriptingElements	^ self allMorphs select:		[:s | s isTileScriptingElement]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 9/9/1998 10:45'!abandonCostumeHistory	self allMorphsDo:		[:m | m player ifNotNil: [m player forgetOtherCostumes]]! !!Player methodsFor: 'costume' stamp: 'sw 9/11/1998 16:02'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm cur degs chgd |	itsForm _ aSketchMorph form.	((cur _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cur form == itsForm ifTrue: [^ self]].	costumes size > 0 ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	chgd _ false.	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume originalForm: itsForm;		rotationCenter: aSketchMorph rotationCenter;		framesToDwell: aSketchMorph framesToDwell.		chgd _ true].	((cur isKindOf: SketchMorph) and: [cur rotationStyle ~~ #normal])			ifTrue:				[newCostume rotationStyle: cur rotationStyle.				newCostume rotationDegrees: cur rotationDegrees.				degs _ cur valueOfProperty: #setupAngle ifAbsent: [nil].				degs ifNotNil: [newCostume setupAngle: degs].				chgd _ true].	chgd ifTrue: [newCostume layoutChanged].	self renderedCostume: newCostume! !!Player methodsFor: 'slots-kernel' stamp: 'sw 9/10/1998 14:48'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!getRotationStyle	^ self getValueFromCostume: #rotationStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!setRotationStyle: aStyle	self setCostumeSlot: #rotationStyle toValue: aStyle! !!Player methodsFor: 'misc' stamp: 'sw 9/10/1998 14:35'!seesColor: aColor	^ self costume touchesColor: aColor! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'sw 9/11/1998 16:02'!editPlayerScriptsInPlace	^ false! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 8/6/1998 13:59'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/11/1998 11:22'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	Preferences editPlayerScriptsInPlace		ifTrue:			[self addTextualScript: newBrowser]		ifFalse:			[Browser openBrowserView: (newBrowser openMessageEditString: nil) label: ('textual script for "', scriptName, '" in ', playerScripted externalName)]! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/9/1998 13:15'!originalForm: aForm	originalForm _ aForm! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 9/10/1998 14:23'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(colorSees		boolean'Whether any part of thisobject is over the specified color')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(objectNameInHalo  control'Object''s name -- To change:click here; backspace over old name,type in new name; hit ENTER')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/10/1998 14:42'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(stopScript				'stop script')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(stopScript:				'stop script')		(startScript:				'start script')		(pauseScript:			'pause script')		(max:					'max')		(min:					'min')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(clearTurtleTrails		'clear pen trails')		(seesColor:				'is over color')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:23'!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	self initializeSystemSlotDictionary.	self new initializeHelpStrings! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:21'!initializeSystemSlotDictionary	"StandardScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(seesColor		boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 9/11/1998 16:02'!addScriptableTab	^ self addScriptableTabWithTitle: 'aTab'! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 8/30/1998 09:11'!addScriptableTabWithTitle: aTitle	| aTab |	aTab _ tabsMorph addActionTabWithTitle: aTitle.	aTab actionSelector: #tabSelected; target: aTab.	^ aTab! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 9/9/1998 17:35'!initialize	"TilePadMorph initialize"	ColorsForType _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(point			(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | ColorsForType at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !StandardScriptingSystem initialize!TilePadMorph initialize!WorldMorph removeSelector: #allTileScriptingElements!