'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6643] on 11 April 2005 at 12:49:55 am'!"Change Set:		SymbolCleanupDate:			11 April 2005Author:			Andreas RaabClean up the use of foo isKindOf: Symbol and use foo isSymbol instead. Provide the definition for ByteSymbol and use it where appropriate."!Symbol variableByteSubclass: #ByteSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!ByteSymbol commentStamp: '<historical>' prior: 0!This class represents the symbols containing 8bit characters.!!Behavior methodsFor: 'printing' stamp: 'ar 4/10/2005 22:15'!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key _ scannedLiteral key.	value _ scannedLiteral value.	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNilDo:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNilDo:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'ar 4/10/2005 22:15'!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key _ aCodeLiteral key.	(key isNil and: [(value _ aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	((key isSymbol) and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!Analyzer class methodsFor: 'methods' stamp: 'ar 4/10/2005 22:15'!methodsCalledAndCalleeForClass: aClass 	| r |	r := Set new.	aClass methodDict		associationsDo: [:assoc | (assoc value literals				select: [:l | l isSymbol])				do: [:ll | r 						add: (Array with: assoc key with: ll)]].	^ r! !!Analyzer class methodsFor: 'methods' stamp: 'ar 4/10/2005 22:15'!methodsCalledForClass: aClass 	| r |	r := Set new.	aClass methodDict values 		do: [:cm | (cm literals				select: [:l | l isSymbol])				do: [:ll | r add: ll]].	^ r! !!CompiledMethod methodsFor: 'literals' stamp: 'ar 4/10/2005 22:16'!literalStrings	| lits litStrs |	lits _ self literals.	litStrs _ OrderedCollection new: lits size * 3.	self literals do:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 22:17'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: ByteString put: 5.   refTypes add: 1.	t at: ByteSymbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.self flag: #ByteArray.	t at: ByteString put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: SoundBuffer put: 20.  refTypes add: 1.	"And all other word arrays, both 		16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"	"t at:  put: 22.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."	Smalltalk do: [:cls |		cls isInMemory ifTrue: [			cls isBehavior ifTrue: [				cls isPointers not & cls isVariable & cls isWords ifTrue: [					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].! !!DictionaryInspector methodsFor: 'menu' stamp: 'ar 4/10/2005 22:17'!sendersOfSelectedKey	"Create a browser on all senders of the selected key"	| aKey |	self selectionIndex = 0		ifTrue: [^ self changed: #flash].	((aKey := keyArray at: selectionIndex  - self numberOfFixedFields) isSymbol)		ifFalse: [^ self changed: #flash].	SystemNavigation default browseAllCallsOn: aKey! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 22:18'!buildFakeSlider: nameStringOrSymbol selector: aSymbol help: helpString 	| col |	col := self inAColumn: { 						(nameStringOrSymbol isSymbol) 							ifTrue: 								[(UpdatingStringMorph new)									useStringFormat;									getSelector: nameStringOrSymbol;									target: self;									growable: true;									minimumWidth: 24;									lock]							ifFalse: [self lockedString: nameStringOrSymbol]}.	col		borderWidth: 2;		borderColor: color darker;		color: color muchLighter;		hResizing: #shrinkWrap;		setBalloonText: helpString;		on: #mouseMove			send: #mouseAdjust:in:			to: self;		on: #mouseDown			send: #mouseAdjust:in:			to: self;		on: #mouseUp			send: #clearSliderFeedback			to: self;		setProperty: #changeSelector toValue: aSymbol.	^col! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:49'!copyFromRootsForExport: rootArray 	"When possible, use copySmartRootsExport:.  This way may not copy a complete tree of objects.  Add to roots: all of the methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.	"self halt."	symbolHolder _ Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:49'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements naughtyBlocks goodToGo allClasses sizeHint proj |	Smalltalk forgetDoIts.	"self halt."	symbolHolder _ Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj _dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses _ SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements _ dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"	naughtyBlocks _ arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [			goodToGo _ PopUpMenu				confirm: 'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?' 				trueChoice: 'keep going' 				falseChoice: 'stop and take a look'.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint _ (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:19'!smartFillRoots: dummy
	| refs known ours ww blockers |
	"Put all traced objects into my arrayOfRoots.  Remove some
that want to be in outPointers.  Return blockers, an
IdentityDictionary of objects to replace in outPointers."

	blockers _ dummy blockers.
	known _ (refs _ dummy references) size.
	refs fasterKeys do: [:obj | "copy keys to be OK with removing items"
		(obj isSymbol) ifTrue: [refs removeKey: obj.
known _ known-1].
		(obj class == PasteUpMorph) ifTrue: [
			obj isWorldMorph & (obj owner == nil) ifTrue: [
				obj == dummy project world ifFalse: [
					refs removeKey: obj.  known _ known-1.
					blockers at: obj put:
						(StringMorph
contents: 'The worldMorph of a different world')]]].
					"Make a ProjectViewMorph here"
		"obj class == Project ifTrue: [Transcript show: obj; cr]."
		(blockers includesKey: obj) ifTrue: [
			refs removeKey: obj ifAbsent: [known _
known+1].  known _ known-1].
		].
	ours _ dummy project world.
	refs keysDo: [:obj |
			obj isMorph ifTrue: [
				ww _ obj world.
				(ww == ours) | (ww == nil) ifFalse: [
					refs removeKey: obj.  known _ known-1.
					blockers at: obj put:
(StringMorph contents:
								obj
printString, ' from another world')]]].
	"keep original roots on the front of the list"
	(dummy rootObject) do: [:rr | refs removeKey: rr ifAbsent: []].
	^ dummy rootObject, refs fasterKeys asArray.

! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:19'!writeToFileWithSymbols	| symbols nonSymbols pound |	state = #extracted ifFalse: [self error: 'wrong state'].	segmentName ifNil: [		segmentName _ (FileDirectory localNameFor: fileName) sansPeriodSuffix].		"OK that still has number on end.  This is an unusual case"	fileName _ self class uniqueFileNameFor: segmentName.	symbols _ OrderedCollection new.	nonSymbols _ OrderedCollection new.	pound _ '#' asSymbol.	outPointers do:		[:s | 		((s isSymbol) and: [s isLiteral and: [s ~~ pound]])			ifTrue: [symbols addLast: s]			ifFalse: [symbols addLast: pound.  nonSymbols addLast: s]].	(self class segmentDirectory newFileNamed: fileName)		store: symbols asArray; cr;		nextPutAll: segment; close.	outPointers _ nonSymbols asArray.	state _ #onFileWithSymbols! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 4/10/2005 22:45'!comeFullyUpOnReload: smartRefStream
	"fix up the objects in the segment that changed size.  An
object in the segment is the wrong size for the modern version of the
class.  Construct a fake class that is the old size.  Replace the
modern class with the old one in outPointers.  Load the segment.
Traverse the instances, making new instances by copying fields, and
running conversion messages.  Keep the new instances.  Bulk forward
become the old to the new.  Let go of the fake objects and classes.
	After the install (below), arrayOfRoots is filled in.
Globalize new classes.  Caller may want to do some special install on
certain objects in arrayOfRoots.
	May want to write the segment out to disk in its new form."

	| mapFakeClassesToReal ccFixups receiverClasses
rootsToUnhiberhate myProject existing |

	RecentlyRenamedClasses _ nil.		"in case old data
hanging around"
	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.
		"Dictionary of just the ones that change shape.
Substitute them in outPointers."
	ccFixups _ self remapCompactClasses: mapFakeClassesToReal
				refStrm: smartRefStream.
	ccFixups ifFalse: [^ self error: 'A class in the file is not
compatible'].
	endMarker _ segment nextObject. 	"for enumeration of objects"
	endMarker == 0 ifTrue: [endMarker _ 'End' clone].
	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.
		"Can't use install.  Not ready for rehashSets"
	mapFakeClassesToReal isEmpty ifFalse: [
		self reshapeClasses: mapFakeClassesToReal refStream:
smartRefStream
	].
	"When a Project is stored, arrayOfRoots has all objects in
the project, except those in outPointers"
	arrayOfRoots do: [:importedObject |
		(importedObject isKindOf: MultiString) ifTrue: [
			importedObject mutateJISX0208StringToUnicode.
			importedObject class = MultiSymbol ifTrue: [
				"self halt."
				Symbol hasInterned: 
importedObject asString ifTrue: [:multiSymbol |
					multiSymbol == importedObject
ifFalse: [
						importedObject
becomeForward: multiSymbol.
					].
				].
			].
		].
		(importedObject isKindOf: TTCFontSet) ifTrue: [
			existing _ TTCFontSet familyName:
importedObject familyName
						pointSize:
importedObject pointSize.	"supplies default"
			existing == importedObject ifFalse:
[importedObject becomeForward: existing].
		].
	].
	"Smalltalk garbageCollect.   MultiSymbol rehash.  These take
time and are not urgent, so don't to them.  In the normal case, no
bad MultiSymbols will be found."

	receiverClasses _ self restoreEndianness.		"rehash sets"
	smartRefStream checkFatalReshape: receiverClasses.

	"Classes in this segment."
	arrayOfRoots do: [:importedObject |
		importedObject class class == Metaclass ifTrue: [self
declare: importedObject]].
	arrayOfRoots do: [:importedObject |
		(importedObject isKindOf: CompiledMethod) ifTrue: [
			importedObject sourcePointer > 0 ifTrue:
[importedObject zapSourcePointer]].
		(importedObject isKindOf: Project) ifTrue: [
			myProject _ importedObject.
			importedObject ensureChangeSetNameUnique.
			Project addingProject: importedObject.
			importedObject restoreReferences.
			self dependentsRestore: importedObject.
			ScriptEditorMorph writingUniversalTiles:
				((importedObject projectPreferenceAt:
#universalTiles) ifNil: [false])]].

	rootsToUnhiberhate _ arrayOfRoots select: [:importedObject |
		importedObject respondsTo: #unhibernate
	"ScriptEditors and ViewerFlapTabs"
	].
	myProject ifNotNil: [
		myProject world setProperty: #thingsToUnhibernate
toValue: rootsToUnhiberhate
	].

	mapFakeClassesToReal isEmpty ifFalse: [
		mapFakeClassesToReal keys do: [:aFake |
			aFake indexIfCompact > 0 ifTrue: [aFake
becomeUncompact].
			aFake removeFromSystemUnlogged].
		SystemOrganization removeEmptyCategories].
	"^ self"
! !!ImageSegment methodsFor: 'instance change shape' stamp: 'ar 4/10/2005 22:19'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances segSize |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	"If has instances, they point out at the class"	(outPointers includes: oldClass) ifFalse: [		oldClass == SmallInteger ifTrue: [^ self].	"instance not changable"		oldClass == Symbol ifTrue: [^ self].	"instance is never in a segment"		oldClass == ByteSymbol ifTrue: [^ self].	"instance is never in a segment"		(Smalltalk compactClassesArray includes: oldClass) ifFalse: [^ self]].		"For a compact class, must search the segment.  Instance does not 		 point outward to class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!MethodFinder methodsFor: 'search' stamp: 'ar 4/10/2005 22:20'!exceptions	"Handle some very slippery selectors.	asSymbol -- want to be able to produce it, but do not want to make every string submitted into a Symbol!!" 	| aSel |	answers first isSymbol ifFalse: [^ self].	thisData first first isString ifFalse: [^ self].	aSel _ #asSymbol.	(self testPerfect: aSel) ifTrue: [		selector add: aSel.		expressions add: (String streamContents: [:strm | 			strm nextPutAll: 'data', argMap first printString.			aSel keywords doWithIndex: [:key :ind |				strm nextPutAll: ' ',key.				(key last == $:) | (key first isLetter not)					ifTrue: [strm nextPutAll: ' data', 						(argMap at: ind+1) printString]]])].! !!MethodFinder methodsFor: 'search' stamp: 'ar 4/10/2005 22:20'!testPerfect: aSelector	"Try this selector!! Return true if it answers every example perfectly.  Take the args in the order they are.  Do not permute them.  Survive errors.  later cache arg lists."| sz argList val rec activeSel perform |	"Transcript cr; show: aSelector.		debug"perform _ aSelector beginsWith: 'perform:'.sz _ argMap size.1 to: thisData size do: [:ii | "each example set of args"	argList _ (thisData at: ii) copyFrom: 2 to: sz.	perform		ifFalse: [activeSel _ aSelector]		ifTrue: [activeSel _ argList first.	"what will be performed"			((Approved includes: activeSel) or: [AddAndRemove includes: activeSel])				ifFalse: [^ false].	"not approved"			aSelector == #perform:withArguments: 				ifTrue: [activeSel numArgs = (argList at: 2) basicSize "avoid error" 							ifFalse: [^ false]]				ifFalse: [activeSel numArgs = (aSelector numArgs - 1) 							ifFalse: [^ false]]].	1 to: sz do: [:num | 		(Blocks includes: (Array with: activeSel with: num)) ifTrue: [			(argList at: num) class == BlockContext ifFalse: [^ false]]].	rec _ (AddAndRemove includes: activeSel) 			ifTrue: [(thisData at: ii) first isSymbol ifTrue: [^ false].						"vulnerable to modification"				(thisData at: ii) first copyTwoLevel] 	"protect from damage"			ifFalse: [(thisData at: ii) first].	val _ [rec perform: aSelector withArguments: argList] 				ifError: [:aString :aReceiver | 							"self test3."							"self test2: (thisData at: ii)."							^ false].	"self test3."	"self test2: (thisData at: ii)."	((answers at: ii) closeTo: val) ifFalse: [^ false].	].^ true! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 4/10/2005 22:46'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start _ mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanLitVec.			mark _ start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isSymbol)								ifTrue: "##word"									[token _ token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token _ token asSymbol]]]].	mark _ start.	tokenType _ #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!SmartRefStream methodsFor: 'read write' stamp: 'ar 4/10/2005 22:46'!readInstanceSize: instSize clsname: className refPosn: refPosn	"The common code to read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| anObject newName newClass dict oldInstVars isMultiSymbol |	self flag: #bobconv.		self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	isMultiSymbol _ newName = #MultiSymbol.	newClass _ Smalltalk at: newName asSymbol.	(steady includes: newClass) & (newName == className) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		isMultiSymbol ifTrue: [^ Symbol intern: anObject asString].		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	dict at: #ClassName put: className.	"so conversion method can know it"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	anObject _ self applyConversionMethodsTo: anObject className: className varMap: dict.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!Symbol methodsFor: 'comparing' stamp: 'ar 4/10/2005 23:45'!= aSymbol	"Compare the receiver and aSymbol." 	self == aSymbol ifTrue: [^ true].	self class == aSymbol class ifTrue: [^ false].	"Use String comparison otherwise"	^ super = aSymbol! !!Symbol methodsFor: 'converting' stamp: 'ar 4/10/2005 22:42'!asString 	"Refer to the comment in String|asString."	| newString |	newString _ self species new: self size.	newString replaceFrom: 1 to: newString size with: self startingAt: 1.	^newString! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 22:10'!at: index 	"Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."	<primitive: 63>	^ Character value: (super at: index)! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 22:10'!at: anInteger put: anObject 	"You cannot modify the receiver."	self errorNoModification! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 22:10'!byteAt: index	<primitive: 60>	^(self at: index) asciiValue! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 22:10'!byteAt: anInteger put: anObject 	"You cannot modify the receiver."	self errorNoModification! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 22:11'!byteSize	^self size! !!ByteSymbol methodsFor: 'testing' stamp: 'ar 4/10/2005 22:14'!isByteString	"Answer whether the receiver is a ByteString"	^true! !!ByteSymbol methodsFor: 'testing' stamp: 'ar 4/10/2005 22:14'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	^ true.! !!ByteSymbol methodsFor: 'converting' stamp: 'ar 4/10/2005 22:12'!asByteArray	| ba sz |	sz := self byteSize.	ba := ByteArray new: sz.	ba replaceFrom: 1 to: sz with: self startingAt: 1.	^ba! !!ByteSymbol methodsFor: 'converting' stamp: 'ar 4/10/2005 22:12'!asOctetString	^ self! !!ByteSymbol methodsFor: 'private' stamp: 'ar 4/11/2005 00:08'!pvtAt: index put: aCharacter	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	aCharacter isCharacter 		ifFalse:[^self errorImproperStore].	index isInteger		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex]! !!ByteSymbol methodsFor: 'private' stamp: 'ar 4/10/2005 23:02'!string: aString	1 to: aString size do: [:j | self pvtAt: j put: (aString at: j)].	^self! !!ByteSymbol methodsFor: 'comparing' stamp: 'ar 4/10/2005 22:13'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	^super compare: string1 with: string2 collated: order! !!ByteSymbol methodsFor: 'comparing' stamp: 'ar 4/10/2005 22:14'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	^super findSubstring: key in: body startingAt: start matchTable: matchTable! !!Symbol class methodsFor: 'access' stamp: 'ar 4/10/2005 22:49'!allSymbols	"Answer all interned symbols"	^Array streamContents:[:s|		s nextPutAll: NewSymbols.		s nextPutAll: OneCharacterSymbols.		s nextPutAll: SymbolTable.	].! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 23:04'!intern: aStringOrSymbol 	^(self lookup: aStringOrSymbol) ifNil:[		| aClass aSymbol |		aStringOrSymbol isSymbol ifTrue:[			aSymbol _ aStringOrSymbol.		] ifFalse:[			aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[MultiSymbol].			aSymbol := aClass new: aStringOrSymbol size.			aSymbol string: aStringOrSymbol.		].		NewSymbols add: aSymbol.		aSymbol].! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 23:04'!internCharacter: aCharacter	aCharacter asciiValue > 256 ifTrue:[^self intern: aCharacter asString].	OneCharacterSymbols ifNil: [^self intern: aCharacter asString].	^OneCharacterSymbols at: aCharacter asciiValue + 1! !!Symbol class methodsFor: 'private' stamp: 'ar 4/10/2005 22:43'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol),  	otherwise supply the symbol to symBlock and return true."	| symbol |	^ (symbol _ self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol.			true]! !WeakSet removeSelector: #likeLoadedSymbol:!MultiSymbol class removeSelector: #hasInternedALoadedSymbol:ifTrue:!MultiSymbol class removeSelector: #internLoadedSymbol:!MultiSymbol class removeSelector: #lookupForLoadedSymbol:!DataStream initialize!