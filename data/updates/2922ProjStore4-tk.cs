'From Squeak2.9alpha of 16 June 2000 [latest update: #2962] on 7 November 2000 at 1:32:09 pm'!"Change Set:		ProjStore4-tkDate:			7 November 2000Author:			Ted Kaehler	Make loading a project work when one class has been converted to another (not simply renamed).  ImageSegments are hard in this case.  	When collecting objects with a DummyStream, don't enumerate non-pointer objects (thanks Andreas).	Make the original class name available to conversion methods. (varDict at: #ClassName)."!ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'structures steady reshaped renamed superclasses progressBar objCount classInstVars renamedConv '	classVariableNames: 'ScannedObject '	poolDictionaries: ''	category: 'System-Object Storage'!!SmartRefStream commentStamp: 'tk 11/3/2000 17:19' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principle is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now from the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name.  Make an instance of the new			class, and send it the conversion call.				(old class name symbol -> new class name).  renamedConv	Dictionary of conversion selector for Classes who have a different name.				(old class name symbol -> conversion selector).  topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, the top object if deep inside.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.  A class may be stored inside an ImageSegment that is stored by me.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self, does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.Some metaclasses are put into the structures table.  This is for when a block has a receiver that is a class.  See checkFatalReshape:.ImageSegments:	A ReferenceStream is used to enumerate objects to put inside an ImageSegment.  If an instance of a UniClass is seen, the class is put in also.	A SmartRefStream is used to store the ImageSegment.  Roots are nil, and the segment is a wordArray.  We are encoding the outPointers.  Structures contains all classes from both places.  Must filter out UniClasses for some things, and do include them for putting source code at end of file.  Do not write any class inst vars in file.Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tell how to make conversion work when some files have already been written.!!Object methodsFor: 'objects from disk' stamp: 'tk 11/7/2000 13:29'!storeDataOn: aDataStream	"Store myself on a DataStream. Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.	 NOTE: This method must send 'aDataStream beginInstance:size:'		and then put a number of objects (via aDataStream nextPut:/nextPutWeak:).	 Cf. readDataFrom:size:, which must read back what this puts	when given the size that it gave to beginInstance:size:. -- 11/15/92 jhm"	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	(aDataStream byteStream class == DummyStream) ifFalse: [		1 to: cntIndexedVars do:			[:i | aDataStream nextPut: (self basicAt: i)]].		"save a little time if dummy stream"! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 11/6/2000 20:58'!objectForDataStream: refStrm	| |	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	refStrm insideASegment		ifFalse: ["Normal use"			^ DiskProxy global: self theNonMetaClass name selector: #yourself				args: #()]		ifTrue: ["recording objects to go into an ImageSegment"			self isSystemDefined ifFalse: [^ self].		"do trace Player classes"			(refStrm rootObject includes: self) ifTrue: [^ self].				"is in roots, intensionally write out, ^ self"						"A normal class.  remove it from references.  Do not trace."			refStrm references removeKey: self ifAbsent: []. 	"already there"			^ nil]! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 11/7/2000 11:28'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol pr nn arrayIndex |	symbol _ globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		"If in outPointers in an ImageSegment, remember original class name.  		 See mapClass:installIn:.  Would be lost otherwise."		((thisContext sender sender sender sender sender sender 			sender sender receiver class == ImageSegment) and: [ 		thisContext sender sender sender sender method == 			(DataStream compiledMethodAt: #readArray)]) ifTrue: [				arrayIndex _ (thisContext sender sender sender sender) tempAt: 4.					"index var in readArray.  Later safer to find i on stack of context."				smartRefStream renamedConv at: arrayIndex put: symbol].	"save original name"		symbol _ smartRefStream renamed at: symbol ifAbsent: [symbol]].	"map"	globalObj _ Smalltalk at: symbol 		ifAbsent: [^ self error: 'Global not found'].	((symbol == #World) and: [Smalltalk isMorphic not]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			globalObj _ globalObj perform: selector]].	symbol == #Project ifTrue: [		(constructorSelector = #fromUrl:) ifTrue: [			nn _ (constructorArgs first findTokens: '/') last.			nn _ (nn findTokens: '.|') first.			pr _ Project named: nn. 			^ pr ifNil: [self] ifNotNil: [pr]].		pr _ globalObj perform: constructorSelector withArguments: constructorArgs.		^ pr ifNil: [self] ifNotNil: [pr]].	"keep the Proxy if Project does not exist"	constructorSelector ifNil: [^ globalObj].	constructorSelector ifNotNil: [		Symbol hasInterned: constructorSelector ifTrue: [:selector |			^ globalObj perform: selector					withArguments: constructorArgs]].					"args not checked against Renamed"	^ nil 	"was not in proper form"! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 11/6/2000 22:38'!constructorSelector	^ constructorSelector! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 11/6/2000 22:38'!globalObjectName	^ globalObjectName! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 11/6/2000 22:35'!preSelector	^ preSelector! !!Morph methodsFor: 'object fileIn' stamp: 'tk 11/7/2000 12:26'!convertbosfces0: varDict bosfce0: smartRefStrm	| rend |	"Work hard to eliminate the DropShadow.  Inst vars are already stored into."	submorphs size > 0 ifTrue: [		rend _ submorphs first renderedMorph.	"a text?"		rend setProperty: #hasDropShadow toValue: true.		rend setProperty: #shadowColor toValue: (varDict at: 'color').		rend setProperty: #shadowOffset toValue: (varDict at: 'shadowOffset').		"ds owner ifNotNil: [ds owner addAllMorphs: ds submorphs].   ^rend does this"		rend privateOwner: owner.		extension ifNotNil: [			extension actorState ifNotNil: [				rend actorState: extension actorState].			extension externalName ifNotNil: [				rend setNameTo: extension externalName].			extension player ifNotNil: [				rend player: extension player.				extension player rawCostume: rend]].		^ rend].	(rend _ Morph new) color: Color transparent.	^ rend! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 17:38'!mapClass: incoming	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel nm newList newVer instSel |	nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"	(nm endsWith: ' class') 		ifFalse: [cls _ Smalltalk at: nm ifAbsent: [nil].			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."		ifTrue: [cls _ Smalltalk at: nm substrings first asSymbol ifAbsent: [nil].			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNil: [cls _ self writeClassRenameMethod: sel was: nm					fromInstVars: (structures at: nm).			   cls class == String ifTrue: [cls _ nil]].	cls ifNotNil: [renamed at: nm put: cls name.				newList _ (Array with: cls classVersion), (cls allInstVarNames).				newVer _ self versionSymbol: newList.				instSel _ 'convert',oldVer,':',newVer, ':'. 				renamedConv at: nm put: instSel].	^ cls! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 17:59'!readInstance	"Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	^ self readInstanceSize: instSize clsname: className refPosn: refPosn! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/7/2000 12:33'!readInstanceSize: instSize clsname: className refPosn: refPosn	"The common code to read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| anObject newName newClass dict oldInstVars sel supers this |	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) & (newName == className) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	dict at: #ClassName put: className.	"so conversion method can know it"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"(newName == className) 	ifTrue: [		supers _ OrderedCollection with: (this _ className).		[(this _ superclasses at: this) = 'nil'] whileFalse: [			supers addFirst: this].		supers do: [:aName |				sel _ reshaped at: aName ifAbsent: [nil].			sel ifNotNil: [				anObject _ anObject perform: sel with: dict with: self]]]	"convert"	ifFalse: [sel _ renamedConv at: aName ifAbsent: [nil].	"one for all superclasses"			sel ifNotNil: [				anObject _ anObject perform: sel with: dict with: self]].	"convert"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 18:04'!readShortInst	"Instance has just one byte of size.  Class symbol is encoded in two bytes of file position.  See readInstance."	| instSize className refPosn |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	className _ self readShortRef.	"class symbol in two bytes of file pos"	^ self readInstanceSize: instSize clsname: className refPosn: refPosn! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/7/2000 11:12'!renamedConv	^ renamedConv! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 17:41'!setStream: aStream	"Initialize me. "	super setStream: aStream.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new.  "(old class name symbol -> new class name)"			renamedConv _ Dictionary new].				"(old class name symbol -> conversion selector in new class)"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 17:42'!setStream: aStream reading: isReading	"Initialize me. "	super setStream: aStream reading: isReading.	isReading ifFalse: [^ false].	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new.  "(old class name symbol -> new class name)"			renamedConv _ Dictionary new].				"(old class name symbol -> conversion selector in new class)"! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 11/3/2000 18:26'!verifyClass: newClass was: nm selector: sel newList: newShort oldList: oldShort	| selectorDictionary |	"Compare the incoming inst var name lists with the existing class.  See if the proper conversion method is present.  Works for either comparing inst vars for THIS class, or for allInstVars of the superclasses.  Store selector in a renamedConv if the old class is being renamed or replaced."	selectorDictionary _ newClass name == nm asSymbol 							ifTrue: [reshaped] ifFalse: [renamedConv].	Symbol hasInterned: sel ifTrue: [:symb | selectorDictionary at: nm put: symb].	newShort = oldShort ifFalse: ["inst vars did change"		(selectorDictionary includesKey: nm) ifFalse: ["No conversion method exists"				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ #new]].	(selectorDictionary includesKey: nm) ifTrue: ["Symbol exists"		(newClass canUnderstand: sel asSymbol) ifFalse: ["But not in this class!!"			self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.			^ #new]].	"Existing conversion methods is here"	^ #exists! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 11/3/2000 18:47'!dropShadowMorphbosfces0	^ Morph ! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 11/7/2000 12:30'!convert: misShapenInst to: goodClass	"Go through the normal instance conversion process and return a modern object."	| newName className oldInstVars anObject varMap supers this sel |	goodClass isVariable ifTrue: [		goodClass error: 'shape change for variable class not implemented yet'].	newName _ goodClass name.	(misShapenInst class name beginsWith: 'Fake37') ifFalse: [self error: 'why mapping?'].	className _ (misShapenInst class name allButFirst: 6) asSymbol.	oldInstVars _ structures at: className.	anObject _ goodClass basicNew.	varMap _ Dictionary new.	"later, indexed vars as (1 -> val) etc."	2 to: oldInstVars size do: [:ind |		varMap at: (oldInstVars at: ind) put: (misShapenInst instVarAt: ind-1)].	varMap at: #ClassName put: className.	"original"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: varMap. 	"ones with the same names"(newName == className) 	ifTrue: [		supers _ OrderedCollection with: (this _ className).		[(this _ superclasses at: this) = 'nil'] whileFalse: [supers addFirst: this].		supers do: [:aName |				sel _ reshaped at: aName ifAbsent: [nil].			sel ifNotNil: [				anObject _ anObject perform: sel with: varMap with: self]]]					"do the mapping"	ifFalse: [sel _ renamedConv at: className ifAbsent: [nil].	"one for all superclasses"			sel ifNotNil: [				anObject _ anObject perform: sel with: varMap with: self]].	"convert"	^ anObject! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 11/7/2000 11:24'!mapClass: newClass origName: originalName	"See if instances changed shape.  If so, make a fake class for the old shape and return it.  Remember the original class name."	| newName oldInstVars fakeClass |	newClass isMeta ifTrue: [^ newClass].	newName _ newClass name.	(steady includes: newClass) & (newName == originalName) ifTrue: [^ newClass].		"instances in the segment have the right shape"	oldInstVars _ structures at: originalName ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	fakeClass _ Object subclass: ('Fake37', originalName) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	Smalltalk changes removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 11/7/2000 12:21'!reshapedClassesIn: outPointers	"Look for classes in the outPointer array that have changed shape.  Make a fake class for the old shape.  Return a dictionary mapping Fake classes to Real classes.  Substitute fake classes for real ones in outPointers."	| mapFakeClassesToReal fakeCls originalName |	mapFakeClassesToReal _ IdentityDictionary new.	outPointers withIndexDo: [:outp :ind | 		outp isBehavior ifTrue: [			originalName _ renamedConv at: ind ifAbsent: [outp name].				"in DiskProxy>>comeFullyUpOnReload: we saved the name at the index"			fakeCls _ self mapClass: outp origName: originalName.			fakeCls == outp ifFalse: [				mapFakeClassesToReal at: fakeCls put: outp.				outPointers at: ind put: fakeCls]]].	^ mapFakeClassesToReal! !SmartRefStream removeSelector: #convertbosfces0:btbrocfbsissrrspoc0:!SmartRefStream removeSelector: #mapClass:installIn:!ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'structures steady reshaped renamed renamedConv superclasses progressBar objCount classInstVars '	classVariableNames: 'ScannedObject '	poolDictionaries: ''	category: 'System-Object Storage'!