'From Squeak2.7 of 5 January 2000 [latest update: #1789] on 6 February 2000 at 6:45:28 pm'!"Change Set:		DavesBlobMorphDate:			17 January 2000Author:			David N. Smith & RAA, SM, SMAThe Blob was written by David N Smith.  It started out as a simple test of the CurveMorph and ended up as an oozing, pulsating, repulsive mess which will wander across your screen until killed.  Each instance has its own rate of oozing, so some are faster than others.  It's not good for anything.Try:	BlobMorph new openInWorld15 Jan 2000 by Bob Arning, a change so that the blob tries to be a color like the color under itself.16 Jan 2000 by David N Smith, added blob merging: if two blobs meet then one eats the other.18 Jan 2000 by Sean McGrath, smother color changes.06 Feb 2000 by Stefan Matthias Aust, refactoring and support for duplication, dragging and translucent colors."!CurveMorph subclass: #BlobMorph	instanceVariableNames: 'random velocity sneaky '	classVariableNames: 'AllBlobs '	poolDictionaries: ''	category: 'Morphic-Demo'!BlobMorph class	instanceVariableNames: ''!!BlobMorph commentStamp: '<historical>' prior: 0!The Blob was written by David N Smith.  It started out as a simple test of the CurveMorph and ended up as an oozing, pulsating, repulsive mess which will wander across your screen until killed.  Each instance has its own rate of oozing, so some are faster than others.  It's not good for anything.Try:	BlobMorph new openInWorld15 Jan 2000 by Bob Arning, a change so that the blob tries to be a color like the color under itself.16 Jan 2000 by David N Smith, added blob merging: if two blobs meet then one eats the other.18 Jan 2000 by Sean McGrath, smother color changes.06 Feb 2000 by Stefan Matthias Aust, refactoring and support for duplication, dragging and translucent colors.!!BlobMorph methodsFor: 'copying' stamp: 'sma 2/6/2000 18:07'!veryDeepCopy	^ self class remember: super veryDeepCopy! !!BlobMorph methodsFor: 'geometry' stamp: 'sma 2/6/2000 18:39'!setConstrainedPositionFrom: aPoint	"Deal with dragging the blob over another blob	which results in spontaneous deletations."	self owner ifNil: [^ self].	super setConstrainedPositionFrom: aPoint! !!BlobMorph methodsFor: 'initialization' stamp: 'sma 2/6/2000 18:24'!initialize	super initialize.	random _ Random new.	sneaky _ random next < 0.75.	self initializeColor.	self initializeBlobShape.	self setVelocity! !!BlobMorph methodsFor: 'initialization' stamp: 'sma 2/6/2000 18:22'!initializeBlobShape	self		vertices: {59@40. 74@54. 79@74. 77@93. 57@97. 37@97. 22@83. 15@67. 22@50. 33@35. 47@33}		color: self color		borderWidth: 1		borderColor: Color black! !!BlobMorph methodsFor: 'initialization' stamp: 'sma 2/6/2000 18:27'!initializeColor	color _ random next < 0.75		ifTrue: [Color random]		ifFalse: [Color random alpha: random next * 0.4 + 0.5]! !!BlobMorph methodsFor: 'initialization' stamp: 'sma 2/6/2000 18:28'!maximumVelocity	^ 6.0! !!BlobMorph methodsFor: 'initialization' stamp: 'sma 2/6/2000 18:28'!setVelocity	velocity _		((random next - 0.5) * self maximumVelocity) @ 		((random next - 0.5) * self maximumVelocity)! !!BlobMorph methodsFor: 'stepping' stamp: 'sma 2/6/2000 18:13'!adjustColors	"Bob Arning <arning@charm.net>"	"Color mixing - Sean McGrath <sean@email.ces.ucsf.edu>"	| nearbyColors center r degrees |	center _ bounds center.	nearbyColors _ vertices collect:		[:each |		degrees _ (each - center) degrees.		r _ (each - center) r.		Display colorAt: (Point r: r + 6 degrees: degrees) + center].		self color: ((self color mixed: 0.95 with: (Color			r: (nearbyColors collect: [:each | each red]) average			g: (nearbyColors collect: [:each | each green]) average			b: (nearbyColors collect: [:each | each blue]) average))				alpha: self color alpha).        sneaky ifFalse: [self color: color negated]! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/17/2000 13:31'!bounceOffWalls	" Change sign of velocity when we hit a wall of the container "	| ob sb |	" If owned by a handmorph we're being dragged or something;	  don't bounce since the boundaries are different than our real parent "	(owner isKindOf: HandMorph) ifTrue: [ ^ self ].	" If we're entirely within the parents bounds, we don't bounce "	ob := owner bounds.	sb := self bounds.	(ob containsRect: sb) ifTrue: [ ^ self ].	" We're partly outside the parents bounds; better bounce or we disappear!! "	sb top < ob top ifTrue: [ velocity := velocity x @ velocity y abs ].	sb left < ob left ifTrue: [ velocity := velocity x abs @ velocity y ].	sb bottom > ob bottom ifTrue: [ velocity := velocity x @ velocity y abs negated ].	sb right > ob right ifTrue: [ velocity := velocity x abs negated @ velocity y ].! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/16/2000 16:29'!limitRange: verts	" limit radius to range 20-120; limit interpoint angle to surrounding angles with max of twice of average separation. "	| cent new prevn nextn prevDeg nextDeg thisDeg dincr |	cent := self bounds center.	new := Array new: verts size.	dincr := 360 // verts size.	verts doWithIndex: [ :pt :n |		"Find prev/next points, allowing for wrapping around "		prevn := n-1 < 1 ifTrue: [new size] ifFalse: [n-1].		nextn := n+1 > new size ifTrue: [1] ifFalse: [n+1].		"Get prev/this/next point's angles "		prevDeg := ((verts at: prevn)-cent) degrees.		thisDeg := ((verts at: n)-cent) degrees.		nextDeg := ((verts at: nextn)-cent) degrees.		"Adjust if this is where angles wrap from 0 to 360"		(thisDeg - prevDeg) abs > 180 ifTrue: [ prevDeg := prevDeg - 360 ].		(thisDeg - nextDeg) abs > 180 ifTrue: [ nextDeg := nextDeg + 360 ].		"Put adjusted point into new collection"		new at: n put: cent +			(self selfPolarPointRadius: ((((pt - cent) r) min: 80) max: 20)				degrees: (((thisDeg min: nextDeg-5) max: prevDeg+5) min: dincr*2+prevDeg)) ].	^ new! !!BlobMorph methodsFor: 'stepping' stamp: 'sma 2/6/2000 18:36'!mergeBlobs	"See if we need to merge by checking our bounds against all other Blob	bounds, then all our vertices against any Blob with overlapping bounds.	If we find a need to merge, then someone else does all the work."	AllBlobs size < 2 ifTrue: [^ self].	AllBlobs		do:			[:aBlob |			aBlob owner == self owner ifTrue:				[(self bounds intersects: aBlob bounds) ifTrue:					[vertices do:						[:aPoint |						(aBlob containsPoint: aPoint) ifTrue:							[^ self mergeSelfWithBlob: aBlob atPoint: aPoint]]]]]		without: self! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/17/2000 13:34'!mergeSelfWithBlob: aBlob atPoint: aPoint	" It has already been determined that we merge with aBlob; we do all the work here. "	| v v2 c |	c := self bounds center.	" Merge the vertices by throwing them all together in one pot "	v := vertices, aBlob vertices.	" Sort the vertices by degrees to keep them in order "	v := (v asSortedCollection: [ :a :b | (a-c) degrees < (b-c) degrees ]) asArray.	" Now, pick half of the vertices so the count stays the same "	v2 := Array new: v size // 2.	1 to: v2 size do: [ :n |		v2 at: n put: (v at: n+n) ].	v := v2.	" Average each contiguous pair to help minimize jaggies "	2 to: v size do: [ :n |		v at: n put: ((v at: n) + (v at: n-1)) / 2.0 ].	" Remember the new vertices, set a new velocity, then delete the merged blob "	vertices := v.	self setVelocity.	aBlob delete! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/17/2000 13:36'!oozeAFewPointsOf: verts	" change some points at random to cause oozing across screen "	| n v |	(verts size sqrt max: 2) floor timesRepeat: [		n := (verts size * random next) floor + 1.		v := verts at: n.		v := (v x + (random next * 2.0 - 1.0))  @ 			(v y + (random next * 2.0 - 1.0)).		verts at: n put: v + velocity ].! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/14/2000 17:47'!selfPolarPointRadius: rho degrees: theta	" Same as Point>>#r:degrees: in Point class except that x and y are not truncated to integers "	| radians x y |	radians _ theta asFloat degreesToRadians.	x _ rho asFloat * radians cos.	y _ rho asFloat * radians sin.	^ Point x: x y: y! !!BlobMorph methodsFor: 'stepping' stamp: 'dns 1/16/2000 16:35'!step	| verts |	self mergeBlobs.	verts := vertices copy.	" change two points at random to cause oozing across screen "	self oozeAFewPointsOf: verts.	" limit radius and interpoint angle "	verts := self limitRange: verts.	" Set new vertices; bounce off a wall if necessary "	self setVertices: verts.	self bounceOffWalls.	self adjustColors! !!BlobMorph methodsFor: 'stepping' stamp: 'sma 2/6/2000 18:41'!stepTime	"Answer the desired time between steps in milliseconds."	^ 125! !!BlobMorph methodsFor: 'submorphs-add/remove' stamp: 'sma 2/6/2000 17:41'!delete	self class delete: self.	super delete! !!BlobMorph class methodsFor: 'instance creation' stamp: 'dns 1/16/2000 15:11'!new	^ self remember: super new		! !!BlobMorph class methodsFor: 'instance remembering' stamp: 'sma 2/6/2000 18:36'!delete: anInstance	AllBlobs ifNotNil: [AllBlobs remove: anInstance ifAbsent: []]! !!BlobMorph class methodsFor: 'instance remembering' stamp: 'sma 2/6/2000 18:35'!remember: anInstance	AllBlobs isNil ifTrue: [AllBlobs := IdentitySet new].	^ AllBlobs add: anInstance! !