'From Squeak 2.1 of June 30, 1998 on 17 August 1998 at 2:05:19 pm'!"Change Set:		SqueakTime-diDate:			18 August 1998Author:			Dan IngallsThis file includes everything you need to give the demo I gave in Glendale last week.  Moreover, it has been "civilized" to use normal step methods, and normal morphic display, and still seems to run fast enough.[I'll follow this with a bit of documentation, esp regarding the format of the .movie file, and code to produce on from a plie of .BMPs].Here is how you would run that demo:1)  Have a .movie file on your disk.2)  Have a MIDI file on your disk.3)  Open a fileList to the .movie file and ask to 'open as movie'.     This should give you a movie player in which you can step and play fwd and back.4)  Open a fileList to the .mid file and ask to 'play midi file'.     This should give you a score player playing the piece.     Hit 'pause', and then use 'piano roll' to lay down a piano roll morph.     Choose 'open drag and drop' from the piano roll menu (very impt)5)  Rewind both score and movie, and then use the movie menu to make a thumbnail     (not a bookmark), and drop that at the beginning of the piano roll.6)  Now you can stop the music at various places, positition the movie, and drop more     thumbnails (not bookmarks) into the piano roll for further synchronization.7)  Similarly, you should be able to drop thumbnails from any normal bookmorph     into a piano roll that has been opened for dNd, to make your own sketch-movie."!'From Squeak 2.1 of June 30, 1998 on 1 August 1998 at 2:05:19 pm'!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount soundScore playDirection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!fileHandle	^ fileHandle! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!waitForCompletion	semaphore wait! !!Bitmap methodsFor: 'filing' stamp: 'di 6/1/1998 20:35'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream.	A leading byte ~= 16r80 identifies this as raw bits (uncompressed)."	aStream nextInt32Put: self size.	aStream nextPutAll: self! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:31'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:30'!writeUncompressedOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'as yet unclassified' stamp: 'di 7/8/1998 12:18'!baldMountainWorkspace"   -- Reset player, do this, then play -- 	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 2 do:		[:i | file position: i-1*153613+1.		ff readFrom: file.		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		Sensor yellowButtonPressed ifTrue: [^ file close]].	file close] -- Async version -- |  file ff byteCount nFrames bytesRead di |	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	byteCount _ ff bits size * 4.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: 1+13 count: byteCount.	1 to: nFrames by: (di_1) do:		[:i |		file waitForCompletion.		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		Sensor anyButtonPressed ifTrue: [^ file close].		(i+di) <= nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: (i-1+di)*(byteCount+13)+1+13 count: byteCount].		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		].	file close.	waitTime	| ps zps f32 f16 |	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		f32 _ Form fromFile: (FileStream oldFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps bmps:Bald' , zps , '.BMP').		f32 displayAt: 0@0.		f16 _ Form extent: f32 extent depth: 16.		f32 displayOn: f16 at: 0@0.		f16 displayAt: 330@0.		Transcript cr; show: i printString.		f16 writeUncompressedOnFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form'.		Sensor anyButtonPressed ifTrue: [^ nil]]	| ps zps  file |	file _ FileStream newFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fpsAll338.forms'.	file binary.	file nextPut: 2.	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form') display; writeUncompressedOn: file.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close	-- convert .forms file to .movie format --	|  out ps zps ff |	out _ FileStream newFileNamed: 'Bald2minAt10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 338) , (6 to: 32)		do: [:i | out nextInt32Put: i].			1 to: 1203 by: 1 do:		[:i | i printString displayAt: 400@0.		ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'BackStreet HD:Bald Mt Disk:Bald2 10fps Proc:Bald10.' , zps) 			displayOn: ff.		ff display; writeOnMovie: out].	out close.	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 1 do:		[:i | ff  readFrom: file.		ff display.		Sensor anyButtonPressed ifTrue: [^ file close]].	file close]	|  file ff byteCount nFrames filePosition bytesRead waitTime t |Array with: (Time millisecondsToRun: [	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	waitTime _ 0.	byteCount _ ff bits size * 4.	filePosition _ 1.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount.	1 to: nFrames by: 1 do:		[:i |		t _ Time millisecondClockValue.		file waitForCompletion.		waitTime _ waitTime + (Time millisecondClockValue - t).		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		filePosition _ filePosition+13 + bytesRead.		Sensor anyButtonPressed ifTrue: [^ file close].		i < nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount].		ff display].	file close])	with: waitTime (18400 9798 ) | ff | ff _ Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald00338.form'. Time millisecondsToRun: [1 to: 100 do: [:i | ff display]] 100000//1359 73Try out on-the-fly pixel doubling [dummied for timing]... | file f1 f2 f2a pixMap bb1 bb2 |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	f1 _ Form extent: 320@240 depth: 16.	f2 _ Form extent: 640@480 depth: 16.	f2a _ Form extent: 320@480 depth: 32.	f2a bits: f2 bits.	pixMap _ Bitmap new: 32768.	1 to: 32768 do: [:i | pixMap at: i put: (i bitOr: (i bitShift: 16))].	bb1 _ BitBlt destForm: f2a sourceForm: f1 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 320@1 clipRect: f2a boundingBox.	bb1 colorMap: pixMap.	bb2 _ BitBlt destForm: f2 sourceForm: f2 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 640@1 clipRect: f2 boundingBox.	1 to: 338 by: 1 do:		[:i | f1  readFrom: file.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		0 to: 239 do:			[:j |			bb1 sourceY: j; destY: j*2; copyBits.			bb2 sourceY: j*2; destY: j*2+1; copyBits].		f2 display.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close] 104512 53247 39812 338000.0/ 53247 6.34777546152835 6 6"! !!MoviePlayerMorph reorganize!('initialization' authorControlSpecs initialize insertPage makeMyPage openFile position:)('control' firstPage goToPage: lastPage nextPage playAllFrames playForward playReverse previousPage stopPlay)!!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 17:19'!authorControlSpecs	^ #(				('<<>>'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			('->'			nextPage		'Forward one frame')			('>>'			playForward	'Play forward')			( '-->'		lastPage			'Go to final page'))! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/7/1998 13:32'!initialize	| f w h d n |	movieFileName _ 'Bald2minAt10fps.movie'.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	super initialize.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 14:05'!insertPage	^ self makeMyPage! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 17:41'!makeMyPage	currentPage ifNotNil: [currentPage releaseCachedState; delete].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	self addMorphBack: currentPage.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 17:38'!openFile	^ AsyncFile new open: movieFileName forWrite: false! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 23:37'!position: newPos	super position: newPos.	(currentPage ~~ nil and: [currentPage left odd])		ifTrue: ["crude word alignment for depth = 16"				super position: newPos + (1@0)]! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 19:32'!firstPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 23:29'!goToPage: i	| file ff byteCount filePosition |	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	file _ self openFile.	ff _ currentPage image.	byteCount _ ff bits size * 4.	filePosition _ 128 + ((frameNumber-1)*(4+byteCount)) + 4.	file primReadStart: file fileHandle fPosition: filePosition count: byteCount.	file waitForCompletion.	file primReadResult: file fileHandle intoBuffer: ff bits at: 1 count: byteCount//4.	self isInWorld ifTrue: [ff displayAt: currentPage position].	file close.! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 19:29'!lastPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: frameCount! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 19:29'!nextPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber + 1 min: frameCount).! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/9/1998 13:07'!playAllFrames  "Just as a test, for now"	|  file ff byteCount pm |	file _ self openFile.	ff _ currentPage image.	byteCount _ ff bits size * 4.	pm _ self world  allFindA: ScorePlayerMorph.	[(playDirection > 0 and: [frameNumber < frameCount])	or: [playDirection < 0 and: [frameNumber > 1]]]		whileTrue:		[file primReadStart: file fileHandle			fPosition: 128 + ((frameNumber-1)*(4+byteCount)) + 4			count: byteCount.		frameNumber _ frameNumber + playDirection.		pm == nil 			ifTrue: [World doOneCycle]			ifFalse: [true  "enable/disable score sync"						ifTrue: [World doOneCycle]						ifFalse: [[(frameNumber*124) > pm scorePlayer msecsSinceStart]									whileTrue: [World doOneCycle]]].		file waitForCompletion.		file primReadResult: file fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.		ff displayAt: currentPage position].	playDirection _ 0.	file close! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 16:56'!playForward	playDirection _ 1.	self playAllFrames! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 16:56'!playReverse	playDirection _ -1.	self playAllFrames! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 19:29'!previousPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber - 1 max: 1).! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 7/6/1998 16:56'!stopPlay	playDirection _ 0! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 7/7/1998 10:25'!msecsSinceStart	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !MoviePlayerMorph removeSelector: #delete!MoviePlayerMorph removeSelector: #releaseCachedState!'From Squeak 2.1 of June 30, 1998 on 6 August 1998 at 11:57:48 pm'!AbstractScoreEvent subclass: #AmbientEvent	instanceVariableNames: 'morph target selector arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #MIDIScore	instanceVariableNames: 'tracks trackInfo ambientTrack tempoMap ticksPerQuarterNote '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!SketchMorph subclass: #BookPageThumbnailMorph	instanceVariableNames: 'page pageNumber bookMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount playDirection msSinceStart msPerFrame scorePlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!ImageMorph subclass: #MovieFrameSyncMorph	instanceVariableNames: 'moviePlayerMorph frameNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!ImageMorph subclass: #PianoRollNoteMorph	instanceVariableNames: 'offset '	classVariableNames: 'WholeNote '	poolDictionaries: ''	category: 'Music-Scores'!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!AlignmentMorph subclass: #ScorePlayerMorph	instanceVariableNames: 'scorePlayer trackInstNames instrumentSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!AmbientEvent reorganize!('all' morph morph: occurAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: relatedPlayer target:selector:arguments:)!!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 21:27'!morph 	^ morph! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:09'!morph: m	morph _ m! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/4/1998 15:47'!occurAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick	(target == nil or: [selector == nil]) ifTrue:		[^ morph encounteredAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick].	target perform: selector withArguments: arguments! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/6/1998 08:07'!relatedPlayer	(morph isMemberOf: MovieFrameSyncMorph)		ifFalse: [^ nil].	^ morph player.	! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:08'!target: t selector: s arguments: a	target _ t.	selector _ s.	arguments _ a.! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 14:55'!addAmbientEvent: evt	| i |	ambientTrack == nil ifTrue: [^ ambientTrack _ Array with: evt].	i _ ambientTrack findFirst: [:e | e time >= evt time].	i = 0 ifTrue: [^ ambientTrack _ ambientTrack , (Array with: evt)].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i-1 with: (Array with: evt)! !!MIDIScore methodsFor: 'all' stamp: 'di 8/1/1998 15:31'!ambientEventAfter: eventIndex ticks: scoreTicks	| evt |	(ambientTrack == nil or: [eventIndex > ambientTrack size]) ifTrue: [^ nil].	evt _ ambientTrack at: eventIndex.	evt time <= scoreTicks ifTrue: [^ evt].	^ nil! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 20:34'!ambientTrack	^ ambientTrack! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 08:04'!otherPlayersDo: playerBlock	"Not elegant -- scan for any players registered in the ambientTrack,	and evaluate the block for them."	| players p |	ambientTrack == nil ifTrue: [^ self].	players _ Set new.	ambientTrack do:		[:evt | p _ evt relatedPlayer.		p ifNotNil: [players add: p]].	players do: playerBlock! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!pauseFrom: scorePlayer	self otherPlayersDo: [:p | p pauseFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 21:52'!removeAmbientEventWithMorph: aMorph	| i |	ambientTrack == nil ifTrue: [^ self].	i _ ambientTrack findFirst: [:e | e morph == aMorph].	i = 0 ifTrue: [^ self].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i with: Array new! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resetFrom: scorePlayer	self otherPlayersDo: [:p | p resetFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resumeFrom: scorePlayer	self otherPlayersDo: [:p | p resumeFrom: scorePlayer]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!closeDragAndDrop	self setProperty: #openToDragAndDrop toValue: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!openDragAndDrop	self setProperty: #openToDragAndDrop toValue: true! !!BookMorph methodsFor: 'navigation' stamp: 'di 8/6/1998 23:49'!pageNumber.	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:24'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:50'!thumbnailForThisPage	self primaryHand attachMorph:		(currentPage thumbnailForPageSorter pageNumber: self pageNumber inBook: self)! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Flip to this page with no extra sound"	BookMorph turnOffSoundWhile: [bookMorph goToPage: pageNumber]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!pageNumber: n inBook: b	pageNumber _ n.	bookMorph _ b! !!MoviePlayerMorph reorganize!('initialization' authorControlSpecs initialize insertPage makeMyPage openFile position:)('access' frameNumber: msPerFrame: msSinceStart:)('control' bookmarkForThisPage firstPage goToPage: lastPage nextPage pauseFrom: playAllFrames playForward playReverse previousPage resetFrom: resumeFrom: stopPlay)!!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/5/1998 17:55'!initialize	| f w h d n |	movieFileName _ 'Bald2minAt10fps.movie'.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ 100.0.	super initialize.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!frameNumber: n	frameNumber _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msPerFrame: n	msPerFrame _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msSinceStart: n	msSinceStart _ n! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/5/1998 17:53'!bookmarkForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self primaryHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/6/1998 22:59'!pauseFrom: player	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/6/1998 23:05'!playAllFrames  "Just as a test, for now"	|  file ff byteCount |	file _ self openFile.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	[(playDirection > 0 and: [frameNumber < frameCount])	or: [playDirection < 0 and: [frameNumber > 1]]]		whileTrue:		[file primReadStart: file fileHandle			fPosition: 128 + ((frameNumber-1)*(4+byteCount)) + 4			count: byteCount.		frameNumber _ frameNumber + playDirection.		scorePlayer == nil 			ifTrue: [World doOneCycle]			ifFalse: [[scorePlayer ~~ nil and: [msSinceStart > scorePlayer msecsSinceStart]]									whileTrue: [World doOneCycle]].		file waitForCompletion.		file primReadResult: file fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.		ff displayAt: currentPage position.		msSinceStart _ msSinceStart + msPerFrame].	playDirection _ 0.	file close! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/6/1998 08:46'!resetFrom: player	self pauseFrom: player.	frameNumber _ 1! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/6/1998 23:04'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self playAllFrames! !!MoviePlayerMorph methodsFor: 'control' stamp: 'di 8/5/1998 23:40'!stopPlay	playDirection _ 0.	scorePlayer _ nil! !!MovieFrameSyncMorph reorganize!('all' encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: frameNumber image:player:frameNumber: nextSyncEventAfter:inTrack: player)!!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 22:44'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber.	moviePlayerMorph msSinceStart: scorePlayer msecsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 14:13'!frameNumber	^ frameNumber! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 17:04'!image: aForm player: aMoviePlayer frameNumber: n	self image: aForm.	moviePlayerMorph _ aMoviePlayer.	frameNumber _ n! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 21:57'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		(evt morph isMemberOf: MovieFrameSyncMorph) ifTrue: [^ evt]].	^ nil! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 08:06'!player	^ moviePlayerMorph! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:08'!acceptDroppingMorph: aMorph event: evt	"In addition to placing this morph in the pianoRoll, add a corresponding	event to the score so that it will always appear when played, in addition	to possibly triggering other actions"	| ambientEvent |	ambientEvent _ AmbientEvent new morph: aMorph;							time: (self timeForX: aMorph left).	super acceptDroppingMorph: aMorph event: evt.	score addAmbientEvent: ambientEvent.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 15:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #openToDragAndDrop) == true	ifTrue: [aCustomMenu add: 'close drag anddrop' action: #closeDragAndDrop]	ifFalse: [aCustomMenu add: 'open drag and drop' action: #openDragAndDrop]! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 22:00'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"		track _ score ambientTrack.		i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated.							visibleMorphs add:								(Morph									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:19'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) time < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:48'!privateRemoveMorph: aMorph	score removeAmbientEventWithMorph: aMorph.	^ super privateRemoveMorph: aMorph! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:35'!timeForX: aNumber	^ ((aNumber - bounds left - borderWidth) asFloat / timeScale + leftEdgeTime) asInteger! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:29'!xForTime: aNumber	^ ((aNumber - leftEdgeTime) asFloat * timeScale) asInteger + bounds left + borderWidth! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/5/1998 23:07'!isPlaying	^ SoundPlayer isPlaying: self! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/4/1998 15:46'!processEventsAtTick: scoreTicks	| instr j snd evt |	"First schedule all note events"	1 to: score tracks size do:		[:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[snd _ score soundForTrack: i after: j ticks: scoreTicks					instrument: instr secsPerTick: secsPerTick.		snd ~~ nil]			whileTrue:				[(muted at: i)					ifFalse: [activeSounds add: (Array with: snd with: i)].				j _ j + 1].		trackEventIndex at: i put: j].	"Then fire any ambient events"	j _ trackEventIndex at: trackEventIndex size.	[evt _ score ambientEventAfter: j ticks: scoreTicks.	evt ~~ nil]		whileTrue:			[j _ j + 1.			evt occurAtTime: scoreTicks inScorePlayer: self atIndex: j inEventTrack: score ambientTrack secsPerTick: secsPerTick].	trackEventIndex at: trackEventIndex size put: j.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/6/1998 07:51'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	score resetFrom: self.! !!ScorePlayer methodsFor: 'operating' stamp: 'di 8/6/1998 07:49'!pause	score pauseFrom: self.	super pause! !!ScorePlayer methodsFor: 'operating' stamp: 'di 8/6/1998 10:33'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	super resumePlaying.	score resumeFrom: self.! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !AmbientEvent removeSelector: #occur!AmbientEvent removeSelector: #occurAtTime:atIndex:inEventTrack:secsPerTick:!MoviePlayerMorph removeSelector: #startIfNecessary!MoviePlayerMorph removeSelector: #startIfNecessaryFrom:!MovieFrameSyncMorph removeSelector: #nextSyncMorphAfter:inTrack:!'From Squeak 2.1 of June 30, 1998 on 17 August 1998 at 3:54:35 pm'!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount playDirection msSinceStart msPerFrame scorePlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!MoviePlayerMorph reorganize!('initialization' authorControlSpecs initialize insertPage makeMyPage position:)('access' frameNumber: msPerFrame: msSinceStart: thumbnailForThisPage)('player control' firstPage goToPage: lastPage nextPage playForward playReverse previousPage stopPlay)('score events' pauseFrom: resetFrom: resumeFrom:)('stepping' startStepping step stepTime stopStepping)!!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/8/1998 11:53'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self primaryHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/8/1998 11:35'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startStepping; step  "will stop after first step"! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/8/1998 11:40'!playForward	playDirection = 0 ifFalse: [^ self]. "No-op during play"	playDirection _ 1.	self startStepping! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/8/1998 11:40'!playReverse	playDirection = 0 ifFalse: [^ self]. "No-op during play"	playDirection _ -1.	self startStepping! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/8/1998 11:38'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self startStepping! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:46'!startStepping	| ff byteCount |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 12:04'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If it is nil, then play runs at full speed -- ie at one frame for every call of step.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization, and this may cause some calls on step to skip their display action."	"ALSO: The player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	|  ff byteCount |	movieFile == nil ifTrue: [^ self].	(scorePlayer ~~ nil and: [msSinceStart > scorePlayer msecsSinceStart])		ifTrue: [^ self].	ff _ currentPage image. 	byteCount _ ff bits size * 4.	frameNumber _ frameNumber + playDirection.	msSinceStart _ msSinceStart + msPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.	"self isInWorld ifTrue: [ff displayAt: currentPage position]."  currentPage changed.	(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopStepping].		"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:57'!stepTime	^ 0  "step as fast as possible"! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:34'!stopStepping	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil:		[movieFile close.		movieFile _ nil].	playDirection _ 0.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 8/16/1998 00:12'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !BookPageThumbnailMorph removeSelector: #forBook:!MoviePlayerMorph removeSelector: #bookmarkForThisPage!MoviePlayerMorph removeSelector: #openFile!MoviePlayerMorph removeSelector: #playAllFrames!'From Squeak 2.1 of June 30, 1998 on 17 August 1998 at 5:33:15 pm'!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount playDirection msSinceStart msPerFrame scorePlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!FileList methodsFor: 'file list menu' stamp: 'di 8/17/1998 17:27'!fileSelectedMenu: aMenu	"This SHOULD only present special options related to file type (extension),	with a -more- item at the end that offers all special options."	^ aMenu		labels:'fileInfile into new change setbrowse changescopy name to clipboardopen image in a windowread image into GIFImportsload as morphplay midi fileopen as moviesort by namesort by sizesort by daterenamedeleteadd new fileadd new directorybroadcast as update'		lines: # (4 6 9 13)		selections: #(fileInSelection fileIntoNewChangeSet browseChanges  copyNameopenImageInWindow importImage openMorphFromFile playMidiFile openAsMovie sortByName sortBySize sortByDate renameFile deleteFile addNewFile addNewDirectory putUpdate)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/17/1998 17:31'!openAsMovie	"Open a MoviePlayerMorph on the given file (must be in .movie format)." 	Smalltalk at: #Morph ifAbsent: [^ self beep].	(MoviePlayerMorph new openFileNamed: self fullName) openInWorld! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:21'!fullControlSpecs	^ #(				('<<>>'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			('->'			nextPage		'Forward one frame')			('>>'			playForward	'Play forward')			( '-->'		lastPage			'Go to final page'))! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:56'!makeMyPage	currentPage ifNotNil: [currentPage releaseCachedState; delete].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	pages _ OrderedCollection with: currentPage.	self addMorphBack: currentPage.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:56'!openFileNamed: fName	| f w h d n |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ 100.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 17:12'!setInitialState	super setInitialState.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8! !MoviePlayerMorph removeSelector: #initialize!MoviePlayerMorph removeSelector: #authorControlSpecs!'From Squeak 2.1 of June 30, 1998 on 17 August 1998 at 10:06:42 pm'!!Morph methodsFor: 'initialization' stamp: 'di 8/17/1998 20:59'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	World addMorph: self.	World startSteppingSubmorphsOf: self.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 22:01'!openFileNamed: fName	| f w h d n m |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ m/1000.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 19:02'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step  "will stop after first step"! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playForward	(playDirection ~= 0 or: [frameNumber >= frameCount]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ 1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playReverse	(playDirection ~= 0 or: [frameNumber <= 1]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ -1.	self startRunning! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/17/1998 19:02'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self startRunning! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:47'!startRunning	| ff byteCount |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.	scorePlayer == nil ifTrue: [msSinceStart _ Time millisecondClockValue].! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:49'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If it is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  In either case, ssome calls on step will skip their  action until the right time."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	|  ff byteCount ms |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				ms < msSinceStart ifTrue: [msSinceStart _ ms "clock rollover"].				ms < (msSinceStart + msPerFrame) ifTrue: [^ self]]		ifFalse: [msSinceStart > scorePlayer msecsSinceStart ifTrue: [^ self]].	ff _ currentPage image. 	byteCount _ ff bits size * 4.	frameNumber _ frameNumber + playDirection.	msSinceStart _ msSinceStart + msPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.	currentPage changed.	(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].		"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 19:01'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil:		[movieFile close.		movieFile _ nil].	playDirection _ 0.! !MoviePlayerMorph removeSelector: #startStepping!MoviePlayerMorph removeSelector: #stopStepping!'From Squeak 2.1 of June 30, 1998 on 17 August 1998 at 10:17:06 pm'!!Form methodsFor: 'scaling, rotation' stamp: 'di 8/17/1998 22:17'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: self boundingBox by: scale			smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])! !