'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:09:52 am'!"Change Set:		Finalization-RoundTwoDate:			7 October 1998Author:			Andreas RaabRound two of the Finalization updates installs all the necessary modifications in Behavior/ClassDescription/Class/Metaclass for definingweakSubclasses. Note that a number of methods have becomeobsolete (they're flagged with #obsolete) but not yet removedto avoid inconsistencies."!!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/21/98 02:36'!kindOfSubclass 	"Answer a String that is the keyword that describes the receiver's kind of 	subclass, either a regular subclass, a variableSubclass, a 	variableByteSubclass, a variableWordSubclass, or a weakSubclass"	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Behavior methodsFor: 'private' stamp: 'ar 3/23/98 22:55'!becomeCompact	| cct index |	self isWeak ifTrue:[^self halt:'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09'!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	self flag: #obsolete.	^self format: nInstVars variable: isVar words: isWords pointers: isPointers weak: false! !!Behavior methodsFor: 'private' stamp: 'ar 10/7/1998 14:09'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:12'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	self flag: #obsolete.	^self		subclassOf: newSuper 		oldClass: oldClass 		instanceVariableNames: newInstVarString 		variable: v 		words: w 		pointers: p 		weak: false		ifBad: badBlock ! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 14:11'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p weak: beWeak ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass ifNotNil: [superclass removeSubclass: self.				"Object flushCache"		"done in removeSubclass"].			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p		weak: beWeak.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			weak: sub isWeak			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 3/21/98 02:36'!kindOfSubclass	"Answer a string that describes what kind of subclass the receiver is, i.e.,	weak, variable, variable byte, variable word, or not variable."	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:15'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: self instanceVariablesString , aString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'instance variables' stamp: 'ar 10/7/1998 17:16'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	superclass class		name: self name		inEnvironment: Smalltalk		subclassOf: superclass		instanceVariableNames: newInstVarString		variable: self isVariable		words: self isWords		pointers: self isPointers		weak: self isWeak		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:18'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	self isVariable		ifTrue: 			[self isPointers 				ifTrue: [^self							variableSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			self isBytes 				ifTrue: [^self							variableByteSubclass: t							instanceVariableNames: f							classVariableNames: d							poolDictionaries: s							category: cat].			^self				variableWordSubclass: t				instanceVariableNames: f				classVariableNames: d				poolDictionaries: s				category: cat].	^self class		name: t		inEnvironment: Smalltalk		subclassOf: self		instanceVariableNames: f		variable: false		words: true		pointers: true		weak: false		classVariableNames: d		poolDictionaries: s		category: cat		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(self isVariable and: [self isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a byte subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: false 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:16'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 10/7/1998 17:17'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	self instSize > 0 		ifTrue: [^self error: 					'cannot make a word subclass of a class with named fields'].	self isBytes		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(self isVariable and: [self isPointers])		ifTrue: [^self error: 					'cannot make a word subclass of a class with pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: false		weak: false		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Class methodsFor: 'subclass creation' stamp: 'ar 3/21/98 02:36'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: true		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 10/7/1998 17:12'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				weak: false				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 10/7/1998 14:14'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	self flag: #obsolete.	^self 		name: newName 		inEnvironment: environ 		subclassOf: sup 		instanceVariableNames: instVarString 		variable: v 		words: w 		pointers: p 		weak: false		classVariableNames: classVarString 		poolDictionaries: poolString 		category: categoryName 		comment: commentString 		changed: changed ! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 10/7/1998 14:13'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !