'From Squeak 2.5 of August 6, 1999 on 16 September 1999 at 2:55:39 pm'!"Change Set:		VRMLBase-arDate:			16 September 1999Author:			Andreas RaabThis change set contains the generic VRML 97 parser definition."!Object subclass: #VRMLBaseNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLBaseNode class	instanceVariableNames: ''!VRMLBaseNode subclass: #VRMLClassNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLClassNode class	instanceVariableNames: 'nodeSpec '!Object subclass: #VRMLEnumerator	instanceVariableNames: ''	classVariableNames: 'EnumActions '	poolDictionaries: ''	category: 'VRML-Definition'!VRMLEnumerator class	instanceVariableNames: ''!VRMLBaseNode subclass: #VRMLGenericNode	instanceVariableNames: 'attributes '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLGenericNode class	instanceVariableNames: ''!VRMLBaseNode subclass: #VRMLNamedNode	instanceVariableNames: 'name node '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLNamedNode subclass: #VRMLDefNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLNamedNode class	instanceVariableNames: ''!Object subclass: #VRMLNodeAttribute	instanceVariableNames: 'type name value attrClass '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-Definition'!VRMLNodeAttribute subclass: #VRMLDynamicAttribute	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-Definition'!VRMLNodeAttribute class	instanceVariableNames: ''!Object subclass: #VRMLNodeParser	instanceVariableNames: 'nodeTypes scene protoList infoBar '	classVariableNames: 'VRMLFieldTypes VRMLRuntimeFieldTypes VRMLScriptFieldTypes VRMLStatements '	poolDictionaries: ''	category: 'VRML-Definition'!VRMLNodeParser class	instanceVariableNames: ''!Object subclass: #VRMLNodeSpec	instanceVariableNames: 'name attributes vrmlClass nodeId attrDict '	classVariableNames: 'CurrentSpecs UndefinedSpec '	poolDictionaries: ''	category: 'VRML-Definition'!VRMLNodeSpec class	instanceVariableNames: ''!VRMLGenericNode subclass: #VRMLProtoNode	instanceVariableNames: 'nodeSpec protoType '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!Object subclass: #VRMLScene	instanceVariableNames: 'fileURL nodes defs protos actions '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-Definition'!VRMLGenericNode subclass: #VRMLStandardNode	instanceVariableNames: 'nodeId '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!Object subclass: #VRMLStream	instanceVariableNames: 'theStream backups '	classVariableNames: 'NonFirstChars NonRestChars SeparatorChars '	poolDictionaries: ''	category: 'VRML-Definition'!VRMLStream class	instanceVariableNames: ''!VRMLBaseNode subclass: #VRMLUndefinedNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLBaseNode subclass: #VRMLUnhandledNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLUnhandledNode subclass: #VRMLProtoClassNode	instanceVariableNames: 'protoSpec protoValues '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLProtoClassNode subclass: #VRMLExternProtoClassNode	instanceVariableNames: 'urlList '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLNamedNode subclass: #VRMLUseNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-BaseNodes'!VRMLEnumerator subclass: #VRMLWonderlandBuilder	instanceVariableNames: 'myWonderland scene attributes baseActor currentActor defaultCamera progress '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-Definition'!VRMLWonderlandBuilder class	instanceVariableNames: ''!Object subclass: #VRMLWriter	instanceVariableNames: ''	classVariableNames: 'Default VRMLFieldTypes '	poolDictionaries: ''	category: 'VRML-Definition'!VRMLWriter class	instanceVariableNames: ''!!Object methodsFor: 'testing' stamp: 'ar 8/17/1999 19:43'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/12/98 12:36'!includesBehavior: aClass	^self == aClass or:[self inheritsFrom: aClass]! !!Collection methodsFor: 'testing' stamp: 'ar 8/17/1999 19:43'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^true! !!FileList methodsFor: 'file list menu' stamp: 'ar 9/16/1999 14:48'!openVRMLFile	| scene |	scene _ Wonderland new.	scene makeActorFromVRML: self fullName.! !!Stream methodsFor: 'converting' stamp: 'ar 3/12/98 18:18'!asVRMLStream	^VRMLStream on: self! !!VRMLBaseNode reorganize!('initialize' fromSpec:)('accessing' children inEventNamed: name nodeSpec outEventNamed:)('printing' printOn: printOn:indent:)('testing' isPrototype)('enumerating' doWith:)('copying' vrmlProtoCopy)!!VRMLBaseNode methodsFor: 'initialize' stamp: 'ar 3/13/98 01:26'!fromSpec: aNodeSpec! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 3/13/98 13:45'!children	^nil! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 8/18/1999 09:18'!inEventNamed: aString	| spec inAttr |	spec _ self nodeSpec.	inAttr _ spec attributeNamed: aString.	inAttr == nil ifFalse:[		(inAttr attrClass = 'exposedField' or:[inAttr attrClass = 'eventIn'])			ifFalse:[inAttr _ nil]].	(inAttr == nil and:[aString beginsWith:'set_']) ifTrue:[		inAttr _ spec attributeNamed: (aString copyFrom: 5 to: aString size)].	inAttr == nil ifFalse:[		(inAttr attrClass = 'exposedField' or:[inAttr attrClass = 'eventIn'])			ifFalse:[inAttr _ nil]].	^inAttr! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 3/13/98 13:39'!name	^self nodeSpec name! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:26'!nodeSpec	^self subclassResponsibility! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 8/18/1999 09:18'!outEventNamed: aString	| spec outAttr |	spec _ self nodeSpec.	outAttr _ spec attributeNamed: aString.	outAttr == nil ifFalse:[		(outAttr attrClass = 'exposedField' or:[outAttr attrClass = 'eventOut'])			ifFalse:[outAttr _ nil]].	(outAttr == nil and:[aString endsWith:'_changed']) ifTrue:[		outAttr _ spec attributeNamed: (aString copyFrom: 1 to: aString size - 8)].	outAttr == nil ifFalse:[		(outAttr attrClass = 'exposedField' or:[outAttr attrClass = 'eventOut'])			ifFalse:[outAttr _ nil]].	^outAttr! !!VRMLBaseNode methodsFor: 'printing' stamp: 'ar 3/12/98 22:40'!printOn: aStream	self printOn: aStream asVRMLStream indent: 0.! !!VRMLBaseNode methodsFor: 'printing' stamp: 'ar 3/13/98 01:26'!printOn: aStream indent: level	self nodeSpec print: self on: aStream indent: level.! !!VRMLBaseNode methodsFor: 'testing' stamp: 'ar 3/13/98 00:28'!isPrototype	^false! !!VRMLBaseNode methodsFor: 'enumerating' stamp: 'ar 8/18/1999 19:39'!doWith: aVRMLEnumerator	aVRMLEnumerator doNode: self.! !!VRMLBaseNode methodsFor: 'copying' stamp: 'ar 3/13/98 14:37'!vrmlProtoCopy	^self shallowCopy! !!VRMLBaseNode class methodsFor: 'instance creation' stamp: 'ar 3/13/98 01:25'!fromSpec: aNodeSpec	^self new fromSpec: aNodeSpec! !!VRMLClassNode methodsFor: 'accessing' stamp: 'ar 8/18/1999 09:17'!nodeSpec	^self class nodeSpec! !!VRMLClassNode class methodsFor: 'accessing' stamp: 'ar 8/18/1999 09:11'!nodeSpec	^nodeSpec! !!VRMLClassNode class methodsFor: 'accessing' stamp: 'ar 8/18/1999 09:11'!nodeSpec: aSpec	nodeSpec _ aSpec! !!VRMLEnumerator commentStamp: '<historical>' prior: 0!A VRMLEnumerator enumerates a tree of VRML nodes and dispatches the nodes to appropriate actions.!!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 09:52'!doChildrenOf: aVRMLNode	| children |	children := aVRMLNode children.	children isNil ifTrue:[^self].	children do:[:each| each doWith: self].! !!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 09:59'!doInterpolator: aVRMLNode	^self! !!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 09:59'!doLight: aVRMLNode	^self! !!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 19:38'!doNamedNode: aVRMLNode	^self doNode: aVRMLNode node! !!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 09:52'!doNode: aVRMLNode	| action |	action := EnumActions at: aVRMLNode name ifAbsent:[nil].	action ifNotNil:[self perform: action with: aVRMLNode].! !!VRMLEnumerator methodsFor: 'enumerating' stamp: 'ar 8/18/1999 09:59'!doSensor: aVRMLNode	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doAnchor: aVRMLNode	"This method was automatically generated"	^self doChildrenOf: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doAppearance: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doAudioClip: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doBackground: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doBillboard: aVRMLNode	"This method was automatically generated"	^self doChildrenOf: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doBox: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCollision: aVRMLNode	"This method was automatically generated"	^self doChildrenOf: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doColor: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doColorInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCone: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCoordinate: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCoordinateInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCylinder: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doCylinderSensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doDirectionalLight: aVRMLNode	"This method was automatically generated"	^self doLight: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doElevationGrid: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doExtrusion: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doFog: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doFontStyle: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doGroup: aVRMLNode	"This method was automatically generated"	^self doChildrenOf: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doImageTexture: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doIndexedFaceSet: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doIndexedLineSet: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doInline: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doLOD: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doMaterial: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doMovieTexture: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doNavigationInfo: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doNormal: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doNormalInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doOrientationInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doPixelTexture: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doPlaneSensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doPointLight: aVRMLNode	"This method was automatically generated"	^self doLight: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doPointSet: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doPositionInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doProximitySensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doScalarInterpolator: aVRMLNode	"This method was automatically generated"	^self doInterpolator: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doScript: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doShape: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doSound: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doSphere: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doSphereSensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doSpotLight: aVRMLNode	"This method was automatically generated"	^self doLight: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doSwitch: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doText: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doTextureCoordinate: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doTextureTransform: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doTimeSensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doTouchSensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doTransform: aVRMLNode	"This method was automatically generated"	^self doChildrenOf: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doViewpoint: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doVisibilitySensor: aVRMLNode	"This method was automatically generated"	^self doSensor: aVRMLNode! !!VRMLEnumerator methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 09:59'!doWorldInfo: aVRMLNode	"This method was automatically generated"	^self! !!VRMLEnumerator class methodsFor: 'class initialization' stamp: 'ar 8/18/1999 09:58'!compileSelector: selector spec: nodeSpec	| isComposite source |	isComposite := nodeSpec containsAttribute: 'children' ofType: 'MFNode'.	source := String streamContents:[:s|		s nextPutAll: selector.		s nextPutAll:' aVRMLNode'.		s crtab; nextPutAll:'"This method was automatically generated"'.		s crtab; nextPutAll:'^self'.		('*Light*' match: nodeSpec name ) ifTrue:[			s nextPutAll:' doLight: aVRMLNode'.		] ifFalse:[		('*Interpolator*' match: nodeSpec name) ifTrue:[			s nextPutAll:' doInterpolator: aVRMLNode'.		] ifFalse:[		('*Sensor*' match: nodeSpec name) ifTrue:[			s nextPutAll:' doSensor: aVRMLNode'.		] ifFalse:[			isComposite ifTrue:[s nextPutAll:' doChildrenOf: aVRMLNode']]]].		].	self compile: source classified: 'enumerating nodes'.! !!VRMLEnumerator class methodsFor: 'class initialization' stamp: 'ar 9/16/1999 14:44'!initialize	"VRMLEnumerator initialize"	| selector |	EnumActions := Dictionary new.	VRMLNodeSpec initialize.	VRMLNodeSpec currentSpecs do:[:nodeSpec|		selector := ('do',nodeSpec name,':') asSymbol.		EnumActions at: nodeSpec name put: selector.		(self includesSelector: selector) ifFalse:[			self compileSelector: selector spec: nodeSpec.		].	].! !!VRMLGenericNode methodsFor: 'initialize' stamp: 'ar 3/13/98 00:21'!fromSpec: aVRMLNodeSpec	aVRMLNodeSpec defineGenericIn: self.! !!VRMLGenericNode methodsFor: 'initialize' stamp: 'ar 3/13/98 00:21'!initialize	attributes := Dictionary new.! !!VRMLGenericNode methodsFor: 'testing' stamp: 'ar 3/12/98 21:23'!isGeneric	^true! !!VRMLGenericNode methodsFor: 'attributes' stamp: 'ar 8/18/1999 20:20'!attributeNamed: aString	| attr |	attr _ self nodeSpec attributeNamed: aString.	attr == nil ifTrue:[^nil].	^self attributes at: attr ifAbsent:[attr].! !!VRMLGenericNode methodsFor: 'attributes' stamp: 'ar 3/12/98 21:39'!defineAttribute: aVRMLAttribute	attributes at: aVRMLAttribute put: aVRMLAttribute copy! !!VRMLGenericNode methodsFor: 'attributes' stamp: 'ar 3/12/98 21:40'!getAttributeValue: aVRMLAttribute	^(self attributes at: aVRMLAttribute) value! !!VRMLGenericNode methodsFor: 'attributes' stamp: 'ar 3/12/98 21:38'!setAttribute: aVRMLNodeAttribute toValue: newValue	(self attributes at: aVRMLNodeAttribute) value: newValue! !!VRMLGenericNode methodsFor: 'accessing' stamp: 'ar 3/12/98 21:39'!attributes	^attributes! !!VRMLGenericNode methodsFor: 'accessing' stamp: 'ar 3/13/98 14:36'!attributes: aCollection	attributes := aCollection! !!VRMLGenericNode methodsFor: 'accessing' stamp: 'ar 3/13/98 13:47'!children	| attr |	attr := self nodeSpec getFieldNamed: 'children'.	^attr ifNotNil:[self getAttributeValue: attr].! !!VRMLGenericNode methodsFor: 'accessing' stamp: 'ar 3/13/98 00:21'!nodeSpec	^self subclassResponsibility! !!VRMLGenericNode methodsFor: 'printing' stamp: 'ar 3/13/98 00:21'!printOn: aStream indent: level	self nodeSpec print: self on: aStream indent: level.! !!VRMLGenericNode methodsFor: 'copying' stamp: 'ar 3/13/98 14:29'!vrmlProtoCopy	| attrCopy |	attrCopy := Dictionary new: self attributes size.	self attributes associationsDo:[:assoc|		attrCopy at: assoc key put:  assoc value vrmlProtoCopy.	].	^self shallowCopy attributes: attrCopy.! !!VRMLGenericNode class methodsFor: 'instance creation' stamp: 'ar 3/12/98 21:33'!fromSpec: aVRMLNodeSpec	^self new fromSpec: aVRMLNodeSpec! !!VRMLGenericNode class methodsFor: 'instance creation' stamp: 'ar 3/12/98 21:33'!new	^super new initialize! !!VRMLNamedNode methodsFor: 'initialize' stamp: 'ar 3/12/98 21:48'!name: aString node: aNode	name := aString.	node := aNode.! !!VRMLNamedNode methodsFor: 'accessing' stamp: 'ar 8/18/1999 19:37'!name	^name! !!VRMLNamedNode methodsFor: 'accessing' stamp: 'ar 8/18/1999 19:38'!node	^node! !!VRMLNamedNode methodsFor: 'copying' stamp: 'ar 3/13/98 14:29'!vrmlProtoCopy	^node vrmlProtoCopy! !!VRMLNamedNode methodsFor: 'enumerating' stamp: 'ar 8/18/1999 19:38'!doWith: aVRMLEnumerator	aVRMLEnumerator doNamedNode: self.! !!VRMLDefNode methodsFor: 'printing' stamp: 'ar 3/12/98 21:50'!printOn: aVRMLStream indent: aLevel	aVRMLStream 		nextPutAll: 'DEF ';		nextPutAll: name;		space.	node printOn: aVRMLStream indent: aLevel.! !!VRMLNamedNode class methodsFor: 'instance creation' stamp: 'ar 3/12/98 21:48'!name: aString node: aNode	^self new name: aString node: aNode! !!VRMLNodeAttribute commentStamp: '<historical>' prior: 0!This class defines a generic attribute of a VRML node.Instance variables:	type		<String>	The type of the attribute (e.g., 'SFFloat', 'MFString')	name		<String>	The name of the attribute (e.g., 'children')	value		<Object>	The (default or current) value of the attribute	attrClass	<String>	The attribute class (e.g., 'exposedField', 'field', 'eventIn', 'eventOut')!!VRMLNodeAttribute methodsFor: 'reading' stamp: 'ar 3/12/98 23:29'!readFrom: aVRMLStream in: aParser	^aParser readAttribute: self from: aVRMLStream! !!VRMLNodeAttribute methodsFor: 'initialize' stamp: 'ar 3/12/98 21:27'!name: nameString type: typeString value: defaultValue	name := nameString.	type := typeString.	value := defaultValue.! !!VRMLNodeAttribute methodsFor: 'initialize' stamp: 'ar 8/17/1999 21:45'!name: nameString type: typeString value: defaultValue attrClass: classString	name := nameString.	type := typeString.	value := defaultValue.	attrClass := classString.! !!VRMLNodeAttribute methodsFor: 'printing' stamp: 'ar 3/12/98 21:56'!print: aVRMLNode on: aVRMLStream indent: aLevel	| newValue |	newValue := aVRMLNode getAttributeValue: self.	newValue = value ifTrue:[^self].	aVRMLStream crtab: aLevel.	VRMLWriter writeAttribute: self on: aVRMLStream value: newValue indent: aLevel.! !!VRMLNodeAttribute methodsFor: 'printing' stamp: 'ar 3/13/98 01:53'!printExternOn: aVRMLStream indent: aLevel	aVRMLStream 		nextPutAll: self attributeClass; 		space; 		nextPutAll: self type; 		space;		nextPutAll: self name;		crtab: aLevel.! !!VRMLNodeAttribute methodsFor: 'printing' stamp: 'ar 8/18/1999 09:48'!printOn: aStream	aStream 		"nextPutAll: self class name;		nextPut:$(;"		nextPut:$[;		print: attrClass;		nextPutAll:'] ';		print: type;		space;		print: name;		space.	value isCollection		ifTrue:[aStream print: value asArray]		ifFalse:[aStream print: value].! !!VRMLNodeAttribute methodsFor: 'printing' stamp: 'ar 3/13/98 01:44'!printOn: aVRMLStream indent: aLevel	"aVRMLStream crtab: aLevel."	aVRMLStream nextPutAll: self attributeClass; space; nextPutAll: self type; space.	VRMLWriter writeAttribute: self on: aVRMLStream value: value indent: aLevel.! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 8/17/1999 22:07'!attrClass	^attrClass! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/13/98 01:37'!attributeClass	^'field'! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 22:39'!name	^name! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 21:37'!setValue: newValue in: aVRMLNode	aVRMLNode 		setAttribute: self toValue: newValue.! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 21:28'!setValueIn: aVRMLNode	self setValue: value in: aVRMLNode! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 22:40'!type	^type! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 21:41'!value	^value! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 3/12/98 21:39'!value: anObject	value _ anObject! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 3/13/98 14:39'!containsNodes	^type = 'MFNode' or:[type = 'SFNode']! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 3/13/98 14:22'!isDynamic	^false! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 3/13/98 14:41'!isMultiType	^type first = $M! !!VRMLNodeAttribute methodsFor: 'copying' stamp: 'ar 3/13/98 14:42'!vrmlProtoCopy	| valueCopy |	self containsNodes		ifTrue:[valueCopy := self vrmlProtoCopyValues]		ifFalse:[valueCopy := self value shallowCopy]. 	^self shallowCopy value: valueCopy! !!VRMLNodeAttribute methodsFor: 'copying' stamp: 'ar 3/13/98 14:42'!vrmlProtoCopyValues	self isMultiType ifFalse:[^self value vrmlProtoCopy].	^self value collect:[:node| node vrmlProtoCopy].! !!VRMLDynamicAttribute commentStamp: '<historical>' prior: 0!A VRMLDynamicAttribute is a hidden attribute used for storing information in a VRMLNode which is not part of the standard spec.!!VRMLDynamicAttribute methodsFor: 'printing' stamp: 'ar 3/13/98 14:07'!print: aVRMLNode on: aVRMLStream indent: aLevel	"Do nothing"! !!VRMLDynamicAttribute methodsFor: 'printing' stamp: 'ar 3/13/98 14:14'!printOn: aVRMLStream indent: aLevel	"Do nothing"! !!VRMLDynamicAttribute methodsFor: 'testing' stamp: 'ar 3/13/98 14:22'!isDynamic	^true! !!VRMLNodeAttribute class methodsFor: 'instance creation' stamp: 'ar 8/17/1999 21:46'!name: nameString type: typeString value: defaultValue attrClass: classString	^self new name: nameString type: typeString value: defaultValue attrClass: classString! !!VRMLNodeParser commentStamp: '<historical>' prior: 0!A VRMLNodeParser creates a generic tree of VRMLNodes from a VRML file. These nodes are not intended to be used directly in a 3D system; they should be used to create a retained mode description for the 3D rendering system.Instance variables:	nodeTypes 	<Collection of: VRMLNodeSpec>	The specs used for construction the VRML nodes	scene 		<VRMLScene>					The scene which will be defined by the parser	protoList 	<Collection of: VRMLNodeSpec>	Prototypes currently under construction	infoBar 	<BlockContext>					Progress indicatorClass variables:	VRMLFieldTypes 			<Dictionary>		Basic VRML field types	VRMLRuntimeFieldTypes 	<Dictionary>		The field types in a valid VRML file	VRMLScriptFieldTypes 		<Dictionary>		The field types for node definitions	VRMLStatements 			<Dictionary>		The valid statements in a VRML file!!VRMLNodeParser methodsFor: 'initialize' stamp: 'ar 8/17/1999 19:31'!initialize	| specs |	specs _ self nodeSpecs.	specs == nil ifTrue:[		nodeTypes _ Dictionary new.	] ifFalse:[		nodeTypes _ Dictionary new: specs size.		specs do:[:nodeSpec|			nodeTypes at: nodeSpec name put: nodeSpec.		].	].! !!VRMLNodeParser methodsFor: 'parsing' stamp: 'ar 3/11/98 20:04'!parseField: aVRMLStream	| fieldType fieldValue |	aVRMLStream backup.	fieldType := aVRMLStream readName.	fieldValue := self dispatchOn: fieldType						in: VRMLFieldTypes						with: aVRMLStream						ifNone:[nil].	aVRMLStream restoreIf: fieldValue isNil.	^fieldValue! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldBoolFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readBool! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldColorFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readColor! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldFloatFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readFloat! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldImageFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readImage! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldInt32From: aVRMLStream	"This method was automatically generated"	^aVRMLStream readInt32! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/12/98 00:49'!readSingleFieldNodeFrom: aVRMLStream	"This method was automatically generated"	aVRMLStream backup.	aVRMLStream readName = 'NULL' ifTrue:[		aVRMLStream discard.		^nil].	aVRMLStream restore.	^self parseStatement: aVRMLStream! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldRotationFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readRotation! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldStringFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readString! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldTimeFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readTime! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldVec2fFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readVec2f! !!VRMLNodeParser methodsFor: 'single field parsing' stamp: 'ar 3/11/98 23:10'!readSingleFieldVec3fFrom: aVRMLStream	"This method was automatically generated"	^aVRMLStream readVec3f! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 8/17/1999 21:51'!parseAttribute: aVRMLStream from: aDictionary	| attrClass type name value isEvent |	aVRMLStream skipSeparators.	attrClass := aVRMLStream readName.	isEvent := attrClass = 'eventIn' or:[attrClass = 'eventOut'].	aVRMLStream skipSeparators.	type := aVRMLStream readName.	aVRMLStream skipSeparators.	name := aVRMLStream readName.	aVRMLStream skipSeparators.	isEvent ifFalse:[		value := self dispatchOn: type							in: aDictionary							with: aVRMLStream							ifNone:[self error:'Unknown attribute type: ',type]].	^VRMLNodeAttribute name: name type: type value: value attrClass: attrClass! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 3/13/98 01:29'!parseDefinition: aVRMLStream	| name attributes attr spec vrmlClassName |	aVRMLStream skipSeparators.	name := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream nextChar = ${ ifFalse:[		self error:'Node definition expected'.	].	attributes := OrderedCollection new.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $}] whileFalse:[		attr := self parseAttribute: aVRMLStream from: VRMLScriptFieldTypes.		attr ifNotNil:[attributes add: attr].	].	aVRMLStream skip: 1.	spec := VRMLNodeSpec name: name attributes: attributes.	vrmlClassName := (self vrmlClassNameFor: name) asSymbol.	(Smalltalk includesKey: vrmlClassName)		ifTrue:[spec vrmlClass: (Smalltalk at: vrmlClassName)]		ifFalse:[spec vrmlClass: VRMLStandardNode].	^spec! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 3/11/98 23:06'!parseDefinitions: aVRMLStream	| nodes |	aVRMLStream reset.	nodes := OrderedCollection new.	[aVRMLStream skipSeparators.	aVRMLStream atEnd] whileFalse:[		nodes add: (self parseDefinition: aVRMLStream).	].	^nodes! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 8/17/1999 21:47'!parseExternAttribute: aVRMLStream	| attrClass type name isEvent |	aVRMLStream skipSeparators.	attrClass := aVRMLStream readName.	isEvent := attrClass = 'eventIn' or:[attrClass = 'eventOut'].	aVRMLStream skipSeparators.	type := aVRMLStream readName.	aVRMLStream skipSeparators.	name := aVRMLStream readName.	aVRMLStream skipSeparators.	isEvent ifTrue:[^nil].	^VRMLNodeAttribute name: name type: type value: nil attrClass: attrClass! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 3/13/98 00:07'!parseScriptEvent: aVRMLStream	"Dummy"	^nil! !!VRMLNodeParser methodsFor: 'definition parsing' stamp: 'ar 3/13/98 00:07'!parseScriptField: aVRMLStream	"Dummy"	^nil! !!VRMLNodeParser methodsFor: 'private' stamp: 'ar 3/11/98 22:46'!dispatchOn: key in: table with: arg ifNone: aBlock	^self perform: (table at: key ifAbsent:[^aBlock value]) with: arg.! !!VRMLNodeParser methodsFor: 'private' stamp: 'ar 3/12/98 21:20'!nodeSpecs	^VRMLNodeSpec currentSpecs! !!VRMLNodeParser methodsFor: 'private' stamp: 'ar 3/13/98 01:03'!skipParens: endChar from: aVRMLStream	| char |	[true] whileTrue:[		aVRMLStream skipSeparators.		char := aVRMLStream nextChar.		char = endChar ifTrue:[^self].		char = $[ ifTrue:[self skipParens:$] from: aVRMLStream].		char = ${ ifTrue:[self skipParens:$] from: aVRMLStream].		char = $" ifTrue:[			aVRMLStream skip: -1.			aVRMLStream readString].	].! !!VRMLNodeParser methodsFor: 'private' stamp: 'ar 3/12/98 19:31'!vrmlClassNameFor: aString	^self class vrmlClassNameFor: aString! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldColorFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldColorFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldColorFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldFloatFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldFloatFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldFloatFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldInt32From: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldInt32From: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldInt32From: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldNodeFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldNodeFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldNodeFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldRotationFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldRotationFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldRotationFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldStringFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldStringFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldStringFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldTimeFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldTimeFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldTimeFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldVec2fFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldVec2fFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldVec2fFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'multi field parsing' stamp: 'ar 3/11/98 23:19'!readMultiFieldVec3fFrom: aVRMLStream	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self readSingleFieldVec3fFrom: aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self readSingleFieldVec3fFrom: aVRMLStream).	].	aVRMLStream nextChar.	^fields.! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/12/98 21:47'!parseDEF: aVRMLStream	| nodeName nodeValue |	aVRMLStream skipSeparators.	nodeName := aVRMLStream readName.	nodeValue := self parseStatement: aVRMLStream.	scene defineNode: nodeName value: nodeValue.	^VRMLDefNode name: nodeName node: nodeValue! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/13/98 14:19'!parseEXTERNPROTO: aVRMLStream	| spec urlList subScene protoNode |	spec := self parseExternProtoSpec: aVRMLStream.	aVRMLStream skipSeparators.	urlList := self readMultiFieldStringFrom: aVRMLStream.	subScene := self class parseURLs: urlList.	scene addPrototype: (subScene prototypeAt: spec name) spec: spec.	protoNode := (VRMLExternProtoClassNode fromSpec: spec) urlList: urlList.	scene addNode: protoNode.	^nil! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/13/98 01:12'!parseIS: aVRMLStream with: aVRMLNodeAttribute	| outerScopeName |	outerScopeName := aVRMLStream readName.	^aVRMLNodeAttribute value! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 8/17/1999 21:47'!parsePROTO: aVRMLStream	| spec nodeList node protoNode protoAttr |	spec := self parseProtoSpec: aVRMLStream.	aVRMLStream skipSeparators.	aVRMLStream next = ${ ifFalse:[^self error:'Prototype body expected'].	protoList ifNil:[protoList := OrderedCollection new].	protoList add: spec.	nodeList := OrderedCollection new.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $}] whileFalse:[		node := self parseStatement: aVRMLStream.		node ifNotNil:[nodeList add: node].	].	aVRMLStream skip: 1.	protoList remove: spec.	protoNode := VRMLProtoClassNode fromSpec: spec.	protoNode protoValues: nodeList.	protoAttr := VRMLDynamicAttribute name:'protoType' type: 'SFNode' value: protoNode attrClass: nil.	spec addAttribute: protoAttr.	scene addPrototype: protoNode spec: spec.	scene addNode: protoNode.	protoList isEmpty ifTrue:[protoList := nil].	^nil! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 8/17/1999 22:21'!parseROUTE: aVRMLStream	| fromNode outEvent toNode inEvent |	aVRMLStream skipSeparators.	fromNode := aVRMLStream readName.	aVRMLStream next = $. ifFalse:[^self error:'Period expected'].	outEvent := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream readName = 'TO' ifFalse:[^self error:'TO expected'].	aVRMLStream skipSeparators.	toNode := aVRMLStream readName.	aVRMLStream next = $. ifFalse:[^self error:'Period expected'].	inEvent := aVRMLStream readName.	scene routeFrom: fromNode event: outEvent to: toNode event: inEvent.	^nil! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 9/14/1999 20:04'!parseScene: aVRMLStream	| version node |	version := aVRMLStream resetAndCheckVersion.	version isNil ifTrue:[^self error:'No VRML file'].	version first = '2.0' ifFalse:[^self error:'Wrong VRML version (',version first,')'].	version last = 'utf8' ifFalse:[^self error:'Wrong VRML character definition set (not utf8)'].	'Reading VRML file' 		displayProgressAt: Sensor cursorPoint		from: 0 to: 100		during:[:bar|			infoBar := bar.			scene := VRMLScene new.			scene fileURL: aVRMLStream name.			[aVRMLStream skipSeparators.			aVRMLStream atEnd] whileFalse:[				node := self parseStatement: aVRMLStream.				node ifNotNil:[scene addNode: node].			].	].	^scene! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/13/98 02:05'!parseStatement: aVRMLStream	| token |	aVRMLStream skipSeparators.	token := aVRMLStream readName.	(VRMLStatements includesKey: token) ifTrue:[		^self dispatchOn: token in: VRMLStatements with: aVRMLStream ifNone:[]].	(nodeTypes includesKey: token) ifTrue:[		infoBar value: (aVRMLStream position * 100 // aVRMLStream size).		^(nodeTypes at: token) readFrom: aVRMLStream in: self].	self error:'Unkown token'.! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/12/98 21:51'!parseUSE: aVRMLStream	| nodeName |	aVRMLStream skipSeparators.	nodeName := aVRMLStream readName.	^VRMLUseNode name: nodeName node: (scene definedNode: nodeName)! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 3/13/98 00:12'!readAttribute: aVRMLNodeAttribute from: aVRMLStream	aVRMLStream skipSeparators.	self isPrototyping ifTrue:[		aVRMLStream backup.		(aVRMLStream next: 2) = 'IS' ifTrue:[			aVRMLStream discard.			^self parseIS: aVRMLStream with: aVRMLNodeAttribute.		].		aVRMLStream restore.	].	^self dispatchOn: aVRMLNodeAttribute type			in: VRMLRuntimeFieldTypes			with: aVRMLStream			ifNone:[^self error:'Unknown attribute type: ',aVRMLNodeAttribute type]! !!VRMLNodeParser methodsFor: 'proto-parsing' stamp: 'ar 3/13/98 01:16'!parseExternProtoSpec: aVRMLStream	| protoName attributes attr spec vrmlClassName |	aVRMLStream skipSeparators.	protoName := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream next = $[ ifFalse:[^self error:'Interface expected'].	attributes := OrderedCollection new.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $]] whileFalse:[		attr := self parseExternAttribute: aVRMLStream.		attr ifNotNil:[attributes add: attr].	].	aVRMLStream skip: 1.	spec := VRMLNodeSpec name: protoName attributes: attributes.	spec vrmlClass: VRMLProtoNode.	vrmlClassName := (self vrmlClassNameFor: protoName) asSymbol.	(Smalltalk includesKey: vrmlClassName)		ifTrue:[spec vrmlClass: (Smalltalk at: vrmlClassName)].	nodeTypes at: protoName put: spec.	^spec! !!VRMLNodeParser methodsFor: 'proto-parsing' stamp: 'ar 3/13/98 01:16'!parseProtoSpec: aVRMLStream	| protoName attributes attr spec vrmlClassName |	aVRMLStream skipSeparators.	protoName := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream next = $[ ifFalse:[^self error:'Interface expected'].	attributes := OrderedCollection new.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $]] whileFalse:[		attr := self parseAttribute: aVRMLStream from: VRMLFieldTypes.		attr ifNotNil:[attributes add: attr].	].	aVRMLStream skip: 1.	spec := VRMLNodeSpec name: protoName attributes: attributes.	spec vrmlClass: VRMLProtoNode.	vrmlClassName := (self vrmlClassNameFor: protoName) asSymbol.	(Smalltalk includesKey: vrmlClassName)		ifTrue:[spec vrmlClass: (Smalltalk at: vrmlClassName)].	nodeTypes at: protoName put: spec.	^spec! !!VRMLNodeParser methodsFor: 'script parsing' stamp: 'ar 3/13/98 01:40'!parseScript: aVRMLStream	aVRMLStream skipSeparators.	aVRMLStream next = ${ ifFalse:[^self error: 'Script definition expected'].	self skipParens: $} from: aVRMLStream.	^VRMLUndefinedNode new.! !!VRMLNodeParser methodsFor: 'script parsing' stamp: 'ar 3/13/98 00:19'!readScriptEvent: aVRMLStream	| type name outer |	aVRMLStream skipSeparators.	type := aVRMLStream readName.	aVRMLStream skipSeparators.	name := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream backup.	aVRMLStream readName = 'IS' ifTrue:[		aVRMLStream discard.		aVRMLStream skipSeparators.		outer := aVRMLStream readName.	] ifFalse:[aVRMLStream restore].	^nil! !!VRMLNodeParser methodsFor: 'script parsing' stamp: 'ar 3/13/98 00:19'!readScriptField: aVRMLStream	| type name outer |	aVRMLStream skipSeparators.	type := aVRMLStream readName.	aVRMLStream skipSeparators.	name := aVRMLStream readName.	aVRMLStream skipSeparators.	aVRMLStream backup.	aVRMLStream readName = 'IS' ifTrue:[		aVRMLStream discard.		aVRMLStream skipSeparators.		outer := aVRMLStream readName.	] ifFalse:[aVRMLStream restore].	^nil! !!VRMLNodeParser methodsFor: 'testing' stamp: 'ar 3/12/98 23:37'!isPrototyping	^protoList notNil! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 3/12/98 00:36'!new	^super new initialize! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 3/12/98 00:33'!parse: aStream	^self new parseScene: aStream asVRMLStream.! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 8/17/1999 21:05'!parseFileNamed: aString	"VRMLNodeParser parseFileNamed:'C:\WDI-Website\Link 3D Models\08-17-99\vrml\test.wrl'"	"MessageTally spyOn:[		VRMLNodeParser 			parseFileNamed:'C:\WDI-Website\Link 3D Models\08-17-99\vrml\linkvrml97.WRL']"	| stream result |	stream := FileStream readOnlyFileNamed: aString.	result := self parse: stream.	stream close.	^result! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 3/12/98 00:32'!parseString: aString	^self parse: (ReadStream on: aString)! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 3/13/98 00:50'!parseURLs: aCollection	"Parse a collection of URLs return the result of first success"	^VRMLScene new! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 3/13/98 00:11'!initFields	"VRMLNodeParser initialize"	| selString multi typeString singleString multiString selector |	VRMLFieldTypes := Dictionary new.#(MFColor MFFloat MFInt32 MFNode MFRotation MFString MFTime MFVec2f MFVec3f SFBool SFColor SFFloat SFImage SFInt32 SFNode SFRotation SFString SFTime SFVec2f SFVec3f) do:[:sym|	multi := sym first = $M.	typeString := sym copyFrom: 3 to: sym size.	singleString := 'readSingleField', typeString, 'From:'.	multiString := 'readMultiField', typeString, 'From:'.	selString := multi ifTrue:[multiString] ifFalse:[singleString].	selector := selString asSymbol.	VRMLFieldTypes at: sym asString put: selector.	(self includesSelector: selector) ifFalse:[		multi			ifTrue:[self compileMultiFieldMethod: selString single: singleString]			ifFalse:[self compileSingleFieldMethod: selString type: typeString]].]. ! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 3/13/98 00:12'!initRuntimeFields	"VRMLNodeParser initialize"	VRMLRuntimeFieldTypes := Dictionary new.	VRMLFieldTypes associationsDo:[:assoc|		VRMLRuntimeFieldTypes at: assoc key put: assoc value.	].	VRMLRuntimeFieldTypes		at: 'fieldType' put: #readScriptField:;		at: 'eventType' put: #readScriptEvent:;		yourself.! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 3/13/98 00:06'!initScriptFields	"VRMLNodeParser initialize"	| |	VRMLScriptFieldTypes := Dictionary new.	VRMLFieldTypes associationsDo:[:assoc|		VRMLScriptFieldTypes at: assoc key put: assoc value.	].	VRMLScriptFieldTypes		at: 'fieldType' put: #parseScriptField:;		at: 'eventType' put: #parseScriptEvent:;		yourself.! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 3/13/98 00:58'!initStatements	"VRMLNodeParser initialize"	VRMLStatements := Dictionary new.	#(	DEF	USE	PROTO	EXTERNPROTO	ROUTE	Script	) do:[:sym| VRMLStatements at: sym asString put: ('parse',sym,':') asSymbol]! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 3/13/98 00:11'!initialize	"VRMLNodeParser initialize"	self initFields.	self initScriptFields.	self initRuntimeFields.	self initStatements.! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:08'!buildClasses	"VRMLNodeParser buildClasses"	VRMLNodeSpec currentSpecs do:[:nodeSpec|		(nodeSpec attributeNamed: 'children') notNil ifTrue:[			self compileCompositeNode: nodeSpec.		] ifFalse:[		('*Light*' match: nodeSpec name ) ifTrue:[			self compileLightNode: nodeSpec.		] ifFalse:[		('*Interpolator*' match: nodeSpec name) ifTrue:[			self compileInterpolatorNode: nodeSpec.		] ifFalse:[		('*Sensor*' match: nodeSpec name) ifTrue:[			self compileSensorNode: nodeSpec.		] ifFalse:[			self compileSimpleNode: nodeSpec.		]]]]].! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileCompositeNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLClassNode category:'VRML-Nodes-Composite'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileInterpolatorNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLClassNode category:'VRML-Nodes-Interpolators'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileLightNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLClassNode category:'VRML-Nodes-Light'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 3/11/98 23:19'!compileMultiFieldMethod: selString single: singleString	| source |	source := String streamContents:[:s|		s nextPutAll: selString.		s nextPutAll:' aVRMLStream'.		s nextPutAll:('	"This method was automatically generated"	| fields |	fields := OrderedCollection new.	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields add: (self $READSINGLE$ aVRMLStream).		^fields].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields add: (self $READSINGLE$ aVRMLStream).	].	aVRMLStream nextChar.	^fields.' copyReplaceAll:'$READSINGLE$' with: singleString).	].	self compile: source classified:'multi field parsing'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileNode: nodeSpec superClass: aClass category: aString	| varNames theClass |	(aClass includesBehavior: VRMLClassNode) ifFalse:[^self halt].	varNames := WriteStream on: (String new).	nodeSpec attributes do:[:attr|		('event*' match: attr attrClass ) ifFalse:[			varNames nextPutAll: (attr name copyReplaceAll:'_' with: '').			varNames space.		].	].	theClass := aClass subclass: (self vrmlClassNameFor: nodeSpec name) asSymbol		instanceVariableNames: varNames contents		classVariableNames: ''		poolDictionaries: ''		category: aString.	theClass nodeSpec: nodeSpec.! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileSensorNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLClassNode category:'VRML-Nodes-Sensors'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 8/18/1999 09:12'!compileSimpleNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLClassNode category:'VRML-Nodes-Simple'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 3/11/98 21:21'!compileSingleFieldMethod: selString type: typeString	| source |	source := String streamContents:[:s|		s nextPutAll: selString.		s nextPutAll:' aVRMLStream'.		s crtab.		s nextPutAll:'"This method was automatically generated"'.		s crtab.		s nextPutAll:'^aVRMLStream read'.		s nextPutAll: typeString.	].	self compile: source classified:'single field parsing'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 3/12/98 19:30'!vrmlClassNameFor: aString	^'VRML',aString,'Node'! !!VRMLNodeParser class methodsFor: 'documentation' stamp: 'ar 3/11/98 23:36'!vrml97NodeDefinition	"Node definitions from the VRML97 spec"^'Anchor {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField MFNode   children        []  exposedField SFString description     ""   exposedField MFString parameter       []  exposedField MFString url             []  field        SFVec3f  bboxCenter      0 0 0     # (-,)  field        SFVec3f  bboxSize        -1 -1 -1  # (0,) or -1,-1,-1}Appearance {   exposedField SFNode material          NULL  exposedField SFNode texture           NULL  exposedField SFNode textureTransform  NULL}AudioClip {   exposedField   SFString description      ""  exposedField   SFBool   loop             FALSE  exposedField   SFFloat  pitch            1.0        # (0,)  exposedField   SFTime   startTime        0          # (-,)  exposedField   SFTime   stopTime         0          # (-,)  exposedField   MFString url              []  eventOut       SFTime   duration_changed  eventOut       SFBool   isActive}Background {   eventIn      SFBool   set_bind  exposedField MFFloat  groundAngle  []         # [0,/2]  exposedField MFColor  groundColor  []         # [0,1]  exposedField MFString backUrl      []  exposedField MFString bottomUrl    []  exposedField MFString frontUrl     []  exposedField MFString leftUrl      []  exposedField MFString rightUrl     []  exposedField MFString topUrl       []  exposedField MFFloat  skyAngle     []         # [0,]  exposedField MFColor  skyColor     0 0 0      # [0,1]  eventOut     SFBool   isBound}Billboard {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField SFVec3f  axisOfRotation 0 1 0     #	(-,)  exposedField MFNode   children       []  field        SFVec3f  bboxCenter     0 0 0     #	(-,)  field        SFVec3f  bboxSize       -1 -1 -1  #	(0,) or -1,-1,-1}Box {   field    SFVec3f size  2 2 2        #	(0,	)}Collision {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField MFNode   children        []  exposedField SFBool   collide         TRUE  field        SFVec3f  bboxCenter      0 0 0      # (-,)  field        SFVec3f  bboxSize        -1 -1 -1   # (0,) or -1,-1,-1  field        SFNode   proxy           NULL  eventOut     SFTime   collideTime}Color {   exposedField MFColor color  []         # [0,1]}ColorInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFColor keyValue      []    # [0,1]  eventOut     SFColor value_changed}Cone {   field     SFFloat   bottomRadius 1        # (0,)  field     SFFloat   height       2        # (0,)  field     SFBool    side         TRUE  field     SFBool    bottom       TRUE}Coordinate {   exposedField MFVec3f point  []      # (-,)}CoordinateInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFVec3f keyValue      []    # (-,)  eventOut     MFVec3f value_changed}Cylinder {   field    SFBool    bottom  TRUE  field    SFFloat   height  2         # (0,)  field    SFFloat   radius  1         # (0,)  field    SFBool    side    TRUE  field    SFBool    top     TRUE}CylinderSensor {   exposedField SFBool     autoOffset TRUE  exposedField SFFloat    diskAngle  0.262       # (0,/2)  exposedField SFBool     enabled    TRUE  exposedField SFFloat    maxAngle   -1          # [-2,2]  exposedField SFFloat    minAngle   0           # [-2,2]  exposedField SFFloat    offset     0           # (-,)  eventOut     SFBool     isActive  eventOut     SFRotation rotation_changed  eventOut     SFVec3f    trackPoint_changed}DirectionalLight {   exposedField SFFloat ambientIntensity  0        # [0,1]  exposedField SFColor color             1 1 1    # [0,1]  exposedField SFVec3f direction         0 0 -1   # (-,)  exposedField SFFloat intensity         1        # [0,1]  exposedField SFBool  on                TRUE }ElevationGrid {   eventIn      MFFloat  set_height  exposedField SFNode   color             NULL  exposedField SFNode   normal            NULL  exposedField SFNode   texCoord          NULL  field        MFFloat  height            []      # (-,)  field        SFBool   ccw               TRUE  field        SFBool   colorPerVertex    TRUE  field        SFFloat  creaseAngle       0       # [0,]  field        SFBool   normalPerVertex   TRUE  field        SFBool   solid             TRUE  field        SFInt32  xDimension        0       # [0,)  field        SFFloat  xSpacing          1.0     # (0,)  field        SFInt32  zDimension        0       # [0,)  field        SFFloat  zSpacing          1.0     # (0,)}Extrusion {   eventIn MFVec2f    set_crossSection  eventIn MFRotation set_orientation  eventIn MFVec2f    set_scale  eventIn MFVec3f    set_spine  field   SFBool     beginCap         TRUE  field   SFBool     ccw              TRUE  field   SFBool     convex           TRUE  field   SFFloat    creaseAngle      0                # [0,)  field   MFVec2f    crossSection     [ 1 1, 1 -1, -1 -1,                                       -1 1, 1  1 ]    # (-,)  field   SFBool     endCap           TRUE  field   MFRotation orientation      0 0 1 0          # [-1,1],(-,)  field   MFVec2f    scale            1 1              # (0,)  field   SFBool     solid            TRUE  field   MFVec3f    spine            [ 0 0 0, 0 1 0 ] # (-,)}Fog {   exposedField SFColor  color            1 1 1      # [0,1]  exposedField SFString fogType          "LINEAR"  exposedField SFFloat  visibilityRange  0          # [0,)  eventIn      SFBool   set_bind  eventOut     SFBool   isBound}FontStyle {   field MFString family       "SERIF"  field SFBool   horizontal   TRUE  field MFString justify      "BEGIN"  field SFString language     ""  field SFBool   leftToRight  TRUE  field SFFloat  size         1.0          # (0,)  field SFFloat  spacing      1.0          # [0,)  field SFString style        "PLAIN"  field SFBool   topToBottom  TRUE}Group {   eventIn      MFNode  addChildren  eventIn      MFNode  removeChildren  exposedField MFNode  children      []  field        SFVec3f bboxCenter    0 0 0     #	(-,)  field        SFVec3f bboxSize      -1 -1 -1  #	(0,)	or	-1,-1,-1}ImageTexture {   exposedField MFString url     []  field        SFBool   repeatS TRUE  field        SFBool   repeatT TRUE}IndexedFaceSet {   eventIn       MFInt32 set_colorIndex  eventIn       MFInt32 set_coordIndex  eventIn       MFInt32 set_normalIndex  eventIn       MFInt32 set_texCoordIndex  exposedField  SFNode  color             NULL  exposedField  SFNode  coord             NULL  exposedField  SFNode  normal            NULL  exposedField  SFNode  texCoord          NULL  field         SFBool  ccw               TRUE  field         MFInt32 colorIndex        []        # [-1,)  field         SFBool  colorPerVertex    TRUE  field         SFBool  convex            TRUE  field         MFInt32 coordIndex        []        # [-1,)  field         SFFloat creaseAngle       0         # [0,)  field         MFInt32 normalIndex       []        # [-1,)  field         SFBool  normalPerVertex   TRUE  field         SFBool  solid             TRUE  field         MFInt32 texCoordIndex     []        # [-1,)}IndexedLineSet {   eventIn       MFInt32 set_colorIndex  eventIn       MFInt32 set_coordIndex  exposedField  SFNode  color             NULL  exposedField  SFNode  coord             NULL  field         MFInt32 colorIndex        []     # [-1,)  field         SFBool  colorPerVertex    TRUE  field         MFInt32 coordIndex        []     # [-1,)}Inline {   exposedField MFString url        []  field        SFVec3f  bboxCenter 0 0 0     #	(-,)  field        SFVec3f  bboxSize   -1 -1 -1  #	(0,)	or	-1,-1,-1}LOD {   exposedField MFNode  level    []   field        SFVec3f center   0 0 0    #	(-,)  field        MFFloat range    []       #	(0,)}Material {   exposedField SFFloat ambientIntensity  0.2         #	[0,1]  exposedField SFColor diffuseColor      0.8 0.8 0.8 #	[0,1]  exposedField SFColor emissiveColor     0 0 0       #	[0,1]  exposedField SFFloat shininess         0.2         #	[0,1]  exposedField SFColor specularColor     0 0 0       #	[0,1]  exposedField SFFloat transparency      0           #	[0,1]}MovieTexture {   exposedField SFBool   loop             FALSE  exposedField SFFloat  speed            1.0      #	(-,)  exposedField SFTime   startTime        0        #	(-,)  exposedField SFTime   stopTime         0        #	(-,)  exposedField MFString url              []  field        SFBool   repeatS          TRUE  field        SFBool   repeatT          TRUE  eventOut     SFTime   duration_changed  eventOut     SFBool   isActive}NavigationInfo {   eventIn      SFBool   set_bind  exposedField MFFloat  avatarSize      [0.25, 1.6, 0.75] #	[0,)  exposedField SFBool   headlight       TRUE  exposedField SFFloat  speed           1.0               #	[0,)  exposedField MFString type            ["WALK", "ANY"]  exposedField SFFloat  visibilityLimit 0.0               #	[0,)  eventOut     SFBool   isBound}Normal {   exposedField MFVec3f vector  []   #	(-,)}NormalInterpolator {   eventIn      SFFloat set_fraction       #	(-,)  exposedField MFFloat key           []   #	(-,)  exposedField MFVec3f keyValue      []   #	(-,)  eventOut     MFVec3f value_changed}OrientationInterpolator {   eventIn      SFFloat    set_fraction      #	(-,)  exposedField MFFloat    key           []  #	(-,)  exposedField MFRotation keyValue      []  # [-1,1],(-,)  eventOut     SFRotation value_changed}PixelTexture {   exposedField SFImage  image      0 0 0    # see 5.5, SFImage  field        SFBool   repeatS    TRUE  field        SFBool   repeatT    TRUE}PlaneSensor {   exposedField SFBool  autoOffset          TRUE  exposedField SFBool  enabled             TRUE  exposedField SFVec2f maxPosition         -1 -1     # (-,)  exposedField SFVec2f minPosition         0 0       # (-,)  exposedField SFVec3f offset              0 0 0     # (-,)  eventOut     SFBool  isActive  eventOut     SFVec3f trackPoint_changed  eventOut     SFVec3f translation_changed}PointLight {   exposedField SFFloat ambientIntensity  0       # [0,1]  exposedField SFVec3f attenuation       1 0 0   # [0,)  exposedField SFColor color             1 1 1   # [0,1]  exposedField SFFloat intensity         1       # [0,1]  exposedField SFVec3f location          0 0 0   # (-,)  exposedField SFBool  on                TRUE   exposedField SFFloat radius            100     # [0,)}PointSet {   exposedField  SFNode  color      NULL  exposedField  SFNode  coord      NULL}PositionInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFVec3f keyValue      []    # (-,)  eventOut     SFVec3f value_changed}ProximitySensor {   exposedField SFVec3f    center      0 0 0    # (-,)  exposedField SFVec3f    size        0 0 0    # [0,)  exposedField SFBool     enabled     TRUE  eventOut     SFBool     isActive  eventOut     SFVec3f    position_changed  eventOut     SFRotation orientation_changed  eventOut     SFTime     enterTime  eventOut     SFTime     exitTime}ScalarInterpolator {   eventIn      SFFloat set_fraction         # (-,)  exposedField MFFloat key           []     # (-,)  exposedField MFFloat keyValue      []     # (-,)  eventOut     SFFloat value_changed}Script {   exposedField MFString url           []   field        SFBool   directOutput  FALSE  field        SFBool   mustEvaluate  FALSE  # And any number of:  #eventIn      eventType eventName  #field        fieldType fieldName initialValue  #eventOut     eventType eventName}Shape {   exposedField SFNode appearance NULL  exposedField SFNode geometry   NULL}Sound {   exposedField SFVec3f  direction     0 0 1   # (-,)  exposedField SFFloat  intensity     1       # [0,1]  exposedField SFVec3f  location      0 0 0   # (-,)  exposedField SFFloat  maxBack       10      # [0,)  exposedField SFFloat  maxFront      10      # [0,)  exposedField SFFloat  minBack       1       # [0,)  exposedField SFFloat  minFront      1       # [0,)  exposedField SFFloat  priority      0       # [0,1]  exposedField SFNode   source        NULL  field        SFBool   spatialize    TRUE}Sphere {   field SFFloat radius  1    # (0,)}SphereSensor {   exposedField SFBool     autoOffset        TRUE  exposedField SFBool     enabled           TRUE  exposedField SFRotation offset            0 1 0 0  # [-1,1],(-,)  eventOut     SFBool     isActive  eventOut     SFRotation rotation_changed  eventOut     SFVec3f    trackPoint_changed}SpotLight {   exposedField SFFloat ambientIntensity  0         # [0,1]  exposedField SFVec3f attenuation       1 0 0     # [0,)  exposedField SFFloat beamWidth         1.570796  # (0,/2]  exposedField SFColor color             1 1 1     # [0,1]  exposedField SFFloat cutOffAngle       0.785398  # (0,/2]  exposedField SFVec3f direction         0 0 -1    # (-,)  exposedField SFFloat intensity         1         # [0,1]  exposedField SFVec3f location          0 0 0     # (-,)  exposedField SFBool  on                TRUE  exposedField SFFloat radius            100       # [0,)}Switch {   exposedField    MFNode  choice      []  exposedField    SFInt32 whichChoice -1    # [-1,)}Text {   exposedField  MFString string    []  exposedField  SFNode   fontStyle NULL  exposedField  MFFloat  length    []      # [0,)  exposedField  SFFloat  maxExtent 0.0     # [0,)}TextureCoordinate {   exposedField MFVec2f point  []      # (-,)}TextureTransform {   exposedField SFVec2f center      0 0     # (-,)  exposedField SFFloat rotation    0       # (-,)  exposedField SFVec2f scale       1 1     # (-,)  exposedField SFVec2f translation 0 0     # (-,)}TimeSensor {   exposedField SFTime   cycleInterval 1       # (0,)  exposedField SFBool   enabled       TRUE  exposedField SFBool   loop          FALSE  exposedField SFTime   startTime     0       # (-,)  exposedField SFTime   stopTime      0       # (-,)  eventOut     SFTime   cycleTime  eventOut     SFFloat  fraction_changed      # [0,	1]  eventOut     SFBool   isActive  eventOut     SFTime   time}TouchSensor {   exposedField SFBool  enabled TRUE  eventOut     SFVec3f hitNormal_changed  eventOut     SFVec3f hitPoint_changed  eventOut     SFVec2f hitTexCoord_changed  eventOut     SFBool  isActive  eventOut     SFBool  isOver  eventOut     SFTime  touchTime}Transform {   eventIn      MFNode      addChildren  eventIn      MFNode      removeChildren  exposedField SFVec3f     center           0 0 0    #	(-,)  exposedField MFNode      children         []  exposedField SFRotation  rotation         0 0 1 0  # [-1,1],(-,)  exposedField SFVec3f     scale            1 1 1    #	(0,)  exposedField SFRotation  scaleOrientation 0 0 1 0  # [-1,1],(-,)  exposedField SFVec3f     translation      0 0 0    #	(-,)  field        SFVec3f     bboxCenter       0 0 0    #	(-,)  field        SFVec3f     bboxSize         -1 -1 -1 #	(0,)	or	-1,-1,-1} Viewpoint {   eventIn      SFBool     set_bind  exposedField SFFloat    fieldOfView    0.785398  #	(0,)  exposedField SFBool     jump           TRUE  exposedField SFRotation orientation    0 0 1 0   # [-1,1],(-,)  exposedField SFVec3f    position       0 0 10    #	(-,)  field        SFString   description    ""  eventOut     SFTime     bindTime  eventOut     SFBool     isBound}VisibilitySensor {   exposedField SFVec3f center   0 0 0      #	(-,)  exposedField SFBool  enabled  TRUE  exposedField SFVec3f size     0 0 0      #	[0,)  eventOut     SFTime  enterTime  eventOut     SFTime  exitTime  eventOut     SFBool  isActive}WorldInfo {   field MFString info  []  field SFString title ""}'! !!VRMLNodeParser class methodsFor: 'documentation' stamp: 'ar 3/12/98 18:18'!vrml97Nodes	"VRMLNodeParser vrml97Nodes"	| stream |	stream := VRMLStream on: (ReadStream on: self vrml97NodeDefinition).	^VRMLNodeParser new parseDefinitions: stream! !!VRMLNodeParser class methodsFor: 'examples' stamp: 'ar 3/12/98 00:34'!exD10	"VRMLNodeParser parseString: VRMLNodeParser exD10"^'#VRML V2.0 utf8Shape {     geometry PointSet {        coord DEF mypts Coordinate { point [ 0 0 0, 2 2 2, 3 3 3 ] }        color Color { color [ 1 0 0, 0 1 0, 0 0 1 ] }    }}Transform {    translation 2 0 0    children Shape {        geometry PointSet {	    coord USE mypts	    color Color { color [ .5 .5 0, 0 .5 .5, 1 1 1 ] }        }    }}'! !!VRMLNodeSpec commentStamp: '<historical>' prior: 0!This class represents the specification for a VRML node.Instance variables:	name		<String>		The name of the node	attributes	<Collection of: VRMLNodeAttribute>	All defined attributes for this node	vrmlClass	<Class>		The class used for constructing an instance of this spec	nodeId		<Integer|nil>	The index of this node in the spec list	attrDict		<Dictionary>	The mapping of names to attributes!!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/13/98 14:04'!addAttribute: aVRMLNodeAttribute	self attributes add: aVRMLNodeAttribute.	self attrDict at: aVRMLNodeAttribute name put: aVRMLNodeAttribute.! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/13/98 14:04'!attrDict	^attrDict ifNil:[attrDict := Dictionary new].! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/13/98 14:04'!attributeNamed: aName	^self attrDict at: aName ifAbsent:[nil]! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 22:18'!attributes	^attributes! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/13/98 14:22'!defineGenericIn: aVRMLNode	self assert:[aVRMLNode isGeneric].	self attributes do:[:attr|		attr isDynamic ifFalse:[aVRMLNode defineAttribute: attr].	].! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/13/98 13:47'!getFieldNamed: aString	^self attributeNamed: aString! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 22:36'!name	^name! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 22:37'!newInstance	| vrmlInstance |	vrmlClass isNil ifTrue:[self error:'No class'].	vrmlInstance := vrmlClass fromSpec: self.	^vrmlInstance! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 21:38'!nodeId	^nodeId! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 21:07'!nodeId: anObject	nodeId _ anObject! !!VRMLNodeSpec methodsFor: 'accessing' stamp: 'ar 3/12/98 22:17'!vrmlClass: anObject	vrmlClass _ anObject! !!VRMLNodeSpec methodsFor: 'printing' stamp: 'ar 3/13/98 00:53'!print: aVRMLNode on: aVRMLStream indent: level	aVRMLStream nextPutAll: name.	aVRMLStream space.	aVRMLStream nextPut: ${; space; space.	self attributes do:[:attr|		attr print: aVRMLNode on: aVRMLStream indent: level + 1.	].	aVRMLStream skip: -1.	aVRMLStream nextPut:$}.! !!VRMLNodeSpec methodsFor: 'printing' stamp: 'ar 3/13/98 00:53'!printOn: aStream	aStream nextPut:$[.	aStream print: nodeId.	aStream nextPutAll:'] '.	aStream nextPutAll: name.	aStream nextPutAll:' {'.	aStream cr.	self attributes do:[:attr|		attr printOn: aStream.		aStream cr.	].	aStream nextPut:$}.! !!VRMLNodeSpec methodsFor: 'initialize' stamp: 'ar 3/13/98 01:28'!name: aString attributes: aCollection	name := aString.	attributes := aCollection.	attrDict := Dictionary new: attributes size.	vrmlClass := VRMLUndefinedNode.	aCollection do:[:attr| attrDict at: attr name put: attr].! !!VRMLNodeSpec methodsFor: 'reading' stamp: 'ar 3/13/98 13:32'!readAttributeFrom: aVRMLStream in: aParser	"Read an attribute"	| attrName attrSpec attrValue |	attrName := aVRMLStream readName.	attrSpec := self attributeNamed: attrName.	attrSpec notNil ifTrue:[		attrValue := attrSpec readFrom: aVRMLStream in: aParser.		^attrSpec -> attrValue].	self warn:'Unkown attribute: ', attrName.	aVRMLStream skip: 1.! !!VRMLNodeSpec methodsFor: 'reading' stamp: 'ar 3/12/98 22:28'!readFrom: aVRMLStream in: aParser	"Read a node"	| assoc vrmlInstance |	vrmlInstance := self newInstance.	aVRMLStream skipSeparators.	aVRMLStream nextChar = ${ ifFalse:[^self error:'Node definition expected'].	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $}] whileFalse:[		assoc := self readAttributeFrom: aVRMLStream in: aParser.		assoc key setValue: assoc value in: vrmlInstance.	].	aVRMLStream nextChar.	^vrmlInstance! !!VRMLNodeSpec methodsFor: 'testing' stamp: 'ar 3/13/98 13:32'!containsAttribute: nameString ofType: typeString	| attr |	attr := self attributeNamed: nameString.	^attr isNil		ifTrue:[false]		ifFalse:[attr type = typeString]! !!VRMLNodeSpec methodsFor: 'debug' stamp: 'ar 8/17/1999 19:46'!assert: aBlock	aBlock value ifFalse:[self error:'Assertion failed'].! !!VRMLNodeSpec class methodsFor: 'accessing' stamp: 'ar 3/12/98 21:09'!currentSpecs	^CurrentSpecs! !!VRMLNodeSpec class methodsFor: 'accessing' stamp: 'ar 3/13/98 01:30'!undefinedSpec	^UndefinedSpec! !!VRMLNodeSpec class methodsFor: 'vrml97' stamp: 'ar 3/13/98 00:08'!vrml97NodeDefinition	"Node definitions from the VRML97 spec - HACKED in Script node!!"^'Anchor {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField MFNode   children        []  exposedField SFString description     ""   exposedField MFString parameter       []  exposedField MFString url             []  field        SFVec3f  bboxCenter      0 0 0     # (-,)  field        SFVec3f  bboxSize        -1 -1 -1  # (0,) or -1,-1,-1}Appearance {   exposedField SFNode material          NULL  exposedField SFNode texture           NULL  exposedField SFNode textureTransform  NULL}AudioClip {   exposedField   SFString description      ""  exposedField   SFBool   loop             FALSE  exposedField   SFFloat  pitch            1.0        # (0,)  exposedField   SFTime   startTime        0          # (-,)  exposedField   SFTime   stopTime         0          # (-,)  exposedField   MFString url              []  eventOut       SFTime   duration_changed  eventOut       SFBool   isActive}Background {   eventIn      SFBool   set_bind  exposedField MFFloat  groundAngle  []         # [0,/2]  exposedField MFColor  groundColor  []         # [0,1]  exposedField MFString backUrl      []  exposedField MFString bottomUrl    []  exposedField MFString frontUrl     []  exposedField MFString leftUrl      []  exposedField MFString rightUrl     []  exposedField MFString topUrl       []  exposedField MFFloat  skyAngle     []         # [0,]  exposedField MFColor  skyColor     0 0 0      # [0,1]  eventOut     SFBool   isBound}Billboard {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField SFVec3f  axisOfRotation 0 1 0     #	(-,)  exposedField MFNode   children       []  field        SFVec3f  bboxCenter     0 0 0     #	(-,)  field        SFVec3f  bboxSize       -1 -1 -1  #	(0,) or -1,-1,-1}Box {   field    SFVec3f size  2 2 2        #	(0,	)}Collision {   eventIn      MFNode   addChildren  eventIn      MFNode   removeChildren  exposedField MFNode   children        []  exposedField SFBool   collide         TRUE  field        SFVec3f  bboxCenter      0 0 0      # (-,)  field        SFVec3f  bboxSize        -1 -1 -1   # (0,) or -1,-1,-1  field        SFNode   proxy           NULL  eventOut     SFTime   collideTime}Color {   exposedField MFColor color  []         # [0,1]}ColorInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFColor keyValue      []    # [0,1]  eventOut     SFColor value_changed}Cone {   field     SFFloat   bottomRadius 1        # (0,)  field     SFFloat   height       2        # (0,)  field     SFBool    side         TRUE  field     SFBool    bottom       TRUE}Coordinate {   exposedField MFVec3f point  []      # (-,)}CoordinateInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFVec3f keyValue      []    # (-,)  eventOut     MFVec3f value_changed}Cylinder {   field    SFBool    bottom  TRUE  field    SFFloat   height  2         # (0,)  field    SFFloat   radius  1         # (0,)  field    SFBool    side    TRUE  field    SFBool    top     TRUE}CylinderSensor {   exposedField SFBool     autoOffset TRUE  exposedField SFFloat    diskAngle  0.262       # (0,/2)  exposedField SFBool     enabled    TRUE  exposedField SFFloat    maxAngle   -1          # [-2,2]  exposedField SFFloat    minAngle   0           # [-2,2]  exposedField SFFloat    offset     0           # (-,)  eventOut     SFBool     isActive  eventOut     SFRotation rotation_changed  eventOut     SFVec3f    trackPoint_changed}DirectionalLight {   exposedField SFFloat ambientIntensity  0        # [0,1]  exposedField SFColor color             1 1 1    # [0,1]  exposedField SFVec3f direction         0 0 -1   # (-,)  exposedField SFFloat intensity         1        # [0,1]  exposedField SFBool  on                TRUE }ElevationGrid {   eventIn      MFFloat  set_height  exposedField SFNode   color             NULL  exposedField SFNode   normal            NULL  exposedField SFNode   texCoord          NULL  field        MFFloat  height            []      # (-,)  field        SFBool   ccw               TRUE  field        SFBool   colorPerVertex    TRUE  field        SFFloat  creaseAngle       0       # [0,]  field        SFBool   normalPerVertex   TRUE  field        SFBool   solid             TRUE  field        SFInt32  xDimension        0       # [0,)  field        SFFloat  xSpacing          1.0     # (0,)  field        SFInt32  zDimension        0       # [0,)  field        SFFloat  zSpacing          1.0     # (0,)}Extrusion {   eventIn MFVec2f    set_crossSection  eventIn MFRotation set_orientation  eventIn MFVec2f    set_scale  eventIn MFVec3f    set_spine  field   SFBool     beginCap         TRUE  field   SFBool     ccw              TRUE  field   SFBool     convex           TRUE  field   SFFloat    creaseAngle      0                # [0,)  field   MFVec2f    crossSection     [ 1 1, 1 -1, -1 -1,                                       -1 1, 1  1 ]    # (-,)  field   SFBool     endCap           TRUE  field   MFRotation orientation      0 0 1 0          # [-1,1],(-,)  field   MFVec2f    scale            1 1              # (0,)  field   SFBool     solid            TRUE  field   MFVec3f    spine            [ 0 0 0, 0 1 0 ] # (-,)}Fog {   exposedField SFColor  color            1 1 1      # [0,1]  exposedField SFString fogType          "LINEAR"  exposedField SFFloat  visibilityRange  0          # [0,)  eventIn      SFBool   set_bind  eventOut     SFBool   isBound}FontStyle {   field MFString family       "SERIF"  field SFBool   horizontal   TRUE  field MFString justify      "BEGIN"  field SFString language     ""  field SFBool   leftToRight  TRUE  field SFFloat  size         1.0          # (0,)  field SFFloat  spacing      1.0          # [0,)  field SFString style        "PLAIN"  field SFBool   topToBottom  TRUE}Group {   eventIn      MFNode  addChildren  eventIn      MFNode  removeChildren  exposedField MFNode  children      []  field        SFVec3f bboxCenter    0 0 0     #	(-,)  field        SFVec3f bboxSize      -1 -1 -1  #	(0,)	or	-1,-1,-1}ImageTexture {   exposedField MFString url     []  field        SFBool   repeatS TRUE  field        SFBool   repeatT TRUE}IndexedFaceSet {   eventIn       MFInt32 set_colorIndex  eventIn       MFInt32 set_coordIndex  eventIn       MFInt32 set_normalIndex  eventIn       MFInt32 set_texCoordIndex  exposedField  SFNode  color             NULL  exposedField  SFNode  coord             NULL  exposedField  SFNode  normal            NULL  exposedField  SFNode  texCoord          NULL  field         SFBool  ccw               TRUE  field         MFInt32 colorIndex        []        # [-1,)  field         SFBool  colorPerVertex    TRUE  field         SFBool  convex            TRUE  field         MFInt32 coordIndex        []        # [-1,)  field         SFFloat creaseAngle       0         # [0,)  field         MFInt32 normalIndex       []        # [-1,)  field         SFBool  normalPerVertex   TRUE  field         SFBool  solid             TRUE  field         MFInt32 texCoordIndex     []        # [-1,)}IndexedLineSet {   eventIn       MFInt32 set_colorIndex  eventIn       MFInt32 set_coordIndex  exposedField  SFNode  color             NULL  exposedField  SFNode  coord             NULL  field         MFInt32 colorIndex        []     # [-1,)  field         SFBool  colorPerVertex    TRUE  field         MFInt32 coordIndex        []     # [-1,)}Inline {   exposedField MFString url        []  field        SFVec3f  bboxCenter 0 0 0     #	(-,)  field        SFVec3f  bboxSize   -1 -1 -1  #	(0,)	or	-1,-1,-1}LOD {   exposedField MFNode  level    []   field        SFVec3f center   0 0 0    #	(-,)  field        MFFloat range    []       #	(0,)}Material {   exposedField SFFloat ambientIntensity  0.2         #	[0,1]  exposedField SFColor diffuseColor      0.8 0.8 0.8 #	[0,1]  exposedField SFColor emissiveColor     0 0 0       #	[0,1]  exposedField SFFloat shininess         0.2         #	[0,1]  exposedField SFColor specularColor     0 0 0       #	[0,1]  exposedField SFFloat transparency      0           #	[0,1]}MovieTexture {   exposedField SFBool   loop             FALSE  exposedField SFFloat  speed            1.0      #	(-,)  exposedField SFTime   startTime        0        #	(-,)  exposedField SFTime   stopTime         0        #	(-,)  exposedField MFString url              []  field        SFBool   repeatS          TRUE  field        SFBool   repeatT          TRUE  eventOut     SFTime   duration_changed  eventOut     SFBool   isActive}NavigationInfo {   eventIn      SFBool   set_bind  exposedField MFFloat  avatarSize      [0.25, 1.6, 0.75] #	[0,)  exposedField SFBool   headlight       TRUE  exposedField SFFloat  speed           1.0               #	[0,)  exposedField MFString type            ["WALK", "ANY"]  exposedField SFFloat  visibilityLimit 0.0               #	[0,)  eventOut     SFBool   isBound}Normal {   exposedField MFVec3f vector  []   #	(-,)}NormalInterpolator {   eventIn      SFFloat set_fraction       #	(-,)  exposedField MFFloat key           []   #	(-,)  exposedField MFVec3f keyValue      []   #	(-,)  eventOut     MFVec3f value_changed}OrientationInterpolator {   eventIn      SFFloat    set_fraction      #	(-,)  exposedField MFFloat    key           []  #	(-,)  exposedField MFRotation keyValue      []  # [-1,1],(-,)  eventOut     SFRotation value_changed}PixelTexture {   exposedField SFImage  image      0 0 0    # see 5.5, SFImage  field        SFBool   repeatS    TRUE  field        SFBool   repeatT    TRUE}PlaneSensor {   exposedField SFBool  autoOffset          TRUE  exposedField SFBool  enabled             TRUE  exposedField SFVec2f maxPosition         -1 -1     # (-,)  exposedField SFVec2f minPosition         0 0       # (-,)  exposedField SFVec3f offset              0 0 0     # (-,)  eventOut     SFBool  isActive  eventOut     SFVec3f trackPoint_changed  eventOut     SFVec3f translation_changed}PointLight {   exposedField SFFloat ambientIntensity  0       # [0,1]  exposedField SFVec3f attenuation       1 0 0   # [0,)  exposedField SFColor color             1 1 1   # [0,1]  exposedField SFFloat intensity         1       # [0,1]  exposedField SFVec3f location          0 0 0   # (-,)  exposedField SFBool  on                TRUE   exposedField SFFloat radius            100     # [0,)}PointSet {   exposedField  SFNode  color      NULL  exposedField  SFNode  coord      NULL}PositionInterpolator {   eventIn      SFFloat set_fraction        # (-,)  exposedField MFFloat key           []    # (-,)  exposedField MFVec3f keyValue      []    # (-,)  eventOut     SFVec3f value_changed}ProximitySensor {   exposedField SFVec3f    center      0 0 0    # (-,)  exposedField SFVec3f    size        0 0 0    # [0,)  exposedField SFBool     enabled     TRUE  eventOut     SFBool     isActive  eventOut     SFVec3f    position_changed  eventOut     SFRotation orientation_changed  eventOut     SFTime     enterTime  eventOut     SFTime     exitTime}ScalarInterpolator {   eventIn      SFFloat set_fraction         # (-,)  exposedField MFFloat key           []     # (-,)  exposedField MFFloat keyValue      []     # (-,)  eventOut     SFFloat value_changed}Script {   exposedField MFString url           []   field        SFBool   directOutput  FALSE  field        SFBool   mustEvaluate  FALSE  # And any number of:	#eventIn      eventType eventName	#field        fieldType fieldName initialValue	#eventOut     eventType eventName	# AR note: This has been hacked !!	dummy		eventType	eventIn	dummy		eventType	eventOut	dummy 		fieldType	field}Shape {   exposedField SFNode appearance NULL  exposedField SFNode geometry   NULL}Sound {   exposedField SFVec3f  direction     0 0 1   # (-,)  exposedField SFFloat  intensity     1       # [0,1]  exposedField SFVec3f  location      0 0 0   # (-,)  exposedField SFFloat  maxBack       10      # [0,)  exposedField SFFloat  maxFront      10      # [0,)  exposedField SFFloat  minBack       1       # [0,)  exposedField SFFloat  minFront      1       # [0,)  exposedField SFFloat  priority      0       # [0,1]  exposedField SFNode   source        NULL  field        SFBool   spatialize    TRUE}Sphere {   field SFFloat radius  1    # (0,)}SphereSensor {   exposedField SFBool     autoOffset        TRUE  exposedField SFBool     enabled           TRUE  exposedField SFRotation offset            0 1 0 0  # [-1,1],(-,)  eventOut     SFBool     isActive  eventOut     SFRotation rotation_changed  eventOut     SFVec3f    trackPoint_changed}SpotLight {   exposedField SFFloat ambientIntensity  0         # [0,1]  exposedField SFVec3f attenuation       1 0 0     # [0,)  exposedField SFFloat beamWidth         1.570796  # (0,/2]  exposedField SFColor color             1 1 1     # [0,1]  exposedField SFFloat cutOffAngle       0.785398  # (0,/2]  exposedField SFVec3f direction         0 0 -1    # (-,)  exposedField SFFloat intensity         1         # [0,1]  exposedField SFVec3f location          0 0 0     # (-,)  exposedField SFBool  on                TRUE  exposedField SFFloat radius            100       # [0,)}Switch {   exposedField    MFNode  choice      []  exposedField    SFInt32 whichChoice -1    # [-1,)}Text {   exposedField  MFString string    []  exposedField  SFNode   fontStyle NULL  exposedField  MFFloat  length    []      # [0,)  exposedField  SFFloat  maxExtent 0.0     # [0,)}TextureCoordinate {   exposedField MFVec2f point  []      # (-,)}TextureTransform {   exposedField SFVec2f center      0 0     # (-,)  exposedField SFFloat rotation    0       # (-,)  exposedField SFVec2f scale       1 1     # (-,)  exposedField SFVec2f translation 0 0     # (-,)}TimeSensor {   exposedField SFTime   cycleInterval 1       # (0,)  exposedField SFBool   enabled       TRUE  exposedField SFBool   loop          FALSE  exposedField SFTime   startTime     0       # (-,)  exposedField SFTime   stopTime      0       # (-,)  eventOut     SFTime   cycleTime  eventOut     SFFloat  fraction_changed      # [0,	1]  eventOut     SFBool   isActive  eventOut     SFTime   time}TouchSensor {   exposedField SFBool  enabled TRUE  eventOut     SFVec3f hitNormal_changed  eventOut     SFVec3f hitPoint_changed  eventOut     SFVec2f hitTexCoord_changed  eventOut     SFBool  isActive  eventOut     SFBool  isOver  eventOut     SFTime  touchTime}Transform {   eventIn      MFNode      addChildren  eventIn      MFNode      removeChildren  exposedField SFVec3f     center           0 0 0    #	(-,)  exposedField MFNode      children         []  exposedField SFRotation  rotation         0 0 1 0  # [-1,1],(-,)  exposedField SFVec3f     scale            1 1 1    #	(0,)  exposedField SFRotation  scaleOrientation 0 0 1 0  # [-1,1],(-,)  exposedField SFVec3f     translation      0 0 0    #	(-,)  field        SFVec3f     bboxCenter       0 0 0    #	(-,)  field        SFVec3f     bboxSize         -1 -1 -1 #	(0,)	or	-1,-1,-1} Viewpoint {   eventIn      SFBool     set_bind  exposedField SFFloat    fieldOfView    0.785398  #	(0,)  exposedField SFBool     jump           TRUE  exposedField SFRotation orientation    0 0 1 0   # [-1,1],(-,)  exposedField SFVec3f    position       0 0 10    #	(-,)  field        SFString   description    ""  eventOut     SFTime     bindTime  eventOut     SFBool     isBound}VisibilitySensor {   exposedField SFVec3f center   0 0 0      #	(-,)  exposedField SFBool  enabled  TRUE  exposedField SFVec3f size     0 0 0      #	[0,)  eventOut     SFTime  enterTime  eventOut     SFTime  exitTime  eventOut     SFBool  isActive}WorldInfo {   field MFString info  []  field SFString title ""}'! !!VRMLNodeSpec class methodsFor: 'vrml97' stamp: 'ar 3/12/98 21:04'!vrml97Nodes	"VRMLNodeSpec initialize"	| stream |	stream := VRMLStream on: (ReadStream on: self vrml97NodeDefinition).	^VRMLNodeParser new parseDefinitions: stream! !!VRMLNodeSpec class methodsFor: 'class initialization' stamp: 'ar 8/17/1999 19:33'!initialize	"VRMLNodeSpec initialize"	VRMLStream initialize.	VRMLNodeParser initialize.	CurrentSpecs := self vrml97Nodes.	UndefinedSpec := VRMLNodeSpec name:'Undefined' attributes: #().	CurrentSpecs doWithIndex:[:nodeSpec :index|		nodeSpec nodeId: index.	].! !!VRMLNodeSpec class methodsFor: 'instance creation' stamp: 'ar 3/12/98 22:16'!name: aString attributes: aCollection	^self new name: aString attributes: aCollection! !!VRMLProtoNode reorganize!('initialize' fromSpec:)('accessing' nodeSpec)('testing' isPrototype)('enumerating' doWith:)!!VRMLProtoNode methodsFor: 'initialize' stamp: 'ar 3/13/98 14:23'!fromSpec: aNodeSpec	nodeSpec := aNodeSpec.	super fromSpec: aNodeSpec.	protoType := (aNodeSpec attributeNamed:'protoType') value vrmlProtoCopy.! !!VRMLProtoNode methodsFor: 'accessing' stamp: 'ar 3/13/98 00:24'!nodeSpec	^nodeSpec! !!VRMLProtoNode methodsFor: 'testing' stamp: 'ar 3/13/98 00:27'!isPrototype	^true! !!VRMLProtoNode methodsFor: 'enumerating' stamp: 'ar 8/18/1999 10:02'!doWith: aVRMLEnumerator	protoType doWith: aVRMLEnumerator! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/12/98 20:26'!addNode: aVRMLNode	self nodes add: aVRMLNode! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/13/98 00:41'!addPrototype: aCollection spec: aNodeSpec	self prototypes at: aNodeSpec put: aCollection! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/13/98 00:57'!defineNode: nodeName value: aVRMLNode	self definedNodes at: nodeName put: aVRMLNode.! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/12/98 20:25'!definedNode: nodeName 	^self definedNodes at: nodeName! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/12/98 20:25'!definedNodes	^defs ifNil:[defs := Dictionary new]! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/12/98 20:23'!nodes	^nodes ifNil:[nodes := OrderedCollection new].! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/13/98 01:40'!prototypeAt: aNodeSpec	^self prototypes at: aNodeSpec ifAbsent:[Array with:VRMLUndefinedNode new].! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/13/98 00:41'!prototypes	^protos ifNil:[protos := Dictionary new].! !!VRMLScene methodsFor: 'node accessing' stamp: 'ar 3/13/98 13:43'!renderNodes	^self nodes! !!VRMLScene methodsFor: 'printing' stamp: 'ar 3/12/98 21:55'!printOn: aStream	VRMLWriter default writeScene: self on: aStream asVRMLStream.! !!VRMLScene methodsFor: 'actions' stamp: 'ar 8/17/1999 22:13'!actions	^actions ifNil:[actions _ Dictionary new].! !!VRMLScene methodsFor: 'actions' stamp: 'ar 8/17/1999 22:29'!routeFrom: fromNode event: outEventName to: toNode event: inEventName	| inEvent outEvent list |	outEvent _ (self definedNode: fromNode) outEventNamed: outEventName.	outEvent == nil ifTrue:[self error: outEventName,' is not a valid event'].	inEvent _ (self definedNode: toNode) inEventNamed: inEventName.	inEvent == nil ifTrue:[self error: inEventName,' is not a valid event'].	list _ (self actions at: fromNode ifAbsentPut:[Dictionary new])			at: outEvent ifAbsentPut:[Dictionary new].	(list at: toNode ifAbsentPut:[Set new]) add: inEvent.! !!VRMLScene methodsFor: 'enumerating' stamp: 'ar 8/18/1999 19:45'!doWith: aVRMLEnumerator	nodes do:[:node| node doWith: aVRMLEnumerator].! !!VRMLScene methodsFor: 'accessing' stamp: 'ar 9/14/1999 20:03'!fileURL	^fileURL! !!VRMLScene methodsFor: 'accessing' stamp: 'ar 9/14/1999 20:04'!fileURL: aURL	fileURL _ aURL! !!VRMLStandardNode methodsFor: 'initialize' stamp: 'ar 3/13/98 00:23'!fromSpec: aNodeSpec	nodeId := aNodeSpec nodeId.	super fromSpec: aNodeSpec! !!VRMLStandardNode methodsFor: 'accessing' stamp: 'ar 3/13/98 00:23'!nodeSpec	^VRMLNodeSpec currentSpecs at: nodeId! !!VRMLStream commentStamp: '<historical>' prior: 0!A VRMLStream supports reading/writing of UTF8 characters and the basic VRML types such as Int32, Float, Bool, and String.!!VRMLStream methodsFor: 'initialize' stamp: 'ar 3/12/98 18:19'!on: refStream	theStream := refStream.	backups := OrderedCollection new: 100.! !!VRMLStream methodsFor: 'initialize' stamp: 'ar 3/11/98 22:31'!reset	backups := OrderedCollection new: 100.	theStream reset.! !!VRMLStream methodsFor: 'initialize' stamp: 'ar 3/12/98 00:36'!resetAndCheckVersion	"Check for #VRML V2.0 utf8"	| version charSet |	self reset.	"Check basic type of VRML file"	'#VRML V' do:[:char| theStream next = char ifFalse:[^nil]].	version := theStream next: 3.	charSet := WriteStream on: String new.	theStream next = Character space ifTrue:[		[char := theStream next.		char asciiValue = 32 or:[char asciiValue = 13 or:[char asciiValue = 10]]		] whileFalse:[ charSet nextPut: char].	].	self reset.	^Array with: version with: charSet contents.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/14/1999 20:05'!name	^theStream name! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 22:52'!next	^self nextChar! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 23:33'!nextByte	^theStream next asInteger! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/12/98 18:29'!nextPut: aChar	^self nextPutChar: aChar.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/12/98 18:30'!nextPutAll: aCollection	aCollection do: [:v | self nextPut: v].	^aCollection! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 22:52'!peekFor: anObject	| nextObject |	self atEnd ifTrue: [^false].	nextObject _ self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	self position: self position - 1.	^false! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 19:39'!position	^theStream position! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 19:40'!position: aNumber	theStream position: aNumber! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/13/98 02:01'!size	^theStream size! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 22:28'!skip: n	theStream skip: n! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 22:25'!skipLine	| char |	[char := self nextChar.	char asciiValue = 13 or:[char asciiValue = 10]] whileFalse.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 3/11/98 23:32'!skipSeparators	| char |	[self atEnd ifTrue:[^self].	char := self nextChar.	SeparatorChars includes: char asciiValue] whileTrue:[		char = $# ifTrue:[self skipLine].	].	self skip: -1.! !!VRMLStream methodsFor: 'testing' stamp: 'ar 3/11/98 22:28'!atEnd	^theStream atEnd! !!VRMLStream methodsFor: 'backup-restore' stamp: 'ar 3/11/98 19:39'!backup	backups addLast: self position.! !!VRMLStream methodsFor: 'backup-restore' stamp: 'ar 3/11/98 19:40'!discard	backups removeLast! !!VRMLStream methodsFor: 'backup-restore' stamp: 'ar 3/11/98 19:40'!restore	self position: backups removeLast.! !!VRMLStream methodsFor: 'backup-restore' stamp: 'ar 3/11/98 19:40'!restoreIf: aBoolean	aBoolean		ifTrue:[self restore]		ifFalse:[self discard]! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 3/11/98 22:34'!firstChar	| char |	self backup.	char := self utf8Char.	(NonFirstChars includes: char asciiValue) ifTrue:[		self restore.		^nil	] ifFalse:[		self discard.		^char	].! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 3/11/98 22:30'!nextChar	^self utf8Char! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 3/11/98 22:37'!peekChar	| pos char |	pos := self position.	char := self nextChar.	self position: pos.	^char! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 3/12/98 23:31'!restChar	| char |	self atEnd ifTrue:[^nil].	self backup.	char := self utf8Char.	(NonRestChars includes: char asciiValue) ifTrue:[		self restore.		^nil	] ifFalse:[		self discard.		^char	].! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 3/11/98 19:57'!utf8Char	"Note: we silently clamp every char to US ASCII range"	| firstByte lastByte maskValue prevByte |	firstByte := lastByte := self nextByte.	firstByte < 128 ifTrue:[^Character value: firstByte].	self halt.	"More than one byte"	maskValue := 2r00100000.	[prevByte := lastByte.	lastByte := self nextByte.	(firstByte bitAnd: maskValue) = 0] whileTrue:[		maskValue := maskValue bitShift: -1.	].	^Character value: (lastByte bitAnd: 2r00111111) + ((prevByte bitAnd: 1) bitShift: 6).! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/12/98 23:41'!next: anInteger   | array |array _ String new: anInteger.    1 to: anInteger do: [:i |        array at: i put: self next].    ^ array! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 20:41'!readBool	| string bool |	self backup.	string := self readName.	string = 'TRUE' ifTrue:[bool := true].	string = 'FALSE' ifTrue:[bool := false].	self restoreIf: bool isNil.	^bool! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 21:16'!readColor	^self readFloatVector: 3 do:[:array|		Color r: (array at: 1) g: (array at: 2) b: (array at: 3).	].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 21:21'!readDouble	^self readFloat! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 9/15/1999 16:03'!readFloat	| intVal fracVal expVal char s floatValue fracExp negative |	self backup.	s := ReadWriteStream on: (String new: 10).	fracVal := 0.0.	"Read sign"	negative _ self peekChar = $-.	negative ifTrue:[self skip: 1].	"Read integer part"	(self peekChar = $.) 		ifTrue:[intVal := 0]		ifFalse:[intVal := self readInt32].	"Read fraction part"	self peekChar = $. ifTrue:[		self skip: 1.		fracExp := 1.		[(char := self nextChar) isDigit] whileTrue:[s nextPut: char. fracExp := fracExp * 10].		self skip: -1.		s reset.		fracVal := Integer readFrom: s.		fracVal := fracVal asFloat / fracExp asFloat.	].	"Check for exponent"	self peekChar asLowercase = $e ifTrue:[		self skip: 1.		expVal := self readInt32.	] ifFalse:[expVal := 1].	floatValue := intVal asFloat + fracVal.	expVal = 1 ifFalse:[ floatValue := floatValue raisedTo: expVal].	self discard.	negative		ifTrue:[^0.0 - floatValue]		ifFalse:[^floatValue]! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/12/98 01:05'!readFloatVector: n do: aBlock	| vec value |	self backup.	vec := Array new: n.	1 to: n do:[:i |		value := self readFloat.		value isNil ifTrue:[self restore. ^nil].		vec at: i put: value.		i < n ifTrue:[self skipSeparators].	].	self discard.	^aBlock value: vec! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/12/98 01:23'!readImage	| width height nComponents pixels size |	width := self readInt32.	self skipSeparators.	height := self readInt32.	size := width * height.	self skipSeparators.	nComponents := self readInt32.	self skipSeparators.	nComponents <= 4 ifTrue:[		pixels := Bitmap new: size.	] ifFalse:[		pixels := Array new: size.	].	1 to: size do:[:i|		self skipSeparators.		pixels at: i put: self readInt32.	].	^Array with: width with: height with: nComponents with: pixels.! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 23:00'!readInt32	| negative intVal char |	self backup.	negative := false.	"Read sign"	char := self nextChar.	char isDigit ifFalse:[		char = $- ifTrue:[			negative := true		] ifFalse:[			char = $+ ifFalse:[ self restore. ^nil]].		char := self nextChar].	(char = $0 and:[self peekChar asLowercase = $x]) ifTrue:[		"hexadecimal notation"		self skip: 1.		intVal := Integer readFrom: self base: 16.	] ifFalse:[		"decimal notation"		self skip: -1.		intVal := Integer readFrom: self base: 10.	].	self discard.	^negative		ifTrue:[intVal negated]		ifFalse:[intVal]! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/12/98 18:39'!readName	| out char |	self skipSeparators.	out := WriteStream on: (String new: 20).	char := self firstChar.	char ifNil:[^nil].	out nextPut: char.	[char := self restChar.	char notNil] whileTrue:[		out nextPut: char.	].	^out contents! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 21:17'!readRotation	^self readFloatVector: 4 do:[:array|		array	].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 21:19'!readString	| out char |	out := WriteStream on: (String new: 10).	self peekChar = $" ifFalse:[ ^nil].	self skip: 1.	[char := self nextChar.	char = $\ ifTrue:[char := self nextChar].	char = $"] whileFalse:[out nextPut: char].	^out contents! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 3/11/98 21:20'!readTime	^self readDouble! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 8/18/1999 20:11'!readVec2f	^self readFloatVector: 2 do:[:array| array].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 8/18/1999 20:11'!readVec3f	^self readFloatVector: 3 do:[:array| array].! !!VRMLStream methodsFor: 'converting' stamp: 'ar 3/12/98 00:33'!asVRMLStream	^self! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:20'!writeBool: aBoolean	self nextPutAll: (aBoolean ifTrue:['TRUE'] ifFalse:['FALSE']).! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:21'!writeDouble: aDouble	self writeFloat: aDouble! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:22'!writeFloat: aFloat	self nextPutAll: aFloat printString.! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:26'!writeFloatVector: aCollection	1 to: aCollection size do:[:i|		self writeFloat: (aCollection at: i).		i < aCollection size ifTrue:[self space].	].! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:24'!writeImage: anArray	| width height nComponents pixels size |	width := anArray at: 1.	height := anArray at: 2.	size := width * height.	nComponents := anArray at: 3.	pixels := anArray at: 4.	self writeInt32: width.	self space.	self writeInt32: height.	self space.	self writeInt32: nComponents.	self space.	1 to: size do:[:i|		self writeInt32: (pixels at: i).	].! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:25'!writeInt32: anInteger	self nextPutAll: anInteger printString.! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:25'!writeRotation: anArray	self writeFloatVector: anArray.! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:27'!writeString: aString	self nextPut:$".	aString do:[:char|		char = $" ifTrue:[self nextPut:$\].		char = $\ ifTrue:[self nextPut:$\].		self nextPut: char.	].	self nextPut:$".! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:28'!writeTime: aTime	self writeDouble: aTime! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:28'!writeVec2f: anArray	self writeFloatVector: anArray.! !!VRMLStream methodsFor: 'writing data' stamp: 'ar 3/12/98 18:28'!writeVec3f: anArray	self writeFloatVector: anArray.! !!VRMLStream methodsFor: 'character writing' stamp: 'ar 3/12/98 21:55'!cr	theStream cr.! !!VRMLStream methodsFor: 'character writing' stamp: 'ar 3/13/98 02:35'!crtab	self crtab: 1.! !!VRMLStream methodsFor: 'character writing' stamp: 'ar 3/13/98 02:35'!crtab: level	theStream cr.	theStream next: level put: Character space! !!VRMLStream methodsFor: 'character writing' stamp: 'ar 3/12/98 18:39'!nextPutChar: aChar	| firstChar lastChar |	aChar asciiValue < 128 ifTrue:[^theStream nextPut: aChar].	firstChar := 2r11000000 + (aChar asciiValue bitShift: -6).	lastChar := 2r10000000 + (aChar asciiValue bitAnd: 2r00111111).	theStream nextPut: firstChar asCharacter; nextPut: lastChar asCharacter.	^aChar! !!VRMLStream methodsFor: 'character writing' stamp: 'ar 3/12/98 19:20'!space	theStream space.! !!VRMLStream methodsFor: 'writing fields' stamp: 'ar 3/12/98 20:50'!writeColor: aColor	self writeFloat: (aColor red roundTo: 0.001).	self space.	self writeFloat: (aColor green roundTo: 0.001).	self space.	self writeFloat: (aColor blue roundTo: 0.001).! !!VRMLStream class methodsFor: 'class initialization' stamp: 'ar 3/12/98 19:13'!initialize	"VRMLStream initialize"	NonFirstChars := Set new: 100.	NonFirstChars 		addAll: (16r30 to: 16r39);		addAll: (16r0 to: 16r20);		addAll: #(16r22 16r23 16r27 16r2B 16r2C 16r2D 16r2E 16r5B 16r5C 16r5D 16r7B 16r7D 16r7F).	NonRestChars := Set new: 100.	NonRestChars		addAll: (16r0 to: 16r20);		addAll: #(16r22 16r23 16r27 16r2C 16r2E 16r5B 16r5C 16r5D 16r7B 16r7D 16r7F).	SeparatorChars := Set new: 10.	SeparatorChars addAll: #(16r0D 16r0A 16r20 16r09 16r2C 16r23).! !!VRMLStream class methodsFor: 'instance creation' stamp: 'ar 3/11/98 22:20'!on: refStream	^self new on: refStream! !!VRMLUndefinedNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:27'!nodeSpec	^VRMLNodeSpec undefinedSpec! !!VRMLProtoClassNode methodsFor: 'initialize' stamp: 'ar 3/13/98 01:21'!fromSpec: aSpec	protoSpec := aSpec! !!VRMLProtoClassNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:31'!nodeSpec	^protoSpec! !!VRMLProtoClassNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:36'!protoValues	^protoValues! !!VRMLProtoClassNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:31'!protoValues: anObject	protoValues _ anObject! !!VRMLProtoClassNode methodsFor: 'printing' stamp: 'ar 3/13/98 01:43'!printOn: aStream indent: aLevel	aStream 		nextPutAll:'PROTO ';		nextPutAll: self nodeSpec name;		nextPutAll:' [';		crtab: aLevel+1.	self nodeSpec attributes do:[:attr|		attr printOn: aStream indent: aLevel+1.	].	aStream nextPutAll:'] {'.	aStream crtab: aLevel.	self protoValues do:[:value|		value printOn: aStream indent: aLevel+1.		aStream crtab: aLevel.	].	aStream nextPut:$}.! !!VRMLProtoClassNode methodsFor: 'copying' stamp: 'ar 3/13/98 14:26'!vrmlProtoCopy	^self shallowCopy protoValues: (self protoValues collect:[:each| each vrmlProtoCopy])! !!VRMLExternProtoClassNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:53'!urlList	^urlList! !!VRMLExternProtoClassNode methodsFor: 'accessing' stamp: 'ar 3/13/98 01:53'!urlList: anObject	urlList _ anObject! !!VRMLExternProtoClassNode methodsFor: 'printing' stamp: 'ar 3/13/98 01:54'!printOn: aVRMLStream indent: aLevel	| first |	aVRMLStream 		nextPutAll:'EXTERNPROTO ';		nextPutAll: self nodeSpec name;		nextPutAll:' [';		crtab: aLevel+1.	self nodeSpec attributes do:[:attr|		attr printExternOn: aVRMLStream indent: aLevel+1.	].	aVRMLStream nextPutAll:']'.	aVRMLStream crtab: aLevel;		nextPut:$[; space.	first := true.	self urlList do:[:string|		first ifFalse:[aVRMLStream crtab: aLevel].		aVRMLStream writeString: string.		first := false].	aVRMLStream nextPut:$].	aVRMLStream cr.! !!VRMLUseNode methodsFor: 'printing' stamp: 'ar 3/12/98 22:43'!printOn: aVRMLStream indent: aLevel	aVRMLStream 		nextPutAll: 'USE ';		nextPutAll: name;		space.! !!VRMLWonderlandBuilder commentStamp: '<historical>' prior: 0!This class builds a Wonderland representation from a given scene.!!VRMLWonderlandBuilder methodsFor: 'initialize' stamp: 'ar 9/14/1999 23:33'!initializeFor: aWonderland	myWonderland _ aWonderland.	defaultCamera _ aWonderland getDefaultCamera.! !!VRMLWonderlandBuilder methodsFor: 'initialize' stamp: 'ar 8/18/1999 19:46'!on: aVRMLScene	scene _ aVRMLScene! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 23:57'!baseActor	^baseActor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 23:57'!baseActor: aWonderlandActor	baseActor _ aWonderlandActor.	self currentActor: baseActor.! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/15/1999 16:29'!buildActors	"Using the given VRML scene build a set of actors for Wonderland"	attributes _ Dictionary new.	Utilities informUserDuring:[:bar| 		progress _ bar.		scene doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:39'!buildActorsFor: aWonderland	"Using the given VRML scene build a set of actors for Wonderland"	self initializeFor: aWonderland.	self buildActors.! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 8/26/1999 12:28'!createActorFor: aMesh	^self createActorFor: aMesh suffix:''! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/15/1999 18:54'!createActorFor: aMesh name: aString suffix: suffix	| actor |	actor _ myWonderland createSimpleActor: aMesh 					named: aString, suffix					parent: currentActor.	"actor setMaterial: (attributes at: #currentMaterial ifAbsent:[nil])."	^actor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/9/1999 12:29'!createActorFor: aMesh suffix: aString	^self createActorFor: aMesh			name: (attributes at: #currentName ifAbsent:['unnamed'])			suffix: aString! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:43'!currentActor	^currentActor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:43'!currentActor: aWonderlandActor	currentActor _ aWonderlandActor! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/19/1999 13:20'!doAppearance: node	| attr |	attr _ node attributeNamed: 'material'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'texture'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'textureTransform'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 20:26'!doCoordinate: node	| attr points |	attr _ node attributeNamed: 'point'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec3fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentPoints]		ifFalse:[attributes at: #currentPoints put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:23'!doDirectionalLight: node	| ambientIntensity intensity color on material light dir |	ambientIntensity _ (node attributeNamed:'ambientIntensity') value.	intensity _ (node attributeNamed: 'intensity') value.	color _ (node attributeNamed: 'color') value.	dir _ self positionFrom: (node attributeNamed:'direction') value.	on _ (node attributeNamed:'on') value.	material _ B3DMaterialColor new.	material ambientPart: (color * ambientIntensity).	material diffusePart: (color * intensity).	light _ myWonderland makeLight: (Wonderland wonderlandConstants at: 'directional').	light lightColor: material.	light setDirection: dir.	currentActor ifNotNil:[light reparentTo: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:22'!doImageTexture: node	| attr texFileName tex |	"Create a new texture."	attributes at: #currentTexture put: nil.	attr _ node attributeNamed: 'url'.	(attr notNil and:[attr value notNil]) 		ifTrue:[			texFileName _ (FileDirectory on: (FileDirectory dirPathFor: scene fileURL)) fullNameFor: attr value first.			(FileDirectory default fileExists: texFileName)				ifTrue:[tex _ myWonderland makeTextureFrom: texFileName].			attributes at: #currentTexture put: tex].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 18:53'!doIndexedFaceSet: node	| attr faces points mesh |	attributes at: #currentPoints put: nil.	attr _ node attributeNamed: 'coord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	points _ attributes at: #currentPoints.	points ifNil:[^self].	attr _ node attributeNamed: 'coordIndex'.	(attr notNil and:[attr value notNil]) 		ifTrue:[faces _ self facesFrom: attr value for: points].	faces ifNil:[^self].	mesh _ B3DSimpleMesh withAll: faces.	self assignIndexedNormals: node in: mesh.	self assignIndexedTexCoords: node in: mesh.	self assignIndexedColors: node in: mesh.	mesh _ mesh asIndexedTriangleMesh.	"Try to recycle the actors"	(currentActor == nil or:[currentActor hasMesh])		ifTrue:[self createActorFor: mesh]		ifFalse:[currentActor setMesh: mesh].	currentActor setMaterial: (attributes at: #currentMaterial ifAbsent:[nil]).	currentActor setTexturePointer: (attributes at: #currentTexture ifAbsent:[nil]).! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/19/1999 15:50'!doMaterial: node	| ambientIntensity diffuseColor emissiveColor shininess specularColor material |	ambientIntensity _ (node attributeNamed: 'ambientIntensity') value.	diffuseColor _ (node attributeNamed: 'diffuseColor') value.	emissiveColor _ (node attributeNamed:'emissiveColor') value.	shininess _ (node attributeNamed: 'shininess') value.	specularColor _ (node attributeNamed: 'specularColor') value.	"transparency _ (node attributeNamed:'transparency') value."	material _ B3DMaterial new.	material ambientPart: (diffuseColor * ambientIntensity).	material diffusePart: diffuseColor.	material specularPart: specularColor.	material emission: emissiveColor.	material shininess: shininess.	attributes at: #currentMaterial put: material.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 21:07'!doNormal: node	| attr points |	attr _ node attributeNamed: 'vector'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec3fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentNormals]		ifFalse:[attributes at: #currentNormals put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 23:12'!doShape: node	| attr |	attributes at: #currentTexture put: nil.	attr _ node attributeNamed: 'appearance'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'geometry'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 19:15'!doTextureCoordinate: node	| attr points |	attr _ node attributeNamed: 'point'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec2fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentTexCoords]		ifFalse:[attributes at: #currentTexCoords put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:20'!doTransform: node	| attr c r s sr t xform oldActor |	attr _ node attributeNamed: 'center'.	attr notNil ifTrue:[c _ self positionFrom: attr value].	attr _ node attributeNamed: 'rotation'.	attr notNil ifTrue:[r _ self rotationFrom: attr value].	attr _ node attributeNamed: 'scale'.	attr notNil ifTrue:[s _ self scaleFrom: attr value].	attr _ node attributeNamed: 'scaleOrientation'.	attr notNil ifTrue:[sr _ self rotationFrom: attr value].	attr _ node attributeNamed: 'translation'.	attr notNil ifTrue:[t _ self positionFrom: attr value].	xform _ B3DMatrix4x4 identity.	xform translation: t+c.	xform _ xform composedWithLocal: r asMatrix4x4.	xform _ xform composedWithLocal: sr asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity scaling: s).	xform _ xform composedWithLocal: sr negated asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity translation: c negated).	oldActor _ currentActor.	currentActor _ self createActorFor: nil.	currentActor setComposite: xform.	super doTransform: node.	currentActor _ oldActor.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:21'!doViewpoint: node	| attr pos r fov name m camera |	attr _ node attributeNamed: 'position'.	attr notNil ifTrue:[pos _ self positionFrom: attr value].	attr _ node attributeNamed: 'orientation'.	attr notNil ifTrue:[r _ self rotationFrom: attr value].	attr _ node attributeNamed: 'fieldOfView'.	attr notNil ifTrue:[fov _ attr value radiansToDegrees].	attr _ node attributeNamed: 'description'.	attr notNil ifTrue:[name _ attr value].	m _ B3DMatrix4x4 identity.	m _ m composedWithGlobal: (r asMatrix4x4).	m _ m composedWithGlobal: (B3DMatrix4x4 withOffset: pos).	(currentActor == baseActor and:[defaultCamera ~~ nil]) ifTrue:[		camera _ defaultCamera.		defaultCamera _ nil.	] ifFalse:[		camera _ myWonderland makeCameraNamed: (name ifNil:['camera']) parent: currentActor.	].	camera setComposite: m.	camera setFieldOfView: fov.! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:02'!assignIndexedColors: node in: mesh	| attr colors colorIndex faces vertices |	attributes at: #currentColors put: nil.	attr _ node attributeNamed: 'color'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	colors _ attributes at: #currentColors.	colors == nil ifTrue:[^self].	attr _ node attributeNamed: 'colorIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	colorIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[colorIndex next = -1] whileTrue.		colorIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) color: (colors at: colorIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:02'!assignIndexedNormals: node in: mesh	| attr normals nrmlIndex faces vertices |	attributes at: #currentNormals put: nil.	attr _ node attributeNamed: 'normal'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	normals _ attributes at: #currentNormals.	normals == nil ifTrue:[^self].	attr _ node attributeNamed: 'normalIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	nrmlIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[nrmlIndex next = -1] whileTrue.		nrmlIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) normal: (normals at: nrmlIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:08'!assignIndexedTexCoords: node in: mesh	| attr faces vertices texCoords texIndex |	attributes at: #currentTexCoords put: nil.	attr _ node attributeNamed: 'texCoord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	texCoords _ attributes at: #currentTexCoords.	texCoords == nil ifTrue:[^self].	attr _ node attributeNamed: 'texCoordIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	texIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[texIndex next = -1] whileTrue.		texIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) texCoord: (texCoords at: texIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:04'!facesFrom: anArray for: vertices	"Create and return a set of faces from the given index array"	| faces vtx |	vtx _ WriteStream on: (Array new: 4).	faces _ WriteStream on: (Array new: anArray size // 4).	anArray do:[:idx|		idx = -1 ifTrue:[			vtx position > 2 				ifTrue:[faces nextPut: (B3DSimpleMeshFace withAll: vtx contents)].			vtx reset.		] ifFalse:[			vtx nextPut: (B3DSimpleMeshVertex new position: (vertices at: idx+1)).		].	].	^faces contents! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 8/19/1999 13:11'!indexedFacesFrom: anArray	"Create and return a set of faces from the given index array"	| faces index idx0 idx1 idx2 |	faces _ WriteStream on: (B3DIndexedTriangleArray new: anArray size // 4).	index _ 0.	[index < anArray size] whileTrue:[		idx0 _ anArray at: (index _ index + 1).		idx1 _ anArray at: (index _ index + 1).		[idx2 _ anArray at: (index _ index + 1).		faces nextPut: (B3DIndexedTriangle with: idx0+1 with: idx1+1 with: idx2+1).		idx1 _ idx2.		index < anArray size			ifTrue:[idx2 _ anArray at: (index_index+1)]			ifFalse:[idx2 _ -1].		idx2 = -1] whileFalse.	].	^faces contents! !!VRMLWonderlandBuilder methodsFor: 'enumerating' stamp: 'ar 9/15/1999 16:29'!doNamedNode: node	| lastName |	progress value:'Reading ', node name,' ...'.	lastName _ attributes at: #currentName ifAbsent:[nil].	attributes at: #currentName put: node name.	super doNamedNode: node.	lastName		ifNil:[attributes removeKey: #currentName]		ifNotNil:[attributes at: #currentName put: lastName].! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 16:16'!mfVec2fFrom: anArray	"Convert the given array into a B3DVector2Array"	| pts |	pts _ WriteStream on: (B3DTexture2Array new: anArray size).	anArray do:[:spec|		pts nextPut: (B3DVector2 u: (spec at: 1) v: (spec at: 2)).	].	^pts contents! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 17:33'!mfVec3fFrom: anArray	"Convert the given array into a B3DVector3Array"	| pts |	pts _ WriteStream on: (B3DVector3Array new: anArray size).	anArray do:[:spec|		pts nextPut: (B3DVector3 x: (spec at: 1) y: (spec at: 2) z: 0.0 - (spec at: 3)).	].	^pts contents! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 17:33'!positionFrom: attr	"Fix up coord systems"	^B3DVector3 x: (attr at: 1) y: (attr at: 2) z: 0.0 - (attr at: 3).! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 18:20'!rotationFrom: attr	"Fix up coord systems"	^B3DRotation radiansAngle: (attr at: 4) negated axis: 			(B3DVector3 x: (attr at: 1) y: (attr at: 2) z: (attr at: 3))! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 18:05'!scaleFrom: attr	"Fix up coord systems"	^B3DVector3 x: (attr at: 1) y: (attr at: 2) z: (attr at: 3).! !!VRMLWonderlandBuilder class methodsFor: 'instance creation' stamp: 'ar 8/18/1999 19:46'!on: aVRMLScene	^self new on: aVRMLScene! !!VRMLWriter commentStamp: '<historical>' prior: 0!A VRMLWriter supports writing a set of VRMLNodes (or entire scenes) in VRML format.!!VRMLWriter methodsFor: 'data writing' stamp: 'ar 3/12/98 19:56'!storeSingleFieldNode: aField on: aVRMLStream indent: level 	aField printOn: aVRMLStream indent: level.! !!VRMLWriter methodsFor: 'data writing' stamp: 'ar 3/12/98 19:19'!writeAttribute: aVRMLNodeAttribute on: aVRMLStream value: value indent: aLevel	aVRMLStream nextPutAll: aVRMLNodeAttribute name.	aVRMLStream space.	self perform: (VRMLFieldTypes at: aVRMLNodeAttribute type)			with: value			with: aVRMLStream			with: aLevel.	aVRMLStream crtab: aLevel.! !!VRMLWriter methodsFor: 'data writing' stamp: 'ar 3/12/98 19:13'!writeAttribute: aVRMLNodeAttribute value: value indent: aLevel	self nextPutAll: aVRMLNodeAttribute name.	self space.	self perform: (VRMLFieldTypes at: aVRMLNodeAttribute type)			with: aVRMLNodeAttribute			with: value			with: aLevel.	self crtab: aLevel.! !!VRMLWriter methodsFor: 'data writing' stamp: 'ar 8/17/1999 22:20'!writeScene: aScene on: aVRMLStream	aVRMLStream nextPutAll:'#VRML V2.0 utf8'; cr.	aScene nodes do:[:node| 		node printOn: aVRMLStream indent: 0.		aVRMLStream cr.].	aScene actions keysAndValuesDo:[:fromName :outDict|		outDict keysAndValuesDo:[:outEvt :toDict|			toDict keysAndValuesDo:[:toName :inSet|				inSet do:[:inEvt|		aVRMLStream 			nextPutAll:'ROUTE ';			nextPutAll: fromName;			nextPut:$.;			nextPutAll: outEvt name;			nextPutAll:' TO ';			nextPutAll: toName;			nextPut:$.;			nextPutAll: inEvt name;			cr]]]].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldColor: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldColor: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldFloat: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldFloat: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldInt32: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldInt32: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldNode: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldNode: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldRotation: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldRotation: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldString: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldString: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldTime: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldTime: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldVec2f: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldVec2f: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'multi field writing' stamp: 'ar 3/12/98 22:42'!writeMultiFieldVec3f: fields on: aVRMLStream indent: level 	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleFieldVec3f: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldBool: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeBool: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldColor: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeColor: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldFloat: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeFloat: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldImage: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeImage: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldInt32: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeInt32: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldRotation: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeRotation: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldString: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeString: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldTime: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeTime: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldVec2f: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeVec2f: aField! !!VRMLWriter methodsFor: 'single field writing' stamp: 'ar 3/12/98 22:42'!storeSingleFieldVec3f: aField on: aVRMLStream indent: level 	"This method was automatically generated"	^aVRMLStream writeVec3f: aField! !!VRMLWriter class methodsFor: 'class initialization' stamp: 'ar 3/12/98 22:42'!initFields	"VRMLWriter initialize"	| selString multi typeString selector singleString multiString |	VRMLFieldTypes := Dictionary new.	#(MFColor MFFloat MFInt32 MFNode MFRotation MFString MFTime MFVec2f MFVec3f 	SFBool SFColor SFFloat SFImage SFInt32 SFNode SFRotation SFString SFTime SFVec2f SFVec3f) do:[:sym|	multi := sym first = $M.	typeString := sym copyFrom: 3 to: sym size.	singleString := 'storeSingleField', typeString, ':on:indent:'.	multiString := 'writeMultiField', typeString, ':on:indent:'.	selString := multi ifTrue:[multiString] ifFalse:[singleString].	selector := selString asSymbol.	VRMLFieldTypes at: sym asString put: selector.	(self includesSelector: selector) ifFalse:[		multi			ifTrue:[self compileMultiFieldMethod: selString type: typeString]			ifFalse:[self compileSingleFieldMethod: selString type: typeString]].]. ! !!VRMLWriter class methodsFor: 'class initialization' stamp: 'ar 3/12/98 18:55'!initialize	"VRMLWriter initialize"	self initFields.! !!VRMLWriter class methodsFor: 'private' stamp: 'ar 3/12/98 20:09'!compileMultiFieldMethod: selString type: typeString	| source selParts |	source := String streamContents:[:s|		selParts := selString splitBy:$:.		s nextPutAll: (selParts at: 1).		s nextPutAll: ': fields '.		s nextPutAll: (selParts at: 2).		s nextPutAll: ': aVRMLStream '.		s nextPutAll: (selParts at: 3).		s nextPutAll: ': level '.		s nextPutAll:('	"This method was automatically generated"	aVRMLStream nextPut: $[.	1 to: fields size do:[:i|		i > 1 ifTrue:[aVRMLStream crtab: level+1].		self storeSingleField$TYPESTRING$: (fields at: i) on: aVRMLStream indent: level+1].	aVRMLStream nextPut:$].' copyReplaceAll:'$TYPESTRING$' with: typeString).	].	self compile: source classified:'multi field writing'! !!VRMLWriter class methodsFor: 'private' stamp: 'ar 3/12/98 19:09'!compileSingleFieldMethod: selString type: typeString	| source selParts |	source := String streamContents:[:s|		selParts := selString splitBy:$:.		s nextPutAll: (selParts at: 1).		s nextPutAll: ': aField '.		s nextPutAll: (selParts at: 2).		s nextPutAll: ': aVRMLStream '.		s nextPutAll: (selParts at: 3).		s nextPutAll: ': level '.		s crtab.		s nextPutAll:'"This method was automatically generated"'.		s crtab.		s nextPutAll:'^aVRMLStream write'.		s nextPutAll: typeString.		s nextPutAll:': aField'.	].	self compile: source classified:'single field writing'! !!VRMLWriter class methodsFor: 'accessing' stamp: 'ar 3/12/98 19:16'!default	^Default isNil		ifTrue:[Default := self new]		ifFalse:[Default].! !!VRMLWriter class methodsFor: 'accessing' stamp: 'ar 3/12/98 20:03'!writeAttribute: aVRMLNodeAttribute on: aVRMLStream value: value indent: aLevel	^self default writeAttribute: aVRMLNodeAttribute on: aVRMLStream value: value indent: aLevel! !VRMLEnumerator initialize!VRMLNodeParser initialize!VRMLNodeSpec initialize!VRMLStream initialize!VRMLWriter initialize!