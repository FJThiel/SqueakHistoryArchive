'From Squeak2.9alpha of 17 July 2000 [latest update: #3174] on 14 December 2000 at 2:16:13 pm'!"Change Set:		slowNebraskaDate:			14 December 2000Author:			Bob ArningVarious Nebraska improvements, but most specifically: added an option for the client to request a 'buffered' connection whereby each individual drawing command is not sent. Rather, the entire screen (or deltas from the last full screen sent) are transmitted. This transmission only happens after the previous has completed, thus limiting the potential backlog on slow connections."!PluggableCanvas subclass: #BufferedCanvas	instanceVariableNames: 'remote previousVersion lastTick dirtyRect mirrorOfScreen '	classVariableNames: 'BufferingEnabled '	poolDictionaries: ''	category: 'Morphic-Remote'!Object subclass: #CanvasEncoder	instanceVariableNames: 'connection lastClipRect lastTransform fontCache junk cachedObjects cachingEnabled '	classVariableNames: 'CachingEnabled SentTypesAndSizes SimpleCounters '	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaDebug commentStamp: '<historical>' prior: 0!BufferedCanvas enabled: false.BufferedCanvas enabled: true.NebraskaDebug beginStatsNebraskaDebug showStatsNebraskaDebug stopAndShowAllNebraskaDebug killStatsStringSocket showRatesSeenStringSocket clearRatesSeenNebraskaDebug showAndClearStats: #allStatsNebraskaDebug showAndClearStats: #queuedbufferSizesCanvasEncoder beginStatsCanvasEncoder showStatsCanvasEncoder killStatsNebraskaDebug showStats: #peerBytesSentNebraskaDebug showStats: #soundReductionTimeNebraskaDebug showStats: #FormEncodeTimesNebraskaDebug showStats: #SendReceiveStatsNebraskaDebug showStats: #sendDeltasNebraskaDebug showStats: #bigImageNebraskaDebug showStats: #sketchNebraskaDebug showStats: #addToOutBuf:----buffered off, painting 125kb/s, dragging 400kb/sbuffered on, painting 100kb/s, dragging 170kb/s!]style[(62 142 14 78 17 3 73 415)f1cblue;,f1cblack;,f1,f1cblack;,f1cred;,f1cblack;,f1cblue;,f1cblack;!ProjectNavigationMorph subclass: #NebraskaNavigationMorph	instanceVariableNames: 'nebraskaBorder nebraskaTerminal '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Navigators'!AlignmentMorphBob1 subclass: #NebraskaServerMorph	instanceVariableNames: 'server slowCounter previousBacklog lastFullUpdateTime previousClients fullDisplay currentStatusString '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!HandMorph subclass: #RemoteControlledHandMorph	instanceVariableNames: 'eventDecoder viewExtent nebraskaClient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!ObjectSocket subclass: #StringSocket	instanceVariableNames: 'numStringsInNextArray stringsForNextArray nextStringSize files startTime stringCounter socketWriterProcess outputQueue slowNetworkTime slowNetworkCount bytesInOutputQueue transmissionError extraUnsentBytes '	classVariableNames: 'MaxRatesSeen RecentSendHistory RunningSendCount '	poolDictionaries: ''	category: 'Network-ObjectSocket'!!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 11/7/2000 13:54'!displayIsFullyUpdated! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 13:52'!apply: aBlock	"self checkIfTimeToDisplay"! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/8/2000 15:04'!asBufferedCanvas	^self! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 15:03'!checkIfTimeToDisplay	remote backlog > 0 ifTrue: [^self].	"why bother if network full?"	dirtyRect ifNil: [^self].	self sendDeltas.	lastTick _ Time millisecondClockValue.! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 13:04'!clipRect		^0@0 extent: 99999@99999! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/8/2000 14:35'!connection: connection clipRect: newClipRect transform: transform remoteCanvas: remoteCanvas	remote _ remoteCanvas.	lastTick _ 0.! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 13:54'!displayIsFullyUpdated	self checkIfTimeToDisplay! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 15:00'!forceToScreen: rect	mirrorOfScreen ifNil: [		mirrorOfScreen _ (previousVersion ifNil: [Display]) deepCopy.	].	mirrorOfScreen copy: rect from: rect origin in: Display rule: Form over.	dirtyRect _ dirtyRect ifNil: [rect] ifNotNil: [dirtyRect merge: rect].! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/8/2000 15:06'!purgeOutputQueue! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 18:08'!sendDeltas"NebraskaDebug showStats: #sendDeltas"	| t deltas dirtyFraction |	previousVersion ifNil: [		previousVersion _ Display deepCopy.		remote 			image: previousVersion 			at: 0@0 			sourceRect: previousVersion boundingBox 			rule: Form paint.		^remote forceToScreen: previousVersion boundingBox.	].	dirtyRect ifNil: [^self].	t _ Time millisecondClockValue.	dirtyFraction _ dirtyRect area / previousVersion boundingBox area roundTo: 0.0001.	deltas _ mirrorOfScreen deltaFrom: (previousVersion copy: dirtyRect) at: dirtyRect origin.	previousVersion _ mirrorOfScreen.	mirrorOfScreen _ nil.	remote 		image: deltas at: dirtyRect origin sourceRect: deltas boundingBox rule: Form reverse;		forceToScreen: dirtyRect.	t _ Time millisecondClockValue - t.	NebraskaDebug at: #sendDeltas add: {t. dirtyFraction. deltas boundingBox}.	dirtyRect _ nil.! !!BufferedCanvas methodsFor: 'object fileIn' stamp: 'RAA 12/11/2000 11:43'!converttfrpld0: varDict tfrpldm0: smartRefStrm	"These variables are automatically stored into the new instance #('target' 'filterSelector' 'remote' 'previousVersion' 'lastTick' 'dirtyRect').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mirrorOfScreen')  If a non-nil value is needed, please assign it."! !!CanvasEncoder methodsFor: 'connection' stamp: 'RAA 11/7/2000 17:54'!connection: aStringSocket	"set this connection to talk over the given socket"	cachingEnabled _ true.	connection _ aStringSocket! !!CanvasEncoder methodsFor: 'connection' stamp: 'RAA 11/8/2000 15:06'!purgeOutputQueue	connection purgeOutputQueue.! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 11/7/2000 17:56'!cachingEnabled: aBoolean	(cachingEnabled _ aBoolean) ifFalse: [		cachedObjects _ nil.	].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 12/14/2000 11:30'!image: aFormOrNil at: aPoint sourceRect: sourceRect rule: rule cacheID: cacheID newToCache: newToCache	| t destRect d2 |	destRect _ aPoint extent: sourceRect extent.	d2 _ (lastTransform invertBoundsRect: destRect) expandBy: 1.	(d2 intersects: lastClipRect) ifFalse: [		^NebraskaDebug at: #bigImageSkipped add: {lastClipRect. d2}.	].	t _ Time millisecondsToRun: [		self sendCommand: {			String with: CanvasEncoder codeImage.			self class encodeImage: aFormOrNil.			self class encodePoint: aPoint.			self class encodeRectangle: sourceRect.			self class encodeInteger: rule.			self class encodeInteger: cacheID.			self class encodeInteger: (newToCache ifTrue: [1] ifFalse: [0]).		}.	].	(aFormOrNil notNil and: [aFormOrNil boundingBox area > 10000]) ifTrue: [		NebraskaDebug 			at: #bigImage 			add: {lastClipRect. aPoint. sourceRect extent. t. cacheID. newToCache}.	].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 11/7/2000 17:55'!testCache: anObject	| firstFree cachedObject newEntry |	cachingEnabled ifFalse: [		cachedObjects _ nil.		^nil	].	cachedObjects ifNil: [		cachedObjects _ (1 to: 100) collect: [ :x | {WeakArray new: 1. nil. nil. nil}].	].	self purgeCache.	firstFree _ nil.	cachedObjects withIndexDo: [ :each :index |		cachedObject _ each first first.		firstFree ifNil: [cachedObject ifNil: [firstFree _ index]].		cachedObject == anObject ifTrue: [			each at: 2 put: (each at: 2) + 1.			^{index. false. each}		].	].	firstFree ifNil: [^nil].	newEntry _ {		WeakArray with: anObject.		1.		Time millisecondClockValue.		nil.	}.	cachedObjects at: firstFree put: newEntry.	^{firstFree. true. newEntry}! !!CanvasEncoder methodsFor: 'initialization' stamp: 'RAA 11/7/2000 17:55'!initialize	cachingEnabled _ true.	fontCache := FontCache new: 5.! !!CanvasEncoder methodsFor: 'object fileIn' stamp: 'RAA 12/11/2000 11:43'!convertcllfjc0: varDict cllfjcc0: smartRefStrm	"These variables are automatically stored into the new instance #('connection' 'lastClipRect' 'lastTransform' 'fontCache' 'junk' 'cachedObjects').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('cachingEnabled')  If a non-nil value is needed, please assign it."	cachingEnabled _ true.! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 12/14/2000 11:30'!encodeImage: form		| t answer |	form ifNil: [^''].	t _ Time millisecondsToRun: [answer _ form encodeForRemoteCanvas].	form boundingBox area > 5000 ifTrue: [		NebraskaDebug at: #FormEncodeTimes add: {t. form extent. answer size}	].	^answer	"HandMorph>>restoreSavedPatchOn: is one culprit here"! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/14/2000 10:48'!myWorldChanged	| trans |	trans _ self myTransformation.	self changed.	self layoutChanged.	trans ifNotNil:[		trans extentFromParent: self innerBounds extent.		bounds _ bounds topLeft extent: trans extent + (borderWidth * 2).	].	self changed.! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'RAA 11/8/2000 15:15'!apply: aStringArray to: aHand	"decode aStringArray, and apply the encoded command to aHand"	aStringArray first = 'event' ifTrue: [		^self applyEventMessage: aStringArray to: aHand	].	aStringArray first = 'viewExtent' ifTrue: [		^self applyViewExtentMessage: aStringArray to: aHand	].	aStringArray first = 'beginBuffering' ifTrue: [		^aHand convertRemoteClientToBuffered	].	^self error: 'unknown message type: ', aStringArray first! !!MorphicEventEncoder methodsFor: 'network I/O' stamp: 'RAA 12/13/2000 08:19'!requestBufferedConnection	"request the opposite side to send complete screen updates rather than discrete drawing commands"		connection nextPut: { 'beginBuffering' }! !!MultiCanvas methodsFor: 'accessing' stamp: 'RAA 11/7/2000 17:46'!clipRect		^super clipRect ifNil: [		0@0 extent: 5000@5000	].! !!NebraskaClient methodsFor: 'initialization' stamp: 'RAA 11/8/2000 15:05'!convertToBuffered	canvas purgeOutputQueue.	canvas _ canvas asBufferedCanvas.! !!NebraskaClient methodsFor: 'initialization' stamp: 'RAA 11/8/2000 15:14'!initialize: aConnection	| remoteAddress userPicture |	connection := aConnection.	hand := RemoteControlledHandMorph on: (MorphicEventDecoder on: aConnection).	hand nebraskaClient: self.	remoteAddress _ connection remoteAddress.	remoteAddress ifNotNil: [remoteAddress _ NetNameResolver stringFromAddress: remoteAddress].	userPicture _ EToySenderMorph pictureForIPAddress: remoteAddress.	hand		userInitials: ((EToySenderMorph nameForIPAddress: remoteAddress) ifNil: ['???'])		andPicture: (userPicture ifNotNil: [userPicture scaledToSize: 16@20]).	encoder := CanvasEncoder on: aConnection.	canvas := RemoteCanvas		connection: encoder		clipRect: NebraskaServer extremelyBigRectangle		transform: MorphicTransform identity! !!NebraskaClient methodsFor: 'as yet unclassified' stamp: 'RAA 12/13/2000 08:30'!currentStatusString	(connection isNil or: [connection isConnected not]) ifTrue: [^'nada'].	^(NetNameResolver stringFromAddress: connection remoteAddress),		' - ',		(self backlog // 1024) printString,'k'! !!NebraskaNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/13/2000 08:49'!addButtons	self addARow: {		self inAColumn: {self buttonScale}.		self inAColumn: {self buttonQuit}.		self inAColumn: {self buttonBuffered}.	}.! !!NebraskaNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/13/2000 08:26'!bufferNebraska	nebraskaTerminal requestBufferedConnection! !!NebraskaNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/13/2000 08:23'!buttonBuffered	^self makeButton: 'B' balloonText: 'Request buffered Nebraska session' for: #bufferNebraska! !!NebraskaNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/13/2000 08:25'!nebraskaTerminal: aNebraskaTerminal	nebraskaTerminal _ aNebraskaTerminal! !!NebraskaServer class methodsFor: 'as yet unclassified' stamp: 'RAA 11/8/2000 14:59'!extremelyBigRectangle	^(0@0 extent: 5000@5000)! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'RAA 12/11/2000 11:42'!initialize	super initialize.	fullDisplay _ true.	color _ Color white.	lastFullUpdateTime _ 0.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'RAA 12/11/2000 12:22'!rebuild	| myServer |	self removeAllMorphs.	self updateCurrentStatusString.	self addARow: {		self inAColumn: {			SimpleButtonMorph new target: self; actionSelector: #delete; label: 'X'.		}.		self inAColumn: {			UpdatingStringMorph new				useStringFormat;				target:  self;				getSelector: #currentStatusString;				contents: self currentStatusString;				stepTime: 2000;				lock.		}.		self inAColumn: {			SimpleButtonMorph new target: self; actionSelector: #toggleFull; label: 'O'.		}.	}.	myServer _ self server.	(myServer isNil or: [fullDisplay not]) ifTrue: [		^World startSteppingSubmorphsOf: self	].	self addARow: {		self inAColumn: {			(StringMorph contents: '--clients--') lock.		}.	}.	myServer clients do: [ :each |		self addARow: {			UpdatingStringMorph new				useStringFormat;				target: each;				getSelector: #currentStatusString;				contents: each currentStatusString;				stepTime: 2000;				lock.		}	].	World startSteppingSubmorphsOf: self.! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'RAA 11/8/2000 16:13'!toggleFull	fullDisplay _ fullDisplay not.	self rebuild.! !!NebraskaServerMorph methodsFor: 'stepping and presenter' stamp: 'RAA 11/8/2000 15:57'!stepTime	^10! !!NebraskaServerMorph methodsFor: 'stepping and presenter' stamp: 'RAA 11/8/2000 16:03'!update: aSymbol	self rebuild.! !!NebraskaServerMorph methodsFor: 'structure' stamp: 'RAA 12/11/2000 12:19'!step	| now |	self server ifNil: [ ^self ].	self server step.	now _ Time millisecondClockValue.	(now - lastFullUpdateTime) abs > 5000 ifTrue: [		lastFullUpdateTime _ now.		(previousBacklog = self server backlog and: [self server clients = previousClients]) ifFalse: [			previousClients _ self server clients copy.			self rebuild		]	].! !!NebraskaServerMorph methodsFor: 'drawing' stamp: 'RAA 12/13/2000 08:31'!updateCurrentStatusString	self server ifNil:[		currentStatusString _ '<server not active>'	] ifNotNil:[		currentStatusString _ 			'server with ', 			self server numClients printString, 			' clients  ',			((previousBacklog _ self server backlog) // 1024) printString,'k'	].! !!NebraskaServerMorph methodsFor: 'accessing' stamp: 'RAA 11/8/2000 16:07'!currentStatusString	^currentStatusString! !!NebraskaServerMorph methodsFor: 'object fileIn' stamp: 'RAA 12/11/2000 11:43'!convertbosfcessp0: varDict bosfcebbssplcfp0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'server' 'slowCounter' 'previousBacklog').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('borderWidth' 'borderColor' 'lastFullUpdateTime' 'currentStatusString' 'fullDisplay' 'previousClients')  If a non-nil value is needed, please assign it."! !!NetworkTerminalBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/14/2000 14:12'!initialize	super initialize.	self setBalloonText: nil.		"'I am a view on another Squeak'."	self layoutInset: 0.! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 12/13/2000 08:25'!openScaled	| window tm |	window _ NetworkTerminalBorderMorph new		minWidth: 100;		minHeight: 100;		borderWidth: 8;		borderColor: Color orange;		bounds: (0@0 extent: Display extent * 3 // 4).	tm _ BOBTransformationMorph new.	tm useRegularWarpBlt: true.		"try to reduce memory used"	window addMorphBack: tm.	tm addMorph: self.	window openInWorld.	NebraskaNavigationMorph new 		nebraskaBorder: window;		nebraskaTerminal: self;		openInWorld.! !!NetworkTerminalMorph methodsFor: 'shutting down' stamp: 'RAA 12/13/2000 08:21'!requestBufferedConnection	eventEncoder ifNotNil: [eventEncoder requestBufferedConnection].! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'RAA 11/8/2000 15:04'!convertRemoteClientToBuffered: aClient	worldState removeRemoteCanvas: aClient canvas.	aClient convertToBuffered.	worldState addRemoteCanvas: aClient canvas.	self changed.  "force a redraw"! !!RemoteCanvas methodsFor: 'initialization' stamp: 'RAA 11/8/2000 15:00'!asBufferedCanvas	| bufferedCanvas |	bufferedCanvas _ BufferedCanvas new.	connection cachingEnabled: false.	bufferedCanvas		connection: connection		clipRect: NebraskaServer extremelyBigRectangle		transform: MorphicTransform identity		remoteCanvas: self.	^bufferedCanvas! !!RemoteCanvas methodsFor: 'initialization' stamp: 'RAA 11/8/2000 15:06'!purgeOutputQueue	connection purgeOutputQueue.! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'RAA 12/14/2000 13:47'!clipBy: aRectangle during: aBlock	| newCanvas newR |	"Set a clipping rectangle active only during the execution of aBlock."	newR _ transform localBoundsToGlobal: aRectangle.	newCanvas _ RemoteCanvas 		connection: connection 		clipRect: (outerClipRect intersect: newR) 		transform: transform.	aBlock value: newCanvas! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'RAA 12/11/2000 12:30'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	(aDisplayTransform isPureTranslation) ifTrue: [		^self 			transformBy: aDisplayTransform 			clippingTo: aClipRect 			during: aBlock 			smoothing: cellSize	].	^super 		transform2By: aDisplayTransform 		clippingTo: aClipRect 		during: aBlock 		smoothing: cellSize! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'RAA 11/8/2000 15:15'!convertRemoteClientToBuffered	self world convertRemoteClientToBuffered: nebraskaClient! !!RemoteControlledHandMorph methodsFor: 'initialization' stamp: 'RAA 11/8/2000 15:13'!nebraskaClient: aNebraskaClient	nebraskaClient _ aNebraskaClient! !!RemoteControlledHandMorph methodsFor: 'object fileIn' stamp: 'RAA 12/11/2000 11:43'!convertbosfcemkemkmmltdcctthsulev0: varDict bosfcemkemkmmltdcctthsulevn0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'mouseFocus' 'keyboardFocus' 'eventListeners' 'mouseListeners' 'keyboardListeners' 'mouseClickState' 'mouseOverHandler' 'lastMouseEvent' 'targetOffset' 'damageRecorder' 'cacheCanvas' 'cachedCanvasHasHoles' 'temporaryCursor' 'temporaryCursorOffset' 'hasChanged' 'savedPatch' 'userInitials' 'lastEventBuffer' 'eventDecoder' 'viewExtent').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('nebraskaClient')  If a non-nil value is needed, please assign it."! !!SharedQueue methodsFor: 'accessing' stamp: 'RAA 12/14/2000 10:25'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	| value |	accessProtect critical: [		readPosition >= writePosition ifTrue: [			value _ nil		] ifFalse: [			value _ contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition _ readPosition + 1		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/13/2000 08:29'!backlog	^bytesInOutputQueue + extraUnsentBytes! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/14/2000 09:54'!isConnected	^super isConnected and: [socketWriterProcess notNil]! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/14/2000 09:52'!nextPut: anObject	socketWriterProcess ifNil: [^self].	outObjects addLast: anObject! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/14/2000 09:46'!processIO	"do some as much network IO as possible"	socketWriterProcess ifNil: [^self].	self processOutput.	self processInput.! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/12/2000 19:42'!purgeOutputQueue	bytesInOutputQueue _ 0.	[outputQueue nextOrNil notNil] whileTrue.! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/12/2000 19:42'!queueOutBufContents	bytesInOutputQueue _ bytesInOutputQueue + outBufIndex - 1.	outputQueue nextPut: {outBuf. outBufIndex - 1}.	NebraskaDebug at: #queuedbufferSizes add: {outBufIndex - 1}.	outBufIndex _ 1.	outBuf _ String new: 11000.	! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/13/2000 08:29'!sendDataCautiously: aStringOrByteArray bytesToSend: bytesToSend	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent count |	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		extraUnsentBytes _ bytesToSend - bytesSent.		count _ socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 6000).		bytesSent _ bytesSent + count.		(Delay forMilliseconds: 1) wait.	].	extraUnsentBytes _ 0.	^ bytesSent! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 12/14/2000 09:42'!transmitQueueNext	| bufTuple |	bufTuple _ outputQueue next.	bytesInOutputQueue _ bytesInOutputQueue - bufTuple second max: 0.	[		self 			sendDataCautiously: bufTuple first 			bytesToSend: bufTuple second.	]		on: Error		do: [ :ex |			transmissionError _ true.		].	^transmissionError not! !!StringSocket methodsFor: 'as yet unclassified' stamp: 'RAA 12/12/2000 19:42'!destroy	socketWriterProcess ifNotNil: [socketWriterProcess terminate. socketWriterProcess _ nil].	outputQueue _ nil.	bytesInOutputQueue _ 0.	socket ifNotNil: [socket destroy. socket _ nil.].! !!StringSocket methodsFor: 'as yet unclassified' stamp: 'RAA 12/14/2000 09:46'!initialize: aSocket	transmissionError _ false.	super initialize: aSocket.	outputQueue _ SharedQueue new.	extraUnsentBytes _ bytesInOutputQueue _ 0.	socketWriterProcess _ [		[self transmitQueueNext] whileTrue.		socketWriterProcess _ nil.		outputQueue _ nil.		bytesInOutputQueue _ 0.	] forkAt: Processor lowIOPriority.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 11/7/2000 13:54'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	allDamage do: [:r | Display forceToScreen: r].	self remoteCanvasesDo: [ :each | 		allDamage do: [:r | each forceToScreen: r].		each displayIsFullyUpdated.	].! !ObjectSocket subclass: #StringSocket	instanceVariableNames: 'numStringsInNextArray stringsForNextArray nextStringSize files startTime stringCounter socketWriterProcess outputQueue bytesInOutputQueue extraUnsentBytes transmissionError '	classVariableNames: 'MaxRatesSeen RecentSendHistory RunningSendCount '	poolDictionaries: ''	category: 'Network-ObjectSocket'!NebraskaServerMorph removeSelector: #drawOn:!NebraskaServerMorph removeSelector: #initialExtent!NebraskaServerMorph removeSelector: #stepError:withReceiver:!AlignmentMorphBob1 subclass: #NebraskaServerMorph	instanceVariableNames: 'server slowCounter previousBacklog lastFullUpdateTime currentStatusString fullDisplay previousClients '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!NebraskaDebug class removeSelector: #fixups!CanvasEncoder class removeSelector: #beginCaching!CanvasEncoder class removeSelector: #cachingString!CanvasEncoder class removeSelector: #stopCaching!Object subclass: #CanvasEncoder	instanceVariableNames: 'connection lastClipRect lastTransform fontCache cachedObjects cachingEnabled '	classVariableNames: 'SentTypesAndSizes SimpleCounters '	poolDictionaries: ''	category: 'Morphic-Remote'!BufferedCanvas class removeSelector: #connection:clipRect:transform:!BufferedCanvas class removeSelector: #enabled!BufferedCanvas class removeSelector: #enabled:!BufferedCanvas class removeSelector: #enabledString!BufferedCanvas removeSelector: #connection:clipRect:transform:!PluggableCanvas subclass: #BufferedCanvas	instanceVariableNames: 'remote previousVersion lastTick dirtyRect mirrorOfScreen '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!