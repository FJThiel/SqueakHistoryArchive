'From Squeak3.7alpha of 11 September 2003 [latest update: #5707] on 16 February 2004 at 7:54:51 pm'!"Change Set:		Kernel-Chronology-TestsDate:			16 February 2004Author:			Brent Pinkney and Tom KoenigThese are the Chronology Tests, done by Brent Pinkney and Tom Koenig.The changeset adds some good utility methods to ClassTestCase for ensuringfull test coverage.md: this is a fileout of Chronology-b-Tests-SqueakAndSmalltalk80CompatibilityChronology-h-Tests-NewGenerationChronology-k-Tests-CleanupTom did more tests, these will follow in an additional changeset"!!ClassTestCase commentStamp: 'brp 7/26/2003 16:57' prior: 0!This class is intended for unit tests of individual classes and their metaclasses.It provides methods to determine the coverage of the unit tests.Subclasses are expected to re-implement #classesToBeTested and #selectorsToBeIgnored.They should also implement to confirm that all methods have been tested.#testCoverage	super testCoverage.!TestCase subclass: #DateAndTimeEpochTest	instanceVariableNames: 'aDateAndTime aDuration aTimeZone localTimeZoneToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!DateAndTimeEpochTest commentStamp: 'tlk 1/6/2004 18:27' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage  for the Chronology set of classes as part of the external testing. The other Chronology sunit test cases are: DateTestCase DateAndTimeLeapTestCase, DurationTestCase, ScheduleTestCase TimeStampTestCase TimespanDoTestCase,  TimespanDoSpanAYearTestCase,  TimespanTestCase,  YearMonthWeekTestCase.  These tests attempt to exercise all public and private methods.  Except, they do not explicitly depreciated methods. tlkMy fixtures are:aDateAndTime = January 01, 1901 midnight (the start of the Squeak epoch) with localTimeZone = Grenwhich Meridian (local offset = 0 hours)aDuration = 1 day, 2 hours, 3, minutes, 4 seconds and 5 nano seconds.aTimeZone =  'Epoch Test Time Zone', 'ETZ' , offset: 12 hours, 15 minutes. !TestCase subclass: #DateAndTimeLeapTest	instanceVariableNames: 'aDateAndTime aDuration aTimeZone localTimeZoneToRestore'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!DateAndTimeLeapTest commentStamp: 'tlk 1/6/2004 17:54' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. tlk.My fixtures are:aDateAndTime = February 29, 2004 1:33 PM with offset: 2 hoursaDuration = 15 days, 14 hours, 13 minutes, 12 seconds and 11 nano seconds.aTimeZone =  Grenwhich Meridian (local offset = 0 hours) !ClassTestCase subclass: #DateAndTimeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!ClassTestCase subclass: #DateTest	instanceVariableNames: 'date aDate aTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!DateTest commentStamp: 'brp 7/26/2003 16:58' prior: 0!This is the unit test for the class Date. !ClassTestCase subclass: #DurationTest	instanceVariableNames: 'aDuration'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!ClassTestCase subclass: #MonthTest	instanceVariableNames: 'month'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!MonthTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class Month.!ClassTestCase subclass: #ScheduleTest	instanceVariableNames: 'firstEvent aSchedule'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!ClassTestCase subclass: #StopwatchTest	instanceVariableNames: 'aStopwatch aDelay'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!ClassTestCase subclass: #TimeStampTest	instanceVariableNames: 'aTimeStamp timestamp '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!TimeStampTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class TimeStamp.!ClassTestCase subclass: #TimeTest	instanceVariableNames: 'time aTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!TimeTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class Time.!TestCase subclass: #TimespanDoSpanAYearTest	instanceVariableNames: 'aTimespan aDuration aDate'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!TimespanDoSpanAYearTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list. tlk.My fixtures include a Timespan that crosses over a year boundary:aDate = December 25, 2004, midnightaDuration = 91 daysaTimeSpan= 91 days, starting December 25, 2004, midnight!TestCase subclass: #TimespanDoTest	instanceVariableNames: 'aTimespan aDuration aDate'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!TimespanDoTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list.  tlk.My fixtures are:aDate = January 8, 2003, midnightaDuration = 91 daysaTimeSpan= 91 days, starting January 8, 2003, midnight!ClassTestCase subclass: #TimespanTest	instanceVariableNames: 'timespan aTimespan anOverlappingTimespan anIncludedTimespan aDisjointTimespan aDay aWeek dec31 jan01 jan08'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!ClassTestCase subclass: #WeekTest	instanceVariableNames: 'week'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!TestCase subclass: #YearMonthWeekTest	instanceVariableNames: 'restoredStartDay'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!YearMonthWeekTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndEpochTestCase for a complete list.  tlk.I have no fixtures but do make sure to restore anything I change.!ClassTestCase subclass: #YearTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:32'!categoriesForClass: aClass ^ aClass organization allMethodSelectors collect: 			[:each |  aClass organization categoryOfElement: each].! !!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:28'!targetClass  |className|  className := self class name asText copyFrom: 0 to: self class name size - 4.  ^ Smalltalk at: (className asString asSymbol).! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/26/2003 17:39'!testClassComment	self shouldnt: [self targetClass organization hasNoComment].! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/25/2003 23:07'!testNew	self shouldnt: [self targetClass new] raise: Error.! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/26/2003 17:24'!testUnCategorizedMethods	| categories slips  |	categories := self categoriesForClass: self targetClass.	slips := categories select: [:each | each = #'as yet unclassified'].	self should: [slips isEmpty].	! !!ClassTestCase methodsFor: 'Tests' stamp: 'brp 12/14/2003 15:51'!testCoverage	| untested | 	self class mustTestCoverage ifTrue:		[ untested := self selectorsNotTested.		self assert: untested isEmpty 		description: untested size asString, ' selectors are not covered' ]! !!ClassTestCase methodsFor: 'Private' stamp: 'brp 8/6/2003 19:24'!resumeFromDeprecatedMethods: autoResume	"If true, make the default action for all Deprecation warnings to resume"	| da |	autoResume		ifTrue: [Deprecation compiledMethodAt: #defaultAction ifAbsent: 					[ Deprecation 						addSelector: #defaultAction 						withMethod: (Notification >> #defaultAction) ] ]		ifFalse: [da _ Deprecation compiledMethodAt: #defaultAction ifAbsent: [].				da == (Notification >> #defaultAction) 					ifTrue: [ Deprecation removeSelectorSimply: #defaultAction] ]				! !!ClassTestCase methodsFor: 'Running' stamp: 'brp 8/6/2003 19:25'!setUp	self resumeFromDeprecatedMethods: true.! !!ClassTestCase methodsFor: 'Running' stamp: 'brp 8/6/2003 19:26'!tearDown	self resumeFromDeprecatedMethods: false.! !!ClassTestCase methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:39'!classToBeTested		self subclassResponsibility! !!ClassTestCase methodsFor: 'Coverage' stamp: 'brp 7/26/2003 16:35'!selectorsNotTested	^ self selectorsToBeTested difference: self selectorsTested.! !!ClassTestCase methodsFor: 'Coverage' stamp: 'brp 7/26/2003 17:36'!selectorsTested	| literals |	literals _ Set new.	self class		selectorsAndMethodsDo: [ :s :m | (s beginsWith: 'test')			ifTrue: [ literals addAll: (m literals select: [ :l | l isSymbol and: [l first isLowercase]]) ] ].	^ literals! !!ClassTestCase methodsFor: 'Coverage' stamp: 'brp 7/26/2003 17:22'!selectorsToBeIgnored	^ #(#DoIt #DoItIn:)! !!ClassTestCase methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:40'!selectorsToBeTested	^ ( { self classToBeTested. self classToBeTested class } gather: [:c | c selectors]) 			difference: self selectorsToBeIgnored! !!ClassTestCase class methodsFor: 'Testing' stamp: 'brp 7/27/2003 12:53'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self sunitName = #ClassTestCase			! !!ClassTestCase class methodsFor: 'Testing' stamp: 'brp 12/14/2003 15:50'!mustTestCoverage	^ false! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testAsDate	self assert: aDateAndTime asDate =   'January 1, 1901' asDate.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:31'!testAsDateAndTime	self assert: aDateAndTime asDateAndTime =  aDateAndTime	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:34'!testAsDuration	self assert: aDateAndTime asDuration =  0 asDuration	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:06'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:27'!testAsMonth	self assert: aDateAndTime asMonth = (Month month: 'January' year: 1901). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  0 asDuration asNanoSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:01'!testAsSeconds	self assert: aDateAndTime asSeconds =  0 asDuration asSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:32'!testAsTime	self assert: aDateAndTime asTime =  Time midnight.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:51'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  TimeStamp new.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:07'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:43'!testAsWeek	self assert: aDateAndTime asWeek = (Week starting: '12-31-1900' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:43'!testAsYear	self assert: aDateAndTime asYear =   (Year starting: '01-01-1901' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testCurrent	self deny: aDateAndTime =  (DateAndTime current).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:46'!testDateTime	self assert: aDateAndTime =  (DateAndTime date: '01-01-1901' asDate time: '00:00:00' asTime)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDay	self assert: aDateAndTime day =   DateAndTime new day! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:08'!testDayMonthYearDo	|iterations|	iterations := 0.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1])  = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 1901.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 15:45'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:47'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 3.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Tue'.	self assert: aDateAndTime dayOfWeekName = 'Tuesday'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 31.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInYear	self assert: aDateAndTime daysInYear  = 365.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 364.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:24'!testDuration	self assert: aDateAndTime duration  = 0 asDuration.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:25'!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:44'!testFirstDayOfMonth	self assert: aDateAndTime firstDayOfMonth =   1! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:25'!testFromSeconds	self assert: aDateAndTime =  (DateAndTime fromSeconds: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:26'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testHash	self assert: aDateAndTime hash =    DateAndTime new hash.	self assert: aDateAndTime hash =    199296261! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:59'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    0.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:57'!testHour12	self assert: aDateAndTime hour12  =    DateAndTime new hour12.	self assert: aDateAndTime hour12  =    1! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testIsLeapYear	self deny: aDateAndTime isLeapYear! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:18'!testJulianDayNumber	self assert: aDateAndTime =  (DateAndTime julianDayNumber: 2415386).	self assert: aDateAndTime julianDayNumber = 2415386.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:20'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:40'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'AM'.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:37'!testMiddleOf	self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) = 	 (Timespan starting: '12-31-1900' asDate duration: 2 days).	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:39'!testMidnight	self assert: aDateAndTime midnight =  aDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:03'!testMinus	self assert: aDateAndTime - aDateAndTime =  '0:00:00:00' asDuration.	self assert: aDateAndTime - '0:00:00:00' asDuration = aDateAndTime.	self assert: aDateAndTime - aDuration =  (DateAndTime year: 1900 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours ).	" I believe this Failure is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)" ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:35'!testMinute	self assert: aDateAndTime minute =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:41'!testMinutes	self assert: aDateAndTime minutes = 0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:46'!testMonth	self assert: aDateAndTime month  = 1.	self assert: aDateAndTime monthAbbreviation = 'Jan'.	self assert: aDateAndTime monthName = 'January'.	self assert: aDateAndTime monthIndex = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:47'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:27'!testNew	self assert: aDateAndTime =  (DateAndTime new).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:49'!testNoon	self assert: aDateAndTime noon =  '1901-01-01T12:00:00+00:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testNow	self deny: aDateAndTime =  (DateAndTime now).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:41'!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 11:03'!testPlus	self assert: aDateAndTime + '0:00:00:00' = aDateAndTime.	self assert: aDateAndTime + 0 = aDateAndTime.	self assert: aDateAndTime + aDuration = (DateAndTime year: 1901 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours )	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:37'!testPrintOn  	|cs rw |	cs _ ReadStream on: ' 1901-01-01T00:00:00+00:00'.	rw _ ReadWriteStream on: ''.     aDateAndTime printOn: rw.     self assert: rw contents = cs contents.	cs  _ ReadStream on: 'a TimeZone(ETZ)'.	rw _ ReadWriteStream on: ''.     aTimeZone printOn:  rw.     self assert: rw contents = cs contents! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:25'!testTicks	self assert: aDateAndTime ticks =  (DateAndTime julianDayNumber: 2415386) ticks.	self assert: aDateAndTime ticks = #(2415386 0 0)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:31'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2415386 0 0) offset: DateAndTime localOffset).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:42'!testTo	self assert: (aDateAndTime to: aDateAndTime) = (DateAndTime new to: DateAndTime new) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:43'!testToBy	self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) = 				(DateAndTime new to: DateAndTime new + 10 days by: 5 days ) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:53'!testToByDo	"self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days do: []) =  "	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:35'!testToday	self deny: aDateAndTime =  (DateAndTime today).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:45'!testTommorrow	self assert: (DateAndTime today + 24 hours) =  (DateAndTime tomorrow).	self deny: aDateAndTime =  (DateAndTime tomorrow).     "MessageNotUnderstood: Date class>>starting:"! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:58'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 21:00'!testYear	self assert: aDateAndTime year = 1901.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:30'!testYearDay	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDay	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:23'!testYearMonthDayHourMinuteSecondNanosSecondOffset	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset:0 hours ).	self assert: ((DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours ) +				(Duration days: 1 hours: 2 minutes: 3 seconds: 4  nanoSeconds: 5) ) =  					(DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours ) 	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"   ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:47'!testYesterday	self deny: aDateAndTime =  (DateAndTime yesterday).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:12'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Grenwich Mean Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'GMT'! !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'tlk 1/2/2004 10:58'!setUp     localTimeZoneToRestore := DateAndTime localTimeZone.	aDateAndTime :=  DateAndTime localTimeZone: TimeZone default; epoch.	aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Epoch Test Time Zone' abbreviation: 'ETZ'.	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'tlk 1/2/2004 11:04'!tearDown     DateAndTime localTimeZone: localTimeZoneToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:00'!testAsDate	self assert: aDateAndTime asDate =   'February 29, 2004' asDate.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:55'!testAsDuration	self assert: aDateAndTime asDuration =  aDuration	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:00'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:24'!testAsMonth	self assert: aDateAndTime asMonth = (Month month: 'February' year: 2004).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  aDuration asNanoSeconds.	self assert: aDateAndTime asNanoSeconds = 48780000000000	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:05'!testAsSeconds	self assert: aDuration asSeconds =  48780.	self assert: aDateAndTime asSeconds =  3255507180	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:26'!testAsTime	self assert: aDateAndTime asTime = (Time hour: 13 minute: 33 second: 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:31'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  ((TimeStamp readFrom: '2-29-2004 1:33 pm' readStream) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:30'!testAsWeek	self assert: aDateAndTime asWeek =    (Week starting: '02-29-2004' asDate).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:36'!testAsYear	self assert: aDateAndTime asYear =   (Year starting: '02-29-2004' asDate).  	self deny: aDateAndTime asYear =   (Year starting: '01-01-2004' asDate)  ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:23'!testDay	self assert: aDateAndTime day =   60. 	self deny: aDateAndTime day =   29 ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:16'!testDayMonthYearDo	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 2004.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 2.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:17'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:34'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 1.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Sun'.	self assert: aDateAndTime dayOfWeekName = 'Sunday'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 60.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInYear	self assert: aDateAndTime daysInYear  = 366.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 306.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:38'!testFirstDayOfMonth	self deny: aDateAndTime firstDayOfMonth =  1.	self assert: aDateAndTime firstDayOfMonth = 32! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:43'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00').! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testHash	self assert: aDateAndTime hash =     29855404! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:48'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    13.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:57'!testHour12	self assert: aDateAndTime hour12  =    2.	self deny: aDateAndTime hour12  =    1! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:35'!testIsLeapYear	self assert: aDateAndTime isLeapYear! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:42'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'PM'.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:12'!testMiddleOf	self assert: (aDateAndTime middleOf: aDuration)  = 	 (Timespan starting: (DateAndTime year: 2004 month: 2 day: 29 hour: 6 minute: 46 second: 30 offset: 2 hours)	duration: (Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0 ))	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:57'!testMidnight	self assert: aDateAndTime midnight =  '2004-02-29T00:00:00+00:00'.	self deny: aDateAndTime midnight =  '2004-02-29T00:00:00+02:00'! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:00'!testMinute	self assert: aDateAndTime minute =  33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:44'!testMinutes	self assert: aDateAndTime minutes = 33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:02'!testMonth	self assert: aDateAndTime month  = 2.	self assert: aDateAndTime monthAbbreviation = 'Feb'.	self assert: aDateAndTime monthName = 'February'.	self assert: aDateAndTime monthIndex = 2.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:03'!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:07'!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:42'!testPrintOn    	|cs rw |	cs _ ReadStream on: ' 2004-02-29T13:33:00+02:00'.	rw _ ReadWriteStream on: ''.     aDateAndTime printOn: rw.     self assert: rw contents = cs contents.	cs  _ ReadStream on: 'a TimeZone(GMT)'.	rw _ ReadWriteStream on: ''.     aTimeZone printOn:  rw.     self assert: rw contents = cs contents	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:12'!testTicks	self assert: aDateAndTime ticks =  ((DateAndTime julianDayNumber: 2453065) + 48780 seconds) ticks.	self assert: aDateAndTime ticks =  #(2453065 48780 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:52'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2453065 48780 0) offset: DateAndTime localOffset).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:51'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:17'!testYear	self assert: aDateAndTime year = 2004.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:21'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 day: 60 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:23'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Grenwich Mean Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'GMT'! !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'tlk 1/2/2004 21:54'!setUp     localTimeZoneToRestore := DateAndTime localTimeZone.     "so how do I set local time zone?"	aDateAndTime := (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours).	aTimeZone := TimeZone default.	aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0 ! !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'tlk 1/2/2004 21:30'!tearDown     DateAndTime localTimeZone: localTimeZoneToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 17:00'!testArithmeticAcrossDateBoundary	| t1 t2 |	t1 _ '2004-01-07T11:55:00+00:00' asDateAndTime. 	t2 _ t1 - ( (42900+1) seconds).  	self 		assert: t2 = ('2004-01-06T23:59:59+00:00' asDateAndTime)		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:37'!testInstanceCreation	| t |	t _ DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t julianDayNumber = 1721427);		assert: (t offset = 6 hours);		assert: (t hour = 2);		assert: (t minute = 3);		assert: (t second = 4);		assert: (t nanoSecond = 5).		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 09:47'!testMonotonicity	| t1 t2 t3 t4 |	t1 _ DateAndTime now.	t2 _ DateAndTime now.	t3 _ DateAndTime now.	t4 _ DateAndTime now.	self 		assert: (	t1 < t2);		assert: (	t2 < t3);		assert: (	t3 < t4).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:43'!testSmalltalk80Accessors	| t |	t _ DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t hours = t hours);		assert: (t minutes = t minute);		assert: (t seconds = t second).! !!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!classToBeTested	^ DateAndTime! !!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DateTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:07'!testAccessing	self			assert: date day = 153;		assert: date julianDayNumber = 2441836;		assert: date leap = 0;		assert: date monthIndex = 6;		assert: date monthName = #June;		assert: date weekday = #Saturday;		assert: date weekdayIndex = 7;		assert: date year = 1973.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:10'!testArithmetic	| d |	d := date addDays: 32.		"4 July 1973"	self 		assert: d year = 1973;		assert: d monthIndex = 7;		assert: d dayOfMonth = 4.	self 		assert: (d subtractDate: date) = 32;		assert: (date subtractDate: d) = -32.	self	 		assert: (d subtractDays: 32) = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:54'!testComparing	| d1 d2 d3 |	d1 := self dateClass newDay: 2 month: #June year: 1973.	d2 := self dateClass newDay: 97 year: 2003. 		"7 April 2003"	d3 := self dateClass newDay: 250 year: 1865. 		"7 September 1865"	self		assert: date = d1;		assert: date = date copy;		assert: date hash = d1 hash.	self 		assert: date < d2;		deny: date < d3.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:15'!testConverting	self 		assert: date asDate = date;		assert: '2 June 1973' asDate = date;		assert: date asSeconds = 2285280000.	date dayMonthYearDo: [ :d :m :y | self assert: d = 2; assert: m = 6; assert: y = 1973 ].! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:47'!testFromDays	| epoch d0 d1 d2 |	epoch := self dateClass newDay: 1 year: 1901.	d0 := self dateClass fromDays: 0. 			"1 January 1901"	self assert: d0 = epoch.	d1 := self dateClass fromDays:  26450. 	"2 June 1973"	self assert: d1 = date.	d2 := self dateClass fromDays: -100000.	"18 March 1627"	self assert: d2 julianDayNumber = 2315386.	self assert: aDate  =  (Date fromDays:  37642).	self assert: aDate  =  (Date fromDays: 103*365 + 22 + 25 "leap days") .	! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testFromSeconds	| d |	d := self dateClass fromSeconds: 2285280000. 	self		assert: d = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:37'!testGeneralInquiries	| shuffled indices names now | 	shuffled := #(#January #February #March #April #May #June #July 					#August #September #October #November #December) shuffled.	indices := shuffled collect: [ :m | self dateClass indexOfMonth: m ].	names := indices collect: [ :i | self dateClass nameOfMonth: i ].	self assert: names = shuffled.	shuffled := #(#Monday #Tuesday #Wednesday #Thursday #Friday #Saturday #Sunday) shuffled.	indices := shuffled collect: [ :m | self dateClass dayOfWeek: m ].	names := indices collect: [ :i | self dateClass nameOfDay: i ].	self assert: names = shuffled.		now  := self dateClass dateAndTimeNow.	self 		assert: now size = 2;		assert: now first = self dateClass today.	self assert: (self dateClass firstWeekdayOfMonth: #June year: 1973) = 6.	self		assert: (self dateClass leapYear: 1973) = 0;		assert: (self dateClass leapYear: 1972) = 1;		assert: (self dateClass daysInYear: 1973) = 365;		assert: (self dateClass daysInYear: 1972) = 366;		assert: (self dateClass daysInMonth: #February forYear: 1973) = 28;		assert: (self dateClass daysInMonth: #February forYear: 1972) = 29.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testInitialization	self should: [ self dateClass initialize. true ].! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:18'!testInquiries	self			assert: date dayOfMonth = 2;		assert: date dayOfYear = 153;		assert: date daysInMonth = 30;		assert: date daysInYear = 365;		assert: date daysLeftInYear = (365 - 153);		assert: date firstDayOfMonth = 152.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testNew	| epoch |	epoch := self dateClass newDay: 1 year: 1901.	self assert: (self dateClass new = epoch).! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:33'!testPreviousNext	| n p pt ps |	n := date next.	p := date previous.	self		assert: n year = 1973;		assert: n dayOfYear = 154;		assert: p year = 1973;		assert: p dayOfYear = 152.	pt := date previous: #Thursday.		"31 May 1973"	self			assert: pt year = 1973;		assert: pt dayOfYear = 151.	ps := date previous: #Saturday.		" 26 May 1973"	self			assert: ps year = 1973;		assert: ps dayOfYear = (153-7).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:21'!testPrinting	self			assert: date mmddyyyy = '6/2/1973';		assert: date yyyymmdd = '1973-06-02';		assert: (date printFormat: #(3 1 2 $!! 2 1 1)) = '1973!!2!!Jun'.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:23'!testReadFrom	| s1 s2 s3 s4 s5 | 	s1 := '2 June 1973'.	s2 := '2-JUN-73'.	s3 := 'June 2, 1973'.	s4 := '6/2/73'.	s5 := '2JUN73'.	self			assert: date = (self dateClass readFrom: s1 readStream);		assert: date = (self dateClass readFrom: s2 readStream);		assert: date = (self dateClass readFrom: s3 readStream);		assert: date = (self dateClass readFrom: s4 readStream);		assert: date = (self dateClass readFrom: s5 readStream).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testStoring	self			assert: date storeString = '''2 June 1973'' asDate';		assert: date = ('2 June 1973' asDate).! !!DateTest methodsFor: 'Private' stamp: 'brp 8/24/2003 00:10'!dateClass	^ Date! !!DateTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:01'!classToBeTested	^ self dateClass! !!DateTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 14:05'!selectorsToBeIgnored	 | deprecated private special |	deprecated := #(		#fromJulianDayNumber:		#uniqueDateStringBetween:and:		#daylightSavingsInEffectAtStandardHour:		#daylightSavingsInEffect		#asGregorian		#asJulianDayNumber		#day:year:		#firstDayOfMonthIndex:		#mmddyy		#absoluteDaysToYear:		#yearAndDaysFromDays:into:		#week		#month ).	private := #( #julianDayNumber: ).	special := #( #< #= #new #next #previous #printOn: #printOn:format: #storeOn: #fromString: ).	^ super selectorsToBeIgnored, deprecated, private, special! !!DateTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:46'!setUp	date := self dateClass newDay: 153 year: 1973.	"2 June 1973"	aDate := Date readFrom: '01-23-2004' readStream.	aTime := Time readFrom: '12:34:56 pm' readStream! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAddDays	self assert: (aDate addDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate addDays: 30) yyyymmdd =  '2004-02-22'.	self assert: (aDate addDays: 60) yyyymmdd =  '2004-03-23'.	self assert: (aDate addDays: 90) yyyymmdd =  '2004-04-22'.	self assert: (aDate addDays:120) yyyymmdd =  '2004-05-22'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsDate	self assert: (aDate asDate) = aDate! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsSeconds	self assert: (aDate asSeconds) =   3252268800.	self assert: (aDate asSeconds) =  ((103*365*24*60*60) + (22+25"leap days"*24*60*60)) .	self assert: aDate  =  (Date fromSeconds: 3252268800).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDateAndTimeNow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch time errors"	self assert: Date dateAndTimeNow first  = Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDayMonthYearDo	self assert: (aDate dayMonthYearDo: [:day :month :year | day asString , month asString, year asString]) = '2312004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInMonthForYear	self assert: (Date daysInMonth: 'February' forYear: 2008)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2000)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2100)  = 28.		self assert: (Date daysInMonth: 'July' forYear: 2100)  = 31.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInYear	self assert: (Date daysInYear: 2008)  = 366.		self assert: (Date daysInYear: 2000)  = 366.		self assert: (Date daysInYear: 2100)  = 365	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDuration	self assert: aDate duration = 24 hours! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testEqual	self assert: aDate = (Date readFrom: (ReadStream on: 'January 23, 2004')).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testFirstWeekdayOfMonthYear	self assert: (Date firstWeekdayOfMonth: 'January' year: 2004)  = 5.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testIndexOfMonth	self assert: (Date indexOfMonth: 'January')  = 1.		self assert: (Date indexOfMonth: 'December')  = 12.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testJulianDayNumber	self assert: aDate = (Date julianDayNumber: ((4713+2004)*365 +1323) ).  ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeap	self assert: aDate leap = 1.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeapNot	self assert: (aDate addDays: 365) leap = 0! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLessThan	self assert: aDate < (Date readFrom: (ReadStream on: '01-24-2004')).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testMmddyyyy	self assert: aDate mmddyyyy =  '1/23/2004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNameOfMonth	self assert: (Date nameOfMonth: 5) = 'May'.		self assert: (Date nameOfMonth: 8) = 'August' ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayMonthYear	self assert: aDate = (Date newDay: 23 month: 1 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayYear	self assert: aDate = (Date newDay: 23 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousFriday	self assert: (aDate previous: 'Friday') yyyymmdd = '2004-01-16'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousThursday	self assert: (aDate previous: 'Thursday') yyyymmdd = '2004-01-22'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintFormat	self assert: (aDate printFormat: #(1 2 3 $? 2 2)) =  '23?Jan?04'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintOn	| cs rw |	cs := ReadStream on: '23 January 2004'.	rw := ReadWriteStream on: ''.	aDate printOn: rw.	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintOnFormat	| cs rw |	cs := ReadStream on: '04*Jan*23'.	rw := ReadWriteStream on: ''.	aDate printOn: rw format: #(3 2 1 $* 2 2).	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testStarting	self assert: aDate = (Date starting: (DateAndTime fromString: '2004-01-23T12:12')).  ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testStoreOn	| cs rw |	cs := ReadStream on: '''23 January 2004'' asDate'.	rw := ReadWriteStream on: ''.	aDate storeOn: rw.	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDate	self assert: (aDate subtractDate:(aDate addDays: 30)) = -30.		self assert: (aDate subtractDate:(aDate subtractDays: 00)) = 0.		self assert: (aDate subtractDate:(aDate subtractDays: 30)) = 30.! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDays	self assert: (aDate subtractDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate subtractDays: 30) yyyymmdd =  '2003-12-24'.	self assert: (aDate subtractDays: 60) yyyymmdd =  '2003-11-24'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testTomorrow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch many errors"	self assert: Date tomorrow  > Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testWeekday	self assert: aDate weekday = 'Friday'.		self assert: aDate weekdayIndex = 6. 	self assert: (Date dayOfWeek: aDate weekday ) =6.	self assert: (Date nameOfDay: 6 ) = 'Friday'	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYesterday	"Not a great test:  doesnt catch many errors"	self assert: Date yesterday  < Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYyyymmdd	self assert: aDate yyyymmdd =  '2004-01-23'! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:32'!testComparing	| d1 d2 d3 |	d1 _ Duration seconds: 10 nanoSeconds: 1.	d2 _ Duration seconds: 10 nanoSeconds: 1.	d3 _ Duration seconds: 10 nanoSeconds: 2.		self		assert: (d1 = d1);		assert: (d1 = d2);		deny: (d1 = d3);		assert: (d1 < d3)! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:36'!testModulo	| d1 d2 d3 |	d1 _ 11.5 seconds.	d2 _ d1 \\ 3.	self assert: d2 = (Duration nanoSeconds: 1).	d3 _ d1 \\ (3 seconds).	self assert: d3 =  (Duration seconds: 2 nanoSeconds: 500000000).	self assert: aDuration \\ aDuration = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0). 	self assert: aDuration \\ 2 = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1).	! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/16/2004 14:17'!testMonthDurations	| jan feb dec |	jan _ Duration month: #January.	feb _ Duration month: #February.	dec _ Duration month: #December.		self 		assert: jan = (Year current months first duration);		assert: feb = (Year current months second duration);		assert: dec = (Year current months last duration)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:28'!testNumberConvenienceMethods	self		assert: 1 week = (Duration days: 7);		assert: -1 week = (Duration days: -7);		assert: 1 day = (Duration days: 1);		assert: -1 day = (Duration days: -1);		assert: 1 hours = (Duration hours: 1);		assert: -1 hour = (Duration hours: -1);		assert: 1 minute = (Duration seconds: 60);		assert: -1 minute = (Duration seconds: -60);		assert: 1 second = (Duration seconds: 1);		assert: -1 second = (Duration seconds: -1);		assert: 1 milliSecond = (Duration milliSeconds: 1);		assert: -1 milliSecond = (Duration milliSeconds: -1);		assert: 1 nanoSecond = (Duration nanoSeconds: 1);		assert: -1 nanoSecond = (Duration nanoSeconds: -1)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 14:57'!testQuotient	| d1 d2 q |	d1 _ 11.5 seconds.	d2 _ d1 // 3.	self assert: d2 = (Duration seconds: 3 nanoSeconds: 833333333).	q _ d1 // (3 seconds).	self assert: q = 3.! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:38'!testRoundTo	self assert: ((5 minutes + 37 seconds) roundTo: (2 minutes)) = (6 minutes).		self assert:  (aDuration roundTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration roundTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration roundTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:37'!testTruncateTo	self assert: ((5 minutes + 37 seconds) truncateTo: (2 minutes)) = (4 minutes).	self assert:  (aDuration truncateTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration truncateTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration truncateTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!classToBeTested	^ Duration! !!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DurationTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:36'!setUp	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAbs	self assert: aDuration abs = aDuration. 	self assert: (Duration nanoSeconds: -5)  abs =  (Duration nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDelay	self deny: aDuration asDelay =   aDuration.	"want to come up with a more meaningful test"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDuration	self assert: aDuration asDuration =  aDuration	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsMilliSeconds	self assert: (Duration nanoSeconds: 1000000)  asMilliSeconds = 1.	self assert: (Duration seconds: 1)  asMilliSeconds = 1000.		self assert: (Duration nanoSeconds: 1000000)  asMilliSeconds = 1.	self assert: (Duration nanoSeconds: 1000000)  asMilliSeconds = 1.	self assert: aDuration   asMilliSeconds = 93784000.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsNanoSeconds	self assert: (Duration nanoSeconds: 1)  asNanoSeconds = 1.	self assert: (Duration seconds: 1)  asNanoSeconds = 1000000000.		self assert: aDuration   asNanoSeconds = 93784000000005.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsSeconds	self assert: (Duration nanoSeconds: 1000000000)  asSeconds = 1.	self assert: (Duration seconds: 1)  asSeconds = 1.		self assert: aDuration   asSeconds = 93784.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDays	self assert: aDuration   days = 1.	self assert: (Duration   days: 1) days= 1.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDivide	self assert: aDuration / aDuration = 1. 	self assert: aDuration / 2 = (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2). 	self assert: aDuration / (1/2) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10).! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testFromString	self assert: aDuration = (Duration fromString: '1:02:03:04.000000005').! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHash	self assert: aDuration hash =    	(Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) hash.	self assert: aDuration hash =     93789	"must be a more meaningful test?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHours	self assert: aDuration   hours = 2.	self assert: (Duration   hours: 2) hours = 2.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testIntegerDivision	self assert: aDuration // aDuration = 1. 	self assert: aDuration // 2 =  (aDuration / 2). 	"is there ever a case where this is not true, since precision is always to the nano second?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testLessThan	self assert: aDuration  < (aDuration + 1 day ).	self deny: aDuration < aDuration.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMilliSeconds	self assert: (Duration milliSeconds: 5) nanoSeconds = 5000000.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinus	self assert: aDuration - aDuration = (Duration seconds: 0).	self assert: aDuration - (Duration days: -1 hours: -2 minutes: -3 seconds: -4 nanoSeconds: -5) = 						    (Duration days: 2  hours: 4  minutes: 6  seconds: 8  nanoSeconds: 10). 	self assert: aDuration - (Duration days: 0  hours: 1  minutes: 2  seconds: 3  nanoSeconds: 4) = 						    (Duration days: 1  hours: 1  minutes: 1  seconds: 1  nanoSeconds: 1). 	self assert: aDuration - (Duration days: 0  hours: 3   minutes: 0  seconds: 5  nanoSeconds: 0) = 						    (Duration days: 0  hours: 23  minutes: 2  seconds: 59  nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinutes	self assert: aDuration   minutes = 3.	self assert: (Duration minutes: 3) minutes = 3.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMultiply	self assert: aDuration * 2 = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNanoSeconds	self assert: aDuration nanoSeconds = 5.	self assert: (Duration nanoSeconds: 5) nanoSeconds = 5.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegated	self assert: aDuration + aDuration negated = (Duration seconds: 0). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegative	self deny: aDuration negative.	self assert: aDuration negated negative! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNew	"self assert: Duration new =  (Duration seconds: 0)."    "new is not valid as a creation method: MessageNotUnderstood: UndefinedObject>>quo:, where Duration seconds is nil"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPlus	self assert: (aDuration + 0 hours) = aDuration.	self assert: (aDuration + aDuration) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPositive	self assert: (Duration nanoSeconds: 0) positive.	self assert: aDuration positive.	self deny: aDuration negated positive! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPrintOn    	|cs rw |	cs _ ReadStream on: '1:02:03:04.000000005'.	rw _ ReadWriteStream on: ''.     aDuration printOn: rw.     self assert: rw contents = cs contents.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testReadFrom	self assert: aDuration =  (Duration readFrom: (ReadStream on: '1:02:03:04.000000005'))! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testSeconds	self assert: aDuration seconds =   (800000001/200000000).	self assert: (Duration  nanoSeconds: 2) seconds = (2/1000000000).		self assert: (Duration  seconds: 2) seconds = 2.		self assert: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (4).	self deny: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (1*24*60*60+(2*60*60)+(3*60)+4).	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testSecondsNanoSeconds 	self assert: (Duration   seconds: 0 nanoSeconds: 5)  = (Duration  nanoSeconds: 5).		"not sure I should include in sunit since its Private "	self assert: (aDuration seconds: 0 nanoSeconds: 1) = (Duration nanoSeconds: 1). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testStoreOn     self assert: (aDuration storeOn: (WriteStream on:'')) asString ='1:02:03:04.000000005'.      "storeOn: returns a duration (self) not a stream"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testTicks	self assert: aDuration ticks =  #(1 7384 5)! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testWeeks	self assert: (Duration  weeks: 1) days= 7.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testZero	self assert: (Duration zero) = (Duration seconds: 0).	! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:52'!testConverting	self assert: month asDate = '1 July 1998' asDate! !!MonthTest methodsFor: 'Tests' stamp: 'brp 8/5/2003 22:43'!testDeprecated	self 		assert: month firstDate = '1 July 1998' asDate;		assert: month lastDate = '31 July 1998' asDate.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:38'!testEnumerating	| weeks |	weeks := OrderedCollection new.	month eachWeekDo: [ :w | weeks add: w firstDate ].	0 to: 4 do: [ :i | weeks remove: 		(Week fromDate: ('29 June 1998' asDate addDays: i * 7)) firstDate ].	self assert: weeks isEmpty! !!MonthTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:08'!testInquiries	self 		assert: month index = 7;		assert: month name = #July;		assert: month duration = (31 days).! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:05'!testInstanceCreation	| m1 m2 |	m1 := Month fromDate: '4 July 1998' asDate.	m2 := Month month: #July year: 1998.		self		assert: month = m1;		assert: month = m2.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:02'!testPreviousNext	| n p |	n := month next.	p := month previous.	self		assert: n year = 1998;		assert: n index = 8;		assert: p year = 1998;		assert: p index = 6.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:50'!testPrinting	self 		assert: month printString = 'July 1998'.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:46'!testReadFrom	| m |	m := Month readFrom: 'July 1998' readStream.	self 		assert: m = month! !!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Month! !!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/26/2003 23:29'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #( #next ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!setUp	super setUp.	month _ Month month: 7 year: 1998.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!tearDown	super tearDown.	month _ nil.! !!ScheduleTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 16:08'!testFromDateAndTime	| oc1 oc2 |	oc1 _ OrderedCollection new.	DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [ :dt | oc1 add: dt ].	oc2 _ { DateAndTime today. 			(DateAndTime today + 10 hours). 				(DateAndTime today + 20 hours) }.	self assert: (oc1 asArray = oc2)! !!ScheduleTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 16:03'!testMonotonicity	| t1 t2 t3 t4 |	t1 _ DateAndTime now.	t2 _ DateAndTime now.	t3 _ DateAndTime now.	t4 _ DateAndTime now.	self 		assert: (	t1 < t2);		assert: (	t2 < t3);		assert: (	t3 < t4).! !!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!classToBeTested	^ Schedule! !!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!ScheduleTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:43'!setUp 	 "Schedule is a type of Timespan representing repeated occurences of the same event. 	The beginning of the schedule is the first occurrence of the event.	A schedule maintains an array of Durations. Each durations specify the offset to the next scheduled each. 	The duration of each occurence of the event is not specified. Nor are any other attributes such as name"		"Create aSchedule with an event scheduled for 8:30pm every Saturday and Sunday for the year 2003. "	"Create the first event occurring on the first Saturday at 8:30 pm: 1/4/03"	firstEvent :=  DateAndTime year: 2003 month: 1 day: 4 hour: 20 minute: 30. 	"Create a schedule for one year starting with the first event" 	aSchedule := Schedule starting: firstEvent duration: 52 weeks.	"Schedule the recurring events by scheduling the time in between each one.  One day for Sat-Sun. 6 days for Sun-Sat" 	aSchedule schedule: { Duration days: 1. Duration days: 6 }.! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoDisjointWithSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2004				month: 4				day: 1)		and: (DateAndTime				year: 2004				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 0! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoIncludedInSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2003				month: 4				day: 1)		and: (DateAndTime				year: 2003				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoOverlappingSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2002				month: 12				day: 1)		and: (DateAndTime				year: 2003				month: 1				day: 31)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testDateAndTimes	| answer |	self assert: aSchedule dateAndTimes size  = 104.	self assert: aSchedule dateAndTimes first = firstEvent.	answer _ true.	aSchedule dateAndTimes do: [:each | (each dayOfWeekName = 'Saturday'		or: [each dayOfWeekName = 'Sunday']) ifFalse: [^false]].	self assert: answer! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testExampleFromSwikiPage	"It is often neccessary to schedule repeated events, like airline flight schedules, TV programmes, and file backups.	 Schedule is a Timespan which maintains an array of Durations.	 The durations specify the offset to the next scheduled DateAndTime. "	"Consider a TV programme scheduled for 8:30pm every Saturday and Sunday for the current year. "	"Find the first Saturday and set its time to 20h30"	| sat shows |	sat := Year current asMonth dates detect: [ :d | d dayOfWeekName = #Saturday ].	sat := sat start + (Duration hours: 20.5).	"Create a schedule" 	shows := Schedule starting: sat ending: Year current end.	shows schedule: { Duration days: 1. Duration days: 6 }.	"To inspect:"	shows dateAndTimes.	shows dateAndTimes collect: [ :dt | dt dayOfWeekName ].! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testIncludes	self assert: (aSchedule includes: (DateAndTime year: 2003 month: 6 day: 15 hour: 20 minute: 30 second: 0 offset: 0 hours))	! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testSchedule	self assert: aSchedule schedule size = 2.	self assert: aSchedule schedule first = 1 days.		self assert: aSchedule schedule second = 6 days.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:45'!testActive	| sw |	sw _ Stopwatch new.	sw activate.		1 seconds asDelay wait.	self 		assert: (sw duration >= 1 seconds).	2 seconds asDelay wait.	self 		assert: (sw duration >= 3 seconds).	sw suspend.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/24/2003 22:56'!testNew	| sw |	sw _ Stopwatch new.		self 		assert: (sw isSuspended);		assert: (sw state = #suspended);		deny: (sw isActive);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 12:02'!testReActivate	| sw |	sw _ Stopwatch new.	sw 		activate;		suspend;		reActivate.		self 		assert: (sw isActive).! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:56'!testReset	| sw |	sw _ Stopwatch new.	sw activate.		sw reset.	self 		assert: (sw isSuspended);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:11'!testStartStop	| sw t1 t2 t3 t4 |	sw _ Stopwatch new.	t1 _ DateAndTime now.		sw activate; activate.	t2 _ DateAndTime now.		self 		deny: (sw isSuspended);		assert: (sw isActive);		assert: (sw timespans size = 1);		assert: (t1 < sw start);		assert: (sw start < t2).	t3 _ DateAndTime now.		sw suspend; suspend.	t4 _ DateAndTime now.	self 		assert: (sw isSuspended);		deny: (sw isActive);		assert: (sw timespans size = 1);		assert: (sw end between: t3 and: t4);		assert: (t3 < sw end);		assert: (sw end < t4).! !!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 22:49'!classToBeTested	^ Stopwatch! !!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 23:01'!selectorsToBeIgnored	| private | 	private := #( #printOn: #state: ).	^ super selectorsToBeIgnored, private! !!StopwatchTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:49'!setUp	aStopwatch := Stopwatch new.	aDelay := Delay forMilliseconds: 1.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testChangingStatus	aStopwatch activate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 1.	aStopwatch suspend.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 1.	aStopwatch activate.	aStopwatch reActivate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 3.	aStopwatch reset.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 0.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testInitialStatus	self assert: aStopwatch isSuspended.	self deny: aStopwatch isActive.	self assert: aStopwatch duration = 0 seconds! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testMultipleTimings	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 2. 	self assert: aStopwatch timespans first asDateAndTime < aStopwatch 	timespans last asDateAndTime.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testPrintOn	| cs rw |	cs := ReadStream on: 'a Stopwatch(suspended:0:00:00:00)'.	rw := ReadWriteStream on: ''.	aStopwatch printOn: rw.	self assert: rw contents = cs contents! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testSingleTiming	| timeBefore |	timeBefore := DateAndTime now.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 1. 	self assert: aStopwatch timespans first asDateAndTime > timeBefore. 	self assert: aStopwatch timespans first asDateAndTime < aStopwatch end.! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDate	self assert: aTimeStamp date = '01-02-2004' asDate! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDateAndTime	self assert: aTimeStamp dateAndTime			= (Array with: '01-02-2004' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusDays	self assert: (aTimeStamp minusDays: 5) dateAndTime			= (Array with: '12-28-2003' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSeconds	self assert: (aTimeStamp minusSeconds: 34 * 60 + 56) dateAndTime			= (Array with: '01-02-2004' asDate with: '00:00:00' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSecondsOverMidnight	self assert: (aTimeStamp minusSeconds: 34 * 60 + 57) dateAndTime			= (Array with: '01-01-2004' asDate with: '23:59:59' asTime)	"Bug The results are actual results are: #(1 January 2005 11:25:03 pm)"! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusDays	self assert: (aTimeStamp plusDays: 366) dateAndTime			= (Array with: '01-02-2005' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSeconds	self assert: (aTimeStamp plusSeconds: 60 * 60 ) dateAndTime			= (Array with: '01-02-2004' asDate with: '01:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSecondsOverMidnight	self assert: (aTimeStamp plusSeconds: 24 * 60 * 60 + 1) dateAndTime			= (Array with: '01-03-2004' asDate with: '00:34:57' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPrintOn	| cs rw |	cs := ReadStream on: '2 January 2004 12:34:56 am'.	rw := ReadWriteStream on: ''.	aTimeStamp printOn: rw.	self assert: rw contents = cs contents! !!TimeStampTest methodsFor: 'testing' stamp: 'cbc 2/4/2004 21:18'!testReadFromA1	|ts|	ts _ TimeStamp current.
	self assert: (ts = (TimeStamp fromString: ts asString)).! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testStoreOn	| cs rw |	cs := ReadStream on: '''2 January 2004 12:34:56 am'' asTimeStamp'.	rw := ReadWriteStream on: ''.	aTimeStamp storeOn: rw.	self assert: rw contents = cs contents! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTime	self assert: aTimeStamp time =  '00:34:56' asTime! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTimeStamp	self assert: aTimeStamp = aTimeStamp asTimeStamp! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 21:56'!testAccessing	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: timestamp date = d;		assert: timestamp time = t.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:05'!testArithmetic	| ts |	ts := timestamp minusDays: 123.  	"9 September 1999, 11:55 am"	ts := ts minusSeconds: 1056.			"9 September 1999, 11:37:24 am"	ts := ts plusDays: 123.				"10 January 2000, 11:37:24 am"	ts := ts plusSeconds: 1056.			"10 January 2000, 11:55 am"	self		assert: ts  = timestamp.	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:34'!testArithmeticAcrossDateBoundary	| ts |	ts := timestamp minusSeconds: ((11*3600) + (55*60) + 1).	self		assert: ts = ('1-9-2000 11:59:59 pm' asTimeStamp).	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:24'!testComparing	| ts1 ts2 ts3 c1 c2 le |	ts1 := self timestampClass date: ('01-10-2000' asDate) time: ('11:55:00 am' asTime).	ts2 := self timestampClass date: ('07-26-2003' asDate) time: ('22:09:45 am' asTime).	ts3 := self timestampClass date: ('05-28-1972' asDate) time: ('04:31:14 pm' asTime).	self		assert: ts1 = timestamp;		assert: ts1 hash = timestamp hash;		assert: timestamp = timestamp copy;		assert: ts1 < ts2;		deny: ts1 < ts3.	c1 := self timestampClass current.	c2 := self timestampClass current.	le _ (c1 < c2).	self assert: le.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:19'!testConverting	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: timestamp asSeconds = (d asSeconds + t asSeconds);		assert: timestamp asDate = d;		assert: timestamp asTime = t;		assert: timestamp asTimeStamp == timestamp;		assert: timestamp dateAndTime = {d. t}.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:55'!testFromSeconds	self		assert: (self timestampClass fromSeconds: 3124958100) = timestamp.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testFromString	"This should signal an exception in 3.6beta as Time>>fromString: does not exist."	self should: [ timestamp = (self timestampClass fromString: '1-10-2000 11:55:00 am') ] ! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 14:52'!testInstanceCreation	| warn |	warn _ Preferences showDeprecationWarnings.	Preferences setPreference: #showDeprecationWarnings toValue: true.		self 		should: [ self timestampClass midnight asDuration = (0 hours) ];		should: [ self timestampClass midnightOn: timestamp date ] 			raise: Deprecation;		should: [ self timestampClass noon asDuration = (12 hours) ];		should: [ self timestampClass noonOn: timestamp date ] 			raise: Deprecation.				Preferences setPreference: #showDeprecationWarnings toValue: warn.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testPrinting	self			assert: timestamp printString = '10 January 2000 11:55 am'.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 17:47'!testSorting	| c1 c2 |	c1 _ self timestampClass current.	c2 _ self timestampClass current.	self		assert: (self timestampClass current) <= (self timestampClass current);		assert: (c1 <= c2).! !!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:50'!classToBeTested	^ self timestampClass! !!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 14:04'!selectorsToBeIgnored	| deprecated private special |	deprecated := #( #<= #>= #> ).	private := #( #date: #time: #printOn: ).	special := #( #< #= ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!TimeStampTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:50'!timestampClass	^ TimeStamp! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:41'!setUp	timestamp := self timestampClass date: ('1-10-2000' asDate) time: ('11:55:00 am' asTime).	aTimeStamp := TimeStamp readFrom: '1-02-2004 12:34:56 am' readStream! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 7/26/2003 21:53'!tearDown	timestamp := nil.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:33'!testAccessing	self		assert: time hours = 4;		assert: time minutes = 2;		assert: time seconds = 47;		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:35'!testArithmetic	| t1 t2 t3 |	t1 := time addSeconds: 70.		"4:03:57 am"	self		assert: t1 hours = 4;		assert: t1 minutes = 3;		assert: t1 seconds = 57.	t2 := t1 addTime: (self timeClass fromSeconds: (60*60*5)).	self		assert: t2 hours = 9;		assert: t2 minutes = 3;		assert: t2 seconds = 57.	t3 := t2 subtractTime: (self timeClass fromSeconds: (60*60*5) + 70).	self		assert: t3 = time.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:36'!testComparing	| t1 t2 t3 |	t1 := self timeClass fromSeconds: 14567.		"4:02:47 am"	t2 := self timeClass fromSeconds: 5000.		"1:23:20 am"	t3 := self timeClass fromSeconds: 80000.		"10:13:20 pm"	self		assert: time = t1;		assert: time hash = t1 hash;		assert: time = time copy.	self		deny: t1 < t2;		assert: t1 < t3.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:37'!testConverting	self		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:38'!testFromSeconds	| t |	t := self timeClass fromSeconds: 14567.	self		assert: t = time! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:52'!testGeneralInquiries	| now d t dt |	now  := self timeClass dateAndTimeNow.	self 		assert: now size = 2;		assert: now last <= self timeClass now.	self should: [ self timeClass timeWords ] raise: MessageNotUnderstood.	d := '2 June 1973' asDate.	t := '4:02:47 am' asTime.	dt := self timeClass dateAndTimeFromSeconds: (2285280000 + 14567).	self		assert: dt = {d. t.}.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:44'!testNew		self assert: self timeClass new asSeconds = 0! !!TimeTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 22:27'!testPrinting	self			assert: time printString = '4:02:47 am';		assert: time intervalString =  '4 hours 2 minutes 47 seconds';		assert: time print24 = '04:02:47';		assert: time printMinutes = '4:02 am';		assert: time hhmm24 = '0402'.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:46'!testReadFrom	| string t |	string := '4:02:47 am'.	t := self timeClass readFrom: string readStream.	self		assert: time = t.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:49'!testSqueakInquiries	| timewords totalseconds condensed corrected |	self assert: 		(self timeClass namesForTimes: #(2 10000023 10000026))			= #('January, 1901' 'April, 1901, 4/26/1901, 5:47 pm' 'April, 1901, 4/26/1901, 5:47 pm').	timewords := #(0.5 30 62 130 4000 10000 60000 90000) 		collect: [ :ss | self timeClass humanWordsForSecondsAgo: ss ].	self assert: 		timewords = #('a second ago' '30 seconds ago' 'a minute ago' '2 minutes ago' 			'an hour ago' '2 hours ago' '16 hours ago' 'yesterday').	totalseconds :=  self timeClass totalSeconds.	condensed := self timeClass condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [:tt | totalseconds - tt]).	corrected := condensed collect: [ :e | totalseconds - e ].	self		assert: (corrected includesAllOf: #(20 400 401 20000 40000 45000 200000)).! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:47'!testStoring	self			assert: time storeString = '''4:02:47 am'' asTime';		assert: time = ('4:02:47 am' asTime).! !!TimeTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:31'!classToBeTested	^ self timeClass! !!TimeTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 14:04'!selectorsToBeIgnored	 | deprecated private special primitives timing benchmarks |	deprecated := #().	private := #( #hours: #hours:minutes:seconds: #setSeconds: #print24:on: #print24:showSeconds:on: ).	special := #( #< #= #new #printOn: #storeOn: ).	primitives := #( #primMillisecondClock #primSecondsClock ).	timing := #( #millisecondClockValue #milliseconds:since: #millisecondsSince: ).	benchmarks := #( #benchmarkMillisecondClock #benchmarkPrimitiveResponseDelay ). 	^ super selectorsToBeIgnored, deprecated, private, special, primitives, timing, benchmarks.! !!TimeTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:52'!setUp	time := self timeClass fromSeconds: 14567.		"4:02:47 am"	aTime := Time readFrom: '12:34:56 pm' readStream! !!TimeTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:32'!timeClass	^ Time! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAddSeconds	self assert: (aTime addSeconds: 1) = (Time readFrom: (ReadStream on: '12:34:57')).	self assert: (aTime addSeconds: 60) = (Time readFrom: (ReadStream on: '12:35:56')).		self assert: (aTime addSeconds: 3600) = (Time readFrom: (ReadStream on: '13:34:56')).	self assert: (aTime addSeconds: 24*60*60) = (Time readFrom: (ReadStream on: '12:34:56')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAddTime	self assert: (aTime addTime: aTime) = (Time readFrom: (ReadStream on: '01:09:52')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDate	self assert: (aTime asDate) = (Date current)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDateAndTime	self assert: (aTime asDateAndTime) = (DateAndTime current midnight + aTime)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDuration	self assert: (aTime asDuration) = (Duration days: 0 hours: 12 minutes: 34 seconds: 56)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsNanoSeconds	self assert: (aTime asNanoSeconds) = 45296000000000! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsSeconds	self assert: (aTime asSeconds) = 45296! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTime	self assert: (aTime asTime) = aTime! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTimeStamp	self assert: (aTime asTimeStamp) = (DateAndTime current midnight + aTime) asTimeStamp! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsWeek	self assert: aTime asWeek = (DateAndTime current midnight + aTime) asWeek! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsYear	self assert: aTime asYear = (DateAndTime current midnight + aTime) asYear! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testDuration	self assert: aTime duration = 0 seconds! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testEqual	self assert: aTime = (Time readFrom: (ReadStream on: '12:34:56')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHash	self assert: aTime hash =  167741779.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHhmm24	self assert: aTime hhmm24 = '1234'! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHour	self assert: aTime hour =  12.	self assert: aTime hour12 =  1.	self assert: aTime hour24 =  12.	self assert: aTime hours =  12.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgo	self assert: (Time humanWordsForSecondsAgo: 0.999999999)			= 'a second ago'.	self assert: (Time humanWordsForSecondsAgo: 44.99999999)			= '44.99999999 seconds ago'.	self assert: (Time humanWordsForSecondsAgo: 89.999999999)			= 'a minute ago'.	self assert: (Time humanWordsForSecondsAgo: 2699.999999999)			= '44 minutes ago'.	self assert: (Time humanWordsForSecondsAgo: 5399.999999999)			= 'an hour ago'.	self assert: (Time humanWordsForSecondsAgo: 64799.999999999)			= '17 hours ago'.	! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgoWithDays	self assert: (Time humanWordsForSecondsAgo: 18 * 60 * 60)					= 'yesterday'.	self assert: (Time humanWordsForSecondsAgo: 24 * 60 * 60)					= 'yesterday'.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testLessThan	self assert: aTime < (Time readFrom: (ReadStream on: '12:34:57')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMeridianAbbreviation	self assert: aTime meridianAbbreviation =  'PM'.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMinute	self assert: aTime minute =  34.	self assert: aTime minutes =  34! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testNanoSecond	self assert: aTime nanoSecond = 0	"Right now all times all seconds"! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24	self assert: aTime print24 = '12:34:56'! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24On	| cs rw |	cs := ReadStream on: '12:34:56'.	rw := ReadWriteStream on: ''.	aTime print24: true on: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24OnWithPM	| cs rw |	cs := ReadStream on: '12:34:56 pm'.	rw := ReadWriteStream on: ''.	aTime print24: false on: rw.	^ self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24OnWithoutSeconds	| cs rw |	cs := ReadStream on: '12:34:56'.	rw := ReadWriteStream on: ''.	aTime print24: true showSeconds: true on: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrintMinutes	self assert: aTime printMinutes = '12:34 pm'! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrintOn	| cs rw |	cs := ReadStream on: '12:34:56 pm'.	rw := ReadWriteStream on: ''.	aTime printOn: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSecond	self assert: aTime second =  56.	self assert: aTime seconds =  56! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testStoreOn	| cs rw |	cs := ReadStream on: '''12:34:56 pm'' asTime'.	rw := ReadWriteStream on: ''.	aTime storeOn: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSubtractTime	self assert: (aTime subtractTime: aTime) = (Time readFrom: (ReadStream on: '00:00:00'))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTicks	self assert: aTime ticks = #(0 45296 0).	self assert: aTime  = (Time new ticks: #(0 45296 0))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTimeStamp	self assert: aTime = aTime asTimeStamp asTime! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month starting: (DateAndTime year: 2004 day: 355) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 1) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 32) duration: 29 days)				with: (Month starting: (DateAndTime year: 2005 day: 61) duration: 31 days).					self assert: aTimespan months = monthArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testNext	self assert: aTimespan next			= (Timespan					starting: (DateAndTime							year: 2005							month: 3							day: 26							hour: 0							minute: 0							second: 0)					duration: aDuration)! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 14:01'!testWeeksDo	| weekArray |	weekArray := OrderedCollection new.	weekArray		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).	2 to: 86 by: 7 do: 		[ :i | weekArray				addLast: (Week starting: (DateAndTime year: 2005 day: i) duration: 7 days) ].				weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:54'!testYearsDo	| yearArray |	yearArray := Array				with: (Year starting: (DateAndTime year: 2004 month: 12 day: 25) duration: 366 days).	self assert: aTimespan years contents = yearArray contents! !!TimespanDoSpanAYearTest methodsFor: 'running' stamp: 'tlk 1/5/2004 17:06'!setUp	aDate := DateAndTime				year: 2004				month: 12				day: 25				hour: 0				minute: 0				second: 0.	aDuration := Duration				days: 91				hours: 0				minutes: 0				seconds: 0				nanoSeconds: 0.	aTimespan := Timespan starting: aDate duration: aDuration! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 18:00'!testDatesDo	| dateArray |	dateArray := OrderedCollection new.	7		to: 97		do: [:each | dateArray				addLast: (Date year: 2003 day: each)].	dateArray := dateArray asArray.	self assert: aTimespan dates = dateArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:36'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan				starting: aDate				duration: 7 days).	self assert: count = 13! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:39'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: aDate duration: 7 days)		when: [:each | count < 5].	self assert: count = 5	! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 15:39'!testEveryDo	|count  duration |	count := 0.	duration := 7 days.	(aTimespan			every: duration			do: [:each | count := count + 1]).	self assert: count = 13			! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:05'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month						starting: (DateAndTime year: 2003 day: 1)						duration: 31 days)				with: (Month						starting: (DateAndTime year: 2003 day: 32)						duration: 28 days)				with: (Month						starting: (DateAndTime year: 2003 day: 60)						duration: 31 days)						with: (Month						starting: (DateAndTime year: 2003 day: 91)						duration: 30 days).	self assert: aTimespan months = monthArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:09'!testNext	self assert: aTimespan next 			= (Timespan					starting: (DateAndTime							year: 2003							month: 4							day: 8							hour: 0							minute: 0							second: 0)					duration: aDuration)! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:07'!testWeeksDo	| weekArray |	weekArray := OrderedCollection new.	7		to: 98		by: 7		do: [:each | weekArray				addLast: (Week						starting: (DateAndTime year: 2003 day: each)						duration: 7 days)].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:09'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime year: 2003 day: 7)						duration: 365 days).	self assert: aTimespan years contents = yearArray contents! !!TimespanDoTest methodsFor: 'running' stamp: 'tlk 1/5/2004 13:01'!setUp	aDate := DateAndTime				year: 2003				month: 01				day: 07				hour: 0				minute: 0				second: 0.	aDuration := Duration				days: 91				hours: 0				minutes: 0				seconds: 0				nanoSeconds: 0.	aTimespan := Timespan starting: aDate duration: aDuration! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:25'!testAccessing	self 		assert: (timespan start =				 (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0));		assert: timespan duration = (Duration hours: 100);		assert: timespan month = 3;		assert: timespan monthName = 'March';		assert: timespan monthAbbreviation = 'Mar'		! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 9/15/2003 14:29'!testArithmetic	| ts1 ts2 d |	ts1 _ timespan + 2 days.	ts2 _ ts1 - 2 days.	d _ ts1 - (DateAndTime year: 2003 month: 03 day: 20).	self 		assert: (ts1 start = 				 (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0));		assert: (ts1 duration = timespan duration);		assert: (ts2 start = timespan start);		assert: (ts2 duration = timespan duration).	self		assert: d = (Duration days: 4 hours: 12 minutes: 0 seconds: 0)! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:43'!testInclusion	| t1 t2 t3 t4 |	t1 _ timespan start.	t2 _ timespan start + (timespan duration / 2).	t3 _ timespan end.	t4 _ timespan start + (timespan duration).	self 		assert: (timespan includes: t1);		assert: (timespan includes: t2);		assert: (timespan includes: t3)";		deny: (timespan includes: t4).	self		assert: (timespan includes: (t1 to: t2));		assert: (timespan includes: (t1 to: t4));		deny: (timespan includes: (Timespan starting: t2 duration: (timespan duration * 2))).	self 		assert: (timespan includesAllOf: { t1. t2. t3 } );		deny: (timespan includesAllOf: { t1. t2. t3. t4} ).	self 		assert: (timespan includesAnyOf: { t1. t2. t3 } );		deny: (timespan includesAnyOf: { t4 } )."! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:49'!testUnion	| union |	union _ timespan union: timespan.		self 		assert: (union start = timespan start);		assert: (union duration = timespan duration)! !!TimespanTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:23'!setUp	"100 hours starting noon 22 March 2003"	timespan _ Timespan starting: 					(DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0)						duration: (Duration hours: 100).	dec31 := (DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0).	jan01 := (DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0).	jan08 := (DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second:0).	aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0. 	aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.      aTimespan := Timespan starting: jan01 duration: aWeek.	anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.     anIncludedTimespan := Timespan starting: jan01 duration: aDay.     aDisjointTimespan := Timespan starting: jan08 duration: aWeek.						! !!TimespanTest methodsFor: 'Running' stamp: 'brp 9/15/2003 14:20'!tearDown	timespan _ nil! !!TimespanTest methodsFor: 'Coverage' stamp: 'brp 9/15/2003 14:15'!classToBeTested	^ Timespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDate	self assert: aTimespan asDate =   jan01 asDate.	"MessageNotUnderstood: Date class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDateAndTime	self assert: aTimespan asDateAndTime =   jan01.	"MessageNotUnderstood: Date class>>starting:"	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDuration	self assert: aTimespan asDuration =  aWeek.		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsMonth	self assert: aTimespan asMonth =   jan01 asMonth.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTime	self assert: aTimespan asTime =  jan01 asTime	"MessageNotUnderstood: Time class>>seconds:nanoSeconds:" ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTimeStamp	self assert: aTimespan asTimeStamp =  ((TimeStamp readFrom: '1-01-2005 0:00 am' readStream) offset: 0 hours).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsWeek	self assert: aTimespan asWeek =   jan01 asWeek.	"DateAndTime new asWeek	 MessageNotUnderstood: Week class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsYear	self assert: aTimespan asYear =   jan01 asYear.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testCurrent	self assert: (Timespan starting: DateAndTime current)			< Timespan current.	self assert:  Timespan current			< (Timespan starting: DateAndTime current)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDay	self assert: aTimespan day =   jan01 day! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfMonth	self assert: aTimespan dayOfMonth  = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfWeek	self assert: aTimespan  dayOfWeek  = 7.	self assert: aTimespan  dayOfWeekName = 'Saturday'.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfYear	self assert: aTimespan  dayOfYear  = 1.	"MessageNotUnderstood: UndefinedObject>>year:, Undefined object is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInMonth	self assert: aTimespan  daysInMonth  = 31.	"MessageNotUnderstood: Month class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInYear	self assert: aTimespan  daysInYear  = 365.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysLeftInYear	self assert: aTimespan  daysLeftInYear  = 364.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay).	self assert: count = 7! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay)		when: [:each | count < 5].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDuration	self assert: aTimespan duration  = aWeek.	aTimespan duration: aDay.	self assert: aTimespan duration =  aDay.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testEnd	self assert: aTimespan end 	+ (Duration  nanoSeconds:1)  =  aDisjointTimespan	"self assert: aTimespan end 	(DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours). "	"This should work once DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset: is fixed"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testEveryDo	| count duration |	count := 0.	duration := 7 days.	aTimespan		every: duration		do: [:each | count := count + 1].	self assert: count = 1! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testFirstDayOfMonth	self assert: aTimespan firstDayOfMonth =   1. 	self assert: aDisjointTimespan firstDayOfMonth =   1! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testHash	self assert: aTimespan hash =     268333199	"must be a more meaningful test?"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludes	self assert: (aTimespan includes: jan01).	self deny: (aTimespan includes: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAllOf	self assert: (aTimespan includesAllOf: (Bag with: jan01)).	self deny: (aTimespan includesAllOf: (Bag with: jan01 with: jan08))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAnyOf	self deny: (aTimespan includesAnyOf: (Bag with: dec31)).	self assert: (aTimespan includesAnyOf: (Bag with: jan01 with: jan08))	"Error is due to bug in Timespan includesAnyOf: aCollection "	"Answer whether any element of aCollection is included in the receiver"	"aCollection do: [ :elem | (self includes: elem) ifTrue: [^ true]].Shouldn't this return false if none are included?"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithDisjoint	self assert: (aTimespan intersection: aDisjointTimespan) isNil.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithIncluded	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithOverlapping	self assert: (aTimespan intersection: anOverlappingTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 5 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSelf	self assert: (aTimespan intersection: aTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 6 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= aTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSeparate	self assert: (aTimespan intersection: aDisjointTimespan) isNil.	self deny: (aTimespan intersection: anOverlappingTimespan) isNil.	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIsLeapYear	"self assert: anOverlappingTimespan isLeapYear."	"not sure why this fails"	self deny: aTimespan isLeapYear! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testJulianDayNumber	self assert: aTimespan julianDayNumber =  (jan01 julianDayNumber).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testLessThan	self assert: aTimespan  < aDisjointTimespan.	self deny: anIncludedTimespan < aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADateAndTime	"It appears that subtracting a date from a Timespan gives you a duration = to the difference between the start of the timespan and the date "	self assert: aTimespan - dec31 =  aDay.	self assert: aDisjointTimespan - jan01 =  aWeek.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADuration	"It appears that subtracting a duration from a Timespan gives you a Timespan shifted by the duration"	self assert: aTimespan - aDay =  anOverlappingTimespan.	self assert: aDisjointTimespan - aWeek =  aTimespan.	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMonth	self assert: aTimespan month  = 1.	self assert: aTimespan monthName = 'January'.	self assert: aTimespan monthIndex = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNew	self assert: Timespan new = (Timespan starting: '01-01-1901' asDate)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNext	self assert: aTimespan next = aDisjointTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPlus	self assert: aTimespan + aWeek = aDisjointTimespan.	self assert: anOverlappingTimespan + aDay = aTimespan.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPrevious	self assert: aTimespan  = aDisjointTimespan previous.	self assert: aTimespan next previous = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPrintOn 	|cs rw |	cs _ ReadStream on: 'a Timespan( 2005-01-01T00:00:00+00:00D7:00:00:00)'.	rw _ ReadWriteStream on: ''.     aTimespan  printOn: rw.     self assert: rw contents = cs contents! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStart	self assert: aTimespan start =   jan01.	aTimespan start: jan08.	self assert: aTimespan start =   jan08.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStartingEnding	self assert: aTimespan  = (Timespan starting: jan01 ending: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testTo	self assert: (anIncludedTimespan to: jan08) = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithDisjoint	self assert: (aTimespan union: aDisjointTimespan)  = 		(Timespan starting: jan01 duration: (14 days)).				! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithIncluded	self 		assert: (aTimespan union: anIncludedTimespan) = aTimespan 	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithOverlapping	self 		assert: (aTimespan union: anOverlappingTimespan)  = 				(Timespan starting: dec31 duration: (8 days))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSelf	self assert: (aTimespan union: aTimespan) = aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSeparate	self 		assert: (anOverlappingTimespan union: aDisjointTimespan) = 			(Timespan 				starting: anOverlappingTimespan start				ending:  (aDisjointTimespan end + DateAndTime clockPrecision))			! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testWorkDatesDo	| count |	count := 0.	aTimespan		workDatesDo: [:each | count := count + 1].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testYear	self assert: aTimespan year = 2005.	! !!WeekTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:28'!testEnumerating	| days |	days := OrderedCollection new.	0 to: 6 do: [ :i | days add: ('29 June 1998' asDate addDays: i) ].	week do: [ :d | days remove: d ].		self assert: days isEmpty.! !!WeekTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:08'!testInquiries	self		assert: week firstDate = '29 June 1998' asDate;		assert: week lastDate = '5 July 1998' asDate;		assert: week index = 5;		assert: week duration = (7 days).! !!WeekTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:19'!testPreviousNext	self		assert: week next = (Week fromDate: '6 July 1998' asDate);		assert: week previous = (Week fromDate: '22 June 1998' asDate).! !!WeekTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Week! !!WeekTest methodsFor: 'Coverage' stamp: 'brp 7/26/2003 23:43'!selectorsToBeIgnored	| deprecated private special |	deprecated := #( #startMonday #toggleStartMonday).	private := #( #indexInMonth: #printOn: ).	special := #( #next #do: ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!WeekTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:25'!setUp	"June 1998, 5th week"	super setUp.	Week startMonday ifFalse: [ Week toggleStartMonday ].	week _ Week fromDate: '4 July 1998' asDate.! !!WeekTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:26'!tearDown	super tearDown.	week _ nil.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:51'!testDaysInMonth	self assert: (Month daysInMonth: 2 forYear: 2000) = 29.	self assert: (Month daysInMonth: 2 forYear: 2001) = 28.	self assert: (Month  daysInMonth: 2 forYear: 2004) = 29.	self assert: (Month  daysInMonth: 2 forYear: 2100) = 28.		self assert: (Month  daysInMonth: 'January' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'February' forYear: 2003) = 28.	self assert: (Month  daysInMonth: 'March' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'April' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'May' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'June' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'July' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'August' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'September' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'October' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'November' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'December' forYear: 2003) = 31.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:37'!testDaysInYear	self assert: (Year daysInYear: 2000) = 366.	self assert: (Year daysInYear: 2001) = 365.	self assert: (Year daysInYear: 2004) = 366.	self assert: (Year daysInYear: 2100) = 365.	self assert: (Year daysInYear: 2003) = 365.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:37'!testIndexOfDay	self assert: (Week indexOfDay: 'Friday') = 6.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:33'!testIsLeapYear	self assert: (Year isLeapYear: 2000).	self deny: (Year isLeapYear: 2001).	self assert: (Year isLeapYear: 2004).	self deny: (Year isLeapYear: 2100).	self deny: (Year isLeapYear: 2002).! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 18:53'!testMonthPrintOn    	|aMonth cs rw |	aMonth _ 	Month starting: DateAndTime new duration: 31 days.  	cs _ ReadStream on: 'January 1901'.	rw _ ReadWriteStream on: ''.     aMonth printOn: rw.     self assert: rw contents = cs contents.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:34'!testStartDay	Week startDay: 'Wednesday'.	self assert: Week startDay = 'Wednesday'.	Week startDay: 'Thursday'.	self assert: Week startDay = 'Thursday'.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:50'!testWeekPrintOn    	|aWeek cs rw |	aWeek _ Week starting: DateAndTime new duration: 7 days. 	cs _ 'a Week starting:  1900-12-31T00:00:00+00:00'.	rw _ WriteStream on: ''.     aWeek printOn: rw.     self assert: rw contents = cs! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 18:51'!testYearPrintOn    	|aYear cs rw |	aYear _ 	Year starting: DateAndTime new duration: 365 days. 	cs _ ReadStream on: 'a Year (1901)'.	rw _ ReadWriteStream on: ''.     aYear printOn: rw.     self assert: rw contents = cs contents.! !!YearMonthWeekTest methodsFor: 'running' stamp: 'tlk 1/3/2004 13:03'!setUp	restoredStartDay _ Week startDay! !!YearMonthWeekTest methodsFor: 'running' stamp: 'tlk 1/3/2004 13:26'!tearDown	Week startDay: restoredStartDay! !!YearTest methodsFor: 'Tests' stamp: 'brp 9/11/2003 14:30'!testCurrent	| yyyy |	yyyy _ DateAndTime now year.		self assert: Year current start = (DateAndTime year: yyyy month: 1 day: 1)! !!YearTest methodsFor: 'Coverage' stamp: 'brp 9/11/2003 14:31'!classToBeTested	^ Year! !ClassTestCase subclass: #TimeStampTest	instanceVariableNames: 'timestamp aTimeStamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology-Tests'!