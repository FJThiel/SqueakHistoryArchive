'From Squeak 2.5 of August 6, 1999 on 23 September 1999 at 2:02 pm'!"Change Set:		SegmentsDate:			23 September 1999Author:			Ted KaehlerMechanism for allowing whole Projects to be sent to the disk as Segments.  Only a few need to be in memory at once.  *** Not fully debugged at this time ***Also corrects a non-translatable (to C) phrase I introduced into the Interpreter."!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state fileName endMarker '	classVariableNames: 'BiggestFileNumber '	poolDictionaries: ''	category: 'System-Object Storage'!!HandMorph methodsFor: 'world menu commands' stamp: 'tk 9/21/1999 22:12'!clearPasteBuffer	"Clear the paste buffer."	PasteBuffer _ nil.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/21/1999 16:56'!copyFromRoots: aRootArray	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize |	aRootArray ifNil: [self errorWrongState].	arrayOfRoots _ aRootArray.	outPointers _ nil.	"may have used this instance before"	segSize _ 50000.	["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	endMarker _ 'End' clone.	"for enumeration of objects"	outPointerArray _ Array new: segSize // 20.	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/15/1999 09:27'!copyFromRootsLocalFileFor: rootArray 	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots _ rootArray.	[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	Smalltalk forgetDoIts.  	self copyFromRoots: arrayOfRoots.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/23/1999 13:52'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	"Sensor shiftPressed ifTrue: [self halt]."	"(self confirm: 'Installing segment.  Want a debugger?') ifTrue: [self halt]."	state _ #inactive.	(PluckedSound pitch: 261.625*3 dur: 0.25 loudness: 0.1) play.	"interrupts previous sound"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/15/1999 09:29'!writeForExport: shortName	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk."	| fileStream temp |	state = #activeCopy ifFalse: [self error: 'wrong state'].	temp _ endMarker.	endMarker _ nil.	(shortName endsWith: '.extSeg')		ifTrue: [fileName _ shortName]		ifFalse: [fileName _ shortName , '.extSeg'].	fileStream _ FileStream newFileNamed: fileName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/15/1999 09:27'!writeToFile: shortName	state = #active ifFalse: [self error: 'wrong state'].	(shortName endsWith: '.seg')		ifTrue: [fileName _ shortName]		ifFalse: [fileName _ shortName , '.seg'].	(FileStream newFileNamed: fileName) nextPutAll: segment; close.	segment _ nil.	endMarker _ nil.	state _ #onFile! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/15/1999 09:34'!allObjectsDo: aBlock	"Enumerate all objects that came from this segment.  NOTE this assumes that the segment was created (extract) but not removed from memory (writeToFile:).  After the segment has been installed (install), this method allows you to enumerate its objects."	| obj |	endMarker == nil ifTrue: [^ self error: 'Just extract and install, don''t writeToFile:'].	segment size ~= 1 ifTrue: [^ self error: 'Vestigial segment size must be 1 (version word)'].	obj _ segment nextObject.  "Start with the next object after the vestigial header"	[obj == endMarker] whileFalse:  "Stop at the next object after the full segment"		[aBlock value: obj.		obj _ obj nextObject].  "Step through the objects installed from the segment."! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'tk 9/8/1999 18:48'!folder	^ 'Segments'! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'tk 9/8/1999 19:25'!uniqueFileNameFor: segName	"Choose a unique file name for the segment with this name.  If no folder exists, create it in the same directory as the image."| dir segDir fileName |dir _ FileDirectory default.(dir includesKey: self folder "Segments") ifFalse: [	dir createDirectory: ImageSegment folder].	"create the folder"segDir _ dir directoryNamed: self folder.BiggestFileNumber ifNil: [BiggestFileNumber _ 1].[fileName _ segName, BiggestFileNumber asString, '.seg'. segDir fileExists: fileName] whileTrue: [	BiggestFileNumber _ BiggestFileNumber + 1].	"force a unique file name"^ segDir pathName, FileDirectory slash, fileName! !!Interpreter methodsFor: 'debug support' stamp: 'tk 9/23/1999 13:40'!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = '16r1C' "(Metaclass instSize +1*4)" ifTrue: [		self printNameOfClass: (self fetchPointer: 5 "thisClass" ofObject: classOop) 			count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 9/9/1999 12:08'!storeProjectsAsSegments	"Force my sub-projects out to disk"submorphs do: [:sub |	(sub isKindOf: SystemWindow) ifTrue: [		(sub model isKindOf: Project) ifTrue: [			sub model storeSegment]]].	"OK if was already out"! !!Project methodsFor: 'initialization' stamp: 'tk 9/22/1999 18:35'!defaultBackgroundColor	^ self isMorphic		ifTrue: [self backgroundColorForMorphicProject]		ifFalse: [self backgroundColorForMvcProject]! !!Project methodsFor: 'accessing' stamp: 'tk 9/22/1999 18:32'!isMorphic	"Complexity is because #isMVC is lazily installed"	^ world isInMemory 		ifTrue: [world isMorph]		ifFalse: [(self projectParameters at: #isMVC ifAbsent: [false]) not]! !!Project methodsFor: 'menu messages' stamp: 'tk 9/22/1999 19:00'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case."	| showZoom recorderOrNil same old |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	CurrentProject makeThumbnail.	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue:[displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	showZoom ifTrue:[self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	(same _ CurrentProject topIsolated == self topIsolated) ifFalse: [		CurrentProject revoke].	old _ CurrentProject.	CurrentProject _ self.	same ifFalse: [CurrentProject invoke].	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [				self storeSomeSegment].			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts.			self spawnNewProcessAndTerminateOld: true]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world.			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'file in/out' stamp: 'tk 9/22/1999 18:29'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg"| is response |world == World ifTrue: [^ self]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].		"keep the Menu flap from pointing at my project.  Already done by enter?"	"Preferences setPreference: #useGlobalFlaps toValue: false."	"Utilities globalFlapTabsIfAny do:		[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].	Utilities clobberFlapTabList.	"	"project world deleteAllFlapArtifacts."	"self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: world presenter with: world).	"world, and all Players"is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' not enough objects for a Segment.'; cr.	^ false].is extract; writeToFile: (ImageSegment uniqueFileNameFor: self name).^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 9/22/1999 18:29'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |world == World ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: world presenter with: world).	"world, and all Players"is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ self beep].false ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !!Project methodsFor: 'file in/out' stamp: 'tk 9/22/1999 19:00'!storeSomeSegment	"Try all projects to see if any is ready to go out.  Previous one has to wait for a garbage collection before it can go out."	Project allInstances do: [:proj | 		(PluckedSound pitch: 261.625*2 dur: 0.25 loudness: 0.1) play.		proj storeSegment "Send its morphs to disk" ifTrue: [			(PluckedSound pitch: 261.625*4 dur: 1 loudness: 0.1) play]].! !!Project class methodsFor: 'utilities' stamp: 'tk 9/22/1999 18:45'!addItem: item toMenu: menu selection: action project: aProject	| aColor |	aColor _ aProject isMorphic 		ifTrue: [aProject world isInMemory 			ifTrue: [Color red darker] 			ifFalse: [Color brown]]		ifFalse: [aProject world isInMemory 			ifTrue: [Color veryVeryDarkGray]			ifFalse: [Color blue]].	(menu isKindOf: MenuMorph)		ifTrue:			[menu add: item selector: #jumpToSelection: argument: action.			menu items last color: aColor]		ifFalse:			[menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'tk 9/22/1999 18:51'!ofWorld: aPasteUpMorph	"Find the project of a world.  Not efficient"	^ self allSubInstances detect: [:pr | 		pr world isInMemory 			ifTrue: [pr world == aPasteUpMorph]			ifFalse: [false]		] ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'tk 9/21/1999 22:31'!storeAllInSegments	"Write out all Projects in this Image.	Project storeAllInSegments.		"	| all ff ll |all _ Project allInstances.Transcript show: 'Initial Space Left: ', (ff _ Smalltalk garbageCollect) printString; cr.all do: [:proj |	Transcript show: proj name; cr.	proj storeSegment  "storeSegmentNoFile"].Transcript show: 'After writing all: ', (ll _ Smalltalk garbageCollect) printString; cr.Transcript show: 'Space gained: ', (ll - ff) printString; cr."some will come back in"! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'tk 9/8/1999 17:51'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg"	project storeSegment! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 9/21/1999 15:57'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !"Postscript:Later turn this on.  Then as you leave each project, an old one is written out as a segment."Preferences setPreference: #projectsSentToDisk toValue: false.!