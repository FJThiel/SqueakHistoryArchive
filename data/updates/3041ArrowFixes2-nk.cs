'From Squeak2.9alpha of 13 June 2000 [latest update: #2915] on 12 November 2000 at 12:06:31 pm'!"Change Set:		234ArrowFixes2-nkDate:			6 October 2000Author:			Ned KonzThis change set adds the ability to have four kinds of arrow heads: concave and triangular, open or filled.Requires 2.9a and 2765ArrowTweaks2-di changeset.---not the same number in all update streams---ChangeSet allInstances	detect: [ :ea | ea name = '2765ArrowTweaks2-di' ]	ifNone: [ self error: 'prerequisite 2765ArrowTweaks2-di not present' ]"!!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:09'!drawArrowOn: aCanvas at: endPoint from: priorPoint 	"Draw a triangle oriented along the line from priorPoint to  	endPoint. Answer the wingBase."	| pts spec wingBase |	pts _ self arrowBoundsAt: endPoint from: priorPoint.	wingBase _ pts size = 4 ifTrue: [ pts at: 3 ]		ifFalse: [ (pts copyFrom: 2 to: 3) average ].	spec _ self				valueOfProperty: #arrowSpec				ifAbsent: [5 @ 4].	spec x sign = spec y sign		ifTrue: [aCanvas drawPolygon: pts fillStyle: borderColor]		ifFalse: [aCanvas				drawPolygon: pts				fillStyle: Color transparent				borderWidth: borderWidth + 1 // 2				borderColor: borderColor].	^wingBase! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:00'!drawArrowsOn: aCanvas 	"Answer (possibly modified) endpoints for border drawing"	"ArrowForms are computed only upon demand"	| array |	(closed			or: [arrows == #none					or: [vertices size < 2]])		ifTrue: [^ self].	"Nothing to do"	borderColor isColor		ifFalse: [^ self].	array _ Array new: 2.	"Prevent crashes for #raised or #inset borders"	array at: 2 put: ((arrows == #forward			or: [arrows == #both])		ifTrue: [ self				drawArrowOn: aCanvas				at: vertices last				from: self nextToLastPoint]		ifFalse: [ vertices last ]).	array at: 1 put: ((arrows == #back			or: [arrows == #both])		ifTrue: [self				drawArrowOn: aCanvas				at: vertices first				from: self nextToFirstPoint]		ifFalse: [ vertices first ]).	^array! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:22'!drawBorderOn: aCanvas 	self		drawBorderOn: aCanvas		usingEnds: (Array with: vertices first with: vertices last)! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 13:01'!drawBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas."	"NOTE: Much of this code is also copied in drawDashedBorderOn:  	(should be factored)"	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	borderDashSpec		ifNotNil: [^ self drawDashedBorderOn: aCanvas usingEnds: anArray].	(borderColor == nil			or: [borderColor isColor					and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of  	vertices"	borderColor == #raised		ifTrue: [topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset		ifTrue: [topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	brush _ nil.	self		lineSegmentsDo: [:p1 :p2 | 			p1i _ p1 asIntegerPoint.			p2i _ p2 asIntegerPoint.			(arrows ~= #none					and: [closed not])				ifTrue: ["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back								or: [arrows == #both])							and: [p1 = vertices first])						ifTrue: [p1i _ anArray first asIntegerPoint].					((arrows == #forward								or: [arrows == #both])							and: [p2 = vertices last])						ifTrue: [p2i _ anArray last asIntegerPoint]].			(closed					or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"						((p1i min: p2i)							max: bigClipRect origin)							<= ((p1i max: p2i)									min: bigClipRect corner)])				ifTrue: [bevel						ifTrue: [(p1i quadrantOf: p2i)									> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					(borderWidth > 3							and: [borderColor isColor])						ifTrue: [brush == nil								ifTrue: [brush _ (ColorForm dotOfSize: borderWidth)												colors: (Array with: Color transparent with: borderColor)].							aCanvas								line: p1i								to: p2i								brushForm: brush]						ifFalse: [aCanvas								line: p1i								to: p2i								width: borderWidth								color: lineColor]]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:23'!drawDashedBorderOn: aCanvas 	self		drawDashedBorderOn: aCanvas		usingEnds: (Array with: vertices first with: vertices last)! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:36'!drawDashedBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas. NOTE: mostly copied from  	drawBorderOn:"	| lineColor bevel topLeftColor bottomRightColor bigClipRect p1i p2i segmentOffset |	(borderColor == nil			or: [borderColor isColor					and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of  	vertices"	borderColor == #raised		ifTrue: [topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset		ifTrue: [topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	segmentOffset _ self borderDashOffset.	self		lineSegmentsDo: [:p1 :p2 | 			p1i _ p1 asIntegerPoint.			p2i _ p2 asIntegerPoint.			(arrows ~= #none					and: [closed not])				ifTrue: ["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back								or: [arrows == #both])							and: [p1 = vertices first])						ifTrue: [p1i _ anArray first asIntegerPoint].					((arrows == #forward								or: [arrows == #both])							and: [p2 = vertices last])						ifTrue: [p2i _ anArray last asIntegerPoint]].			(closed					or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"						((p1i min: p2i)							max: bigClipRect origin)							<= ((p1i max: p2i)									min: bigClipRect corner)])				ifTrue: [bevel						ifTrue: [(p1i quadrantOf: p2i)									> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					segmentOffset _ aCanvas								line: p1i								to: p2i								width: borderWidth								color: lineColor								dashLength: borderDashSpec first								secondColor: borderDashSpec third								secondDashLength: borderDashSpec second								startingOffset: segmentOffset]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:07'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight 	line segments."	| array |	vertices size < 1		ifTrue: [self error: 'a polygon must have at least one point'].	closed		ifTrue: [aCanvas drawPolygon: self getVertices fillStyle: self fillStyle].	array _ self drawArrowsOn: aCanvas.	self drawBorderOn: aCanvas usingEnds: array.! !!PolygonMorph methodsFor: 'drawing' stamp: 'nk 10/4/2000 12:22'!drawPostscriptOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight 	line segments."	| array |	vertices size < 1		ifTrue: [self error: 'a polygon must have at least one point'].	array _ self drawArrowsOn: aCanvas.	closed		ifTrue: [aCanvas				drawPolygon: self getVertices				color: self color				borderWidth: self borderWidth				borderColor: self borderColor]		ifFalse: [self drawBorderOn: aCanvas usingEnds: array].! !!PolygonMorph methodsFor: 'editing' stamp: 'nk 10/4/2000 12:56'!updateHandles	| newVert oldVert midPts nextVertIx tweens |	smoothCurve		ifTrue: [			handles first center: vertices first.			handles last center: vertices last.			midPts _ OrderedCollection new.			nextVertIx _ 2.			tweens _ OrderedCollection new.			self				lineSegmentsDo: [:p1 :p2 | 					tweens addLast: p2 asIntegerPoint.					p2							= (vertices atWrap: nextVertIx)						ifTrue: ["Found endPoint."							midPts addLast: (tweens at: tweens size // 2)									+ (tweens at: tweens size + 1 // 2) // 2.							tweens _ OrderedCollection new.							nextVertIx _ nextVertIx + 1]].			midPts				withIndexDo: [:midPt :vertIndex | (closed							or: [vertIndex < vertices size])						ifTrue: [newVert _ handles at: vertIndex * 2.							newVert position: midPt - (newVert extent // 2)]]]		ifFalse: [vertices				withIndexDo: [:vertPt :vertIndex | 					oldVert _ handles at: vertIndex * 2 - 1.					oldVert position: vertPt - (oldVert extent // 2).					(closed							or: [vertIndex < vertices size])						ifTrue: [newVert _ handles at: vertIndex * 2.							newVert position: vertPt									+ (vertices atWrap: vertIndex + 1) - newVert extent // 2 + (1 @ -1)]]]! !