'From Squeak2.9alpha of 13 June 2000 [latest update: #3389] on 2 February 2001 at 4:41:15 pm'!"Change Set:		IndexedExternalPrims-arDate:			2 February 2001Author:			Andreas RaabThe change set closes a security loophole which exposed C function addresses in named primitives to the Smalltalk side directly. We now allocate dynamically a primitive index (from the external primitive table) which is exposed to the ST side, making it impossible to call a fake pointer to an arbitrary memory location by using named primitives."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignalA semaphoresUseBufferA semaphoresToSignalCountA semaphoresToSignalB semaphoresToSignalCountB savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory newNativeMethod methodClass receiverClass interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy showSurfaceFn interruptCheckCounterFeedBackReset interruptChecksEveryNms externalPrimitiveTable '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex GenerateBrowserPlugin HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex JitterTable LastLinkIndex LiteralStart MaxExternalPrimitiveTableSize MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCacheNative MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MillisecondClockMask MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!Interpreter methodsFor: 'other primitives' stamp: 'ar 2/2/2001 16:34'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger) [OBSOLETE]		* The function index (Integer) in the externalPrimitiveTable	For fast failures the primitive index of any method where the external prim is not found is rewritten in the method cache with zero. This allows for ultra fast responses as long as the method stays in the cache.	The fast failure response relies on lkupClass being properly set. This is done in #addToMethodCacheSel:class:method:primIndex: to compensate for execution of methods that are looked up in a superclass (such as in primitivePerformAt).	With the latest modifications (e.g., actually flushing the function addresses from the VM), the session ID is obsolete. But for backward compatibility it is still kept around. Also, a failed lookup is reported specially. If a method has been looked up and not been found, the function address is stored as -1 (e.g., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be returned from the lookup).	It is absolutely okay to remove the rewrite if we run into any problems later on. It has an approximate speed difference of 30% per failed primitive call which may be noticable but if, for any reasons, we run into problems (like with J3) we can always remove the rewrite.	"	| lit addr moduleName functionName moduleLength functionLength index |	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0."@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) 					and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function index in case it has been loaded before"	index _ self fetchPointer: 3 ofObject: lit.	(self isIntegerObject: index) ifFalse:[^self success: false].	index _ self integerValueOf: index.	"Check if we have already looked up the function and failed."	index < 0 ifTrue:[		"Function address was not found in this session,		Rewrite the mcache entry with a zero primitive index."		self			rewriteMethodCacheSel: messageSelector			class: lkupClass			primIndex: 0.				^self success: false].	"Try to call the function directly"	(index > 0 and:[index <= MaxExternalPrimitiveTableSize]) ifTrue:[		addr _ externalPrimitiveTable at: index-1.		addr ~= 0 ifTrue:[^self cCode:' ((int (*) (void)) addr) ()' 							inSmalltalk:[self callExternalPrimitive: addr]].		"if we come here, then an index to the external prim was kept		on the ST side although the underlying prim table was already flushed"		^self success: false].	"Clean up session id and external primitive index"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	"Backward compatibility:		Attempt to map any old-style named primitives into the new ones.		The old ones are exclusively bound into the VM so we don't need		to check if a module is given."	addr _ 0. "Addr ~= 0 indicates we have a compat match later"	moduleLength = 0 ifTrue:[		"Search the obsolete named primitive table for a match"		index _ self findObsoleteNamedPrimitive: (self cCoerce: (functionName+4) to: 'char *') length: functionLength.		"The returned value is the index into the obsolete primitive table.		If the index is found, use the 'C-style' version of the lookup."		index < 0 ifFalse:[			addr _ self ioLoadFunction: (self cCoerce: ((obsoleteNamedPrimitiveTable at: index) at: 2) to: 'char*')						From: (self cCoerce: ((obsoleteNamedPrimitiveTable at: index) at: 1) to:'char*')]].	addr = 0 ifTrue:["Only if no compat version was found"		addr _ self ioLoadExternalFunction: functionName + 4					OfLength: functionLength 					FromModule: moduleName + 4					OfLength: moduleLength.	].	addr = 0 ifTrue:[		index _ -1. "remember we failed"	] ifFalse:[		"add the function to the external primitive table"		index _ self addToExternalPrimitiveTable: addr.		"if no space, index will be zero so we will look it up again.		although slow it makes sure we will find the prim in case		it's needed."	].	self success: index >= 0.	"Store the index (or -1 if failure) back in the literal"	self storePointer: 3 ofObject: lit withValue: (self integerObjectOf: index).	"If the function has been successfully loaded process it"	(successFlag and:[addr ~= 0])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'					inSmalltalk:[self callExternalPrimitive: addr]]		ifFalse:["Otherwise rewrite the primitive index"			self				rewriteMethodCacheSel: messageSelector				class: lkupClass				primIndex: 0].! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 2/2/2001 16:28'!addToExternalPrimitiveTable: functionAddress	"Add the given function address to the external primitive table and return the index where it's stored. This function doesn't need to be fast since it is only called when an external primitive has been looked up (which takes quite a bit of time itself). So there's nothing specifically complicated here.	Note: Return index will be one-based (ST convention)"	0 to: MaxExternalPrimitiveTableSize-1 do:[:i|		(externalPrimitiveTable at: i) = 0 ifTrue:[			externalPrimitiveTable at: i put: functionAddress.			^i+1]].	"if no space left, return zero so it'll looked up again"	^0! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 2/2/2001 16:29'!flushExternalPrimitiveTable	"Flush the external primitive table"	0 to: MaxExternalPrimitiveTableSize-1 do:[:i|		externalPrimitiveTable at: i put: 0.	].! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 2/2/2001 16:30'!flushExternalPrimitives	"Flush the references to external functions from plugin primitives.	This will force a reload of those primitives when accessed next.	Note: We must flush the method cache here so that any failed	primitives are looked up again."	| oop fmt primIdx |	oop _ self firstObject.	[oop < endOfMemory] whileTrue:[		(self isFreeObject: oop) ifFalse: [			fmt _ self formatOf: oop.			fmt >= 12 ifTrue:["This is a compiled method"				primIdx _ self primitiveIndexOf: oop.				primIdx = PrimitiveExternalCallIndex ifTrue:["It's primitiveExternalCall"					self flushExternalPrimitiveOf: oop.				].			].		].		oop _ self objectAfter: oop.	].	self flushMethodCache.	self flushObsoleteIndexedPrimitives.	self flushExternalPrimitiveTable.! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 2/2/2001 16:35'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 500.	PrimitiveExternalCallIndex _ 117. "Primitive index for #primitiveExternalCall"	GenerateBrowserPlugin _ false.	MillisecondClockMask _ 16r1FFFFFFF.	"Note: The external primitive table should actually be dynamically sized but for the sake of inferior platforms (e.g., Mac :-) who cannot allocate memory in any reasonable way, we keep it static (and cross our fingers...)"	MaxExternalPrimitiveTableSize _ 4096. "entries"! !!Interpreter class methodsFor: 'translation' stamp: 'ar 2/2/2001 16:37'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator 		var: #interpreterProxy 		type: #'struct VirtualMachine*'.	aCCodeGenerator		var: #methodCache		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator		var: #atCache		declareC: 'int atCache[', (AtCacheTotalSize + 1) printString, ']'.	aCCodeGenerator var: #localIP type: #'char*'.	aCCodeGenerator var: #localSP type: #'char*'.	aCCodeGenerator var: 'semaphoresToSignalA'		declareC: 'int semaphoresToSignalA[', (SemaphoresToSignalSize + 1) printString, ']'.	aCCodeGenerator var: 'semaphoresToSignalB'		declareC: 'int semaphoresToSignalB[', (SemaphoresToSignalSize + 1) printString, ']'.	aCCodeGenerator		var: #compilerHooks		declareC: 'int (*compilerHooks[', (CompilerHooksSize + 1) printString, '])()'.	aCCodeGenerator		var: #interpreterVersion		declareC: 'const char *interpreterVersion = "', Smalltalk version, ' [', Smalltalk lastUpdateString,']"'.	aCCodeGenerator		var: #obsoleteIndexedPrimitiveTable		declareC: 'char* obsoleteIndexedPrimitiveTable[][3] = ', self obsoleteIndexedPrimitiveTableString.	aCCodeGenerator		var: #obsoleteNamedPrimitiveTable		declareC: 'const char* obsoleteNamedPrimitiveTable[][3] = ', self obsoleteNamedPrimitiveTableString.	aCCodeGenerator		var: #externalPrimitiveTable		declareC: 'int externalPrimitiveTable[', (MaxExternalPrimitiveTableSize + 1) printString, ']'.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'ar 2/2/2001 16:31'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	atCache _ Array new: AtCacheTotalSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresUseBufferA _ true.	semaphoresToSignalA _ Array new: SemaphoresToSignalSize.	semaphoresToSignalB _ Array new: SemaphoresToSignalSize.	externalPrimitiveTable _ CArrayAccessor on: (Array new: MaxExternalPrimitiveTableSize size).	obsoleteNamedPrimitiveTable _ 		CArrayAccessor on: self class obsoleteNamedPrimitiveTable.	obsoleteIndexedPrimitiveTable _ CArrayAccessor on: 		(self class obsoleteIndexedPrimitiveTable collect:[:spec| 			CArrayAccessor on:				(spec ifNil:[Array new: 3] 					  ifNotNil:[Array with: spec first with: spec second with: nil])]).	pluginList _ #().	mappedPluginEntries _ #().	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !Interpreter initialize!