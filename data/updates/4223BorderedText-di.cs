'From Squeak3.1alpha of 5 February 2001 [latest update: #4164] on 30 July 2001 at 2:22:41 pm'!"Change Set:		BorderedTextDate:			25 July 2001Author:			Dan IngallsMakes TextMorph a subclass of RectangleMorph.Existing textMorphs will continue to display with no border and no fill, but they can henceforth, eg, through the properties control panel, be given a visible border and interior color.In addition a new parameter, margins, is included.  If not nil, this parameter causes the composition rectangle for the text to be computed as (innerBounds insetBy: margins).The wrapFlag which determines whether or not the text should be wrapped (other than by CRs) is now externally accessible, and controllable by the morph menu.The auto fit capability, that causes the bounds to be reset as a result of changes to the text, is now associated with a property, autoFitContents, that can be set from the morph menu.  This makes textMorphs much better behaved when you want a fixed border.TextMorphs can now be picked up by their borders, and they can be selected from anywhere within their border."!Transcript closeAllViews.  "Possible interaction"!RectangleMorph subclass: #TextMorph	instanceVariableNames: 'textStyle text wrapFlag paragraph editor container predecessor successor lastGesture backgroundColor margins '	classVariableNames: 'CaretForm '	poolDictionaries: ''	category: 'Morphic-Basic'!!TextMorph commentStamp: 'di 7/25/2001 09:08' prior: 0!TextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as embedded hot links, and the ability to embed submorphs in the text.Late in life, TextMorph was made a subclass of BorderedMorph to provide border and background color if desired.  In order to keep things compatible, protocols have been redirected so that color (preferably textColor) relates to the text, and backgroundColor relates to the inner fill color.Text display is clipped to the innerBounds of the rectangle, and text composition is normally performed within a rectangle which is innerBounds inset by the margins parameter.If text has been embedded in another object, one can elect to fill the owner's shape, in which case the text will be laid out in the shape of the owner's shadow image (including any submorphs other than the text).  One can also elect to have the text avoid occlusions, in which case it will avoid the bounds of any sibling morphs that appear in front of it.  It may be necessary to update bounds in order for the text runaround to notice the presence of a new occluding shape.The optional autoFitContents property enables the following feature:  if the text contents changes, then the bounds of the morph will be adjusted to fit the minimum rectangle that encloses the text (plus any margins specified).  Similarly, any attempt to change the size of the morph will be resisted if this parameter is set.  Except...If the wrapFlag parameter is true, then text will be wrapped at word boundaries based on the composition width (innerBounds insetBy: margins) width.  Thus an attempt to resize the morph in autofit mode, if it changes the width, will cause the text to be recomposed with the new width, and then the bounds will be reset to the minimum enclosing rectangle.  Similarly, if the text contents are changed with the wrapFlag set to true, word wrap will be performed based on the current compostion width, after which the bounds will be set (or not), based on the autoFitcontents property.Yet to do:Make a comprehensive control for the eyedropper, with border width and color, inner color and text color, and margin widths.!!FormCanvas methodsFor: 'drawing' stamp: 'di 7/27/2001 12:43'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ (port clippedBy: (bounds translateBy: origin)) displayScannerFor: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'di 7/12/2001 22:22'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addUpdating: #autoFitString target: self action: #autoFitOnOff.! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'di 7/12/2001 22:22'!autoFitOnOff	"Toggle between auto fit to size of code and manual resize with scrolling"	| tw |	(tw _ self findA: TwoWayScrollPane) ifNil: [^ self].	(self hasProperty: #autoFitContents)		ifTrue: [self removeProperty: #autoFitContents]		ifFalse: [self setProperty: #autoFitContents toValue: true].	tw layoutChanged! !!TextMorph methodsFor: 'initialization' stamp: 'di 6/22/2001 09:36'!defaultColor	"Return the default fill style for the receiver"	^ Color black! !!TextMorph methodsFor: 'initialization' stamp: 'di 7/27/2001 11:56'!initialize	super initialize.	borderWidth _ 0.	textStyle _ TextStyle default copy.	wrapFlag _ true.! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/12/2001 22:25'!autoFit: trueOrFalse	self isAutoFit = trueOrFalse ifTrue: [^ self].	self autoFitOnOff! !!TextMorph methodsFor: 'accessing' stamp: 'di 6/22/2001 09:33'!backgroundColor	^ backgroundColor! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/23/2001 15:30'!backgroundColor: newColor	backgroundColor _ newColor.	self changed! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/19/2001 11:08'!borderWidth: newWidth	super borderWidth: newWidth.	paragraph ifNotNil: [self composeToBounds].! !!TextMorph methodsFor: 'accessing' stamp: 'di 6/22/2001 09:51'!fillStyle	"Return the current fillStyle of the receiver."	extension ifNil: [^ backgroundColor ifNil: [Color transparent]].	^ self valueOfProperty: #fillStyle ifAbsent:		[backgroundColor ifNil: [Color transparent]].! !!TextMorph methodsFor: 'accessing' stamp: 'di 6/22/2001 09:52'!fillStyle: aFillStyle	"Set the current fillStyle of the receiver."	self setProperty: #fillStyle toValue: aFillStyle.	"Workaround for Morphs not yet converted"	backgroundColor _ aFillStyle asColor.	self changed.! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/24/2001 11:20'!hasTranslucentColor	"Overridden from BorderedMorph to test backgroundColor instead of (text) color."	backgroundColor ifNil: [^ true].	(backgroundColor isColor and: [backgroundColor isTranslucentColor]) ifTrue: [^ true].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue: [^ true].	^ false! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/12/2001 14:01'!isAutoFit	^ self valueOfProperty: #autoFitContents ifAbsent: [true]! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/20/2001 22:44'!margins: newMargins	"newMargins can be a number, point or rectangle, as allowed by, eg, insetBy:."	margins _ newMargins.	self composeToBounds! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/21/2001 10:37'!textColor	^ color! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/21/2001 10:35'!textColor: aColor	color = aColor ifTrue: [^ self].	color _ aColor.	self changed.! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/27/2001 13:10'!wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag _ aBoolean.	self composeToBounds! !!TextMorph methodsFor: 'drawing' stamp: 'di 7/12/2001 10:45'!debugDrawLineRectsOn: aCanvas	"Shows where text line rectangles are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 7/27/2001 13:14'!drawOn: aCanvas	| fauxBounds |	self setDefaultContentsIfNil.	super drawOn: aCanvas.  "Border and background if any"	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: ["Hack here:  The canvas expects bounds to carry the location				of the text, but we also need to communicate clipping."				fauxBounds _ bounds topLeft corner: self innerBounds bottomRight.				aCanvas paragraph: self paragraph bounds: fauxBounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 7/21/2001 09:44'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self innerBounds containsPoint: evt cursorPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/24/2001 11:18'!areasRemainingToFill: aRectangle	"Overridden from BorderedMorph to test backgroundColor instead of (text) color."	(backgroundColor isNil or: [backgroundColor isTranslucent])		ifTrue: [^ Array with: aRectangle].	self wantsRoundedCorners	ifTrue: [(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])				ifTrue: [^ aRectangle areasOutside: (self innerBounds intersect: self boundsWithinCorners)]				ifFalse: [^ aRectangle areasOutside: self boundsWithinCorners]]	ifFalse: [(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])				ifTrue: [^ aRectangle areasOutside: self innerBounds]				ifFalse: [^ aRectangle areasOutside: self bounds]]! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/19/2001 10:57'!container	"Return the container for composing this text.  There are four cases:	1.  container is specified as, eg, an arbitrary shape,	2.  container is specified as the bound rectangle, because		this morph is linked to others,	3.  container is nil, and wrap is true -- grow downward as necessary,	4.  container is nil, and wrap is false -- grow in 2D as nexessary."	container ifNil:		[successor ifNotNil: [^ self compositionRectangle].		wrapFlag ifTrue: [^ self compositionRectangle withHeight: 9999999].		^ self compositionRectangle topLeft extent: 9999999@9999999].	^ container! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/12/2001 22:15'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].  "Not in my bounds"	container ifNil: [^ true].  "In bounds of simple text"	self startingIndex > text size ifTrue:		["make null text frame visible"		^ super containsPoint: aPoint].	"In complex text (non-rect container), test by line bounds"	^ self paragraph containsPoint: aPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/27/2001 12:58'!extent: aPoint 	| newExtent |	self isAutoFit		ifTrue: [wrapFlag ifFalse: [^ self].  "full autofit can't change"				newExtent _ aPoint truncated max: self minimumExtent.				newExtent x = self extent x ifTrue: [^ self].  "No change of wrap width"				self releaseParagraph.  "invalidate the paragraph cache"				super extent: newExtent.				self fit  "since the width has changed..."]		ifFalse: [super extent: (aPoint truncated max: self minimumExtent).				wrapFlag ifFalse: [^ self].  "no effect on composition"				self composeToBounds]! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/20/2001 22:51'!minimumExtent	| minExt |	textStyle ifNil: [^ 9@16].	borderWidth ifNil: [^ 9@16].	minExt _ (9@(textStyle lineGrid+2)) + (borderWidth*2).	margins ifNil: [^ minExt].	^ ((0@0 extent: minExt) expandBy: margins) extent! !!TextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:18'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'text color...' action: #changeTextColor.	aCustomMenu addUpdating: #autoFitString target: self action: #autoFitOnOff.	aCustomMenu addUpdating: #wrapString target: self action: #wrapOnOff.	aCustomMenu add: 'text margins...' action: #changeMargins:.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	(Preferences valueOfFlag: #noviceMode) not & 		(Preferences valueOfFlag: #simpleMenus) not ifTrue: [			aCustomMenu add: 'code pane menu...' action: #yellowButtonActivity.			aCustomMenu add: 'code pane shift menu....' action: #shiftedYellowButtonActivity].	outer _ self owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:19'!autoFitOnOff	self setProperty: #autoFitContents toValue: self isAutoFit not.	self isAutoFit ifTrue: [self fit]! !!TextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:19'!autoFitString	"Answer the string to put in a menu that will invite the user to switch autoFit mode"	^ ((self hasProperty: #autoFitContents)		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text auto fit'! !!TextMorph methodsFor: 'menu' stamp: 'di 7/20/2001 22:48'!changeMargins: evt	| handle origin aHand oldMargin newMargin |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	oldMargin _ margins.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newMargin _ (newPoint - origin max: 0@0) // 5.			self margins: newMargin]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'margin change';					undoTarget: self selector: #margins: argument: oldMargin;					redoTarget: self selector: #margins: argument: newMargin)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor down and to the rightto increase margin inset.Click when done.' hand: evt hand.	handle startStepping! !!TextMorph methodsFor: 'menu' stamp: 'di 7/21/2001 10:36'!changeTextColor	"Change the color of the receiver -- triggered, e.g. from a menu"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #textColor:;		originalColor: self textColor;		putUpFor: self near: self fullBoundsInWorld! !!TextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:20'!wrapOnOff	self wrapFlag: wrapFlag not! !!TextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:19'!wrapString	"Answer the string to put in a menu that will invite the user to switch autoFit mode"	^ (wrapFlag		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text wrap to bounds'! !!TextMorph methodsFor: 'linked frames' stamp: 'di 7/28/2001 10:34'!addPredecessor: evt	| newMorph |	newMorph _ self copy predecessor: predecessor successor: self.	newMorph extent: self width @ 100.	predecessor ifNotNil: [predecessor setSuccessor: newMorph].	self setPredecessor: newMorph.	predecessor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'linked frames' stamp: 'di 7/28/2001 10:35'!addSuccessor: evt	| newMorph |	newMorph _ self copy predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'private' stamp: 'di 6/22/2001 09:10'!clippingRectangle	^ self innerBounds! !!TextMorph methodsFor: 'private' stamp: 'di 7/20/2001 22:18'!compositionRectangle	| compRect |	compRect _ self innerBounds.	margins ifNotNil: [compRect _ compRect insetBy: margins].	compRect width < 9 ifTrue: [compRect _ compRect withWidth: 9].	compRect height < 16 ifTrue: [compRect _ compRect withHeight: 16].	^ compRect! !!TextMorph methodsFor: 'private' stamp: 'di 7/20/2001 22:32'!fit	"Adjust my bounds to fit the text.  Should be a no-op if autoFit is not specified.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para cBounds lastOfLines heightOfLast |	self isAutoFit ifTrue:		[newExtent _ (self paragraph extent max: 9@textStyle lineGrid) + (0@2).		newExtent _ newExtent + (2*borderWidth).		margins ifNotNil: [newExtent _ ((0@0 extent: newExtent) expandBy: margins) extent].		newExtent ~= bounds extent ifTrue:			[(container == nil and: [successor == nil]) ifTrue:				[para _ paragraph.  "Save para (layoutChanged smashes it)"				super extent: newExtent.				paragraph _ para]].		container notNil & successor isNil ifTrue:			[cBounds _ container bounds truncated.			"23 sept 2000 - try to allow vertical growth"			lastOfLines _ self paragraph lines last.			heightOfLast _ lastOfLines bottom - lastOfLines top.			(lastOfLines last < text size and: 					[lastOfLines bottom + heightOfLast >= self bottom]) ifTrue:				[container releaseCachedState.				cBounds _ cBounds origin corner: cBounds corner + (0@heightOfLast)].			self privateBounds: cBounds]].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: self position.	successor ifNotNil:		[successor predecessorChanged].	self changed. "Too conservative: only paragraph composition					should cause invalidation."! !!TextMorph methodsFor: 'private' stamp: 'di 7/28/2001 10:33'!predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	predecessor _ pred.	successor _ succ.! !!TextMorph methodsFor: 'private' stamp: 'di 7/28/2001 10:34'!text: t textStyle: s wrap: wrap color: c	predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	text _ t.	textStyle _ s.	wrapFlag _ wrap.	color _ c.	paragraph _ editor _ container _ nil.	self predecessor: pred successor: succ! !!TextMorph methodsFor: 'object fileIn' stamp: 'di 7/30/2001 14:19'!convertToCurrentVersion: varDict refStream: smartRefStrm		borderWidth ifNil:		[borderWidth _ 0.		self removeProperty: #fillStyle].	^ super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TextMorph methodsFor: 'copying' stamp: 'di 7/28/2001 10:24'!veryDeepInner: deepCopier 	"Copy all of my instance variables. Some need to be not copied at all, but shared.	Warning!!!! Every instance variable defined in this class must be handled.	We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	textStyle _ textStyle veryDeepCopyWith: deepCopier.	text _ text veryDeepCopyWith: deepCopier.	wrapFlag _ wrapFlag veryDeepCopyWith: deepCopier.	paragraph _ paragraph veryDeepCopyWith: deepCopier.	editor _ editor veryDeepCopyWith: deepCopier.	container _ container veryDeepCopyWith: deepCopier.	predecessor _ predecessor.	successor _ successor.	lastGesture _ lastGesture veryDeepCopyWith: deepCopier.	backgroundColor _ backgroundColor veryDeepCopyWith: deepCopier.	margins _ margins veryDeepCopyWith: deepCopier.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'di 7/28/2001 10:35'!makeSuccessorMorph	| newMorph |	self fixAllLeftOffsets.	newMorph _ self copy predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	^newMorph! !TextMorph removeSelector: #drawBoundsOn:!ScriptEditorMorph removeSelector: #toggleAutoFit!"Postscript:Conversion for minimal compatibility."TextMorph allSubInstancesDo:	[:t | t instVarNamed: 'borderWidth' put: 0.	t removeProperty: #fillStyle].!