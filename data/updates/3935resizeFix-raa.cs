'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 5 February 2001 update 3932] on 19 April 2001 at 11:44:50 am'!"Change Set:		resizeFixDate:			19 April 2001Author:			Bob ArningWhen resizing SystemWindows with fast drag ON, filckering was observed after the mouse was released but before the mouse had moved again. This was due to both Sensor- and Event-style calls in the same interaction. Since the Sensor calls were flushing the event queue, the Event calls were getting the wrong answer"!!NewHandleMorph methodsFor: 'all' stamp: 'RAA 4/19/2001 11:36'!sensorMode	"If our client is still addressing the Sensor directly, we need to do so as well"	^self valueOfProperty: #sensorMode ifAbsent: [false].! !!NewHandleMorph methodsFor: 'all' stamp: 'RAA 4/19/2001 11:36'!sensorMode: aBoolean	"If our client is still addressing the Sensor directly, we need to do so as well"	self setProperty: #sensorMode toValue: aBoolean.! !!NewHandleMorph methodsFor: 'all' stamp: 'RAA 4/19/2001 11:37'!step	| eventSource |	eventSource _ self sensorMode ifTrue: [		Sensor	] ifFalse: [		hand lastEvent	].	eventSource anyButtonPressed		ifTrue: [waitingForClickInside _ false.				self position: eventSource cursorPoint - (self extent // 2).				pointBlock value: self center]		ifFalse: [waitingForClickInside					ifTrue: [(self containsPoint: eventSource cursorPoint)								ifFalse: ["mouse wandered out before clicked"										^ self delete]]					ifFalse: [lastPointBlock value: self center.							^ self delete]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'RAA 4/19/2001 11:38'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) ifTrue: [^self].	(side == #top and: [growingPane top = self panelRect top]) ifTrue: [^self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	resizer _ NewHandleMorph new		sensorMode: self fastFramingOn;		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ growingPane bounds				  newRectButtonPressedDo:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'RAA 4/19/2001 11:38'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new		sensorMode: self fastFramingOn;		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds				withSideOrCorner: ptName				setToPoint: localPt				minExtent: self minimumExtent.			self fastFramingOn 			ifTrue:				[self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorphInLayer: resizer.	resizer startStepping! !