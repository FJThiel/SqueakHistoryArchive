'From Squeak3.0 of 4 February 2001 [latest update: #3552] on 22 April 2002 at 12:47:41 pm'!!ArrayedCollection commentStamp: 'raok 4/22/2002 12:03' prior: 0!I am an abstract collection of elements with a fixed range of integers (from 1 to n>=0) as external keys.!!Set commentStamp: 'raok 4/22/2002 12:27' prior: 0!I represent a set of objects without duplicates.  I can hold anything that responds to#hash and #=, except for nil.  My instances will automatically grow, if necessary,Note that I rely on #=, not #==.  If you want a set using #==, use IdentitySet.Instance structure:  array	An array whose non-nil elements are the elements of the set,		and whose nil elements are empty slots.  There is always at least one nil.		In fact I try to keep my "load" at 75% or less so that hashing will work well.  tally	The number of elements in the set.  The array size is always greater than this.The core operation is #findElementOrNil:, which either finds the position where anobject is stored in array, if it is present, or finds a suitable position holding nil, ifits argument is not present in array,!!Dictionary commentStamp: 'raok 4/22/2002 12:14' prior: 0!I represent a set of elements that can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to =. The external name is referred to as the key.  I inherit many operations from Set.!!IdentityDictionary commentStamp: 'raok 4/22/2002 12:30' prior: 0!I represent a set of associations all of whose #key parts are distinct according to#== (identity test).  Considered another way, I represent a collection of valuesaccessed by external names, two external names being considered the same if andonly if they are #==.Apart from that, I'm pretty much the same as Dictionary.!!IdentitySet commentStamp: 'raok 4/22/2002 12:38' prior: 0!I represent a set of objects, where two objects are regarded as the same if and onlyif the are #== (identical).  I can hold any objects that respond meaningfully to#hash and #==.Except for using #== instead of #=, I'm pretty much the same as Set.If you combine plain Sets and IdentitySets using #union:, #intersection,or #difference:, sometimes it will work, and sometimes it will be very queer.For example, (s1 intersection: s2) may equal s1 even those (s1 includes: x) isfalse for every element of s2.  (Because the latter asks s1 if the element isthere, using ==, but the former asks s2 if the element is there, using =.)So even if you think you know what you are doing, use asIdentitySet orasSet to bring the sets to a common form before combining them.!!WeakValueAssociation commentStamp: 'raok 4/22/2002 12:46' prior: 0!I am a lookup key (acting like an association but) holding only weakly on my value.!!Dictionary methodsFor: 'private' stamp: 'raok 4/22/2002 12:09'!copy	"Must copy the associations, or later store will affect both theoriginal and the copy"	^ self shallowCopy withArray:		(array collect: [:assoc |			assoc ifNil: [nil]				ifNotNil: [Association key: assoc keyvalue: assoc value]])! !