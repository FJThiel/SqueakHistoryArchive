'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6643] on 12 April 2005 at 5:03:25 pm'!"Change Set:		MoreStringFixesDate:			11 April 2005Author:			Andreas RaabFixes a few more issues:* Make String>>new: work properly without having to override it.* Make sure all Strinngs hash equal if equal.* Reclassify Strings under Collections-Text and move FilePath over to System-Files.* Move some more methods up to String.* Replace Character>>isUnicode with a method which is equally obscure but has a somewhat less confusing name ;-)* Fix some String implementations for accessors."!Object subclass: #FilePath	instanceVariableNames: 'squeakPathName vmPathName converter'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!ArrayedCollection subclass: #String	instanceVariableNames: ''	classVariableNames: 'AsciiOrder CaseInsensitiveOrder CaseSensitiveOrder CSLineEnders CSNonSeparators CSSeparators HtmlEntities LowercasingTable Tokenish UppercasingTable'	poolDictionaries: ''	category: 'Collections-Text'!!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and MultiString (that represents an array of  32-bit MultiCharacters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!]style[(55 382 188 13 2 18 72 24 2 44)f1,f2,f1,f1LString match:;,f1,f1LString contractTo:;,f1,f1LSequenceableCollection ,;,f1,f1LSequenceableCollection copyReplaceAll:with:;!!ByteString commentStamp: '<historical>' prior: 0!This class represents the array of 8 bit wide characters.!String variableWordSubclass: #MultiString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!Character methodsFor: 'testing' stamp: 'ar 4/12/2005 14:09'!isTraditionalDomestic	"Yoshiki's note about #isUnicode says:		[This method] is for the backward compatibility when we had domestic		traditional encodings for CJK languages.  To support loading the		projects in traditional domestic encodings (From Nihongo4), and load		some changesets.  Once we decided to get rid of classes like JISX0208		from the EncodedCharSet table, the need for isUnicode will not be		necessary.	I (Andreas) decided to change the name from isUnicode to #isTraditionalDomestic	since I found isUnicode to be horribly confusing (how could the character *not*	be Unicode after all?). But still, we should remove this method in due time."	^ ((EncodedCharSet charsetAt: self leadingChar) isKindOf: LanguageEnvironment class) not! !!CompoundTextConverter methodsFor: 'conversion' stamp: 'ar 4/12/2005 14:10'!nextPut: aCharacter toStream: aStream	| ascii leadingChar class |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aCharacter isTraditionalDomestic ifFalse: [		class _ (EncodedCharSet charsetAt: aCharacter leadingChar) traditionalCharsetClass.		ascii _ (class charFromUnicode: aCharacter asUnicode) charCode.		leadingChar _ class leadingChar.	] ifTrue: [		ascii _ aCharacter charCode.		leadingChar _ aCharacter leadingChar.	].	self nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForLeadingChar: leadingChar.! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ar 4/12/2005 14:10'!nextPut: aCharacter toStream: aStream 	| value leadingChar nonUnicodeChar value1 value2 |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	value _ aCharacter charCode.	leadingChar _ aCharacter leadingChar.	(leadingChar = 0 and: [value < 128]) ifTrue: [		aStream basicNextPut: (Character value: value).		^ aStream	].	(128 <= value and: [value < 256]) ifTrue: [^ aStream].	aCharacter isTraditionalDomestic ifFalse: [		nonUnicodeChar _ self nonUnicodeClass charFromUnicode: value.	] ifTrue: [		nonUnicodeChar _(Character value: value)	].	nonUnicodeChar ifNotNil: [		value _ nonUnicodeChar charCode.		value1 _ value // 94 + 161.		value2 _ value \\ 94 + 161.		aStream basicNextPut: (Character value: value1).		aStream basicNextPut: (Character value: value2).		^ aStream	]! !!ShiftJISTextConverter methodsFor: 'conversion' stamp: 'ar 4/12/2005 14:10'!nextPut: aCharacter toStream: aStream 	| value leadingChar aChar |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aCharacter isTraditionalDomestic ifTrue: [			aChar _ aCharacter.		value _ aCharacter charCode.	] ifFalse: [		value _ aCharacter charCode.		(16rFF61 <= value and: [value <= 16rFF9F]) ifTrue: [			aStream basicNextPut: (self sjisKatakanaFor: value).			^ aStream		].		aChar _ JISX0208 charFromUnicode: value.		aChar ifNil: [^ aStream].		value _ aChar charCode.	].	leadingChar _ aChar leadingChar.	leadingChar = 0 ifTrue: [		aStream basicNextPut: (Character value: value).		^ aStream.	].	leadingChar == self leadingChar ifTrue: [		| upper lower | 		upper _ value // 94 + 33.		lower _ value \\ 94 + 33.		upper \\ 2 == 1 ifTrue: [			upper _ upper + 1 / 2 + 112.			lower _ lower + 31		] ifFalse: [			upper _ upper / 2 + 112.			lower _ lower + 125		].		upper >= 160 ifTrue: [upper _ upper + 64].		lower >= 127 ifTrue: [lower _ lower + 1].		aStream basicNextPut: (Character value: upper).		aStream basicNextPut: (Character value: lower).		^ aStream	].! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index put: value	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteSize	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter startingAt: start	(aCharacter isCharacter) ifFalse: [^ 0].	^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter isCharacter) ifFalse: [ ^ aBlock value ].	ans _ self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 22:39'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and MultiString."	^ self class stringHash: self initialHash: ByteString hash! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 13:55'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string _ FileDirectory checkName: self fixErrors: true.	checkedString _ (FilePath pathName: string) asVmPathName.	^ (FilePath pathName: checkedString isEncoded: true) asSqueakPathName.! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 23:50'!asMultiString 	self isMultiString		ifTrue:[^self]		ifFalse:[^MultiString from: self]! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 14:02'!convertFromSuperSwikiServerString	^self! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 14:03'!convertToSuperSwikiServerString	^self! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 14:01'!convertToSystemString	| readStream writeStream converter |	readStream _ self readStream.	writeStream _ String new writeStream.	converter _ LanguageEnvironment defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 16:32'!subStrings: separators 	"Answer an array containing the substrings in the receiver separated 	by the elements of separators."	| char result sourceStream subString |	#Collectn.	"Changed 2000/04/08 For ANSI <readableString> protocol."	(separators isString or:[separators allSatisfy: [:element | element isKindOf: Character]])		ifFalse: [^ self error: 'separators must be Characters.'].	sourceStream := ReadStream on: self.	result := OrderedCollection new.	subString := String new.	[sourceStream atEnd]		whileFalse: 			[char := sourceStream next.			(separators includes: char)				ifTrue: [subString notEmpty						ifTrue: 							[result add: subString copy.							subString := String new]]				ifFalse: [subString := subString , (String with: char)]].	subString notEmpty ifTrue: [result add: subString copy].	^ result asArray! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 23:25'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	1 to: self size do: [:pos |		(self at: pos) asInteger >= 256 ifTrue: [^ false].	].	^ true.! !!MultiString methodsFor: 'testing' stamp: 'ar 4/12/2005 14:10'!isUnicodeStringWithCJK	self do: [:c |		(c isTraditionalDomestic not and: [Unicode isUnifiedKanji: c charCode]) ifTrue: [			^ true		].	].	^ false.! !!String class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 23:26'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	self == String 		ifTrue:[^ByteString new: sizeRequested]		ifFalse:[^self basicNew: sizeRequested].! !MultiString class removeSelector: #new:!ByteString class removeSelector: #new:!MultiString removeSelector: #asFileName!MultiString removeSelector: #asMultiString!MultiString removeSelector: #asMultiSymbol!MultiString removeSelector: #convertFromSuperSwikiServerString!MultiString removeSelector: #convertToSystemString!MultiString removeSelector: #isOctetString!MultiString removeSelector: #isUnicodeString!ByteString removeSelector: #convertToSuperSwikiServerString!ByteString removeSelector: #convertToSystemString!String removeSelector: #at:put:!String removeSelector: #isUnicodeString!Character removeSelector: #isUnicode!