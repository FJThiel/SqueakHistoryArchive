'From Squeak2.7 of 5 January 2000 [latest update: #1762] on 7 January 2000 at 4:34:22 pm'!"Change Set:		chgListAdditiosn-swDate:			7 January 2000Author:			Scott WallaceAdditions to the changelist browser:*  select conflicts with any changeset -- selects methods that occur in *any* change set in the system, rather than just looking at the current change set.*  the 'select conflicts' button now selects conflicts with any change-set, but you can still query conflicts with the *current* change-set from the menu.*  browse current versions of selections -- opens a message-list browser on the in-memory versions of the selected methods.  This makes it easy to look at the methods that would be changed if you filed in the code on disk that the changelist is looking at.*  balloon help is added for all the buttons.*  Lex Spoon's support code for 'select methods for this class' is finally incorporated, allowing that feature finally to work.*  Lex's implementation of the 'select such that...' feature is also incorporated (not for amateurs!!) but access to it in the changelist-browser's menu is only available in commented-out form."!!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 12:43'!buttonRowForChangeList	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightBlue; borderWidth: 1; borderColor: Color blue darker.	aRow addTransparentSpacerOfSize: (5@0).	self changeListButtonSpecs do:		[:triplet |			aButton _ aButton fullCopy.			aButton actionSelector: triplet second.			aButton label: triplet first.			aRow addMorphBack: aButton.			aButton setBalloonText: triplet third.			aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.		^ aRow! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 12:42'!changeListButtonSpecs	^#(		('select all' 			selectAll				'select all entries')		('deselect all'		deselectAll			'deselect all entries')		('select conflicts'	selectAllConflicts	'select all methods that occur in any change set')		('file in selections' 	fileInSelections		'file in all selected entries')		)! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 15:43'!optionalButtonsView	| view bHeight vWidth offset specs previousView button wid buttonCount |	view _ View new model: self.	bHeight _ self optionalButtonHeight.	vWidth _ 180.	view window: (0@0 extent: vWidth@bHeight).	offset _ 0.	specs _ self changeListButtonSpecs.	buttonCount _ specs size + 1.	previousView _ nil.	wid _ vWidth // buttonCount.	specs do: [:triplet |		button _ PluggableButtonView on: self getState: nil action: triplet second.		button			label: triplet first asParagraph;			insideColor: Color lightBlue;			borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		triplet last = specs first last			ifTrue: [view addSubView: button]			ifFalse: [view addSubView: button toRightOf: previousView].		previousView _ button].	button _ PluggableButtonView on: self getState: #showDiffs action: #toggleDiff.	button		label: 'toggle diff' asParagraph;		insideColor: Color lightBlue;		window: (offset@0 extent: (vWidth - offset)@bHeight).	view addSubView: button toRightOf: previousView.	^view! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 12:59'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	|  aClass aChange aList |	aList _ OrderedCollection new.	Cursor read showWhile: 	[1 to: changeList size do:		[:i | (listSelections at: i) ifTrue:			 [aChange _ changeList at: i.			(aChange type = #method				and: [(aClass _ aChange methodClass) notNil				and: [aClass includesSelector: aChange methodSelector]])					ifTrue:						[aList add: aClass name, ' ', aChange methodSelector]]]].	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	MessageSet openMessageList: aList name: 'Current versions of selected methods in ', file localName! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 13:25'!changeListMenu: aMenu^ aMenu labels:'fileIn selectionsfileOut selections...compare to currenttoggle diffingselect conflicts with any changesetselect conflicts with current changesetselect conflicts with...select unchanged methodsselect methods for this classselect alldeselect allbrowse current versions of selectionsremove doItsremove older versionsremove selections'	lines: #(2 4 6 9 11 12)	selections: #(fileInSelections fileOutSelectionscompareToCurrentVersion toggleDiffing selectAllConflicts  selectConflicts selectConflictsWith selectUnchangedMethods selectMethodsForThisClass  selectAll  deselectAll browseCurrentVersionsOfSelectionsremoveDoIts removeOlderMethodVersions removeSelections)"select such that...   selectSuchThat"! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 12/27/1999 12:24'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | aChange _ changeList at: i.		listSelections at: i put:			(aChange type = #method			and: [(aClass _ aChange methodClass) notNil			and: [(ChangeSorter allChangeSetsWithClass: aClass selector: aChange methodSelector) size > 0]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 15:04'!selectSuchThat	"query the user for a selection criterio.  By Lex Spoon.  NB: the UI for invoking this from a changelist browser is currently commented out; to reenfranchise it, you'll need to mild editing to ChangeList method #changeListMenu:"	| code block |	code _ FillInTheBlank request: 'selection criteria for a change named aChangeRecord?\For instance, ''aChangeRecord category = ''System-Network''''' withCRs.	code isEmpty ifTrue: [^ self ].	block _ Compiler evaluate: '[:aChangeRecord | ', code, ']'.	self selectSuchThat: block! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 5/12/1999 07:56'!selectSuchThat: aBlock	"select all changes for which block returns true"	listSelections _ changeList collect: [ :change | aBlock value: change ].	self changed: #allSelections! !!ChangeList methodsFor: 'accessing' stamp: 'ls 5/12/1999 07:55'!currentChange	"return the current change being viewed, or nil if none"	listIndex = 0 ifTrue: [ ^nil ].	^changeList at: listIndex! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 1/7/2000 15:43'!open: aChangeList name: aString multiSelect: multiSelect	"Create a standard system view for the messageSet, whose label is aString.	The listView may be either single or multiple selection type"	| topView aBrowserCodeView aListView underPane pHeight |	World ifNotNil: [^ self openAsMorph: aChangeList name: aString multiSelect: multiSelect].	topView _ (StandardSystemView new) model: aChangeList.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	Preferences optionalButtons		ifTrue:			[underPane _ aChangeList optionalButtonsView.			underPane isNil				ifTrue: [pHeight _ 100]				ifFalse:					[topView addSubView: underPane.					pHeight _ 100 - aChangeList optionalButtonHeight]]		ifFalse:			[underPane _ nil.			pHeight _ 100].	aListView _ (multiSelect					ifTrue: [PluggableListViewOfMany]					ifFalse: [PluggableListView])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])		keystroke: #messageListKey:from:.	aListView window: (0 @ 0 extent: 180 @ pHeight).	underPane isNil		ifTrue: [topView addSubView: aListView]		ifFalse: [topView addSubView: aListView below: underPane].	aBrowserCodeView _ PluggableTextView on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView controller: ReadOnlyTextController new.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 1/7/2000 14:59'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window boundary  |	window _ (SystemWindow labelled: labelString) model: aChangeList.	Preferences optionalButtons		ifFalse:			[boundary _ 0]		ifTrue:			[boundary _ 0.08.			window addMorph: aChangeList buttonRowForChangeList frame: (0 @ 0 corner: 1 @ boundary)].	window addMorph: ((multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])			keystroke: nil)		frame: (0@boundary corner: 1@0.4).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@1).	^ window openInWorld! !ChangeList removeSelector: #buttonRowForChangeListView!ChangeList removeSelector: #changeListButtonPairs!ChangeList removeSelector: #browseAllConflicts!ChangeList removeSelector: #optionalButtons!