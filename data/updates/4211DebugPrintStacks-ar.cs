'From Squeak3.1alpha of 28 February 2001 [latest update: #4207] on 18 July 2001 at 4:36:25 pm'!"Change Set:		DebugPrintStacks-arDate:			18 July 2001Author:			Andreas RaabAdds a debugging facility to the VM allowing to print all the call stacks of both, the active and all waiting processes."!!CCodeGenerator methodsFor: 'inlining' stamp: 'ar 7/18/2001 16:31'!pruneUnreachableMethods	"Remove any methods that are not reachable. Retain methods needed by the BitBlt operation table, primitives, plug-ins, or interpreter support code." 	| retain |	"Build a set of selectors for methods that should be output even though they have no apparent callers. Some of these are stored in tables for indirect lookup, some are called by the C support code or by primitives."	retain _ BitBltSimulation opTable asSet.	#(checkedLongAt: fullDisplayUpdate interpret printCallStack printAllStacks	   readImageFromFile:HeapSize:StartingAt: success:		"Windows needs the following two for startup and debug"	   readableFormat: getCurrentBytecode		"Jitter reuses all of these"	   allocateChunk: characterForAscii:	   findClassOfMethod:forReceiver: findSelectorOfMethod:forReceiver:	   firstAccessibleObject loadInitialContext noteAsRoot:headerLoc:	   nullCompilerHook	   primitiveFloatAdd primitiveFloatDivide primitiveFloatMultiply	   primitiveFloatSubtract primitiveFlushExternalPrimitives	   setCompilerInitialized: splObj:)			do: [:sel | retain add: sel].	InterpreterProxy organization categories do: [:cat |		((cat ~= 'initialize') and: [cat ~= 'private']) ifTrue: [			retain addAll: (InterpreterProxy organization listAtCategoryNamed: cat)]].	"Remove all the unreachable methods that aren't retained for the reasons above."	self unreachableMethods do: [:sel |		(retain includes: sel) ifFalse: [			methods removeKey: sel ifAbsent: []]].! !!Interpreter methodsFor: 'debug support' stamp: 'ar 7/18/2001 16:34'!printAllStacks	"Print all the stacks of all running processes, including those that are currently suspended."	| oop proc ctx |	proc _ self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self printNameOfClass: (self fetchClassOf: proc) count: 5.	self cr.	self printCallStackOf: activeContext. "first the active context"	oop _ self firstObject.	[oop < endOfMemory] whileTrue:[		(self fetchClassOf: oop) == self classSemaphore ifTrue:[			self cr.			proc _ self fetchPointer: FirstLinkIndex ofObject: oop.			[proc == self nilObject] whileFalse:[				self printNameOfClass: (self fetchClassOf: proc) count: 5.				self cr.				ctx _ self fetchPointer: SuspendedContextIndex ofObject: proc.				ctx == self nilObject ifFalse:[self printCallStackOf: ctx].				proc _ self fetchPointer: NextLinkIndex ofObject: proc].		].		oop _ self objectAfter: oop.	].! !!Interpreter methodsFor: 'debug support' stamp: 'ar 7/18/2001 16:23'!printCallStack	^self printCallStackOf: activeContext! !!Interpreter methodsFor: 'debug support' stamp: 'ar 7/18/2001 16:31'!printCallStackOf: aContext	| ctxt home methClass methodSel |	self inline: false.	ctxt _ aContext.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self printNum: ctxt.		self print: ' '.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methClass count: 5.		self print: '>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].! !