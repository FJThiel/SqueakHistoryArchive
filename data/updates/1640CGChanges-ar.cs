'From Squeak2.6 of 13 October 1999 [latest update: #1637] on 24 November 1999 at 1:12:27 am'!"Change Set:		CGChanges-arDate:			19 November 1999Author:			Andreas RaabContains two modifications in the C code generator:1) Allows Smalltalk loops with the structure	[stmt.	...	cond] whileTrue/whileFalse.to be translated into	do {		stmt.		...	} while(cond);2) Allows case dispatches with arguments, e.g., #dispatchOn:in:with: and #dispatchOn:in:with:with:."!Object subclass: #TMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export '	classVariableNames: 'CaseStatements '	poolDictionaries: ''	category: 'Squeak-Translation to C'!!CCodeGenerator methodsFor: 'C code generator' stamp: 'ar 11/19/1999 14:44'!cLiteralFor: anObject	"Return a string representing the C literal value for the given object."	(anObject isKindOf: Integer) ifTrue: [		(anObject < 16r7FFFFFFF)			ifTrue: [^ anObject printString]			ifFalse: [^ anObject printString , 'U']].	(anObject isKindOf: String) ifTrue: [^ '"', anObject, '"' ].	(anObject isKindOf: Float) ifTrue: [^ anObject printString ].	anObject == nil ifTrue: [^ 'null' ].	anObject == true ifTrue: [^ '1' ].			"ikp"	anObject == false ifTrue: [^ '0' ].			"ikp"	(anObject isKindOf: Character) ifTrue:[^anObject asString printString]. "ar"	self error:								"ikp"		'Warning: A Smalltalk literal could not be translated into a C constant: ', anObject printString.	^'"XXX UNTRANSLATABLE CONSTANT XXX"'! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/25/1999 01:43'!generateDoWhileFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while(!!('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: '))'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/25/1999 01:43'!generateDoWhileTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/27/1999 22:12'!generateWhileFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(msgNode receiver statements size > 1) ifTrue:[		"[stmt1. stmt2. condition] whileFalse."		^self generateDoWhileFalse: msgNode on: aStream indent: level].	aStream nextPutAll: 'while (!!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/27/1999 22:12'!generateWhileTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	(msgNode receiver statements size > 1) ifTrue:[		"[stmt1. stmt2. condition] whileTrue."		^self generateDoWhileTrue: msgNode on: aStream indent: level].	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 10/24/1999 19:33'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#whileTrue 		#generateDoWhileTrue:on:indent:	#whileFalse		#generateDoWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCode:inSmalltalk:	#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	#asFloat				#generateAsFloat:on:indent:	#asInteger			#generateAsInteger:on:indent:	#anyMask:			#generateBitAnd:on:indent:	#raisedTo:			#generateRaisedTo:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!TCaseStmtNode methodsFor: 'as yet unclassified' stamp: 'ar 11/18/1999 20:08'!setExpression: aNode selectors: selectorList arguments: anArray	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression _ aNode.	selfNode _ TVariableNode new setName: 'self'.	firsts _ OrderedCollection new: 400.	lasts _ OrderedCollection new: 400.	cases _ OrderedCollection new: 400.	lastSel _ selectorList first.	firstInRun _ 0.	1 to: selectorList size do: [ :i |		sel _ selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: anArray.			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel _ sel.			firstInRun _ i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: anArray.	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !!TMethod methodsFor: 'transformations' stamp: 'ar 11/19/1999 14:40'!buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size >= 2) and:	 [aSendNode args second isConstant and:	 [aSendNode args second value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args second value		arguments: (aSendNode args copyFrom: 3 to: aSendNode args size)! !!TMethod methodsFor: 'transformations' stamp: 'ar 11/18/1999 20:09'!prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts _ node statements.			1 to: stmts size do: [ :i |				stmt _ stmts at: i.				(stmt isSend and: [CaseStatements includes: stmt selector]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].! !!TMethod methodsFor: 'inlining' stamp: 'ar 10/27/1999 22:15'!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists _ OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				"Allow inlining if it is a [...] whileTrue/whileFalse.				This is identified by having more than one statement in the 				receiver block in which case the C code wouldn't work anyways"				node receiver statements size = 1					ifTrue:[stmtLists remove: node receiver ifAbsent: []].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists! !!TMethod class methodsFor: 'class initialization' stamp: 'ar 11/18/1999 20:06'!initialize	"TMethod initialize"		CaseStatements _ IdentitySet new: 10.	CaseStatements addAll: #(dispatchOn:in: dispatchOn:in:with: dispatchOn:in:with:with:).! !TCaseStmtNode removeSelector: #setExpression:selectors:!TMethod initialize!