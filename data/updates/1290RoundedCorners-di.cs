'From Squeak 2.4c of May 10, 1999 on 1 July 1999 at 4:16:44 pm'!"Change Set:		RoundedCornersDate:			26 June 1999Author:			Dan IngallsA slightly dirty implementation of rounded window corners.  See the comment in CornerRounder.  Controlled by a new preference, #roundedWindowCorners."!Object subclass: #CornerRounder	instanceVariableNames: 'cornerMasks cornerOverlays underBits '	classVariableNames: 'CR0 CR1 CR2 '	poolDictionaries: ''	category: 'Graphics-Display Objects'!!CornerRounder commentStamp: 'di 7/1/1999 14:44' prior: 0!This class is a quick hack to support rounded corners in morphic.Rather than produce rounded rectangles, it tweaks the display of corners.Rather than work for any radius, it only supports a radius of 6.Rather than work for any border width, it only supports widths 0, 1 and 2.The corners, while apparently transparent, still behave opaquely to mouse clicks.Worse than this, the approach relies on the ability to extract underlying bits from the canvas prior to display.  This ran afoul of top-down display, it seems, in SystemWindow spawnReframeHandle: (qv).  It will also make a postscript printer very unhappy.But, hey, it's cute.!!CornerRounder reorganize!('all' masterMask:masterOverlay: saveBitsUnderCornersOf:on: tweakCornersOf:on:borderWidth:)!!CornerRounder methodsFor: 'all' stamp: 'di 6/24/1999 09:35'!masterMask: maskForm masterOverlay: overlayForm	cornerMasks _ #(none left pi right) collect:		[:dir | (maskForm rotateBy: dir centerAt: 0@0) offset: 0@0].	cornerOverlays _ #(none left pi right) collect:		[:dir | (overlayForm rotateBy: dir centerAt: 0@0) offset: 0@0].! !!CornerRounder methodsFor: 'all' stamp: 'di 7/1/1999 15:52'!saveBitsUnderCornersOf: aMorph on: aCanvas	| offset corner mask form |	underBits _ (1 to: 4) collect:		[:i | 		mask _ cornerMasks at: i.		corner _ aMorph bounds corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		form _ aCanvas form copy: (corner + offset + aCanvas origin extent: mask extent).		form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0)].! !!CornerRounder methodsFor: 'all' stamp: 'di 7/1/1999 15:51'!tweakCornersOf: aMorph on: aCanvas borderWidth: w	| offset corner saveBits c fourColors c14 c23 insetColor mask |	w > 0 ifTrue:		[c _ aMorph borderColor.		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c14 _ aMorph color lighter. c23 _ aMorph color darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[insetColor _ aMorph owner colorForInsets.			c14 _ insetColor lighter. c23 _ insetColor darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	(1 to: 4) do:		[:i | 		corner _ aMorph bounds corners at: i.		saveBits _ underBits at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@saveBits height negated].		i = 3 ifTrue: [offset _ saveBits extent negated].		i = 4 ifTrue: [offset _ saveBits width negated@0].		"Mask out corner area (painting saveBits won't clear if transparent)."		mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas image: mask at: corner + offset sourceRect: mask boundingBox rule: Form and.		"Paint back corner bits."		aCanvas image: saveBits at: corner + offset.		w > 0 ifTrue:			["Paint over with border if any"			aCanvas stencil: (cornerOverlays at: i) at: corner + offset					color: (fourColors at: i)]].! !!CornerRounder class reorganize!('all' initialize roundCornersOf:on:displayBlock:borderWidth:)!!CornerRounder class methodsFor: 'all' stamp: 'di 6/28/1999 15:51'!initialize  "CornerRounder initialize"	CR0 _ CR1 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r110e26 2r1000e26 2r10000e26 2r10000e26 2r100000e26)				offset: 0@0).	CR2 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11100e26 2r11000e26 2r111000e26)				offset: 0@0).! !!CornerRounder class methodsFor: 'all' stamp: 'di 6/30/1999 09:17'!roundCornersOf: aMorph on: aCanvas displayBlock: displayBlock borderWidth: w	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder saveBitsUnderCornersOf: aMorph on: aCanvas.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas borderWidth: w! !!Form methodsFor: 'scaling, rotation' stamp: 'di 7/1/1999 15:57'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot |	direction == #none ifTrue: [^ self].	newForm _ self class extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!MenuMorph methodsFor: 'drawing' stamp: 'di 6/28/1999 16:01'!fullDrawOn: aCanvas	Preferences roundedWindowCorners		ifTrue: [CornerRounder roundCornersOf: self on: aCanvas					displayBlock: [super fullDrawOn: aCanvas]					borderWidth: borderWidth]		ifFalse: [super fullDrawOn: aCanvas]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 7/1/1999 16:16'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue:		[World ifNotNil: [World fullRepaintNeeded]].! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'di 6/28/1999 15:46'!borderColor	^ Color black! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'di 6/29/1999 10:44'!fullDrawOn: aCanvas	(Preferences roundedWindowCorners and: [(owner isKindOf: SystemWindow) not])		ifTrue: [CornerRounder roundCornersOf: self on: aCanvas					displayBlock: [super fullDrawOn: aCanvas]					borderWidth: 1]		ifFalse: [super fullDrawOn: aCanvas]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 7/1/1999 15:56'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ self bounds newRectFrom:					[:f | f extent > (100@80)						ifTrue: [f withSideOrCorner: ptName									setToPoint: (self pointFromWorld: Sensor cursorPoint)]						ifFalse: [f]].				self bounds: newBounds]			ifFalse:				[newBounds extent > (100@80) ifTrue: [self bounds: newBounds].				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'drawing' stamp: 'di 6/28/1999 16:02'!fullDrawOn: aCanvas	Preferences roundedWindowCorners		ifTrue: [CornerRounder roundCornersOf: self on: aCanvas					displayBlock: [super fullDrawOn: aCanvas]					borderWidth: 2]		ifFalse: [super fullDrawOn: aCanvas]! !CornerRounder removeSelector: #tweakCornersOf:on:!CornerRounder initialize!CornerRounder class removeSelector: #roundCornersOf:on:displayBlock:!CornerRounder class removeSelector: #roundCornersOf:On:displayBlock:borderWidth:borderColor:!CornerRounder class removeSelector: #default!CornerRounder class removeSelector: #roundCornersOf:on:displayBlock:borderWidth:borderColor:!ProjectViewMorph removeSelector: #borderWidth!"Postscript:Install the preference for rounded corners."Preferences disable: #roundedWindowCorners.!