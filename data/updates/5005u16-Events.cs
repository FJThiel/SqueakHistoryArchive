'From Squeak3.1alpha of 7 March 2001 [latest update: #4398] on 2 October 2001 at 7:48:08 am'!"Change Set:		EventsDate:			11 February 2002Author:			Rob Withers et al.Published to 3.3a as 4756Events.csThe NuBlue events code. Finally..."!Array variableSubclass: #ActionSequence	instanceVariableNames: ''	classVariableNames: ''	module: #(Squeak Language Core Objects)!Object subclass: #EventManager	instanceVariableNames: 'actionMap '	classVariableNames: 'ActionMaps '	module: #(Squeak Language Core Objects)!EventManager class	instanceVariableNames: ''!Object subclass: #MessageSend	instanceVariableNames: 'receiver selector arguments '	classVariableNames: ''	module: #(Squeak Language Core Objects)!!MessageSend commentStamp: '<historical>' prior: 0!Instances of MessageSend encapsulate message sends to objects. Arguments can be either predefined or supplied when the message send is performed. MessageSends are used to implement the #when:send:to: event system.Use #value to perform a message send with its predefined arguments and #valueWithArguments: if additonal arguments have to supplied.Structure: receiver		Object -- object receiving the message send selector		Symbol -- message selector arguments		Array -- bound arguments!MessageSend class	instanceVariableNames: ''!!Object methodsFor: 'converting' stamp: 'reThink 2/18/2001 15:13'!asActionSequence	^ActionSequence with: self! !!Object methodsFor: 'dependents access' stamp: 'reThink 2/18/2001 17:06'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self releaseActionMap! !!Object methodsFor: 'evaluating' stamp: 'reThink 3/12/2001 18:14'!value	^self! !!Object methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 15:23'!valueWithArguments: aSequenceOfArguments	^self! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 14:48'!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."    ^self actionMap        at: anEventSelector asSymbol        ifAbsent: [nil]! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 14:54'!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."    ^self actionMap        at: anEventSelector asSymbol        ifAbsent: [^anExceptionBlock value]! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 14:43'!actionMap	^EventManager actionMapFor: self! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 17:01'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^ActionSequence new])            asActionSequence! !!Object methodsFor: 'events-accessing' stamp: 'SqR 6/28/2001 13:19'!actionsDo: aBlock	self actionMap do: aBlock! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 14:38'!createActionMap	^IdentityDictionary new! !!Object methodsFor: 'events-accessing' stamp: 'SqR 2/19/2001 14:04'!hasActionForEvent: anEventSelector    "Answer true if there is an action associated with anEventSelector"    ^(self actionForEvent: anEventSelector) notNil! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/18/2001 15:29'!setActionSequence: actionSequenceforEvent: anEventSelector    | action |    action := actionSequence asMinimalRepresentation.    action == nil        ifTrue:            [self removeActionsForEvent: anEventSelector]        ifFalse:            [self updateableActionMap                at: anEventSelector asSymbol                put: action]! !!Object methodsFor: 'events-accessing' stamp: 'reThink 2/25/2001 08:50'!updateableActionMap	^EventManager updateableActionMapFor: self! !!Object methodsFor: 'events-registering' stamp: 'reThink 2/18/2001 15:04'!when: anEventSelector evaluate: anAction 	| actions |	actions := self actionSequenceForEvent: anEventSelector.	(actions includes: anAction)		ifTrue: [^ self].	self 		setActionSequence: (actions copyWith: anAction)		forEvent: anEventSelector! !!Object methodsFor: 'events-registering' stamp: 'reThink 2/18/2001 15:14'!when: anEventSelectorsend: aMessageSelectorto: anObject    self        when: anEventSelector        evaluate: (MessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: 'events-registering' stamp: 'reThink 2/18/2001 17:05'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArg    self        when: anEventSelector        evaluate: (MessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: 'events-registering' stamp: 'reThink 2/18/2001 17:04'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArray    self        when: anEventSelector        evaluate: (MessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:33'!releaseActionMap	EventManager releaseActionMapFor: self! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:31'!removeAction: anActionforEvent: anEventSelector    self        removeActionsSatisfying: [:action | action = anAction]        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:33'!removeActionsForEvent: anEventSelector    | map |    map := self actionMap.    map removeKey: anEventSelector asSymbol ifAbsent: [].    map isEmpty        ifTrue: [self releaseActionMap]! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:31'!removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: [:anAction | aOneArgBlock value: anAction])        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'SqR 2/19/2001 14:09'!removeActionsWithReceiver: anObject	self actionMap keysDo:		[:eachEventSelector |			self   				removeActionsSatisfying: [:anAction | anAction receiver == anObject]				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'reThink 2/18/2001 15:36'!removeActionsWithReceiver: anObjectforEvent: anEventSelector    self        removeActionsSatisfying:            [:anAction |            anAction receiver == anObject]        forEvent: anEventSelector! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:22'!triggerEvent: anEventSelector	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self actionForEvent: anEventSelector) value! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 17:09'!triggerEvent: anEventSelectorifNotHandled: anExceptionBlock	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value]) value! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 14:59'!triggerEvent: anEventSelectorwith: anObject    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 14:59'!triggerEvent: anEventSelectorwith: anObjectifNotHandled: anExceptionBlock    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)		ifNotHandled: anExceptionBlock! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:21'!triggerEvent: anEventSelectorwithArguments: anArgumentList    ^(self actionForEvent: anEventSelector)        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'reThink 2/18/2001 15:21'!triggerEvent: anEventSelectorwithArguments: anArgumentListifNotHandled: anExceptionBlock    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value])        valueWithArguments: anArgumentList! !!ActionSequence methodsFor: 'converting' stamp: 'reThink 2/18/2001 15:12'!asActionSequence	^self! !!ActionSequence methodsFor: 'converting' stamp: 'reThink 2/18/2001 15:28'!asMinimalRepresentation	self size = 0		ifTrue: [^nil].	self size = 1		ifTrue: [^self first].	^self! !!ActionSequence methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 17:51'!value    "Answer the result of evaluating the elements of the receiver."    | answer |    self do:        [:each |        answer := each value].    ^answer! !!ActionSequence methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 17:52'!valueWithArguments: anArray    | answer |    self do:        [:each |        answer := each valueWithArguments: anArray].    ^answer! !!ActionSequence methodsFor: 'printing' stamp: 'SqR 07/28/2001 18:25'!printOn: aStream	self size < 2 ifTrue: [^super printOn: aStream].	aStream nextPutAll: '#('.	self		do: [:each | each printOn: aStream]		separatedBy: [aStream cr].	aStream nextPut: $)! !!BlockContext methodsFor: 'evaluating'!valueWithArguments: anArray 	"Primitive. Evaluate the block represented by the receiver. The argument 	is an Array whose elements are the arguments for the block. Fail if the 	length of the Array is not the same as the the number of arguments that 	the block was expecting. Fail if the block is already being executed. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 82>	self numArgs = anArray size		ifTrue: [self error: 'Attempt to evaluate a block that is already being evaluated.']		ifFalse: [self error: 'This block requires ' , self numArgs printString , ' arguments.']! !!EventManager methodsFor: 'copying' stamp: 'reThink 3/3/2001 10:22'!copy	| answer |	answer := super copy.	answer release.	^answer! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:37'!actionMap    ^actionMap == nil        ifTrue: [self createActionMap]        ifFalse: [actionMap]! !!EventManager methodsFor: 'accessing' stamp: 'reThink 3/3/2001 10:07'!changedEventSelector	^#changed:! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:39'!releaseActionMap    actionMap := nil! !!EventManager methodsFor: 'accessing' stamp: 'reThink 3/3/2001 10:07'!updateEventSelector	^#update:! !!EventManager methodsFor: 'accessing' stamp: 'reThink 2/18/2001 15:38'!updateableActionMap    actionMap == nil        ifTrue: [actionMap := self createActionMap].    ^actionMap! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!addDependent: anObject	"Make the given object one of the receiver's dependents."	self		when: self changedEventSelector		send: self updateEventSelector		to: anObject.	^anObject! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!breakDependents	"Remove all of the receiver's dependents."	self removeActionsForEvent: self changedEventSelector! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:18'!dependents	^(self actionSequenceForEvent: self changedEventSelector) asSet		collect:			[:each | each receiver]! !!EventManager methodsFor: 'dependents access' stamp: 'reThink 3/3/2001 10:07'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	self 		removeActionsWithReceiver: anObject		forEvent: self changedEventSelector.	^ anObject! !!EventManager methodsFor: 'updating' stamp: 'reThink 3/3/2001 10:20'!changed: aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self 		triggerEvent: self changedEventSelector		with: aParameter! !!EventManager class methodsFor: 'accessing' stamp: 'reThink 2/18/2001 14:42'!actionMapFor: anObject    ^self actionMaps        at: anObject        ifAbsent: [self createActionMap]! !!EventManager class methodsFor: 'accessing' stamp: 'rww 10/2/2001 07:20'!actionMaps	ActionMaps == nil		ifTrue: [ActionMaps := WeakIdentityKeyDictionary new].	^ActionMaps! !!EventManager class methodsFor: 'accessing' stamp: 'reThink 2/25/2001 08:52'!updateableActionMapFor: anObject    ^self actionMaps        at: anObject        ifAbsentPut: [self createActionMap]! !!EventManager class methodsFor: 'releasing' stamp: 'reThink 2/18/2001 15:34'!releaseActionMapFor: anObject	self actionMaps		removeKey: anObject		ifAbsent: []! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!arguments	^ arguments! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:40'!arguments: anArray	arguments _ anArray! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!receiver	^ receiver! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!receiver: anObject	receiver _ anObject! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!selector	^ selector! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!selector: aSymbol	selector _ aSymbol! !!MessageSend methodsFor: 'comparing' stamp: 'sma 2/29/2000 20:43'!= anObject	^ anObject species == self species 		and: [receiver == anObject receiver		and: [selector == anObject selector		and: [arguments = anObject arguments]]]! !!MessageSend methodsFor: 'comparing' stamp: 'sma 3/11/2000 10:35'!hash	^ receiver hash bitXor: selector hash! !!MessageSend methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 15:20'!value	^ receiver 		perform: selector 		withArguments: (self collectArguments: arguments)! !!MessageSend methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 16:51'!valueWithArguments: anArray	^ receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!MessageSend methodsFor: 'printing' stamp: 'SqR 7/14/2001 11:36'!printOn: aStream        aStream                nextPutAll: self class name;                nextPut: $(.        selector printOn: aStream.        aStream nextPutAll: ' -> '.        receiver printOn: aStream.        aStream nextPut: $)! !!MessageSend methodsFor: 'private' stamp: 'reThink 2/18/2001 17:33'!collectArguments: anArgArray	"Private"    | staticArgs |    staticArgs := self arguments.    ^(anArgArray size = staticArgs size)        ifTrue: [anArgArray]        ifFalse:            [(staticArgs isEmpty                ifTrue: [ staticArgs := Array new: selector numArgs]                ifFalse: [staticArgs copy] )                    replaceFrom: 1                    to: (anArgArray size min: staticArgs size)                    with: anArgArray                    startingAt: 1]! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:44'!receiver: anObject selector: aSymbol	^ self receiver: anObject selector: aSymbol arguments: #()! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:44'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:39'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray! !