'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:21 am'!"Change Set:		Pluggable-Primitives-arDate:			11 October 1998Author:			Andreas RaabThis change set provides the framework for pluggable primitives by:* extending Parser to handle named primitives* adding primitiveExternalCall in the Interpreter* Changing TMethod to handle the #export: directive* Changing TSendNode for plugin code generation* Adding class PluggableCodeGenerator* Adding the following classes for simulating plugins	InterpreterPlugin	InterpreterProxy	CObjectAccessor	CArrayAccessor* Adding methods in ObjectMemory/Interpreter for plugin support."!Object subclass: #CObjectAccessor	instanceVariableNames: 'object offset '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!CObjectAccessor subclass: #CArrayAccessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!Object subclass: #InterpreterPlugin	instanceVariableNames: 'interpreterProxy '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!Object subclass: #InterpreterProxy	instanceVariableNames: 'successFlag remapBuffer stack method argumentCount '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!CCodeGenerator subclass: #PluggableCodeGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!Object subclass: #TMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!Object methodsFor: 'translation support' stamp: 'ar 9/18/1998 23:27'!export: aBoolean	"For translation only; noop when running in Smalltalk."! !!CCodeGenerator methodsFor: 'utilities' stamp: 'ar 10/7/1998 17:53'!isGeneratingPluginCode	^false! !!CObjectAccessor commentStamp: '<historical>' prior: 0!I am used to simulate the indexed access to any object during plugin simulation.!!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object instVarAt: index + offset + 1! !!CObjectAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object instVarAt: index + offset + 1 put: value! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+ increment	^self clone += increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:57'!+= increment	offset _ offset + increment! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!- decrement	^self clone -= decrement! !!CObjectAccessor methodsFor: 'pointer arithmetic' stamp: 'ar 10/9/1998 21:58'!-= decrement	offset _ offset - decrement! !!CObjectAccessor methodsFor: 'printing' stamp: 'ar 9/16/1998 21:38'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:' on: ';		print: object.! !!CObjectAccessor methodsFor: 'private' stamp: 'ar 10/9/1998 21:56'!setObject: anObject	object _ anObject.	offset _ 0.! !!CArrayAccessor commentStamp: '<historical>' prior: 0!I am used to simulate the indexed access to arrays during plugin simulation.!!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index	^object at: index + offset + 1! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/9/1998 21:56'!at: index put: value	^object at: index + offset + 1 put: value! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index	| idx |	idx _ (offset + index) // 4 + 1.	"Note: This is a special hack for BitBlt."	(idx = (object basicSize + 1)) ifTrue:[^0].	^object basicAt: idx! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 10/10/1998 16:26'!longAt: index put: value	^object basicAt: (offset + index) // 4 + 1 put: value! !!CObjectAccessor class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 21:36'!on: anObject	^self new setObject: anObject! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ar 10/11/1998 00:19'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 10/11/1998 00:19'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterPlugin methodsFor: 'initialize' stamp: 'ar 10/11/1998 02:06'!setInterpreter: anInterpreter	| ok |	self export: true.	self var: #anInterpreter declareC: 'struct VirtualMachine *anInterpreter'.	interpreterProxy _ anInterpreter.	"Note: 	The following is coded so that it can be run from Squeak			where the return value is ignored."	ok _ self cCode: 'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'.	ok == false ifTrue:[^false].	ok _ self cCode: 'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'.	^ok! !!InterpreterPlugin class methodsFor: 'class initialization' stamp: 'ar 9/16/1998 20:26'!initialize	"Nothing to do ..."! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 9/16/1998 20:27'!declareCVarsIn: aCCodeGenerator	"Note: This method must be implemented by all subclasses to declare variables"	aCCodeGenerator var: 'interpreterProxy'		declareC: 'struct VirtualMachine *interpreterProxy'.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName all: classes doInlining: inlineFlag	"Time millisecondsToRun: [		InterpreterPlugin translate:'all.c' all:{FloatArrayPlugin. FFTPlugin} doInlining: true.		Smalltalk beep]"	| cg theClass |	cg _ PluggableCodeGenerator new initialize.	classes do:[:cls|		theClass _ cls.		theClass initialize.		[theClass == InterpreterPlugin] whileFalse:[			cg addClass: theClass.			theClass declareCVarsIn: cg.			theClass _ theClass superclass]].	(classes includes: InterpreterPlugin) ifFalse:[		cg addClass: InterpreterPlugin.		InterpreterPlugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 10/7/1998 18:45'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ PluggableCodeGenerator new initialize.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 9/11/1998 18:03'!translateDoInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translateDoInlining: true.		Smalltalk beep]"	^self translate: (self moduleName,',c') doInlining: inlineFlag! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^''! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'ar 9/30/1998 23:12'!simulatorClass	"For running from Smalltalk - return a class that can be used to simulate the receiver.	By default every plugin can simulate itself."	^self! !!InterpreterPlugin class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:45'!doPrimitive: primitiveName	| proxy plugin |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin _ self simulatorClass new.	plugin setInterpreter: proxy.	plugin perform: primitiveName asSymbol.	^proxy stackValue: 0! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 9/16/1998 01:35'!initialize	successFlag _ true.	remapBuffer _ OrderedCollection new.	stack _ OrderedCollection new.! !!InterpreterProxy methodsFor: 'initialize' stamp: 'ar 10/3/1998 18:50'!loadStackFrom: aContext	self push: aContext receiver.	method _ aContext method.	argumentCount _ method numArgs.	1 to: argumentCount do:[:i| self push: (aContext at: i) ].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems	1 to: nItems do:[:i| stack removeLast].! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:41'!pop: nItems thenPush: oop	self pop: nItems.	self push: oop.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 01:42'!push: object	stack addLast: object! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushBool: trueOrFalse	(trueOrFalse == true or:[trueOrFalse == false]) ifFalse:[self error:'Not a Boolean'].	self push: trueOrFalse! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:16'!pushFloat: f	self var: #f declareC: 'double f'.	f class == Float ifFalse:[^self error:'Not a Float'].	self push: f.! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 10/10/1998 21:20'!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/27/1998 15:22'!stackFloatValue: offset	| oop |	self returnTypeC: 'double'.	oop _ self stackValue: offset.	(self isFloatObject: oop) ifFalse: [self primitiveFail. ^0.0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackIntegerValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifFalse: [self primitiveFail. ^0].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 22:07'!stackObjectValue: offset	| oop |	oop _ self stackValue: offset.	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^oop! !!InterpreterProxy methodsFor: 'stack access' stamp: 'ar 9/16/1998 11:47'!stackValue: offset	^stack at: stack size - offset.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!argumentCountOf: methodPointer	^methodPointer numArgs! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/11/1998 03:01'!arrayValueOf: oop	self returnTypeC: 'void *'.	self success: (self isWordsOrBytes: oop).	^CArrayAccessor on: oop.! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:23'!byteSizeOf: oop	"Return the size of the receiver in bytes"	^oop class isBytes		ifTrue:[(self slotSizeOf: oop)]		ifFalse:[(self slotSizeOf: oop) * 4]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:22'!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:07'!fetchClassOf: oop	^oop class! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:21'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:19'!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchPointer: index ofObject: oop	^oop instVarAt: index+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:04'!fetchWord: fieldIndex ofObject: oop	^oop instVarAt: fieldIndex+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/18/1998 20:26'!firstFixedField: oop	self returnTypeC:'void *'.	^CObjectAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 16:22'!firstIndexableField: oop	self returnTypeC:'void *'.	^CArrayAccessor on: oop! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:38'!literal: offset ofMethod: methodPointer	^methodPointer literals at: offset+1! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:40'!literalCountOf: methodPointer	^methodPointer numLiterals! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodArgumentCount	^argumentCount! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:43'!methodPrimitiveIndex	^method primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:39'!primitiveIndexOf: methodPointer	^methodPointer primitive! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 19:03'!sizeOfSTArrayFromCPrimitive: cPtr	"Note: Only called by translated primitive code."	self var: #cPtr declareC: 'void *cPtr'.	^self shouldNotImplement! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	^(oop basicSize) + (oop class instSize)! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index	^array at: index! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 9/16/1998 01:53'!stObject: array at: index put: value	^array at: index put: value! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/7/1998 18:26'!stSizeOf: oop	"Return the number of indexable fields in the receiver"	^oop basicSize! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:25'!storeInteger: index ofObject: oop withValue: integer	(self isIntegerValue: integer) 		ifTrue:[^self storeWord: index ofObject: oop withValue: integer]		ifFalse:[^self primitiveFail]! !!InterpreterProxy methodsFor: 'object access' stamp: 'ar 10/10/1998 21:25'!storePointer: index ofObject: oop withValue: valuePointer	^oop instVarAt: index+1 put: valuePointer! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:00'!is: oop KindOf: aString	"InterpreterProxy new is: 42 KindOf: 'Number'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isKindOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/19/1998 14:01'!is: oop MemberOf: aString	"InterpreterProxy new is: 42 MemberOf:'SmallInteger'"	| theClass |	self var: #aString declareC:'char *aString'.	theClass _ Smalltalk at: aString asSymbol ifAbsent:[nil].	^theClass isNil		ifTrue:[false]		ifFalse:[^oop isMemberOf: theClass]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isBytes: oop	^oop class isBytes! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:44'!isFloatObject: oop	^oop class == Float! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 21:45'!isIndexable: oop	^oop isVariable! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:12'!isIntegerObject: objectPointer	^objectPointer class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:13'!isIntegerValue: intValue	^intValue class == SmallInteger! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:04'!isPointers: oop	^oop class isPointers! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:16'!isWeak: oop	^oop class isWeak! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 10/9/1998 22:19'!isWords: oop	^oop class isPointers not and:[oop class isBytes not]! !!InterpreterProxy methodsFor: 'testing' stamp: 'ar 9/16/1998 01:05'!isWordsOrBytes: oop	^(self isBytes: oop) or:[self isWords: oop]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 21:27'!booleanValueOf: obj	obj == true ifTrue:[^true].	obj == false ifTrue:[^false].	self primitiveFail.	^nil! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/4/1998 15:47'!checkedIntegerValueOf: intOop	(self isIntegerObject: intOop)		ifTrue:[^self integerValueOf: intOop]		ifFalse:[self primitiveFail. ^0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:08'!floatObjectOf: aFloat	self var: #aFloat declareC: 'double aFloat'.	aFloat class == Float ifFalse:[self error:'Not a float object'].	^aFloat! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:09'!floatValueOf: oop	self returnTypeC:'double'.	oop class == Float		ifTrue:[^oop]		ifFalse:[self primitiveFail. ^0.0].! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:13'!integerObjectOf: value	value class == SmallInteger ifFalse:[self error:'Not a SmallInteger object'].	^value! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:10'!integerValueOf: oop	oop class == SmallInteger ifFalse:[self error:'Not a SmallInteger'].	^oop! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:11'!positive32BitIntegerFor: integerValue	integerValue isInteger ifFalse:[self error:'Not an Integer object'].	^integerValue > 0		ifTrue:[integerValue]		ifFalse:[ (1 bitShift: 32) + integerValue]! !!InterpreterProxy methodsFor: 'converting' stamp: 'ar 10/10/1998 16:12'!positive32BitValueOf: oop	oop isInteger ifFalse:[self error:'Not an integer object'].	oop < 0 		ifTrue:[self primitiveFail. ^0]		ifFalse:[^oop]! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:43'!characterTable	^Character characterTable! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 21:42'!displayObject	^Display! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!falseObject	^false! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:40'!nilObject	^nil! !!InterpreterProxy methodsFor: 'special objects' stamp: 'ar 9/16/1998 20:41'!trueObject	^true! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:42'!classArray	^Array! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classBitmap	^Bitmap! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classByteArray	^ByteArray! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classCharacter	^Character! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classFloat	^Float! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classLargePositiveInteger	^LargePositiveInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classPoint	^Point! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classSemaphore	^Semaphore! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 21:43'!classSmallInteger	^SmallInteger! !!InterpreterProxy methodsFor: 'special classes' stamp: 'ar 9/16/1998 20:43'!classString	^String! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/18/1998 20:11'!clone: oop	^oop clone! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:11'!instantiateClass: classPointer indexableSize: size	^size = 0 		ifTrue:[classPointer basicNew]		ifFalse:[classPointer basicNew: size]! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 10/10/1998 16:14'!makePointwithxValue: xValue yValue: yValue	(xValue class == SmallInteger and:[yValue class == SmallInteger]) 		ifFalse:[self error:'Not SmallInteger objects'].	^xValue@yValue! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!popRemappableOop	^remapBuffer removeLast! !!InterpreterProxy methodsFor: 'instance creation' stamp: 'ar 9/16/1998 01:14'!pushRemappableOop: oop	remapBuffer addLast: oop! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!become: array1 with: array2	array1 elementsExchangeIdentityWith: array2! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!failed	^successFlag not! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!fullDisplayUpdate	Display display! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!fullGC	Smalltalk garbageCollect.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!incrementalGC	Smalltalk garbageCollectMost.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!primitiveFail	(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt].	successFlag _ false.! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:52'!showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	aForm == Display ifTrue:[		Display forceToScreen: (Rectangle left: l right: r top: t bottom: b)].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!signalSemaphoreWithIndex: semaIndex	((Smalltalk specialObjectsArray at: 39) at: semaIndex) signal! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/19/1998 13:30'!success: aBoolean	successFlag not ifTrue:[^self].	successFlag _ successFlag and:[aBoolean].	successFlag not ifTrue:[		(self confirm:'A primitive is failing -- Stop simulation?') ifTrue:[self halt]].! !!InterpreterProxy methodsFor: 'other' stamp: 'ar 9/16/1998 20:51'!superclassOf: classPointer	^classPointer superclass! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!byteAt: accessor	^accessor byteAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:12'!byteAt: accessor put: value	^accessor byteAt: 0 put: value! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor	^accessor longAt: 0! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 9/18/1998 21:11'!longAt: accessor put: value	^accessor longAt: 0 put: value! !!InterpreterProxy class methodsFor: 'instance creation' stamp: 'ar 9/16/1998 00:23'!new	^super new initialize! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 18:45'!generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass _ InterpreterProxy.	cg _ PluggableCodeGenerator new initialize.	cg addClass: proxyClass.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList _ catList collect:[:cat| cat -> (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"! !!InterpreterProxy class methodsFor: 'private' stamp: 'ar 10/7/1998 19:04'!validateProxyImplementation: anInterpreter	"InterpreterProxy validateProxyImplementation: Interpreter"	"InterpreterProxy validateProxyImplementation: DynamicInterpreter"	| proxyClass catList |	proxyClass _ InterpreterProxy.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList do:[:category|		(proxyClass organization listAtCategoryNamed: category) do:[:selector|			(anInterpreter canUnderstand: selector) 				ifFalse:[self notify: selector, ' is not implemented in ', anInterpreter name]]].! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!characterTable	^self splObj: CharacterTable! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classArray	^self splObj: ClassArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classBitmap	^self splObj: ClassBitmap! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:06'!classByteArray	^self splObj: ClassByteArray! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classCharacter	^self splObj: ClassCharacter! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classFloat	^self splObj: ClassFloat! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classLargePositiveInteger	^self splObj: ClassLargePositiveInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classPoint	^self splObj: ClassPoint! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSemaphore	^self splObj: ClassSemaphore! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:11'!classSmallInteger	^self splObj: ClassInteger! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!classString	^self splObj: ClassString! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!displayObject	^self splObj: TheDisplay! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!falseObject	^falseObj! !!ObjectMemory methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:16'!trueObject	^trueObj! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ar 10/7/1998 18:41'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: self stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'ar 10/7/1998 18:42'!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ar 10/9/1998 11:21'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger)		* The function address (Integer)	"	| thisSession lit functionAddress addr moduleName functionName moduleLength functionLength session |	self var: #thisSession declareC:'static int thisSession = 0'.	"Make sure the session is initialized"	thisSession = 0 ifTrue:[		thisSession _ self ioMicroMSecs bitAnd: 16r1FFFFFFF.		thisSession = 0 ifTrue:[thisSession _ 1]].	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0.	"@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function address and session id in case it has been loaded before"	addr _ self positive32BitValueOf: (self fetchPointer: 3 ofObject: lit).	session _ self fetchInteger: 2 ofObject: lit.	"If so, call the function directly"	(successFlag and:[session = thisSession and:[addr ~= 0]])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'].	"Clean up session id and function address"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	addr _ self ioLoadExternalFunction: functionName + 4				OfLength: functionLength 				FromModule: moduleName + 4				OfLength: moduleLength.	self success: addr ~= 0.	"If the function has been successfully loaded process it"	successFlag ifTrue:[		"Store the session ID"		self storeInteger: 2 ofObject: lit withValue: thisSession.		"Store the address back in the literal"		self pushRemappableOop: lit.		functionAddress _ self positive32BitIntegerFor: addr.		lit _ self popRemappableOop.		self storePointer: 3 ofObject: lit withValue: functionAddress.		(successFlag and:[addr ~= 0])			ifTrue:[self cCode:' ((int (*) (void)) addr) ()'].	].! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!byteSizeOf: oop	| slots |	(self isIntegerObject: oop) ifTrue:[^0].	slots _ self slotSizeOf: oop.	(self isBytes: oop)		ifTrue:[^slots]		ifFalse:[^slots * 4]! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| srcName name length |	self var: #className declareC:'char *className'.	self var: #srcName declareC:'char *srcName'.	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	length _ self stSizeOf: name.	srcName _ self cCoerce: (self arrayValueOf: name) to:'char *'.	0 to: length-1 do:[:i|		(srcName at: i) = (className at: i) ifFalse:[^false].	].	"Check if className really ends at this point"	^(className at: length) = 0! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!firstFixedField: oop	self returnTypeC:'void *'.	^self cCoerce: oop+4 to:'void *'.! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!firstIndexableField: oop	| hdr fmt totalLength fixedFields |	self returnTypeC:'void *'.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	fmt < 8 ifTrue:["32 bit field objects"		^ self cCoerce: oop+4+ (fixedFields << 2) to:'void *'.	] ifFalse:["Byte objects"		^ self cCoerce: oop+4+fixedFields to:'void *'.	]! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!floatObjectOf: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	^newFloatObj! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!is: oop KindOf: className	"Support for external primitives."	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	[oopClass == nilObj] whileFalse:[		(self classNameOf: oopClass Is: className) ifTrue:[^true].		oopClass _ self superclassOf: oopClass].	^false! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!is: oop MemberOf: className	"Support for external primitives"	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	^(self classNameOf: oopClass Is: className)! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!isFloatObject: oop	^(self fetchClassOf: oop) == self classFloat! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!isIndexable: oop	^(self formatOf: oop) >= 2! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!methodArgumentCount	^argumentCount! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:40'!methodPrimitiveIndex	^primitiveIndex! !!DynamicInterpreter methodsFor: 'plugin support' stamp: 'ar 10/10/1998 21:25'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	(self isIntegerObject: oop) ifTrue:[^0].	^self lengthOf: oop! !!Interpreter methodsFor: 'contexts' stamp: 'ar 10/7/1998 18:16'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 10/7/1998 18:14'!showDisplayBits: aForm Left: affectedRectL Top: affectedRectT Right: affectedRectR Bottom: affectedRectB	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d |	deferDisplayUpdates ifTrue: [^ nil].	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 10/9/1998 11:21'!primitiveExternalCall	"Call an external primitive. The external primitive methods contain as first literal an array consisting of:		* The module name (String | Symbol)		* The function name (String | Symbol)		* The session ID (SmallInteger)		* The function address (Integer)	"	| thisSession lit functionAddress addr moduleName functionName moduleLength functionLength session |	self var: #thisSession declareC:'static int thisSession = 0'.	"Make sure the session is initialized"	thisSession = 0 ifTrue:[		thisSession _ self ioMicroMSecs bitAnd: 16r1FFFFFFF.		thisSession = 0 ifTrue:[thisSession _ 1]].	"Fetch the first literal of the method"	self success: (self literalCountOf: newMethod) > 0.	"@@: Could this be omitted for speed?!!"	successFlag ifFalse:[^nil].	lit _ self literal: 0 ofMethod: newMethod.	"Check if it's an array of length 4"	self success: ((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4]).	successFlag ifFalse:[^nil].	"Look at the function address and session id in case it has been loaded before"	addr _ self positive32BitValueOf: (self fetchPointer: 3 ofObject: lit).	session _ self fetchInteger: 2 ofObject: lit.	"If so, call the function directly"	(successFlag and:[session = thisSession and:[addr ~= 0]])		ifTrue:[^self cCode:' ((int (*) (void)) addr) ()'].	"Clean up session id and function address"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.	"The function has not been loaded yet. 	Fetch module and function name."	moduleName _ self fetchPointer: 0 ofObject: lit.	moduleName = nilObj ifTrue:[		moduleLength _ 0.	] ifFalse:[		self success: (self isBytes: moduleName).		moduleLength _ self lengthOf: moduleName.	].	functionName _ self fetchPointer: 1 ofObject: lit.	self success: (self isBytes: functionName).	functionLength _ self lengthOf: functionName.	successFlag ifFalse:[^nil].	addr _ self ioLoadExternalFunction: functionName + 4				OfLength: functionLength 				FromModule: moduleName + 4				OfLength: moduleLength.	self success: addr ~= 0.	"If the function has been successfully loaded process it"	successFlag ifTrue:[		"Store the session ID"		self storeInteger: 2 ofObject: lit withValue: thisSession.		"Store the address back in the literal"		self pushRemappableOop: lit.		functionAddress _ self positive32BitIntegerFor: addr.		lit _ self popRemappableOop.		self storePointer: 3 ofObject: lit withValue: functionAddress.		(successFlag and:[addr ~= 0])			ifTrue:[self cCode:' ((int (*) (void)) addr) ()'].	].! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:34'!byteSizeOf: oop	| slots |	(self isIntegerObject: oop) ifTrue:[^0].	slots _ self slotSizeOf: oop.	(self isBytes: oop)		ifTrue:[^slots]		ifFalse:[^slots * 4]! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:07'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| srcName name length |	self var: #className declareC:'char *className'.	self var: #srcName declareC:'char *srcName'.	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	length _ self stSizeOf: name.	srcName _ self cCoerce: (self arrayValueOf: name) to:'char *'.	0 to: length-1 do:[:i|		(srcName at: i) = (className at: i) ifFalse:[^false].	].	"Check if className really ends at this point"	^(className at: length) = 0! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!firstFixedField: oop	self returnTypeC:'void *'.	^self cCoerce: oop+4 to:'void *'.! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:12'!firstIndexableField: oop	| hdr fmt totalLength fixedFields |	self returnTypeC:'void *'.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	fmt < 8 ifTrue:["32 bit field objects"		^ self cCoerce: oop+4+ (fixedFields << 2) to:'void *'.	] ifFalse:["Byte objects"		^ self cCoerce: oop+4+fixedFields to:'void *'.	]! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!floatObjectOf: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	^newFloatObj! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop KindOf: className	"Support for external primitives."	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	[oopClass == nilObj] whileFalse:[		(self classNameOf: oopClass Is: className) ifTrue:[^true].		oopClass _ self superclassOf: oopClass].	^false! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!is: oop MemberOf: className	"Support for external primitives"	| oopClass |	self var: #className declareC:'char *className'.	oopClass _ self fetchClassOf: oop.	^(self classNameOf: oopClass Is: className)! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isFloatObject: oop	^(self fetchClassOf: oop) == self classFloat! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:13'!isIndexable: oop	^(self formatOf: oop) >= 2! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:38'!methodArgumentCount	^argumentCount! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/7/1998 18:39'!methodPrimitiveIndex	^primitiveIndex! !!Interpreter methodsFor: 'plugin support' stamp: 'ar 10/10/1998 21:24'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	(self isIntegerObject: oop) ifTrue:[^0].	^self lengthOf: oop! !!Parser methodsFor: 'primitives' stamp: 'ar 10/7/1998 20:15'!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse:[^0].	prim _ here.	(self match: #number) ifTrue:[^prim].	"Indexed primitives"	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^117! !!PluggableCodeGenerator commentStamp: '<historical>' prior: 0!I generate code that can be loaded dynamically from external libraries (e.g., DSOs on Unix or DLLs on Windows)!!PluggableCodeGenerator methodsFor: 'testing' stamp: 'ar 10/7/1998 17:54'!isGeneratingPluginCode	^true! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'ar 10/11/1998 03:04'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define successFlag (!!interpreterProxy->failed())#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayValueOf(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value)EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter);/*** Variables ***/struct VirtualMachine *interpreterProxy;EXPORT(int) setInterpreter(struct VirtualMachine *anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == false) {		return false;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'ar 10/10/1998 21:36'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */';cr.	aStream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/7/1998 20:31'!storeVirtualMachineProxyHeader: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 0typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr; crtab.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitProxyFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; crtab]].	stream nextPutAll:'} VirtualMachine;#endif /* _SqueakVM_H */'.	stream close.! !!PluggableCodeGenerator methodsFor: 'private' stamp: 'ar 10/11/1998 00:52'!storeVirtualMachineProxyImplementation: categoryList on: fileName	"Store the interpreter definitions on the given file"	| stream |	stream _ FileStream newFileNamed: fileName.	stream nextPutAll:'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"'; cr;cr.	stream nextPutAll:'/*** Function prototypes ***/'.	categoryList do:[:assoc|		stream cr; cr; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr.		assoc value asSortedCollection do:[:sel|			(methods at: sel) emitCFunctionPrototype: stream generator: self.			stream nextPutAll: ';'; cr]].	stream cr; nextPutAll:'struct VirtualMachine *VM = NULL;'; cr.	stream cr; nextPutAll:'static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;'.	categoryList do:[:assoc|		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; crtab.		assoc value asSortedCollection do:[:sel|		stream nextPutAll:'VM->';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:' = ';			nextPutAll: (self cFunctionNameFor: sel);			nextPutAll:';';			crtab]].	stream cr; crtab; nextPutAll:'return VM;'; cr; nextPutAll:'}'; cr.	stream close.! !!TMethod methodsFor: 'initialization' stamp: 'ar 9/18/1998 23:24'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	export _ self extractExportDirective.	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'primitive compilation' stamp: 'ar 10/10/1998 23:36'!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	"ar 10/7/1998 -- 	Add the export directive for translated primitives.				--	Use the name of the primitive if it's called by name."	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	primArgCount _ args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn _ self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	"Check for pluggable primitive"	primitive = 117 		ifTrue:[	selector _ (aClass compiledMethodAt: selector) literals first at: 2.				export _ true]		ifFalse:[selector _ 'prim', aClass name, selector].	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].! !!TMethod methodsFor: 'transformations' stamp: 'ar 10/7/1998 18:55'!extractExportDirective	"Scan the top-level statements for an inlining directive of the form:		self export: <boolean>	 and remove the directive from the method body. Return the argument of the directive or false if there is no export directive."	| result newStatements |	result _ false.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #export:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25'!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	export 		ifTrue:[aStream nextPutAll:'EXPORT('; nextPutAll: returnType; nextPutAll:') ']		ifFalse:[aStream nextPutAll: returnType; space].	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'C code generation' stamp: 'ar 9/18/1998 23:25'!emitProxyFunctionPrototype: aStream generator: aCodeGen	"Emit an indirect C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: '(*', (aCodeGen cFunctionNameFor: selector), ')('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TSendNode methodsFor: 'all' stamp: 'ar 10/7/1998 17:53'!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Special case for pluggable modules. Replace messages to interpreterProxy	by interpreterProxy->message(..) if the message is not builtin"	(aCodeGen isGeneratingPluginCode and:[		receiver isVariable and:[			receiver name = 'interpreterProxy' and:[				self isBuiltinOperator not]]]) 		ifTrue:[aStream nextPutAll:'interpreterProxy->'].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !InterpreterPlugin initialize!