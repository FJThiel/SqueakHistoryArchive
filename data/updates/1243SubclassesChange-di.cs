'From Squeak 2.4c of May 10, 1999 on 10 June 1999 at 4:16:55 pm'!"Change Set:		SubclassesChangeDate:			10 June 1999Author:			Dan IngallsThis changeSet implements a change to the representation of Behaviors.  It moves the redundant structure, subclasses, down from Behavior to ClassDescription.  It would have been moved down to Class, but that would have changed the order of variables in every class and metaclass.  The slot is not used in Metaclasses.This has several benefits:1.  It simplifies operations on class structure.2.  It frees other subclasses of Behavior from carrying this burden as, for example, in lightweight behaviors for experiments with prototypes.3.  In the process it gets rid of a few obsolete metaclasses."!!Behavior methodsFor: 'initialize-release' stamp: 'di 6/10/1999 16:11'!obsolete	"Invalidate and recycle local messages."	methodDict _ MethodDictionary new.! !!Behavior methodsFor: 'copying' stamp: 'di 6/10/1999 10:04'!copy	"Answer a copy of the receiver without a list of subclasses."	| myCopy |	myCopy _ self shallowCopy.	^myCopy methodDictionary: methodDict copy! !!Behavior methodsFor: 'creating class hierarchy' stamp: 'di 6/10/1999 15:50'!superclass: aClass 	"Change the receiver's superclass to be aClass."	(aClass == nil or: [aClass isKindOf: Behavior])		ifTrue: [superclass _ aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!ClassDescription commentStamp: 'di 6/10/1999 10:44' prior: 0!I add a number of facilities to basic Behaviors:	Named instance variables	Category organization for methods	The notion of a name of this class (implemented as subclass responsibility)	The maintenance of a ChangeSet, and logging changes on a file	Most of the mechanism for fileOut.	I am an abstract class, in particular, my facilities are intended for inheritance by two subclasses, Class and Metaclass.The slot 'subclasses' that is defined here is only used in Class, not in Metaclass.  This is due to history and, at some point, the slot should bemoved down to Class.!!ClassDescription methodsFor: 'initialize-release' stamp: 'di 6/10/1999 16:13'!obsolete	"Make the receiver obsolete."	organization _ nil.	self isMeta not & superclass notNil		ifTrue: [superclass removeSubclass: self].	super obsolete! !!ClassDescription methodsFor: 'initialize-release' stamp: 'di 6/10/1999 15:50'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p weak: beWeak ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass isMeta				ifTrue: [superclass _ newSuper]				ifFalse: [superclass ifNotNil: [superclass removeSubclass: self].						superclass _ newSuper.						superclass addSubclass: self].			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p		weak: beWeak.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 12:04'!allSubclasses	"Answer a Set of the receiver's and the receiver's descendent's subclasses."	| aSet |	aSet _ Set new.	aSet addAll: self subclasses.	self subclasses do: [:eachSubclass | aSet addAll: eachSubclass allSubclasses].	^aSet! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 12:04'!printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subclassNames subclass |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames _ self subclasses collect: [:subC | subC name].	"Print subclasses in alphabetical order"	subclassNames asSortedCollection do:		[:name |		subclass _ self subclasses detect: [:subC | subC name = name].		subclass printSubclassesOn: aStream level: level + 1]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 12:05'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | c removeFromSystem].	^ Smalltalk garbageCollect - oldFree! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 12:05'!withAllSubclasses	"Answer a Set of the receiver, the receiver's descendent's, and the 	receiver's descendent's subclasses."	| aSet |	aSet _ Set with: self.	aSet addAll: self subclasses.	self subclasses do: [:eachSubclass | aSet addAll: eachSubclass allSubclasses].	^aSet! !!Class commentStamp: 'di 6/10/1999 10:48' prior: 0!I add a number of facilities to those in ClassDescription:	A set of all my subclasses (defined in ClassDescription, but only used here and below)	A name by which I can be found in a SystemDictionary	A classPool for class variables shared between this class and its metaclass	A list of sharedPools which probably should be supplanted by some better mechanism.My instances describe the representation and behavior of objects. I add more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations.  !!Class methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 09:56'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [self error: aSubclass name , ' is not my subclass']		ifFalse: [subclasses == nil					ifTrue:	[subclasses _ Set with: aSubclass]					ifFalse:	[subclasses add: aSubclass]]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 09:59'!removeSubclass: aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses remove: aSubclass ifAbsent: [].		subclasses isEmpty ifTrue: [subclasses _ nil]].! !!Class methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 10:04'!subclasses	"Answer a Set containing the receiver's subclasses."	subclasses == nil		ifTrue: [^Set new]		ifFalse: [^subclasses copy]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 10:00'!subclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil ifFalse:		[subclasses do: [:cl | aBlock value: cl]]! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'di 6/10/1999 16:16'!demoteSubclasses  "Behavior demoteSubclasses"	"This method preforms surgery on the hierarchy of Behavior.	In the end, the slot, 'subclasses', has been moved from Behavior down to ClassDescription.	It could have been moved down to Class, but that would have changed the order of fields in all classes and metaclasses, and recompilation would have been difficult at best."	Behavior instSize = 3 ifTrue: [^ self].  "Has already been done"	Behavior subclasses size > 1 ifTrue: [self notify: 'Warning:  Your system has direct subclasses of Behavior that will be altered as a result of this operation.  You may proceed, though.'].	"Add the var subclasses to all subclasses of Behavior, and remove it from Behavior"	Behavior subclassesDo:		[:c | c instVarAt: 5 put: (Array with: 'subclasses') , (c instVarAt: 5)].	Behavior instVarAt: 5 put: ((Behavior instVarAt: 5) copyWithout: 'subclasses').	"Decrease the instSize of Behavior by 1 (subclasses don't change though)."	Behavior instVarNamed: 'format'			put: ((Behavior instVarNamed: 'format') - 2).	Behavior instSize = 3 ifFalse: [self error: 'oops'].	"Finally, make sure all metaclasses have subclasses = nil"	Metaclass allInstancesDo: [:m | m instVarAt: 4 put: nil].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'di 6/10/1999 13:36'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, look at veryDeepCopyWith:, or tables in WeakFields and WeakFieldNames need to be updated.  	DeepCopier new checkVariables	"	| str str2 meth |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self error: 'Morph', str].	"added ones are OK"	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('subclasses' 'instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!Metaclass methodsFor: 'initialize-release' stamp: 'di 6/10/1999 15:55'!subclassOf: superMeta 	"Set the receiver to be a subclass of the argument, superMeta, a 	metaclass. Reset the receiver's method dictionary and properties.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ superMeta.	methodDict _ MethodDictionary new.	format _ superMeta format.	instanceVariables _ nil! !!Player class methodsFor: 'housekeeping' stamp: 'di 6/10/1999 11:58'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are housekeepingwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have no references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| oldFree candidatesForRemoval |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _ self subclasses asOrderedCollection select:		[:aClass | (aClass name beginsWith: 'Player') and: [aClass name endsWithDigit]].	"Break all system links and then perform garbage collection."	candidatesForRemoval do:		[:c | self removeSubclass: c.  "Break downward subclass pointers."		Smalltalk removeKey: c name ifAbsent: [].  "Break binding of global name"].	candidatesForRemoval _ nil.	Smalltalk garbageCollect.  "Now this should reclaim all unused subclasses"	"Now reconstruct system links to subclasses with valid references."	"First restore any global references via associations"	(Association allInstances select:			[:assn | (assn key isMemberOf: Symbol)					and: [(assn key beginsWith: 'Player')					and: [assn key endsWithDigit]]])		do: [:assn | c _ assn value.			(c isKindOf: self class) ifTrue:				[self addSubclass: c.				Smalltalk add: assn]].	"Then restore any further direct references, creating new associations."	(Metaclass allInstances select:			[:m | (m soleInstance name beginsWith: 'Player')					and: [m soleInstance name endsWithDigit]])		do: [:m | c _ m soleInstance.			((c isKindOf: self class) and: [(Smalltalk includesKey: c name) not]) ifTrue:				[self addSubclass: c.				Smalltalk at: c name put: c]].	SystemOrganization removeMissingClasses.	^ Smalltalk garbageCollect - oldFree! !Behavior removeSelector: #printSubclassesOn:level:!Behavior removeSelector: #subclassesDo:!Behavior removeSelector: #allSubclasses!Behavior removeSelector: #removeUninstantiatedSubclassesSilently!Behavior removeSelector: #withAllSubclasses!Behavior removeSelector: #addSubclass:!Behavior removeSelector: #removeSubclass:!Behavior removeSelector: #subclasses!ClassDescription removeSelector: #subclassOf:oldClass:instanceVariableNames:variable:words:pointers:ifBad:!"Postscript:Perform surgery, leaving Behavior with only three instance variables."Behavior demoteSubclasses. Behavior class removeSelector: #demoteSubclasses.Metaclass allInstancesDo:		[:m | m instVarAt: 4 put: nil].!