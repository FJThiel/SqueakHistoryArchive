'From Squeak 2.4b of April 23, 1999 on 1 September 1999 at 5:09:55 pm'!"Change Set:		ClassBuilderFix-arDate:			1 September 1999Author:			Andreas RaabMisc fixes for the ClassBuilder"!Object subclass: #ClassBuilder	instanceVariableNames: 'environ classMap instVarMap progress maxClassIndex currentClassIndex '	classVariableNames: 'QuietMode '	poolDictionaries: ''	category: 'Kernel-Classes'!!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 8/29/1999 12:02'!methodsDo: aBlock	"Evaluate aBlock for all the compiled methods in my method dictionary."	^methodDict valuesDo: aBlock! !!Browser methodsFor: 'class functions' stamp: 'ar 8/29/1999 12:51'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName |	oldClass _ self selectedClassOrMetaClass.	newClassName _ (defString findTokens: Character separators) third copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [Smalltalk includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 8/29/1999 12:32'!initialize	environ _ Smalltalk.	instVarMap _ IdentityDictionary new.! !!ClassBuilder methodsFor: 'public' stamp: 'ar 8/29/1999 15:38'!class: oldClass instanceVariableNames: instVarString	"This is the basic initialization message to change the definition of	an existing Metaclass"	oldClass isMeta ifFalse:[^self error: oldClass name, 'is not a Metaclass'].	^self class: oldClass instanceVariableNames: instVarString unsafe: false! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:38'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass |	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass _ self recompile: false from: oldClass to: newClass mutate: false.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/26/1999 12:54'!mutate: oldClass to: newClass	"Mutate oldClass to newClass.	Convert all instances of oldClass and recursively update	the subclasses."	| subs newSubclass oldSubclass |	subs _ oldClass subclasses asArray.	"Walk down"	1 to: subs size do:[:i|		oldSubclass _ subs at: i.		self showProgressFor: oldSubclass.		"Create the new class"		newSubclass _ self reshapeClass: oldSubclass to: nil super: newClass.		self mutate: oldSubclass to: newSubclass.	].	oldClass obsolete.	newClass isObsolete ifTrue:[newClass obsolete].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:34'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	^self 		name: className 		inEnvironment: env 		subclassOf: newSuper 		type: type 		instanceVariableNames: instVarString 		classVariableNames: classVarString 		poolDictionaries: poolString 		category: category		unsafe: false! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:38'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass == oldClass ifFalse:[newClass setName: className].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	"... record any new class ..."	oldClass == nil ifTrue:[Smalltalk changes addClass: newClass].	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		environ at: newClass name put: newClass.		Smalltalk flushClassNameCache.	].	"... and fix eventual references to obsolete globals."	oldClass _ nil. "So we have no references to the old class anymore"	self fixGlobalReferences.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:36'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass unsafe: unsafe	"Create a new subclass of the given superclass.	Note: The new class may be meta."	| newFormat newClass meta |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	(oldClass ~~ nil and:[		newSuper == oldClass superclass and:[			newFormat = oldClass format and:[				instVars = oldClass instVarNames]]]) 					ifTrue:[^oldClass].	unsafe ifFalse:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.			^nil].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined!! \Proceed to store over it.' withCRs]].	oldClass == nil ifTrue:["Requires new metaclass"		meta _ Metaclass new.		meta			superclass: (newSuper ifNil:[Class] ifNotNil:[newSuper class])			methodDictionary: MethodDictionary new			format: (newSuper ifNil:[Class format] ifNotNil:[newSuper class format]).		meta superclass addSubclass: meta. "In case of Class"		newClass _ meta new.	] ifFalse:[ newClass _ oldClass shallowCopy ].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars;		organization: (oldClass ifNotNil:[oldClass organization]).	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/1/1999 17:04'!recompile: force from: oldClass to: aClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		newClass superclass addSubclass: newClass.		^newClass]. "newClass has an empty method dictionary"	(newClass == oldClass and:[force not and:[forceMutation not]])			ifTrue:[^newClass]. "No recompilation necessary"	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	classMap _ WeakValueDictionary new.	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		self showProgressFor: oldClass.		newClass _ self reshapeClass: oldClass to: newClass super: newClass superclass.		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 12:17'!reshapeClass: aClass to: templateClass super: newSuper	"Reshape the given class to the new super class.	If templateClass is not nil then it defines the shape of the new class"	| fmt newClass newMeta newSuperMeta oldMeta instVars oldClass |	templateClass == nil		ifTrue:[oldClass _ aClass]		ifFalse:[oldClass _ templateClass].	aClass becomeUncompact.	"Compute the new format of the class"	instVars _ instVarMap at: aClass name ifAbsent:[oldClass instVarNames].	fmt _ self computeFormat: oldClass typeOfClass				instSize: instVars size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted aClass first"	fmt == nil ifTrue:[^nil].	aClass isMeta ifFalse:["Create a new meta class"		oldMeta _ aClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass removeSubclass: oldMeta.		newMeta superclass addSubclass: newMeta.		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: aClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: instVars;		organization: aClass organization.	"Recompile the new class"	aClass hasMethods 		ifTrue:[newClass compileAllFrom: aClass].	"Export the new class into the environment"	aClass isMeta ifFalse:[		"Derefence super sends in the old class"		self fixSuperSendsFrom: aClass.		"Export the class"		environ at: newClass name put: newClass.		"And use the ST association in the new class"		self fixSuperSendsTo: newClass].	"Fix up the class hierarchy"	aClass superclass removeSubclass: aClass.	newClass superclass addSubclass: newClass.	"Adopt all the instances of the old class"	aClass autoMutateInstances		ifTrue:[newClass updateInstancesFrom: aClass].	"And record the change"	self recordClass: aClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 13:47'!fixGlobalReferences	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses |	classMap == nil ifTrue:[^self].	(self retryWithGC:[classMap contains:[:any| any notNil and:[any isObsolete]]]		until:[:obsRef| 				any _ nil. "Grrrr. Must clean up the temp of the block above"				obsRef = false]) ifFalse:[^self]. "GC cleaned up the remaining refs"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references to globals'].	"Forward all old refs to the new ones"	(oldClasses asArray) elementsForwardIdentityTo: (newClasses asArray).	"Done"! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:03'!fixSuperSendsFrom: oldClass	"The oldClass is about to be removed from the environment.	Fix all references to super so that the association is different from	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Association key: nil value: oldClass.	oldClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral class == Association and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:04'!fixSuperSendsTo: newClass	"The newClass has been exported into the environment.	Fix all references to super so that the association is	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Smalltalk associationAt: newClass name ifAbsent:[nil].	newSuper == nil ifTrue:[^self].	newSuper value == newClass ifTrue:[^self].	newClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral class == Association and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 13:03'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress _ bar.		aBlock value].	progress _ nil.! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:29'!mapObsoleteClassesToTemps: oldClasses	"Map the old classes to temporary classes.	These temporary classes will survive the #become:	operation and be used as the class of any instances	or subclasses of the obsolete classes."	| oldMeta tempMeta obsoleteClasses |	obsoleteClasses _ IdentityDictionary new: oldClasses size.	oldClasses do:[:oldClass| 		"Note: If a class is getting obsolete here so is its metaclass"		oldMeta _ oldClass isMeta ifTrue:[oldClass] ifFalse:[oldClass class].		tempMeta _ obsoleteClasses at: oldMeta ifAbsentPut:[oldMeta clone].		oldClass isMeta ifFalse:[			tempMeta adoptInstance: oldClass from: oldMeta.			obsoleteClasses at: oldClass put: tempMeta soleInstance.			"Note: If we haven't mutated the instances of the old class to the new			layout we must do it here."			oldClass autoMutateInstances ifFalse:[				tempMeta soleInstance updateInstancesFrom: oldClass]]].	"Fix the superclasses of the clones"	obsoleteClasses keysAndValuesDo:[:old :temp|		temp superclass: 			(obsoleteClasses 				at: temp superclass				"Might be a subclass of a live class"				ifAbsent:[temp superclass])].	"And install new method dictionaries"	obsoleteClasses valuesDo:[:temp|		temp methodDictionary: temp methodDictionary copy.	].	^obsoleteClasses! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 15:43'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod TranslatedMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 8/29/1999 12:49'!subclassDefinerClass	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"	^Compiler! !ClassBuilder removeSelector: #reshapeClass:toSuper:!ClassBuilder removeSelector: #recordObsoleteAssociation:!ClassBuilder removeSelector: #newSubclassOf:type:instanceVariables:from:!ClassBuilder class removeSelector: #superSend!