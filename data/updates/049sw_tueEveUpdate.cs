'From Squeak 2.0 BETA of May 8, 1998 on 19 May 1998 at 9:58:34 pm'!!Class methodsFor: 'subclass creation' stamp: 'sw 5/19/1998 09:07'!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'UserObjects'"Point newSubclass new"! !!EventHandler methodsFor: 'initialization' stamp: 'sw 5/18/1998 17:06'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue:			[mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue:			[mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue:			[mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue:			[mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue:			[mouseLeaveRecipient _ mouseLeaveSelector _ nil].	keyStrokeSelector == aSelector		ifTrue:			[keyStrokeRecipient _ keyStrokeSelector _ nil].! !!ImageMorph class methodsFor: 'class initialization' stamp: 'sw 5/19/1998 18:30'!authoringPrototype	| aMorph aForm |	aMorph _ super authoringPrototype.	aForm _ ScriptingSystem formAtKey: 'Image'.	aForm ifNil: [aForm _ aMorph image rotateBy: 90].	aMorph image: aForm.	^ aMorph! !!Morph methodsFor: 'menu' stamp: 'sw 5/19/1998 12:22'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	costumee ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	self colorSettable ifTrue:		[aMenu add: 'fill color' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'naming' stamp: 'sw 5/19/1998 13:10'!submorphNamed: aName ifNone: aBlock	^ self submorphs detect: [:p | p knownName = aName] ifNone: [aBlock value]! !!Morph methodsFor: 'properties' stamp: 'sw 5/18/1998 17:32'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	(val _ self valueOfProperty: #balloonText) ifNotNil: [^ val].	(val _ self valueOfProperty: #balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil! !!Morph methodsFor: 'properties' stamp: 'sw 5/18/1998 17:27'!balloonTextSelector: aSelector	self setProperty: #balloonTextSelector toValue: aSelector! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 5/18/1998 17:48'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str balloon |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	anEvent controlKeyPressed ifTrue:		[^ self editBalloonHelpContent: str].	"Put up the actual balloon"	balloon _ BalloonMorph string: str for: self corner: #bottomRight.	"corner is a suggestion"	self world addMorphFront: balloon.	self setProperty: #balloon toValue: balloon! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 5/18/1998 17:48'!wantsBalloon	^ self balloonText ~~ nil! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/19/1998 18:49'!makeNewDrawing	"Make a new drawing in the standard playfield."	| aPlayfield |	(aPlayfield _ self world playfield) ifNil: [aPlayfield _ self world].	self makeNewDrawingInBounds: aPlayfield paintingBounds pasteUpMorph: aPlayfield! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/18/1998 15:27'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ PasteBuffer usableDuplicate).	aPastee costumee ifNotNil: [aPastee costumee startRunning]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 5/18/1998 10:25'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	|  aPaintWindow  aSketchMorph aPlayer  aWorld |	aWorld _ aPasteUpMorph world.	aWorld stopRunningAll; abandonAllHalos.	aSketchMorph _ self drawingClass new costumee: (aPlayer _ Player newUserInstance).	aPlayer costume: aSketchMorph.	aSketchMorph form: (Form extent: rect extent depth: aWorld assuredCanvas depth).	aSketchMorph bounds: rect.	aPaintWindow _ SketchEditorMorph new.	aWorld addMorphFront: aPaintWindow.	aPaintWindow initializeFor: aSketchMorph inBounds: rect ofWorld: aWorld.	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			owner fullRepaintNeeded.			aSketchMorph form: aForm.			aSketchMorph position: aRect origin.			aSketchMorph forwardDirection: aPaintWindow forwardDirection.			aSketchMorph rotationDegrees: aPaintWindow forwardDirection.	"Same orientation as she drew it"			aSketchMorph rotationStyle: aPaintWindow rotationStyle.			aPasteUpMorph addMorphFront: aSketchMorph.			aWorld startSteppingSubmorphsOf: aSketchMorph.			self presenter drawingJustCompleted: aSketchMorph]		 ifNoBits: [aPasteUpMorph standardPalette ifNotNil: [aPasteUpMorph standardPalette showNoPalette]]! !!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 5/19/1998 18:52'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/18/1998 19:13'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '?' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot]).	^ aButton! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/19/1998 13:22'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: '+' font: aFont; color: Color gray muchLighter; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Hit plus to addan instance variableto this player.'.	r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #newCostume to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to specify new costume.'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/19/1998 17:32'!rowBeforeScripts	| r aButton |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 40@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'new script' font: (StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new script'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 40@5.	^ r! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/19/1998 18:50'!makeNewDrawingWithin	self primaryHand makeNewDrawingInBounds: self paintingBounds pasteUpMorph: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/19/1998 18:51'!paintingBounds	^ self paintingBoundsAround: self bounds center! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/19/1998 18:51'!paintingBoundsAround: dropPoint	| anExtent possibleBounds |	^ (self bounds area > ScriptingSystem maxPaintArea)		ifTrue:			[anExtent _ ScriptingSystem reasonablePaintingExtent.			possibleBounds _ (dropPoint - (anExtent // 2)) extent: anExtent.			possibleBounds intersect: self bounds]		ifFalse:			[self bounds]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/19/1998 15:06'!morphToDropFrom: aMorph	"Presently only in service for features in the tile-scripting system that allow a different object from the one being carried to be dropped"	| itsSelector aScriptor adjustment anEditor actualObject aUserScript |	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/19/1998 15:03'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!Player methodsFor: 'name' stamp: 'sw 5/19/1998 13:20'!assureExternalName	costume knownName ifNil:		[costume setNameTo: costume externalName]! !!Player class methodsFor: 'scripts' stamp: 'sw 5/19/1998 09:44'!scripts	scripts ifNil: [scripts _ IdentityDictionary new].	^ scripts! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/19/1998 14:17'!wantsDroppedMorph: aMorph	^ (aMorph isTileLike and: [aMorph resultType == #command]) and:		[self isTextuallyCoded not]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:11'!actuallyDestroyScript	| aHandler |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName.		"not quite enough yet in the multiple-instance case..."	(aHandler _ playerScripted costume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	playerScripted updateAllViewers! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:39'!addDismissButtonTo: aRowMorph	aRowMorph addMorphBack:		((SimpleButtonMorph new label: 'X' font: ScriptingSystem fontForScriptorButtons)			target: self;			color:  Color lightRed;			actionSelector: #dismiss;			balloonTextSelector: #dismiss).	^ aRowMorph! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:42'!buttonRowForEditor	| r aString aButtonMorph buttonFont aStatusMorph aStatus |	buttonFont _ ScriptingSystem fontForScriptorButtons.	r _ AlignmentMorph newRow color: Color transparent; inset: 0.	r addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	r addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	r addMorphBack:		(aButtonMorph _ SimpleButtonMorph new label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	r addTransparentSpacerOfSize: 6@10.	aStatus _ self scriptInstantiation status.	r addMorphBack:			(aStatusMorph _ SimpleButtonMorph new label: aStatus font: buttonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger;				balloonTextSelector: #chooseTrigger).	r addTransparentSpacerOfSize: 10@10.	r addMorphBack:		((SimpleButtonMorph new label: '¥' font: buttonFont)			target: self;			color: Color veryLightGray;			actWhen: #buttonDown;			actionSelector: #addYesNoToHand;			balloonTextSelector: #addYesNoToHand).	r addTransparentSpacerOfSize: 12@10.	self addDismissButtonTo: r.	self updateStatusMorph: aStatusMorph.	^ r! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 16:16'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters me with button up'		'mouseLeave -- when mouse exits me with button up'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 "8")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume startStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:12'!destroyScript	| aMenu reply |	(self isAnonymous not and: [submorphs size > 1]) ifTrue:		[aMenu _ SelectionMenu selections: #('destroy it' 'oops, no, don''t destroy').		reply _ aMenu startUpWithCaption: 'Do you really want todestroy this script?'.		(reply = 'destroy it') ifFalse: [^ self]].	self actuallyDestroyScript! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 14:05'!dismiss	| aMenu reply |	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	(self isAnonymous and:			[(submorphs size > 3) or: [self scriptInstantiation status ~~ #normal]]) ifTrue:		[aMenu _ SelectionMenu selections: #('yes, name it' 'no, discard it' 'cancel').		reply _ aMenu startUpWithCaption: 'Do you want to give thisscript a name and save it? '.		(reply size == 0 or: [reply = 'cancel']) ifTrue: [^ self].		(reply = 'yes, name it') ifTrue: [^ self renameScript].		self actuallyDestroyScript].	self delete! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 14:16'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	^ Browser openBrowserView: (newBrowser openMessageEditString: nil)		label: ('textual script for "', scriptName, '" in ', playerScripted externalName)! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 15:27'!tryMe	self playerScripted perform: scriptName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 15:24'!becomeTextuallyCoded	self isTextuallyCoded ifTrue: [^ self].	self saveScriptVersion.	self userScriptObject becomeTextuallyCoded.	(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete].	self color: Color darkGray! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 13:57'!isTextuallyCoded	^ self userScriptObject isTextuallyCoded! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 17:41'!offerScriptorMenu	| aMenu result  aList lines title |	self isAnonymous		ifTrue:			[aList _ #(				('name and save this script'	renameScript)				('destroy this script'			destroyScript)).			title _ 'temporary script'.			lines _ #()]		ifFalse:			[title _ scriptName asString.			self isTextuallyCoded				ifTrue:					[title _ title, ' (textually coded)'.					aList _ #(						('revert to tile version...'		revertScriptVersion)						('modify textual script'			editScriptTextually)						('view all scripts'				browseScripts)						('destroy this script'				destroyScript)).					lines _ #(1 3)]				ifFalse:					[aList _ #(						('save this version'				saveScriptVersion)						('revert to prior version...'		revertScriptVersion)						('edit this script textually'		editScriptTextually)						('view all scripts'				browseScripts)						('destroy this script'				destroyScript)).					lines _ #(2 4)]].	aMenu _ SelectionMenu labelList: (aList collect: [:pair | pair first]) lines: lines selections: (aList collect: [:pair | pair second]).	result _ aMenu startUpWithCaption: title.	result ifNotNil: [self perform: result]"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 14:12'!saveScriptVersion	self userScriptObject saveScriptVersion: self setTimeStamp! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 13:57'!userScriptObject	^ playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 5/18/1998 16:08'!insertTileRow: tileList after: index	"Return a row to be used to insert an entire row of tiles."	self isThisEverCalled.   "an error if so.... evaluator can't add or delete rows"! !!ScriptInstantiation commentStamp: 'sw 5/19/1998 21:58' prior: 0!One of these is associated with each user-defined script for each Player.   Holds the state that defines when the script should be run automatically by the system.	player				The player whose script this is.	selector				The message to send my player to activate this script	status				#ticking, #paused, #normal, #mouseDown, #mouseStillDown, #mouseUp,							#mouseEnter, #mouseLeave, #keyStroke	frequency			For ticking scripts, their frequency.  Place-holder: not implemented yet	anonymous			If true, the script has is unnamed -- in this case, the selector is private to the implementation!!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 5/18/1998 10:10'!initializeFor: aSketchMorph inBounds: boundsToUse ofWorld: aWorldMorph	hostView _ aSketchMorph.  "Note that aSketchMorph may well be ownerless at this juncture"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: aWorldMorph viewBox origin.	palette _ aWorldMorph paintBox.	aWorldMorph addMorphFront: palette.	"Bring it in front"	aWorldMorph fullRepaintNeeded.	paintingForm _ Form extent: bounds extent 		depth: aWorldMorph assuredCanvas depth.	self dimTheWindow.	"And set up the bitBlts"	aSketchMorph ~~ nil ifTrue:		[aSketchMorph form displayOn: paintingForm 			at: (hostView bounds origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter].	palette rememberColorsFrom: paintingForm.	self resumePainting.! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 5/18/1998 10:10'!initializeFor: aSketchMorph inPasteUpMorph: aPasteUpMorph	self initializeFor: aSketchMorph inBounds: aPasteUpMorph bounds ofWorld: aPasteUpMorph world! !!SketchMorph methodsFor: 'menu' stamp: 'sw 5/19/1998 20:31'!editDrawingIn: aPasteUpMorph forBackground: aBoolean	| oldRotation aPaintWindow oldFwdDir w boundsToUse |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	aPaintWindow _ SketchEditorMorph new.	aBoolean ifTrue: [aPaintWindow setProperty: #background toValue: true].	w addMorphFront: aPaintWindow.	oldRotation _ rotationDegrees.	oldFwdDir _ self forwardDirection.	self rotationDegrees: 0.	aBoolean		ifTrue:			[aPaintWindow initializeFor: self inPasteUpMorph: aPasteUpMorph]		ifFalse:			[boundsToUse _ (aPasteUpMorph paintingBoundsAround: self bounds center) merge: self bounds.			aPaintWindow initializeFor: self inBounds: boundsToUse ofWorld: aPasteUpMorph world].	self rotationDegrees: oldRotation.  "while drawing is still rotated. cancel leaves it right"	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self position: aRect origin.			self forwardDirection: aPaintWindow forwardDirection.			self rotationDegrees: oldRotation + (aPaintWindow forwardDirection - oldFwdDir).				"add in any changes"			self rotationStyle: aPaintWindow rotationStyle.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			aBoolean ifTrue: [self goBehind].  "shouldn't be necessary"			owner changed]		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil: [aPasteUpMorph standardPalette viewMorph: self]].	aPaintWindow changed.! !!StandardScriptingSystem methodsFor: 'all' stamp: 'sw 5/19/1998 21:53'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'all' stamp: 'sw 5/19/1998 18:36'!maxPaintArea	"Answer the largest paintable area for new 'make new drawing'"	"ScriptingSystem maxPaintArea"	| anExtent |	anExtent _ self reasonablePaintingExtent.	^ anExtent x * anExtent y! !!StandardScriptingSystem methodsFor: 'all' stamp: 'sw 5/19/1998 20:11'!reasonablePaintingExtent	"Answer a reasonable maximum extent for new 'make new drawing'"	^  240 @ 280! !!StandardScriptingSystem methodsFor: 'all' stamp: 'sw 5/18/1998 17:53'!tryButtonFor: aPhraseTileMorph	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aPhraseTileMorph; actionSelector: #try; label: '!!' font: (StrikeFont familyName: #ComicBold size: 16); color: Color yellow; borderWidth: 0.	aButton actWhen: #whilePressed.	aButton balloonTextSelector: #try.	^ aButton! !!StandardScriptingSystem class methodsFor: 'as yet unclassified' stamp: 'sw 5/19/1998 18:21'!initialize	"StandardScriptingSystem initialize"	self initializeSystemSlotDictionary.	self new initializeHelpStrings! !!StandardScriptingSystem class methodsFor: 'as yet unclassified' stamp: 'sw 5/19/1998 21:57'!initializeSystemSlotDictionary	"StandardScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!UserScript commentStamp: 'sw 5/19/1998 21:58' prior: 0!Holds the ScriptEditorMorph structures for the current version of a user-defined tile script, as well as previous versions thereof.	currentScriptEditor	The current version of the ScriptEditorMorph for the script	formerScriptEditors 	Earlier versions of the script, for recapturing via the Versions feature							(a dictionary, <timeStamp> -> ScriptEditorMorph!!UserScript reorganize!('textually coded' isTextuallyCoded)('versions' becomeTextuallyCoded revertScriptVersionFrom: saveScriptVersion:)('script editor' allScriptVersionsDo: bringUpToDate currentScriptEditor: donorActor:ownActor: initializeForPlayer:afterShallowCopyFrom: instantiatedScriptEditor)!!UserScript methodsFor: 'textually coded' stamp: 'sw 5/19/1998 09:55'!isTextuallyCoded	^ currentScriptEditor == #textuallyCoded! !!UserScript methodsFor: 'versions' stamp: 'sw 5/19/1998 14:13'!becomeTextuallyCoded	currentScriptEditor _ #textuallyCoded! !!UserScript methodsFor: 'versions' stamp: 'sw 5/19/1998 15:19'!revertScriptVersionFrom: anEditor	| aMenu result aPosition |	formerScriptEditors size == 0 ifTrue: [^ self beep].	aMenu _ SelectionMenu labelList: (formerScriptEditors collect: [:e | e timeStamp])		selections: formerScriptEditors.	result _ aMenu startUp.	result ifNotNil:		[aPosition _ anEditor position.		anEditor delete.		currentScriptEditor _ result bringUpToDate install.		player costume viewAfreshShowingScript: selector at: aPosition]! !!UserScript methodsFor: 'versions' stamp: 'sw 5/19/1998 14:12'!saveScriptVersion: timeStampCurrentlyIgnored	self isTextuallyCoded ifFalse:		[formerScriptEditors == nil ifTrue: [formerScriptEditors _ OrderedCollection new].		currentScriptEditor ifNotNil: [formerScriptEditors add: currentScriptEditor fullCopy].		formerScriptEditors size > 100 ifTrue: [^ self halt: 'apparent runaway versions']]! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/19/1998 12:18'!allScriptVersionsDo: aBlock	self isTextuallyCoded ifFalse: [aBlock value: currentScriptEditor].	formerScriptEditors ifNotNil: [formerScriptEditors do:		[:ed | aBlock value: ed]]! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/19/1998 12:28'!initializeForPlayer: aPlayer afterShallowCopyFrom: aDonorUserScript	player _ aPlayer.	formerScriptEditors _ nil.	aDonorUserScript isTextuallyCoded		ifFalse:			[currentScriptEditor _ currentScriptEditor fullCopy.			currentScriptEditor playerScripted: aPlayer.			currentScriptEditor donorActor: aDonorUserScript player ownActor: aPlayer]		! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/19/1998 15:27'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume startStepping]].		^ currentScriptEditor! !EToyPlayer removeSelector: #toggleButtonsFor:!Morph removeSelector: #addSensitivityItemsTo:hand:!CommandTilesMorph removeSelector: #justDroppedInto:event:!HandMorph removeSelector: #makeNewDrawingIn:!PasteUpMorph removeSelector: #establishMouseScriptFor:mouseState:!Player removeSelector: #onTicks!Player class removeSelector: #scriptEditorsDo:!ScriptInstantiation removeSelector: #anonymnous!SketchEditorMorph removeSelector: #getRepaintingStaringWith:at:!StandardScriptingSystem initialize!TrashCanMorph removeSelector: #addLabel!UserScript removeSelector: #currentScriptEditor!