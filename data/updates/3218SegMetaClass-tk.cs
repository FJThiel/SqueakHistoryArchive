'From Squeak2.9alpha of 5 August 2000 [latest update: #3274] on 18 January 2001 at 4:12:03 pm'!"Change Set:		SegMetaClass-tkDate:			18 January 2001Author:			Scott WallaceFixes bug in which PlayerXX class was not being included in the segment.  Now follows the rule that every class in roots must have its metaclass in roots.  (broken when I went to enumerating objects.)"!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/18/2001 16:02'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements world naughtyBlocks goodToGo allClasses |	Smalltalk forgetDoIts.  	1 to: 5 do: [:ii | ((rootArray at: ii) respondsTo: #isCurrentProject) ifTrue: [					world _ rootArray at: ii]].	world ifNotNil: [world presenter flushPlayerListCache].	"old and outside guys"	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	allClasses _ SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements _ dummy blockers.	dummy project ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"	naughtyBlocks _ arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	naughtyBlocks isEmpty ifFalse: [		goodToGo _ PopUpMenu			confirm: 'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?' 			trueChoice: 'keep going' 			falseChoice: 'stop and take a look'.		goodToGo ifFalse: [			naughtyBlocks inspect.			self error: 'Here are the bad blocks'].	].	"Creation of the segment happens here"	"try using one-quarter of memory to publish (will get bumped later)"	self copyFromRoots: arrayOfRoots sizeHint: (Smalltalk garbageCollect // 4 // 4) areUnique: true.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	symbolHolder.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/18/2001 15:54'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class.	Return all classes seen." | uniClasses normal more aUniClass mySize allClasses |"Note: Any classes used in the structure of classInstVars must be written out also!!"uniClasses _ Set new.allClasses _ IdentitySet new.normal _ Object class instSize.more _ true.[more] whileTrue: [	more _ false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass _ each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize _ aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more _ true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]].		each class class isMeta ifFalse: ["it is a class" allClasses add: each]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."^ allClasses! !