'From Squeak 2.5 of August 6, 1999 on 17 September 1999 at 4:30:06 pm'!"Change Set:		endUserStringEdit-swDate:			17 September 1999Author:			Scott WallaceBuiliding on Dan's StringEditHack, makes traditional text-editing available for editing end-user string-like structures such as viewer readouts, tile-script parameters, watchers, object names in halos, object names in viewers, etc.Also changes the default string editing behavior such that you now start out in a 'select-all' state, ready to replace the old string completely if you simply start typing after selecting.Makes a considerable effort to harmonize the resizing algorithms for structures containing embedded strings (primarily UpdatingStringMorphs) across the various ways that string contents can be changed, viz. by text-editing, by the target changing the value, by hitting increase/decrease arrows on tiles, etc."!StringMorph subclass: #UpdatingStringMorph	instanceVariableNames: 'format target lastValue getSelector putSelector floatPrecision growable stepTime autoAcceptOnFocusLoss minimumWidth maximumWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!UpdatingStringMorph subclass: #NameStringInHalo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!Morph methodsFor: 'naming' stamp: 'sw 9/7/1999 16:31'!setNameTo: aName	| nameToUse nameString |	nameToUse _ aName ifNotNil:		[(nameString _ aName asString) size > 0 ifTrue: [nameString] ifFalse: ['É']].	self setNamePropertyTo: nameToUse "no Texts here!!"! !!Morph methodsFor: 'scripting' stamp: 'sw 9/15/1999 15:03'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile displayer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[StringReadoutTile new typeColor: aColor]]. 	displayer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: true;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	(typeSymbol == #number)		ifTrue:			 [(#(cursorWrapped  "etc...") includes: partName)				ifTrue:					[displayer floatPrecision: 0.1]				ifFalse:					[(self player slotInfo includesKey: partName)  "i.e., a user-defined numeric slot"						ifTrue:							[displayer floatPrecision: (self player slotInfoAt: partName) floatPrecision]]].	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	((putSelector ~~ #unused) and: [#(number sound boolean) includes: typeSymbol])  ifTrue: [aTile addArrows].	aTile literal: (self scriptPerformer perform: getSelector).	^ aTile! !!HaloMorph methodsFor: 'initialization' stamp: 'sw 9/9/1999 18:13'!delete	| label |	(label _ self findA: NameStringInHalo) ifNotNil:		[label hasFocus ifTrue:			[label lostFocusWithoutAccepting]].	super delete! !!HaloMorph methodsFor: 'events' stamp: 'sw 9/7/1999 15:43'!staysUpWhenMouseIsDownIn: aMorph	^ ((aMorph == target) or: [submorphs includes: aMorph]) or:		["name under edit, special case"		(aMorph isKindOf: StringMorphEditor) and: [submorphs includes: aMorph owner]]! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/9/1999 10:35'!addHandles	| box s dismissHandle lab |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.		self bounds: target renderedMorph fullBoundsInWorld.  "update my size"	box _ self basicBox.	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	"innerTarget colorSettable ifTrue:		[self addGraphicalHandle: ColorHalo at: (box topLeft + (0@14)) on: #mouseDown send: #doRecolor:with: to: self]."  "possible future"	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	dismissHandle _ self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color red muchLighter		on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.	dismissHandle on: #mouseStillDown send: #setDismissColor:with: to: self.	dismissHandle addMorphBack: (lab _ StringMorph contents: 'X' font: ScriptingSystem fontForScriptorButtons).	lab position: dismissHandle position + (4 @ 0).	lab lock.	self addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[self addHandleAt: ((box topRight + box rightCenter) // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/8/1999 11:06'!addName	self addNameBeneath: self basicBox string: target externalName! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/8/1999 10:53'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition |	nameMorph _ NameStringInHalo contents: aString.	nameMorph useStringFormat; target: innerTarget; putSelector: #renameTo:.	namePosition _ outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: self world extent - nameMorph extent y + 2).	nameMorph balloonTextSelector: #objectNameInHalo.	self addMorph: nameMorph.	^ nameMorph! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/7/1999 17:48'!basicBox	^ (self bounds expandBy: self handleSize + 1)			intersect: (self world bounds insetBy: 8@8)! !!Morph class methodsFor: 'misc' stamp: 'sw 9/7/1999 15:37'!helpContributions	"Answer a list of pairs of the form		<symbol> <help message> 	to contribute to the system help dictionary"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new instance variable to the receiver')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addSlotNamedLike:withValue:			'add a slot with a unique name derived from the first parameter, giving it the second parameter as its initial value')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(chooseTrigger'When this script should run."normal" means "only when called".See "explain status alternatives" at leftfor more information.')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCard			'Go to the next card')		(goToPreviousCard			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(newCard			'Create a new card.')		(nextPage			'Go to next page.')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(offerScriptorMenu			'Press here to get a menu of options for this Scriptor')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly.')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.  Click here to rename or delete it')		(userSlot			'This is an instance variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!Presenter methodsFor: 'viewer' stamp: 'sw 9/9/1999 20:16'!viewMorph: aMorph	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph topRendererOrSelf assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	(Preferences viewersInFlaps) ifTrue:		[aViewer initializeFor: aPlayer barHeight: 0.		aViewer enforceTileColorPolicy.		associatedMorph world hideViewerFlapsOtherThanFor: aPlayer.		aFlapTab _ associatedMorph world viewerFlapTabFor: aMorph.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		associatedMorph world startSteppingSubmorphsOf: aFlapTab.		^ associatedMorph world startSteppingSubmorphsOf: aViewer].			aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint _ aMorph bounds right @ 			(aMorph center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: associatedMorph world bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		associatedMorph world startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ self].	aMorph primaryHand attachMorph: (aViewer visible: true)! !!StandardViewer methodsFor: 'as yet unclassified' stamp: 'sw 9/7/1999 14:47'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean	| header aFont aButton aTextMorph nail wrpr costs headWrapper inner |	header _ AlignmentMorph newRow color: self color muchLighter; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	aBoolean ifTrue:		[header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).		aButton target: self;				color:  Color lightRed;				actionSelector: #dismiss;				setBalloonText: 'Delete'.		header addTransparentSpacerOfSize: 4@1].	header addMorphBack: (aButton _ SimpleButtonMorph new label: '+' font: aFont).	aButton target: self; beTransparent; borderWidth: 0;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother viewer'.	header addTransparentSpacerOfSize: 4@1.	costs _ scriptedPlayer costumes.	costs ifNotNil:	[(costs size > 1 or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume']].		aBoolean		ifTrue:			[nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]		ifFalse:			[inner _ ImageMorph new image: (ScriptingSystem formAtKey: 'Menu').			nail _ RectangleMorph new beTransparent extent: inner extent.			nail addMorph: inner lock].	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.	nail borderWidth: 3; borderColor: #raised.	"nail addDropShadow.	nail owner color: Color gray."	header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer costume assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.'.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper _ AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/17/1999 16:29'!contents: newContents	newContents isText		ifTrue: [emphasis _ newContents emphasisAt: 1.				contents _ newContents string]		ifFalse: [contents = newContents ifTrue: [^ self].  "no substantive change"				contents _ newContents].	self fitContents.	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 13:27'!fitContents	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: self fontToUse.	self extent: (((scanner stringWidth: contents) max: self minimumWidth)  @ scanner lineHeight).	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/9/1999 18:09'!handsWithMeForKeyboardFocus	| foc |	"Answer the hands that have me as their keyboard focus"	hasFocus ifFalse: [^ #()].	^ self currentWorld hands select:		[:aHand | (foc _ aHand keyboardFocus) notNil and: [foc owner == self]]! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 11:26'!hasFocus	^ hasFocus! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 11:10'!interimContents: aString	"The receiver is under edit and aString represents the string the user sees as she edits, which typically will not have been accepted and indeed may be abandoned"	self contents: aString! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 13:44'!minimumWidth	"Answer the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	^ 3! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/16/1999 22:57'!valueFromContents	"Return a new value from the current contents string."	^ contents! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/17/1999 13:27'!cancelEdits	self doneWithEdits! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/7/1999 16:13'!launchMiniEditor: evt	| textMorph |	hasFocus _ true.  "Really only means edit in progress for this morph"	textMorph _ StringMorphEditor new contentsAsIs: contents.	textMorph beAllFont: self fontToUse.	textMorph bounds: (self bounds expandBy: 0@2).	self addMorphFront: textMorph.	evt hand newMouseFocus: textMorph.	evt hand newKeyboardFocus: textMorph.	textMorph editor selectFrom: 1 to: textMorph paragraph text string size! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/8/1999 10:42'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus -- typically by clicking on some editable text somewhere else -- without having accepted the current edits."	self acceptContents! !!StringMorphEditor methodsFor: 'all' stamp: 'sw 9/7/1999 16:22'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: Color yellow muchLighter.	^ super drawOn: aCanvas! !!StringMorphEditor methodsFor: 'all' stamp: 'sw 9/17/1999 13:40'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| priorEditor char |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner acceptContents; doneWithEdits.						evt hand newKeyboardFocus: nil.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand newKeyboardFocus: nil.		^ self delete].	priorEditor _ self editor.  "Save selection state"	super keyStroke: evt.	self releaseParagraph.  "zap the paragraph cache"	self paragraph.  "re-instantiate to set new bounds"	owner interimContents: self contents asString.	self installEditorToReplace: priorEditor.  "restore selection state"! !!StringMorphEditor methodsFor: 'all' stamp: 'sw 9/10/1999 15:58'!keyboardFocusChange: aBoolean	| hadFocus |	hadFocus _ owner hasFocus.	super keyboardFocusChange: aBoolean.	aBoolean ifFalse:		[hadFocus ifTrue:			[owner lostFocusWithoutAccepting; doneWithEdits].		^ self delete]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/17/1999 08:00'!basicWidth	"Provide a nominal minimum, exclusive of arrows and independent of label width"	^ operatorOrExpression		ifNotNil:			[3]		ifNil:			[18]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/17/1999 08:02'!minimumWidth	| aWidth |	aWidth _ self basicWidth.	upArrow ifNotNil: [aWidth _ aWidth + UpArrowAllowance].	suffixArrow ifNotNil: [aWidth _ aWidth + SuffixArrowAllowance].	^ aWidth	! !!TileMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 13:58'!abandonLabelFocus	| aLabel |	"If the receiver's label has editing focus, abandon it"	(aLabel _ self labelMorph) ifNotNil:		[aLabel hasFocus ifTrue: [self currentHand newKeyboardFocus: nil]]! !!TileMorph methodsFor: 'mouse handling' stamp: 'sw 9/15/1999 14:21'!mouseMove: evt	| aPoint label |	"See if arrows are being pressed and call arrowAction:..."	upArrow ifNotNil:		[aPoint _ evt cursorPoint.		(label _ self labelMorph) ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: 1.				self resizeToFitLabel].			^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: -1.				self resizeToFitLabel].			^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !!TileMorph methodsFor: 'arrows' stamp: 'sw 9/15/1999 15:01'!arrowAction: delta	"Figure out what to do when the up or down arrow is pressed.	May be overridden in subclasses"	| index aList |	owner ifNil: [^ self].	(type == #literal and: [literal isNumber])		ifTrue:			[self literal: literal + delta. ^ self layoutChanged.].	(type == #literal and: [literal isKindOf: Boolean])		ifTrue: [self literal: literal not.  ^ self layoutChanged].	operatorOrExpression ifNotNil:		[aList _ #(+ - * / // \\ min: max:).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[self setOperatorAndUseArrows: (aList atWrap: index + delta)].		aList _ #(< <= = ~= > >= isDivisibleBy:).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[owner firstSubmorph type = #number 				ifTrue: [self setOperator: (aList atWrap: index + delta)]				ifFalse: [self setOperator: (#(= ~=) atWrap: index - 2 + delta)]].						"Color does not understand <"			^ self acceptNewLiteral]	! !!TileMorph methodsFor: 'private' stamp: 'sw 9/17/1999 08:19'!resizeToFitLabel	|  desiredW leader myLabel suffixAllowance |	(myLabel _ self labelMorph) ifNil: [^ self].	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + (6 max: myLabel width) + 2.	suffixAllowance _  suffixArrow ifNotNil: [SuffixArrowAllowance] ifNil: [0].	self extent: ((desiredW + suffixAllowance) max: self minimumWidth) @ self class defaultH.	myLabel position: (((self right - (suffixAllowance + 3)) - myLabel width) @ (bounds top + 3)); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed.	self layoutChanged.! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 9/17/1999 08:02'!addColorSwatch	| m1 m2 desiredW |	m1 _ StringMorph new contents: 'color'.	m2 _ Morph new extent: 12@8; color: (Color r: 0.8 g: 0 b: 0).	desiredW _ m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	m2 position: (bounds center x - (m2 width // 2)) @ (m1 bottom - 1).	self addMorph: m1; addMorph: m2.	colorSwatch _ m2.! !!ColorSeerTile methodsFor: 'initialization' stamp: 'sw 9/17/1999 08:02'!initialize	| m1 m2 desiredW |	super initialize.	self removeAllMorphs.	"get rid of the parts of a regular Color tile"	type _ #operator.	operatorOrExpression _ #color:sees:.	m1 _ StringMorph contents: 'color    sees' font: ScriptingSystem fontForTiles.	m2 _ Morph new extent: 12@8; color: (Color r: 0.8 g: 0 b: 0).	desiredW _ m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 5).	m2 position: (bounds center x - (m2 width // 2) + 3) @ (bounds top + 8).	self addMorph: m1; addMorphFront: m2.	colorSwatch _ m2.	! !!NumericReadoutTile methodsFor: 'literal' stamp: 'sw 9/10/1999 16:08'!literal: anObject	literal _ anObject.	self updateLiteralLabel.	submorphs last informTarget! !!NumericReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal _ anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'sw 9/9/1999 18:13'!abandonLabelFocus	| aLabel |	"If the receiver's label has editing focus, abandon it"	(aLabel _ self labelMorph) ifNotNil:		[aLabel hasFocus ifTrue:			[aLabel contents: aLabel readFromTarget.			aLabel handsWithMeForKeyboardFocus do:				[:aHand | aHand newKeyboardFocus: nil]]]! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'sw 9/10/1999 16:06'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	upArrow ifNotNil:		[p _ evt cursorPoint.		self abandonLabelFocus.		label _ self findA: UpdatingStringMorph.		label ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue + 1).						self resizeToFitLabel].					^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue - 1).						self resizeToFitLabel].					^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !!NumericReadoutTile methodsFor: 'size' stamp: 'sw 9/17/1999 08:01'!basicWidth	^ 26! !!NumericReadoutTile methodsFor: 'size' stamp: 'sw 9/17/1999 08:18'!minimumWidth	^ 40! !!StringReadoutTile methodsFor: 'literal' stamp: 'sw 9/17/1999 08:01'!basicWidth	^ 26! !!StringReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal _ anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 9/17/1999 08:04'!basicWidth	^ 18! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 9/17/1999 08:03'!setType: aSymbol	type _ aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (self basicWidth @ TileMorph defaultH)! !!UpdatingRectangleMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/15/1999 15:31'!initialize	super initialize.	borderColor _ Color lightGray lighter ! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'sw 9/10/1999 09:59'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _  nil.	floatPrecision _ 1.	growable _ true.	stepTime _ 50.	autoAcceptOnFocusLoss _ true.	minimumWidth _ 8.	maximumWidth _ 300.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/9/1999 16:47'!autoAcceptOnFocusLoss	^ autoAcceptOnFocusLoss ~~ false! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 10:45'!autoAcceptOnFocusLoss: aBoolean	autoAcceptOnFocusLoss _ aBoolean! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/15/1999 14:57'!fitContents	| scanner newExtent |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: self fontToUse.	newExtent _ (((scanner stringWidth: contents) max: self minimumWidth) min: self maximumWidth)  @ scanner lineHeight.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed.		(owner isKindOf: TileMorph) ifTrue: [owner resizeToFitLabel]]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/10/1999 10:07'!maximumWidth	"Answer the maximum width that the receiver can have.   A nil value means no maximum, and for practical purposes results in a value of 99999 here temporarily, for help in future debugging"	^ maximumWidth ifNil: [99999]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/10/1999 09:59'!minimumWidth	"Answer the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	^ minimumWidth ifNil: [minimumWidth _ 8]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 9/15/1999 15:10'!acceptValue: aValue	| newVal |	newVal _ self acceptValueFromTarget: aValue.	self updateContentsFrom: newVal.	(owner isKindOf: TileMorph) ifTrue:		[owner resizeToFitLabel]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 9/15/1999 14:55'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target scriptPerformer perform: putSelector with: newValue.			target isMorph ifTrue: [target changed]].			self fitContents.			(owner isKindOf: TileMorph) ifTrue: [owner resizeToFitLabel]			"self growable ifTrue:				[self readFromTarget; fitContents.				owner ifNotNil:  [owner updateLiteralLabel]]"]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 9/8/1999 10:46'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus -- typically by clicking on some editable text somewhere else -- without having accepted the current edits."	self autoAcceptOnFocusLoss ifTrue: [self acceptContents]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 9/9/1999 10:58'!mouseDown: evt	(owner wantsKeyboardFocusFor: self) ifTrue:		[putSelector ifNotNil: [self launchMiniEditor: evt]]! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'sw 9/10/1999 10:09'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	format _ format.				"Weakly copied"	target _ target.					"Weakly copied"	lastValue _ lastValue veryDeepCopyWith: deepCopier.	getSelector _ getSelector.			"Weakly copied"	putSelector _ putSelector.		"Weakly copied"	floatPrecision _ floatPrecision.	"Weakly copied"	growable _ growable.			"Weakly copied"	stepTime _ stepTime.				"Weakly copied"	autoAcceptOnFocusLoss _ autoAcceptOnFocusLoss.  "Weakly copied"	minimumWidth _ minimumWidth."Weakly copied"	maximumWidth _ maximumWidth	"Weakly copied"! !!UpdatingStringMorph methodsFor: 'object fileIn' stamp: 'sw 9/9/1999 10:50'!convertbosfcefechftlgpfgs0: varDict bosfcefechftlgpfgsa0: smartRefStrm	"New variables: ('autoAcceptOnFocusLoss' )  If a non-nil value is needed, please assign it."	autoAcceptOnFocusLoss _ false! !!UpdatingStringMorph methodsFor: 'object fileIn' stamp: 'sw 9/15/1999 15:07'!convertbosfcefechftlgpfgs0: varDict bosfcefechftlgpfgsamm0: smartRefStrm	"These variables are automatically stored into the new instance ('format' 'target' 'lastValue' 'getSelector' 'putSelector' 'floatPrecision' 'growable' 'stepTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('autoAcceptOnFocusLoss' 'minimumWidth' 'maximumWidth' )  If a non-nil value is needed, please assign it."! !!UpdatingStringMorph methodsFor: 'object fileIn' stamp: 'sw 9/10/1999 10:07'!convertbosfcefechftlgpfgsa0: varDict bosfcefechftlgpfgsamm0: smartRefStrm	"These variables are automatically stored into the new instance ('format' 'target' 'lastValue' 'getSelector' 'putSelector' 'floatPrecision' 'growable' 'stepTime' 'autoAcceptOnFocusLoss' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('minimumWidth' 'maximumWidth' )  If a non-nil value is needed, please assign it."! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/9/1999 16:27'!acceptContents	super acceptContents.	"owner addName."  "recentered"	"self delete"! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/17/1999 13:41'!cancelEdits	self interimContents: target externalName.	super cancelEdits! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/7/1999 21:27'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: Color white.	super drawOn: aCanvas.! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/17/1999 13:17'!interimContents: aString	self contents: aString.	self placeContents! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/9/1999 16:16'!placeContents	| namePosition |	(owner notNil and: [owner isInWorld]) ifTrue:		[namePosition _ owner basicBox bottomCenter -			((self width // 2) @ (owner handleSize negated // 2 - 1)).		namePosition _ namePosition min: self world extent - self extent y + 2.		self bounds: (namePosition extent: self extent)]! !TileMorph removeSelector: #updateLiteralLabelClipped!NumericReadoutTile removeSelector: #literal:width:!StringReadoutTile removeSelector: #literal:width:!TileMorph class removeSelector: #defaultW!NumericReadoutTile class removeSelector: #defaultW!StringReadoutTile class removeSelector: #defaultW!UpdatingStringMorph removeSelector: #keyStroke:!"Postscript:"ScriptingSystem initializeHelpStrings.!