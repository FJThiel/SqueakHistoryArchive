'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5305] on 2 July 2003 at 10:56:34 am'!"Change Set:		CS5305Fixes-nkDate:			2 July 2003Author:			Ned Konzv2: adds a couple of methods that Brent Vukmer noticed, cleans up some more callers of Smalltalk newChanges:.This fixes a few problems and omissions in updates 5303KCP85MoveToChangeSet and KCP-0089-FixChangeSet, notably fixing some SqueakMap-related methods to refer to ChangeSet current instead of Smalltalk changes."!!ChangeSet methodsFor: 'testing' stamp: 'nk 7/2/2003 10:47'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified aSelector |	notClassified _ {'as yet unclassified' asSymbol. #all}.	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one"	| slips method aTimeStamp |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[((aTimeStamp _ Utilities timeStampForMethod: method) notNil and:							[(aTimeStamp beginsWith: myInits) not])								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass selectors includes:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 7/2/2003 09:01'!checkForConversionMethods	"See if any conversion methods are needed"	| oldStruct newStruct tell choice list needsel smart restore renamed listAdd listDrop msgSet rec nn |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list _ OrderedCollection new.	renamed _ OrderedCollection new.	self changedClasses do: [:class |		need _ (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec _ changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need _ false]]]].		need ifTrue: [need _ (self atClass: class includes: #change)].		need ifTrue: [oldStruct _ structures at: class name 									ifAbsent: [need _ false.  #()]].		need ifTrue: [			newStruct _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldStruct ~= newStruct)].		need ifTrue: [sel _ #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell _ 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | 				nn _ (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	listAdd _ self askAddedInstVars: list.	"Go through each inst var that was added"	listDrop _ self askRemovedInstVars: list.	"Go through each inst var that was removed"	list _ (listAdd, listDrop) asSet asArray.	smart _ SmartRefStream on: (RWBinaryOrTextStream on: '12345').	smart structures: structures.	smart superclasses: superclasses.	(restore _ self class current) == self ifFalse: [		self class  newChanges: self].	"if not current one"	msgSet _ smart conversionMethodsFor: list.		"each new method is added to self (a changeSet).  Then filed out with the rest."	self askRenames: renamed addTo: msgSet using: smart.	"renamed classes, add 2 methods"	restore == self ifFalse: [self class newChanges: restore].	msgSet messageList isEmpty ifTrue: [^ self].	self inform: 'Remember to fileOut again after modifying these methods.'.	MessageSet open: msgSet name: 'Conversion methods for ', self name.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 7/2/2003 10:47'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"ChangeSet current preambleTemplate"! !!CodeHolder methodsFor: 'categories' stamp: 'nk 7/2/2003 10:47'!changeCategory	"Present a menu of the categories of messages for the current class, and let the user choose a new category for the current message"	| aClass aSelector |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(aSelector _ self selectedMessageName) ifNotNil:			[(aClass letUserReclassify: aSelector) ifTrue:				["ChangeSet current reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!SARInstaller methodsFor: 'fileIn' stamp: 'nk 7/2/2003 10:47'!fileInFrom: stream
	"The zip has been saved already by the download.
	Read the zip into my instvar, then file in the correct members"

	| preamble postscript |
	[ stream position: 0.
		zip _ ZipArchive new readFrom: stream.
		preamble _ zip memberNamed: 'install/preamble'.
		preamble ifNotNil: [
			preamble contentStream ascii fileInFor: self announcing: 'Preamble'.
			ChangeSet current preambleString: preamble contents.
		].
		postscript _ zip memberNamed: 'install/postscript'.
		postscript ifNotNil: [
			postscript contentStream ascii fileInFor: self announcing: 'Postscript'.
			ChangeSet current postscriptString: postscript contents.
		].
	] ensure: [ stream close. zip _ nil. ].! !!SARInstaller methodsFor: 'private' stamp: 'nk 7/2/2003 10:48'!withCurrentChangeSetNamed: aString do: aOneArgumentBlock 
	"Evaluate the one-argument block aOneArgumentBlock while the named change set is active.
	We let the user confirm operating on an existing ChangeSet 
	or specify another ChangeSet name if 
	the name derived from the filename already exists. 
	Duplicated from SMSimpleInstaller. 
	Should be a class-side method. 
	Returns change set."

	| changeSet newName oldChanges |
	newName := aString.
	changeSet := self class changeSetNamed: newName.
	changeSet ifNotNil: 
			[newName := FillInTheBlank 
						request: 'ChangeSet already present, just confirm to overwrite or enter a new name:'
						initialAnswer: newName.
			newName isEmpty ifTrue: [self error: 'Cancelled by user'].
			changeSet := self class changeSetNamed: newName].
	changeSet ifNil: [changeSet := self class basicNewChangeSet: newName].
	changeSet 
		ifNil: [self error: 'User did not specify a valid ChangeSet name'].
	oldChanges := ChangeSet current.
	
	[ChangeSet newChanges: changeSet.
	aOneArgumentBlock value: changeSet] 
			ensure: [ChangeSet newChanges: oldChanges].
	^changeSet! !!SMSimpleInstaller methodsFor: 'services' stamp: 'nk 7/2/2003 10:48'!fileIntoChangeSetNamed: aString fromStream: stream	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| changeSet newName oldChanges |	newName _ aString.	changeSet _ SMInstaller changeSetNamed: newName.	changeSet ifNotNil: [		newName _ FillInTheBlank						request: 'ChangeSet already present, just confirm to overwrite or enter a new name:' 						initialAnswer: newName.		newName isEmpty ifTrue:[self error: 'Cancelled by user'].		changeSet _ SMInstaller changeSetNamed: newName].		changeSet ifNil:[changeSet _ SMInstaller basicNewChangeSet: newName].		changeSet ifNil:[self error: 'User did not specify a valid ChangeSet name'].		oldChanges _ ChangeSet current. 		[ChangeSet newChanges: changeSet.		stream fileInAnnouncing: 'Loading ', newName, ' into change set ''', newName, ''''.		stream close] ensure: [ChangeSet newChanges: oldChanges]! !!SMSqueakMap class methodsFor: 'bootstrap upgrade' stamp: 'nk 7/2/2003 10:48'!bootStrap	"Bootstrap upgrade. Only used when SqueakMap itself is too old to	communicate with the server. This relies on the existence of a package	called SqueakMap that is packaged as a .cs.gz."	| server set oldChanges url |	server _ self findServer.	server ifNotNil: ["Ok, found a SqueakMap server"		url _ (('http://', server, '/sm/packagebyname/squeakmap/downloadurl')				asUrl retrieveContents content) asUrl.		name _ url path last sansPeriodSuffix.		set _ SMInstaller changeSetNamed: name.		set ifNil: [set _ SMInstaller basicNewChangeSet: name].		oldChanges _ ChangeSet current.			[ChangeSet newChanges: set.		(url retrieveContents content unzipped readStream)				fileInAnnouncing: 'Loading ', name, '...']			ensure: [ChangeSet newChanges: oldChanges].	]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'bkv 7/2/2003 11:08'!makeSqueaklandRelease	"Smalltalk makeSqueaklandRelease"	"NOTE: This method assumes that 	* ALL WINDOWS HAVE BEEN CLOSED (most importantly all project 	windows) * ALL GLOBAL FLAPS HAVE BEEN DESTROYED (not just disabled) 	This method may needs to be run twice - upon the first run you will 	probably receive an error message saying 'still have obsolete 	behaviors'. Close the notifier and try again. If there are still obsolete 	behaviors then go looking for them. 	Last update: ar 8/18/2001 01:14 for Squeak 3.1"	| ss |	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.')		ifFalse: [^ self].	"Delete all projects"	Project		allSubInstancesDo: [:p | p == Project current				ifFalse: [Project deletingProject: p]].	"Fix up for some historical problem"	self systemNavigation		allObjectsDo: [:o | o isMorph				ifTrue: [o removeProperty: #undoGrabCommand]].	"Hm ... how did this come in?!!"	Smalltalk keys		do: [:x | (x class == String					and: [(Smalltalk at: x) isBehavior])				ifTrue: [Smalltalk removeKey: x]].	"Remove stuff from References"	References keys		do: [:k | References removeKey: k].	"Reset command history"	CommandHistory resetAllHistory.	"Clean out Undeclared"	Undeclared removeUnreferencedKeys.	"Reset scripting system"	StandardScriptingSystem initialize.	"Reset preferences"	Preferences chooseInitialSettings; installBrightWindowColors.	"Do a nice fat GC"	Smalltalk garbageCollect.	"Dependents mean that we're holding onto stuff"	(Object classPool at: #DependentsFields) size > 1		ifTrue: [self error: 'Still have dependents'].	"Set a few default preferences"	#(#(#honorDesktopCmdKeys #false) #(#warnIfNoChangesFile #false) #(#warnIfNoSourcesFile #false) #(#showDirectionForSketches #true) #(#menuColorFromWorld #false) #(#unlimitedPaintArea #true) #(#useGlobalFlaps #false) #(#mvcProjectsAllowed #false) #(#projectViewsInWindows #false) #(#automaticKeyGeneration #true) #(#securityChecksEnabled #true) #(#showSecurityStatus #false) #(#startInUntrustedDirectory #true) #(#warnAboutInsecureContent #false) #(#promptForUpdateServer #false) #(#fastDragWindowForMorphic #false) )		do: [:spec | Preferences setPreference: spec first toValue: spec last == #true].	"Initialize Browser (e.g., reset recent classes etc)"	Browser initialize.	"Check for Undeclared"	Undeclared isEmpty		ifFalse: [self error: 'Please clean out Undeclared'].	"Remove graphics we don't want"	ScriptingSystem deletePrivateGraphics.	"Remove a few text styles"	#(#Helvetica #Palatino #Courier )		do: [:n | TextConstants				removeKey: n				ifAbsent: []].	"Dump all player uniclasses"	Smalltalk		at: #Player		ifPresent: [:player | player				allSubclassesDo: [:cls | cls isSystemDefined						ifFalse: [cls removeFromSystem]]].	"Dump all Wonderland uniclasses"	Smalltalk		at: #WonderlandActor		ifPresent: [:wnldActor | wnldActor				allSubclassesDo: [:cls | cls isSystemDefined						ifFalse: [cls removeFromSystem]]].	"Attempt to get rid of them"	Smalltalk garbageCollect.	"Now remove larger parts"	Smalltalk discardFFI; discard3D; "discardSUnit;" discardSpeech; "discardVMConstruction; discardPWS;" discardIRC.	"Dump change sets"	ChangeSorter		removeChangeSetsNamedSuchThat: [:cs | cs name ~= ChangeSet current name].	"Clear current change set"	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	"Remove refs to old ControlManager"	ScheduledControllers _ nil.	"Flush obsolete subclasses"	Behavior flushObsoleteSubclasses.	Smalltalk garbageCollect.	Smalltalk obsoleteBehaviors isEmpty		ifFalse: [self error: 'Still have obsolete behaviors'].	"Clear all server entries"	ServerDirectory serverNames		do: [:each | ServerDirectory removeServerNamed: each].	SystemVersion current resetHighestUpdate.	ss _ Set allSubInstances.	'Rehashing all sets'		displayProgressAt: Sensor cursorPoint		from: 1		to: ss size		during: [:bar | 1				to: ss size				do: [:i | 					bar value: i.					(ss at: i) rehash]].	Smalltalk obsoleteClasses isEmpty		ifFalse: [self halt].	self halt: 'Ready to condense changes or sources'.	SystemDictionary removeSelector: #makeSqueaklandRelease! !!Environment class methodsFor: 'system conversion' stamp: 'nk 7/2/2003 08:59'!reorganizeEverything	"Undertake a grand reorganization.	Environment reorganizeEverything.	"	| bigCat envt pool s |	"First check for clashes between environment names and existing globals..."	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			[(Smalltalk includesKey: bigCat) ifTrue:				[^ self error: bigCat , ' cannot be used to nameboth a package and a class or other global variable.No reorganization will be attempted.']]].	(self confirm:'Your image is about to be partitioned into environments.Many things may not work after this, so you should beworking in a throw-away copy of your working image.Are you really ready to procede?(choose ''no'' to stop here safely)')		ifFalse: [^ self inform: 'No changes were made'].	ChangeSet  newChanges: (ChangeSet basicNewNamed: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	ChangeSet newChanges: (ChangeSet basicNewNamed: 'PostReorganization').	ChangeSorter initialize.	Preferences enable: #browserShowsPackagePane.! !!TheWorldMenu methodsFor: 'construction' stamp: 'nk 7/2/2003 10:54'!changesMenu        "Build the changes menu for the world."        | menu |        menu _ self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { Utilities . #fileOutChanges}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.                { 'find recent submissions (R)' . { #myWorld . #openRecentSubmissionsBrowser:}.                                'Make an open recent-submissions browser be the front-window, expanding a collapsed one or creating a new one if necessary.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted, latest first.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions at the top of the browser.'}.			nil.                { 'recently logged changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' . {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' . {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.                }.        ].        ^ menu! !