'From Squeak2.8alpha of 13 January 2000 [latest update: #1948] on 22 March 2000 at 7:22:57 pm'!!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 3/22/2000 14:23'!printOn: aStream	"Try to report the name of the project"	globalObjectName == #Project ifFalse: [^ super printOn: aStream].	constructorArgs size > 0 ifFalse: [^ super printOn: aStream].	constructorArgs first class == String ifFalse: [^ super printOn: aStream].	aStream nextPutAll: constructorArgs first, ' (on server)'! !!Project methodsFor: 'file in/out' stamp: 'tk 3/22/2000 19:12'!fromMyServerLoad: otherProjectName	| servers pair pr strm |	"If a newer version of me is on the server, load it."	(pr _ Project named: otherProjectName) ifNotNil: ["it appeared"		^ pr enter].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 			'Current project does not know a server either.'].	pair _ self class mostRecent: otherProjectName onServer: servers first.	pair first ifNil: [^ self inform: 'Can''t find file on server for ', otherProjectName].	strm _ servers first oldFileNamed: pair first.	self installRemoteFrom: strm named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'tk 3/22/2000 19:11'!installRemoteFrom: strm named: otherProjectName	| pvm projViewer dp is proj |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	self world submorphsDo: [:sub | 		(sub isKindOf: SystemWindow) ifTrue: [			(pvm _ sub findA: ProjectViewMorph) ifNotNil: [				(pvm project class == DiskProxy and: 					[pvm project constructorArgs first = otherProjectName])						ifTrue: [projViewer _ pvm]]].		(sub isKindOf: ProjectViewMorph) ifTrue: [				((dp _ sub project) class == DiskProxy and: 					[dp constructorArgs first = otherProjectName])						ifTrue: [projViewer _ sub]].		].	projViewer 		ifNotNil: [is _ strm asUnZippedStream fileInObjectAndCode.			(is isKindOf: ImageSegment) ifTrue: [				proj _ is arrayOfRoots detect: [:mm | mm class == Project] 							ifNone: [nil].				proj ifNotNil: [proj versionFrom: strm.					proj setParent: Project current.					(projViewer owner isKindOf: SystemWindow) ifTrue: [						projViewer owner model: proj].					^ projViewer project: proj]]]		ifNil: [(SelectionMenu confirm: 'No old thumbnail found. Debug?') 					ifTrue: [self halt]].	"replace with a new one"	ProjectViewMorph openFromFile: strm.		"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'tk 3/22/2000 14:13'!storeOnServer	| servers pair newVersion resp newName local folder |	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	"write locally"	self exportSegment.	(FileStream oldFileNamed: self name, '.pr') compressFile.	"Find out what version"	(servers _ self serverList) isEmpty 		ifTrue: [folder _ PluggableFileList getFolderDialog openLabel:					 'Select a folder on a server:'.			folder ifNil: [^ self].			servers _ Array with: folder.			urlList _ Array with: folder realUrl.			pair _ Array with: nil with: -1]		ifFalse: [pair _ self class mostRecent: self name onServer: servers first].	(newVersion _ self newVersion: pair) ifNil: [^ self].	newName _ self name, '|', newVersion, '.pr'.	local _ FileStream oldFileNamed: self name, '.pr.gz'.	resp _ servers first putFile: local named: newName retry: false.	resp ifFalse: [self inform: 'the primary server of this project seems to be down'.  ^ self].	version _ newVersion.	"committed"	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."	"Rename disk file to be the final name"	local reset.	FileDirectory default rename: local localName toBe: newName.! !!Project class methodsFor: 'squeaklet on server' stamp: 'tk 3/22/2000 15:00'!mostRecent: projName onServer: aServerDirectory	| stem list max goodName triple num stem1 stem2 rawList |	"Find the exact fileName of the most recent version of project with the stem name of projName.  Names are of the form 'projName|mm.pr' where mm is a mime-encoded integer version number.	File names may or may not be HTTP escaped, %20 on the server."	stem _ (projName unescapePercents findTokens: '|.') first, '|'.	"strip it first"	rawList _ aServerDirectory fileNames.	rawList class == String ifTrue: [^ self inform: 'server is unavailable'].	list _ rawList collect: [:nnn | nnn unescapePercents].	max _ -1.  goodName _ nil.	list withIndexDo: [:aName :ind |		(aName beginsWith: stem) ifTrue: [			(triple _ aName findTokens: '|.') size >= 3 ifTrue: [				num _ Base64MimeConverter decodeInteger: triple second unescapePercents.				num > max ifTrue: [max _ num.  goodName _ (rawList at: ind)]]]].	max = -1 ifTrue: ["try with underbar for spaces on server"		(stem includes: $ ) ifTrue: [			stem1 _ stem copyReplaceAll: ' ' with: '_'.			list withIndexDo: [:aName :ind |				(aName beginsWith: stem1) ifTrue: [					(triple _ aName findTokens: '|.') size >= 3 ifTrue: [						num _ Base64MimeConverter decodeInteger: triple second unescapePercents.						num > max ifTrue: [max _ num.  goodName _ (rawList at: ind)]]]]]].	max = -1 ifTrue: ["try without the marker | "		stem1 _ stem allButLast, '.pr'.		stem2 _ stem1 copyReplaceAll: ' ' with: '_'.	"and with spaces replaced"		list withIndexDo: [:aName :ind |			(aName beginsWith: stem1) | (aName beginsWith: stem2) ifTrue: [				(triple _ aName findTokens: '.') size >= 2 ifTrue: [					max _ 0.  goodName _ (rawList at: ind)]]]].	"no other versions"	^ Array with: goodName with: max! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'tk 3/22/2000 18:59'!enter	"Enter my project."	project class == DiskProxy ifTrue: ["When target is not in yet"		project enter: false revert: false saveForRevert: false.	"will bring it in"		project class == DiskProxy ifTrue: [self error: 'Could not find view']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showBorderAs: Color gray.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'tk 3/22/2000 17:27'!project: aProject	project _ aProject! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'tk 3/22/2000 16:37'!openFromFile: preStream	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |	morphOrList _ preStream asUnZippedStream fileInObjectAndCode.	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [proj versionFrom: preStream.			window _ (SystemWindow labelled: proj name) model: proj.			window				addMorph: (self on: proj)				frame: (0@0 corner: 1.0@1.0).			window openInWorld.			proj setParent: Project current.			^ proj enter]].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'].	(window _ self newMorphicProjectOn: morphOrList) openInWorld.	window model enter! !!ReadWriteStream methodsFor: 'converting' stamp: 'tk 3/22/2000 18:03'!asUnZippedStream	| isGZip outputStream first |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else."	self binary.	first _ self next.	isGZip _ (self next * 256 + first) = (GZipConstants at: #GZipMagic).	self skip: -2.	isGZip 		ifTrue: [outputStream _ (RWBinaryOrTextStream with:					(GZipReadStream on: self) upToEnd) reset.				self close]		ifFalse: [outputStream _ self].	^ outputStream! !StandardFileStream removeSelector: #asUnZippedStream!