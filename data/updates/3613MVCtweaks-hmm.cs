'From Squeak3.1alpha of 5 February 2001 [latest update: #3611] on 16 February 2001 at 7:46:37 am'!"Change Set:		MVCtweaks-hmmDate:			9 February 2001Author:			Hans-Martin Mosner <hmm@heeg.de>Update: Fixes indenting in Morphic as well, now.Fixes 3 issues:1. Selecting after the last blank in a line would not work if the blank crosses the right margin2. Indenting was seriously broken3. TextAction feedback would only highlight up to the next-to-last character in the range.In addition, speeds up text display in a number of cases, and utilizes deferred updating in MVC to achieve much smoother displaying on slowish machines.Here is some further clarification of the issues involved:> 1. Tell me what 'Indenting was seriously broken' means so I can see for myself.Ok, you see it when you display text that uses the TextIndent attribute. The following shows the effect both in MVC and in Morphic:    indented := 'not indented\' withCRs asText,    (Text string: 'indented 1\' withCRs attribute: (TextIndent tabs: 1)),    (Text string: 'indented 2\' withCRs attribute: (TextIndent tabs: 2)).    Clipboard clipboardText: indented.Execute it, and paste the clipped text into a workspace. The TextIndent attribute should make the second and third line be indented by 1 or 2 tabs, respectively (if it would work correctly). Note that selecting text within the second and third line looks wrong, too (you can select past the line's end, for example)...After the fixes are filed in, display and selection are exactly as intended.> 2. Tell me how to run the tests in SCAN-Tests.st.Execute (TestModel open) in MVC, or (TestModel openAsMorph) in Morphic. Run the tests. Without the fixes, 3 of the unit tests show test failures. With the fixes, all tests pass. Note that the unit tests do not cover all fixed situations; the indenting bit is only tested within the MVC environment (with Paragraph) and not with NewParagraph. But the problem was existent in NewParagraph as well (as you've seen with the indenting example) and is fixed, too.> 3. Tell me what, if any, changes one would expect to see in Morphic.For example, if you view a page containing bulleted lists in Scamper, these should be properly indented by now. Note that Scamper itself does not do a very good job at rendering these; they would look better if the bullets were moved to the left of the indented paragraphs, as other WWW browser do it. I have a fix for that, too, but did not include it because it is not really a fix for the mechanism."!Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox '	classVariableNames: 'DisplayChangeSignature OuterMorphicWorld ScreenSave DeferringUpdates '	poolDictionaries: ''	category: 'Graphics-Display Objects'!TestCase subclass: #TestIndenting	instanceVariableNames: 'para '	classVariableNames: ''	poolDictionaries: ''	category: 'SCAN-Tests'!TestCase subclass: #TestParagraphFix	instanceVariableNames: 'para '	classVariableNames: ''	poolDictionaries: ''	category: 'SCAN-Tests'!!TestParagraphFix commentStamp: '<historical>' prior: 0!This class tests whether locating characters past the end of a text is possible in all cases.!TestParagraphFix subclass: #TestNewParagraphFix	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCAN-Tests'!!TestNewParagraphFix commentStamp: '<historical>' prior: 0!This class tests the same things as its superclass, but for NewParagraph which is used in the Morphic environment.!!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/15/2000 22:40'!handleIndentation	self indentationLevel timesRepeat: [		self plainTab]! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/15/2000 22:41'!plainTab	"This is the basic method of adjusting destX for a tab."	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/14/2000 16:07'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'hmm 2/2/2001 15:27'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ nextLeftMargin @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'hmm 2/2/2001 14:59'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex _ characterIndex.			characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	textStyle alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab _ true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab _ false]].	(textStyle alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!CharacterBlockScanner methodsFor: 'private' stamp: 'hmm 2/1/2001 16:20'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop _ line last  "characterBlockAtPoint"]		ifFalse:	[lineStop _ characterIndex  "characterBlockForIndex"].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	self handleIndentation.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'hmm 2/2/2001 15:07'!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin _ leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin _ textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 2/9/2001 11:55'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	spaceCount _ 0.	self handleIndentation.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 7/20/2000 18:24'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!DisplayMedium methodsFor: 'displaying' stamp: 'hmm 9/16/2000 21:27'!deferUpdatesIn: aRectangle while: aBlock	"DisplayScreen overrides with something more involved..."	^aBlock value! !!DisplayScanner methodsFor: 'scanning' stamp: 'hmm 9/20/2000 12:54'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!DisplayScanner methodsFor: 'private' stamp: 'hmm 9/16/2000 21:29'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (aParagraph foregroundColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: clippingRectangle.! !!DisplayScanner methodsFor: 'private' stamp: 'hmm 9/16/2000 21:29'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!plainTab	| oldX |	oldX _ destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!tab	self plainTab.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'quick print' stamp: 'hmm 9/20/2000 11:44'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	lastIndex _ 1.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: bitBlt clipX + bitBlt clipWidth + font maxWidth		stopConditions: stopConditions kern: kern.	font displayString: aString on: bitBlt from: 1 to: lastIndex at: aPoint kern: kern.! !!DisplayScanner methodsFor: 'quick print' stamp: 'hmm 2/1/2001 16:24'!stringWidth: aString	"Answer the width of the given string."	destX _ destY _ 0.	aString ifNil: [^ 0].	lastIndex _ 1.		"else the prim will fail"	self scanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		kern: kern.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:16'!deferUpdates: aBoolean	| wasDeferred |	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer whether updates were deferred before if the primitive succeeds, nil if it fails."	wasDeferred _ DeferringUpdates == true.	DeferringUpdates _ aBoolean.	^(self primitiveDeferUpdates: aBoolean) ifNotNil: [wasDeferred]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 2/2/2001 10:14'!deferUpdatesIn: aRectangle while: aBlock	| result |	(self deferUpdates: true) ifTrue: [^aBlock value].	result _ aBlock value.	self deferUpdates: false.	self forceToScreen: aRectangle.	^result! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:14'!primitiveDeferUpdates: aBoolean	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer the receiver if the primitive succeeds, nil if it fails."	<primitive: 126>	^ nil  "answer nil if primitive fails"! !!NewParagraph methodsFor: 'editing' stamp: 'hmm 7/17/2000 10:55'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[	"			range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint].					*This doesn't work in morphic*				Need to replace by a highlighting morph that waits for moueUp.				Utilities awaitMouseUpIn: (editor transform invertRect: box)						repeating: []						ifSucceed: [(att actOnClickFor: model) ifTrue: [action _ true]].	"				(target _ model) ifNil: [target _ editor morph].				(att actOnClickFor: target)					ifTrue: [Sensor waitNoButton.  "FIX THIS"							action _ true]]].	^ action! !!Paragraph methodsFor: 'selecting' stamp: 'hmm 7/17/2000 10:55'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex forStyle: textStyle.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model) ifTrue: [action _ true]]]]].	^ action! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max _ 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min _ 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount _ ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!TestIndenting methodsFor: 'running' stamp: 'hmm 2/2/2001 14:29'!setUp	| text |	text _ 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	para _ text asParagraph! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:42'!testBreak1	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para compositionRectangle: (0@0 extent: para width - 1@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:45'!testBreak2	"When an indented line is broken at a space, the character block must still lie in the line crossing the right margin."	| cb |	para compositionRectangle: (0@0 extent: para width - 24 // 2 + 24@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 7.	self assert: cb top = 0.	self assert: cb left >= 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR2	"Checks whether the drawing of indented text is really indented..."	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: (para asForm copy: (0@cb top extent: 24@cb height)) isAllWhite! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 15:17'!testCR3	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 11 to: 11 with: (Text string: (String with: Character cr) attribute: (TextIndent tabs: 1)) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 12.	self assert: cb top > 0.	self assert: cb left = 24! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:52'!testCharacterBlockAfterReplacingAll	para replaceFrom: 1 to: 3 with: 'mmm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingOther	para replaceFrom: 3 to: 3 with: 'm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingSpace	para replaceFrom: 3 to: 3 with: ' ' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockNormal	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para _ 'i i' asParagraph! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingAll	^super testCharacterBlockAfterReplacingAll! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingOther	^super testCharacterBlockAfterReplacingOther! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingSpace	^super testCharacterBlockAfterReplacingSpace! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:43'!testCharacterBlockNormal	^super testCharacterBlockNormal! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph _ TextMorph new contents: 'i i'.	morph fit.	para _ morph paragraph! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!leftMargin	"This has to get fixed -- store during composition"	^ self left! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!leftMargin: lm	left _ lm! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!rectangle: lineRectangle	left _ lineRectangle left.	right _ lineRectangle right.	top _ lineRectangle top.	bottom _ lineRectangle bottom! !!View methodsFor: 'displaying' stamp: 'hmm 6/27/2000 07:07'!display	"Display the receiver's border, display the receiver, then display the 	subViews of the receiver. Can be sent to the top View of a structured 	picture in order to display the entire structure, or to any particular View 	in the structure in order to display that View and its subViews. It is 	typically sent in response to an update request to a View."	Display deferUpdatesIn: self displayBox while: [		self displayBorder.		self displayView.		self displaySubViews]! !!StringHolderView methodsFor: 'displaying' stamp: 'hmm 6/18/2000 19:24'!displayView 	"Refer to the comment in View|displayView."	Display deferUpdatesIn: self displayBox while: [		self clearInside.		(self controller isKindOf: ParagraphEditor)			ifTrue: [controller display]			ifFalse: [displayContents display]]! !Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox '	classVariableNames: 'DeferringUpdates DisplayChangeSignature OuterMorphicWorld ScreenSave '	poolDictionaries: ''	category: 'Graphics-Display Objects'!