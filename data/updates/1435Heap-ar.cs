'From Squeak 2.5 of August 6, 1999 on 10 September 1999 at 2:14:10 pm'!"Change Set:		Heap-arDate:			10 September 1999Author:			Andreas RaabThis change set adds class Heap. See the examples protocol for a speed comparison with SortedCollection."!SequenceableCollection subclass: #Heap	instanceVariableNames: 'array tally sortBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!Heap class	instanceVariableNames: ''!!Collection class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 13:20'!withAll: aCollection	"Create a new collection containing all the elements from aCollection"	^(self new: aCollection size)		addAll: aCollection;		yourself! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 13:29'!withAll: aCollection	"Create a new collection containing all the elements from aCollection"	^(self new: aCollection size)		replaceFrom: 1 to: aCollection size with: aCollection startingAt: 1;		yourself! !!Heap commentStamp: 'ar 9/10/1999 13:11' prior: 0!Class Heap implements a special data structure commonly referred to as 'heap'. Heaps are more efficient than SortedCollections if:a) Elements are only removed at the beginningb) Elements are added with arbitrary sort order.The sort time for a heap is O(n log n) in all cases.Instance variables:	array		<Array>		the data repository	tally		<Integer>	the number of elements in the heap	sortBlock	<Block|nil>	a two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]!!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 13:02'!at: index	"Return the element at the given position within the receiver"	(index < 1 or:[index > tally]) ifTrue:[^self errorSubscriptBounds: index].	^array at: index! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:14'!at: index put: newObject	"Heaps are accessed with #add: not #at:put:"	^self shouldNotImplement! !!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 13:02'!first	"Return the first element in the receiver"	self emptyCheck.	^array at: 1! !!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 14:08'!reSort	"Resort the entire heap"	self isEmpty ifTrue:[^self].	tally // 2 to: 1 by: -1 do:[:i| self downHeap: i].! !!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 13:02'!size	"Return the number of elements in the receiver"	^tally! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock	^sortBlock! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock: aBlock	sortBlock _ aBlock.	sortBlock fixTemps.	self reSort.! !!Heap methodsFor: 'testing' stamp: 'ar 9/10/1999 13:03'!isEmpty	"Answer whether the receiver contains any elements."	^tally = 0! !!Heap methodsFor: 'testing' stamp: 'ar 9/10/1999 13:03'!sorts: element1 before: element2	"Return true if element1 should be sorted before element2.	This method defines the sort order in the receiver"	^sortBlock == nil		ifTrue:[element1 <= element2]		ifFalse:[sortBlock value: element1 value: element2].! !!Heap methodsFor: 'adding' stamp: 'ar 9/10/1999 13:04'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally _ tally + 1) put: anObject.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:04'!remove: oldObject ifAbsent: aBlock	"Remove oldObject as one of the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject."	1 to: tally do:[:i| 		(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].	^aBlock value! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:05'!removeAt: index	"Remove the element at given position"	(index < 1 or:[index > tally]) ifTrue:[^self errorSubscriptBounds: index].	^self privateRemoveAt: index! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:05'!removeFirst	"Remove the first element from the receiver"	^self removeAt: 1! !!Heap methodsFor: 'comparing' stamp: 'ar 9/10/1999 13:05'!= aHeap	"Answer true if my and aHeap's species are the same,	and if our blocks are the same, and if our elements are the same."	self species = aHeap species ifFalse: [^ false].	sortBlock = aHeap sortBlock		ifTrue: [^ super = aHeap]		ifFalse: [^ false]! !!Heap methodsFor: 'enumerating' stamp: 'ar 9/10/1999 13:05'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: tally do:[:i| aBlock value: (array at: i)]! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:17'!grow	"Become larger."	self growTo: self size + self growSize.! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growSize	"Return the size by which the receiver should grow if there are no empty slots left."	^array size max: 5! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growTo: newSize	"Grow to the requested size."	| newArray |	newArray _ Array new: (newSize max: tally).	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!trim	"Remove any empty slots in the receiver."	self growTo: self size.! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j _ j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n _ k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					"and try again with j"					k _ j]].	array at: k put: value.! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j _ j + 1].		array at: k put: (array at: j).		"and try again with j"		k _ j].	array at: k put: value.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k _ anIndex.	value _ array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp _ array at: (kDiv2 _ k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			k _ kDiv2].	array at: k put: value.! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:19'!array	^array! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:36'!privateRemoveAt: index	"Remove the element at the given index and make sure the sorting order is okay"	| removed |	removed _ array at: index.	array at: index put: (array at: tally).	array at: tally put: nil.	tally _ tally - 1.	"Use #downHeapSingle: since only one element has been removed"	self downHeapSingle: index.	^removed! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:35'!setCollection: aCollection	array _ aCollection.	tally _ 0.! !!Heap methodsFor: 'private' stamp: 'ar 9/10/1999 13:18'!setCollection: aCollection tally: newTally	array _ aCollection.	tally _ newTally.! !!Heap class methodsFor: 'instance creation' stamp: 'ar 7/1/1999 04:20'!new	^self new: 10! !!Heap class methodsFor: 'instance creation' stamp: 'ar 7/1/1999 04:20'!new: n	^super new setCollection: (Array new: n)! !!Heap class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 14:13'!sortBlock: aBlock	"Create a new heap sorted by the given block"	^self new sortBlock: aBlock! !!Heap class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 13:23'!withAll: aCollection	"Create a new heap with all the elements from aCollection"	^(self basicNew)		setCollection: aCollection asArray copy tally: aCollection size;		reSort;		yourself! !!Heap class methodsFor: 'examples' stamp: 'ar 9/10/1999 14:07'!heapExample	"Heap heapExample"	"Create a sorted collection of numbers, remove the elements	sequentially and add new objects randomly.	Note: This is the kind of benchmark a heap is designed for."	| n rnd array time sorted |	n _ 5000. "# of elements to sort"	rnd _ Random new.	array _ (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time _ Time millisecondsToRun:[		sorted _ Heap withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for Heap: ', time printString,' msecs'.	"The quicksort version"	time _ Time millisecondsToRun:[		sorted _ SortedCollection withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for SortedCollection: ', time printString,' msecs'.! !!Heap class methodsFor: 'examples' stamp: 'ar 9/10/1999 13:32'!heapSortExample	"Heap heapSortExample"	"Sort a random collection of Floats and compare the results with	SortedCollection (using the quick-sort algorithm) and 	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."	| n rnd array out time sorted |	n _ 10000. "# of elements to sort"	rnd _ Random new.	array _ (1 to: n) collect:[:i| rnd next].	"First, the heap version"	out _ Array new: n. "This is where we sort into"	time _ Time millisecondsToRun:[		sorted _ Heap withAll: array.		1 to: n do:[:i| sorted removeFirst].	].	Transcript cr; show:'Time for heap-sort: ', time printString,' msecs'.	"The quicksort version"	time _ Time millisecondsToRun:[		sorted _ SortedCollection withAll: array.	].	Transcript cr; show:'Time for quick-sort: ', time printString,' msecs'.	"The merge-sort version"	time _ Time millisecondsToRun:[		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].	].	Transcript cr; show:'Time for merge-sort: ', time printString,' msecs'.! !