'From Squeak2.8alpha of 19 January 2000 [latest update: #2299] on 7 June 2000 at 9:21:36 pm'!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'JMM 6/7/2000 16:07'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode macArchiveBinaryFile asByteArray		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'platform.exports') contentsOfEntireFile =	InterpreterSupportCode squeakPlatformExportsFile		ifFalse: [self inform: 'File platform.exports differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqADPCMPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakADPCMCodecPrimsFile		ifFalse: [self inform: 'File sqADPCMPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqGSMCodecPlugin.c') contentsOfEntireFile =	InterpreterSupportCode squeakGSMCodecPluginFile		ifFalse: [self inform: 'File sqGSMCodecPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNSPlugin.c') contentsOfEntireFile =	InterpreterSupportCode macBrowserPluginFile		ifFalse: [self inform: 'File sqMacNSPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystickAndTablet.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickAndTabletFile		ifFalse: [self inform: 'File sqMacJoystickAndTablet.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqNamedPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakNamedPrimsFile		ifFalse: [self inform: 'File sqNamedPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.h') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineHeaderFile		ifFalse: [self inform: 'File sqVirtualMachine.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.c') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineFile		ifFalse: [self inform: 'File sqVirtualMachine.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 21:21'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		ParagraphEditor clipboardTextPut: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 94 52 0 0 0 114 0 7 0 0 0 114 84 133 0 59 1 193 1 40 3 188 0 0 0 0 0 0 165 165 165 165 1 0 0 71 0 0 180 207 51 128 181 83 210 11 0 0 0 0 0 0 2 93 0 0 0 0 0 23 113 171 0 0 0 0 0 0 0 0 0 0 0 0 0 0 68 79 76 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 149 220 114 115 114 99 82 83 69 68 1 0 4 47 0 123 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 188 0 0 1 114 0 0 0 0 15 0 66 193 213 7 19 227 116 139 95 155 18 214 234 25 52 230 57 114 110 6 58 195 129 208 199 140 96 212 93 151 132 73 91 131 251 245 55 183 136 243 98 82 57 86 63 83 175 12 168 0 248 223 201 189 17 113 105 28 167 98 162 142 153 174 139 23 194 108 91 26 165 117 158 188 22 21 19 14 216 241 61 228 74 125 240 96 248 234 190 228 99 237 97 182 103 71 34 88 225 33 111 207 60 209 188 253 113 228 167 43 111 96 4 23 183 107 37 122 242 22 112 114 81 107 4 94 205 249 245 232 16 59 239 175 78 116 180 226 206 206 181 80 2 217 231 169 2 227 33 85 101 251 25 116 158 54 133 6 10 51 142 59 115 246 167 211 221 45 41 106 69 11 149 173 61 112 179 207 25 232 26 184 202 16 216 113 218 242 63 115 142 164 254 242 220 93 244 55 45 253 36 65 238 52 146 24 235 82 94 205 193 97 66 105 48 102 113 116 35 35 175 237 16 76 201 38 110 199 113 114 213 25 236 149 114 27 247 197 5 44 214 98 25 94 255 161 95 253 125 161 98 159 224 234 74 251 241 176 255 187 17 63 45 96 1 231 254 64 13 177 201 33 130 124 179 12 211 215 239 38 224 212 185 131 116 27 56 159 130 127 19 40 242 132 106 153 187 22 231 23 73 71 130 117 108 201 50 192 85 200 107 72 232 200 161 250 43 101 144 229 19 171 53 49 126 41 150 21 115 100 123 35 143 220 91 157 84 226 218 75 52 142 65 201 141 5 113 176 105 98 123 112 117 3 9 146 26 153 229 217 67 152 114 210 119 71 17 81 122 112 165 165 165 165 1 0 0 68 0 0 180 207 51 128 181 83 204 37 0 0 0 114 0 0 4 43 0 0 0 0 0 20 243 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 4 93 114 115 114 99 82 83 69 68 1 0 4 110 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 161 0 0 1 88 0 0 0 0 15 0 66 193 212 234 64 104 180 215 220 249 147 34 27 2 118 105 161 219 86 224 222 226 23 143 199 139 89 209 134 209 116 41 175 96 124 66 224 138 85 193 72 9 35 91 108 160 132 35 140 74 36 213 183 96 18 215 239 111 29 214 220 104 189 29 207 88 65 22 22 43 215 109 33 216 193 9 5 40 16 225 30 50 18 236 223 145 176 171 159 197 117 142 252 91 13 2 98 6 190 187 103 238 237 153 129 78 73 166 125 115 174 76 86 165 114 66 208 107 39 252 213 67 137 183 130 157 251 211 106 103 158 47 184 51 245 253 44 61 181 127 43 227 173 42 245 142 154 6 40 60 3 226 147 151 103 253 57 106 246 156 126 33 230 39 182 12 8 84 113 130 107 247 229 69 207 81 166 208 193 166 142 255 109 150 111 17 228 45 199 31 51 5 156 9 58 102 45 251 211 113 50 186 233 86 247 118 72 27 153 238 11 123 11 35 106 201 204 39 12 116 60 178 235 196 88 111 247 59 209 65 38 38 224 108 147 250 111 85 97 92 123 84 111 206 131 191 247 227 146 39 141 214 58 170 4 129 228 177 134 62 195 224 230 58 83 88 238 199 26 23 166 99 196 147 12 42 70 63 217 123 184 136 245 17 228 193 103 192 92 169 146 255 189 21 204 2 101 143 80 145 226 114 58 220 100 137 205 68 168 151 219 242 61 209 178 142 41 134 161 124 188 10 203 250 173 252 120 237 212 223 20 221 78 20 149 137 247 218 174 89 208 254 56 48 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 2 93 0 0 16 216 0 0 0 0 0 13 24 181 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 186 192 77 77 80 82 67 87 73 69 1 0 4 47 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 4 43 0 0 29 39 0 0 0 0 0 16 129 11 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 220 45 77 77 80 82 67 87 73 69 1 0 4 110 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 62 0 0 172 94 90 110 181 100 107 240 0 0 16 216 0 0 49 165 0 0 0 0 0 14 69 11 0 0 61 146 0 0 11 65 0 0 0 0 15 0 83 113 117 101 97 107 54 56 75 46 112 114 111 106 0 1 11 252 77 77 80 82 67 87 73 69 1 0 4 173 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 42 61 0 0 8 205 0 0 0 0 15 0 66 193 213 32 209 31 45 72 8 195 90 187 142 178 38 179 18 58 241 193 130 49 135 38 109 111 89 180 169 14 69 179 241 1 247 102 220 179 38 220 26 67 94 150 167 235 230 230 251 208 18 175 29 181 92 67 149 190 181 66 195 161 55 50 158 229 105 254 152 54 10 119 44 10 220 166 193 204 241 213 52 3 218 223 205 244 70 146 168 183 35 37 161 189 123 69 120 161 49 40 218 48 102 77 184 67 80 67 141 137 102 170 143 195 150 51 30 115 86 21 161 234 62 138 154 132 184 124 42 27 145 150 73 30 104 220 146 116 99 230 105 128 114 227 255 231 126 96 180 15 38 99 6 244 7 35 49 236 147 50 24 92 129 196 241 22 220 95 139 161 143 156 138 42 181 100 179 72 191 47 51 28 117 30 37 155 214 189 66 38 218 112 195 72 84 235 22 126 136 53 187 250 65 156 74 89 221 147 200 213 15 165 0 45 34 183 225 132 130 129 142 42 52 114 221 85 113 27 132 231 1 182 204 140 180 236 247 131 97 96 112 98 40 41 166 157 9 15 56 8 137 193 143 86 172 133 63 87 104 101 181 92 175 116 163 214 154 254 132 120 29 76 89 98 57 205 186 193 252 195 27 201 196 241 163 155 128 83 178 244 4 219 38 142 183 98 48 143 200 194 63 129 44 36 174 16 255 94 135 152 239 154 162 138 219 9 101 170 176 91 193 74 21 122 185 49 147 71 204 139 87 142 3 77 96 160 199 149 184 39 55 248 18 20 121 223 0 141 111 121 44 200 188 88 14 122 147 55 73 37 203 209 206 239 84 99 51 82 112 42 250 150 40 176 250 244 42 64 32 60 71 49 70 149 214 79 160 255 32 127 186 178 42 65 38 241 193 227 33 212 40 122 185 51 206 236 172 38 91 146 237 130 250 75 213 240 34 24 69 155 14 234 56 9 36 133 86 148 163 113 161 62 34 21 107 61 83 83 105 163 121 74 163 94 146 19 28 236 87 102 49 249 42 71 220 233 194 212 203 14 61 79 213 162 91 28 202 49 61 42 75 61 192 211 233 180 187 30 233 28 30 103 203 222 146 25 108 214 89 16 247 225 51 151 47 140 24 0 105 130 212 208 23 95 233 154 157 0 251 22 227 176 80 18 20 3 173 90 59 44 174 180 76 238 71 137 55 2 65 12 148 213 3 99 216 50 91 152 253 65 125 181 119 135 187 0 152 60 221 16 31 151 15 122 20 5 199 114 249 118 175 120 196 41 250 224 145 230 195 174 249 196 214 98 61 151 60 248 191 187 202 205 237 48 65 144 106 104 19 183 202 188 67 48 244 209 77 69 33 62 183 61 19 212 41 82 93 66 169 148 205 49 12 235 42 171 81 121 85 99 89 86 167 245 252 120 62 165 221 54 238 96 194 140 110 114 41 218 162 138 9 19 154 130 26 134 63 115 56 132 255 122 233 193 169 110 109 103 118 143 214 238 42 149 120 222 144 22 59 69 56 17 92 177 246 123 128 104 6 168 248 90 225 203 223 35 225 216 154 113 26 49 194 252 170 222 250 58 172 118 165 237 71 202 114 56 194 253 52 69 58 230 176 189 193 230 235 131 248 12 110 89 37 209 190 51 188 3 205 145 234 149 51 178 72 3 37 61 237 230 24 101 47 101 223 239 1 195 163 8 25 182 91 208 153 217 185 168 22 74 69 109 213 42 184 225 86 39 194 53 200 94 236 161 38 194 187 198 185 193 52 110 185 114 251 209 162 73 93 140 155 176 186 120 136 42 33 154 169 248 16 162 55 57 199 16 246 179 62 219 204 221 80 217 107 16 207 155 20 78 54 255 154 82 248 227 179 230 20 39 104 231 59 14 102 178 171 76 138 72 97 127 240 1 244 49 124 128 17 239 82 21 242 35 42 66 181 105 184 144 107 25 102 43 107 171 146 199 45 57 161 224 121 194 41 123 142 44 221 201 23 192 98 147 103 247 205 198 122 27 65 54 15 139 38 103 134 212 247 124 141 208 29 243 141 72 189 53 105 80 119 25 211 196 32 100 9 250 185 198 190 55 114 21 107 172 214 37 217 64 158 144 36 74 124 112 186 43 128 156 41 98 239 52 116 186 89 96 254 76 165 18 117 117 139 56 177 212 192 34 219 113 83 78 238 115 24 37 43 218 29 248 212 87 156 9 202 126 57 50 165 46 71 112 230 16 25 172 169 224 203 183 201 252 67 173 42 121 219 223 106 228 182 78 186 115 116 28 175 174 163 176 180 212 164 70 28 43 234 108 64 50 192 77 240 15 94 33 29 52 37 235 66 248 81 252 38 149 202 191 230 132 187 28 119 101 7 24 222 43 4 61 137 241 70 148 65 36 43 50 244 144 50 36 29 225 184 231 175 146 43 106 160 221 192 181 176 68 230 205 242 249 6 231 73 182 253 70 94 56 251 10 73 120 108 30 22 222 116 152 175 236 26 110 202 69 163 6 214 169 124 77 24 29 176 23 139 29 2 214 223 148 79 94 191 151 158 81 49 68 109 239 151 153 102 42 87 71 174 83 60 224 214 48 137 130 228 203 118 148 53 109 18 18 158 10 28 223 42 155 241 41 142 248 45 146 197 60 105 127 190 50 7 63 61 75 38 74 4 251 57 101 160 207 117 167 133 37 135 149 138 106 217 218 48 229 60 176 60 168 139 118 90 191 219 198 87 38 129 208 128 13 221 130 34 238 199 246 124 176 149 2 211 220 244 68 189 43 229 204 182 173 139 163 105 27 163 236 239 4 194 94 20 165 150 222 73 138 138 76 172 2 153 170 11 196 28 86 20 157 209 169 166 247 236 100 55 143 147 253 57 73 65 215 239 111 15 4 156 139 202 108 237 37 155 180 63 187 192 199 173 149 47 106 254 183 25 233 244 23 227 3 13 45 148 124 115 175 52 210 55 149 216 20 235 234 51 41 93 20 28 18 40 29 243 90 228 71 225 227 183 199 145 214 37 221 19 16 195 64 63 20 181 35 50 171 27 114 234 91 54 46 129 72 139 93 13 224 4 9 24 180 26 232 7 30 240 69 131 236 222 241 230 208 192 193 235 244 221 104 183 192 111 227 154 121 240 56 253 189 11 172 76 37 243 107 154 14 212 206 191 46 188 111 75 124 79 95 27 135 56 127 49 153 43 176 96 80 15 116 88 164 169 109 107 95 191 9 197 174 215 50 40 252 11 82 30 165 57 115 105 23 142 220 181 70 69 73 216 49 156 171 80 202 212 254 187 19 163 74 79 234 223 0 241 124 179 92 52 110 202 41 249 153 239 110 15 155 33 228 30 20 173 72 113 117 82 58 6 152 13 221 89 63 159 90 64 251 15 136 53 207 107 12 140 231 57 157 77 3 156 35 193 248 241 177 51 251 85 217 123 215 120 39 236 185 233 77 40 109 97 241 181 94 255 4 167 25 29 119 142 210 122 114 194 13 226 250 43 59 150 214 148 52 245 93 168 198 5 58 93 193 221 181 26 61 226 61 91 139 131 122 253 23 249 146 217 52 91 79 10 153 53 21 205 140 0 246 43 128 118 28 6 3 109 106 17 128 167 110 38 229 68 27 201 246 103 79 49 217 164 64 213 89 121 175 119 229 68 136 122 69 98 78 67 28 23 145 149 168 191 82 115 117 254 121 3 205 146 212 130 88 126 67 53 176 139 46 228 63 82 141 78 231 36 83 104 112 190 149 111 217 61 113 38 199 55 207 117 46 76 210 208 212 155 54 115 74 21 101 212 206 107 19 34 230 13 230 21 206 90 43 104 236 89 168 205 79 53 68 111 146 7 183 157 70 222 125 45 18 140 253 31 225 119 92 39 215 106 232 7 255 36 200 17 154 144 5 115 241 117 41 220 171 22 59 124 162 233 93 251 154 186 4 46 78 139 211 65 136 252 78 244 237 20 183 240 61 246 250 196 59 232 175 205 15 105 210 46 253 75 77 117 20 77 58 55 197 44 99 15 8 209 173 129 53 102 153 76 99 76 21 43 97 57 44 148 195 77 217 186 202 142 17 183 124 138 196 124 220 115 111 53 217 159 70 208 27 191 224 138 143 6 202 21 61 190 6 66 177 100 159 189 149 120 57 21 122 24 108 56 29 240 161 138 104 73 77 8 12 161 114 128 203 56 9 104 253 158 196 68 20 36 160 67 31 118 74 179 140 185 87 215 57 226 73 112 39 110 89 103 235 137 225 133 219 5 159 234 106 12 178 82 29 120 20 251 44 240 208 220 209 134 93 32 28 50 34 116 49 216 216 230 154 65 184 147 59 166 118 165 188 243 64 241 73 164 82 249 10 50 121 75 95 204 0 188 160 65 116 175 16 178 123 185 15 201 3 10 59 133 38 162 181 178 74 89 240 182 225 14 58 190 3 228 207 20 216 239 169 67 246 83 46 249 47 230 247 20 29 8 226 85 122 145 208 129 126 10 124 70 194 164 62 95 64 247 251 37 3 164 239 249 92 126 95 212 214 1 237 116 146 181 194 70 203 4 247 0 224 95 247 29 58 96 39 255 90 86 70 53 54 237 175 34 101 93 40 213 37 123 147 148 205 2 90 142 196 236 160 134 145 66 197 59 9 106 118 184 52 105 52 94 195 56 141 222 69 164 3 255 33 87 30 94 235 143 97 243 81 115 195 187 167 131 143 179 49 101 251 33 43 210 220 96 252 140 46 34 118 135 82 177 165 48 28 132 0 183 212 30 148 47 163 40 40 12 165 122 169 120 119 195 53 154 92 205 60 221 241 123 18 157 146 158 79 78 193 194 47 229 24 45 158 201 8 189 191 249 55 178 13 163 82 220 151 180 152 42 6 254 7 92 49 37 44 207 30 238 160 142 129 216 81 122 136 12 216 92 224 133 30 26 146 95 229 24 93 188 220 213 84 67 196 95 65 18 53 134 59 148 34 166 137 167 174 190 50 138 150 38 165 116 12 70 205 240 43 246 52 212 21 161 157 100 113 209 160 137 90 98 42 243 176 149 76 108 167 230 61 103 12 217 91 101 168 101 46 104 30 30 18 24 66 193 212 251 179 75 10 196 76 73 55 116 6 134 28 209 115 215 71 226 229 3 7 5 226 230 205 163 222 11 35 137 55 114 210 2 46 208 77 114 47 255 109 224 97 37 251 225 14 151 4 247 33 76 173 210 81 141 68 59 189 110 31 228 118 89 193 195 225 178 17 243 134 44 16 253 41 175 165 253 83 215 152 176 63 82 121 131 104 230 193 62 132 193 35 172 51 14 33 220 145 4 25 114 57 110 148 184 198 94 45 220 76 139 146 232 109 21 227 209 56 132 173 250 30 74 121 100 103 99 33 107 175 230 60 194 202 185 205 140 68 183 64 222 196 75 14 104 110 48 2 83 239 241 104 28 68 0 144 76 193 162 37 157 213 113 41 30 169 32 181 234 45 212 95 43 151 199 54 38 1 238 226 75 41 42 7 97 248 137 101 92 11 54 220 225 2 121 133 108 18 160 49 149 59 42 148 71 218 99 129 141 145 0 185 108 85 64 240 233 22 149 138 76 87 20 111 16 181 179 182 12 54 160 227 117 85 10 169 152 94 134 117 220 157 222 79 234 41 100 158 126 244 174 26 107 57 73 164 62 121 124 206 23 70 34 20 71 249 103 244 6 125 223 236 111 215 131 129 240 216 250 164 107 185 210 144 67 40 83 226 53 123 224 227 221 114 88 149 17 126 44 94 76 173 68 190 196 176 254 250 85 198 78 224 33 70 56 134 100 175 245 49 85 238 29 30 1 68 46 36 26 86 115 1 21 172 15 57 219 75 86 27 218 122 8 86 182 36 180 219 241 109 252 107 183 22 128 105 78 155 191 104 213 91 155 6 115 198 114 83 231 205 220 117 232 44 227 254 177 177 112 151 145 121 173 130 151 142 189 63 173 93 189 21 128 15 113 124 245 223 48 30 184 224 74 131 229 164 77 23 203 182 199 190 77 217 13 121 51 228 138 8 241 8 193 154 166 222 191 114 158 93 26 188 203 51 54 166 249 57 32 57 55 68 248 57 128 15 29 123 30 229 41 219 206 141 75 107 100 245 215 207 26 97 144 206 221 158 152 200 29 201 174 53 205 46 182 56 252 150 8 160 217 46 134 174 30 51 131 137 29 202 59 199 240 175 128 197 122 180 75 167 46 221 44 81 7 99 96 196 207 58 235 251 190 87 247 197 219 46 180 72 96 38 129 18 49 226 154 231 168 142 113 33 73 86 235 168 214 91 222 244 14 192 114 129 166 143 59 114 148 135 112 153 183 92 191 96 116 213 106 42 234 89 115 111 231 24 109 147 170 122 185 73 37 3 50 195 111 220 79 201 178 21 196 201 238 165 9 160 142 7 253 210 103 26 230 217 56 57 216 140 80 191 57 96 188 248 216 76 226 160 120 184 61 94 170 130 131 137 70 63 94 128 206 115 249 138 78 225 168 230 98 77 126 119 181 119 137 49 140 167 117 106 79 3 216 250 101 248 146 121 138 32 175 202 79 202 192 90 114 57 45 225 58 68 145 226 196 223 106 45 161 164 120 246 89 172 233 14 43 217 106 151 38 253 164 179 187 69 115 79 106 89 13 1 187 198 181 189 223 58 120 229 174 191 209 59 231 82 138 234 128 228 53 27 179 238 249 44 190 10 92 42 79 151 166 128 197 45 192 84 176 164 194 133 99 241 185 180 225 232 244 53 96 166 12 40 31 110 115 251 225 185 220 229 211 245 191 46 44 45 113 39 111 176 108 247 130 75 241 156 180 109 45 125 114 248 174 177 210 231 153 19 173 91 1 230 48 209 250 133 34 177 133 188 228 148 48 168 89 199 55 93 104 254 70 125 39 65 3 141 30 123 70 211 187 224 28 136 108 248 54 144 214 157 158 73 209 218 218 164 243 182 8 47 147 2 203 246 129 194 47 119 146 49 184 172 145 23 65 158 125 134 234 209 169 74 153 10 192 145 104 130 40 106 218 71 123 233 249 1 216 144 191 233 210 197 83 121 227 93 144 165 18 13 202 171 126 195 138 85 174 146 107 57 66 123 253 196 4 212 123 119 170 219 176 194 38 52 44 66 41 121 94 169 159 3 128 124 62 230 111 189 84 125 192 194 115 122 171 68 130 134 42 66 105 212 185 253 24 195 43 29 105 209 95 151 69 6 66 37 73 80 53 168 247 175 251 168 107 110 131 164 5 49 57 190 184 48 246 145 133 176 158 146 161 247 247 189 152 73 51 172 8 13 90 11 223 121 217 253 12 193 132 29 214 54 133 144 220 41 6 51 189 218 25 210 134 114 71 178 205 197 236 226 25 231 78 159 183 138 149 226 163 253 124 141 145 61 180 69 155 188 43 235 8 48 4 77 31 170 52 145 114 216 71 188 243 115 92 103 105 125 224 144 125 170 177 127 176 26 235 169 191 205 164 191 117 158 122 91 209 245 66 146 225 169 49 200 14 228 205 49 90 65 145 208 170 101 125 149 105 122 200 221 227 153 53 78 77 184 102 181 89 157 95 250 187 243 233 80 164 92 37 120 245 244 0 240 135 20 16 242 7 239 248 3 82 151 48 117 48 247 3 43 26 153 182 133 141 113 160 139 49 208 134 141 198 203 45 127 112 233 224 173 214 123 237 182 51 190 29 186 234 230 177 93 130 129 159 237 197 158 135 62 21 115 149 103 217 128 17 109 111 177 202 207 221 223 71 126 151 42 109 139 236 12 181 210 141 24 253 168 219 49 132 68 192 117 4 146 73 1 135 254 208 207 172 212 148 204 253 121 115 225 82 61 43 213 245 158 12 132 216 201 105 123 51 92 94 41 38 181 25 42 131 202 184 191 198 122 182 117 153 160 249 33 198 144 125 117 38 67 200 154 12 14 234 240 159 255 125 143 83 234 243 219 239 40 185 3 90 150 67 18 38 79 85 79 207 51 66 217 247 222 142 175 89 217 185 188 241 98 215 163 230 136 212 93 21 167 4 92 132 113 221 209 136 2 110 189 185 196 94 253 208 36 86 64 144 196 94 131 176 47 33 207 26 83 0 0 76 237 141 118 229 208 67 159 80 50 42 229 232 119 81 228 55 11 126 155 203 135 131 243 223 179 220 70 30 44 225 28 97 168 146 25 213 30 135 137 242 14 37 164 24 253 142 208 218 57 144 65 143 102 252 84 219 41 130 167 65 198 225 141 212 5 22 60 114 239 226 51 133 159 27 206 242 176 249 209 242 239 131 182 7 152 4 33 198 167 116 49 141 10 40 182 100 242 122 113 72 179 72 41 204 138 75 131 56 249 33 107 239 9 57 202 13 119 158 241 74 231 125 49 175 8 206 211 193 216 181 123 164 21 127 93 196 52 209 102 138 231 70 218 130 161 204 96 201 172 172 255 226 134 43 152 240 176 173 134 183 179 182 24 31 228 57 243 219 45 25 192 55 169 35 24 229 25 147 189 242 45 163 179 23 223 146 160 19 72 19 127 193 208 202 250 23 158 178 110 183 51 162 16 115 238 26 88 207 173 9 96 26 112 130 68 14 24 64 32 253 3 56 223 89 99 16 104 25 96 73 52 27 14 145 199 201 183 202 28 51 12 215 164 53 168 192 190 41 88 74 163 97 0 126 191 190 87 41 103 97 154 97 220 68 44 235 45 182 19 173 78 252 252 74 203 203 50 69 86 207 150 102 83 248 63 9 242 161 187 239 148 166 14 56 118 68 168 250 217 53 144 44 123 186 156 248 204 52 191 107 89 84 94 197 195 3 40 57 175 42 204 229 220 93 17 158 136 87 213 89 188 206 70 95 42 137 84 105 180 236 111 24 200 75 42 81 251 228 2 119 138 54 11 11 177 124 201 221 33 142 146 50 237 246 7 151 74 33 109 29 130 183 219 106 218 244 67 61 225 41 51 236 167 234 189 24 193 50 249 92 156 116 239 249 167 15 92 249 166 188 84 128 65 149 174 225 143 196 214 246 212 41 190 9 93 85 217 53 167 222 75 81 215 98 31 106 222 114 216 200 239 186 84 161 70 129 61 27 179 19 72 14 159 116 226 69 139 23 0 216 59 31 41 102 13 145 120 112 108 0 155 66 175 151 111 186 31 25 103 169 166 229 241 28 206 108 208 209 154 194 125 167 127 181 75 217 119 221 23 232 106 11 27 8 23 182 89 34 79 27 76 42 28 120 37 99 201 198 195 220 94 7 76 197 164 158 65 106 252 5 105 185 132 70 213 28 15 142 77 196 94 185 22 221 15 131 26 166 222 168 54 70 246 106 59 253 233 195 8 89 199 81 51 152 104 30 27 110 9 98 82 172 170 140 92 30 121 12 192 98 174 240 14 173 54 228 46 244 182 212 179 105 127 195 133 167 73 98 241 189 93 73 229 92 187 104 224 120 158 124 132 97 169 37 110 35 218 156 95 129 247 171 108 145 174 119 70 174 48 175 91 83 95 111 150 113 179 217 16 91 168 198 157 155 11 140 96 91 103 236 185 96 215 106 52 156 156 181 101 138 234 42 141 0 100 81 157 85 162 58 245 155 147 157 210 247 31 135 236 214 194 44 187 129 228 201 224 164 153 225 159 86 116 86 44 198 180 67 245 149 123 85 31 35 2 24 45 34 47 94 229 16 111 225 93 225 108 70 251 130 245 140 177 249 25 177 177 147 11 202 147 100 242 34 133 147 60 60 249 75 54 197 224 54 96 82 24 123 116 171 148 69 36 122 196 239 132 12 27 87 188 15 215 5 164 3 101 239 158 108 232 47 243 179 1 111 14 4 128 197 25 146 72 178 35 209 232 154 109 121 176 174 200 45 178 30 232 126 175 48 72 107 60 113 7 159 178 226 44 206 207 237 5 222 186 99 63 194 37 131 151 219 114 13 249 203 238 35 53 217 198 82 157 25 56 56 133 97 246 233 63 11 137 196 160 191 63 70 138 212 163 15 4 114 210 224 119 198 31 210 178 115 107 142 130 15 216 218 95 202 22 195 8 171 56 155 181 145 64 180 202 19 143 167 22 6 49 235 147 178 113 32 239 74 246 239 202 88 172 115 205 248 188 107 132 209 243 182 180 209 231 23 105 182 177 32 86 225 198 171 89 153 144 150 185 206 233 59 165 245 43 131 39 201 91 35 24 155 61 243 113 135 151 15 14 39 229 99 127 94 198 157 136 137 72 252 200 221 110 51 228 146 32 68 84 101 73 32 177 194 189 231 119 35 16 19 65 186 252 103 114 252 100 200 245 95 73 2 204 13 13 113 193 199 132 98 211 90 191 73 155 62 139 56 207 89 131 78 165 14 119 10 44 251 19 86 61 59 91 93 157 108 96 27 101 173 67 61 5 80 173 117 44 118 46 134 39 73 251 236 126 174 29 34 196 116 6 211 118 51 203 36 243 240 250 109 181 101 253 220 96 126 134 122 38 162 77 153 150 107 215 30 6 108 158 2 109 82 40 45 205 35 176 139 226 233 119 44 58 19 37 54 161 31 103 201 86 139 13 221 111 84 126 100 201 95 238 110 196 143 129 219 227 128 57 89 132 86 105 128 99 141 190 125 191 239 132 17 164 229 125 12 194 110 181 177 96 13 74 19 252 222 229 55 135 66 151 213 212 221 78 199 68 237 134 237 221 125 216 206 8 193 162 88 28 145 117 204 160 131 81 200 42 147 76 37 65 252 167 169 72 248 57 200 27 201 52 98 212 42 143 108 198 5 3 109 9 128 78 238 197 214 22 42 176 220 82 82 186 148 7 235 142 103 25 4 46 41 5 214 35 241 54 204 110 194 117 23 140 21 58 125 50 37 189 102 239 5 126 120 199 23 240 185 2 121 29 216 163 51 201 71 234 93 154 254 168 179 58 49 64 174 43 37 161 69 157 21 113 240 76 172 87 64 2 240 44 112 131 106 92 0 38 168 246 146 92 101 50 188 92 188 52 240 25 216 122 198 81 64 183 207 80 163 120 210 218 148 224 70 152 146 230 132 47 27 50 24 249 154 68 215 221 236 0 42 7 32 1 162 28 26 134 237 68 66 52 37 255 251 211 158 206 239 15 244 163 94 25 235 142 236 188 132 194 63 57 133 220 31 193 111 180 194 191 74 226 29 180 75 114 52 144 169 64 207 130 84 33 174 179 59 18 37 53 75 202 72 189 236 207 64 138 155 124 33 109 152 20 51 243 180 59 219 54 155 109 189 212 75 245 69 72 128 195 79 21 201 98 4 197 214 156 116 242 53 97 175 249 115 1 137 171 110 50 250 253 59 45 67 116 87 132 253 201 190 127 73 67 210 51 253 160 210 31 85 76 24 123 88 25 142 36 74 25 25 219 2 222 64 45 211 198 41 252 250 30 101 103 140 245 3 144 83 86 29 119 101 123 50 76 124 224 21 242 214 73 132 178 37 16 85 149 46 6 186 239 19 239 82 50 65 205 197 224 50 235 237 72 255 44 164 254 237 92 77 186 153 148 90 86 15 173 11 39 138 15 39 249 109 150 113 236 64 252 19 48 165 165 165 165 1 0 0 68 0 0 172 94 103 33 181 100 108 90 0 0 29 39 0 0 72 235 0 0 0 0 0 20 177 93 0 0 67 112 0 0 13 15 0 0 0 0 15 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 112 114 111 106 0 1 35 119 77 77 80 82 67 87 73 69 1 0 4 110 0 123 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 99 0 0 9 193 0 0 0 0 15 0 66 193 213 0 97 188 164 25 114 80 214 139 60 68 179 239 114 164 115 186 84 30 162 253 3 169 203 243 214 107 37 157 60 146 123 136 23 37 148 96 50 128 246 101 107 118 186 24 17 43 57 95 192 197 105 142 108 107 127 223 51 155 141 133 195 180 238 222 91 196 93 148 87 87 102 194 27 101 120 27 88 207 9 103 127 79 99 60 169 16 200 129 187 186 99 40 168 139 136 57 9 18 155 169 197 40 107 234 23 125 168 121 60 88 248 115 158 176 228 57 87 46 90 74 136 222 67 254 244 164 99 5 174 148 225 21 123 140 104 240 254 28 78 180 15 119 189 247 158 171 219 133 132 109 34 222 55 138 182 11 75 59 14 247 106 217 237 196 13 177 176 93 124 97 155 12 46 101 30 201 241 90 229 34 141 234 126 4 33 39 207 18 111 237 54 39 27 206 180 54 243 124 220 127 104 241 6 155 201 212 137 38 22 16 184 29 33 35 117 25 251 85 243 145 234 99 141 47 178 242 93 131 117 117 116 33 86 33 1 200 218 48 181 241 8 208 24 184 196 7 89 82 131 231 69 58 25 199 248 205 22 110 78 37 158 128 120 98 170 32 122 14 179 134 213 149 57 165 107 28 11 50 148 20 115 202 130 4 128 242 194 219 188 19 98 168 245 84 32 72 157 147 92 94 93 222 229 136 48 207 165 7 113 80 73 2 125 213 253 98 132 81 246 32 73 218 246 128 153 153 64 194 142 174 45 199 179 147 213 104 157 81 227 211 97 63 44 71 239 108 228 34 129 130 4 43 241 146 130 226 187 146 83 154 15 212 85 136 126 76 78 245 35 206 165 176 102 90 250 31 167 202 18 34 143 97 223 63 21 93 139 222 203 114 80 246 192 105 253 165 187 250 120 148 66 189 135 214 100 57 235 33 80 29 95 145 253 25 63 104 46 72 207 52 17 85 26 74 56 110 200 6 92 239 184 238 19 228 118 152 100 107 250 6 117 194 103 114 161 62 59 1 143 130 53 205 110 239 236 235 106 233 39 21 40 209 32 114 130 179 224 118 134 158 58 15 219 18 125 60 23 92 51 97 66 2 225 62 230 133 138 165 113 207 247 59 90 32 164 119 1 93 52 90 33 24 195 4 62 188 246 230 68 39 159 103 223 177 94 87 125 210 115 155 248 79 163 172 216 37 230 73 55 190 129 156 117 253 0 207 115 158 43 44 42 228 59 232 241 56 85 134 203 241 102 179 75 87 247 222 182 198 52 131 227 242 215 39 236 236 137 230 125 245 209 3 219 255 203 233 100 194 84 99 38 32 233 53 150 183 1 23 152 230 185 203 109 34 167 14 116 214 77 188 63 24 128 144 79 54 47 58 0 248 14 43 197 205 185 40 81 252 6 67 132 104 246 128 236 192 67 1 110 95 245 96 207 57 125 74 54 83 83 173 174 27 193 224 26 117 73 138 59 20 155 193 25 123 91 229 234 139 243 11 90 115 7 105 120 26 18 39 155 227 167 221 27 96 74 105 33 7 103 239 230 96 157 33 10 84 55 84 157 59 4 149 246 237 202 229 2 198 135 126 252 16 110 21 232 186 76 162 115 237 115 13 213 116 45 12 218 223 27 95 1 122 182 128 112 22 17 50 137 206 247 85 128 104 232 1 92 95 60 145 109 165 119 89 200 195 11 175 99 111 84 240 52 29 24 14 20 72 7 183 213 68 234 150 79 40 37 137 198 187 25 0 5 120 193 198 158 111 56 148 155 21 27 107 110 10 248 135 166 76 155 174 239 119 4 167 78 219 216 198 122 2 198 75 200 63 76 153 131 49 238 107 31 63 175 47 134 28 108 148 246 49 89 0 128 218 167 181 239 159 17 221 8 178 213 103 165 56 21 229 216 4 50 155 251 80 106 239 158 143 45 163 86 212 191 203 75 41 4 54 116 46 41 63 6 44 25 211 71 107 41 90 31 178 72 196 188 78 59 192 201 108 238 235 127 109 131 149 112 64 63 173 203 11 236 51 41 180 5 182 43 52 148 201 209 182 105 118 17 122 187 3 69 72 216 25 124 85 170 89 101 251 164 147 251 205 153 81 36 126 224 215 113 75 158 204 186 249 49 133 113 69 206 193 8 77 88 103 248 250 54 14 223 97 135 243 6 228 182 84 74 165 146 176 7 173 74 101 88 44 161 116 82 78 60 169 208 115 69 89 5 105 131 34 193 25 26 183 187 135 233 194 126 172 112 180 32 99 186 52 253 78 135 124 183 77 137 41 201 178 18 104 155 45 98 228 47 161 101 229 141 128 185 176 180 225 254 62 137 37 9 106 239 128 177 100 61 223 238 26 170 186 100 139 116 111 85 64 219 144 16 189 140 49 103 70 145 123 159 4 168 25 140 185 118 141 209 166 242 102 71 43 126 71 6 222 138 34 76 103 160 63 180 173 110 153 33 102 231 186 176 49 175 142 113 120 136 85 50 230 220 199 14 240 155 117 230 254 211 239 78 254 31 13 246 4 233 147 193 212 246 205 118 192 253 233 9 11 23 4 12 79 195 158 48 183 37 87 161 96 48 52 203 104 10 65 52 192 214 100 12 59 188 107 167 221 218 233 0 148 79 14 166 227 41 82 240 89 89 137 46 111 53 251 14 38 149 242 240 133 167 91 43 118 54 156 35 28 143 150 158 20 211 141 120 182 77 214 2 19 48 203 240 245 206 94 144 154 98 115 206 49 137 146 35 58 18 255 172 138 181 158 58 143 137 209 98 42 21 63 248 115 4 93 151 144 149 32 32 239 235 251 243 118 208 131 174 186 10 123 90 212 176 79 188 198 13 118 75 39 173 2 146 64 230 155 16 105 229 207 116 71 123 71 51 232 152 194 95 15 9 144 131 23 0 66 96 152 66 99 89 76 227 20 210 46 4 146 180 233 140 88 180 207 135 116 246 244 12 102 153 185 234 236 214 51 98 239 146 149 197 25 52 99 249 222 150 223 213 18 13 244 150 217 228 69 254 204 74 31 116 145 145 139 216 251 42 200 224 163 28 144 14 205 209 14 103 168 65 4 19 188 208 83 240 191 167 46 84 84 238 250 157 146 61 148 170 78 32 181 232 26 107 32 246 131 9 54 210 103 244 251 192 239 32 148 95 244 121 132 248 216 57 209 155 40 220 102 56 51 126 240 113 109 7 162 194 201 132 209 180 125 130 4 10 173 168 72 117 218 116 110 225 212 53 16 17 172 220 102 11 82 231 252 186 246 203 159 44 133 164 163 155 37 199 195 219 179 191 33 191 27 204 223 173 227 89 98 255 250 81 131 117 59 217 187 29 70 72 179 46 147 123 48 99 179 234 214 4 232 233 238 175 231 214 241 20 49 253 218 189 209 143 59 175 123 251 76 241 112 228 123 120 227 159 135 8 4 110 8 179 144 126 243 254 75 105 22 11 138 38 200 79 110 63 123 243 63 194 56 72 40 193 28 52 53 98 138 87 74 183 79 27 223 26 225 128 254 64 90 211 239 161 149 121 226 154 35 92 27 119 194 159 52 16 252 79 63 27 230 156 22 139 119 45 149 247 147 218 93 23 154 86 60 28 19 209 56 184 47 209 210 54 202 174 178 131 40 233 138 57 206 232 224 78 173 182 113 157 115 170 39 93 201 80 71 45 122 154 109 196 135 192 80 115 43 114 18 62 63 236 160 12 198 253 245 116 51 113 46 13 88 212 50 87 28 145 193 63 17 246 190 73 15 249 247 5 49 6 213 217 226 165 235 106 86 236 105 147 150 101 42 218 14 102 181 216 128 174 42 44 8 24 238 141 251 134 237 31 117 232 228 4 30 29 38 180 78 236 124 30 116 3 78 249 45 129 110 128 36 121 153 83 179 74 78 82 189 142 151 166 165 112 114 163 180 164 210 19 150 21 54 195 136 172 38 42 30 191 231 102 85 44 12 180 105 190 63 214 217 141 92 3 201 252 248 27 17 19 143 208 240 170 187 16 3 103 55 158 193 83 218 128 100 10 43 64 138 8 231 191 89 58 108 3 236 251 59 87 112 10 163 65 233 210 95 225 153 184 255 227 195 66 24 201 149 82 135 166 62 18 216 34 229 35 127 17 95 188 113 26 69 4 163 16 102 140 108 26 208 80 63 156 49 204 197 182 111 166 49 94 141 9 60 222 177 177 7 200 235 142 116 178 116 193 211 206 51 232 85 68 236 138 215 2 167 7 209 237 182 206 3 157 77 106 158 53 218 23 210 130 81 40 77 140 154 92 212 121 198 74 70 151 19 224 23 143 0 233 208 255 157 29 107 242 213 123 177 192 152 149 240 204 128 36 198 236 26 58 80 201 234 203 98 42 231 37 68 110 78 6 46 6 73 141 98 88 112 70 47 16 126 212 34 153 20 228 87 73 191 248 3 243 30 129 47 26 240 232 153 43 87 41 80 144 74 192 192 116 114 227 230 232 118 126 205 248 57 39 135 43 28 121 99 203 249 238 241 28 138 234 117 138 181 27 131 112 172 124 14 137 158 53 161 66 246 117 15 111 146 28 152 147 79 198 25 206 231 205 119 48 44 39 33 251 216 77 192 231 176 120 88 75 18 147 45 156 171 132 109 242 42 162 48 113 179 206 217 230 5 65 150 159 175 238 231 161 186 21 146 84 71 139 98 98 27 254 76 231 5 101 16 209 11 148 71 64 228 107 230 247 33 244 112 155 42 173 112 144 4 216 115 141 231 116 126 87 3 205 233 20 32 109 152 239 110 2 134 117 19 81 76 97 67 148 239 224 104 19 75 57 191 220 157 141 209 150 237 152 21 115 159 224 194 221 79 55 34 243 45 158 108 95 229 118 123 203 103 159 212 17 67 37 71 23 111 120 214 30 13 40 137 52 146 224 204 73 39 161 116 138 212 205 25 238 88 213 222 195 5 226 159 0 78 54 76 65 10 111 160 142 52 153 157 137 75 244 137 165 40 59 144 187 17 21 2 45 132 138 127 109 16 64 138 104 198 55 224 62 31 245 70 78 171 64 0 108 149 234 154 201 215 17 35 233 115 137 137 176 128 146 124 161 3 235 236 106 236 209 134 201 26 25 251 123 212 246 110 122 54 42 88 191 78 91 129 102 62 63 226 195 132 141 95 213 135 58 135 51 129 2 176 215 243 77 172 31 154 8 139 185 117 207 217 168 6 105 72 207 71 198 197 248 55 230 241 43 93 88 172 211 148 211 98 66 141 101 19 238 41 224 56 0 187 103 6 51 78 186 90 230 110 235 179 200 153 130 185 1 196 153 123 41 91 245 144 68 246 92 80 116 118 103 221 118 128 194 59 27 210 118 197 37 231 3 97 146 115 105 28 50 206 32 99 218 97 230 209 218 13 100 92 96 62 2 48 148 75 142 47 76 240 182 66 121 62 78 234 247 195 68 39 0 242 161 119 178 127 199 75 238 159 71 236 90 211 91 236 253 20 243 207 247 9 209 214 247 123 38 70 226 149 219 230 103 204 158 2 244 249 1 224 216 131 62 47 42 121 41 182 97 134 108 176 100 120 32 11 157 200 55 102 211 1 54 8 164 103 45 118 132 53 98 131 99 193 28 255 183 148 36 169 0 66 193 212 125 38 145 77 172 217 105 203 239 245 149 172 87 226 189 107 88 16 35 69 70 83 37 144 117 149 220 43 0 88 219 121 238 56 50 254 83 66 22 8 251 154 28 151 140 235 80 122 180 103 91 50 37 79 23 238 143 27 38 254 175 198 222 149 91 19 215 39 218 245 193 247 104 247 47 187 59 22 87 192 203 104 195 163 52 20 117 52 254 63 36 16 171 143 202 134 230 79 233 236 158 22 85 189 179 91 205 118 34 49 22 106 9 126 157 110 64 119 190 236 228 176 247 238 29 89 237 99 176 24 178 255 36 213 191 98 109 140 54 89 17 242 249 5 235 37 146 66 180 59 249 5 9 124 14 111 0 251 58 190 31 144 98 228 72 94 73 249 183 166 35 90 227 72 96 120 35 236 231 25 163 45 96 219 110 211 67 34 146 21 45 187 78 211 33 188 26 233 230 171 4 204 184 10 163 94 1 65 163 108 245 212 25 28 98 229 197 243 95 167 39 122 3 152 101 5 0 164 165 143 30 70 155 231 2 109 69 22 179 132 194 250 150 186 60 31 55 222 83 181 77 24 31 0 179 90 229 148 112 159 226 235 7 95 216 51 250 23 65 128 198 239 212 129 151 8 71 245 236 53 246 85 23 87 32 165 205 219 217 184 160 52 123 220 209 44 117 99 122 158 104 84 74 95 250 198 198 76 126 210 20 102 78 247 151 41 35 186 124 132 9 242 181 247 252 100 54 240 65 240 12 103 13 231 249 82 103 209 254 210 194 246 26 85 25 118 96 253 160 197 247 242 117 31 76 155 150 113 177 27 69 41 60 14 85 43 10 64 246 83 221 204 177 181 198 225 161 110 25 97 2 12 181 188 37 221 204 198 40 47 252 9 190 94 184 34 168 91 41 235 157 29 101 165 148 30 240 242 216 144 135 242 227 38 198 12 175 230 251 37 236 132 126 118 136 218 44 27 248 52 194 89 211 26 149 39 164 186 69 99 240 157 10 79 171 165 235 28 199 227 137 223 201 37 31 236 29 7 36 159 124 193 57 201 62 123 53 86 55 30 156 9 8 70 148 91 234 9 229 200 22 100 141 19 251 79 178 187 136 167 141 217 36 18 11 143 9 84 211 29 138 161 138 219 57 236 35 63 150 54 154 20 28 252 69 199 63 99 29 154 76 52 54 114 72 16 84 179 105 33 133 35 120 40 190 182 206 99 199 151 37 72 159 148 119 200 229 157 1 224 50 170 37 99 132 153 114 65 39 4 112 189 146 132 54 151 13 218 14 221 186 110 47 47 210 45 242 34 225 167 236 229 159 46 111 243 6 130 197 240 97 171 53 28 241 187 84 75 223 238 103 46 49 141 190 231 78 95 18 208 137 173 196 81 230 174 60 214 255 118 65 125 242 30 253 217 234 53 193 212 81 168 242 140 141 32 119 99 101 54 178 250 188 240 131 161 124 215 163 93 167 216 87 106 65 36 95 11 252 228 18 191 188 223 217 245 15 227 232 104 87 6 98 213 69 35 120 200 121 123 64 15 177 96 85 29 114 90 243 4 112 89 167 177 228 236 120 73 217 170 44 172 235 229 83 66 116 21 134 64 146 242 65 166 161 111 196 75 60 88 177 237 27 29 226 244 108 86 239 184 200 239 149 79 32 176 163 55 85 107 29 61 25 64 183 131 228 115 125 19 156 101 250 208 192 227 184 223 72 88 226 65 130 127 166 14 249 147 68 30 33 254 14 129 116 102 135 56 154 7 209 93 57 218 245 60 101 37 208 21 90 11 183 118 215 147 114 71 115 45 167 177 190 70 130 82 163 81 11 94 159 184 181 164 113 252 162 89 162 109 152 17 64 1 121 248 193 200 154 109 57 186 111 8 145 178 17 102 147 107 70 110 119 85 153 50 230 47 138 7 185 6 48 48 158 222 181 132 237 144 38 56 214 174 208 217 71 145 189 230 62 133 228 69 166 99 143 183 216 236 43 44 47 246 126 192 72 187 190 101 193 246 154 243 188 153 13 250 50 214 158 84 82 200 10 13 161 224 109 151 1 238 224 134 62 114 93 98 88 83 245 156 205 128 222 9 154 209 121 65 41 255 216 127 237 35 179 28 235 237 165 100 136 244 28 190 177 17 212 180 235 90 250 107 111 31 108 110 133 36 80 178 93 54 171 7 204 177 198 51 70 41 112 196 50 8 96 172 243 206 22 85 61 211 186 51 199 168 23 86 242 241 8 218 186 146 221 136 94 141 125 25 149 31 136 186 76 188 85 156 2 33 85 233 190 68 89 7 77 71 7 12 126 125 154 221 139 220 157 176 235 199 142 122 13 84 101 73 30 106 207 230 78 247 248 196 107 212 153 99 72 174 113 197 175 97 26 146 131 209 126 97 21 69 105 127 211 204 193 142 249 195 85 103 48 251 44 36 208 227 65 109 242 82 249 33 241 161 5 188 102 217 232 0 187 162 102 229 198 126 235 56 93 190 235 46 189 48 229 41 160 193 39 208 78 132 139 129 161 5 243 248 218 167 104 248 105 240 155 175 103 131 244 20 101 5 18 121 189 150 239 148 246 25 191 166 191 157 41 236 218 0 154 89 81 204 14 167 18 37 164 246 110 137 1 8 153 236 103 13 105 54 124 104 39 49 192 255 63 211 48 148 2 88 172 201 32 244 56 103 31 109 200 52 205 155 128 15 86 164 114 176 104 118 221 181 152 220 30 171 68 47 25 64 229 80 31 49 170 159 79 116 83 147 201 43 194 227 80 216 153 60 32 227 147 59 168 245 117 238 211 14 20 50 103 48 102 150 36 80 135 226 37 242 63 28 92 180 53 207 102 88 211 137 82 162 84 137 254 23 49 37 150 29 182 210 5 214 55 38 77 190 63 65 205 192 11 149 248 155 224 88 38 218 147 12 214 145 14 239 111 18 189 135 110 212 98 210 72 99 234 149 28 101 207 207 150 192 9 111 38 62 98 226 29 94 248 74 123 237 112 126 244 55 187 47 7 255 134 161 74 59 38 132 133 206 95 133 73 81 66 53 92 63 136 41 130 71 220 205 79 86 249 152 58 92 255 125 134 133 55 188 198 210 231 239 37 54 41 165 220 44 13 230 222 94 202 249 87 117 189 143 69 64 147 190 83 36 29 186 211 15 173 244 222 175 252 34 13 123 23 214 60 122 87 119 255 237 181 156 184 174 173 16 58 185 187 1 218 77 168 132 170 214 220 78 211 213 57 153 49 135 233 56 242 83 30 199 231 121 164 189 171 123 132 190 154 12 16 184 253 99 3 138 155 81 4 152 177 73 180 225 79 17 173 131 184 217 116 27 10 187 115 253 213 80 84 219 223 77 61 154 159 95 39 188 182 242 115 135 43 138 208 242 185 52 50 42 25 142 77 102 53 185 255 42 157 104 89 190 73 217 198 117 3 174 129 109 212 34 188 88 19 27 63 40 200 149 60 239 170 241 229 201 180 185 218 114 12 162 71 64 237 204 207 86 249 49 26 104 77 159 20 161 239 31 83 79 249 32 33 147 134 138 77 174 189 155 59 211 3 136 194 61 4 32 213 206 240 1 117 52 33 136 167 253 71 229 101 72 207 8 186 251 255 89 202 176 34 246 213 116 201 110 114 209 107 117 203 23 77 200 109 114 149 158 31 34 170 254 132 200 232 250 223 226 36 242 73 41 68 73 213 172 162 96 75 250 29 233 225 202 98 238 143 203 103 189 143 24 222 97 38 79 245 217 32 142 109 93 240 74 60 246 165 214 188 55 87 160 24 203 236 227 255 46 15 234 82 231 210 11 241 39 140 222 246 238 186 202 249 136 230 190 238 211 86 21 170 200 73 184 171 240 172 128 255 172 64 100 206 8 165 81 211 254 81 247 85 1 171 138 93 22 111 53 3 134 101 230 203 160 181 24 38 33 173 176 213 144 188 145 234 252 139 135 172 64 203 138 64 210 205 237 227 231 207 149 199 166 151 139 29 169 65 165 89 82 59 120 110 114 37 41 47 34 169 123 191 21 83 90 1 59 160 41 253 7 69 247 179 127 192 221 246 43 249 8 33 126 106 181 206 29 166 176 195 77 187 196 20 131 76 7 179 173 120 133 83 56 192 113 209 253 220 224 135 176 106 165 208 153 51 24 24 246 80 52 73 254 233 7 66 9 25 75 25 212 203 119 120 147 125 211 36 52 198 192 103 96 167 200 217 93 36 67 128 191 32 111 38 28 159 202 215 182 167 56 193 107 195 85 115 135 203 69 123 43 175 68 66 19 60 73 127 148 207 109 45 72 213 17 5 141 78 191 9 199 34 32 249 150 96 213 240 109 59 241 162 3 227 108 86 11 77 52 42 125 125 252 186 54 6 128 76 83 96 123 4 149 212 161 84 63 70 169 237 237 147 159 214 24 53 90 119 11 242 18 166 95 56 251 63 9 199 0 116 30 47 233 31 97 251 66 56 141 219 35 92 62 252 59 5 234 44 98 117 214 183 148 186 69 245 168 182 149 79 255 97 162 137 165 58 178 217 191 167 15 155 64 164 43 191 140 14 72 30 187 172 128 32 205 220 217 80 63 49 76 250 43 161 180 211 190 226 255 177 56 74 191 199 120 200 7 147 236 81 162 231 197 21 235 170 216 184 83 48 231 177 225 55 233 25 220 0 80 209 228 250 155 91 110 232 84 84 18 176 176 143 239 113 139 138 188 124 16 20 236 10 93 154 96 40 28 122 169 138 3 105 182 215 40 110 204 208 94 57 17 199 239 87 149 59 144 148 229 197 48 134 60 65 25 209 194 24 182 80 86 52 187 71 215 71 238 175 3 236 241 119 100 78 91 216 32 186 131 113 73 29 244 80 149 7 122 209 151 144 164 18 108 168 235 141 199 224 17 215 206 151 2 131 43 104 252 233 119 155 239 99 85 24 217 232 227 105 86 78 84 35 49 11 100 160 105 39 79 189 106 155 196 26 145 251 117 167 183 204 124 255 40 231 161 143 163 150 177 198 231 167 238 31 240 77 132 167 90 189 108 91 155 106 100 164 182 217 92 132 17 249 153 82 40 55 26 47 19 216 34 176 196 162 84 248 210 89 247 101 0 138 14 218 132 118 171 219 178 66 229 186 16 10 41 232 169 50 0 4 36 240 3 177 231 7 58 27 149 166 249 33 127 106 228 216 210 144 109 158 230 86 46 16 124 74 28 222 160 39 157 42 37 107 85 99 20 97 89 124 193 105 173 195 188 82 236 160 243 196 189 232 210 188 129 111 64 159 172 83 63 82 227 148 163 109 231 189 202 93 62 39 168 178 29 60 201 231 14 177 224 252 53 230 131 231 248 64 208 201 52 168 155 63 33 149 55 21 227 5 142 7 82 143 235 49 140 217 119 30 185 221 134 156 219 102 253 184 101 4 146 50 70 155 177 45 25 69 26 34 76 237 78 98 195 44 169 157 16 14 32 245 74 224 142 126 151 246 57 147 193 85 179 34 174 178 163 191 240 110 102 8 35 79 158 229 156 124 52 208 55 82 69 76 154 209 89 65 57 109 144 221 193 237 42 234 173 61 59 197 240 137 3 247 17 166 242 30 244 165 226 9 101 181 71 56 201 198 243 34 147 15 2 148 110 48 178 160 134 215 209 133 170 198 72 67 254 100 93 169 144 30 14 157 142 122 71 202 224 82 153 111 112 46 103 17 197 141 249 98 53 132 103 23 223 111 173 205 130 191 83 181 247 198 0 118 231 166 236 154 168 94 107 11 47 193 238 124 130 213 238 223 128 253 194 53 177 173 206 127 158 126 159 29 199 81 179 31 176 93 10 167 234 68 54 226 246 253 31 173 79 219 200 190 201 191 206 208 202 249 209 0 221 227 252 172 249 204 54 250 199 156 158 163 20 160 12 200 200 96 67 90 207 77 197 153 47 171 195 152 27 78 235 90 80 10 109 139 120 2 40 94 41 246 23 134 251 181 43 203 188 0 165 219 18 39 17 100 155 203 246 44 228 5 14 161 83 223 21 153 51 240 18 90 152 186 88 132 28 202 205 32 19 194 95 170 85 133 163 235 206 167 205 47 77 118 198 88 67 244 182 21 37 167 102 37 31 31 55 244 131 182 223 2 165 51 9 1 44 191 14 82 134 3 253 235 32 105 72 115 8 137 114 235 211 26 65 33 139 13 204 1 158 137 247 118 182 126 89 139 67 44 245 18 47 77 217 54 57 142 94 3 29 151 10 10 38 209 252 53 205 152 147 131 56 143 38 64 232 172 163 197 172 115 125 180 43 40 244 138 137 196 214 244 37 196 79 12 77 164 10 197 67 175 225 149 205 63 245 48 80 68 137 176 32 203 166 51 98 175 229 160 1 182 162 88 137 124 180 127 209 29 173 222 231 136 96 36 151 18 162 9 42 8 201 65 97 125 100 153 240 17 95 28 180 49 173 54 97 230 151 86 133 194 89 197 35 24 178 67 63 22 165 131 116 40 240 56 226 111 203 193 141 155 253 169 179 149 224 180 163 164 0 201 125 248 102 36 228 220 247 129 136 239 235 111 178 112 143 254 214 148 161 45 221 186 219 178 143 98 46 134 55 13 204 154 178 235 187 30 193 222 218 124 139 204 118 155 158 155 173 76 94 202 224 104 233 240 191 59 209 164 8 118 218 126 85 57 15 237 170 75 14 153 195 158 80 60 71 238 44 86 17 43 25 18 70 233 112 78 44 132 62 174 138 166 208 179 179 171 157 66 62 203 152 146 131 221 19 16 131 10 102 190 16 243 160 202 165 110 122 58 138 120 121 44 116 74 195 15 252 223 210 14 121 216 100 234 69 57 221 99 215 98 234 126 115 1 142 84 181 198 34 165 213 21 114 150 223 140 189 115 114 85 178 10 102 99 62 90 170 102 124 246 109 188 255 40 139 254 55 9 215 156 131 85 132 207 161 104 106 64 141 176 197 231 92 192 213 32 91 129 107 232 248 54 38 78 233 104 165 125 34 208 237 164 210 31 140 119 99 146 236 174 163 140 235 59 72 139 213 64 87 226 104 203 238 88 231 55 105 192 19 119 187 243 63 164 148 86 201 62 238 88 253 241 6 158 141 9 145 224 115 90 63 22 219 14 19 74 117 219 94 219 189 155 226 19 201 195 27 251 39 74 213 216 11 29 247 114 140 253 106 30 104 239 82 181 157 211 194 248 74 19 6 216 43 224 255 168 17 57 12 122 73 197 98 180 246 35 59 138 14 220 69 166 160 66 170 95 50 150 64 242 200 93 62 219 191 94 55 179 217 85 22 126 146 140 190 125 167 26 47 191 88 60 166 5 5 175 194 11 71 38 207 123 211 164 192 14 180 44 82 203 186 230 225 8 224 35 30 232 100 137 129 245 245 234 166 124 76 143 139 101 109 232 1 21 123 76 186 55 71 194 149 204 212 241 207 164 254 112 168 222 104 74 65 255 224 30 66 164 95 34 98 226 203 173 224 222 19 63 161 207 51 45 78 12 166 144 115 130 192 165 165 165 165 1 0 0 62 0 0 172 94 103 33 181 100 107 228 0 0 49 165 0 0 0 0 0 0 0 0 0 14 51 142 0 0 60 76 0 0 11 24 0 0 0 0 15 0 83 113 117 101 97 107 80 80 67 46 112 114 111 106 0 1 171 72 77 77 80 82 67 87 73 69 1 0 4 173 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 193 0 0 0 0 15 0 66 193 213 34 167 232 172 81 91 7 77 142 124 239 28 45 32 96 71 44 253 247 17 245 112 2 123 7 177 68 60 103 178 138 154 155 220 202 151 35 162 241 82 236 244 55 18 220 139 52 168 60 220 248 234 100 151 196 159 128 216 70 112 94 10 180 81 242 131 191 123 65 34 62 108 150 119 172 8 116 216 73 192 47 56 186 18 69 111 85 194 94 216 118 21 37 241 159 133 65 30 155 90 251 74 241 44 131 74 189 43 132 153 63 138 116 31 21 205 168 130 134 179 83 72 129 117 70 90 175 42 99 21 233 45 180 135 107 45 203 46 248 158 220 73 227 163 242 140 235 34 227 205 250 92 189 230 119 9 16 117 23 212 136 172 200 156 180 192 204 196 185 120 194 160 186 17 23 115 155 204 80 22 231 202 212 6 242 92 78 181 78 203 72 220 198 181 251 161 232 213 39 46 191 220 148 144 185 181 135 243 152 127 161 34 210 82 77 189 26 0 197 0 94 183 250 55 55 21 153 55 132 220 39 92 164 11 107 153 38 144 23 116 21 100 251 246 163 17 239 185 164 162 9 14 67 7 29 186 137 235 2 151 93 70 144 152 24 160 178 206 173 239 159 247 151 159 183 221 141 161 47 97 42 55 31 169 181 210 150 168 19 168 189 178 222 132 20 77 91 82 112 61 23 126 198 207 78 253 153 110 189 64 191 8 235 11 107 194 193 40 198 167 219 90 135 224 217 92 24 33 154 251 36 167 101 188 151 48 22 147 95 255 179 83 184 205 53 39 79 217 77 96 44 128 10 254 241 100 214 156 201 159 125 237 153 220 13 72 229 83 209 41 226 86 172 118 255 144 148 232 82 130 91 203 137 53 124 19 22 183 70 104 104 239 211 79 57 87 166 67 237 66 17 119 68 41 137 193 180 212 149 53 162 214 131 56 70 20 4 48 113 221 45 69 159 10 65 37 119 198 130 31 75 225 252 126 31 108 162 224 102 136 177 7 5 212 45 1 229 194 237 81 2 9 220 255 34 249 42 175 142 244 254 223 21 73 232 102 76 121 6 10 55 77 243 103 33 218 54 241 206 82 77 74 235 80 198 44 89 241 33 188 21 23 22 130 134 135 67 47 225 215 112 29 251 95 172 152 91 41 17 218 8 38 70 154 173 120 251 115 28 179 159 90 3 66 81 239 226 221 228 123 30 195 160 30 210 200 154 99 222 236 50 80 57 197 187 28 53 93 168 205 167 156 132 219 40 77 122 72 134 49 89 149 15 172 45 145 26 206 35 65 123 126 72 126 150 25 31 14 36 87 121 55 136 189 90 44 148 23 6 178 75 83 255 149 30 62 89 162 71 157 123 63 171 217 140 40 178 201 156 167 229 24 94 44 9 167 80 12 29 49 123 143 111 180 132 61 31 15 19 183 145 192 38 121 70 98 26 176 81 174 60 155 210 255 226 179 121 129 53 153 124 152 112 104 156 231 211 245 66 240 220 73 252 235 255 132 212 180 8 120 205 129 243 110 157 62 175 96 188 221 117 143 80 184 145 62 119 179 101 157 5 23 82 54 10 131 206 75 50 200 106 45 64 125 179 159 94 79 208 108 74 53 122 100 245 74 206 254 131 244 85 167 33 188 82 165 8 72 253 9 1 15 88 174 2 11 55 231 19 6 102 132 210 128 216 209 115 92 164 229 248 106 127 212 251 243 75 16 143 50 239 188 33 193 94 110 27 175 77 236 79 133 86 69 217 142 102 75 139 63 125 31 164 45 167 72 169 34 207 227 132 53 169 129 224 85 77 98 220 60 27 149 8 247 135 88 138 109 145 91 168 122 122 75 242 187 139 6 116 126 10 93 119 237 37 74 62 34 3 199 173 199 15 24 154 108 34 231 135 176 249 201 51 101 16 227 215 65 145 153 131 221 212 12 113 97 76 213 108 242 235 26 150 195 84 16 115 77 41 79 40 62 106 169 170 20 236 105 141 7 250 73 193 230 204 250 213 11 56 146 50 76 119 22 227 94 73 201 203 225 10 78 109 35 92 150 209 165 222 59 55 249 11 152 41 182 174 81 69 14 102 245 132 81 131 173 102 109 103 124 140 127 3 239 102 226 2 48 194 133 160 207 41 137 105 103 172 192 183 17 209 153 82 12 124 169 158 201 250 122 72 225 152 167 224 26 178 41 218 32 233 219 141 124 201 205 151 182 134 230 11 127 10 44 195 143 80 194 151 203 133 139 138 5 221 113 243 217 150 105 42 122 40 235 62 73 21 105 200 135 167 32 224 26 48 132 248 73 130 140 102 246 220 0 85 181 81 55 248 154 168 81 3 174 75 129 123 26 220 194 11 59 98 145 249 12 255 155 27 190 3 139 170 251 141 38 5 65 130 102 186 87 231 74 88 192 82 70 11 49 84 157 234 121 82 121 26 20 113 71 186 125 216 104 37 98 115 108 76 225 42 224 209 149 219 112 130 49 229 211 168 65 189 20 143 186 130 127 117 142 99 128 179 232 219 75 65 63 126 50 141 234 227 24 19 228 7 38 152 147 135 139 145 39 165 159 172 93 92 123 215 105 170 34 77 3 65 98 169 70 202 201 113 241 183 5 40 42 173 241 217 214 141 102 224 23 25 7 217 226 114 52 17 202 94 186 115 126 5 137 216 144 60 227 97 10 175 214 28 238 98 3 89 6 30 26 56 234 191 161 45 36 194 138 209 0 45 221 114 114 97 98 120 59 228 176 134 34 215 117 24 187 148 1 215 110 212 25 229 66 171 81 121 166 33 49 225 155 129 52 224 133 76 73 9 208 71 218 226 162 238 99 172 88 91 117 107 108 52 187 96 221 127 213 73 109 5 228 27 250 55 43 179 86 135 107 137 94 195 100 59 140 221 110 212 151 126 108 91 147 164 3 175 114 18 170 41 2 100 45 201 70 89 149 102 170 101 94 1 152 159 36 125 203 65 9 126 223 231 137 52 180 91 142 80 84 202 125 153 167 247 214 120 127 205 157 26 63 138 166 192 175 16 254 29 33 0 77 225 6 238 214 165 187 116 248 54 66 155 101 166 215 150 86 210 54 142 205 35 31 98 253 143 62 161 74 31 0 53 70 100 119 114 244 23 163 149 226 252 97 73 145 59 6 196 226 95 206 104 140 157 60 128 72 178 67 52 229 48 64 209 53 34 164 66 252 76 249 253 50 125 18 249 172 62 102 248 121 22 80 160 145 212 207 38 187 7 232 225 233 250 110 251 242 172 210 50 53 58 36 27 148 65 210 63 184 210 38 17 181 15 89 124 80 145 163 90 87 153 174 194 245 127 239 222 71 134 78 128 241 207 247 219 232 15 74 127 182 228 199 54 142 178 153 59 99 198 168 45 195 103 141 237 196 39 134 196 192 202 34 22 135 190 10 166 15 155 21 92 217 43 201 216 170 103 153 254 161 129 242 210 99 8 232 46 46 91 110 252 108 7 221 181 242 148 68 221 15 55 185 40 114 125 180 40 185 3 248 66 169 124 240 71 21 69 230 224 43 209 84 168 133 119 60 148 52 149 163 111 158 249 56 144 245 101 116 37 178 3 253 82 22 33 117 153 27 167 161 218 79 62 240 190 93 208 217 2 20 116 113 210 75 119 253 134 180 214 6 237 175 221 220 113 218 53 119 170 152 50 181 107 62 172 164 173 218 221 163 3 80 55 52 219 163 120 180 204 57 230 215 224 94 139 175 17 57 204 182 120 90 59 80 132 219 182 203 17 139 34 141 180 84 246 248 101 88 131 200 189 117 229 182 201 165 130 26 36 48 49 80 153 176 144 169 234 249 126 78 167 180 59 89 151 107 59 97 66 151 204 118 144 57 238 159 6 225 189 210 196 224 148 170 92 20 190 224 9 65 13 45 151 209 173 160 228 27 86 107 35 193 147 54 171 109 26 229 169 154 17 158 204 195 66 159 54 215 129 169 167 148 160 76 242 163 203 73 78 35 126 104 180 91 130 25 154 106 174 246 34 34 56 4 163 86 16 172 231 226 233 131 215 43 7 198 167 112 253 173 69 249 113 181 78 233 212 178 2 54 91 91 110 201 48 175 146 10 125 103 188 174 140 90 77 92 133 128 16 92 45 180 154 114 245 65 27 209 89 167 157 67 227 60 243 130 154 41 128 252 12 234 26 241 150 136 86 71 15 9 25 52 133 38 150 47 49 146 5 200 202 176 40 28 161 20 158 242 41 112 140 185 3 207 185 239 196 173 39 159 4 60 127 9 99 88 167 254 191 189 48 242 146 54 33 250 131 252 121 74 19 62 173 193 221 98 132 176 194 57 119 196 96 178 5 62 179 255 108 220 127 239 131 147 223 228 138 12 165 144 160 136 115 59 108 97 3 165 127 204 106 173 204 216 125 233 20 240 51 244 204 247 213 163 37 104 116 91 82 91 93 155 9 166 133 54 156 250 244 255 212 226 8 242 174 142 187 54 209 250 12 186 246 143 179 70 49 208 183 0 29 125 145 181 211 198 166 246 218 33 117 72 245 146 157 180 167 134 65 255 9 148 14 225 210 194 181 104 107 43 61 47 217 251 229 186 82 128 7 87 179 243 126 80 125 187 238 165 148 167 192 194 88 249 131 147 235 127 211 27 206 244 46 176 122 16 23 97 240 215 189 102 50 132 141 71 68 155 51 223 126 167 44 163 216 124 78 154 43 248 144 251 249 208 227 233 20 248 124 249 205 178 125 47 152 206 79 199 55 94 59 39 225 46 224 87 89 23 253 147 55 231 64 86 92 126 159 40 223 51 211 207 69 227 166 187 132 106 127 13 178 75 108 225 197 246 74 61 17 89 157 117 242 46 62 21 69 136 189 8 58 214 106 148 162 218 169 77 218 44 18 160 228 75 53 39 217 83 97 139 57 205 91 240 179 173 123 240 128 0 96 240 25 23 125 65 173 249 133 41 202 189 67 21 7 136 70 221 130 40 65 114 149 68 25 211 207 243 74 125 244 206 223 77 235 83 255 27 116 50 139 164 1 32 184 24 244 27 98 129 206 102 118 14 23 177 134 193 150 116 220 241 228 165 160 175 240 251 15 22 97 50 134 13 167 86 122 167 209 56 165 95 62 105 78 208 147 12 58 222 140 161 23 182 142 121 101 79 112 18 162 119 103 24 25 5 36 131 168 147 32 107 48 226 81 105 137 187 92 226 135 137 242 86 222 106 68 86 94 255 184 166 45 179 186 117 180 115 174 55 33 189 172 184 62 116 159 211 202 174 72 141 128 28 211 220 223 247 25 219 202 247 147 206 247 3 242 44 51 84 246 243 149 202 240 229 55 141 34 230 16 187 121 160 31 7 10 245 231 202 216 130 214 124 159 213 91 49 169 209 45 166 40 147 216 211 194 98 230 60 41 3 120 31 237 165 1 135 116 111 139 92 101 240 188 24 99 202 58 12 1 137 25 33 126 98 254 136 218 66 231 201 249 145 6 0 14 175 137 194 67 205 162 90 25 182 189 115 56 32 200 132 84 223 233 38 153 69 118 241 142 152 33 193 64 156 32 118 224 8 202 170 234 131 107 43 35 1 152 113 223 189 207 185 137 6 11 71 240 219 72 211 42 93 206 0 66 193 212 203 160 222 66 237 136 155 141 235 153 4 57 235 157 152 231 142 223 128 85 33 147 19 246 32 149 147 85 194 130 103 113 194 166 75 255 181 201 25 255 75 135 40 73 76 251 224 2 145 89 151 17 0 109 19 131 104 59 36 171 1 251 240 151 56 244 132 140 207 229 36 89 32 215 49 142 227 202 184 161 169 123 229 6 212 93 242 192 0 169 112 46 222 239 163 106 11 188 185 19 159 211 97 62 126 90 215 252 138 51 188 205 124 131 47 32 27 87 227 5 40 164 39 171 134 36 59 193 244 86 18 111 223 20 84 244 14 49 232 72 183 153 74 227 1 212 112 91 76 49 106 46 137 218 241 196 156 162 102 51 180 130 64 215 247 205 67 169 61 222 119 42 23 14 7 148 88 152 237 212 232 108 24 255 118 115 212 58 240 52 138 27 209 243 217 82 198 156 224 43 232 24 235 68 234 27 165 163 210 127 165 114 224 22 221 22 192 84 193 43 12 71 12 115 192 114 119 198 227 48 65 137 0 52 117 251 127 0 255 144 48 128 224 229 85 98 194 17 125 186 249 238 199 22 32 185 125 250 88 229 31 69 21 209 200 63 203 41 116 54 110 61 21 84 130 168 187 132 193 69 21 18 251 56 25 196 70 242 116 98 196 188 246 104 2 222 84 95 118 214 49 210 27 240 209 168 247 247 1 202 4 42 6 206 107 254 88 238 35 187 75 100 221 19 70 145 253 160 138 25 168 35 133 226 143 210 11 211 71 231 125 35 50 136 62 205 233 46 135 195 109 15 96 136 128 207 230 226 46 119 181 229 126 235 109 50 231 187 185 20 30 7 153 216 5 149 146 132 26 125 0 190 88 95 90 163 112 244 29 27 34 216 254 35 235 88 92 34 27 241 66 87 49 16 177 24 217 117 165 252 132 200 94 110 182 249 159 210 218 211 111 48 139 89 126 178 151 188 247 53 245 110 244 220 244 64 69 11 153 36 91 197 188 137 224 46 74 148 232 160 51 22 105 204 143 187 146 74 132 181 124 237 47 108 4 183 103 150 43 159 66 5 245 237 134 165 200 230 189 57 104 26 108 219 155 202 156 247 206 194 207 231 8 179 95 104 169 143 22 253 35 126 83 91 80 167 150 20 207 248 225 29 164 36 72 171 77 235 67 21 150 125 184 102 52 0 14 9 228 60 29 197 92 225 36 237 66 119 160 222 227 24 112 113 72 204 94 39 108 188 67 16 217 217 37 198 155 27 181 19 186 34 221 255 29 245 56 137 222 196 164 111 183 84 121 59 151 13 100 148 106 126 113 2 18 174 28 200 126 122 79 20 59 214 86 219 219 32 205 68 155 172 15 194 129 134 40 121 160 154 69 51 141 168 178 74 115 2 63 124 134 166 52 169 55 211 200 70 107 149 106 139 45 38 188 30 0 151 60 159 69 228 198 106 199 138 232 93 49 212 246 140 19 109 173 138 190 201 24 161 57 242 100 138 139 7 123 169 120 137 8 188 170 171 76 86 118 89 121 153 195 35 23 80 253 123 177 176 241 137 34 230 241 119 23 45 80 19 141 232 221 254 228 33 228 137 172 174 144 240 250 105 172 207 77 187 185 178 183 127 223 195 255 152 11 242 222 153 53 252 253 251 122 35 67 153 78 147 148 123 151 237 128 5 89 130 36 199 169 185 166 45 205 27 33 102 56 228 20 42 250 14 144 98 163 31 107 81 213 12 10 174 230 89 167 76 59 118 161 204 55 215 65 63 75 166 187 143 94 129 176 125 204 255 33 162 16 46 52 43 172 122 173 233 201 81 189 88 208 74 128 242 131 143 179 5 191 209 175 9 212 101 95 149 30 69 162 223 246 175 41 201 65 30 116 229 81 42 216 237 123 181 194 97 88 138 46 75 117 111 149 199 194 2 56 190 89 4 48 147 233 16 67 0 215 89 89 234 178 62 13 230 42 68 109 173 32 134 91 118 125 153 32 12 249 108 216 141 35 204 59 140 140 123 133 232 67 126 159 206 73 254 9 12 163 151 175 243 224 22 24 64 161 141 7 241 235 79 1 203 117 79 173 194 231 215 90 242 250 35 189 225 39 84 220 104 14 126 62 152 118 32 179 187 37 67 10 195 148 169 56 201 181 194 160 84 145 29 143 122 85 117 171 158 100 71 34 81 154 26 40 33 98 35 232 225 76 109 139 189 151 235 120 214 98 55 246 73 148 66 74 120 137 65 145 237 148 15 166 130 228 127 178 162 13 19 228 231 103 53 87 223 243 150 117 170 249 108 22 135 122 153 204 231 69 47 88 169 10 8 250 223 159 222 195 209 44 33 146 92 98 216 72 89 207 2 130 159 16 104 120 210 60 70 101 89 120 233 175 59 230 52 247 74 42 60 251 173 155 208 165 104 22 4 86 129 90 46 191 123 14 114 163 177 206 120 9 128 13 203 226 246 9 254 192 141 41 95 219 94 158 34 5 42 240 75 128 240 15 206 98 92 247 13 46 212 171 2 100 112 119 218 54 110 231 119 145 111 165 80 222 166 62 13 24 184 201 165 94 202 108 161 42 149 215 49 248 223 223 219 134 37 110 23 119 76 171 243 56 228 70 169 248 239 192 188 156 137 210 119 23 124 21 154 129 6 161 10 219 224 228 105 99 8 186 85 3 253 232 128 134 87 242 21 4 31 219 180 53 104 172 54 72 134 145 150 248 6 216 154 119 143 76 25 138 42 202 129 208 145 183 68 175 225 230 250 150 9 40 125 248 224 240 11 98 50 44 235 98 184 115 208 232 206 247 69 255 141 124 227 170 93 15 78 106 27 106 229 213 77 245 241 20 136 239 20 157 32 134 85 241 111 247 67 184 116 55 217 105 133 170 0 1 253 121 66 27 237 127 157 209 41 174 38 145 102 131 15 150 213 47 242 84 26 50 43 104 219 58 244 222 233 240 145 14 194 45 127 8 143 211 184 209 103 242 166 201 138 98 186 85 168 27 114 186 162 94 27 51 30 213 124 253 217 146 215 247 70 100 8 38 145 199 193 105 210 181 3 195 139 230 22 239 247 250 95 85 113 219 62 172 221 51 197 126 4 189 30 72 5 182 23 198 31 165 115 183 11 156 143 28 186 200 184 225 223 192 218 61 142 192 74 170 152 75 238 59 94 159 157 65 198 252 155 237 10 167 17 140 214 102 193 192 160 186 207 1 254 13 5 154 0 240 198 182 132 109 105 221 240 220 50 28 140 154 130 90 203 228 82 133 75 16 24 78 30 23 59 2 160 52 11 190 25 232 197 23 248 23 187 107 52 239 55 110 220 125 157 229 101 211 97 229 38 249 179 126 81 148 14 196 17 68 246 126 108 203 97 25 159 2 14 187 208 183 119 87 205 156 135 123 112 226 42 239 150 186 227 144 233 127 174 146 106 1 141 241 92 28 64 227 34 237 192 5 240 240 73 13 41 238 217 250 16 29 73 59 181 245 198 88 162 22 38 127 73 175 209 163 37 208 174 25 103 81 173 252 40 247 176 182 60 239 214 195 62 109 159 106 127 63 26 178 60 16 182 140 192 27 220 90 48 204 20 160 58 77 81 167 75 105 27 197 240 84 156 255 44 207 0 229 163 219 187 45 227 28 5 215 176 228 64 158 126 242 155 219 241 182 52 213 170 21 83 87 35 104 166 201 198 213 29 47 22 92 255 147 59 69 65 19 116 168 109 72 37 139 135 8 77 12 95 175 194 191 3 44 9 162 32 208 47 113 4 146 42 244 13 211 200 9 173 132 11 78 32 192 219 212 154 133 187 54 67 136 188 113 148 150 98 211 206 112 227 83 231 121 48 106 225 94 32 17 205 71 206 236 61 14 152 47 169 219 58 67 162 103 57 171 165 251 60 58 44 117 27 130 84 84 229 185 10 65 189 59 234 157 28 152 94 9 243 28 1 183 44 91 163 144 131 153 235 110 234 77 10 9 102 39 105 19 238 63 184 84 174 114 25 70 223 205 160 244 251 158 208 0 98 101 182 251 221 136 10 207 224 237 237 192 85 209 106 120 57 167 113 229 133 144 206 230 125 8 213 136 156 81 134 82 231 199 42 214 201 101 163 93 11 193 20 118 248 5 143 101 5 85 104 193 20 156 62 191 182 120 222 20 21 190 59 11 197 165 208 11 12 126 173 76 247 47 6 43 195 225 138 99 53 231 200 122 207 98 72 71 233 105 118 53 12 89 18 59 9 181 138 114 221 216 112 112 243 104 53 67 230 240 246 84 48 96 30 75 49 236 227 8 179 36 40 210 106 152 186 139 68 96 63 185 209 87 180 149 252 100 235 50 119 44 185 170 15 109 134 53 100 250 241 130 221 24 165 155 120 255 92 161 246 189 90 170 83 126 133 120 65 50 20 103 85 4 238 222 239 99 172 143 173 156 230 121 126 136 23 14 161 104 27 112 86 27 228 254 193 99 209 214 6 183 40 133 9 192 3 139 145 52 23 161 39 56 243 130 61 37 67 58 0 184 185 186 167 122 94 95 143 41 8 7 0 72 243 15 41 137 70 106 41 43 132 192 229 2 71 193 22 161 136 247 155 35 19 154 126 64 202 208 225 52 217 200 81 184 188 64 96 156 156 220 130 123 81 53 43 174 157 238 156 69 52 164 105 213 34 78 186 230 29 97 161 127 229 102 57 239 119 109 94 255 103 223 139 63 157 188 210 72 178 239 109 9 178 157 215 177 64 0 216 70 178 62 13 112 232 54 182 192 28 110 211 23 137 221 202 185 44 245 71 105 211 53 97 178 252 35 88 214 94 60 150 160 71 51 103 110 183 220 204 211 71 250 136 152 167 63 199 124 12 85 141 170 138 43 6 147 8 242 19 181 247 110 13 159 229 169 86 178 193 223 36 0 140 213 152 63 166 40 99 202 35 56 225 7 49 0 139 56 122 116 83 195 98 45 220 184 48 68 115 62 196 58 121 6 124 90 6 154 79 55 161 58 51 143 75 188 18 194 50 17 28 118 13 77 108 183 84 181 120 192 164 50 252 79 215 249 191 75 132 68 33 23 142 241 42 225 61 183 103 137 145 105 100 187 23 1 44 160 242 64 8 153 182 70 101 154 124 162 157 188 2 98 210 57 1 110 238 205 131 90 56 152 176 125 19 50 40 233 94 192 109 60 199 234 238 93 135 53 214 4 66 120 189 7 177 233 86 86 242 84 65 79 1 180 218 246 240 177 125 112 68 185 240 160 11 128 235 157 110 35 255 248 4 150 195 154 243 69 170 206 69 168 161 244 47 173 152 4 30 193 62 101 119 43 26 5 206 145 50 127 101 44 176 219 205 102 250 113 139 0 29 184 46 174 136 190 109 43 184 244 114 118 209 146 41 73 49 85 30 184 28 227 134 97 225 4 207 220 199 217 5 141 9 60 241 25 57 203 238 110 78 184 101 26 187 173 98 212 90 71 132 193 18 210 57 18 41 245 124 145 170 249 100 122 206 244 113 248 64 189 39 109 102 32 139 233 205 139 3 187 46 248 130 5 214 18 198 69 116 202 201 210 114 137 113 242 47 133 170 137 112 127 9 172 217 230 9 239 121 91 22 153 219 95 0 161 232 197 87 188 146 12 128 236 57 223 240 221 159 168 62 26 245 228 186 177 203 116 23 32 225 219 66 23 162 137 198 253 237 158 164 117 123 109 24 52 71 66 149 76 123 14 31 15 217 11 129 242 207 171 224 118 4 252 192 83 194 144 27 118 32 144 181 138 227 193 233 41 13 138 231 110 135 229 194 190 195 153 59 3 231 180 5 148 120 125 210 69 206 222 166 97 118 252 132 64 76 65 233 104 183 212 102 204 56 203 57 133 171 33 218 63 156 152 197 14 185 178 248 106 217 246 140 123 63 248 168 161 63 133 233 9 37 140 241 89 171 246 72 145 63 157 104 149 168 47 235 236 108 6 178 200 53 47 95 56 78 217 112 190 22 31 249 113 231 20 224 84 25 151 24 69 226 25 24 16 222 108 91 219 201 151 124 14 107 21 101 67 190 167 61 46 201 61 162 226 215 211 165 132 13 187 166 138 49 209 94 64 12 97 83 101 171 132 220 170 164 34 253 239 84 145 172 65 191 75 51 199 18 210 30 117 176 120 134 148 180 223 62 224 154 235 115 161 2 91 253 176 108 58 101 43 96 19 134 141 156 40 90 127 134 121 83 109 233 221 236 241 108 54 130 169 85 10 230 123 110 227 43 94 7 155 250 195 253 22 167 11 168 98 85 73 171 64 8 46 242 155 79 3 29 250 65 197 166 255 53 111 110 170 229 128 111 230 249 27 229 119 65 126 100 90 193 191 97 238 71 218 190 0 0 23 187 138 146 56 152 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 16:13'!macAsyncFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#define OLDROUTINELOCATIONS 1#include "sq.h"#include "AsynchFilePlugin.h"/* initialize/shutdown */int asyncFileInit() { return true; }int asyncFileShutdown() {}/* End of adjustments for pluginized VM *//*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 16:15'!macBrowserPluginFile	^ '/********** Notes on Browser Plugin VM ************How it Works:The browser plugin VM allows Squeak to be run as a plug-in underversion 4.0 and later of either Netscape Navigator or Internet Explorer.To use it, you must translate a version of interp.c with the browser pluginhooks. These hooks work by causing the VM to save the state of the currentSqueak process and return control from the interpret() after a shortperiod of time (e.g., 1/15th second). This allows the browser to processevents and perform other tasks. Eventually, the browser calls NPP_HandleEvent()with a NULL event, thus re-entering the Squeak interpret loop. The key toefficiency is to not return control to the browser too often, since thebrowser is quite slow to send the next null event. The VM does thisby polling for events itself; if there are no events in the OS queue,then it return control to the browser much less often.Relationship of this file to sqMacWindow.c:One can think of this file as specializing and extending sqMacWindow.cfor running within a browser. Certain methods in  sqMacWindow.c arereplaced by functions defined here. The originals are removed fromsqMacWindow.c by defining the PLUGIN flag in that file when compiling.Here is a list of the functions overridden:	ioExit()	ioScreenSize()	ioSetFullScreen()	sqAllocateMemory()    plugInAllowAccessToFilePath()In addition, ioProcessEvents() becomes a noop and main() is completelyomitted when sqMacWindow.c is compiled for use in the browser plugin VM.**********/#include "sq.h"#include "FilePlugin.h"#include "npapi.h"#include <Events.h>#include <Files.h>#include <Notification.h>#include <Strings.h>/********** Compilation Options:**	DISNEY*	  Define this to build the Disney Online browser plugin. In this*	  case the image file and Squeak file sandbox are located in the*	  Disney Online folder, and the image name is "dolsqueak.image".**	ENABLE_URL_FETCH*	  Define this to compile primitives to fetch URL''s via the browser.**	  Warning: Fetching file URL''s through the URL fetch mechanism allows*	  potentially untrusted code to read files outside of the Squeak*	  file system "sandbox", a serious breach of privacy. Outside*	  of Disney, there are few uses for use for the browser URL fetch*	  mechanism, since you can always fetch URL''s from remote servers*	  using Squeak''s own HTTPSocket.***********///#define DISNEY#ifdef DISNEY# define IMAGE_NAME "dolsqueak.image"# define ENABLE_URL_FETCH#else# define IMAGE_NAME "squeak.image"#endif/*** Exported Primitives ***/#ifdef ENABLE_URL_FETCH#pragma export onint primitivePluginBrowserReady(void);int primitivePluginDestroyRequest(void);int primitivePluginRequestFileHandle(void);int primitivePluginRequestState(void);int primitivePluginRequestURL(void);int primitivePluginRequestURLStream(void);#pragma export off#endif/* Constants */#define MAX_STRING_LENGTH 255#define STATUS_BAD_HANDLE -1#define STATUS_IDLE 0#define STATUS_IN_PROGRESS 1#define STATUS_FAILED 2#define STATUS_SUCCEEDED 3/*** Imported Variables ***/extern int interruptKeycode;extern unsigned char *memory;extern WindowPtr stWindow;extern char documentName[];  /* full path to document file */extern char imageName[];  /* full path to image file */extern char shortImageName[];  /* just the image file name */extern char vmPath[];  /* full path to interpreter''s directory */extern struct VirtualMachine *interpreterProxy;extern int thisSession;  /* from sqFilePrims.c: *//*** Local Variables ***/int			exitRequested	= false;CGrafPort	gSavePort;CGrafPtr	gOldPort		= nil;int			interpStartTime	= 0;int			needsUpdate		= false;NPWindow* 	netscapeWindow	= nil;Str255		notificationMsg = "";NMRec		notifyRec;int			pluginArgCount	= 0;char		*pluginArgName[100];char		*pluginArgValue[100];int			squeakHeapMBytes = 15;  /* default heap size, override via the "memory" EMBED tag */char		squeakPluginImageName[] = IMAGE_NAME;NPP			thisInstance	= nil;#define URL_REQUEST_COUNT 100typedef struct {	int id;  /* used to associate a request with its outcome */	int status;	int semaIndex;	char fileName[MAX_STRING_LENGTH + 1];} URLRequestRecord;URLRequestRecord urlRequests[URL_REQUEST_COUNT];int nextRequestID = 1;/*** Functions Imported from sqMacWindow ***/int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Local Functions ***/int CaseInsensitiveMatch(char *s1, char *s2);void EndDraw(void);void ExitCleanup(void);int FindIdleURLRequest(void);int InitFilePaths(void);void InitURLRequestTable(void);int IsPrefixedBy(char *s, char *prefix);void OpenFileReadOnly(SQFile *f, char *fileName);void ReadSqueakImage(void);void StartDraw(void);int StringToInteger(char *s);void URLRequestCompleted(int notifyData, const char* fileName);int URLRequestCreate(char *url, char *target, int semaIndex);void URLRequestDestroy(int requestHandle);void URLRequestFailed(int notifyData, int reason);char * URLRequestFileName(int requestHandle);int URLRequestStatus(int requestHandle);/*** Initialize/Shutdown ***/NPError NPP_Initialize(void) {	exitRequested = false;	needsUpdate = false;	netscapeWindow = nil;	pluginArgCount = 0;	squeakHeapMBytes = 20;	thisInstance = nil;	InitURLRequestTable();	return NPERR_NO_ERROR;}void NPP_Shutdown(void) {	ExitCleanup();}/*** Instance Create/Destroy ***/NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode,  int16 argc, char* argn[], char* argv[], NPSavedData* saved) {	int i;	/* only Squeak instance can be active at a time */	if (thisInstance !!= nil) return NPERR_GENERIC_ERROR;	for (i = 0; i < 100; i++) {		pluginArgName[i] = pluginArgValue[i] = "";	}	/* record plugin arguments */	pluginArgCount = argc;	for (i = 0; (i < argc) && (i < 100); i++) {		pluginArgName[i] = (char *) NPN_MemAlloc(strlen(argn[i]) + 1);		strcpy(pluginArgName[i], argn[i]);		pluginArgValue[i] = (char *) NPN_MemAlloc(strlen(argv[i]) + 1);		strcpy(pluginArgValue[i], argv[i]);		if (CaseInsensitiveMatch(pluginArgName[i], "memory")) {			squeakHeapMBytes = StringToInteger(pluginArgValue[i]);		}	}	memory = nil;	ReadSqueakImage();	if (!!memory) return NPERR_GENERIC_ERROR;	thisInstance = instance;	return NPERR_NO_ERROR;}NPError NPP_Destroy(NPP instance, NPSavedData** save) {	ExitCleanup();	return NPERR_NO_ERROR;}NPError NPP_SetWindow(NPP instance, NPWindow* window) {	NP_Port* port;	netscapeWindow = window;	port = (NP_Port *) netscapeWindow->window;	stWindow = (WindowPtr) port->port;	needsUpdate	= true;	return NPERR_NO_ERROR;}/*** Streaming ***/NPError NPP_NewStream(  NPP instance, NPMIMEType type,  NPStream *stream, NPBool seekable, uint16 *stype) {  /* Call to load the initial URL and to handle explicit URL fetch requests. */	*stype = NP_ASFILEONLY;  /* ask Netscape to cache file and call NPP_StreamAsFile */	return NPERR_NO_ERROR;}NPError NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason) {	return NPERR_NO_ERROR;}void NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname) {	if (fname !!= null) {		URLRequestCompleted((int) stream->notifyData, fname);	} else {		URLRequestFailed((int) stream->notifyData, 1);	}}void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData) {	if (reason !!= NPRES_DONE) {		URLRequestFailed((int) notifyData, reason);	}}int32 NPP_WriteReady(NPP instance, NPStream *stream) {  /* not used, because we use ASFILEONLY mode */	return 100000;}int32 NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer) {  /* not used, because we use ASFILEONLY mode */	return len;}/*** Printing ***/void NPP_Print(NPP instance, NPPrint* printInfo) {	/* printing is not supported */}/*** Event Handling ***/int16 NPP_HandleEvent(NPP instance, void *rawEvent) {	EventRecord *eventPtr = (EventRecord*) rawEvent;	if (exitRequested) {		ExitCleanup();		return false;	}	if ((thisInstance == nil) || (eventPtr == NULL)) {		/* no instance or no event; do nothing */		return false;	}	recordModifierButtons(eventPtr);	switch (eventPtr->what) {		case mouseDown:			recordMouseDown(eventPtr);		break;		case keyDown:		case autoKey:			recordKeystroke(eventPtr);		break;		case updateEvt:			needsUpdate = true;		break;		case nullEvent:			/* interpret some bytecodes on every event */			if (memory) {  /* but only if the VM has memory!! */				StartDraw();				interpret();				EndDraw();			}		break;	}	if (needsUpdate && (netscapeWindow !!= nil) && (memory)) {		StartDraw();		fullDisplayUpdate();  /* ask VM to call ioShowDisplay */		EndDraw();		needsUpdate = false;	}	return true;}/*** Drawing ***/void EndDraw(void) {	SetOrigin(gSavePort.portRect.left, gSavePort.portRect.top);	SetClip(gSavePort.clipRgn);	SetPort((GrafPtr) gOldPort);}void StartDraw(void) {	NP_Port* port;	Rect clipRect;	port = (NP_Port *) netscapeWindow->window;	/* save old graphics port and switch to ours */	GetPort((GrafPtr *) &gOldPort);	SetPort((GrafPtr) port->port);	stWindow = (WindowPtr) port->port;	/* save old drawing environment */	gSavePort.portRect = port->port->portRect;	GetClip(gSavePort.clipRgn);	/* setup our drawing environment */	SetOrigin(port->portx, port->porty);	clipRect.top    = netscapeWindow->clipRect.top    + port->porty;	clipRect.left   = netscapeWindow->clipRect.left   + port->portx;	clipRect.bottom = netscapeWindow->clipRect.bottom + port->porty;	clipRect.right  = netscapeWindow->clipRect.right  + port->portx;	ClipRect(&clipRect);	BackColor(whiteColor);  /* needed to avoid funny colors */}/*** Image File Reading ***/void ReadSqueakImage(void) {	sqImageFile f;	char msg[500];	plugInInit(squeakPluginImageName);	InitFilePaths();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		strcpy(msg, "Could not open Squeak image file \"");		strcat(msg, imageName);		strcat(msg, "\"");		plugInNotifyUser(msg);		return;	}	readImageFromFileHeapSizeStartingAt(f, squeakHeapMBytes * 1000000, 0);	sqImageFileClose(f);	interruptKeycode = 515;  /* ctrl-C, since Netscape blocks cmd-. */}/*** URL Requests ***/int URLRequestCreate(char *url, char *target, int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	NPN_GetURLNotify(thisInstance, url, target, (void *) notifyData);	Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded */	StartDraw();	return handle;}void URLRequestDestroy(int requestHandle) {  /* Clear the url request with the given handle. */	if ((requestHandle < 0) || (requestHandle >= URL_REQUEST_COUNT)) {		return;	}	urlRequests[requestHandle].id = 0;	urlRequests[requestHandle].status = STATUS_IDLE;	urlRequests[requestHandle].semaIndex = 0;	urlRequests[requestHandle].fileName[0] = 0;}char * URLRequestFileName(int requestHandle) {  /* Return the filename associated with the url request with the given     handle. Return null if the request status is not STATUS_SUCCEEDED. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status !!= STATUS_SUCCEEDED)) {			return null;	}	return urlRequests[requestHandle].fileName;}int URLRequestStatus(int requestHandle) {  /* Return the status of the url request with the given handle. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status < STATUS_IN_PROGRESS)) {			return STATUS_BAD_HANDLE;	}	return urlRequests[requestHandle].status;}int FindIdleURLRequest(void) {  /* Return the index of an idle request or -1 if there are none. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		if (urlRequests[i].status == STATUS_IDLE) {			return i;		}	}	return -1;}void URLRequestCompleted(int notifyData, const char* fileName) {  /* Record that the given request has completed, caching the result in     the given file name. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		strncpy(urlRequests[handle].fileName, fileName, MAX_STRING_LENGTH);		urlRequests[handle].status = STATUS_SUCCEEDED;		signalSemaphoreWithIndex(urlRequests[handle].semaIndex);	}}void URLRequestFailed(int notifyData, int reason) {  /* Record that the given URL request failed. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		/* Note: For local files, we''re informed that there was a network		   error (but only after NPP_StreamAsFile has reported success).		   We could allow local files to be read through the URL request		   mechanism but NOT failing here if the status has already been		   set to success. But we don''t want to allow the URL mechanism		   to be used as a loophole to read files outside the sandbox, so		   we let this fail. */		if (urlRequests[handle].status !!= STATUS_SUCCEEDED) {			urlRequests[handle].status = STATUS_FAILED;			signalSemaphoreWithIndex(urlRequests[handle].semaIndex);		}	}}void InitURLRequestTable(void) {  /* Initialize the table of URL requests. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		URLRequestDestroy(i);	}	nextRequestID = 1;}/*** Squeak I/O Support and Memory Allocation ***/int ioExit(void) {  /* Request that we stop running plugin. */	plugInForceTimeToReturn();	thisInstance = nil;	exitRequested = true;}int ioScreenSize(void) {	int w = 10, h = 10;	if (netscapeWindow !!= nil) {		w = netscapeWindow->clipRect.right - netscapeWindow->clipRect.left;		h = netscapeWindow->clipRect.bottom - netscapeWindow->clipRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSetFullScreen(int fullScreen) {	/* noop */}void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {  /* Allocate the Squeak object heap memory from the system heap. */	MaxBlockSys();	return NewPtrSys(desiredHeapSize);}/*** File and Access Paths ***/int InitFilePaths(void) {	short vRefNum;	long ignore;	Str255 volumeName;	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	/* get the default volume */	GetVInfo(0, volumeName, &vRefNum, &ignore);	/* set the vmPath */	strcpy(vmPath, p2cstr(volumeName));	strcat(vmPath, ":Disney:Disney Online:Squeak");	/* set the short and full image names */	strcpy(shortImageName, squeakPluginImageName);	strcpy(imageName, vmPath);	strcat(imageName, ":Files:");	strcat(imageName, shortImageName);}int IsPrefixedBy(char *s, char *prefix) {  /* Return true if the given string begins with or equals the given prefix. */	int i;	for (i = 0; prefix[i] !!= 0; i++) {		if (s[i] !!= prefix[i]) return false;	}	return true;}int plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Return true if access to the given file is allowed. */	int i;	char path[2000];	/* copy path into C string */	if (pathStringLength >= 2000) return false;  /* path too long */	for (i = 0; i < pathStringLength; i++) {		path[i] = pathString[i];	}	path[pathStringLength] = 0;	/* disallow relative path names that might access a parent folder */	for (i = 0; i < pathStringLength; i++) {		if ((path[i] == '':'') && (path[i+1] == '':'')) {			return false;		}	}	return IsPrefixedBy(path, vmPath);}/*** Optional URL Fetch Primitives ***/#ifdef ENABLE_URL_FETCHint primitivePluginBrowserReady(void) {	/* Args: none.	   Always return true on Macintosh. */	interpreterProxy->pop(1);	interpreterProxy->pushBool(1);}int primitivePluginDestroyRequest(void) {	/* Args: handle.	   Destroy the given request. */	int handle;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	URLRequestDestroy(handle);	interpreterProxy->pop(1);}int primitivePluginRequestFileHandle(void) {	/* Args: handle.	   Return a file handle for the completed request. Fail if	   the request handle is not valid or hasn''t successfully completed. */	int handle, fileObj;	char *fileName;	SQFile *filePtr;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	fileName = URLRequestFileName(handle);	if (fileName == null) {		interpreterProxy->success(false);		return null;	}	fileObj = interpreterProxy->instantiateClassindexableSize(		interpreterProxy->classByteArray(), sizeof(SQFile));	filePtr = (SQFile *) (fileObj + 4);	/* Note: OpenFileReadOnly() allows any file on the disk to be read via a file URL.	   However, we are using it for now because we are not sure where the Netscape cache	   folder will be--it''s folder might even be user-name dependent. sqFileOpen() will	   only allow opening files within the sandbox, which would be better. Here''s the	   sandbox-safe alternative:		  sqFileOpen(filePtr, (int) fileName, strlen(fileName), false);	*/	OpenFileReadOnly(filePtr, fileName);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(2);	interpreterProxy->push(fileObj);}int primitivePluginRequestState(void) {	/* Args: handle.	   Return true if the request succeeded, false if it failed, and nil if	   it is still in progress. Fail if the request handle is not valid. */	int handle;	int status;	int resultObj;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	status = URLRequestStatus(handle);	if (status == STATUS_BAD_HANDLE) {		interpreterProxy->success(false);		return null;	}	/* default return object: (nil means "in progress") */	resultObj = interpreterProxy->nilObject();	if (status == STATUS_FAILED) {		resultObj = interpreterProxy->falseObject();	}	if (status == STATUS_SUCCEEDED) {		resultObj = interpreterProxy->trueObject();	}	interpreterProxy->pop(2);	interpreterProxy->push(resultObj);}int primitivePluginRequestURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to fetch the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	targetObj = interpreterProxy->stackObjectValue(1);	urlObj = interpreterProxy->stackObjectValue(2);	interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	handle = URLRequestCreate(url, target, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(4);	interpreterProxy->pushInteger(handle);}int primitivePluginRequestURLStream(void) {	/* Args: url, semaphoreIndex.	   Start a URL request to fetch the given URL. Return a handle that	   can be used to identify this request. Fail if there are already	   too many outstanding requests. */	int urlObj, urlSize, semaIndex;	char *urlPtr;	char url[MAX_STRING_LENGTH + 1];	int handle, i;	semaIndex = interpreterProxy->stackIntegerValue(0);	urlObj = interpreterProxy->stackObjectValue(1);	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	handle = URLRequestCreate(url, null, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(3);	interpreterProxy->pushInteger(handle);}void OpenFileReadOnly(SQFile *f, char *fileName) {	/* Opens the given file for reading using the supplied sqFile	   structure. This is a simplified version of sqFileOpen() that	   avoids the "sandbox" access check, since the browser''s	   cache folder is outside the Squeak sandbox. That is why	   we only allow reading of this file. Sets the primitive	   failure flag if not successful. */	f->file = fopen(fileName, "rb");	f->writable = false;	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		interpreterProxy->success(false);		return;	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = 0;}#endif/*** Other ***/int CaseInsensitiveMatch(char *s1, char *s2) {  /* Return true if the two strings are the same, not considering case. */	int len, i, c1, c2;	len = strlen(s1);	if (strlen(s2) !!= len) return false;	for (i = 0; i < len; i++) {		c1 = s1[i];		c2 = s2[i];		if ((c1 >= ''a'') && (c1 <= ''z'')) {			c1 = c1 - (''a'' - ''A'');		}		if ((c2 >= ''a'') && (c2 <= ''z'')) {			c2 = c2 - (''a'' - ''A'');		}		if (c1 !!= c2) return false;	}	return true;}void ExitCleanup(void) {  /* Clean up and stop running plugin. */	thisInstance = nil;	plugInShutdown();	NPP_Initialize();  /* reset local variables */	MaxBlockSys();}int StringToInteger(char *s) {  /* Answer the integer resulting from converting the given     string, assumed to be decimal integer. */	int sign, n, i, ch;	sign = 1;	n = 0;	i = 0;	while ((ch = s[i++]) !!= 0) {		if ((ch == ''-'') && (i == 1)) {			sign = -1;		} else {			if ((ch >= ''0'') && (ch <= ''9'')) {				n = (10 * n) + (ch - ''0'');			} else {				return sign * n;			}		}	}	return sign * n;}/*** Interpreter Hooks ***/void plugInForceTimeToReturn(void) {  /* Ensure that the next call to pluginTimeToReturn() will return true. */	interpStartTime = clock() - 1000;}int plugInNotifyUser(char *msg) {  /* Notify the user that there was a problem starting Squeak. */	strcpy((char *) notificationMsg, msg);  /* copy message, since notification is asynchronous */	c2pstr((char *) notificationMsg);	notifyRec.qType = nmType;	notifyRec.nmMark = false;			/* no mark in applications menu */	notifyRec.nmIcon = nil;				/* no menu bar icon */	notifyRec.nmSound = (Handle) -1;	/* -1 means system beep */	notifyRec.nmStr = notificationMsg;	notifyRec.nmResp = (NMUPP) -1;		/* -1 means remove notification when user confirms */	/* add to notification queue */	NMInstall(&notifyRec);}void plugInSetStartTime(void) {  /* Set that time at which interpret() was started. */	interpStartTime = clock();}int plugInTimeToReturn(void) {  /* Return true if it is time to return from interpret(). */	EventRecord evt;	int delta = clock() - interpStartTime;	if ((delta < 0) || (delta >= 20)) {		/* let Netscape have control every so often whether or		   not there are pending events */		return true;	}	if ((delta & 0x3) == 0x3) {		/* check every 4 ticks; if pending events, return to the browser */		if (OSEventAvail(everyEvent, &evt)) return true;	}	return false;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 16:25'!macDNRFile	^ '/* 		File:		DNR.c 		Contains:	DNR library for MPW  	Copyright:	 1989-1995 by Apple Computer, Inc., all rights reserved	Version:	Technology:			Networking				Package:			Use with MacTCP 2.0.6 and the Universal									Interfaces 2.1b1				Change History (most recent first):		<3>	 1/23/95	rrk  	implemented use of universal procptrs		 						Changed selector name HINFO to HXINFO		 						due to conflict of name in MacTCP header		 						Removed use of TrapAvailable and exchanged		 						for the TrapExists call.								Changed symbol codeHandle to gDNRCodeHndl								Changed symbol dnr to gDNRCodePtr	Further modifications by Steve Falkenburg, Apple MacDTS 8/91	Modifications by Jim Matthews, Dartmouth College, 5/91	*/#include "sq.h"#ifndef __OSUTILS__#include <OSUtils.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FILES__#include <Files.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TRAPS__#include <Traps.h>#endif#ifndef __GESTALT__#include <Gestalt.h>#endif#ifndef __FOLDERS__#include <Folders.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __MACTCP__#include "MacTCP.h"#endif#ifndef __ADDRESSXLATION__#include "AddressXlation.h"#endif// think C compatibility stuff#ifndef	_GestaltDispatch#define	_GestaltDispatch	_Gestalt#endif/* RRK Modification 1/95 - commenting out the following defines as they are	defined in the DNRCalls.h header file*/void GetSystemFolder(short *vRefNumP, long *dirIDP);void GetCPanelFolder(short *vRefNumP, long *dirIDP);short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID);short OpenOurRF(void);short	NumToolboxTraps(void);TrapType	GetTrapType(short theTrap);Boolean TrapExists(short theTrap);static Handle 			gDNRCodeHndl = nil;static ProcPtr			gDNRCodePtr = nil;/*	Check the bits of a trap number to determine its type. *//* InitGraf is always implemented (trap $A86E).  If the trap table is big** enough, trap $AA6E will always point to either Unimplemented or some other** trap, but will never be the same as InitGraf.  Thus, you can check the size** of the trap table by asking if the address of trap $A86E is the same as** $AA6E. */#pragma segment UtilMainshort	NumToolboxTraps(void){	if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))		return(0x200);	else		return(0x400);}#pragma segment UtilMainTrapType	GetTrapType(short theTrap){	/* OS traps start with A0, Tool with A8 or AA. */	if ((theTrap & 0x0800) == 0)					/* per D.A. */		return(OSTrap);	else		return(ToolTrap);}Boolean TrapExists(short theTrap){	TrapType	theTrapType;	theTrapType = GetTrapType(theTrap);	if ((theTrapType == ToolTrap) && ((theTrap &= 0x07FF) >= NumToolboxTraps()))		theTrap = _Unimplemented;	return(NGetTrapAddress(_Unimplemented, ToolTrap) !!= NGetTrapAddress(theTrap, theTrapType));}void GetSystemFolder(short *vRefNumP, long *dirIDP){	SysEnvRec info;	long wdProcID;		SysEnvirons(1, &info);	if (GetWDInfo(info.sysVRefNum, vRefNumP, dirIDP, &wdProcID) !!= noErr) 	{		*vRefNumP = 0;		*dirIDP = 0;	}}void GetCPanelFolder(short *vRefNumP, long *dirIDP){	Boolean hasFolderMgr = false;	long feature;		if (TrapExists(_GestaltDispatch)) if (Gestalt(gestaltFindFolderAttr, &feature) == noErr) hasFolderMgr = true;	if (!!hasFolderMgr) 	{		GetSystemFolder(vRefNumP, dirIDP);		return;	}	else 	{		if (FindFolder(kOnSystemDisk, kControlPanelFolderType, kDontCreateFolder, vRefNumP, dirIDP) !!= noErr) 		{			*vRefNumP = 0;			*dirIDP = 0;		}	}}	/* SearchFolderForDNRP is called to search a folder for files that might 	contain the ''dnrp'' resource */short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID){	HParamBlockRec fi;	Str255 filename;	short refnum;		fi.fileParam.ioCompletion = nil;	fi.fileParam.ioNamePtr = filename;	fi.fileParam.ioVRefNum = vRefNum;	fi.fileParam.ioDirID = dirID;	fi.fileParam.ioFDirIndex = 1;		while (PBHGetFInfo(&fi, false) == noErr) 	{		/* scan system folder for driver resource files of specific type & creator */		if (fi.fileParam.ioFlFndrInfo.fdType == targetType &&			fi.fileParam.ioFlFndrInfo.fdCreator == targetCreator) 		{			/* found the MacTCP driver file? */			refnum = HOpenResFile(vRefNum, dirID, filename, fsRdPerm);			if (GetIndResource(''dnrp'', 1) == NULL)				CloseResFile(refnum);			else				return refnum;		}		/* check next file in system folder */		fi.fileParam.ioFDirIndex++;		fi.fileParam.ioDirID = dirID;	/* PBHGetFInfo() clobbers ioDirID */	}	return(-1);}	/* OpenOurRF is called to open the MacTCP driver resources */short OpenOurRF(void){	short refnum;	short vRefNum;	long dirID;		/* first search Control Panels for MacTCP 1.1 */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''ztcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* next search System Folder for MacTCP 1.0.x */	GetSystemFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* finally, search Control Panels for MacTCP 1.0.x */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			return -1;}	OSErr OpenResolver(char *fileName){	short 			refnum;	OSErr 			rc;		if (gDNRCodePtr !!= nil)		/* resolver already loaded in */		return(noErr);			/* open the MacTCP driver to get DNR resources. Search for it based on	   creator & type rather than simply file name */		refnum = OpenOurRF();	/* ignore failures since the resource may have been installed in the 	   System file if running on a Mac 512Ke */	   	/* load in the DNR resource package */	gDNRCodeHndl = GetIndResource(''dnrp'', 1);	if (gDNRCodeHndl == nil)	{		/* can''t open DNR */		return(ResError());	}		DetachResource(gDNRCodeHndl);	if (refnum !!= -1) 	{		CloseResFile(refnum);	}			/* lock the DNR resource since it cannot be reloated while opened */	MoveHHi(gDNRCodeHndl);	HLock(gDNRCodeHndl);		gDNRCodePtr = (ProcPtr)*gDNRCodeHndl;		/* call open resolver */	// RRK modification 1/95 use CallOpenResolverProc define to call UPP		rc = CallOpenResolverProc(gDNRCodePtr, OPENRESOLVER, fileName);	if (rc !!= noErr) 	{		/* problem with open resolver, flush it */		HUnlock(gDNRCodeHndl);		DisposeHandle(gDNRCodeHndl);		gDNRCodePtr = nil;	}	return(rc);}OSErr CloseResolver(void){		if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			/* call close resolver */	// RRK modification 1/95 use CallCloseResolverProc define to call UPP	// (void) (*dnr)(CLOSERESOLVER);	CallCloseResolverProc(gDNRCodePtr, CLOSERESOLVER);		/* release the DNR resource package */	HUnlock(gDNRCodeHndl);	DisposeHandle(gDNRCodeHndl);	gDNRCodePtr = nil;	return(noErr);}	// RRK modification 1/95 declare parameter resultProc to be of type 	// ResultProcUPP instead of a long	OSErr StrToAddr(char *hostName, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallStrToAddrProc define to call UPP	// return((*dnr)(STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));				return (CallStrToAddrProc(gDNRCodePtr, STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));}	OSErr AddrToStr(unsigned long addr, char *addrStr){	OSErr	err;	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToStrProc define to call UPP	// (*dnr)(ADDRTOSTR, addr, addrStr);		err = CallAddrToStrProc(gDNRCodePtr, ADDRTOSTR, addr, addrStr);	return(noErr);}	OSErr EnumCache(EnumResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallEnumCacheProc define to call UPP	// return((*dnr)(ENUMCACHE, resultproc, userDataPtr));	return (CallEnumCacheProc(gDNRCodePtr, ENUMCACHE, resultproc, userDataPtr));}		OSErr AddrToName(unsigned long addr, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToNameProc define to call UPP	// return((*dnr)(ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));	return(CallAddrToNameProc(gDNRCodePtr, ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));}extern OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(HINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallHInfoProc(gDNRCodePtr, HXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	extern OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallMXInfoProc(gDNRCodePtr, MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	/* removed ; (causes syntax err in Think C 5.0 */	'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'di 6/9/2000 21:57'!macNetworkFile	^ '#include <ConditionalMacros.h>#if TARGET_CPU_PPC || GENERATINGPOWERPC#include <MacHeaders.h>#include <OpenTptInternet.h>		// includes OpenTransport.h#include <OpenTptClient.h>			// needed for OTReleaseBuffer()#include <stropts.h>#include "sq.h"#include "SocketPlugin.h"/*  May 1st 2000	An Open Transport 2.0 version of source code for TCP/IP & UDP support	Some of this the code was descended from Apple sample source written by: Eric Okholm	However getting it to work was done by	John M Mcintosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In May of 2000 under contract to Disney		Some of the original source code was written by John Maloney of Disney thoughout the 1990''s		The basic intent was to make the code fully interrupt driven	No limits.... Well maybe we throttle read buffers to some parcel of memory to prevent us	from using all the memory on the box. Sends depend on lowerlayer buffering/flow control.	Testing from a 500Mhz PowerBook showed we could saturate a 100MB ethernet when sending data oneway.		UDP and TCP/IP are all supported.	Note for TCP we turn on two options IP_REUSEADDR, and IP_KEEPALIVE.	We do NOT handle T_EXDATA  data		V1.0 May 18th 2000, JMM (TCP/IP and UDP)	V1.1 May 19th 2000, JMM Cleanup	V1.2 may 20th 2000, JMM UDP free buffer cleanup, relook at resolver terminate to fix crash	V1.3 may 23rd 2000, JMM fix T_UDERR crash	V1.3.1 may 24th 2000, JMM UDP work	V1.3.2 may 25th 2000, JMM socket options work	V1.3.3 may 27th 2000, JMM rewrote resolver	V1.3.4 Jun 7th 2000, JMM some integration	V1.3.5 Jun 9th 2000, JMM Dan Ingalls found some interesting bugs with a T_GODATA on T_CONNECT.		Notes beware semaphore''s lurk for socket support. Three semaphores lives in Smalltalk, waiting for	connect/disconnect/listen, sending data, and receiving data. When to tap the semaphore is based on	inferences driven from the smalltalk code. We really need a call to tell us intent.		waitForDisconnectUntil:	    via closeAndDestroy: after primSocketCloseConnection:	    	waitForDataUntil:	    Usually before primitiveSocketReceiveDataBufCount: after checking SocketReceiveDataAvailable	    	waitForSendDoneUntil:	    via sendData: or sendSomeData:startIndex;count: before calls to primitiveSocketSendDataBufCount	    	waitForConnectionUntil:	    via waitForAcceptUntil and many places afer doing primitiveSocketConnectToPort*/								/*** Socket Type Constants ***/#define TCPSocketType 0#define UDPSocketType 1#define TCPListenerSocketType 2   //These are special to enable the right options for listening. Not Exposed to Smalltalk#define UDPListenerSocketType 3   //Very special not really linked to an EP structure.  Not Exposed to Smalltalk/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3#define RESOLVER_NAMETOADDR     4#define RESOLVER_ADDRTONAME     5/*** TCP Socket Status Constants ***/#define InvalidSocket           -1#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4	// Overall program statesenum{	kProgramRunning		= 1,	kProgramDone		= 2};	// Bit numbers in EPInfo stateFlags fieldsenum{	kOpenInProgressBit				= 0,  	kUnConnected    				= 1,	kWaitingForConnection           = 2,	kConnected                      = 3,	kSendIsBlocked                  = 4,    kOtherEndClosed                 = 5,    kThisEndClosed                  = 6,	kPassconBit                     = 7};	// Bit numbers in EPInfo stateFlags2 fieldsenum{	kFlushDisconnectInProgressBit	= 0,	kMakeEPIdle                     = 1,	kEPIsBroken                     = 2,	kReadFlowControl                = 3,	kPassconNeeded                  = 4,	kTapSemaphore                   = 5,	kTapSemaphoreReadData           = 6,	kTapSemaphoreWriteData          = 7};	// Bit numbers in EPInfo stateFlags3 fieldsenum{    kKeepAliveOptionNeeded          = 0,    kSleepKilledMe                  = 1}; enum{	kOTVersion111				= 0x01110000,	kOTVersion112				= 0x01120000,	kOTVersion113				= 0x01130000,	kOTVersion130				= 0x01300000};const kTCPKeepAliveInMinutes		= 10;		// 10 minutes  keep aliveconst kReadBuffersToAllocate	    = 50;		// Memory Allocation issue how big, this means 50x mtu size * 4 But for 68K we do 1/2 size	// Endpoint Info Structurestruct EPInfo{	EndpointRef		erf;				//	actual endpoint	OTLink			link;				//	link into an OT LIFO (atomic)	OTLink          globalLink;         //  link that follows all allocated EPs    SInt32          outstandingSends;   //  number of sends outstanding    OTList          readBuffers;        //  Read buffers    SInt32          bytesPendingToRead; //  bytes outstanding to read	SInt32			semaIndex;			//	semaphore index	SInt32          readSemaIndex;      //  read semaphore	SInt32          writeSemaIndex;     //  write semaphore	SInt32          UDPMaximumSize;     //  max size if a UDP endpoint	SInt32			lastError;          //  last error code	UInt8			stateFlags;			//	various status fields	UInt8			stateFlags2;		//	various status fields	UInt8			stateFlags3;		//	various status fields	UInt8           socketType;         //  type of socket, tcp, udp, or tcp/udp listener	InetAddress     localAddress;       //  local address at bind time (ignored used call to get current)	InetAddress     remoteAddress;      //  remote address at connect (ignored used call to get current)	Boolean         UDPMoreFlag;        //  UDP more of datagram flag set    };typedef struct EPInfo EPInfo;struct ReadBuffer                       // Structure to contain read data.{	OTLink			fNext;				//	link into an OT FIFO 	UInt32          readBufferSize;	UInt32			readBufferOriginalSize;  	char *          readBufferData;	char *          readBufferPtr;      //Sliding pointer used to partial read buffer.    InetAddress     UDPAddress;         //UDP address	Boolean         UDPMoreFlag;        //UDP more of datagram flag set};typedef struct ReadBuffer ReadBuffer;struct TKeepAliveOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpKeepAliveOn;	UInt32		tcpKeepAliveTimer;};typedef struct TKeepAliveOpt TKeepAliveOpt;struct TLingerOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpLingerOn;	UInt32		tcpLingerTimer;};typedef struct TLingerOpt TLingerOpt;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;EPInfo*				gDNSResolver;               //Our resolverSInt32				gDNSResolverStatus 			= RESOLVER_UNINITIALIZED;SInt32				gDNSResolverError			= noErr;SInt32			    gDNSResolverSemaIndex;      //This gets changed at startup time.InetHostInfo		gDNSHostInfo;InetDomainName 		gDNSAddrStr;                //Length of domain names? Old code was 512, but specs say 256.InetHost			gDNSAddr;SInt32              gDNSLookupType;OTConfiguration*	gCfgMastertcp				= NULL;OTConfiguration*	gCfgMasterudp				= NULL;OTConfiguration*	gCfgMasterListener			= NULL;OTLIFO				gFreeReadBuffersLIFO;    	//  Buffers that are free to read intoOTLIFO*				gFreeReadBuffers			= &gFreeReadBuffersLIFO;UInt32				gmtuSize 					= 1024; //This gets changed at startup time.SInt32				gthisNetSession 			= 0;    //This gets changed at startup time.SInt32				gMaxConnections				= 0;    //This gets changed at startup time.UInt32				gOTVersion;                         //Gets set to OT version, to help us with special cases.SInt32				gProgramState				= 0;    //This gets changed at startup time.OTLIFO				gIdleEPLIFO[3];OTLIFO*				gIdleEPs[3];SInt32              gIdleEPCounter[3];OTLIFO				gBrokenEPLIFO;OTLIFO*				gBrokenEPs					= &gBrokenEPLIFO;OTLIFO				gAllEPLIFO;OTLIFO*				gAllEPs					    = &gAllEPLIFO;/*** Private TCP Socket Functions ***//*** Private Resolver Functions ***/static void 		ResolverInitialize();static void		    ResolverTerminate(void);static void 		ResolverStart ();/*** Other Private Functions ***/void               CFMTerminate (void);static Boolean	   DestroyAllOpenSockets(void);static Boolean	   SocketValid(SocketPtr s);static Boolean     PortNumberValid(InetPort port) ;static SInt32      unmapStatus(EPInfo *);static void        Recycle();static void        makeEPIdle(EPInfo *epi);static void        purgeReadBuffers(EPInfo *epi);static void        makeEPBrokenThenIdle(EPInfo* epi,OTResult error);static void        makeEPBroken(EPInfo* epi,OTResult error);static EPInfo*     getOrMakeMeAnEP(UInt8 aSocketType);static Boolean     makeMeAnEP(UInt8 aSocketType);static void        attemptToCloseAndDeleteThisEP (EPInfo *epi);static void		   makeEPUnconnected(EPInfo* epi);static void        SetEPLastError(EPInfo* epi,OTResult error);static void        TapAllInterestedSemaphores(EPInfo *epi);int 				socketInit(void);int 				socketShutdown(void);static pascal void  DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie);static void         internalSocketCreate(SocketPtr s, SInt32 netType, SInt32  socketType, SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint);static Boolean		EPOpen(EPInfo* epi);static Boolean 		EPClose(EPInfo*);static void         DoListenAccept(EPInfo* acceptor,EPInfo* theServer);static void         DoConnect(EPInfo* epi,InetHost addr, InetPort port);static void         DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint, OTQLen queueDepth );static UInt32       ReadData(EPInfo* epi, char* specialBuffer, UInt32 specialBufferSize);static OTResult     SendData(EPInfo* epi, char* buffer, UInt32 size);static OSStatus     doAbortConnection(EPInfo* epi);static void         NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo);static UInt32       readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize);static UInt32       readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int *moreFlag, char *buf,UInt32 adjustedBufSize);static SInt32	    lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result);static OTResult     SetFourByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetOneByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetKeepAliveOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetLingerOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);// Some diagnostic routinesvoid JMMLogMessage(Str255 input);void JMMLogMessageAndNumber(Str255 msg,long number);void JMMWriteLog();/*** Network Functions ***/int socketInit() {	//	//Don''t actually do any network work until we are newworked initialized	//This prevents kicking off internet dialup connections until needed	//	return true;}int socketShutdown() {	CFMTerminate();	return true;}int sqNetworkInit(int resolverSemaIndex) {	//	//  Initialize the network and return 0 if successful	//  Loads Open transport, allocates memory for read buffers and various other tasks	//		SInt32              i;	OSStatus            err = noErr;	InetInterfaceInfo   interfaceInformation;	UInt8               aSocketType;    ReadBuffer          *readBufferObject;    long				check68KorPPC;	    	if (gthisNetSession !!= 0) return 0;  /* noop if network is already initialized */		err = InitOpenTransport(); 	if (err) {		return -1;	}			err = Gestalt(gestaltOpenTptVersions, (long*) &gOTVersion);		if (err || (gOTVersion < kOTVersion112))	{		// Please install Open Transport 1.1.2 or later		// This might change to 1.3 since tech notes talked about 		// previous versions having problems with acksend logic.		//		return -111;	}		err = Gestalt(gestaltSysArchitecture, (long*) &check68KorPPC);	gProgramState = kProgramRunning;    //     //Setup the head of the idle queues    //    	for (i=0;i<3;i++) {	    gIdleEPs[i] = &gIdleEPLIFO[i];	    gIdleEPs[i]->fHead	   = NULL;	    gIdleEPCounter[i]      = 0;	}	gBrokenEPs->fHead 		= NULL;	gFreeReadBuffers->fHead = NULL;	gAllEPs->fHead          = NULL;			gMaxConnections			= 24; // Build 8 of each of listeners, tcp, udp.		gDNSResolver = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (gDNSResolver == NULL) return -1;			gDNSResolverSemaIndex = resolverSemaIndex;	ResolverInitialize();		/* Get MTU and default selected host address */		OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);    gmtuSize = interfaceInformation.fIfMTU;    		//	//	Open endpoints 	//	gCfgMastertcp = OTCreateConfiguration(kTCPName);	if (gCfgMastertcp == NULL) return -3;		gCfgMasterudp = OTCreateConfiguration(kUDPName);	if (gCfgMasterudp == NULL) return -4;		gCfgMasterListener = OTCreateConfiguration("tilisten, tcp"); //Note use of special tilisten logic	if (gCfgMasterListener == NULL) return -5;		//	//Build all our EPs, lots of work happens lower down asyncronously	//	aSocketType = TCPSocketType;	for (i = 0; i < gMaxConnections; i++)	{		makeMeAnEP(aSocketType);		aSocketType = ++aSocketType > 2 ? TCPSocketType : aSocketType;	} 		//	//Build storage objects for read buffers	//How much memory to allocate still is a mystery	//    for (i=0;i<kReadBuffersToAllocate ;i++) {         readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {       	    interpreterProxy->success(false);            return -25;        }                 OTMemzero(readBufferObject,sizeof(ReadBuffer));        if (gestalt68k == check68KorPPC)         	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*2 : 1024;        else        	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*4 : 1024;                readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(readBufferObject->readBufferOriginalSize);        if ( readBufferObject->readBufferData == nil) {       	    interpreterProxy->success(false);            return -25;        }        OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext);    }	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	gthisNetSession = clock() + time(NULL);	if (gthisNetSession == 0) gthisNetSession = 1;  /* don''t use 0 */		return 0;}void CFMTerminate (void)    /* termination either via a CFM or Squeak call*/{     sqNetworkShutdown();}void sqNetworkShutdown(void) {	/* shut down the network */    	if (gthisNetSession == 0) return;  /* noop if network is already shut down */	gthisNetSession = 0;	gProgramState = kProgramDone;	DestroyAllOpenSockets();	CloseOpenTransport(); }/*** Resolver Functions ***/static void	ResolverInitialize() {	OSStatus err;		//	//	Prepare to open internet services	//  to invoke DNR services	//		OTMemzero(gDNSResolver, sizeof(EPInfo));	    gDNSResolver->erf = OTOpenInternetServices(kDefaultInternetServicesPath, 0, &err);    gDNSResolver->semaIndex = gDNSResolverSemaIndex;		if (err !!= kOTNoError) {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;		return;	}	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError = kOTNoError;    err =  OTSetAsynchronous(gDNSResolver->erf);    err =  OTSetNonBlocking(gDNSResolver->erf);    err =  OTInstallNotifier(gDNSResolver->erf, DNSNotifier, gDNSResolver);}static void ResolverStart () {	OSStatus err;	//	// Invoke DNR service Async, this meants the DNSNotifier will handle the actual 	// lookup and work, flags like the gDNSResolverStatus are used to indicate back	// to Squeak when the work is done	//	if (gDNSResolver->erf == NULL) //Sleep fix, other endpoints are more explicit about this issue. 	    ResolverInitialize();	    	gDNSResolverStatus  = RESOLVER_BUSY;	switch (gDNSLookupType) {		case RESOLVER_NAMETOADDR: {		    err = OTInetStringToAddress((InetSvcRef)gDNSResolver->erf, gDNSAddrStr, &gDNSHostInfo);			break;		}		case RESOLVER_ADDRTONAME: {			err = OTInetAddressToName((InetSvcRef)gDNSResolver->erf, gDNSAddr, gDNSAddrStr);			break;		}    }	if (err !!= kOTNoError)  {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;	}}void ResolverTerminate(void) {    //JMM if the resolver is opening what happens? 	gDNSResolverStatus = RESOLVER_UNINITIALIZED;   	if (gDNSResolver->erf == NULL) return;	EPClose(gDNSResolver);	OTMemzero(gDNSResolver, sizeof(EPInfo));}void sqResolverAbort(void) {	//	// Abort this running resolver request	//	if (gDNSResolverStatus == RESOLVER_BUSY) {		ResolverTerminate();		ResolverInitialize();	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	//	// copy the name found by the last address lookup into the given string 	//		OTMemcpy(nameForAddress, gDNSAddrStr, (UInt32) nameSize);	}int sqResolverAddrLookupResultSize(void) {	//	// return the length of the looked up name	//	return (long) strlen(gDNSAddrStr);}int sqResolverError(void) {	//	// Return OT error number	//	return gDNSResolverError; }int sqResolverLocalAddress(void) {    //    // Watch out for dynamic changing of this information, so don''t cache    //	InetInterfaceInfo interfaceInformation;	OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError  = noErr;	return (long) interfaceInformation.fAddress;}int sqResolverNameLookupResult(void) {	//	// Return address from last lookup	//    	return (int) gDNSAddr;}void sqResolverStartAddrLookup(int address) {	//	// start process to lookup name from address	//    	if (gDNSResolverStatus == RESOLVER_BUSY) return;	gDNSAddr            = (InetHost) address;    gDNSLookupType      = RESOLVER_ADDRTONAME;	ResolverStart();}void sqResolverStartNameLookup(char *hostName, int nameSize) {	//	// start process to lookup address from name	//    	UInt32 len; 	if (gDNSResolverStatus == RESOLVER_BUSY) return;	len = (UInt32) ((nameSize <= kMaxHostNameLen) ? nameSize : kMaxHostNameLen);  //Old limit was 500  but that appeared to be wrong	OTMemcpy(gDNSAddrStr, hostName, len);	gDNSAddrStr[len]    = ''\0'';    gDNSLookupType      = RESOLVER_NAMETOADDR;	ResolverStart();	}int sqResolverStatus(void) {	//	// return resolver status, this is different from resolver error code	// status is the same among implementations, error is implementation dependent	//    	return gDNSResolverStatus;}//================================// Socket logic //void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {				//	//Old call from old image using new VM	//Just make new call	//	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  		 s,  netType,  socketType, recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex)	{    netType; recvBufSize; sendBufSize;    //    //Create a socket given the supplied information    //We don''t bind the socket to a local port  until     //we do the connection. This of course could change?     //        internalSocketCreate( s, netType, socketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, (UInt8) socketType);}static void internalSocketCreate(  SocketPtr s, SInt32 netType, SInt32 socketType,  SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint)	{  //  // Internal logic to open a socket for a connection or to listen  // Note how we ignore buffer sizes!!  //    EPInfo*     epi;    socketType; netType; recvBufSize; sendBufSize;        //    //Make the socket invalid and then get an idle EP    //Technically we only run out of EP when we run out of memory    //    	s->sessionID = 0;	if (gProgramState !!= kProgramRunning ) {			    interpreterProxy->success(false);        return;    }	epi = getOrMakeMeAnEP(aExtraSocketHint);	if (epi == NULL) {		interpreterProxy->success(false);		return;	}	epi->outstandingSends   = 0;	epi->bytesPendingToRead = 0;	epi->semaIndex          = semaIndex;	epi->readSemaIndex      = readSemaIndex;	epi->writeSemaIndex     = writeSemaIndex;	epi->stateFlags         = 0;	epi->stateFlags2        = 0;	epi->stateFlags3        = 0;	SetEPLastError(epi,noErr);	epi->socketType        = aExtraSocketHint;	OTInitInetAddress(&epi->remoteAddress, 0, 0);    OTInitInetAddress(&epi->localAddress, 0, 0);        if (aExtraSocketHint == UDPSocketType)        OTAtomicSetBit(&epi->stateFlags, kConnected); //udp is always connected     else        OTAtomicSetBit(&epi->stateFlags, kUnConnected);  	s->sessionID            = gthisNetSession;	s->socketType           = (aExtraSocketHint == UDPSocketType) ? UDPSocketType : TCPSocketType;	s->privateSocketPtr     = epi;}void sqSocketListenOnPort(SocketPtr s, int port) {    //    //Listen on port for a connection, this is not the approved method    //sqSocketListenOnPortBacklogSize is the best way if you are a server    //However this works ok for UDP and kinda for onetime connections in TCP    //    EPInfo* epi;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,1);		if (epi->localAddress.fPort !!= port) {//We die if we don''t get the port we want            sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp		DoBind(epi,0,(InetPort) port,UDPListenerSocketType,1);	}}void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {    EPInfo* epi;	SInt32 sema,readSema,writeSema;    //    //Listen on port for a connection, this is the best method if you are    //a server. Works in conjunction with accept. Shouldn''t drop connections    //OT''s special listener logic queues up the listen requestions    //	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	if (s->socketType == TCPSocketType) {		epi = (EPInfo *) s->privateSocketPtr;		sema = epi->semaIndex; readSema = epi->readSemaIndex; writeSema = epi->writeSemaIndex;	    makeEPIdle(epi); //Special case really need a listener EP, so put this EP back on the queue	    				 //This may seem odd but the epi is allocated before we know what type it is.	    				 //Would need to change Squeak to indicate type at creation!!		internalSocketCreate( s, 0, TCPSocketType, 0,  0, sema, readSema, writeSema, TCPListenerSocketType);		epi = (EPInfo *) s->privateSocketPtr;		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,(OTQLen) backlogSize);		if (epi->localAddress.fPort !!= port) {//The port we wanted must match, otherwise we die		    sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp not allowed       	    interpreterProxy->success(false);	}}void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex){	//	//Old call from old image using new VM	//Just make new call	//	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			 s,  serverSocket,  recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);		}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {	//	//Accept incoming request from a listener	//We take information from the listener, create a new socket	//and accept the incoming call	//	    EPInfo* epiSocket;    EPInfo* epiServerSocket;    Boolean	doLeave;	if (!!SocketValid(serverSocket)) return;	if (serverSocket->socketType == TCPSocketType) {            internalSocketCreate( s, 0, TCPSocketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, TCPSocketType);		    epiSocket = (EPInfo *) s->privateSocketPtr;    		DoBind(epiSocket,0,0,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE		    OTAtomicSetBit(&epiSocket->stateFlags2, kPassconNeeded);		    epiServerSocket = (EPInfo *) serverSocket->privateSocketPtr;			OTAtomicSetBit(&epiServerSocket->stateFlags, kWaitingForConnection);			OTAtomicSetBit(&epiServerSocket->stateFlags, kUnConnected);            OTAtomicClearBit(&epiServerSocket->stateFlags, kConnected);    	    OTAtomicSetBit(&epiServerSocket->stateFlags2, kTapSemaphore);        	        	doLeave = OTEnterNotifier(epiServerSocket->erf);        	DoListenAccept(epiSocket,epiServerSocket);        	if (doLeave)        		OTLeaveNotifier(epiServerSocket->erf);	} else { //udp		interpreterProxy->success(false); 	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {    //    //Connect this socket to the given host addr and port    //    EPInfo* epi;	OTResult	epState;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {    	DoBind(epi,(InetHost) addr,(InetPort) port,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect	} else {//udp		epState = OTGetEndpointState(epi->erf);		if (epState == T_UNBND) {//Bind to remote, our side gets wildcarded    	    DoBind(epi,(InetHost) addr,(InetPort) port,UDPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect    	} else {//Already bound to a port/interface on our side    	    OTInitInetAddress(&epi->remoteAddress, (InetPort) port, (InetHost) addr);    	}	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	//	// Send data really fast	// We create a copy of the data and give it to OT to play with	// We can get flow controlled lower down, if no flow control then we	// tap the semiphore since from squeaks viewpoint data is sent, otherwise when flow control is lifted the	// semaphore is tapped in the notification routine	//	OTResult res ;    EPInfo* epi;    Boolean doLeave;    char * buffer; 	UInt32 adjustedBufSize = bufSize > 65536 ? 65536 : (UInt32) bufSize; //? Not sure if we really need to do this limiting.   		if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;		// If send is blocked wait for unblocking	if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    return 0;	}    if (epi->socketType == UDPSocketType) {        //UDP adjust the buffer size again        adjustedBufSize = (adjustedBufSize > epi->UDPMaximumSize) ?   epi->UDPMaximumSize : adjustedBufSize;     }	buffer = OTAllocMem(adjustedBufSize);	if (buffer == nil) {		//Well maybe we back off and wait awhile? 		//If we run out of memory and stress the box, well death lurks.		adjustedBufSize = 256;		buffer = OTAllocMem(adjustedBufSize);		if (buffer == nil) {		    interpreterProxy->success(false); //Death did lurk	        SetEPLastError(epi, -1);	        return -1;	    } 	}			OTMemcpy(buffer,(void*) buf,adjustedBufSize);    	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_GODATA    res = SendData(epi,buffer,adjustedBufSize);  	  	if (doLeave)		OTLeaveNotifier(epi->erf);		  	if (res < 0 ){	    SetEPLastError(epi, res);		interpreterProxy->success(false); //JMM just for testing	    return 0;	}	return res;}////New primitive for sending UDP data to a particular host/port//Avoids race conditions between binding and send in Smalltalk//int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) { sqSocketConnectToPort(s, address, port); return sqSocketSendDataBufCount(s, buf, bufSize);}////Abort the socket//void sqSocketAbortConnection(SocketPtr s) {    EPInfo* epi;   OSStatus err; 	if (!!SocketValid(s)) return;    if (s->socketType == UDPSocketType) {		interpreterProxy->success(false);         return;    }	epi = (EPInfo *) s->privateSocketPtr;	err = doAbortConnection(epi);}////Acutal abort logic//We need to flush the queues//Then do a disconnect//static OSStatus doAbortConnection(EPInfo* epi) {   SInt32		count = 0;   OSStatus     err = kOTNoError; 	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 ) {		//Do flush and wait for it to happen		//Should make sync?		//		if (epi->outstandingSends !!= 0) {		    err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		    while (count++ < 100 && (epi->outstandingSends !!= 0 || OTAtomicTestBit(&epi->stateFlags, kUnConnected) == false)) {			    OTIdle();            }	    }        makeEPBroken(epi,0);	    err = OTSndDisconnect(epi->erf, NULL);	}	    	if (err !!= kOTNoError) 	    return err;	else        return epi->lastError;}////Socket close logic//void sqSocketCloseConnection(SocketPtr s) {    EPInfo* epi;    OSStatus err; 	OTResult	epState;	OTResult	lookResult;    	if (!!SocketValid(s)) return;	epi = (EPInfo *) s->privateSocketPtr;    if (s->socketType == UDPSocketType) {//Handle udp and return        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);		err = OTUnbind(epi->erf);		if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBroken(epi,err);		}	    TapAllInterestedSemaphores(epi);	    return;    }    OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);	// old code is sync and doesn''t trigger semaphore 		epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) 	    makeEPIdle(epi); //Unbound already so make him idle.	else	    err = OTSndOrderlyDisconnect(epi->erf);	    	if (err == kOTNoError) {        if (OTAtomicTestBit(&epi->stateFlags, kOtherEndClosed)) {	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }	} else {// Could get kOTLookErr with T_DISCONNECT pending 		lookResult = OTLook(epi->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT) {        	err = OTRcvDisconnect(epi->erf, NULL);	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }        else {            SetEPLastError(epi,err);    		makeEPBroken(epi,err);            TapAllInterestedSemaphores(epi);       }	}}////Destroy the socket here we must ensure we cleanup and put the //socket back on the idle or broken EP queue//void sqSocketDestroy(SocketPtr s) {    OTResult err;    EPInfo* epi;	OTResult	epState;    JMMWriteLog(); //Diagnostics, turned off, must fiddle recompile to turn on.        if (!!SocketValid(s)) return; 	epi = (EPInfo *) s->privateSocketPtr;    OTAtomicSetBit(&epi->stateFlags2, kMakeEPIdle); 	epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {	    makeEPIdle(epi); //Unbound already so make him idle.	} else {	    if (s->socketType == UDPSocketType)			err = OTUnbind(epi->erf);	    else 		    err = doAbortConnection(epi);			if (err !!= kOTNoError) {//kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBrokenThenIdle(epi,err);		}	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}////Check to see if bytes are available//int sqSocketReceiveDataAvailable(SocketPtr s)							{    EPInfo* epi;    static lastTickCount=0;	if (!!SocketValid(s)) return 0;    epi = (EPInfo *) s->privateSocketPtr;    if (epi->bytesPendingToRead > 0)         return 1;       if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) // New case if data pending but flow controlled then go get it        return 1;        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreReadData); //Note how we imply there will be interest in semaphore    return 0;}////Read data into the buffer supplied//int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {    EPInfo* epi; 	UInt32  bytesRead = 0;    Boolean doLeave;    	if (!!SocketValid(s)) return -1; 		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead = readBytes(epi,(char *) buf,(UInt32) bufSize);    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {        if (bytesRead > 0)             ReadData(epi,NULL,0);         else            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize); //special case attempt read into squeak buffer    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}////New primitive to read UDP data and get data, host/port, and more flag//int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {    EPInfo* epi; 	UInt32 bytesRead = 0;    Boolean doLeave;    InetAddress fromAddress;        OTMemzero(&fromAddress,sizeof(InetAddress));    *address  = 0;    *port = 0;    *moreFlag = 0;    	if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead   = readBytesUDP(epi,&fromAddress, moreFlag, (char *) buf,(UInt32) bufSize);    *address    = fromAddress.fHost;    *port       = fromAddress.fPort;    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {         if (bytesRead > 0)             ReadData(epi,NULL,0);         else {            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize);//special case attempt read into squeak buffer            *address    = epi->remoteAddress.fHost; //Also we happen to know the address just when into this area            *port       = epi->remoteAddress.fPort; //JMM more flag?            *moreFlag   = epi->UDPMoreFlag;        }    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}int sqSocketLocalAddress(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    return (int) (epi->localAddress.fHost == 0) ? sqResolverLocalAddress() : epi->localAddress.fHost;}int sqSocketLocalPort(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;		return epi->localAddress.fPort;}int sqSocketRemoteAddress(SocketPtr s) {    EPInfo*     epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return (int) epi->remoteAddress.fHost;    }        //It seems the only reliable way to get the address    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return (int) remoteAddr.fHost;}int sqSocketRemotePort(SocketPtr s) {    EPInfo* epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return epi->remoteAddress.fPort;    }        //It seems the only reliable way to get the port    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return remoteAddr.fPort;}int sqSocketSendDone(SocketPtr s) {    EPInfo* epi;	if (!!SocketValid(s)) return 1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreWriteData); //Note the implied intent to use the semaphore        return 0;    }    else {        return 1;    }}int sqSocketError(SocketPtr s) {    EPInfo* epi;     	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kUnConnected)  &&         !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)         && epi->lastError == 0)	    return kENOTCONNErr; // old code would return unconnectederror if unconnected	else	    return (epi->lastError);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return InvalidSocket;	return unmapStatus((EPInfo *) s->privateSocketPtr);}static SInt32 unmapStatus(EPInfo *s) {    if (OTAtomicTestBit(&s->stateFlags3, kSleepKilledMe))         {return  InvalidSocket;        }    if (OTAtomicTestBit(&s->stateFlags, kThisEndClosed))         {return  ThisEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kOtherEndClosed))         {return  OtherEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kConnected))         { return  Connected;        }    if (OTAtomicTestBit(&s->stateFlags, kWaitingForConnection))         {return  WaitingForConnection;        }    if (OTAtomicTestBit(&s->stateFlags, kUnConnected))         {return  Unconnected;        }   return 0;}static Boolean SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == gthisNetSession) && 		(s->socketType == TCPSocketType || s->socketType == UDPSocketType) &&		(!!OTAtomicTestBit(&(((EPInfo *)s->privateSocketPtr)->stateFlags3), kSleepKilledMe)) )		    return true;	interpreterProxy->success(false);	return false;}static Boolean PortNumberValid(InetPort port) {	if (port <= 65535) {		return true;	}	interpreterProxy->success(false);	return false;}//Used to signal all semaphores when we''ve closed the socket//I guess the read/write/disconnect threads really want to know//static void TapAllInterestedSemaphores(EPInfo *epi) {    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex); 				}static Boolean DestroyAllOpenSockets(void) {	EPInfo      *epi;	OTLink*		link;    ReadBuffer *aBuffer;	//	//	Start closing connector endpoints.	//	While we could be rude and just close the endpoints, 	//	we try to be polite and wait for all outstanding connections	//	to finish before closing the endpoints.   The is a bit easier	//	on the server which won''t end up keeping around control blocks	//	for dead connections which it doesn''t know are dead.  Alternately,	//	we could just send a disconnect, but this seems cleaner.	//	(void)OTLIFOStealList(gBrokenEPs);	(void)OTLIFOStealList(gIdleEPs[0]);	(void)OTLIFOStealList(gIdleEPs[1]);	(void)OTLIFOStealList(gIdleEPs[2]);	    link = OTLIFODequeue(gAllEPs);    while (link !!= NULL) {        epi = OTGetLinkObject(link, EPInfo, globalLink);     	attemptToCloseAndDeleteThisEP(epi);        link = OTLIFODequeue(gAllEPs);    }	//	//	If the lists are empty now, then all endpoints have been successfully closed,	//	so the client is stopped now.  (Actually we hope that is the case)	//	    //    //Free up all the other resources    //    link = OTLIFODequeue(gFreeReadBuffers);    while (link !!= NULL) {    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer);         link = OTLIFODequeue(gFreeReadBuffers);    }    ResolverTerminate();	OTFreeMem((char*)gDNSResolver);	gIdleEPs[0]->fHead		= NULL;	gIdleEPs[1]->fHead		= NULL;	gIdleEPs[2]->fHead		= NULL;	gBrokenEPs->fHead 		= NULL;	OTDestroyConfiguration(gCfgMastertcp);	OTDestroyConfiguration(gCfgMasterudp);	OTDestroyConfiguration(gCfgMasterListener);	return true;}////	DoBind////	This routine either binds to a wild card address and specfic port if //  we are doing a listen, otherwise we bind to a wild card address and //  wild card port if we are starting a connection to a remote host.//  J M M NOTE A more complex version could use port and addr//  Note we don''t bind to the local socket until here, we could when //  The socket is created, but that leads to odd issues.//static void DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint,OTQLen queueDepth ){	OSStatus 	err;	TBind 		bindReq, bindResult;	InetAddress	inAddr,bindAddr;		switch (aExtraSocketHint) {        case TCPSocketType: {            // for a connection        	//	Bind the endpoint to a wildcard address         	//	(assign us a port, we don''t care which one).        	//  NOTE A more complex version could use port and addr            OTInitInetAddress(&epi->remoteAddress, port, addr);            OTInitInetAddress(&epi->localAddress, 0, kOTAnyInetAddress);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case UDPSocketType: {             // for a connection        	//	Bind the endpoint to earlier supplied information            OTInitInetAddress(&epi->remoteAddress, port, addr);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case TCPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }        case UDPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }	} 	bindReq.addr.len    	= sizeof(InetAddress);	bindReq.addr.buf    	= (unsigned char*) &inAddr;	bindReq.qlen        	= queueDepth; //Note queue depth for listening 	bindResult.addr.maxlen	= sizeof(InetAddress); 	bindResult.addr.len   	= sizeof(InetAddress);	bindResult.addr.buf    	= (unsigned char*) &bindAddr;	epi->stateFlags     	= 0;	epi->stateFlags2   		= 0;	epi->stateFlags3    	= 0;	epi->bytesPendingToRead = 0;	SetEPLastError(epi,noErr);	if (aExtraSocketHint == TCPSocketType|| aExtraSocketHint == TCPListenerSocketType) {        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags, kWaitingForConnection);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);    }		err = OTBind(epi->erf, &bindReq, &bindResult); // resume at T_BINDCOMPLETE		// for bindReq on listen what is queueDepth now? 	// bindReq.qlen could have changed	// But... No why to feed this back to the client!!		if (err !!= kOTNoError) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);    	return;	}		OTMemcpy(&epi->localAddress,bindResult.addr.buf,sizeof(InetAddress)); //Pickup local address	return;}////	DoConnect////	This routine attempts establish a new connection to the given//	address and port.  //  Called via the notifier at interrupt time.//static void DoConnect(EPInfo* epi,InetHost addr, InetPort port){	OSStatus err;	TCall sndCall;	InetAddress inAddr;		//	Don''t want new connections if already shutting down.	if (gProgramState !!= kProgramRunning ) return;			OTInitInetAddress(&inAddr, port, addr);	OTMemzero(&sndCall, sizeof(TCall));	sndCall.addr.len 	= sizeof(InetAddress);					sndCall.addr.buf	= (unsigned char*) &inAddr;		err = OTConnect(epi->erf, &sndCall, NULL); //resume at T_CONNECT	if (err !!= kOTNoDataErr) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);		return;	}}////	DoListenAccept////	The handling of a T_LISTEN is greatly simplified by use//	of the tilisten module, which serializes inbound connections.//	This means that when doing an OTAccept we won''t get a kOTLookErr//	because another inbound connection arrived and created a T_LISTEN.//	Without the tilisten module, we have to use the "8 step //	listen/accept/disconnect method", which is documented elsewhere.//static void DoListenAccept(EPInfo* acceptor,EPInfo* theServer){	TCall		call;	InetAddress	caddr;	OTResult	lookResult;	OSStatus	err;				OTMemzero(&call, sizeof(TCall));	call.addr.maxlen = sizeof(InetAddress);	call.addr.buf = (unsigned char*) &caddr;			err = OTListen(theServer->erf, &call);	if (err !!= kOTNoError) {		//		//	Only two errors are expected at this point.		//	One would be a kOTNoDataErr, indicating the inbound connection		//	was unavailable, temporarily hidden by a higher priority streams		//	message, etc.   The more likely error is a kOTLookErr, 		//	which indicates a T_DISCONNECT on the OTLook()		//	happens when the call we were going to process disconnected.		//	In that case, go away and wait for the next T_LISTEN event.		//		if (err == kOTNoDataErr) return;					lookResult = OTLook(theServer->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT)        	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);		return;		}		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);	//	//	Note an kOTIndOutErr can occur if we are listening on the EP and handling 	//  off to the same EP. Sorry use the listento:backlogqueue: logic instead    //	if (err !!= kOTNoError) {		//		//	Again, we have to be able to handle the connection being disconnected		//	while we were trying to accept it.		//		lookResult = OTLook(theServer->erf);		if (err == kOTLookErr && lookResult == T_DISCONNECT)         	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);	}}////	EPOpen:////	A front end to OTAsyncOpenEndpoint.//	A status bit is set so we know there is an open in progress.//	It is cleared when the notifier gets a T_OPENCOMPLETE where the context//	pointer is this EPInfo.  Until that happens, this EPInfo can''t be cleaned//	up and released.//static Boolean EPOpen(EPInfo* epi){	OSStatus err;		OTAtomicSetBit(&epi->stateFlags, kOpenInProgressBit);	SetEPLastError(epi,kOTNoError);    epi->UDPMaximumSize = 0; //Remember to figure out the max UDP size.    	switch (epi->socketType) {	    case TCPSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMastertcp), 0, NULL, &NotifierSocket, epi); 	        break;	    }	    case UDPSocketType: {	        TEndpointInfo endPointInformation;		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterudp), 0, &endPointInformation, &NotifierSocketUDP, epi); 		    epi->UDPMaximumSize = (endPointInformation.tsdu == T_INFINITE) ? 64*1024 : endPointInformation.tsdu;	        break;	    }	    case TCPListenerSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterListener), 0, NULL, &NotifierSocketListener, epi); 	        break;	    }	}	if (err !!= kOTNoError) {		SetEPLastError(epi,err);		OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);		return false;	}	return (epi->lastError == kOTNoError);}////	EPClose////	This routine is a front end to OTCloseProvider.   //	Centralizing closing of endpoints makes debugging and instrumentation easier.  //static Boolean EPClose(EPInfo* epi){	OSStatus err;		//	//	If an endpoint is still being opened, we can''t close it yet.	//	There is no way to cancel an OTAsyncOpenEndpoint, so we just	//	have to wait for the T_OPENCOMPLETE event at the notifier.	//	if ( OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) )		return false;		    	//	//	If the OTAsyncOpenEndpoint failed, the endpoint ref will be NULL,	//	and we don''t need to close it now. Also can be NULL or should be NULL if sleeping happened.	//	if (epi->erf == NULL || OTAtomicClearBit(&epi->stateFlags3, kSleepKilledMe)) {	    epi->erf = NULL;		return true;	}			if (epi->outstandingSends == 0) {    	err = OTCloseProvider(epi->erf);    	epi->erf = NULL;    	return true;    }    	    //	//	If we get to this point, the endpoint did an OTSnd() with AckSends,	//	and the T_MEMORYRELEASED event hasn''t been returned yet.  In order	//	to make sure we get the event, we flush the stream and then do an	//	OTDisconnect().   This should get the memory freed so we can close	//	the endpoint safely.   Note, we set a flag so we don''t do this 	//	more than once on an endpoint.	//  J M M I''m not sure we''ll ever get here since a flush should have been done higher up	//	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )	{		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		if (err !!= kOTNoError)			{} 	}	return false;}////	Recycle:////	This routine shouldn''t be necessary, but it is helpful to work around both//	problems in OpenTransport and bugs in this program.   Basicly, whenever an//	unexpected error occurs which shouldn''t be fatal to the program, the EPInfo//	is queued on the BrokenEP queue.  When recycle is called,//  it will attempt to close the associated endpoint and open//	a new one to replace it using the same EPInfo structure.   This process of//	closing an errant endpoint and opening a replacement is probably the most//	reliable way to make sure that this program and OpenTransport can recover//	from unexpected happenings in a clean manner.////  Mind you it can be invoked to cleanup UDP sockets that aren''t closed //  properly due to pending traffice on a busy port.//  Solution mentioned in books is to close the EP.//static void Recycle(){	OTLink* 	list = OTLIFOStealList(gBrokenEPs);	OTLink*		link;	EPInfo*		epi;	while ( (link = list) !!= NULL ) {		list = link->fNext;		epi = OTGetLinkObject(link, EPInfo, link);		if (!!EPClose(epi)) {			OTLIFOEnqueue(gBrokenEPs, &epi->link);			continue;		}		if (gProgramState == kProgramRunning)		    EPOpen(epi);		 else		    makeEPIdle(epi);	}}//// Make the EP idle, it either goes on an idle queue or gets broken.//static void    makeEPIdle(EPInfo *epi) {    purgeReadBuffers(epi);        if (OTAtomicClearBit(&epi->stateFlags2, kEPIsBroken)) {        OTLIFOEnqueue(gBrokenEPs, &epi->link);     } else {	    OTLIFOEnqueue(gIdleEPs[epi->socketType], &epi->link);    	    OTAtomicAdd32(1, &gIdleEPCounter[epi->socketType]);    }}static void attemptToCloseAndDeleteThisEP (EPInfo *epi) {    purgeReadBuffers(epi); 	if (!!EPClose(epi)) {		//	Can''t close this endpoint yet, so skip it.	} else 	    OTFreeMem((char*)epi);}static EPInfo* getOrMakeMeAnEP(UInt8 aSocketType) {	EPInfo      *epi;    OTLink		*link;    SInt32      i;        Recycle();  //Ensure broken EP get fixed up    if (gIdleEPCounter[aSocketType] < 5)   //Magic Number ensure we have at least 5 EP available.        makeMeAnEP(aSocketType);            link = OTLIFODequeue(gIdleEPs[aSocketType]);	if (link == NULL) {		for(i=0;i<10;i++) {OTIdle();};		return getOrMakeMeAnEP(aSocketType); //JMM recursive bug lurks	}	   	OTAtomicAdd32(-1, &gIdleEPCounter[aSocketType]);	epi = OTGetLinkObject(link, EPInfo, link);		if (OTAtomicTestBit(&epi->stateFlags3, kSleepKilledMe)) {	//	//A broken epi on the idle stack, now the only way we can 	//get here (I think) is to have gone to sleep which breaks	//all the end points. To clean up we must now fix them	//So make it idle, of course it''s broken	//Then recursive call to get another one	//This continues until we get a good one	//  	    makeEPIdle(epi);	    return getOrMakeMeAnEP(aSocketType);	}    return epi;}////This is where EP are actually made and opened//EP opening is async//static Boolean makeMeAnEP (UInt8 aSocketType) {	EPInfo      *epi;		epi = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (epi == NULL) return false;   //Death lurks	OTMemzero(epi, sizeof(EPInfo));  //zero it out which makes all the pointers null    epi->socketType = aSocketType;    OTLIFOEnqueue(gAllEPs, &epi->globalLink);	return EPOpen(epi);}static void makeEPUnconnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicSetBit(&epi->stateFlags, kUnConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection on error        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPConnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicClearBit(&epi->stateFlags, kUnConnected);    OTAtomicSetBit(&epi->stateFlags, kConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPBrokenThenIdle(EPInfo* epi,OTResult error) {    makeEPBroken(epi,error);    makeEPIdle(epi);}static void makeEPBroken(EPInfo* epi,OTResult error) {    SetEPLastError(epi,error);    OTAtomicSetBit(&epi->stateFlags2, kEPIsBroken);}static void SetEPLastError(EPInfo* epi,OTResult error) {    if (error < 0) {		JMMLogMessageAndNumber("\p NonZero Error For ",epi->semaIndex);		JMMLogMessageAndNumber("\p NonZero Error Is  ",error);    }    epi->lastError = error;}//	ReadData:////	This routine attempts to read all available data from an endpoint.//	it is not necessary for the program to handle//	getting back a T_DATA notification DURING an OTRcv() call, as would be//	the case if we read from outside the notifier.   We must read until we//	get a kOTNoDataErr in order to clear the T_DATA event so we will get//	another notification of T_DATA in the future.//  Note we use EnterNotifier to make this possible////	Note for the curious we attempted to use no-copy receives to get data.  This obligates//	the program to return the buffers to OT asap.  BUT we found we overran memory!!//  So we reverted to more expensive copies into buffers we have preallocated////  Perhaps a seperate routine for UDP would make sense?//  Note May 30/00 we added a special read when we exhaust the internal buffer pool//  But data is still pending we allow you to read into the squeak buffer directly//static UInt32 ReadData(EPInfo* epi,char *specialReadBuffer,UInt32 specialReadSize) {	OTResult  	res;	OTFlags	  	flags;	OTResult	epState;	OTLink		*link;    ReadBuffer 	*readBufferObject,simulatedReadBuffer;    InetAddress UDPdataFromAddress;    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) //tap to clear waitfordata Data Data Data        interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);            if (specialReadSize > 0) { //Special case drop into squeak buffer, make a simulated buffer object        OTMemzero(&simulatedReadBuffer,sizeof(ReadBuffer));        simulatedReadBuffer.readBufferData = specialReadBuffer;        simulatedReadBuffer.readBufferSize = simulatedReadBuffer.readBufferOriginalSize = specialReadSize;        readBufferObject = &simulatedReadBuffer;    } else {       link = OTLIFODequeue(gFreeReadBuffers);                	if (link == NULL) {           	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);  //NO free buffers we are flow controled        	return;     	}    	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);        OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl);      }        OTMemzero(&UDPdataFromAddress,sizeof(InetAddress));    	while (true) {        		readBufferObject->readBufferPtr = readBufferObject->readBufferData;		   	    if (epi->socketType == UDPSocketType) {   	        TUnitData 	UDPDataInBound;   	        OTFlags     flagMeaningMore;            OSStatus    error;                	    UDPDataInBound.addr.maxlen = sizeof(InetAddress);    	    UDPDataInBound.addr.len    = sizeof(InetAddress);    	    UDPDataInBound.addr.buf    = (UInt8*) &readBufferObject->UDPAddress;    	    UDPDataInBound.opt.maxlen  = 0;    	    UDPDataInBound.opt.len     = 0;    	    UDPDataInBound.opt.buf     = NULL;    	    UDPDataInBound.udata.maxlen = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.len    = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.buf    = (UInt8*)readBufferObject->readBufferData;	    	        error =  OTRcvUData(epi->erf, &UDPDataInBound, &flagMeaningMore);	        	        if (error !!= kOTNoError) {	            res = error;	        } else {	            if (UDPDataInBound.addr.len == 0) //Remember UDP address	                readBufferObject->UDPAddress = UDPdataFromAddress;	            else	                UDPdataFromAddress = readBufferObject->UDPAddress;	                	            epi->UDPMoreFlag = readBufferObject->UDPMoreFlag = (flagMeaningMore > 0) ? true: false;	            res = (SInt32) UDPDataInBound.udata.len; 	            OTMemcpy(&epi->remoteAddress,&readBufferObject->UDPAddress,sizeof(InetAddress));  	        }   	    } else {//A less complicated tcp read   	        res = OTRcv(epi->erf, readBufferObject->readBufferData, readBufferObject->readBufferOriginalSize, &flags);   	    }   	    		//		//	Note, check for 0 because can get a real 0 length receive		//	in some protocols (not in TCP), which is different from		//	getting back a kOTNoDataErr.		//		if (res >= 0) {            if (specialReadSize > 0)                 return (UInt32) res; //Note special case                            readBufferObject->readBufferSize = (UInt32) res;                        OTAddLast(&epi->readBuffers,&readBufferObject->fNext); //Put the buffer on the read queue        	OTAtomicAdd32(res, &epi->bytesPendingToRead);            link = OTLIFODequeue(gFreeReadBuffers);                            	if (link == NULL) {               	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl); //Our read flow control, OT will block lower down            	return;         	}        	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);   			continue; //Loop around and get more bytes if available		}		else {            if (specialReadSize == 0)                 OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext); //Read above didn''t work so put it back on free queue		}				if (res == kOTNoDataErr) {			//			//	Since ReadData is only called from inside the notifier			//	we don''t have to worry about having missed a T_DATA 			//	during the OTRcv.			//  Note use of EnterNotifier logic			//			if (specialReadSize > 0)			    OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl); 			return 0;		}		if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_DISCONNECT) {				//	If we got the T_ORDREL, we won''t get any more inbound data.				//	We return and wait for the notifier to get the T_ORDREL notification.				//	Upon getting it, we will notice we still need to send data and do so.				//	The T_ORDREL has to be cleared before we can send. 				//				return 0 ;			}			if (res == T_GODATA) {			    if (specialReadSize == 0) {    			    link = OTLIFODequeue(gFreeReadBuffers);                    	if (link == NULL) {                       	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);                    	return 0 ;                 	}                	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);            	} else {            	    return 0;            	}			    continue; //OT Flow control lifted keep reading. JMM			}		} else {			epState = OTGetEndpointState(epi->erf);			if (res == kOTOutStateErr && epState == T_INREL) {				//				//	Occasionally this problem will happen due to what appears				//	to be an OpenTransport notifier reentrancy problem.   				//	What has occured is that a T_ORDREL event happened and 				//	was processed during ReadData().   This is proven by being				//	in the T_INREL state without having done a call to				//	OTRcvOrderlyDisconnect() here.   It appears to be a benign 				//	situation, so the way to handle it is to understand that no				//	more data is going to arrive and go ahead and being our response				//	to the client.				//				break;			}		break; //Ok error so break out of loop		}	}    return 0;	}//// NOT USED HISTORICAL REASONS// /*static void NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo){   OSStatus     err;   OTBuffer     *thisBuffer;   UInt32       count;   ReadBuffer   *readBufferObject;           thisBuffer = bufferInfo->fBuffer;    err = noErr;    while (err == noErr && thisBuffer !!= nil) {        count = thisBuffer->fLen;    	OTAtomicAdd32(count, &epi->bytesPendingToRead);		readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {			SysBeep(5);            err = -1;            break;        }         OTMemzero(readBufferObject,sizeof(ReadBuffer));        readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(count);        if ( readBufferObject->readBufferData == nil) {			SysBeep(5);             err = -1;            break;        }         readBufferObject->readBufferOriginalSize = readBufferObject->readBufferSize = count;        OTMemcpy(readBufferObject->readBufferData,thisBuffer->fData,count);        OTAddLast(&epi->readBuffers,&readBufferObject->fNext);        thisBuffer = thisBuffer->fNext;    }   // Clean up.  We MUST release the OTBuffer chain to Open Transport    // so that it crelease the OTBuffer chain to Open Transport    // so that it can reuse it., OTReleaseBuffer does not tolerate   // the parameter being nil, so we check for that case first.    if (bufferInfo->fBuffer !!= nil) {      OTReleaseBuffer(bufferInfo->fBuffer);   }}*///// Read Bytes from the buffers// Called by Squeak to get the data//static UInt32  readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // use recursion to fill buf to adjustedBufSize or     // til we have no buffers left    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32 		increment,bytesRead = 0;    ReadBuffer *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        increment = readBytes(epi,buf+bytesRead,adjustedBufSize-bytesRead);        bytesRead += increment;        return bytesRead;   }}static UInt32  readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int * moreFlag, char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // For UDP we just drop in the read buffer and address    // Don''t fill the entire buffer no recursion.    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32      bytesRead = 0;    ReadBuffer  *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        return bytesRead;   }}//Cleanup logic//static void purgeReadBuffers(EPInfo *epi) {    ReadBuffer *aBuffer;            //    //Put buffers for this epi back on the free queue    //    aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);        while (aBuffer !!= NULL) {        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    }    epi->bytesPendingToRead = 0;}////	Send the Bytes (Really fast, we hope)//static SInt32 SendData(EPInfo* epi,char* buffer, UInt32 size){	OTResult res;	struct OTData *dataPtr;  	//	//	Make sure we record that we are starting a send so we don''t try to close	//	the endpoint before a T_MEMORYRELEASED event is returned.	//	OTAtomicAdd32(1, &epi->outstandingSends);		if (epi->socketType == UDPSocketType) {		TUnitData UDPDataOutBound;	    UDPDataOutBound.addr.maxlen  = sizeof(InetAddress);	    UDPDataOutBound.addr.len     = sizeof(InetAddress);	    UDPDataOutBound.addr.buf     = (UInt8*) &epi->remoteAddress;	    UDPDataOutBound.opt.maxlen   = 0;	    UDPDataOutBound.opt.len      = 0;	    UDPDataOutBound.opt.buf      = NULL;	    UDPDataOutBound.udata.maxlen = size;	    UDPDataOutBound.udata.len    = size;	    UDPDataOutBound.udata.buf    = (UInt8*)buffer;	            res =  OTSndUData(epi->erf,&UDPDataOutBound);         if (res == kOTNoError ) return (SInt32) size;                // Other Errors could be kOTFlowErr or kOTBadDataErr	}	else { //TCP Send    	//    	//	In OT 1.1.2 and previous versions, there is a bug with AckSends    	//	which occurs when the same buffer is sent more than once.   In an attempt    	//	to go fast and not allocate memory, TCP may write an IP and TCP header    	//	into the data buffer which is sent.   If the buffer is sent more than once    	//	without being refreshed, the data may be corrupted.   To work around this,    	//	send the data via an OTData structure, using the gather-write mechanism.    	//	The problem does not occur in this code path, and this will not hinder performance.    	//	The problem will be fixed in the next Open Transport release following 1.1.2.    	//    	//  Note the MAC OS 8.1 docs alude to a bug before 1.3 where acksends    	//  cause problems if a disconnect flows just right. Unsure if this    	//  will be an issue    	//    	    	if (gOTVersion < kOTVersion113) {    		dataPtr = OTAllocMem(sizeof(OTData));    		if (dataPtr == NULL) { //Death lurks I''m sure    		    OTAtomicAdd32(-1, &epi->outstandingSends);                OTFreeMem(buffer);                return 0;            }    		dataPtr->fNext = NULL;    		dataPtr->fData = buffer;    		dataPtr->fLen  = size;    		res = OTSnd(epi->erf, dataPtr, kNetbufDataIsOTData, 0);    		    		//Note in the notification routine we cleanup the allocated dataPtr AND buffer.    	}    	else    	{    		res = OTSnd(epi->erf, buffer, size, 0);    		    		//JMM how to handle kENOMEMErr no memory right now error    		//Book says to back off and wait but must do a timer or something    		//Right now we''ll fail the primitive higher up since the error code is bad    	}    }	if (res == size) return (SInt32) size;	if (res >= 0) {		//		//	Implied kOTFlowErr since not all data was accepted.		//  But maybe we aren''t blocked yet so keep sending		//		return res;	} else	{	// res < 0	 		OTAtomicAdd32(-1, &epi->outstandingSends);        OTFreeMem(buffer);        	    if ((epi->socketType !!= UDPSocketType) && (gOTVersion < kOTVersion113) )	       	OTFreeMem(dataPtr); 	   		if (res == kOTFlowErr) {		    //		    // Flow control back off and wait for T_GODATA		    //        	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);			return 0;		}				if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_GODATA || res == T_DISCONNECT)			{				//	Wait to get the T_ORDREL at the notifier and handle it there.				//	Then we will resume sending.				//  Same applies for other events				//                //JMM test?                	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);				return 0;			} else 			    	return res; 		} else 		    return res;		}}////Set the options//int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80],optionValue[80];    SInt32      anInteger;    	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);	optionName[optionNameSize] = 0x00;	    OTMemcpy(optionValue,(char *) optionValueT,optionValueSize);    optionValue[optionValueSize] = 0x00;    stringtonum((char *) optionValue,&anInteger);       	   error = lookupOptionName(epi, false, (char *) &optionName, anInteger,(long *) result);   return error;}////Get the options//int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80];   	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);  //NEED to fiddle with error number JMM to say readonly notvalid etc.	optionName[optionNameSize] = 0x00;	     	   error = lookupOptionName(epi, true, (char *) &optionName, NULL,(long *)  result);   return error;}// A Number of routines to set/get options, first figureout the flags, then call the routine// To set or get the options. static SInt32	lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result) {	if (strcmp("TCP_MAXSEG",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_MAXSEG,value,result);};	if (strcmp("TCP_NODELAY",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NODELAY,value,result);};	if (strcmp("TCP_ABORT_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_NOTIFY_THRESHOLD",aString)==0) {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_ABORT_THRESHOLD",aString)==0) 	{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_NOTIFY_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_URGENT_PTR_TYPE",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_URGENT_PTR_TYPE,value,result);};	if (strcmp("UDP_CHECKSUM",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_UDP,UDP_CHECKSUM,value,result);};	if (strcmp("SO_DEBUG",aString)==0) 			    	{return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_DEBUG,value,result);};	if (strcmp("SO_REUSEADDR",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);;};	if (strcmp("SO_REUSEPORT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);};	if (strcmp("SO_DONTROUTE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_DONTROUTE,value,result);};	if (strcmp("SO_BROADCAST",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST,value,result);};	if (strcmp("SO_SNDBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDBUF,value,result);};	if (strcmp("SO_RCVBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVBUF,value,result);};	if (strcmp("SO_KEEPALIVE",aString)==0) 			   {return SetKeepAliveOption(epi,trueIfGet,INET_TCP,TCP_KEEPALIVE,value,result);};	if (strcmp("SO_OOBINLINE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_OOBINLINE,value,result);};	if (strcmp("SO_PRIORITY",aString)==0) 			     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TOS,value,result);};	if (strcmp("SO_LINGER",aString)==0) 			      {return SetLingerOption(epi,trueIfGet,XTI_GENERIC,XTI_LINGER,value,result);};	if (strcmp("SO_RCVLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVLOWAT,value,result);};	if (strcmp("SO_SNDLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDLOWAT,value,result);};			if (strcmp("IP_OPTIONS",aString)==0) 			    { }; //JMM What to do here?		if (strcmp("IP_TTL",aString)==0) 			         {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TTL,value,result);};		if (strcmp("IP_HDRINCL",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_HDRINCL,value,result);}; //NOT SUPPORT FOR IP		if (strcmp("IP_RCVOPTS",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVOPTS,value,result);};		if (strcmp("IP_RCVDSTADDR",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVDSTADDR,value,result);};		if (strcmp("IP_MULTICAST_IF",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_IF,value,result);};		if (strcmp("IP_MULTICAST_TTL",aString)==0) 			 {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_TTL,value,result);};		if (strcmp("IP_MULTICAST_LOOP",aString)==0) 	     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_LOOP,value,result);};	/*	if (strcmp("IP_ADD_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_ADD_MEMBERSHIP,value,result);};		if (strcmp("IP_DROP_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_DROP_MEMBERSHIP,value,result);};		if (strcmp("IP_BROADCAST_IF",aString)==0) 	        {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST_IF,value,result);};		if (strcmp("IP_RCVIFADDR",aString)==0) 	            {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVIFADDR,value,result);};	*/    *result = 0;    return -1;}static OTResult SetFourByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTFourByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   option->value[0] = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(optBuffer);   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);      if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}								    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = option->value[0];   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }                return (err);}static OTResult SetOneByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTOneByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   *(unsigned char *)option->value = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= kOTOneByteOptionSize;   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = (UInt32) (*(unsigned char *)option->value);   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}static OTResult SetKeepAliveOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TKeepAliveOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpKeepAliveOn = T_NO;   else        optBuffer.tcpKeepAliveOn = T_YES;           optBuffer.tcpKeepAliveTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpKeepAliveTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}		    static OTResult SetLingerOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TLingerOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpLingerOn = T_NO;   else        optBuffer.tcpLingerOn = T_YES;           optBuffer.tcpLingerTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpLingerTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}////	Notifier:////	Most of the interesting networking code in this program for the resolver resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	Note: The only events which are expected from the DNR are T_DNRSTRINGTOADDRCOMPLETE,//	T_DNRADDRTONAMECOMPLETE, and of close sleep/reconfigure notifications.////static pascal void DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);		//	//	Once the program is shutting down, most events would be uninteresting.	//	if (gProgramState !!= kProgramRunning)			return;			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	T_DNRSTRINGTOADDRCOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the server''s name into an IP address we can use to connect to.		//		case T_DNRSTRINGTOADDRCOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSAddr = gDNSHostInfo.addrs[0];			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}				//		//	T_DNRADDRTONAMECOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the  an IP address into a server name.		//		case T_DNRADDRTONAMECOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}									//		//	kOTProviderWillClose:		//		//	This event occurs when the user changes TCP/IP in the control panel		//		case kOTProviderWillClose:		case kOTProviderIsClosed:		{			gDNSResolverError = kOTProviderWillClose;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			ResolverTerminate(); 			gDNSResolverStatus = RESOLVER_SUCCESS; //Cheat!! Keep Squeak happy later we fix the resolver EP.			return;		}				//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.  In the production version of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for socket: Please note we have another notifier for sockets that do multiple listens//  And a different notifier for UDP sockets, however the intesting thing is that we can call/// This routine from othe other as a simple form of inheritence.////	Most of the interesting networking code in this program for socket support resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	IMPORTANT NOTE:  Normal events defined by XTI (T_LISTEN, T_CONNECT, etc)//	and OT completion events (T_OPENCOMPLETE, T_BINDCOMPLETE, etc.) are not//	reentrant.  That is, whenever our notifier is invoked with such an event,//	the notifier will not be called again by OT for another normal or completion//	event until we have returned out of the notifier - even if we make OT calls//	from inside the notifier.   This is a useful synchronization tool.//	However, there are two kinds of events which will cause the notifier to //	be reentered.   One is T_MEMORYRELEASED, which always happens instantly.//	The other are state change events like kOTProviderWillClose.//static pascal void NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie){	OSStatus err;	OTResult epState;	EPInfo* epi = (EPInfo*) context;		JMMLogMessageAndNumber("\p Event  ",event);	JMMLogMessageAndNumber("\p Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	//	//	Once the program is shutting down, most events would be uninteresting.	//	However, we still need T_OPENCOMPLETE and T_MEMORYRELEASED events since	//	we can''t call CloseOpenTransport until all OTAsyncOpenEndpoints and	//	OTSends with AckSends have completed.   So those specific events	//	are still accepted.	//	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	kStreamIoctlEvent:		//		//	This event is returned when an I_FLUSH ioctl has completed.		//	The flush was done in an attempt to get back all T_MEMORYRELEASED events		//	for outstanding OTSnd() calls with Ack Sends.   For good measure, we		//	send a disconnect now.   Errors are ignored at this point since it is		//	possible that the connection will already be gone, etc.		//		case kStreamIoctlEvent:		{			if (OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) !!= 0) {			    OTAtomicClearBit(&epi->stateFlags2, kFlushDisconnectInProgressBit);				(void) OTSndDisconnect(epi->erf, NULL);			}			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only when we open a port with a listen.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);        		return;            }            makeEPConnected(epi);			return;		}		//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound to a wildcard addr.		//  Bind happens when we open a connection to a remote location.		//	No errors are expected.   		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {            	makeEPUnconnected(epi);				return;			}			if (epi->remoteAddress.fHost !!= 0) 			    DoConnect(epi,epi->remoteAddress.fHost, epi->remoteAddress.fPort);			return;		}				//		//	T_CONNECT:		//		//	This event is returned when a connection is established to the server.		//	The program must call OTRcvConnect() to get the conenction information		//	and clear the T_CONNECT event from the stream.  Since OTRcvConnect()		//	returns immediately (rather than via a completion event to the notifier)		//	we can use local stack structures for parameters.		//		case T_CONNECT:		{			TCall call;						            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);  				return;			}						// Address of endpoint that has connection			// This could be different from original request			// Due to hand off to different EP say you connect to 			// port 80, but you end up on 49160						call.addr.maxlen = sizeof(InetAddress);			call.addr.buf = (unsigned char*) &epi->remoteAddress;  			call.opt.maxlen = 0;			call.opt.buf = NULL;			call.udata.maxlen = 0;			call.udata.buf = NULL;						err = OTRcvConnect(epi->erf, &call);			SetEPLastError(epi,err);			if (err !!= kOTNoError) {			    if (err == kOTLookErr) {			        OSStatus	lookStatus;			        lookStatus = OTLook(epi->erf);			        if (lookStatus == T_DISCONNECT) {               			err = OTRcvDisconnect(epi->erf, NULL);        	    		if (err !!= kOTNoError) {        		    		if (err == kOTNoDisconnectErr) {                    			err = OTRcvConnect(epi->erf, &call);                    			SetEPLastError(epi,err);                       			makeEPConnected(epi);       		    		        return;       		    		    }			            } else {                			err = OTRcvConnect(epi->erf, &call);                			SetEPLastError(epi,err);                   			makeEPConnected(epi);                            OTAtomicSetBit(&epi->stateFlags, kOtherEndClosed);			   		    		        return;			            }			        }			        if (lookStatus == T_GODATA) { // HUH            			err = OTRcvConnect(epi->erf, &call);            			SetEPLastError(epi,err);               			makeEPConnected(epi);	    		        return;			        }			    }                //JMM book says may return kOTNoDataErr (no connecton yet) or a kOTLookErr with T_DISCONNECT                // BUT we had got T_GODATA WHY?                 				makeEPUnconnected(epi);				return;			}						makeEPConnected(epi);			return;				// Wait for a T_DATA...		}				//		//	T_LISTEN:		//		case T_LISTEN:		{			DoListenAccept(epi,epi);			return;		}		//		//	T_DATA:		//		//	The main rule for processing T_DATA''s is to remember that once you have		//	a T_DATA, you won''t get another one until you have read to a kOTNoDataErr.		//	The advanced rule is to remember that you could get another T_DATA		//	during an OTRcv() which will eventually return kOTNoDataErr, presenting		//	the application with a synchronization issue to be most careful about.		//			//	In this application, since an OTRcv() calls are made from inside the notifier,		//	this particular synchronization issue doesn''t become a problem.		//		case T_DATA:		{			if (!!OTAtomicTestBit(&epi->stateFlags2, kPassconNeeded)) {			    ReadData(epi,NULL,0);			    return;			 }			 else {    			//    			//	Here we work around a small OpenTransport bug.    			//	It turns out, since this program does almost everything from inside the notifier,    			//	that during a T_UNBINDCOMPLETE we can put an EPInfo back into the idle list.    			//	If that notification is interrupted by a T_LISTEN at the notifier, we could    			//	end up starting a new connection on the endpoint before OT unwinds the stack    			//	out of the code which delivered the T_UNBINDCOMPLETE.   OT has some specific    			//	code to protect against a T_DATA arriving before the T_PASSCON, but in this    			//	case it gets confused and the events arrive out of order.   If we try to    			//	do an OTRcv() at this point we will get a kOTStateChangeErr because the endpoint    			//	is still locked by the earlier OTAccept call until the T_PASSCON is delivered    			//	to us.   This is fairly benign and can be worked around easily.  What we do    			//	is note that the T_PASSCON hasn''t arrived yet and defer the call to ReadData()    			//	until it does.    			//    			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 )    			{    			    ReadData(epi,NULL,0);    			    return;    			}    		}		}							//		//	T_PASSCON:		//		//	This event happens on the accepting endpoint, not the listening endpoint.		//	At this point the connection is fully established and we can begin the		//	process of downloading data.  Note that due to a problem in OT it is 		//	possible for a T_DATA to beat a T_PASSCON to the notifier.  When this		//	happens we note it in the T_DATA case and then start processing the 		//	data here.  		//		case T_PASSCON:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {               	OTAtomicSetBit(&epi->stateFlags, kPassconBit);   				makeEPUnconnected(epi);				return;			}			   			makeEPConnected(epi);                		    if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 ){				//				//	A T_DATA previously beat the T_PASSCON to our notifier.				//	Here we help OT out by having deferred data processing until now.				//			    ReadData(epi,NULL,0);			}			return;		}		//		// T_MEMORYRELEASED		// lower level has finished with buffer						case T_MEMORYRELEASED:		{		    if (cookie == nil) return;			OTAtomicAdd32(-1, &epi->outstandingSends);				    	if (epi->socketType == UDPSocketType) {		        OTFreeMem(cookie);	    	} else {//tcp		    	if (gOTVersion < kOTVersion113) {		    		struct OTData *data=cookie;		    		OTFreeMem(data->fData);		    		OTFreeMem(data);		    	} else {		        	OTFreeMem(cookie);		        }	        }	        			    return;		}					//		//	T_DISCONNECT:		//		//	An inbound T_DISCONNECT event usually indicates that the other side of the		//	connection did an abortive disconnect (as opposed to an orderly release).		//	It also can be generated by the transport provider on the system (e.g. tcp)		//	when it decides that a connection is no longer in existance.		//		//	We receive the disconnect, but this program ignores the associated reason (NULL param).		//	It is possible to get back a kOTNoDisconnectErr from the OTRcvDisconnect call.		//	This can happen when either (1) the disconnect on the stream is hidden by a 		//	higher priority message, or (2) something has flushed or reset the disconnect		//	event in the meantime.   This is not fatal, and the appropriate thing to do is		//	to pretend the T_DISCONNECT event never happened.   Any other error is unexpected		//	and needs to be reported so we can fix it.  Next, unbind the endpoint so we can		//	reuse it for a new inbound connection.		//			//	It is possible to get an error on the unbind due to a bug in OT 1.1.1 and earlier.		//	The best thing to do for that is close the endpoint and open a new one to replace it.		//	We do this back in the main thread so we don''t have to deal with synchronization problems.		//		case T_DISCONNECT:		{			//JMM what should we do			epState = OTGetEndpointState(epi->erf);			if (epState == T_OUTCON) {			}			err = OTRcvDisconnect(epi->erf, NULL);			if (err !!= kOTNoError) {				if (err == kOTNoDisconnectErr) return;			    makeEPBroken(epi,err);				return;			}			                ///                //Both sides now have closed                 //                        OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);						err = OTUnbind(epi->erf);    	    TapAllInterestedSemaphores(epi);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			return;		}				//		//	T_GODATA:		//		//	This event is received when flow control is lifted.   We are under flow control		//	whenever OTSnd() returns a kOTFlowErr or accepted less bytes than we attempted		//	to send.  		//		//	Note, it is also possible to get a T_GODATA without having invoke flow control.		//	Be safe and prepare for this. 		//		case T_GODATA:		{            if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) { 	           if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))  	              interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_OPENCOMPLETE:		//		//	This event occurs when an OTAsyncOpenEndpoint() completes.   Note that this event,		//	just like any other async call made from outside the notifier, can occur during		//	the call to OTAsyncOpenEndpoint().  That is, in the main thread the program did		//	the OTAsyncOpenEndpoint(), and the notifier is invoked before control is returned		//	to the line of code following the call to OTAsyncOpenEndpoint().   This is one		//	event we need to keep track of even if we are shutting down the program since there		//	is no way to cancel outstanding OTAsyncOpenEndpoint() calls.		//		case T_OPENCOMPLETE:		{			TOptMgmt 			optReq;			TOption             opt;			OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);			if (result == kOTNoError)				epi->erf = (EndpointRef) cookie;			else {				makeEPBrokenThenIdle(epi,result);				return;			}			if (gProgramState !!= kProgramRunning) return;										//			//	Set to blocking mode so we don''t have to deal with kEAGAIN errors.			//	Async/blocking is the best mode to write an OpenTransport application in.			//			err = OTSetBlocking(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Set to AckSends so OT doesn''t slow down to copy data sent out.			//	However, this requires special care when closing endpoints, so don''t use			//	AckSends unless you are prepared for this.   Never, ever, close an endpoint			//	when a send has been done but the T_MEMORYRELEASED event hasn''t been returned yet.			//			err = OTAckSends(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Option Management			//			//	Turn on ip_reuseaddr so we don''t have port conflicts in general.			//	We use local stack structures here since the memory for the 			//	option request structure is free upon return.   If we were to request			//	the option return value, we would have to use static memory for it.			//			optReq.flags			= T_NEGOTIATE;			optReq.opt.len			= kOTFourByteOptionSize;			optReq.opt.buf			= (unsigned char *) &opt;						opt.len					= sizeof(TOption);			opt.level				= INET_IP;			opt.name				= IP_REUSEADDR;			opt.status				= 0;			opt.value[0]			= 1;			            if (epi->socketType == TCPSocketType)                 OTAtomicSetBit(&epi->stateFlags3, kKeepAliveOptionNeeded);                			err = OTOptionManagement(epi->erf, &optReq, NULL);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);			}						//			//	Code path resumes at T_OPTMGMTCOMPLETE			//						return;		}				//		//	T_OPTMGMTCOMPLETE:		//		//	An OTOptionManagement() call has completed.  These are used on all		//	endpoints to set IP_REUSEADDR.   It is also used for all endpoints		//	other than the listener to set TCP_KEEPALIVE which helps recover		//	server resources if the other side crashes or is unreachable.		//		case T_OPTMGMTCOMPLETE:		{			TOptMgmt 			optReq;			if (result !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,result);				return;			}			            if (OTAtomicClearBit(&epi->stateFlags3, kKeepAliveOptionNeeded)) {                                TKeepAliveOpt		opt;				//				//	Turn on TCP_KEEPALIVE so we can recover from connections which have				//	gone away which we don''t know about.  				//				optReq.flags			= T_NEGOTIATE;				optReq.opt.len			= sizeof(TKeepAliveOpt);				optReq.opt.buf			= (unsigned char *) &opt;								opt.len					= sizeof(TKeepAliveOpt);				opt.level				= INET_TCP;				opt.name				= TCP_KEEPALIVE;				opt.status				= 0;				opt.tcpKeepAliveOn		= 1;				opt.tcpKeepAliveTimer	= kTCPKeepAliveInMinutes;									err = OTOptionManagement(epi->erf, &optReq, NULL);				if (err !!= kOTNoError) {    			    makeEPBrokenThenIdle(epi,result);                }                return;            }						            makeEPIdle(epi);  //This is where more EP enter the queue of available EPs.            			return;			// now wait 		}		//		//	T_ORDREL:		//		//	This event occurs when an orderly release has been received on the stream.		//		case T_ORDREL:		{			err = OTRcvOrderlyDisconnect(epi->erf);						if (err !!= kOTNoError) {				//				//	It is possible for several reasons for the T_ORDREL to have disappeared,				//	or be temporarily hidden, when we attempt the OTRcvOrderlyDisconnect().				//	The best thing to do when this happens is pretend that the event never				//	occured.   We will get another notification of T_ORDREL if the event				//	becomes unhidden later.  Any other form of error is unexpected and 				//	is reported back so we can correct it.				//				if (err == kOTNoReleaseErr)					return;				//Can get OTLookErr with T_DISCONNECT    		   makeEPBroken(epi,err);			}				if (OTAtomicTestBit(&epi->stateFlags, kThisEndClosed)) {                                ///                //Both sides now have closed                //                                OTAtomicSetBit(&epi->stateFlags, kUnConnected);			    	        OTAtomicClearBit(&epi->stateFlags, kConnected);                OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			                OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);											epState = OTGetEndpointState(epi->erf);				if (epState !!= T_IDLE) {            	    TapAllInterestedSemaphores(epi);				    return;				}				err = OTUnbind(epi->erf);        	    TapAllInterestedSemaphores(epi);				if (err !!= kOTNoError) {				    makeEPBroken(epi,err);				}				    		    return;            } else {    			OTAtomicSetBit(&epi->stateFlags, kOtherEndClosed);			}						//			//	Sometimes our data sends get stopped with a kOTLookErr			//	because of a T_ORDREL from the other side (which doesn''t close			//	the connection, it just means they are done sending data).			//	If so, we still end up in the notifier with the T_ORDREL event,			//	but we won''t resume sending data unless we explictly check			//	here whether or not we need to do so.			//             //JMM Test this?             if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) {  		    	if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))                	interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_UNBINDCOMPLETE:		//		//	This event occurs on completion of an OTUnbind().		//	The endpoint is ready for reuse on a new inbound connection.		//	Note that the OTLIFO structure has atomic queue and dequeue,		//	which can be helpful for synchronization protection.  		//		case T_UNBINDCOMPLETE:		{			if (result !!= kOTNoError) {				//				//	Unbind errors can occur as a result of a bug in OT 1.1.1 and earlier				//	versions.   The best recovery is to put the endpoint in the broken				//	list for recycling with a clean, new endpoint.				//  Since we only support 1.1.2 we don''t expect to run this code.				//			    makeEPBroken(epi,result);				return;			}			return;		}						//		//	T_DISCONNECTCOMPLETE:		//		//	This event occurs on completion of an OTSndDisconnect().		//	Called when we abort a socket		//		case T_DISCONNECTCOMPLETE: {			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			purgeReadBuffers(epi);		            TapAllInterestedSemaphores(epi); 			if (OTAtomicTestBit(&epi->stateFlags2, kMakeEPIdle)) { //Make EP idle if marked as such only happens via destroy. 			    makeEPIdle(epi);			}			epi->stateFlags = 0;			epi->stateFlags2 = 0;			epi->stateFlags3 = 0;            SetEPLastError(epi,result);        	OTAtomicSetBit(&epi->stateFlags, kUnConnected);			return;		}				//		//Sleep sleep sleep all end points get trashed.		//		case kOTProviderWillClose: // reconfig stack disconnect and close		{		    makeEPBroken(epi,-12345678);            if(OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit)) return;            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTSndDisconnect(epi->erf, NULL);            OTUnbind(epi->erf);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 		    return;		}		case kOTProviderIsClosed: //Sleep lurks		{		    makeEPBroken(epi,-12345678);            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 			return;		}		//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.   When running in debugging mode while developing a program,		//	we exit with an informational alert.   Later, in the production version		//	of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for listen socket://static pascal void NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	if (gProgramState !!= kProgramRunning)	{		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED))		{			return;		}	}	JMMLogMessageAndNumber("\p Listener Event  ",event);	JMMLogMessageAndNumber("\p Listener Result ",result);	JMMLogMessageAndNumber("\p Listener Id ",epi->semaIndex);		switch (event)	{		//		//	T_BINDCOMPLETE:		//		//	We only bind the listener endpoint, and bind failure is a fatal error.  		//	Acceptor endpoints are bound within the OTAccept() call when they get a connection.		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError)   				makeEPUnconnected(epi);      			return;		}						//		//	T_LISTEN:		//		case T_LISTEN:		{            SetEPLastError(epi,result);   			makeEPConnected(epi);			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			return;		}				//		//	default:		//		//	There are events which we don''t handle, pass them onwards		//		default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}	}}////	Notifier for UDP listen socket://static pascal void NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	OSStatus err;	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			switch (event)	{		//Some sort of UDP send error, too late to tell anyone?		//		case T_UDERR: {      		TUDErr 		uderr;		    InetAddress errorAddress;                        uderr.addr.maxlen   = sizeof(InetAddress);            uderr.addr.len      = sizeof(InetAddress);            uderr.addr.buf      = (UInt8 *) &errorAddress;            uderr.opt.maxlen    = 0;            uderr.opt.len       = 0;            uderr.opt.buf       = NULL;   		    err =  OTRcvUDErr(epi->erf, &uderr);            if (err !!= kOTNoError)   				makeEPBroken(epi,err);			            SetEPLastError(epi,uderr.error);		    return;		}				//		//	T_DATA:		//		//  Got milk?		//				case T_DATA: {			ReadData(epi,NULL,0);		    return;		}				//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound.		//	No errors are expected.   		//				case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {   				makeEPUnconnected(epi);				return;			}   			makeEPConnected(epi);			return;		}		//		//	default:		//		//	There are events which we don''t handle, pass them onwards to the regular notifier		//				default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}    }}short	        gJMMFile=0;OTTimeStamp 	JMMStartTimeStamp;OTLIFO			JMMLogBufferLIFO;    	//  Buffers that are free to read intoOTLIFO*			JMMLogBufferBuffers			= &JMMLogBufferLIFO; void JMMWriteLog() {	OSErr			error;	OTLink* 	    list = OTReverseList(OTLIFOStealList(JMMLogBufferBuffers));	OTLink*		    link;	ReadBuffer      *aBuffer;	long           dummySize;	char			CH=0x0D;	if (true) return;		error = Create("\pJMMFOOBAR.txt",0,''TEXT'',''TEXT'');	error = FSOpen("\pJMMFOOBAR.txt",0,&gJMMFile);	error = SetFPos(gJMMFile,fsFromLEOF,0);	while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);    	error = FSWrite(gJMMFile,(long *)&aBuffer->readBufferSize,aBuffer->readBufferData);    	dummySize = 1;    	error = FSWrite(gJMMFile,&dummySize,&CH);	}	error = FSClose(gJMMFile);		while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer); 	}	}void JMMLogMessage(Str255 input) {	Str255 			timeString;	long 			timeStringLength,inputLength;	UInt32			duration;	ReadBuffer      *readBufferObject;		if (true) return;		if (gJMMFile == 0) {		gJMMFile = 1;		OTGetTimeStamp(&JMMStartTimeStamp);		JMMLogBufferBuffers->fHead 		= NULL;	}		duration = OTElapsedMilliseconds(&JMMStartTimeStamp);	NumToString(duration,timeString);	timeStringLength = (unsigned char) timeString[0];	inputLength = (unsigned char) input[0];		readBufferObject = OTAllocMem(sizeof(ReadBuffer));	if (readBufferObject == NULL) return;	OTMemzero(readBufferObject,sizeof(ReadBuffer));		readBufferObject->readBufferData = OTAllocMem(60);	if (readBufferObject->readBufferData == NULL) {	    OTFreeMem(readBufferObject);	    return;	}		OTMemcpy(readBufferObject->readBufferData,timeString+1,timeStringLength);	OTMemcpy(readBufferObject->readBufferData+timeStringLength,input+1,inputLength);	readBufferObject->readBufferSize= timeStringLength+inputLength;    OTLIFOEnqueue(JMMLogBufferBuffers, &readBufferObject->fNext);	}void JMMLogMessageAndNumber(Str255 msg,long number) {	Str255 buffer,numberString;	long msgLength,numberLength;		if (true) return;		NumToString(number,numberString);	numberLength = (unsigned char) numberString[0];	msgLength = (unsigned char) msg[0];		OTMemcpy(buffer+1,msg+1,msgLength);	OTMemcpy(buffer+1+msgLength,numberString+1,numberLength);	buffer[0] = (unsigned char) msgLength+numberLength;	JMMLogMessage(buffer);}/*The Open Transport TCP/IP software modules provide a RawIP interface to the IP protocolhostname of '''' lookup fails This is OK? Same on linux and old mac versionJMM look at tlook page, not sure if we have completely understood itJMM is it legal to send a zero byte buffer need case for this?/* According to the XTI spec ("Section 4.6 Events and TLOOK Error indication"), the SndOrderlyDisconnect and RcvOrderlyDisconnect calls can fail because of a pending T_DISCONNECT event. This is XTI trying to tell you that the a connection on that endpoint broke. This can happen in this asynchronous wacky world of networks and your program will have to call a RcvDisconnect to acknowledge that your endpoint dropped.You might want to check out the OTI spec, which, although it is not always written in the most lucid fashion, does contain valuable information for those involved in OpenTransport programming.Further Information:Title: X/OPEN TRANSPORT INTERFACE (XTI) VER 2 [ 1.0 ed]Author: X/OPEN ISBN #: 0133534596A Prior to Open Transport 1.3, there was no supported way of calling Open Transport from CFM-68K code. With the introduction of Open Transport 1.3, it is now possible to call the Open Transport client interface from CFM-68K code. The Open Transport 1.3 SDK includes stub libraries and a document, "Open Tpt CFM68K Dev. Note", which explains Open Transport''s support for CFM-68K. which is supporte for syste 7.x but you can''t install!! No standalone installer exists. Coping the OT files kinda works*/#else/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include <MacHeaders.h>  /* needed only for ExitToShell() */#include "sq.h"#include "SocketPlugin.h"/* initialize/shutdown */int socketInit() { return true; }int socketShutdown() { sqNetworkShutdown(); }/* End of adjustments for pluginized VM */#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket Type Constants ***/#define TCPSocketType 		0#define UDPSocketType 		1#define ListenerQueueType	2/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of open sockets */	int			semaIndex;	int			connectStatus;	void *		nextInListenerQueue; /* next socket in a ListenderQueue waiting socket list */	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;typedef struct {	int			localAddress;	int			localPort;	int			closed;				/* set true by close or abort */	int			semaIndex;			/* semaphore of the server socket */	int			desiredQueueLength;	TCPSockPtr	waitingSockets;} ListenerQueueRec, *ListenerQueuePtr;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of open sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private ListenerQueue Socket Functions ***/void		FillListenerQueue(ListenerQueuePtr listener);TCPSockPtr	FindConnectedSocket(ListenerQueuePtr listener);TCPSockPtr	FindZombieSocket(ListenerQueuePtr listener);void		RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener);ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize);void		ListenerQueueDestroy(ListenerQueuePtr listener);int			ListenerQueueStatus(ListenerQueuePtr listener);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) {  interpreterProxy->success(false);}int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{  interpreterProxy->success(false);}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {  interpreterProxy->success(false);}int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{  interpreterProxy->success(false);}int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;	} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == ListenerQueueType) {		return ListenerQueueStatus((ListenerQueuePtr) s->privateSocketPtr);	}	success(false);}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);		return;	}	success(false);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}		return;	}	if (s->socketType == UDPSocketType) {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}		return;	}	success(false);}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		ListenerQueueDestroy((ListenerQueuePtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == ListenerQueueType) {		return 0;  /* ListenerQueue''s themselves never get an error */	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);		return;	}	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localAddress;	}	success(false);}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localPort;	}	success(false);}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}	success(false);}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	}	if (s->socketType == UDPSocketType) {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}	success(false);}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Squeak TCP Socket Listen/Accept Functions ***/ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize) {	ListenerQueuePtr listener;	/* allocate a new ListenerQueue */	listener = (ListenerQueuePtr) malloc(sizeof(ListenerQueueRec));	if (listener == nil) return nil;	/* initialize it */	listener->localAddress = TCPSockLocalAddress(tcpSocket);	listener->localPort = port;	listener->closed = false;	listener->semaIndex = tcpSocket->semaIndex;	listener->desiredQueueLength = (backlogSize < 1) ? 1 : backlogSize;	listener->waitingSockets = nil;	/* add the given socket to the new ListenerQueue */	tcpSocket->nextInListenerQueue = listener->waitingSockets;	listener->waitingSockets = tcpSocket;	TCPSockListenOn(tcpSocket, listener->localPort);	/* create additional waiting sockets in necessary to fill the ListenerQueue */	FillListenerQueue(listener);	return listener;}void ListenerQueueDestroy(ListenerQueuePtr listener) {	TCPSockPtr thisSock, nextSock;	/* destroy all sockets in this ListenerQueue''s waiting socket list */	thisSock = listener->waitingSockets;	while (thisSock !!= nil) {		nextSock = thisSock->nextInListenerQueue;		TCPSockDestroy(thisSock);		thisSock = nextSock;	}	/* clear a few fields, just in case of a dangling reference */	listener->closed = true;	listener->semaIndex = 0;	listener->waitingSockets = nil;	/* free the ListenerQueue */	free(listener);}int ListenerQueueStatus(ListenerQueuePtr listener) {	TCPSockPtr sock;	if (listener == nil) {		success(false);		return Unconnected;	}	if (listener->closed) return Unconnected;	/* check for zombie sockets; if there is one, clean up the queue */	if (FindZombieSocket(listener) !!= nil) {		FillListenerQueue(listener);  /* removes zombies and refills queue */	}	/* scan queue for a connected socket */	sock = FindConnectedSocket(listener);	return (sock == nil) ? WaitingForConnection : Connected;}void FillListenerQueue(ListenerQueuePtr listener) {	TCPSockPtr sock, newSock;	int count, socksToAdd;	/* remove from the queue and destroy any zombie sockets */	while ((sock = FindZombieSocket(listener)) !!= nil) {		RemoveSocketFromListenerQueue(sock, listener);		TCPSockDestroy(sock);	}	/* count the number of remaining sockets */	count = 0;	sock = listener->waitingSockets;	while (sock !!= nil) {		count++;		sock = sock->nextInListenerQueue;	}	/* create enough new sockets up to fill ListenerQueue to desired size */	socksToAdd = listener->desiredQueueLength - count;	while (socksToAdd > 0) {		newSock = TCPSockCreate();		if (newSock!!= nil) {			/* set semaphore of the new socket*/			newSock->semaIndex = listener->semaIndex;			/* record new socket in openTCPSockets */			newSock->next = openTCPSockets;			openTCPSockets = newSock;			/* add new socket to the listener queue and start it listening */			newSock->nextInListenerQueue = listener->waitingSockets;			listener->waitingSockets = newSock;			TCPSockListenOn(newSock, listener->localPort);		}		socksToAdd--;	}}TCPSockPtr FindConnectedSocket(ListenerQueuePtr listener) {  /* Return the first connected socket in the given ListenerQueue,     or nil if there isn''t one. */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if (sock->connectStatus == Connected) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}TCPSockPtr FindZombieSocket(ListenerQueuePtr listener) {  /* Return the first socket in the given ListenerQueue that is not connected or     waiting for a connection (we call this a zombie), or nil if there isn''t one.     Zombies are created when a connection is made but broken again before an     accept has been done. Since a zombie are no longer waiting for a connection,     it takes the place of listening socket. If the queue became filled with zombies     no connections could get through. Thus, zombies must be eliminated. As the     saying goes: "the only good zombie is a dead zombie." */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if ((sock->connectStatus !!= WaitingForConnection) &&			(sock->connectStatus !!= Connected)) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {  /* Accept a connection for the given server socket. The server socket must     have been turned into a listener queue via sqSocketListenOnPortBacklogSize().     If successful, s is initialized to newly connected socket using the     given paramenters, and a new listening socket will be created and added     to the ListenerQueue to maintain the desired queue length. Note that MacTCP     allows multiple sockets to be listening on the same port number and, indeed,     this is the only way to support the Unix socket notion of a socket backlog. */	ListenerQueuePtr listener;	TCPSockPtr connectedSock;	/* server socket must be a valid ListenerQueue */	if ((serverSocket == nil) ||		(serverSocket->sessionID !!= thisNetSession) ||		(serverSocket->socketType !!= ListenerQueueType) ||		(serverSocket->privateSocketPtr == nil)) {			success(false);			return;	}	/* result socket must be a new, unintialized socket */	if ((s == nil) ||		(s->sessionID !!= 0) ||		(s->socketType !!= 0) ||		(s->privateSocketPtr !!= nil)) {			success(false);			return;	}	/* look for a connected socket */	listener = (ListenerQueuePtr) serverSocket->privateSocketPtr;	connectedSock = FindConnectedSocket(listener);	if (connectedSock == nil) {		success(false);	} else {		/* remove connected socket from the listener queue */		RemoveSocketFromListenerQueue(connectedSock, listener);		/* fill in the result socket handle */		connectedSock->semaIndex = semaIndex;		s->sessionID = thisNetSession;		s->socketType = TCPSocketType;		s->privateSocketPtr = connectedSock;	}	/* ensure that the queue has the desired number of listenening sockets */	FillListenerQueue(listener);}void RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener) {	TCPSockPtr lastSock, thisSock;	if (sockToRemove == nil) return;	if (listener->waitingSockets == sockToRemove) {		listener->waitingSockets = sockToRemove->nextInListenerQueue;		sockToRemove->nextInListenerQueue = nil;		return;	}	lastSock = listener->waitingSockets;	thisSock = lastSock->nextInListenerQueue;	while (thisSock !!= nil) {		if (thisSock == sockToRemove) {			lastSock->nextInListenerQueue = sockToRemove->nextInListenerQueue;			sockToRemove->nextInListenerQueue = nil;			return;		}		lastSock = thisSock;		thisSock = lastSock->nextInListenerQueue;	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	TCPSockPtr tcpSocket;	ListenerQueuePtr listener;	/* s must be an TCP socket that is initialized but unconnected */	if ((!!SocketValid(s)) || (s->socketType !!= TCPSocketType)) {		success(false);		return;	}	tcpSocket = (TCPSockPtr) s->privateSocketPtr;	if (tcpSocket->connectStatus !!= Unconnected) {		success(false);		return;	}	/* make sure the port number is in range */	if (!!PortNumberValid(port)) {;		success(false);		return;	}	/* create a new listener on the given with the given backlog size */	listener = ListenerQueueCreate((TCPSockPtr) s->privateSocketPtr, port, backlogSize);	if (listener == nil) {		success(false);		return;	}	/* mutate s into a listener socket: replace the original TCP socket in s with	   the new listener, and change the type of s to ListenerQueueType */	s->socketType = ListenerQueueType;	s->privateSocketPtr = listener;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;	s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}			return true;	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;	if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;	s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions (not yet implemented) ***/void * UDPSockCreate(void) {	return nil;}void UDPSockDestroy(UDPSockPtr s) {	s;}int UDPSockLocalAddress(UDPSockPtr s) {	s;}int UDPSockLocalPort(UDPSockPtr s) {	s;}int UDPSockRemoteAddress(UDPSockPtr s) {	s;}int UDPSockRemotePort(UDPSockPtr s) {	s;}void UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	s; addr; port;}void UDPSockListenOn(UDPSockPtr s, int port) {	s; port;}int UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}int UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 16:21'!macSoundFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SoundPlugin.h"/* initialize/shutdown */int soundInit() { return true; }int soundShutdown() { snd_Stop(); }/* End of adjustments for pluginized VM */#include <Sound.h>#include <SoundInput.h>/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 2)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, 0, 0, 0, 0, 0, true};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {  /* Switch buffers (at interrupt time). The given buffer just finished playing. */	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();	FillBufferWithSilence(buf);  /* avoids ugly stutter if not filled in time */}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) {   /* could not allocate memory for a buffer; clean up and abort */			SndDisposeChannel(chan, true);			DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);			if (i == 1) {  /* free the first buffer */				DisposePtr((char *) dblBufHeader.dbhBufferPtr[1]);				dblBufHeader.dbhBufferPtr[1] = NULL;			}			return false;		}		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, (unsigned long *) &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 6/7/2000 16:24'!macWindowFile	^ '#include <MacHeaders.h>  /* needed only for ExitToShell() */#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include <sound.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & 0xFF;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);	cachedButtonState = cachedButtonState | buttonState;}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	/* first, look in the "<Squeak VM directory>:Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	strcat(pluginDirPath, ":Plugins");	libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	c2pstr(lookupName);  /* convert to Pascal string */	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) lookupName,		&functionPtr, &ignored);	p2cstr((unsigned char *) lookupName);  /* convert back to C string */	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName;	Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	GetVInfo(0, nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	pb.hFileInfo.ioNamePtr = c2pstr(pluginDirPath);	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	p2cstr((unsigned char *) pluginDirPath);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	fileSpec.vRefNum = vRefNum;	fileSpec.parID = pb.hFileInfo.ioDirID;	strcpy((char *) fileSpec.name, libName);	c2pstr((char *) fileSpec.name);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */	ioProcessEvents();  /* process all pending events */}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = PrefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	short junk;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	/* open MacTCP driver early to avoid leaving a high sandbar in System Heap */	OpenDriver("\p.IPP", &junk);	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */	MaxBlock();	return NewPtr(desiredHeapSize);}#endif/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500 for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, 0);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'! !