'From Squeak2.9alpha of 13 June 2000 [latest update: #3144] on 29 January 2001 at 10:59:12 am'!"Change Set:		MiscFixesDate:			29 January 2001Author:			Juan Manuel VuletichWav file writing. Several fixes for EnvelopeEditorMorphs."!!AbstractSound methodsFor: 'file i/o' stamp: 'JMV 1/19/2001 12:08'!storeWAVOnFileNamed: fileName	| f |	f _ (FileStream fileNamed: fileName) binary.	self storeWAVSamplesSamplingRate: self samplingRate on: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'JMV 1/26/2001 11:36'!storeWAVSamplesSamplingRate: rate on: aBinaryStream	"Write WAV sound file. Stereo, 16 bit. At the appropiate sampling rate."	| bufferSize buffer fullBufferCount lastBufferSize finalSampleCount |	self reset.	finalSampleCount _ (self duration * self samplingRate) ceiling.	bufferSize _ self samplingRate rounded min: finalSampleCount.	"One second. Could be any size."	fullBufferCount _ finalSampleCount // bufferSize.	lastBufferSize _ finalSampleCount \\ bufferSize.	"File header"	aBinaryStream		nextPutAll: 'RIFF' asByteArray;		nextLittleEndianNumber: 4 put: finalSampleCount * 4 + 36;	"Lenght of all chunks"		nextPutAll: 'WAVE' asByteArray.	"Format Chunk"	aBinaryStream		nextPutAll: 'fmt ' asByteArray;		nextLittleEndianNumber: 4 put: 16;		"Lenght of this chunk"		nextLittleEndianNumber: 2 put: 1;		"Format tag"		nextLittleEndianNumber: 2 put: 2;		"Channel count"		nextLittleEndianNumber: 4 put: self samplingRate rounded;		"Samples per sec"		nextLittleEndianNumber: 4 put: self samplingRate rounded * 4;	"Bytes per sec"		nextLittleEndianNumber: 2 put: 4;		"Alignment"		nextLittleEndianNumber: 2 put: 16.		"Bits per sample"	"Data chunk"	aBinaryStream		nextPutAll: 'data' asByteArray;		nextLittleEndianNumber: 4 put: finalSampleCount * 4.		"Lenght of this chunk"	fullBufferCount timesRepeat: [		buffer _ SoundBuffer newStereoSampleCount: bufferSize.		self playSampleCount: bufferSize into: buffer startingAt: 1.		buffer do: [ :sample |			aBinaryStream nextLittleEndianNumber: 2 put: sample \\ 65536 ].	].	buffer _ SoundBuffer newStereoSampleCount: lastBufferSize.	self playSampleCount: lastBufferSize into: buffer startingAt: 1.	buffer do: [ :sample |		aBinaryStream nextLittleEndianNumber: 2 put: sample \\ 65536].! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'JMV 1/9/2001 13:43'!editSound: aSound	| p |	(aSound respondsTo: #envelopes)		ifFalse: [			PopUpMenu inform: 'You selected a ', aSound class name, '.', String cr,				'I can''t handle these kinds of sounds.'.			^self ].	sound _ aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p _ OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'JMV 1/29/2001 10:58'!curveChoices	| extant others |	extant _ sound envelopes collect: [:env | env name].	others _ #('volume' 'modulation' 'pitch' 'random pitch:' 'ratio')		reject: [:x | (extant includes: x) | ((x = 'pitch') & (extant includes: 'random pitch:')) | ((x = 'random pitch:') & (extant includes: 'pitch')) ].	^ (extant collect: [:name | 'edit ' , name])	, (others collect: [:name | 'add ' , name])	, (sound envelopes size > 1		ifTrue: [Array with: 'remove ' , envelope name]		ifFalse: [Array new])! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'JMV 1/29/2001 10:57'!addEnvelopeNamed: envName	| points env |	points _ OrderedCollection new.	points add: 0@0.0;		add: (envelope points at: envelope loopStartIndex) x@1.0;		add: (envelope points at: envelope loopEndIndex) x@1.0;		add: (envelope points last) x@0.0.	envName = 'volume' ifTrue:		[env _ VolumeEnvelope points: points loopStart: 2 loopEnd: 3.		env target: sound; scale: 0.7].	envName = 'modulation' ifTrue:		[env _ Envelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #modulation:;			scale: sound modulation*2.0].	envName = 'pitch' ifTrue:		[env _ PitchEnvelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #pitch:; scale: 0.5].	envName = 'random pitch:' ifTrue:		[env _ RandomEnvelope for: #pitch:.		points _ OrderedCollection new.		points add: 0@(env delta * 5 + 0.5);			add: (envelope points at: envelope loopStartIndex) x@(env highLimit - 1 * 5 + 0.5);			add: (envelope points at: envelope loopEndIndex) x@(env highLimit - 1 * 5 + 0.5);			add: (envelope points last) x@(env lowLimit - 1 * 5 + 0.5).		env setPoints: points loopStart: 2 loopEnd: 3.		env target: sound. ].	envName = 'ratio' ifTrue:		[denominator _ 9999.  "No gridding"		env _ Envelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #ratio:;			scale: sound ratio*2.0].	env ifNotNil:		[sound addEnvelope: env.		self editEnvelope: env]! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'JMV 1/26/2001 11:28'!buildScalesIn: frame	| env hmajortick hminortick |	env _ envelope.	pixPerTick _ graphArea width // (self maxTime//10) max: 1.	hminortick _ ( 1 + ( self maxTime // 800 ) ) * 10.	hmajortick _ ( 1 + ( self maxTime // 800 ) ) * 100.	hScale _ (ScaleMorph newBounds: ((graphArea left)@(frame top) corner: (self xFromMs: self maxTime)@(graphArea top - 1)))		start: 0 stop: self maxTime		minorTick: hminortick minorTickLength: 3		majorTick: hmajortick majorTickLength: 10		caption: 'milliseconds' tickPrintBlock: [:v | v printString].	self addMorph: hScale.	vScale _ ScaleMorph newBounds: (0@0 extent: (graphArea height)@(graphArea left - frame left)).	env name = 'pitch'		ifTrue:		[env scale >= 2.0			ifTrue:			[vScale start: 0 stop: env scale				minorTick: env scale / 24 minorTickLength: 3				majorTick: env scale / 2.0 majorTickLength: 10				caption: 'pitch (octaves)'				tickPrintBlock: [:v | (v-(env scale/2)) asInteger printString]]			ifFalse:			[vScale start: 0 stop: env scale				minorTick: 1.0/48.0 minorTickLength: 3				majorTick: 1.0/12.0 majorTickLength: 10				caption: 'pitch (half-steps)'				tickPrintBlock: [:v | (v-(env scale/2)*12) rounded printString]]]		ifFalse: [			env name = 'random pitch:'				ifTrue: [					vScale start: 0.9 stop: 1.1						minorTick: 0.2 / 50.0 minorTickLength: 3						majorTick: 0.2 / 5.0 majorTickLength: 10						caption: env name						tickPrintBlock: [:v | v printString]]				ifFalse: [					vScale start: 0 stop: env scale						minorTick: env scale / 50.0 minorTickLength: 3						majorTick: env scale / 5.0 majorTickLength: 10						caption: env name						tickPrintBlock: [:v | v printString]].		].	vScale _ TransformationMorph new asFlexOf: vScale.	vScale angle: Float pi / 2.0.	self addMorph: vScale.	vScale position: (frame left)@(graphArea top-1) - (3@1).! !!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'JMV 1/9/2001 13:03'!points	| env |	points isNil ifTrue: [		env _ self target envelopes first.		points _ OrderedCollection new.		points			add: 0@(self delta * 5 + 0.5);			add: (env points at: env loopStartIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points at: env loopEndIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points last)x@(self lowLimit -1 * 5 + 0.5).		loopStartIndex _ 2.		loopEndIndex _ 3.	].	^points! !!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'JMV 1/9/2001 13:08'!setPoints: pointList loopStart: startIndex loopEnd: endIndex	self delta: pointList first y - 0.5 / 5.	self highLimit: (pointList at: startIndex) y - 0.5 / 5 + 1.	self lowLimit: pointList last y - 0.5 / 5 + 1.	^super setPoints: pointList loopStart: startIndex loopEnd: endIndex! !!TransformMorph methodsFor: 'accessing' stamp: 'JMV 1/26/2001 11:22'!angle: newAngle	transform _ transform withAngle: newAngle.	self layoutChanged.	self changed! !"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!