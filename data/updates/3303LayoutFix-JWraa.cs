'From Squeak2.9alpha of 17 July 2000 [latest update: #3369] on 2 February 2001 at 6:29 am'!"Change Set:		LayoutFixDate:			1 February 2001Author:			Jesse WeltonSome comment changes in SmartRefStream by Bob Arning.Changes LayoutFrames so that positive right and bottom offsets represent offsets to the right and down from the lower right corner of the frame.  Eliminates special treatment of the bottom offset in Morph>>addMorph:fullFrame:.  Offsets are now treated the same however a submorph is added.  Changes the few direct calls to #rightOffset: and #bottomOffset: to comply with the new, consistent sign convention.Changes SystemWindows' pane layouts to be based on just the pane region, eliminating the need to offset panes by the labelHeight.  This makes it easier to divide panes as intended, in particular fixing the layout of the bottom (info) pane of FileContentsBrowsers.  The various title bar components are placed in a labelArea submorph to minimize code changes and simplify the layout logic.There may exist problems with some subclasses, but none that I am aware of.  Existing subclasses in the image do not use the layout mechanism to align additional labelArea items, so it is not problematic for these items to be direct submorphs, rather than living in the titleArea.Fixes a mistake made in the preliminary changeset: Now converts all instances of SystemWindow subclasses, not just direct SystemWindow instances."!!SmartRefStream commentStamp: 'RAA 2/2/2001 06:20' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principle is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.-- 2 Feb 2001 --- conversion methods are now different - see SmartRefStream.aComment* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.--------* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now from the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name.  Make an instance of the new			class, and send it the conversion call.				(old class name symbol -> new class name).  renamedConv	Dictionary of conversion selector for Classes who have a different name.				(old class name symbol -> conversion selector).  topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, the top object if deep inside.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.  A class may be stored inside an ImageSegment that is stored by me.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self, does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.Some metaclasses are put into the structures table.  This is for when a block has a receiver that is a class.  See checkFatalReshape:.ImageSegments:	A ReferenceStream is used to enumerate objects to put inside an ImageSegment.  If an instance of a UniClass is seen, the class is put in also.	A SmartRefStream is used to store the ImageSegment.  Roots are nil, and the segment is a wordArray.  We are encoding the outPointers.  Structures contains all classes from both places.  Must filter out UniClasses for some things, and do include them for putting source code at end of file.  Do not write any class inst vars in file.Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tell how to make conversion work when some files have already been written.!]style[(930 555 3463)f1,f1cblue;,f1!MorphicModel subclass: #SystemWindow	instanceVariableNames: 'labelString stripes label closeBox collapseBox activeOnlyOnTop paneMorphs paneRects collapsedFrame fullFrame isCollapsed menuBox mustNotClose labelWidgetAllowance updatablePanes allowReframeHandles labelArea '	classVariableNames: 'TopWindow '	poolDictionaries: ''	category: 'Morphic-Windows'!!LayoutFrame methodsFor: 'layout' stamp: 'JW 2/1/2001 13:04'!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left _ newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left _ left + leftOffset]].	rightFraction ifNotNil:[		right _ newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right _ right + rightOffset]].	topFraction ifNotNil:[		top _ newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top _ top + topOffset]].	bottomFraction ifNotNil:[		bottom _ newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom _ bottom + bottomOffset]].	left ifNil:[ right 			ifNil:[left _ oldBounds left. right _ oldBounds right]			ifNotNil:[left _ right - oldBounds width]].	right ifNil:[right _ left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top _ oldBounds top. bottom _ oldBounds bottom]			ifNotNil:[top _ bottom - oldBounds height]].	bottom ifNil:[bottom _ top + oldBounds height].	^(left rounded @ top rounded) corner: (right rounded @ bottom rounded)! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 13:33'!convertToCurrentVersion: varDict refStream: smartRefStrm	| className oldClassVersion |	"JW 2/1/2001"	"Since class version isn't passed in varDict, look it up through smartRefSrm."	className := varDict at: #ClassName.	oldClassVersion := (smartRefStrm structures at: className) first.	(oldClassVersion = 0) ifTrue: [ self negateBottomRightOffsets ].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 14:37'!negateBottomRightOffsets	bottomOffset ifNotNil: [ bottomOffset := bottomOffset negated ].	rightOffset ifNotNil: [ rightOffset := rightOffset negated ].! !!LayoutFrame class methodsFor: 'as yet unclassified' stamp: 'JW 2/1/2001 12:48'!classVersion	^1 "changed treatment of bottomOffset and rightOffset"! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'JW 2/1/2001 12:52'!addMorph: aMorph fullFrame: aLayoutFrame	aMorph layoutFrame: aLayoutFrame.	aMorph hResizing: #spaceFill; vResizing: #spaceFill.	self addMorph: aMorph.! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'JW 2/1/2001 13:28'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	| query frame topOffset accept cancel buttonAreaHeight |	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self layoutPolicy: ProportionalLayout new.	query _ TextMorph new contents: queryString.	query setNameTo: 'query'.	query lock.		frame _ LayoutFrame new.		frame topFraction: 0.0; topOffset: 2.		frame leftFraction: 0.5; leftOffset: (query width // 2) negated.	query layoutFrame: frame.	self addMorph: query.	topOffset _ query height + 4.	accept _ SimpleButtonMorph new target: self; color: Color veryLightGray.	accept label: 'Accept(s)'; actionSelector: #accept.	accept setNameTo: 'accept'.		frame _ LayoutFrame new.		frame rightFraction: 0.5; rightOffset: -10; bottomFraction: 1.0; bottomOffset: -2.	accept layoutFrame: frame.	self addMorph: accept.	cancel _ SimpleButtonMorph new target: self; color: Color veryLightGray.	cancel label: 'Cancel(l)'; actionSelector: #cancel.	cancel setNameTo: 'cancel'.		frame _ LayoutFrame new.		frame leftFraction: 0.5; leftOffset: 10; bottomFraction: 1.0; bottomOffset: -2.	cancel layoutFrame: frame.	self addMorph: cancel.	buttonAreaHeight _ (accept height max: cancel height) + 4.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hResizing: #spaceFill; vResizing: #spaceFill.	textPane borderWidth: 2.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane setNameTo: 'textPane'.		frame _ LayoutFrame new.		frame leftFraction: 0.0; rightFraction: 1.0; topFraction: 0.0; topOffset: topOffset; bottomFraction: 1.0; bottomOffset: buttonAreaHeight negated.	textPane layoutFrame: frame.	self addMorph: textPane.	self extent: (200 max: query width) + 4 @ (topOffset + answerHeight + 4 + buttonAreaHeight).! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'RAA 2/2/2001 05:45'!toggleAnnotationPaneSize	| handle origin aHand siblings newHeight lf prevBottom m ht |	self flag: #bob.		"CRUDE HACK to enable changing the size of the annotations pane"	owner ifNil: [^self].	siblings _ owner submorphs.	siblings size > 3 ifTrue: [^self].	siblings size < 2 ifTrue: [^self].	aHand _ self primaryHand.	origin _ aHand position.	handle _ HandleMorph new		forEachPointDo: [:newPoint |			handle removeAllMorphs.			newHeight _ (newPoint - origin) y asInteger min: owner height - 50 max: 16.			lf _ siblings last layoutFrame.			lf bottomOffset: newHeight.			prevBottom _ newHeight.			siblings size - 1 to: 1 by: -1 do: [ :index |				m _ siblings at: index.				lf _ m layoutFrame.				ht _ lf bottomOffset - lf topOffset.				lf topOffset: prevBottom.				lf bottomOffset = 0 ifFalse: [					lf bottomOffset: (prevBottom + ht).				].				prevBottom _ prevBottom + ht.			].			owner layoutChanged.		]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].		].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase pane.Click when done.' hand: aHand.	handle startStepping! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 2/2/2001 06:28'!aComment"SmartRefStream implements the 'Seeds' object storage system.  Please see the class comment.--- new changes 2 Feb 2001 ---These changes have actually been in for a little over a month, so it's time to say something about them. In the previous implementation (described further down), there needed to be a separate method of the form #convertxxxxx:yyyyyy: for each conceivable old version (xxxxx) that might be encountered. Additionally, when the current version (yyyyyy) changed, all existing methods were rendered obsolete. The new implementation requires just one method (per class, of course) of the form #convertToCurrentVersion:refStream:. This method is expected to convert any old version to the current version. Determining which old version is represented by the incoming object can be done in several ways: noticing that a current inst var is nil when it should have data, noticing that there is an older inst var name in the variable dictionary (first argument), checking kinds of objects in one or more inst vars or retrieving the classVersion of the incoming object from the ref stream. Note: ChangeSet>>checkForConversionMethods still prompts (if the preference is set) you to write/modify conversion methods when they might be needed, but its ability to do so and the need for such methods is reduced by the new single method format. For now, take the message it produces as a warning and make any conversion method changes by hand (which was mostly what you did in the past, anywat).--- older documentation ---Headlines:	To bring in an instance of a class whose instance variables have changed, you need only define one conversion method.  The method is named	convertxxxxx: aDictionary yyyyyy: aSmartRefStream.Where xxxxxx is the first letters of all the instance variables in the old instance, and yyyyy are the first letters of all instance variables in the current version of the class.  A Form has inst vars 'bits width height depth offset', so version 2 of it has version tag #bwhdo2.  If the old instance had variables 'bitMap extent depth offsetPoint textDescription', its code would be #bedot0.	Form new convertbedot0: aDictionary bwhdo3: aSmartRefStream.All you have to do is to write the method.  aDictionary has entries (old inst var name -> value), so you can fetch the old vars by name.  See SmartRefStream.catalogValues:size:.  aSmartRefStream is available so you can get at 'structures' which tells the inst vars of other old classes in this file.In the Squeak Goodies Folder, we provide an example.	Suppose there once was a file named ArrayTwoDee.  If it like Array2D in this system, but is implemented differently.  ArrayTwoDee was defined like this: (Array variableSubclass: #ArrayTwoDee instanceVariableNames: 'height '...) so it is a variable class with the array values directly in the instance.  	Array2D uses an instance var for 'contents' instead.   It has width varying most quickly, whereas the old ArrayTwoDee had height varying first.  The order of the elements must be changed.	File in the file ConvArrayTwoDee2.st.It defines SmartRefStream.arrayTwoDeeh2 to return Array2D, so we know what class to convert to.It defines Array2D.converth2:wc0: to do the actual conversion.  Look at the method.  The method 'test' has the code for actually doing the conversion:	| new2D ss |	ss _ SmartRefStream fileNamed: 'ArrayTwoDee.test.obj'.	new2D _ ss next.	ss close.	new2D class == Array2D ifFalse: [self error: 'Class conversion failed'].	(new2D atCol: 1) = #(1 2 3 4) ifFalse: [self error: 'not flipped properly'].	^ new2D	The file ArrayTwoDee.test.obj has the object data in it, and is the actual file we converted.  Note that we never had to file in the old class ArrayTwoDee.  It is never needs to be defined in our system.  	If ArrayTwoDee held an instance variable of another old class, say WeirdNumber, what form would it be in when converth2:wc0: gets run?  All objects get assigned instances in the current system before they are put into the value dictionary.  Generally, leaves of the object tree get converted first, so the values in an instance variable should be fully functioning objects in the current system."!]style[(8 94 30 213 20 255 34 474 25 359 27 2659)f1b,f1,f1cblue;,f1,f1b,f1,f1b,f1,f1b,f1,f1cblue;,f1! !!SystemWindow methodsFor: 'initialization' stamp: 'JW 1/30/2001 23:11'!addCloseBox	| frame |	closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: Preferences standardButtonFont; color: Color transparent;			actionSelector: #closeBoxHit; target: self; extent: 14@14.	frame _ LayoutFrame new.	frame leftFraction: 0; leftOffset: 4; topFraction: 0; topOffset: 1.	closeBox layoutFrame: frame.	labelArea addMorph: closeBox.! !!SystemWindow methodsFor: 'initialization' stamp: 'JW 1/31/2001 07:36'!addLabelArea	labelArea := (AlignmentMorph newSpacer: Color transparent) vResizing: #shrinkWrap;			layoutPolicy: ProportionalLayout new.	self addMorph: labelArea.! !!SystemWindow methodsFor: 'initialization' stamp: 'JW 1/30/2001 23:11'!addMenuControl"NB: for the moment, we always supply balloon help for this control, until people get used to it; eventually, we mays switch to showing this balloon help only in novice mode, as we do for the other standard window controls."	| frame |	menuBox _ IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'TinyMenu'); color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #offerWindowMenu; target: self;			setBalloonText: 'window menu'.	frame _ LayoutFrame new.	frame leftFraction: 0; leftOffset: 19; topFraction: 0; topOffset: 1.	menuBox layoutFrame: frame.	labelArea addMorph: menuBox.! !!SystemWindow methodsFor: 'initialization' stamp: 'JW 1/31/2001 07:37'!initialize	| aFont |	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	self layoutPolicy: ProportionalLayout new.	label _ StringMorph new contents: labelString;			font: Preferences windowTitleFont emphasis: 1.	"Add collapse box so #labelHeight will work"	aFont _ Preferences standardButtonFont.	collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 14@14.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addLabelArea.	labelArea addMorph: (stripes first borderWidth: 1).	labelArea addMorph: (stripes second borderWidth: 2).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	labelArea addMorph: label.	labelArea addMorph: collapseBox.	self setFramesForLabelArea.	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabelEvent: to: self.	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'initialization' stamp: 'JW 2/1/2001 13:35'!setFramesForLabelArea	"an aid to converting old instances, but then I found convertAlignment"	| frame |	frame _ LayoutFrame new.	frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.	label layoutFrame: frame.	frame _ LayoutFrame new.	frame rightFraction: 1; topFraction: 0; rightOffset: -1; topOffset: 1.	collapseBox layoutFrame: frame.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 1; topOffset: 1; rightOffset: -1.	stripes first layoutFrame: frame.	stripes first height: self labelHeight - 2.	stripes first hResizing: #spaceFill.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 3; topOffset: 3; rightOffset: -3.	stripes last layoutFrame: frame.	stripes last height: self labelHeight - 6.	stripes last hResizing: #spaceFill.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			topOffset: self labelHeight negated.	labelArea layoutFrame: frame.! !!SystemWindow methodsFor: 'geometry' stamp: 'JW 2/1/2001 13:15'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| layoutBounds box frame left right top bottom |	layoutBounds _ self layoutBounds.	paneMorphs do:[:m|		frame _ m layoutFrame.		box _ m bounds.		frame ifNotNil:[			left _ box left - layoutBounds left - (frame leftOffset ifNil:[0]).			right _ box right - layoutBounds left - (frame rightOffset ifNil:[0]).			top _ box top - layoutBounds top - (frame topOffset ifNil:[0]).			bottom _ box bottom - layoutBounds top - (frame bottomOffset ifNil:[0]).			frame leftFraction: (left / layoutBounds width asFloat).			frame rightFraction: (right / layoutBounds width asFloat).			frame topFraction: (top / layoutBounds height asFloat).			frame bottomFraction: (bottom / layoutBounds height asFloat).		].	].! !!SystemWindow methodsFor: 'panes' stamp: 'JW 1/30/2001 23:13'!addMorph: aMorph fullFrame: aLayoutFrame	super addMorph: aMorph fullFrame: aLayoutFrame.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	aMorph borderWidth: 1.	aMorph color: self paneColor.! !!SystemWindow methodsFor: 'object fileIn' stamp: 'JW 1/31/2001 08:57'!convertToCurrentVersion: varDict refStream: smartRefStrm		allowReframeHandles ifNil: [allowReframeHandles := true].	self layoutPolicy ifNil: [self convertAlignment].	labelArea ifNil: [self convertAlignment].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SystemWindow methodsFor: 'layout' stamp: 'JW 2/1/2001 13:43'!convertAlignment	| frame |	self layoutPolicy: ProportionalLayout new.	(paneMorphs == nil or:[paneRects == nil or:[paneMorphs size ~= paneRects size]]) ifFalse:[		self addLabelArea.		self putLabelItemsInLabelArea.		self setFramesForLabelArea.		paneMorphs with: paneRects do:[:m :r|			frame _ LayoutFrame new.			frame leftFraction: r left; rightFraction: r right; topFraction: r top; bottomFraction: r bottom.			m layoutFrame: frame.			m hResizing: #spaceFill; vResizing: #spaceFill.		].	].	labelArea ifNil: [		self addLabelArea.		self putLabelItemsInLabelArea.		self setFramesForLabelArea.		paneMorphs ifNotNil: [			paneMorphs do: [:m |				frame := m layoutFrame ifNil: [LayoutFrame new].				frame topOffset: (frame topOffset ifNil: [0]) - self labelHeight.				(frame bottomFraction ~= 1.0) ifTrue:					[ frame bottomOffset: (frame bottomOffset ifNil: [0]) - self labelHeight ].			].		].	].	label ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.		label layoutFrame: frame].	collapseBox ifNotNil:[		frame _ LayoutFrame new.		frame rightFraction: 1; topFraction: 0; rightOffset: -1; topOffset: 1.		collapseBox layoutFrame: frame].	stripes ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; topFraction: 0; rightFraction: 1;				leftOffset: 1; topOffset: 1; rightOffset: -1.		stripes first layoutFrame: frame.		stripes first height: self labelHeight - 2.		stripes first hResizing: #spaceFill.		frame _ LayoutFrame new.		frame leftFraction: 0; topFraction: 0; rightFraction: 1;				leftOffset: 3; topOffset: 3; rightOffset: -3.		stripes last layoutFrame: frame.		stripes last height: self labelHeight - 6.		stripes last hResizing: #spaceFill].	menuBox ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; leftOffset: 19; topFraction: 0; topOffset: 1.		menuBox layoutFrame: frame].	closeBox ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; leftOffset: 4; topFraction: 0; topOffset: 1.		closeBox layoutFrame: frame].! !!SystemWindow methodsFor: 'layout' stamp: 'JW 1/30/2001 22:45'!layoutBounds	"Bounds of pane area only."	| box |	box := super layoutBounds.	^box withTop: box top + self labelHeight! !!SystemWindow methodsFor: 'layout' stamp: 'JW 1/31/2001 08:49'!putLabelItemsInLabelArea	stripes ifNotNil: [ stripes do: [:stripe | labelArea addMorph: stripe] ].	closeBox ifNotNil: [ labelArea addMorph: closeBox ].	menuBox ifNotNil: [ labelArea addMorph: menuBox ].	collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].	label ifNotNil: [ labelArea addMorph: label ].! !"Postscript:Convert all existing LayoutFrames and SystemWindows."LayoutFrame allInstances do: [:each | each negateBottomRightOffsets].SystemWindow allSubInstances do: [:each | each convertAlignment].!