'From Squeak3.4alpha of ''11 November 2002'' [latest update: #5100] on 11 November 2002 at 3:08:50 am'!"Change Set:		directCardsRefs-swDate:			11 November 2002Author:			Scott WallaceBottleneck all references to the cards of a stack through a single getter and setter, with the ultimate intention that the card-list ultimately be able to reside outside the stack, though much else would need to change as well."!!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:12'!initialize	"Initialize the stack"	| initialBackground |	super initialize.	initialBackground _ pages first.	initialBackground extent: (640@480); beSticky.	initialBackground beAStackBackground.	self beUnsticky.	self setProperty: #controlsAtBottom toValue: true.	self privateCards: (OrderedCollection with: initialBackground currentDataInstance)."self currentHand attachMorph: StackMorph authoringPrototype"! !!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:13'!initializeWith: aCardMorph	"Install the card inside a new stack.  Make no border or controls, so I the card's look is unchanged.  Card already has a CardPlayer."		| wld |	wld _ aCardMorph world.	self initialize.	self pageSize: aCardMorph extent.	self borderWidth: 0; layoutInset: 0; color: Color transparent.	pages _ Array with: aCardMorph.	currentPage _ aCardMorph.	self privateCards: (OrderedCollection with: currentPage currentDataInstance).	currentPage beAStackBackground.	self position: aCardMorph position.	submorphs last delete.	self addMorph: currentPage.		self showPageControls: self fullControlSpecs.	wld addMorph: self.! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:06'!findText: wants	"Turn to the next card that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ self privateCards identityIndexOf: self currentCard ifAbsent: [1].	fromHereOn _ here+1 to: self privateCards size.	startToHere _ 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys _ wants allButFirst.		strings _ allText at: here.		good _ true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				strings do: [:longString |					(longString findWordStart: searchString startingAt: 1) > 0 ifTrue: [							thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer _ self valueOfProperty: #searchContainer.			oldIndex _ self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				cardNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn _ here to: self privateCards size].	"do search this page"	"other pages"	fromHereOn do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	startToHere do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:07'!getAllText	"Collect the text for each card.  Just point at strings so don't have to recopy them.  (Parallel array of urls for ID of cards.  Remote cards not working yet.)	allText = Array (cards size) of arrays (fields in it) of strings of text.	allTextUrls = Array (cards size) of urls or card numbers."	| oldUrls oldStringLists allText allTextUrls aUrl which |	self writeSingletonData.	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ self privateCards collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: self privateCards size.	self privateCards doWithIndex: [:aCard :ind | aUrl _ aCard url.  aCard isInMemory 		ifTrue: [(allText at: ind) addAll: (aCard allStringsAfter: nil).			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of cards on server may be different.  (later keep up to date?)"			"*** bug in this algorithm if delete a page?"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 01:58'!templateMatches	| template docks keys bkg |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	template _ self currentCard.	template commitCardPlayerData.	docks _ template class variableDocks.	(keys _ template asKeys) ifNil: [^ #()]. "nothing to match against"	bkg _ self currentPage.	^ self privateCards select: [:cardPlayer | 		(((cardPlayer == template) not) and: [cardPlayer costume == bkg]) 			and: [cardPlayer match: keys fields: docks]].! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:00'!writeSingletonData	"Backgrounds that have just one card, may never get their data written into a CardPlayer. Make sure we do it."	| sieve |	sieve _ IdentityDictionary new.	pages do: [:pp | sieve at: pp put: 0].	self privateCards do: [:cc | sieve at: cc costume put: (sieve at: cc costume) + 1].	sieve associationsDo: [:ass | 		ass value = 1 ifTrue:			[ass key player commitCardPlayerDataFrom: ass key]].			"If currently showing card, may be some trouble... <- tk note 5/01"! !!StackMorph methodsFor: 'background' stamp: 'sw 3/18/2002 02:07'!insertAsBackground: newPage resize: doResize	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| aName |	aName _ FillInTheBlank request: 'What should we call this new background?' initialAnswer: 'alternateBackground'.	aName isEmptyOrNil ifTrue: [^ self].	newPage beSticky.	doResize ifTrue: [newPage extent: currentPage extent].	newPage beAStackBackground.	newPage setNameTo: aName.	newPage vResizeToFit: false.	pages isEmpty		ifTrue: [pages add: newPage]		ifFalse: [pages add: newPage after: currentPage].	self privateCards add: newPage currentDataInstance after: currentPage currentDataInstance.	self nextPage.! !!StackMorph methodsFor: 'background' stamp: 'sw 3/18/2002 02:14'!sortByField: varName	"Perform a simple reordering of my cards, sorting by the given field name.  If there are multiple backgrounds, then sort the current one, placing all its cards first, followed by all others in unchanged order"	| holdCards thisClassesInstances sortedList |	holdCards _ self privateCards copy.	thisClassesInstances _ self privateCards select: [:c | c isKindOf: self currentCard class].	sortedList _ thisClassesInstances asSortedCollection:		[:a :b | (a instVarNamed: varName) asString <= (b instVarNamed: varName) asString].	sortedList _ sortedList asOrderedCollection.	holdCards removeAllFoundIn: sortedList.	self privateCards:  (sortedList asOrderedCollection, holdCards).	self goToFirstCardOfStack! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:20'!cardIndexOf: aCard	"Answer the ordinal position of aCard in the receiver's list"	^ self privateCards indexOf: aCard ifAbsent: [nil]! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:12'!cards	"Answer a list of the cards of the receiver, in order"	^ self privateCards copy! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:09'!cardsOrPages	"The turnable and printable entities"	^ self cards! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:21'!deleteAllCardsExceptThisOne	"Delete all cards except the current one"	self privateCards size <= 1 ifTrue: [^ self beep].	(self confirm: 'Really delete ', self privateCards size asString, ' card(s) and all of their data?') ifTrue:		[self privateCards: (OrderedCollection with: self currentCard)].! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:06'!deleteCard	"Delete the current card from the stack"	| aCard |	aCard _ self currentCard.	self privateCards size = 1 ifTrue: [^ self beep].	(self confirm: 'Really delete this card and all of its data?') ifTrue:		[self goToNextCardInStack.		self privateCards remove: aCard].! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:09'!deleteCard: aCard	"Delete the current card from the stack."	self privateCards size = 1 ifTrue: [^ self beep].	(aCard == self currentCard) ifTrue: [^ self deleteCard].	self privateCards remove: aCard ifAbsent: []! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:08'!goToCard	"prompt the user for an ordinal number, and use that as a basis for choosing a new card to install in the receiver"	| reply index |	reply _ FillInTheBlank request: 'Which card number? ' initialAnswer: '1'.	reply isEmptyOrNil ifTrue: [^ self].	((index _ reply asNumber) > 0 and: [index <= self privateCards size])		ifFalse: [^ self inform: 'no such card'].	self goToCard: (self privateCards at: index)! !!StackMorph methodsFor: 'card access' stamp: 'sw 11/11/2002 03:07'!goToCardNumber: aCardNumber	"Install the card whose ordinal number is provided as the current card in the stack"	self goToCard: (self privateCards atWrap: aCardNumber)! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 01:59'!goToFirstCardInBackground	"Install the initial card in the current background as the current card in the stack"	| kind |	kind _ currentPage player class baseUniclass.	self goToCard: (self privateCards detect: [:aCard | aCard isKindOf: kind] ifNone: [^ self beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:01'!goToFirstCardOfStack	"Install the initial card in the stack as the current card"	self goToCard: self privateCards first! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:02'!goToLastCardInBackground	"Install the final card in the current background as the current card"	| kind |	kind _ currentPage player class baseUniclass.	self goToCard: (self privateCards reversed detect: [:aCard | aCard isKindOf: kind] ifNone: [^ self beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:09'!goToLastCardOfStack	"Install the final card in the stack as the current card"	self goToCard: self privateCards last! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!goToNextCardInStack	"Make the card *after* the current card become the current card"	| anIndex newCard |	anIndex _ self privateCards indexOf: currentPage currentDataInstance.	newCard _ self privateCards atWrap: anIndex + 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:01'!goToPreviousCardInStack	"Install the previous card as my current one"	| anIndex newCard |	anIndex _ self privateCards indexOf: currentPage currentDataInstance.	newCard _ self privateCards atWrap: anIndex - 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!insertCardOfBackground: aBackground withDataFrom: aLine forInstanceVariables: slotNames	"Insert a new card of the given background and have it become the current card. "	| newCard |	newCard _  aBackground newCard.	self privateCards add: newCard after: self currentCard.	newCard absorbBackgroundDataFrom: aLine forInstanceVariables: slotNames.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 01:57'!makeCurrentCardFirstInStack	"Move the current card such that it becomes the first card in the stack"	| aCard |	aCard _ self currentCard.	self privateCards remove: aCard ifAbsent: [];		addFirst: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!makeCurrentCardLastInStack	"Move the current card such that it becomes the last card in the stack"	| aCard |	aCard _ self currentCard.	self privateCards remove: aCard ifAbsent: [];		addLast: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:08'!moveCardOnePositionEarlier	"Move the current card such that its ordinal position is one fewer than it formerly was.  If the current card is already the first one one in the stack, then do nothing"	| aCard aPosition |	aCard _ self currentCard.	aCard == self privateCards first ifTrue: [^ self].	aPosition _ self privateCards indexOf: aCard.	self privateCards remove: aCard;		add: aCard afterIndex: (aPosition - 2).	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:05'!moveCardOnePositionLater	"Move the current card such that its ordinal position is one greater than it formerly was.  If the current card is already the last one one in the stack, then do nothing"	| aCard aPosition privateCards |	aCard _ self currentCard.	privateCards _ self privateCards.	aCard == privateCards last ifTrue: [^ self].	aPosition _ privateCards indexOf: aCard.	privateCards remove: aCard.	privateCards add: aCard afterIndex: aPosition.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 01:56'!privateCards	"Private - answer the collection object that sits in my cards instance variable"	^ cards! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:51'!privateCards: aCollection	"Private - Make my cards be te given colllection"	cards _ aCollection! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/18/2002 02:02'!insertCardOfBackground: aBackground	"Insert a new card of the given background and have it become the current card"	| newCard |	newCard _  aBackground newCard.	self privateCards add: newCard after: self currentCard.	self goToCard: newCard! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 3/18/2002 02:20'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs."	| coll |	coll _ OrderedCollection new.	self privateCards do: [:cd | 		cd privateMorphs ifNotNil: [coll addAll: cd privateMorphs]].	^ coll! !