'From Squeak 2.3 of January 14, 1999 on 23 January 1999 at 8:36:40 pm'!"Change Set:		EventRecorderDate:			5 February 1999Author:			Leandro CanigliaThis ChangeSet introduces a mechanism for recording, saving, retrieving and playing back sequences of events in the Morphic environment.Remaining to be done:1.  Repair of the multi-hand support in morphic in the cases where events (with their hand) are not passed through to all consumers of the events.2.  Some mechainism for editing the tapes.3.  Some higher-level information to guide the execution, such as expected class of recipient of mouse clicks, or expected label of menu item clicked, etc.4.  Ultimately a generalization from detailed sensor events to higher level events such as move this morph, change this text, etc."!AlignmentMorph subclass: #EventRecorderMorph	instanceVariableNames: 'tape state time recHand playHand '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Wrappers'!HandMorph subclass: #GhostHandMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!Object subclass: #EventTape	instanceVariableNames: 'cell contents origin '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!EventRecorderMorph class methodsFor: 'instance creation' stamp: 'LC 12/23/1998 11:25'!fromFileNamed: aFileName	| file answer |	file _ FileStream oldFileNamed: aFileName.	answer _ self readFrom: file.	file close.	^ answer! !!EventRecorderMorph class methodsFor: 'instance creation' stamp: 'LC 12/23/1998 11:14'!readFrom: aStream	^ self new readFrom: aStream! !!Morph methodsFor: 'structure' stamp: 'LC 12/22/1998 12:41'!activeHand	^ (self world ifNil: [^ nil]) activeHand! !!Morph methodsFor: 'structure' stamp: 'LC 12/24/1998 17:34'!primaryHand	^ self activeHand ifNil: [self world hands first]! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'LC 12/23/1998 13:30'!addButtons	| r b w |	"record - play - stop"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #record).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #play)			width: w).	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #stop)			width: w).	self addMorphBack: r.	"read file - write file"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #writeTape).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #readTape)			width: w).	self addMorphBack: r.	"rewind - light - reset"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 centering: #center;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #rewind).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: (EllipseMorph new extent: 11 @ 11;		 name: 'light';		 color: Color green;		 borderWidth: 0).	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #reset)			width: w).	self addMorph: r! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'LC 12/21/1998 09:50'!addSlider	| slider r |	slider _ SimpleSliderMorph new extent: 100 @ 2;			 target: tape;			 actionSelector: #percent:;			 adjustToValue: 0.	r _ AlignmentMorph newRow color: color;			 inset: 0;			 centering: #center;			 hResizing: #shrinkWrap;			 vResizing: #rigid;			 height: 24.	r addMorphBack: slider.	self addMorphBack: r! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'LC 12/20/1998 11:25'!buttonFor: aSymbol 	^ SimpleButtonMorph new target: self;	 label: aSymbol asString;	 actionSelector: aSymbol! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'LC 12/21/1998 10:11'!initialize	self stopStepping.	self reset.	super initialize.	borderWidth _ 2.	borderColor _ #raised.	color _ Color red.	orientation _ #vertical.	centering _ #center.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 2.	minCellSize _ 4.	self addButtons.	"	not implemented yet	self addSlider	"	! !!EventRecorderMorph methodsFor: 'commands' stamp: 'LC 12/21/1998 09:52'!nextTrack	tape nextTrack! !!EventRecorderMorph methodsFor: 'commands' stamp: 'r++ 1/23/1999 18:12'!play	self stop.	self world ifNil: [^ self stop].	playHand _ GhostHandMorph new.	self world addHand: playHand.	playHand newKeyboardFocus: self world.	playHand userInitials: 'play'.	tape nextTrack.	tape atEnd		ifTrue: [self stop]		ifFalse:			[state _ #play.			self light color: Color yellow.			self start]! !!EventRecorderMorph methodsFor: 'commands' stamp: 'LC 12/21/1998 09:52'!prevTrack	tape prevTrack! !!EventRecorderMorph methodsFor: 'commands' stamp: 'LC 12/24/1998 13:31'!record	self world isNil ifTrue: [^ self].	self record: self activeHand! !!EventRecorderMorph methodsFor: 'commands' stamp: 'r++ 1/23/1999 18:13'!record: aHand	state _ #record.	self light color: Color red.	recHand _ aHand.	time _ Time millisecondClockValue.	aHand newKeyboardFocus: self world.	aHand startReportingEventsTo: self! !!EventRecorderMorph methodsFor: 'commands' stamp: 'LC 12/21/1998 10:59'!reset	self stop.	tape _ EventTape new! !!EventRecorderMorph methodsFor: 'commands' stamp: 'LC 12/20/1998 12:48'!rewind	tape rewind! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/23/1998 12:48'!button: label 	^ self allMorphs		detect: [:one | (one isKindOf: SimpleButtonMorph)				and: [one label = label]]		ifNone: []! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/21/1998 10:21'!light	self allMorphs do: [:each | each knownName = 'light' ifTrue: [^ each]].	^ EllipseMorph new extent: 11 @ 11! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 15:54'!playHand	^ playHand! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 15:54'!playHand: aHandMorph	playHand _ aHandMorph! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 15:53'!recHand	^ recHand! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 15:54'!recHand: aHandMorph	recHand _ aHandMorph! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/26/1998 12:58'!recTime	| copy ms cell stream |	copy _ tape copy.	ms _ 0.	[copy atEnd]		whileFalse: 			[cell _ copy read.			cell ifNotNil: [ms _ ms + cell key].			copy forward].	stream _ ReadWriteStream with: ''.	(Time fromSeconds: ms // 1000) print24: true on: stream.	^ stream contents! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 12:46'!state	^ state! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/21/1998 09:55'!tape	^ tape! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/20/1998 12:47'!tape: aTape	tape _ aTape! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'LC 12/26/1998 13:31'!time	^ time! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'LC 12/26/1998 01:35'!handleEvent: anEvent 	| t cell lastEvt |	anEvent hand == recHand ifFalse: [^ self].	state == #record ifFalse: [^ self].	t _ Time millisecondClockValue.	tape atLeftEnd ifFalse:		[tape cell: tape cell - 1.		cell _ tape read.		tape cell: tape cell + 1.		lastEvt _ cell isNil ifFalse: [cell value].		anEvent = lastEvt ifTrue: [^ self]].	tape write: t - time -> anEvent.	tape forward.	time _ t.! !!EventRecorderMorph methodsFor: 'stepping' stamp: 'LC 12/22/1998 11:56'!privatePlayBack	| evt w |	evt _ tape read value.	(w _ playHand world) activeHand: playHand.	evt setHand: playHand.	playHand handleEvent: evt.	w activeHand: nil! !!EventRecorderMorph methodsFor: 'stepping' stamp: 'LC 12/21/1998 22:33'!step	| evt doubleClick |	"Play back the next event"	playHand ifNil: [^ self].	tape read ifNil: [^ self].	self privatePlayBack.	tape atEnd ifTrue: [^ self].	doubleClick _ self checkForDoubleClick.	tape forward.	"Special double click support"	doubleClick		ifTrue: [			[self privatePlayBack.			evt _ tape read value.			tape forward.			evt isMouseDown] whileFalse]! !!EventRecorderMorph methodsFor: 'stepping' stamp: 'LC 12/20/1998 21:37'!stepTime	^ (tape read		ifNil: 			[self stop.			^ 1000]) key! !!EventRecorderMorph methodsFor: 'stepping' stamp: 'LC 12/21/1998 19:57'!stop	| w eraser |	super stop.	state _ nil.	self light color: Color green.	w _ self world ifNil: [^ self].	recHand ifNotNil: [recHand stopReportingEventsTo: self].	(w hands includes: playHand)		ifTrue: 			[playHand userInitials: ''.			w removeHand: playHand.			playHand delete.			eraser _ Morph new color: w color;					 bounds: playHand fullBounds.			w addMorph: eraser.			eraser delete]! !!EventRecorderMorph methodsFor: 'stepping' stamp: 'LC 12/20/1998 13:22'!wantsSteps	^ false! !!EventRecorderMorph methodsFor: 'double click support' stamp: 'LC 12/22/1998 10:31'!checkForDoubleClick	"Since the play back slows down the events,	double clicks must be detected ahead."	| evt delta pos clickPos t cell mouseUp answer |	evt _ (tape read ifNil: [^ false]) value.	evt isMouseDown ifFalse: [^ false].	delta _ HandMorph doubleClickTime.	pos _ tape cell.	clickPos _ evt cursorPoint.	mouseUp _ false.	answer _ false.	t _ 0.	[tape atEnd not	 and: [(cell _ tape forward read) notNil	 and: [(t _ t + cell key) < delta	 and: [(clickPos - (evt _ cell value) cursorPoint) r <= 15	 and: [answer not]]]]]		whileTrue:			[mouseUp				ifFalse: [mouseUp _ evt isMouseUp]				ifTrue: [answer _ evt isMouseDown]].	tape cell: pos.	^ answer! !!EventRecorderMorph methodsFor: 'printing' stamp: 'LC 12/23/1998 10:46'!storeOn: aStream	| cell copy |	copy _ tape copy.	copy rewind.	[copy atEnd]		whileFalse:			[cell _ copy read.			cell isNil				ifTrue: [aStream cr]				ifFalse:					[cell key storeOn: aStream.					aStream space.					cell value storeOn: aStream].			aStream cr.			copy forward]			! !!EventRecorderMorph methodsFor: 'private' stamp: 'LC 12/23/1998 12:14'!readFrom: aStream	"Private"	| cr t evt |	cr _ Character cr.	[aStream atEnd]		whileFalse:			[(aStream peekFor: cr)				ifTrue: [tape write: nil]				ifFalse:					[t _ Integer readFrom: aStream.					[aStream peek isLetter] whileFalse: [aStream next].					evt _ MorphicEvent readFrom: aStream.					aStream upTo: cr.					tape write: t -> evt].			tape forward]! !!EventRecorderMorph methodsFor: 'file out' stamp: 'LC 12/24/1998 17:44'!readTape	(Smalltalk at: #RequestBoxMorph)		ifNotNil: [RequestBoxMorph				request: 'Tape file name'				respondTo: self				selector: #readTape:]		ifNil: [self readTape: (FillInTheBlankMorph request: 'Tape file name')]! !!EventRecorderMorph methodsFor: 'file out' stamp: 'LC 12/23/1998 12:54'!readTape: fileName 	| file |	(FileStream isAFileNamed: fileName)		ifFalse: [^ nil].	self reset.	file _ FileStream oldFileNamed: fileName.	self readFrom: file.	file close! !!EventRecorderMorph methodsFor: 'file out' stamp: 'LC 12/23/1998 13:15'!writeFileNamed: fileName	| file |	file _ FileStream newFileNamed: fileName.	self storeOn: file.	file close.	^ file name! !!EventRecorderMorph methodsFor: 'file out' stamp: 'LC 12/24/1998 17:46'!writeTape	| args b |	args _ (b _ self button: 'writeTape') isNil				ifTrue: [#()]				ifFalse: [b arguments].	(args size > 0 and: [args first size > 0])		ifTrue: [args first.				self writeTape: args first]		ifFalse: [(Smalltalk at: #RequestBoxMorph)				ifNotNil: [RequestBoxMorph						request: 'Tape to write'						respondTo: self						selector: #writeTape:]				ifNil: [self writeTape: (FillInTheBlankMorph request: 'Tape to write')]]! !!EventRecorderMorph methodsFor: 'file out' stamp: 'LC 12/26/1998 13:26'!writeTape: fileName 	| b name |	name _ self writeFileNamed: fileName.	(b _ self button: 'writeTape') ifNotNil: [b arguments: (Array with: name)].! !!HandMorph methodsFor: 'event dispatching' stamp: 'LC 12/20/1998 22:11'!handleEvent: evt		eventSubscribers do: [:m | m handleEvent: evt]."--"	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]]."--"	lastEvent _ evt.	temporaryCursor ifNotNil: [		evt setCursorPoint: evt cursorPoint].	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		evt isMouseDown ifTrue: [ ^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue: [		keyboardFocus ifNotNil: [keyboardFocus keyStroke: evt].		^ self].! !!HandMorph methodsFor: 'event dispatching' stamp: 'LC 12/20/1998 18:52'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!GhostHandMorph methodsFor: 'event dispatching' stamp: 'LC 12/20/1998 17:29'!processEvents	! !!GhostHandMorph methodsFor: 'copying' stamp: 'LC 12/23/1998 13:26'!veryDeepCopyWith: deepCopier	^ self copy! !!GhostHandMorph methodsFor: 'halos' stamp: 'LC 12/31/1998 12:42'!addHalo	| halo |	argument isNil		ifTrue: 			[halo _ HaloMorph new bounds: self fullBoundsInWorld.			self world addMorphFront: halo.			halo target: self.			halo startStepping]		ifFalse: [argument addHalo]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'LC 12/22/1998 12:43'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self activeHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!EventTape commentStamp: '<historical>' prior: 0!My instances are recording tapes. A tape has cells and a read/write head. The head acts on the current cell by reading or writing objects on that cell. The tape can grow to the right and to the left. !!EventTape methodsFor: 'private' stamp: 'LC 11/22/97 00:40'!contents: aCollection 	contents _ aCollection isEmpty				ifTrue: [aCollection species with: nil]				ifFalse: [aCollection]! !!EventTape methodsFor: 'private' stamp: 'LC 12/21/1998 21:48'!index	^ cell + origin! !!EventTape methodsFor: 'private' stamp: 'LC 12/21/1998 21:49'!index: anInteger 	cell _ anInteger - origin! !!EventTape methodsFor: 'printing' stamp: 'LC 12/21/1998 21:51'!printOn: aStream 	| first start stop |	aStream nextPut: $(.	first _ true.	start _ self index - 1 max: 1.	start > 1 ifTrue: [aStream nextPutAll: '... '].	stop _ self index + 1 min: contents size.	start to: stop do: 		[:each | 		first			ifTrue: [first _ false]			ifFalse: [aStream nextPut: $ ].		each = self index			ifTrue: 				[aStream nextPut: $[.				(contents at: each)					printOn: aStream.				aStream nextPut: $]]			ifFalse: [(contents at: each)					printOn: aStream]].	stop < contents size ifTrue: [aStream nextPutAll: ' ...'].	aStream nextPut: $)! !!EventTape methodsFor: 'initialization' stamp: 'LC 12/21/1998 21:50'!initialize	self contents: OrderedCollection new.	origin _ 1.	cell _ 0! !!EventTape methodsFor: 'testing' stamp: 'LC 12/21/1998 22:12'!atEnd	^ contents size = self index! !!EventTape methodsFor: 'testing' stamp: 'LC 12/21/1998 22:04'!atLeftEnd	^ self index = 1! !!EventTape methodsFor: 'testing' stamp: 'LC 12/21/1998 21:52'!atRightEnd	^ self atEnd! !!EventTape methodsFor: 'accessing' stamp: 'LC 12/21/1998 21:53'!cell	^ cell! !!EventTape methodsFor: 'accessing' stamp: 'LC 12/21/1998 21:54'!cell: anInteger 	cell _ anInteger! !!EventTape methodsFor: 'accessing' stamp: 'LC 12/23/1998 10:34'!contents	^ contents! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/21/1998 22:07'!backward	self atLeftEnd		ifTrue: 			[contents addFirst: nil.			origin _ origin + 1].	cell _ cell - 1! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/21/1998 22:06'!forward	self index = contents size ifTrue: [contents add: nil].	cell _ cell + 1! !!EventTape methodsFor: 'head movement'!move: anInteger	anInteger = 0 ifTrue: [^ self].	anInteger > 0		ifTrue: [anInteger timesRepeat: [self forward]]		ifFalse: [anInteger negated timesRepeat: [self backward]]! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/20/1998 12:39'!nextTrack	[self atEnd not and: [self read isNil]]		whileTrue: [cell _ cell + 1]! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/21/1998 21:57'!percent	^ self index / contents size! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/21/1998 21:57'!percent: percent	^ self index: (percent * contents size) asInteger! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/21/1998 21:46'!prevTrack	[self atLeftEnd not and: [self read notNil]]		whileTrue: [cell _ cell - 1].	self nextTrack! !!EventTape methodsFor: 'head movement' stamp: 'LC 12/26/1998 13:30'!rewind	self index: 1! !!EventTape methodsFor: 'read/write' stamp: 'LC 12/21/1998 22:06'!read	^ contents at: self index! !!EventTape methodsFor: 'read/write' stamp: 'LC 12/21/1998 22:13'!write: anObject 	contents at: self index put: anObject! !!EventTape methodsFor: 'copying' stamp: 'LC 12/23/1998 10:41'!copy	^ (self class on: contents) rewind! !!EventTape class methodsFor: 'instance creation' stamp: 'LC 12/20/1998 11:38'!new	^ super new initialize! !!EventTape class methodsFor: 'instance creation' stamp: 'LC 12/20/1998 11:38'!on: aCollection	^self new contents: aCollection! !!FileList methodsFor: 'file list menu' stamp: 'di 1/31/1999 11:03'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'tape') | (suffix = '*') ifTrue:		[labels add: 'open for playback'.		selectors add: #openTapeFromFile].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels add: 'view decompressed'.		selectors add: #viewGZipContents].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 1/31/1999 11:05'!openTapeFromFile	"Open an eventRecorder tape for playback." 	(EventRecorderMorph new readTape: self fullName) rewind openInWorld! !