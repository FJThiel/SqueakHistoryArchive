'From Squeak2.8alpha of 16 February 2000 [latest update: #2066] on 4 May 2000 at 7:17:11 pm'!"Change Set:		VRMLExtensionsDate:			4 May 2000Author:			Andreas RaabA number of modifications to the VRML stuff. Mainly intended to fix a number of problems but also a preparation for an (optional) switch to all the real VRML classes (I might do this under certain circumstances)."!B3DInplaceArray variableWordSubclass: #B3DRotationArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Arrays'!B3DInplaceArray variableWordSubclass: #B3DVector2Array	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Arrays'!Object subclass: #VRMLBaseNode	instanceVariableNames: 'myEvents '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-VRML BaseNodes'!VRMLBaseNode subclass: #VRMLClassNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-VRML BaseNodes'!VRMLClassNode subclass: #VRMLCompositeNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-VRML BaseNodes'!VRMLClassNode subclass: #VRMLInterpolatorNode	instanceVariableNames: 'fraction value lastIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-VRML BaseNodes'!Object subclass: #VRMLNodeParser	instanceVariableNames: 'nodeTypes scene protoList infoBar defName '	classVariableNames: 'VRMLFieldTypes VRMLRuntimeFieldTypes VRMLScriptFieldTypes VRMLStatements '	poolDictionaries: ''	category: 'Balloon3D-VRML Definition'!!B3DColor4 methodsFor: 'converting' stamp: 'ar 5/4/2000 17:59'!asB3DColor	^self! !!B3DRotationArray class methodsFor: 'instance creation' stamp: 'ar 5/4/2000 15:45'!contentsClass	^B3DRotation! !!B3DVector2 methodsFor: 'initialize' stamp: 'ar 5/4/2000 15:50'!x: uValue y: vValue	self x: uValue.	self y: vValue.! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 5/4/2000 16:00'!x: aFloat	self floatAt: 1 put: aFloat! !!B3DVector2 methodsFor: 'accessing' stamp: 'ar 5/4/2000 16:00'!y: aFloat	self floatAt: 2 put: aFloat! !!B3DVector2 class methodsFor: 'instance creation' stamp: 'ar 5/4/2000 15:49'!x: uValue y: vValue	^self new x: uValue y: vValue! !!B3DVector2Array class methodsFor: 'instance creation' stamp: 'ar 5/4/2000 15:59'!contentsClass	^B3DVector2! !!VRMLBaseNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 19:06'!attributeValueNamed: aString	"Return the value of the given attribute string as defined in the receiver.	Note: When switching to a full class representation for VRML objects we can	get rid of this and use actual accessors."	| attr |	attr _ (self attributeNamed: aString) ifNil:[^nil].	^self getAttributeValue: attr! !!VRMLBaseNode methodsFor: 'private' stamp: 'ar 5/4/2000 18:14'!myEvents	^myEvents! !!VRMLBaseNode methodsFor: 'private' stamp: 'ar 5/4/2000 18:14'!myEvents: eventList	myEvents _ eventList! !!VRMLClassNode methodsFor: 'initialize' stamp: 'ar 5/4/2000 15:21'!fromSpec: aNodeSpec	aNodeSpec attributes do:[:attr|		attr isEvent ifFalse:[attr setValue: attr value in: self]].! !!VRMLClassNode methodsFor: 'attributes-generic' stamp: 'ar 5/4/2000 17:35'!attributeNamed: aString	^self nodeSpec attributeNamed: aString.! !!VRMLClassNode methodsFor: 'attributes-generic' stamp: 'ar 5/4/2000 15:17'!getAttributeValue: aVRMLNodeAttribute	aVRMLNodeAttribute isEvent		ifTrue:[^nil]		ifFalse:[^self perform: aVRMLNodeAttribute getterName]! !!VRMLClassNode methodsFor: 'attributes-generic' stamp: 'ar 5/4/2000 15:15'!setAttribute: aVRMLNodeAttribute toValue: newValue	self perform: aVRMLNodeAttribute setterName with: newValue! !!VRMLClassNode class methodsFor: 'accessing' stamp: 'ar 5/4/2000 18:43'!compileAccessors	"Compile all accessors for the receiver"	| varName typeName |	(self nodeSpec attributes select:[:attr| attr isEvent not]) do:[:attr|		varName _ (attr name copyReplaceAll:'_' with: '').		typeName _ (attr type copyReplaceAll:'_' with: '').		typeName first isUppercase ifFalse:[			typeName _ typeName first asUppercase asString, 				(typeName copyFrom: 2 to: typeName size)].		self compile:(String streamContents:[:s|			s nextPutAll: varName; crtab.			s nextPutAll: '"This is an automatically generated accessor"'; crtab.			s nextPutAll:'^'; nextPutAll: varName])			classified: 'accessing'.		self compile: (String streamContents:[:s|			s nextPutAll: varName; nextPutAll:': a'; nextPutAll: typeName; crtab.			s nextPutAll: '"This is an automatically generated accessor"'; crtab.			(attr isExposedField and:[attr isSingleField]) ifTrue:[				s nextPutAll: varName; nextPutAll:' = a'; nextPutAll: typeName; 					nextPutAll:' ifFalse:['; crtab: 2].			s nextPutAll: varName; nextPutAll:' := a'; nextPutAll: typeName; nextPutAll:'.'.			attr isExposedField ifTrue:[				s crtab.				attr isSingleField ifTrue:[s tab].				s nextPutAll: 'self trigger: #'; print: (attr name,'_changed');						nextPutAll: ' with: '; nextPutAll: varName.				attr isSingleField ifTrue:[s nextPutAll:']']]])			classified: 'accessing'.	].! !!VRMLClassNode class methodsFor: 'accessing' stamp: 'ar 5/4/2000 18:35'!compileEnumerator	"Compile #nodesDo: for the receiver"	| varName typeName s |	s _ WriteStream on: (String new: 100).	s nextPutAll: 'nodesDo: aBlock'.	s crtab; nextPutAll:'"This method was automatically generated"'.	s crtab; nextPutAll:'aBlock value: self.'.	(self nodeSpec attributes select:[:attr| attr isEvent not]) do:[:attr|		varName _ (attr name copyReplaceAll:'_' with: '').		typeName _ attr type.		(typeName = 'SFNode') ifTrue:[			s crtab; nextPutAll: varName; nextPutAll:' ifNotNil:['; nextPutAll: varName;					nextPutAll:' nodesDo: aBlock].'.		].		(typeName = 'MFNode') ifTrue:[			s crtab; nextPutAll: varName; nextPutAll:' ifNotNil:['; nextPutAll: varName;				nextPutAll:' do:[:doNode| doNode nodesDo: aBlock]].'.		].	].	self compile: s contents classified: 'enumerating'.! !!VRMLCompositeNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 18:22'!addChildren: childList	self children: (self children, childList).! !!VRMLCompositeNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 18:22'!removeChildren: childList	self children: (self children reject:[:child| childList includes: child]).! !!VRMLGenericNode methodsFor: 'attributes' stamp: 'ar 5/4/2000 19:13'!getAttributeValue: aVRMLAttribute	^(self attributes at: aVRMLAttribute ifAbsent:[aVRMLAttribute]) value! !!VRMLInterpolatorNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 16:51'!fraction	^fraction! !!VRMLInterpolatorNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 17:07'!fraction: newFraction	"Do my interpolation based on the new values"	| keys values index delta newValue |	fraction = newFraction ifTrue:[^self].	keys _ self key.	values _ self keyValue.	newFraction <= keys first ifTrue:[^self value: values first].	newFraction >= keys last ifTrue:[^self value: values first].	index _ self largerIndexOf: newFraction in: keys.	delta _ newFraction - (keys at: index-1).	newValue _ (values at: index-1) interpolateTo: (values at: index) at: delta.	fraction _ newFraction.	self value: newValue.! !!VRMLInterpolatorNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 16:51'!value	^value! !!VRMLInterpolatorNode methodsFor: 'accessing' stamp: 'ar 5/4/2000 16:51'!value: newValue	value _ newValue.	self trigger: #'value_changed' with: newValue.! !!VRMLInterpolatorNode methodsFor: 'private' stamp: 'ar 5/4/2000 17:22'!largerIndexOf: aFraction in: anArray	"Find the index of the given fraction in anArray"	| index low high |	(lastIndex == nil) ifTrue:[		"Search entire array"		low _ 1.		high _ anArray size.	] ifFalse:[		"Unroll the first test for a quick hit of small fractional changes"		(anArray at: lastIndex) >= aFraction ifTrue:[			(anArray at: lastIndex - 1) <= aFraction 				ifTrue:[^lastIndex]				ifFalse:[	high _ lastIndex-1]. "No need to look further"		] ifFalse:[			low _ lastIndex. "No need to look further"		].	].			[index _ high + low // 2.	low > high]		whileFalse:[			(anArray at: index) <= aFraction				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]].	^lastIndex _ low! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 5/4/2000 15:17'!getterName	^self selectorString asSymbol! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 5/4/2000 15:09'!selectorString	^self name copyReplaceAll:'_' with: ''! !!VRMLNodeAttribute methodsFor: 'accessing' stamp: 'ar 5/4/2000 15:09'!setterName	^(self selectorString copyWith: $:) asSymbol! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 5/4/2000 15:18'!isEvent	^'event*' match: self attrClass! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 5/4/2000 16:37'!isExposedField	^self attrClass = 'exposedField'! !!VRMLNodeAttribute methodsFor: 'testing' stamp: 'ar 5/4/2000 18:46'!isSingleField	^self type first = $S! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 5/4/2000 14:43'!defineNode: aNode	"Define aNode if necessary"	defName ifNotNil:[		scene defineNode: defName value: aNode.		defName _ nil]! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 5/4/2000 14:42'!parseDEF: aVRMLStream	| nodeName nodeValue |	aVRMLStream skipSeparators.	defName := nodeName := aVRMLStream readName.	nodeValue := self parseStatement: aVRMLStream.	defName := nil.	^VRMLDefNode name: nodeName node: nodeValue! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 5/4/2000 13:58'!parseStatement: token from: aVRMLStream	(VRMLStatements includesKey: token) ifTrue:[		^self dispatchOn: token in: VRMLStatements with: aVRMLStream ifNone:[]].	self error:'Unkown token'.! !!VRMLNodeParser methodsFor: 'testing' stamp: 'ar 5/4/2000 13:59'!isStatement: token	^VRMLStatements includesKey: token! !!VRMLNodeParser methodsFor: 'testing' stamp: 'ar 5/4/2000 14:42'!needsDef	^defName notNil! !!VRMLNodeParser class methodsFor: 'class initialization' stamp: 'ar 5/4/2000 16:00'!initFields	"VRMLNodeParser initialize"	| selString multi typeString singleString multiString selector sym type |	VRMLFieldTypes := Dictionary new.#((MFColor B3DColor4Array)(MFFloat B3DFloatArray)(MFInt32 IntegerArray)(MFNode Array)(MFRotation B3DRotationArray)(MFString Array)(MFTime Array)(MFVec2f B3DVector2Array)(MFVec3f B3DVector3Array)(SFBool)(SFColor) (SFFloat)(SFImage)(SFInt32)(SFNode)(SFRotation)(SFString)(SFTime)(SFVec2f)(SFVec3f)) do:[:spec|	sym _ spec first.	type _ spec last.	multi := sym first = $M.	typeString := sym copyFrom: 3 to: sym size.	singleString := 'readSingleField', typeString, 'From:'.	multiString := 'readMultiField', typeString, 'From:'.	selString := multi ifTrue:[multiString] ifFalse:[singleString].	selector := selString asSymbol.	VRMLFieldTypes at: sym asString put: selector.	(self includesSelector: selector) ifFalse:[		multi			ifTrue:[self compileMultiFieldMethod: selString single: singleString type: type]			ifFalse:[self compileSingleFieldMethod: selString type: typeString]].]. ! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 5/4/2000 15:12'!buildClasses	"VRMLNodeParser buildClasses"	Utilities informUserDuring:[:bar|	VRMLNodeSpec currentSpecs do:[:nodeSpec|		bar value: 'Compiling ', nodeSpec name.		(nodeSpec attributeNamed: 'children') notNil ifTrue:[			self compileCompositeNode: nodeSpec.		] ifFalse:[		('*Light*' match: nodeSpec name ) ifTrue:[			self compileLightNode: nodeSpec.		] ifFalse:[		('*Interpolator*' match: nodeSpec name) ifTrue:[			self compileInterpolatorNode: nodeSpec.		] ifFalse:[		('*Sensor*' match: nodeSpec name) ifTrue:[			self compileSensorNode: nodeSpec.		] ifFalse:[			self compileSimpleNode: nodeSpec.		]]]]].	].! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 5/4/2000 18:23'!compileCompositeNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLCompositeNode category:'VRML-Nodes-Composite'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 5/4/2000 16:52'!compileInterpolatorNode: nodeSpec	^self compileNode: nodeSpec superClass: VRMLInterpolatorNode category:'VRML-Nodes-Interpolators'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 5/4/2000 15:54'!compileMultiFieldMethod: selString single: singleString type: mfFieldType	| source |	source := String streamContents:[:s|		s nextPutAll: selString.		s nextPutAll:' aVRMLStream'.		s nextPutAll:(('	"This method was automatically generated"	| fields |	fields := WriteStream on: ($MF_FIELD_TYPE$ new: 100).	aVRMLStream skipSeparators.	aVRMLStream backup.	(aVRMLStream nextChar = $[) ifFalse:[		aVRMLStream restore.		fields nextPut: (self $READSINGLE$ aVRMLStream).		^fields contents].	aVRMLStream discard.	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $] ] whileFalse:[		fields nextPut: (self $READSINGLE$ aVRMLStream).	].	aVRMLStream nextChar.	^fields contents.' 		copyReplaceAll:'$READSINGLE$' with: singleString)		copyReplaceAll:'$MF_FIELD_TYPE$' with: mfFieldType).	].	self compile: source classified:'multi field parsing'! !!VRMLNodeParser class methodsFor: 'private' stamp: 'ar 5/4/2000 18:25'!compileNode: nodeSpec superClass: aClass category: aString	| varNames theClass |	(aClass includesBehavior: VRMLClassNode) ifFalse:[^self halt].	varNames := WriteStream on: (String new).	nodeSpec attributes do:[:attr|		('event*' match: attr attrClass ) ifFalse:[			varNames nextPutAll: (attr name copyReplaceAll:'_' with: '').			varNames space.		].	].	theClass := aClass subclass: (self vrmlClassNameFor: nodeSpec name) asSymbol		instanceVariableNames: varNames contents		classVariableNames: ''		poolDictionaries: ''		category: aString.	theClass nodeSpec: nodeSpec.	theClass compileAccessors.	theClass compileEnumerator.	nodeSpec vrmlClass: theClass.! !!VRMLNodeSpec methodsFor: 'reading' stamp: 'ar 5/4/2000 13:57'!readAttributeFrom: aVRMLStream in: aParser	"Read an attribute"	| attrName attrSpec attrValue |	attrName := aVRMLStream readName.	attrSpec := self attributeNamed: attrName.	attrSpec notNil ifTrue:[		attrValue := attrSpec readFrom: aVRMLStream in: aParser.		^attrSpec -> attrValue].	(aParser isStatement: attrName) ifTrue:[		aParser parseStatement: attrName from: aVRMLStream.		^nil].	self warn:'Unknown attribute: ', attrName.	aVRMLStream skip: 1.	^nil! !!VRMLNodeSpec methodsFor: 'reading' stamp: 'ar 5/4/2000 14:44'!readFrom: aVRMLStream in: aParser	"Read a node"	| assoc vrmlInstance |	vrmlInstance := self newInstance.	aParser defineNode: vrmlInstance.	aVRMLStream skipSeparators.	aVRMLStream nextChar = ${ ifFalse:[^self error:'Node definition expected'].	[aVRMLStream skipSeparators.	aVRMLStream peekChar = $}] whileFalse:[		assoc := self readAttributeFrom: aVRMLStream in: aParser.		assoc ifNotNil:[assoc key setValue: assoc value in: vrmlInstance].	].	aVRMLStream nextChar.	^vrmlInstance! !!VRMLNodeSpec methodsFor: 'debug' stamp: 'ar 5/4/2000 13:48'!warn: aString	self inform: aString.! !!VRMLScene methodsFor: 'actions' stamp: 'ar 5/4/2000 16:35'!eventSelectorFor: aString	"Make an ST80 type message from aString"	| selector |	(aString beginsWith: 'set_') ifTrue:[		selector _ aString copyFrom: 5 to: aString size.	] ifFalse:[		selector _ aString.	].	selector _ selector copyReplaceAll:'_' with: ''.	selector _ selector copyWith: $:.	^selector asSymbol! !!VRMLScene methodsFor: 'actions' stamp: 'ar 5/4/2000 16:41'!routeFrom: fromNode event: outEventName to: toNode event: inEventName	(self definedNode: fromNode)		when: outEventName asSymbol		send: (self eventSelectorFor: inEventName)		to: (self definedNode: toNode).! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 5/4/2000 15:48'!readColor	^self readFloatVector: 3 do:[:array|		B3DColor4 r: (array at: 1) g: (array at: 2) b: (array at: 3) a: 1.0	].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 5/4/2000 15:49'!readRotation	^self readFloatVector: 4 do:[:array|		B3DRotation radiansAngle: (array at: 4) axis: 			(B3DVector3 x: (array at: 1) y: (array at: 2) z: (array at: 3))	].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 5/4/2000 15:50'!readVec2f	^self readFloatVector: 2 do:[:array| B3DVector2 x: (array at: 1) y: (array at: 2)].! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 5/4/2000 15:50'!readVec3f	^self readFloatVector: 3 do:[:array| 		B3DVector3 x: (array at: 1) y: (array at: 2) z: (array at: 3)].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:02'!doAppearance: node	| attr |	(attr _ node attributeValueNamed: 'material') notNil		ifTrue:[attr doWith: self].	(attr _ node attributeValueNamed: 'texture') notNil		ifTrue:[attr doWith: self].	(attr _ node attributeValueNamed: 'textureTransform') notNil		ifTrue:[attr doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 18:58'!doBox: node	| size box |	size _ (node attributeValueNamed:'size').	box _ B3DIndexedMesh vrml97Box.	self createActorFor: box defaultName:'box'.	currentActor resizeRightNow: size first @ size second @ size third undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 18:58'!doColor: node	| colors |	colors _ (node attributeValueNamed: 'color').	attributes at: #currentColors put: (colors collect:[:c| c asB3DColor])! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 18:58'!doCone: node	| radius height doSide doBottom cone |	radius _ (node attributeValueNamed:'bottomRadius').	height _ (node attributeValueNamed:'height').	doSide _ (node attributeValueNamed:'side').	doBottom _ (node attributeValueNamed:'bottom').	cone _ B3DIndexedMesh vrml97Cone: doSide bottom: doBottom.	self createActorFor: cone defaultName:'cone'.	currentActor resizeRightNow: radius @ height @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:02'!doCoordinate: node	| attr points |	(attr _ node attributeValueNamed: 'point') notNil		ifTrue:[points _ self mfVec3fFrom: attr].	points == nil		ifTrue:[attributes removeKey: #currentPoints]		ifFalse:[attributes at: #currentPoints put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 18:59'!doCylinder: node	| radius height doSide doBottom doTop cylinder |	radius _ (node attributeValueNamed:'radius').	height _ (node attributeValueNamed:'height').	doSide _ (node attributeValueNamed:'side').	doBottom _ (node attributeValueNamed:'bottom').	doTop _ (node attributeValueNamed:'top').	cylinder _ B3DIndexedMesh vrml97Cylinder: doSide bottom: doBottom top: doTop.	self createActorFor: cylinder defaultName:'cylinder'.	currentActor resizeRightNow: radius @ height @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 18:59'!doDirectionalLight: node	| ambientIntensity intensity color on material light dir |	ambientIntensity _ (node attributeValueNamed:'ambientIntensity').	intensity _ (node attributeValueNamed: 'intensity').	color _ (node attributeValueNamed: 'color').	dir _ self positionFrom: (node attributeValueNamed:'direction').	on _ (node attributeValueNamed:'on').	material _ B3DMaterialColor new.	material ambientPart: (color * ambientIntensity).	material diffusePart: (color * intensity).	light _ myWonderland makeLight: (Wonderland wonderlandConstants at: 'directional').	light lightColor: material.	light setDirection: dir.	currentActor ifNotNil:[light reparentTo: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doImageTexture: node	| attr texFileName tex |	"Create a new texture."	(attr _ node attributeValueNamed: 'url') notNil		ifTrue:[			texFileName _ (FileDirectory on: (FileDirectory dirPathFor: scene fileURL)) fullNameFor: attr first.			(FileDirectory default fileExists: texFileName)				ifTrue:[tex _ myWonderland makeTextureFrom: texFileName].			attributes at: #currentTexture put: tex].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doIndexedFaceSet: node	| attr faces points mesh |	attributes at: #currentPoints put: nil.	(attr _ node attributeValueNamed: 'coord') notNil		ifTrue:[attr doWith: self].	points _ attributes at: #currentPoints.	points ifNil:[^self].	(attr _ node attributeValueNamed: 'coordIndex') notNil		ifTrue:[faces _ self facesFrom: attr for: points].	faces ifNil:[^self].	mesh _ B3DSimpleMesh withAll: faces.	self assignIndexedNormals: node in: mesh.	self assignIndexedTexCoords: node in: mesh.	self assignIndexedColors: node in: mesh.	mesh _ mesh asIndexedTriangleMesh.	"Try to recycle the actors"	(currentActor == nil or:[currentActor hasMesh])		ifTrue:[self createActorFor: mesh]		ifFalse:[	currentActor setMesh: mesh.				attributes at: #currentShape put: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:00'!doLOD: node	| levels |	levels _ (node attributeValueNamed: 'level').	levels size > 0 ifTrue:[		levels last doWith: self.	].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doMaterial: node	| ambientIntensity diffuseColor emissiveColor shininess specularColor material |	ambientIntensity _ (node attributeValueNamed: 'ambientIntensity').	diffuseColor _ (node attributeValueNamed: 'diffuseColor').	emissiveColor _ (node attributeValueNamed:'emissiveColor').	shininess _ (node attributeValueNamed: 'shininess').	specularColor _ (node attributeValueNamed: 'specularColor').	"transparency _ (node attributeValueNamed:'transparency')."	material _ B3DMaterial new.	material ambientPart: (diffuseColor * ambientIntensity).	material diffusePart: diffuseColor.	material specularPart: specularColor.	material emission: emissiveColor.	material shininess: shininess.	attributes at: #currentMaterial put: material.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doNormal: node	| attr points |	(attr _ node attributeValueNamed: 'vector') notNil		ifTrue:[points _ self mfVec3fFrom: attr].	points == nil		ifTrue:[attributes removeKey: #currentNormals]		ifFalse:[attributes at: #currentNormals put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doShape: node	| attr shape |	attributes at: #currentTexture put: nil.	attributes at: #currentMaterial put: nil.	attributes at: #currentShape put: nil.	(attr _ node attributeValueNamed: 'appearance') notNil		ifTrue:[attr doWith: self].	(attr _ node attributeValueNamed: 'geometry') notNil		ifTrue:[attr doWith: self].	shape _ attributes at: #currentShape.	shape == nil ifFalse:[		shape setMaterial: (attributes at: #currentMaterial ifAbsent:[nil]).		shape setTexturePointer: (attributes at: #currentTexture ifAbsent:[nil])].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:01'!doSphere: node	| radius sphere |	radius _ (node attributeValueNamed:'radius').	sphere _ B3DIndexedMesh vrml97Sphere.	self createActorFor: sphere defaultName:'sphere'.	currentActor resizeRightNow: radius @ radius @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:01'!doSwitch: node	| choices which |	choices _ (node attributeValueNamed:'choices').	which _ (node attributeValueNamed: 'whichChoice') + 1.	(which > 0 and:[which <= choices size])		ifTrue:[(choices at: which) doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:03'!doTextureCoordinate: node	| attr points |	(attr _ node attributeValueNamed: 'point') notNil		ifTrue:[points _ self mfVec2fFrom: attr].	points == nil		ifTrue:[attributes removeKey: #currentTexCoords]		ifFalse:[attributes at: #currentTexCoords put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:04'!doTransform: node	| attr c r s sr t xform oldActor |	attr _ node attributeValueNamed: 'center'.	attr notNil ifTrue:[c _ self positionFrom: attr].	attr _ node attributeValueNamed: 'rotation'.	attr notNil ifTrue:[r _ self rotationFrom: attr].	attr _ node attributeValueNamed: 'scale'.	attr notNil ifTrue:[s _ self scaleFrom: attr].	attr _ node attributeValueNamed: 'scaleOrientation'.	attr notNil ifTrue:[sr _ self rotationFrom: attr].	attr _ node attributeValueNamed: 'translation'.	attr notNil ifTrue:[t _ self positionFrom: attr].	xform _ B3DMatrix4x4 identity.	xform translation: t+c.	xform _ xform composedWithLocal: r asMatrix4x4.	xform _ xform composedWithLocal: sr asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity scaling: s).	xform _ xform composedWithLocal: sr negated asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity translation: c negated).	oldActor _ currentActor.	currentActor _ self createActorFor: nil.	currentActor setComposite: xform.	super doTransform: node.	currentActor _ oldActor.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 5/4/2000 19:04'!doViewpoint: node	| attr pos r fov name m camera |	attr _ node attributeValueNamed: 'position'.	attr notNil ifTrue:[pos _ self positionFrom: attr].	attr _ node attributeValueNamed: 'orientation'.	attr notNil ifTrue:[r _ self rotationFrom: attr].	attr _ node attributeValueNamed: 'fieldOfView'.	attr notNil ifTrue:[fov _ attr radiansToDegrees].	attr _ node attributeValueNamed: 'description'.	attr notNil ifTrue:[name _ attr].	m _ B3DMatrix4x4 identity.	m _ m composedWithGlobal: (r asMatrix4x4).	m _ m composedWithGlobal: (B3DMatrix4x4 withOffset: pos).	(currentActor == baseActor and:[defaultCamera ~~ nil]) ifTrue:[		camera _ defaultCamera.		defaultCamera _ nil.	] ifFalse:[		camera _ myWonderland makeCameraNamed: (name ifNil:['camera']) parent: currentActor.	].	camera setComposite: m.	camera setFieldOfView: fov.! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 5/4/2000 19:01'!assignIndexedColors: node in: mesh	| attr colors colorIndex faces vertices |	attributes at: #currentColors put: nil.	(attr _ node attributeValueNamed: 'color') notNil		ifTrue:[attr doWith: self].	colors _ attributes at: #currentColors.	(colors == nil or:[colors size = 0]) ifTrue:[^self].	attr _ (node attributeValueNamed: 'colorIndex').	attr size = 0 ifTrue:[attr _ (node attributeValueNamed:'coordIndex')].	colorIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[colorIndex next = -1] whileTrue.		colorIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) color: (colors at: colorIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 5/4/2000 19:02'!assignIndexedNormals: node in: mesh	| attr normals nrmlIndex faces vertices |	attributes at: #currentNormals put: nil.	(attr _ node attributeValueNamed: 'normal') notNil		ifTrue:[attr doWith: self].	normals _ attributes at: #currentNormals.	normals == nil ifTrue:[^self].	attr _ (node attributeValueNamed: 'normalIndex').	attr size = 0 ifTrue:[attr _ (node attributeValueNamed: 'coordIndex')].	nrmlIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[nrmlIndex next = -1] whileTrue.		nrmlIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) normal: (normals at: nrmlIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 5/4/2000 19:02'!assignIndexedTexCoords: node in: mesh	| attr faces vertices texCoords texIndex |	attributes at: #currentTexCoords put: nil.	(attr _ node attributeValueNamed: 'texCoord') notNil		ifTrue:[attr doWith: self].	texCoords _ attributes at: #currentTexCoords.	texCoords == nil ifTrue:[^self].	attr _ (node attributeValueNamed: 'texCoordIndex').	attr size = 0 ifTrue:[attr _ (node attributeValueNamed:'coordIndex')].	texIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[texIndex next = -1] whileTrue.		texIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) texCoord: (texCoords at: texIndex next + 1).		].	].! !"Postscript:Remove old multi-field parsing methods and generate new ones"VRMLNodeParser removeCategory: 'multi field parsing'.VRMLNodeParser initialize.!