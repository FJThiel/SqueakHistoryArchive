'From Squeak3.7beta of ''1 April 2004'' [latest update: #5954] on 21 June 2004 at 11:31:41 am'!"Change Set:		SuppressControlKeyInBrowser-nk (v2)Date:			21 June 2004Author:			Ned Konzv2: fixed what to show in MVC.Now that we have the 'what to show' menu, the use of the control key to display decompilation without temps and the use of the shift key to display decompilation can be replaced with a single modifier key in the 'show decompiled' code holder views.This avoids the surprising and mystifying behavior upon accidentally accepting a method with Ctrl-Alt-S, which can on some platforms display a decompiled method with no temp names.This change set:* removes sensitivity to Ctrl and Shift keys in all but the 'show decompiled' mode of the various browsers* factors all of the decompilation display logic into a single method* retains backwards compatibility with other browsers* makes the 'what to show' menu also work in MVC (so as not to lose the ability to display decompiled methods in the MVC environment)* makes the display of decompiled code *without* temp names be the only special key sequence: if you're already displaying decompiled methods and hold the shift down when you select a method, you will see the decompilation without the temp names."!!CodeHolder methodsFor: 'what to show' stamp: 'nk 6/19/2004 16:59'!addContentsTogglesTo: aMenu 	"Add updating menu toggles governing contents to aMenu."	self contentsSymbolQuints		do: [:aQuint | aQuint == #-				ifTrue: [aMenu addLine]				ifFalse: [Smalltalk isMorphic						ifTrue: [aMenu								addUpdating: aQuint third								target: self								action: aQuint second.							aMenu balloonTextForLastItem: aQuint fifth]						ifFalse: [aMenu								add: (('<yes>*' match: (self perform: aQuint third)) ifTrue: ['*'] ifFalse: ['']), aQuint fourth								target: self								selector: #contentsSymbol: 								argumentList: { aQuint first } ]]]! !!CodeHolder methodsFor: 'what to show' stamp: 'nk 6/19/2004 16:29'!offerWhatToShowMenu	"Offer a menu governing what to show"	| aMenu |	Smalltalk isMorphic		ifTrue: [aMenu := MenuMorph new defaultTarget: self.			aMenu addTitle: 'What to show'.			aMenu addStayUpItem.			self addContentsTogglesTo: aMenu.			aMenu popUpInWorld]		ifFalse: [aMenu := CustomMenu new.			self addContentsTogglesTo: aMenu.			aMenu title: 'What to show' translated.			aMenu invokeOn: self.			self changed: #contents ]! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50'!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:41'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:46'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	contents ifNotNil: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ contents _ (self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class! !!Browser methodsFor: 'message list' stamp: 'nk 6/19/2004 16:44'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ contents _ (self showingDocumentation		ifFalse: [ self sourceStringPrettifiedAndDiffed ]		ifTrue: [ self commentContents ])			copy asText makeSelectorBoldIn: class! !!MessageSet methodsFor: 'contents' stamp: 'nk 6/19/2004 16:47'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'Class vanished'].		selector first isUppercase ifTrue:			[selector == #Comment ifTrue:				[currentCompiledMethod _ class organization commentRemoteStr.				^ class comment].			selector == #Definition ifTrue:				[^ class definitionST80: Preferences printAlternateSyntax not].			selector == #Hierarchy ifTrue: [^ class printHierarchy]].		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		self showingDecompile ifTrue:			[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue:			[^ self commentContents].	source _ self sourceStringPrettifiedAndDiffed.	^ source asText makeSelectorBoldIn: class]! !!Lexicon methodsFor: 'selection' stamp: 'nk 6/19/2004 16:46'!selectedMessage	"Answer the source method for the currently selected message."	(categoryList notNil and: [(categoryListIndex isNil or: [categoryListIndex == 0])])		ifTrue:			[^ '---'].	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'here would go the documentation for the protocol category, if any.'].		self showingDecompile ifTrue:			[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].		self showingDocumentation ifTrue:			[^ self commentContents].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		^ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: class]! !!MethodHolder methodsFor: 'contents' stamp: 'nk 6/19/2004 16:47'!contents	"Answer the contents, with due respect for my contentsSymbol"	contents _ methodClass sourceCodeAt: methodSelector ifAbsent: [''].	currentCompiledMethod _ methodClass compiledMethodAt: methodSelector ifAbsent: [nil].	self showingDecompile ifTrue:			[^ self decompiledSourceIntoContentsWithTempNames: Sensor leftShiftDown not ].	self showingDocumentation ifTrue:		[^ self commentContents].	^ contents _ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: methodClass! !